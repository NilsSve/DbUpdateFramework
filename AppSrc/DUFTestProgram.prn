Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74835>>>>>    End_Procedure
74836>>>>>
74836>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74839>>>>>        Boolean bVisible
74839>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74840>>>>>        Function_Return (bVisible)
74841>>>>>    End_Function
74842>>>>>
74842>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74842>>>>>    // objects defined within this instance of the status panel.
74842>>>>>
74842>>>>>    // note: all of the messages that change text should be forwarded
74842>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74842>>>>>
74842>>>>>    Procedure Set Message_Text String sText
74845>>>>>        Set Label of oMessageTxt to sText
74846>>>>>        Forward Set Message_Text to sText
74848>>>>>    End_Procedure
74849>>>>>
74849>>>>>    Function Message_Text Returns String
74852>>>>>        Function_Return (Label(oMessageTxt))
74853>>>>>    End_Function
74854>>>>>
74854>>>>>    Procedure Set Action_Text String sText
74857>>>>>        Set Label of oActionTxt to sText
74858>>>>>        Forward Set Action_Text to sText
74860>>>>>    End_Procedure
74861>>>>>
74861>>>>>    Function Action_Text Returns String
74864>>>>>        Function_Return (Label(oActionTxt))
74865>>>>>    End_Function
74866>>>>>
74866>>>>>    Procedure Set Button_Text String sText
74869>>>>>        Set Label of oStopButton to sText
74870>>>>>        Forward Set Button_Text to sText
74872>>>>>    End_Procedure
74873>>>>>
74873>>>>>    Function Button_Text Returns String
74876>>>>>        Function_Return (Label(oStopButton))
74877>>>>>    End_Function
74878>>>>>
74878>>>>>    Procedure Set Title_Text String sText
74881>>>>>        Set Label of oTitleTxt to sText
74882>>>>>        Forward Set Title_Text to sText
74884>>>>>    End_Procedure
74885>>>>>
74885>>>>>    Function Title_Text Returns String
74888>>>>>        Function_Return (Label(oTitleTxt))
74889>>>>>    End_Function
74890>>>>>
74890>>>>>    Procedure Set TableName_Text String sText
74893>>>>>        Set Label of oTableNameTxt to sText
74894>>>>>    End_Procedure
74895>>>>>
74895>>>>>    Function TableName_Text Returns String
74898>>>>>        Function_Return (Label(oTableNameTxt))
74899>>>>>    End_Function
74900>>>>>
74900>>>>>    Procedure Set License_Text String sText
74903>>>>>//        Set Label of oLicense_txt to sText
74903>>>>>    End_Procedure
74904>>>>>
74904>>>>>    // gets called when status panel is activated passing whether a button
74904>>>>>    // should appear
74904>>>>>    Procedure EnableCancelButton Boolean bEnable
74907>>>>>        Boolean bVisible
74907>>>>>        Get Cancel_Button_Visible_State to bVisible
74908>>>>>        If (bEnable = False) Begin
74910>>>>>            Set Visible_State of oStopButton to bVisible
74911>>>>>        End
74911>>>>>>
74911>>>>>        Set Enabled_State of oStopButton to bEnable
74912>>>>>    End_Procedure
74913>>>>>
74913>>>>>    Procedure Reset_StatusPanel
74916>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74917>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74918>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74919>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74920>>>>>    End_Procedure
74921>>>>>
74921>>>>>//    Object oProgressBar is a cProgressBar
74921>>>>>//        Move Self to ghoProgressBar
74921>>>>>//        Set Location to 1 25
74921>>>>>//        Set Size to 9 173
74921>>>>>//        Set piMinimum        to 0
74921>>>>>//        Set piMaximum        to 2000
74921>>>>>//        Set piAdvanceBy      to 100
74921>>>>>//        Set pbSmooth to True
74921>>>>>//
74921>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74921>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74921>>>>>//        // color will show correctly.
74921>>>>>//        Procedure Page Integer iPageObject
74921>>>>>//            Handle hWin
74921>>>>>//            Forward Send Page iPageObject
74921>>>>>//            If (ghoSkinFramework <> 0) Begin
74921>>>>>//                Get Window_Handle to hWin
74921>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74921>>>>>//            End
74921>>>>>//        End_Procedure
74921>>>>>//    End_Object
74921>>>>>
74921>>>>>End_Object
74922>>>>>
74922>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74922>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74922>>>>>//
74922>>>>>Use VdfBase.pkg
74922>>>>>Use cApplication.pkg
74922>>>>>Use seq_chnl.pkg
74922>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.pkg)
74922>>>>>>>// This code is part of VDF GUIdance
74922>>>>>>>// Visit us @ http://www.vdf-guidance.com
74922>>>>>>>// e-Mail us @ info@vdf-guidance.com
74922>>>>>>>// VDF GUIdance is a mutual project of
74922>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74922>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74922>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74922>>>>>>>//
74922>>>>>>>//
74922>>>>>>>// *** Windows 32bit file handling wrapper class ***
74922>>>>>>>//
74922>>>>>>>
74922>>>>>>>
74922>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74922>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>//*
74922>>>>>>>>>//* Class:        cvSaveAsDialog
74922>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74922>>>>>>>>>//*
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>
74922>>>>>>>>>Use File_dlg.pkg
74922>>>>>>>>>
74922>>>>>>>>>// *WvA: 13-01-1999 Created
74922>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74922>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74922>>>>>>>>>// file_name.
74922>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74923>>>>>>>>>
74923>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74925>>>>>>>>>        Forward Send Construct_Object iImage_Id
74927>>>>>>>>>        Set HideReadOnly_State to True
74928>>>>>>>>>    End_Procedure
74929>>>>>>>>>
74929>>>>>>>>>    Function SelectedFileName Returns String
74931>>>>>>>>>        String sFileName
74931>>>>>>>>>        Move "" to sFileName
74932>>>>>>>>>        If (Show_Dialog(Self)) Begin
74934>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74935>>>>>>>>>        End
74935>>>>>>>>>>
74935>>>>>>>>>        Function_Return sFileName
74936>>>>>>>>>    End_Function
74937>>>>>>>>>End_Class
74938>>>>>>>>>
74938>>>>>>>>>// *WvA: 13-01-1999 Created
74938>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74938>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74938>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74938>>>>>>>>>//                   file-open dialog
74938>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74940>>>>>>>>>    String sSelectedFile
74940>>>>>>>>>    Integer hoOpenFileDialog
74940>>>>>>>>>
74940>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74942>>>>>>>>>
74942>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74943>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74944>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74945>>>>>>>>>
74945>>>>>>>>>        Move Self       to hoOpenFileDialog
74946>>>>>>>>>    End_Object
74947>>>>>>>>>
74947>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74948>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74949>>>>>>>>>    Function_Return sSelectedFile
74950>>>>>>>>>End_Function
74951>>>>>>>>>
74951>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74952>>>>>>>>>
74952>>>>>>>>>    Procedure Construct_Object
74954>>>>>>>>>        Forward Send Construct_Object
74956>>>>>>>>>        Set HideReadOnly_State to True
74957>>>>>>>>>    End_Procedure
74958>>>>>>>>>
74958>>>>>>>>>    Function SelectedFileName Returns String
74960>>>>>>>>>        String sFileName
74960>>>>>>>>>        Move "" to sFileName
74961>>>>>>>>>        If (Show_Dialog(Self)) Begin
74963>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74964>>>>>>>>>        End
74964>>>>>>>>>>
74964>>>>>>>>>        Function_Return sFileName
74965>>>>>>>>>    End_Function
74966>>>>>>>>>
74966>>>>>>>>>End_Class
74967>>>>>>>>>
74967>>>>>>>>>// Added optional default filename as suggested by Nils
74967>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74969>>>>>>>>>    String sSelectedFile
74969>>>>>>>>>    Integer hoDialog
74969>>>>>>>>>
74969>>>>>>>>>    Move "" to sSelectedFile
74970>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74971>>>>>>>>>    If (hoDialog) Begin
74973>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74973>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74974>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74975>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74976>>>>>>>>>        If (Num_Arguments = 4) Begin
74978>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74979>>>>>>>>>        End
74979>>>>>>>>>>
74979>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74980>>>>>>>>>        Send Destroy of hoDialog
74981>>>>>>>>>    End
74981>>>>>>>>>>
74981>>>>>>>>>    Function_Return sSelectedFile
74982>>>>>>>>>End_Function
74983>>>>>>>Use Seq_chnl.pkg
74983>>>>>>>
74983>>>>>>>Use windows.pkg
74983>>>>>>>Use Dll.pkg
74983>>>>>>>
74983>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
74983>>>>>>>>>// This code is part of VDF GUIdance
74983>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74983>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74983>>>>>>>>>// VDF GUIdance is a mutual project of
74983>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74983>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74983>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74983>>>>>>>>>//
74983>>>>>>>>>//
74983>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74983>>>>>>>>>// Unicode variant
74983>>>>>>>>>
74983>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
74983>>>>>>>>>>>//TH-Header
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74983>>>>>>>>>>>// All rights reserved.
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74983>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74983>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74983>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74983>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// Contents:
74983>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74983>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>//TH-RevisionStart
74983>>>>>>>>>>>//TH-RevisionEnd
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vMax_Path     For |CI260
74983>>>>>>>>>>>Define vMinChar      For |CI$80
74983>>>>>>>>>>>Define vMaxChar      For |CI$7F
74983>>>>>>>>>>>Define vMinShort     For |CI$8000
74983>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74983>>>>>>>>>>>Define vMinLong      For |CI$80000000
74983>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74983>>>>>>>>>>>Define vMaxByte      For |CI$FF
74983>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74983>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// For FindFirstFile
74983>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74983>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74983>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74983>>>>>>>>>>>
74983>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74983>>>>>>>>>>>// the API-call ShellExecute is used.
74983>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74983>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74983>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74983>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74983>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74983>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74983>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74983>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74983>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74983>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74983>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74983>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74983>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74983>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// C-Structure
74983>>>>>>>>>>>//typedef struct _browseinfo {
74983>>>>>>>>>>>//    HWND hwndOwner;
74983>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74983>>>>>>>>>>>//    LPSTR pszDisplayName;
74983>>>>>>>>>>>//    LPCSTR lpszTitle;
74983>>>>>>>>>>>//    UINT ulFlags;
74983>>>>>>>>>>>//    BFFCALLBACK lpfn;
74983>>>>>>>>>>>//    LPARAM lParam;
74983>>>>>>>>>>>//    int iImage;
74983>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74983>>>>>>>>>>>
74983>>>>>>>>>>>//declare C structure struct_browseinfo
74983>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74983>>>>>>>>>>>Struct tvBrowseInfo
74983>>>>>>>>>>>  Handle    hWndOwner
74983>>>>>>>>>>>  Pointer   pIDLRoot
74983>>>>>>>>>>>  Pointer   pszDisplayName
74983>>>>>>>>>>>  Pointer   lpszTitle
74983>>>>>>>>>>>  DWord     ulFlags
74983>>>>>>>>>>>  Pointer   lpfnCallback
74983>>>>>>>>>>>  LongPtr   lParam
74983>>>>>>>>>>>  DWord     iImage
74983>>>>>>>>>>>End_Struct // tvBrowseInfo
74983>>>>>>>>>>>
74983>>>>>>>>>>>// Browsing for directory.
74983>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74983>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74983>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74983>>>>>>>>>>>                                            // The callback function can set the status text by
74983>>>>>>>>>>>                                            // sending messages to the dialog box.
74983>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74983>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74983>>>>>>>>>>>
74983>>>>>>>>>>>// message from browser
74983>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74983>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74983>>>>>>>>>>>
74983>>>>>>>>>>>// messages to browser
74983>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74983>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74983>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74984>>>>>>>>>>>
74984>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74985>>>>>>>>>>>
74985>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>Struct tvSecurity_attributes
74986>>>>>>>>>>>  DWord   nLength
74986>>>>>>>>>>>  Pointer lpDescriptor
74986>>>>>>>>>>>  Integer bInheritHandle
74986>>>>>>>>>>>End_Struct // tvSecurity_attributes
74986>>>>>>>>>>>
74986>>>>>>>>>>>//nLength:
74986>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74986>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74986>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74986>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74986>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//lpSecurityDescriptor:
74986>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74986>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74986>>>>>>>>>>>// descriptor of the calling process.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//bInheritHandle:
74986>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74986>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>// BOOL CreateDirectory(
74986>>>>>>>>>>>//    LPCTSTR lpPathName,
74986>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74986>>>>>>>>>>>//   );
74986>>>>>>>>>>>//
74986>>>>>>>>>>>// lpPathName
74986>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74986>>>>>>>>>>>//  to be created.
74986>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74986>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74986>>>>>>>>>>>// lpSecurityAttributes
74986>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74986>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74986>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74986>>>>>>>>>>>// Returns:
74986>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74986>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74986>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
74987>>>>>>>>>>>
74987>>>>>>>>>>>
74987>>>>>>>>>>>// lpPathName
74987>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74987>>>>>>>>>>>//  to be removed.
74987>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74987>>>>>>>>>>>// Returns:
74987>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74987>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74987>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74988>>>>>>>>>>>// executable file or a document file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Operation can be one of the following:
74988>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74988>>>>>>>>>>>//            The file can be an executable file or a document file.
74988>>>>>>>>>>>//            The file can be a folder to open.
74988>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74988>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74988>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74988>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Return Values:
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74988>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74988>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// The following table lists these error values:
74988>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74988>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74988>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74988>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74988>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74988>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74988>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74988>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74988>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74988>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
74988>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74988>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
74988>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
74988>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// Code to open the program that is associated with the selected file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// External function call used in Procedure DoStartDocument
74988>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
74989>>>>>>>>>>>Define vFO_COPY                For |CI$0002
74989>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
74989>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74989>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74989>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74989>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74989>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74989>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74989>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74989>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74989>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74989>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74989>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74989>>>>>>>>>>>
74989>>>>>>>>>>>Struct tvShFileOpStruct
74989>>>>>>>>>>>  Handle   hWnd
74989>>>>>>>>>>>  UInteger wFunc
74989>>>>>>>>>>>  Pointer  pFrom
74989>>>>>>>>>>>  Pointer  pTo
74989>>>>>>>>>>>  Short    fFlags
74989>>>>>>>>>>>  Integer  fAnyOperationsAborted
74989>>>>>>>>>>>  Pointer  hNameMappings
74989>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74989>>>>>>>>>>>End_Struct // tvShFileOpStruct
74989>>>>>>>>>>>
74989>>>>>>>>>>>// hwnd
74989>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// wFunc
74989>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74989>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74989>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pFrom
74989>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74989>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pTo
74989>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74989>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74989>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74989>>>>>>>>>>>//   double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// fAnyOperationsAborted
74989>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74989>>>>>>>>>>>//   were completed or FALSE otherwise.
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74989>>>>>>>>>>>// This can be a file or a folder.
74989>>>>>>>>>>>// With thanks to Andrew S Kaplan
74989>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
74990>>>>>>>>>>>
74990>>>>>>>>>>>
74990>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74990>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74991>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74991>>>>>>>>>>>//   Pointer lpPathName ;
74991>>>>>>>>>>>//   Pointer lpPrefixString ;
74991>>>>>>>>>>>//   Integer uUnique ;
74991>>>>>>>>>>>//   Pointer lpTempFileName ;
74991>>>>>>>>>>>//   Returns Integer
74991>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74991>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
74992>>>>>>>>>>>
74992>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74993>>>>>>>>>>>
74993>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
74994>>>>>>>>>>>
74994>>>>>>>>>>>// from:
74994>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74994>>>>>>>>>>>//
74994>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74994>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74994>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74994>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74994>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74994>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74994>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74994>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74994>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74994>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74994>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74994>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74994>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74994>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74994>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74994>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74994>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74994>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74994>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74994>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74994>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74994>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74994>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74994>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74994>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74994>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74994>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74994>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74994>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74994>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74994>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74994>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74994>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74994>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74994>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74994>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74994>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74994>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74994>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74994>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74994>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74994>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74994>>>>>>>>>>>
74994>>>>>>>>>>>
74994>>>>>>>>>>>//HRESULT SHGetFolderPath(
74994>>>>>>>>>>>//    HWND hwndOwner,
74994>>>>>>>>>>>//    int nFolder,
74994>>>>>>>>>>>//    HANDLE hToken,
74994>>>>>>>>>>>//    DWORD dwFlags,
74994>>>>>>>>>>>//    LPTSTR pszPath
74994>>>>>>>>>>>//);
74994>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74994>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74994>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74994>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74994>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74994>>>>>>>>>>>//
74994>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>Struct tvWin32FindData
74995>>>>>>>>>>> Dword            dwFileAttributes
74995>>>>>>>>>>> Dword            ftCreationLowDateTime
74995>>>>>>>>>>> Dword            ftCreationHighDateTime
74995>>>>>>>>>>> dword            ftLastAccessLowDateTime
74995>>>>>>>>>>> Dword            ftLastAccessHighDateTime
74995>>>>>>>>>>> Dword            ftLastWriteLowDateTime
74995>>>>>>>>>>> Dword            ftLastWriteHighDateTime
74995>>>>>>>>>>> Dword            nFileSizeHigh
74995>>>>>>>>>>> Dword            nFileSizeLow
74995>>>>>>>>>>> Dword            dwReserved0
74995>>>>>>>>>>> Dword            dwReserved1
74995>>>>>>>>>>> Short[vMax_Path] cFileName
74995>>>>>>>>>>> Short[14]        cAlternateFileName
74995>>>>>>>>>>>End_Struct
74995>>>>>>>>>>>
74995>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74995>>>>>>>>>>>// lpFileName      : address of name of file to search for
74995>>>>>>>>>>>// lpFindFileData  : address of returned information
74995>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
74996>>>>>>>>>>>
74996>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74996>>>>>>>>>>>// hFindFile       : handle of search
74996>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74996>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74997>>>>>>>>>>>
74997>>>>>>>>>>>
74997>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74997>>>>>>>>>>>//  hFindFile      : file search handle
74997>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvFileTime
74998>>>>>>>>>>>  DWord dwLowDateTime
74998>>>>>>>>>>>  DWord dwHighDateTime
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvSystemTime
74998>>>>>>>>>>>  UShort wYear
74998>>>>>>>>>>>  UShort wMonth
74998>>>>>>>>>>>  UShort wDayOfWeek
74998>>>>>>>>>>>  UShort wDay
74998>>>>>>>>>>>  UShort wHour
74998>>>>>>>>>>>  UShort wMinute
74998>>>>>>>>>>>  UShort wSecond
74998>>>>>>>>>>>  UShort wMilliSeconds
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74998>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74998>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74998>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74999>>>>>>>>>>>
74999>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74999>>>>>>>>>>>// This function formats the time in a picture-string passed
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// Picture      Meaning
74999>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74999>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74999>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74999>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74999>>>>>>>>>>>//    t         One character time marker string, such as A or P
74999>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74999>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74999>>>>>>>>>>>
74999>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75000>>>>>>>>>>>
75000>>>>>>>>>>>
75000>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75000>>>>>>>>>>>// This function formats the date in a picture-string passed
75000>>>>>>>>>>>//
75000>>>>>>>>>>>// Picture      Meaning
75000>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75000>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75000>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75000>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75000>>>>>>>>>>>//              value associated with the specified locale.
75000>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75000>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75000>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75000>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75000>>>>>>>>>>>//              associated with the specified locale.
75000>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75000>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75000>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75000>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75000>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75000>>>>>>>>>>>//              does not have an associated era or period string.
75000>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75000>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75000>>>>>>>>>>>
75000>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75001>>>>>>>>>>>
75001>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75001>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75001>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75001>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75001>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75001>>>>>>>>>>>
75001>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75001>>>>>>>>>>>//
75001>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75001>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75001>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75001>>>>>>>>>>>
75001>>>>>>>>>>>
75001>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>// **WvA: 20-02-2004
75002>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75002>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75002>>>>>>>>>>>// incorrectly into an unsigned integer.
75002>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75002>>>>>>>>>>>// It does smell a bit fishy though
75002>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75002>>>>>>>>>>>
75002>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75002>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75002>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75002>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75002>>>>>>>>>>>
75002>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75002>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75002>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75002>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>> // Courtesy Of Steve Walter,
75002>>>>>>>>>>> // USA Software, Inc
75002>>>>>>>>>>> // Format a disk
75002>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75002>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75003>>>>>>>>>>>
75003>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75003>>>>>>>>>>>
75003>>>>>>>>>>>// SHCreateDirectoryEx
75003>>>>>>>>>>>
75003>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75003>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75003>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75003>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75003>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75003>>>>>>>>>>>//        ERROR_CANCELLED.
75003>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75003>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75003>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75003>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75003>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75003>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75003>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75003>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        int SHCreateDirectoryEx(
75003>>>>>>>>>>>//            HWND hwnd,
75003>>>>>>>>>>>//            LPCTSTR pszPath,
75003>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75003>>>>>>>>>>>//        );
75003>>>>>>>>>>>
75003>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75004>>>>>>>>>>>
75004>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75005>>>>>>>>>// This also works with UNC path encoding and wildcards
75005>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75007>>>>>>>>>    Boolean bFolderExists
75007>>>>>>>>>    Boolean bStop
75007>>>>>>>>>    String  sFolder sTmp
75007>>>>>>>>>    Integer iCh
75007>>>>>>>>>
75007>>>>>>>>>    If (sFolderName = "") Begin
75009>>>>>>>>>        Function_Return False
75010>>>>>>>>>    End
75010>>>>>>>>>>
75010>>>>>>>>>
75010>>>>>>>>>    Move True  to bFolderExists
75011>>>>>>>>>    Move False to bStop
75012>>>>>>>>>    Move "dir:" to sFolder
75013>>>>>>>>>    Append sFolder sFolderName
75014>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75015>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75017>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75018>>>>>>>>>>
75018>>>>>>>>>        Function_Return False
75019>>>>>>>>>    End
75019>>>>>>>>>>
75019>>>>>>>>>    Direct_Input channel iCh sFolder
75021>>>>>>>>>    Repeat
75021>>>>>>>>>>
75021>>>>>>>>>        Readln channel iCh sTmp
75023>>>>>>>>>        Move (SeqEof) to bStop
75024>>>>>>>>>        If (Trim(sTmp)="") Begin
75026>>>>>>>>>            Move False to bFolderExists
75027>>>>>>>>>        End
75027>>>>>>>>>>
75027>>>>>>>>>        Else Begin
75028>>>>>>>>>            Move True to bFolderExists
75029>>>>>>>>>            Move True to bStop
75030>>>>>>>>>        End
75030>>>>>>>>>>
75030>>>>>>>>>    Until (bStop)
75032>>>>>>>>>    Close_Input channel iCh
75034>>>>>>>>>    Send Seq_Release_Channel iCh
75035>>>>>>>>>    Function_Return bFolderExists
75036>>>>>>>>>End_Function
75037>>>>>>>>>
75037>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75037>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75039>>>>>>>>>    String  sPath
75039>>>>>>>>>    WString sFolder sTitle
75039>>>>>>>>>    Pointer lpItemIdList
75039>>>>>>>>>    Integer iFolderSelected iRetval
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>
75039>>>>>>>>>    Move "" to sPath
75040>>>>>>>>>    If (sDialogTitle<>"") Begin
75042>>>>>>>>>        Move sDialogTitle to sTitle
75043>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75043>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75043>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75043>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75043>>>>>>>>>        // selected it will always be valid.
75043>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75044>>>>>>>>>    End
75044>>>>>>>>>>
75044>>>>>>>>>
75044>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75045>>>>>>>>>
75045>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75045>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75045>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75046>>>>>>>>>
75046>>>>>>>>>    // null 128 chars into var (make space)
75046>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75047>>>>>>>>>
75047>>>>>>>>>    // select folder
75047>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75048>>>>>>>>>    // get selected folder name
75048>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75049>>>>>>>>>
75049>>>>>>>>>    // release memory resources that are used by the ItemIdList
75049>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75050>>>>>>>>>
75050>>>>>>>>>    If (iFolderSelected<>0) Begin
75052>>>>>>>>>        Move (CString(sFolder)) to sPath
75053>>>>>>>>>    End
75053>>>>>>>>>>
75053>>>>>>>>>    Function_Return  sPath
75054>>>>>>>>>End_Function
75055>>>>>>>>>
75055>>>>>>>>>// returns 0 if the folder is created.
75055>>>>>>>>>//         1 if the API-call returned an error.
75055>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75057>>>>>>>>>    Integer  iRetval bFolderCreated
75057>>>>>>>>>    WString  sFolder
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>
75057>>>>>>>>>    Move False to bFolderCreated
75058>>>>>>>>>    If (sNewFolder <> "") Begin
75060>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75061>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75062>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75063>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75064>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75065>>>>>>>>>    End
75065>>>>>>>>>>
75065>>>>>>>>>
75065>>>>>>>>>    If (bFolderCreated=false) Begin
75067>>>>>>>>>        Move 1 to iRetVal
75068>>>>>>>>>    End
75068>>>>>>>>>>
75068>>>>>>>>>    Function_Return iRetVal
75069>>>>>>>>>End_Function
75070>>>>>>>>>
75070>>>>>>>>>// **WvA: 03-02-2002 Function created.
75070>>>>>>>>>// With this function one can remove a directory.
75070>>>>>>>>>// returns 0 if the folder is removed.
75070>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75070>>>>>>>>>//         2 if the folder did not exist
75070>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75070>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75072>>>>>>>>>    Boolean bRemoved
75072>>>>>>>>>    WString sPath
75072>>>>>>>>>    Integer iRetval
75072>>>>>>>>>
75072>>>>>>>>>    Move 0     to iRetVal
75073>>>>>>>>>    Move False to bRemoved
75074>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75075>>>>>>>>>    If (sFolder="") Begin
75077>>>>>>>>>        Move 3 to iRetVal
75078>>>>>>>>>    End
75078>>>>>>>>>>
75078>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75080>>>>>>>>>        Move 2 to iRetVal
75081>>>>>>>>>    End
75081>>>>>>>>>>
75081>>>>>>>>>    If (iRetVal=0) Begin
75083>>>>>>>>>        // null MAX_PATH chars into var (make space)
75083>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75084>>>>>>>>>        //
75084>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75085>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75086>>>>>>>>>    End
75086>>>>>>>>>>
75086>>>>>>>>>
75086>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75088>>>>>>>>>        Move 1 to iRetVal
75089>>>>>>>>>    End
75089>>>>>>>>>>
75089>>>>>>>>>    Function_Return iRetVal
75090>>>>>>>>>End_Function
75091>>>>>>>>>
75091>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75091>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75091>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75091>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75093>>>>>>>>>    Handle  hInstance hWnd
75093>>>>>>>>>    // remove any leading/trailing spaces in the string
75093>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75094>>>>>>>>>    Move (Trim(sPath))     to sPath
75095>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75095>>>>>>>>>    Append sOperation   (Character(0))
75096>>>>>>>>>    Append sDocument    (Character(0))
75097>>>>>>>>>    Append sParameters  (Character(0))
75098>>>>>>>>>    Append sPath        (Character(0))
75099>>>>>>>>>
75099>>>>>>>>>    Get Window_Handle to hWnd
75100>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75101>>>>>>>>>    If (hInstance <= 32) Begin
75103>>>>>>>>>        Send vDDE_Error_Handler hInstance
75104>>>>>>>>>    End
75104>>>>>>>>>>
75104>>>>>>>>>End_Procedure
75105>>>>>>>>>
75105>>>>>>>>>Class cShellFileOperations is a Array
75106>>>>>>>>>
75106>>>>>>>>>    Procedure Construct_Object
75108>>>>>>>>>        Forward Send Construct_Object
75110>>>>>>>>>        Property Integer piDeleteFlags        0
75111>>>>>>>>>        Property Integer piCopyFlags          0
75112>>>>>>>>>        Property Integer piMoveFlags          0
75113>>>>>>>>>        Property Integer piRenameFlags        0
75114>>>>>>>>>
75114>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75115>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75116>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75117>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75118>>>>>>>>>    End_Procedure
75119>>>>>>>>>
75119>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75119>>>>>>>>>    // files supplied.
75119>>>>>>>>>    //
75119>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75121>>>>>>>>>        Integer  iRetVal
75121>>>>>>>>>        Integer  iUserAbort
75121>>>>>>>>>        WString  wsSource wsDestination
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>
75121>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75122>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75123>>>>>>>>>
75123>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75125>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75126>>>>>>>>>        End
75126>>>>>>>>>>
75126>>>>>>>>>
75126>>>>>>>>>        Move eOperation            to FOS.wFunc
75127>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75128>>>>>>>>>        Move iFlags                to FOS.fFlags
75129>>>>>>>>>
75129>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75130>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75131>>>>>>>>>        If (iUserAbort <> 0) Begin
75133>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75134>>>>>>>>>        End
75134>>>>>>>>>>
75134>>>>>>>>>        Function_Return (iRetVal)
75135>>>>>>>>>    End_Function
75136>>>>>>>>>
75136>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75138>>>>>>>>>        Integer  iRetVal
75138>>>>>>>>>        Integer  iFlags
75138>>>>>>>>>
75138>>>>>>>>>        Get piDeleteFlags to iFlags
75139>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75140>>>>>>>>>        Function_Return iRetVal
75141>>>>>>>>>    End_Function
75142>>>>>>>>>
75142>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75144>>>>>>>>>        Integer  iRetVal
75144>>>>>>>>>        Integer  iFlags
75144>>>>>>>>>
75144>>>>>>>>>        Get piCopyFlags to iFlags
75145>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75146>>>>>>>>>        Function_Return iRetVal
75147>>>>>>>>>    End_Function
75148>>>>>>>>>
75148>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75150>>>>>>>>>        Integer  iRetVal
75150>>>>>>>>>        Integer  iFlags
75150>>>>>>>>>
75150>>>>>>>>>        Get piMoveFlags to iFlags
75151>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75152>>>>>>>>>        Function_Return iRetVal
75153>>>>>>>>>    End_Function
75154>>>>>>>>>
75154>>>>>>>>>    // Rename a file or folder
75154>>>>>>>>>    // Returns a nonzero value if the operation failed.
75154>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75156>>>>>>>>>        Integer  iRetVal
75156>>>>>>>>>        Integer  iFlags
75156>>>>>>>>>
75156>>>>>>>>>        Get piRenameFlags to iFlags
75157>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75158>>>>>>>>>        Function_Return iRetVal
75159>>>>>>>>>    End_Function
75160>>>>>>>>>
75160>>>>>>>>>
75160>>>>>>>>>    //Example:
75160>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75160>>>>>>>>>    //                                          mode.
75160>>>>>>>>>
75160>>>>>>>>>End_Class
75161>>>>>>>>>
75161>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75163>>>>>>>>>End_Object
75164>>>>>>>>>
75164>>>>>>>>>// Restore to the old way of working with the shell file operations.
75164>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75164>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75164>>>>>>>>>Procedure vWin32fhCompatibilityMode
75166>>>>>>>>>    Integer hoSFO
75166>>>>>>>>>    Integer iFlags
75166>>>>>>>>>
75166>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75167>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75168>>>>>>>>>
75168>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75169>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75170>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75171>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75172>>>>>>>>>End_Procedure
75173>>>>>>>>>
75173>>>>>>>>>// Delete a file or folder
75173>>>>>>>>>// Returns a nonzero value if the operation failed.
75173>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75175>>>>>>>>>    Integer  iRetVal
75175>>>>>>>>>
75175>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75176>>>>>>>>>    Function_Return iRetVal
75177>>>>>>>>>End_Function
75178>>>>>>>>>
75178>>>>>>>>>// Copy a file or folder
75178>>>>>>>>>// Returns a nonzero value if the operation failed.
75178>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75180>>>>>>>>>    Integer  iRetVal
75180>>>>>>>>>
75180>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75181>>>>>>>>>    Function_Return iRetVal
75182>>>>>>>>>End_Function
75183>>>>>>>>>
75183>>>>>>>>>// Move a file or folder
75183>>>>>>>>>// Returns a nonzero value if the operation failed.
75183>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75185>>>>>>>>>    Integer  iRetVal
75185>>>>>>>>>
75185>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75186>>>>>>>>>    Function_Return iRetVal
75187>>>>>>>>>End_Function
75188>>>>>>>>>
75188>>>>>>>>>// Rename a file or folder
75188>>>>>>>>>// Returns a nonzero value if the operation failed.
75188>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75190>>>>>>>>>    Integer  iRetVal
75190>>>>>>>>>
75190>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75191>>>>>>>>>    Function_Return iRetVal
75192>>>>>>>>>End_Function
75193>>>>>>>>>
75193>>>>>>>>>Function vGetWindowsDirectory Returns String
75195>>>>>>>>>    WString wDirectory
75195>>>>>>>>>    Integer iRetVal
75195>>>>>>>>>
75195>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75196>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75197>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75199>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75200>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75201>>>>>>>>>    End
75201>>>>>>>>>>
75201>>>>>>>>>    Function_Return (CString(wDirectory))
75202>>>>>>>>>End_Function
75203>>>>>>>>>
75203>>>>>>>>>Function vGetTempPath Returns String
75205>>>>>>>>>    Integer iRetVal
75205>>>>>>>>>    WString wTempPath
75205>>>>>>>>>
75205>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75206>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75207>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75209>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75210>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75211>>>>>>>>>    End
75211>>>>>>>>>>
75211>>>>>>>>>    Function_Return (CString(wTempPath))
75212>>>>>>>>>End_Function
75213>>>>>>>>>
75213>>>>>>>>>// Courtesy of Marco Kuipers
75213>>>>>>>>>Function vMakeTempFile Returns String
75215>>>>>>>>>    Integer iRetval
75215>>>>>>>>>    String  sTempPath
75215>>>>>>>>>    String  sTempFileName
75215>>>>>>>>>    String  sPrefixString
75215>>>>>>>>>    WString wsTempFileName
75215>>>>>>>>>
75215>>>>>>>>>    Get vGetTempPath to sTempPath
75216>>>>>>>>>    If (sTempPath = "") Begin
75218>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75219>>>>>>>>>        If (sTempPath<>"") Begin
75221>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75222>>>>>>>>>        End
75222>>>>>>>>>>
75222>>>>>>>>>    End
75222>>>>>>>>>>
75222>>>>>>>>>
75222>>>>>>>>>    If (sTempPath = "") Begin
75224>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75224>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75224>>>>>>>>>        Get_Current_Directory to sTempPath
75225>>>>>>>>>    End
75225>>>>>>>>>>
75225>>>>>>>>>
75225>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75226>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75228>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75229>>>>>>>>>>
75229>>>>>>>>>    End
75229>>>>>>>>>>
75229>>>>>>>>>
75229>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75230>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75231>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75232>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75234>>>>>>>>>    //Get ShowLastError to iRetval
75234>>>>>>>>>        Move "" to sTempFileName
75235>>>>>>>>>    End
75235>>>>>>>>>>
75235>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75236>>>>>>>>>    Function_Return sTempFileName
75237>>>>>>>>>End_Function
75238>>>>>>>>>
75238>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75238>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75238>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75238>>>>>>>>>// does not take care of that.
75238>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75240>>>>>>>>>    Integer iRetVal
75240>>>>>>>>>    String  sTempFileName
75240>>>>>>>>>    WString wTempFileName
75240>>>>>>>>>
75240>>>>>>>>>    Move (sPath+Character(0))   to sPath
75241>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75242>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75243>>>>>>>>>
75243>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75244>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75245>>>>>>>>>    Function_Return sTempFileName
75246>>>>>>>>>End_Function
75247>>>>>>>>>
75247>>>>>>>>>//
75247>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75247>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75247>>>>>>>>>//
75247>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75249>>>>>>>>>    Integer iVoid
75249>>>>>>>>>    Handle  hWnd
75249>>>>>>>>>    String  sFolder
75249>>>>>>>>>    WString wFolder
75249>>>>>>>>>
75249>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75250>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75251>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75252>>>>>>>>>    Move (CString(wFolder)) to sFolder
75253>>>>>>>>>    Function_Return sFolder
75254>>>>>>>>>End_Function
75255>>>>>>>>>
75255>>>>>>>>>// Courtesy Of Vincent Oorsprong
75255>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75257>>>>>>>>>    String  sFileDateTime
75257>>>>>>>>>    WString wFormattedTime wFormattedDate
75257>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>
75257>>>>>>>>>    Move "" to sFileDateTime
75258>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75259>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75260>>>>>>>>>
75260>>>>>>>>>    Move 0 to SystemTime.wYear
75261>>>>>>>>>
75261>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75262>>>>>>>>>    If (iSuccess = 1) Begin
75264>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75265>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75266>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75267>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75268>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75269>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75270>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75271>>>>>>>>>    End
75271>>>>>>>>>>
75271>>>>>>>>>    Function_Return sFileDateTime
75272>>>>>>>>>End_Function
75273>>>>>>>>>
75273>>>>>>>>>// **WvA:
75273>>>>>>>>>// A windows replacement for the standard function FileExists.
75273>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75273>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75273>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75273>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75273>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75275>>>>>>>>>    String  sDirSep
75275>>>>>>>>>    Handle  hFindFile
75275>>>>>>>>>    Integer iVoid
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>
75275>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75276>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75277>>>>>>>>>
75277>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75279>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75279>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75280>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75284>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75285>>>>>>>>>        Loop
75286>>>>>>>>>>
75286>>>>>>>>>
75286>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75287>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75288>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75289>>>>>>>>>    End
75289>>>>>>>>>>
75289>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75290>>>>>>>>>End_Function
75291>>>>>>>>>
75291>>>>>>>>>
75291>>>>>>>>>//
75291>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75291>>>>>>>>>// Returns -1 if folder doesn't exist.
75291>>>>>>>>>// The files "." and ".." are not counted.
75291>>>>>>>>>//
75291>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75293>>>>>>>>>    Boolean bFound
75293>>>>>>>>>    Handle  hFindFile
75293>>>>>>>>>    Integer iCount  iVoid
75293>>>>>>>>>    Integer iSuccess
75293>>>>>>>>>    String  sFileName
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>
75293>>>>>>>>>    Move -1 to iCount
75294>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75295>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75296>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75297>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75298>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75299>>>>>>>>>    If (bFound) Begin
75301>>>>>>>>>        Move 0 to iCount
75302>>>>>>>>>    End
75302>>>>>>>>>>
75302>>>>>>>>>    While (bFound)
75306>>>>>>>>>        Increment iCount
75307>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75308>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75310>>>>>>>>>            Decrement iCount
75311>>>>>>>>>        End
75311>>>>>>>>>>
75311>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75312>>>>>>>>>        Move (iSuccess<>0) to bFound
75313>>>>>>>>>    Loop
75314>>>>>>>>>>
75314>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75315>>>>>>>>>    Function_Return iCount
75316>>>>>>>>>End_Function
75317>>>>>>>>>
75317>>>>>>>>>// Create the folder, including intermediate directories.
75317>>>>>>>>>// Don't panic if the folder already exists.
75317>>>>>>>>>// Michael Mullan June 2009.
75317>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75319>>>>>>>>>    String  sFolder
75319>>>>>>>>>    Integer iRetval iFolderCreated
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>
75319>>>>>>>>>    Move 0 to iFolderCreated
75320>>>>>>>>>
75320>>>>>>>>>    // null MAX_PATH chars into var (make space)
75320>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75321>>>>>>>>>    If (sNewFolder <> "") Begin
75323>>>>>>>>>
75323>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75324>>>>>>>>>        Move  0  to SA.lpDescriptor
75325>>>>>>>>>        Move  1  to SA.bInheritHandle
75326>>>>>>>>>
75326>>>>>>>>>        //
75326>>>>>>>>>        Move (sNewFolder+"") to sFolder
75327>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75328>>>>>>>>>    End
75328>>>>>>>>>>
75328>>>>>>>>>
75328>>>>>>>>>    If (iFolderCreated <> 0) Begin
75330>>>>>>>>>        Move 1 to iRetVal
75331>>>>>>>>>        Case Begin
75331>>>>>>>>>            Case (iFolderCreated = 161)
75333>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75334>>>>>>>>>>
75334>>>>>>>>>                Case Break
75335>>>>>>>>>            Case (iFolderCreated = 206)
75338>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75339>>>>>>>>>>
75339>>>>>>>>>                Case Break
75340>>>>>>>>>            Case (iFolderCreated = 3)
75343>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75344>>>>>>>>>>
75344>>>>>>>>>                Case Break
75345>>>>>>>>>            Case (iFolderCreated = 80)
75348>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75349>>>>>>>>>                Case Break
75350>>>>>>>>>            Case (iFolderCreated = 183)
75353>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75354>>>>>>>>>                Case Break
75355>>>>>>>>>            Case (iFolderCreated = 1223)
75358>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75359>>>>>>>>>>
75359>>>>>>>>>                Case Break
75360>>>>>>>>>            Case Else
75360>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75361>>>>>>>>>>
75361>>>>>>>>>        Case End
75361>>>>>>>>>    End
75361>>>>>>>>>>
75361>>>>>>>>>    Function_Return iRetVal
75362>>>>>>>>>End_Function
75363>>>>>>>>>
75363>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75365>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75365>>>>>>>>>    Integer iFileSize iVoid
75365>>>>>>>>>    Handle  hFindFile
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>
75365>>>>>>>>>    Move (sFileName+"") to sFileName
75366>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75367>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75368>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75370>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75371>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75372>>>>>>>>>    End
75372>>>>>>>>>>
75372>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75373>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75374>>>>>>>>>
75374>>>>>>>>>    Function_Return iFileSize
75375>>>>>>>>>End_Function
75376>>>>>>>>>
75376>>>>>>>>>//
75376>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75376>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75376>>>>>>>>>//
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>// Verifies that a path is a valid directory.
75376>>>>>>>>>//
75376>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75376>>>>>>>>>//
75376>>>>>>>>>// Parameters:
75376>>>>>>>>>//      sPath - Address of the path to verify.
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75378>>>>>>>>>    Integer iResult
75378>>>>>>>>>    Boolean bRetVal
75378>>>>>>>>>
75378>>>>>>>>>    Move false to bRetVal
75379>>>>>>>>>    Move (sPath - Character (0)) to sPath
75380>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75381>>>>>>>>>    If (iResult<>0) Begin
75383>>>>>>>>>        Move True to bRetVal
75384>>>>>>>>>    End
75384>>>>>>>>>>
75384>>>>>>>>>
75384>>>>>>>>>    Function_Return bRetVal
75385>>>>>>>>>End_Function
75386>>>>>>>>>
75386>>>>>>>
75386>>>>>>>//
75386>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75386>>>>>>>// If sStopChar has no occurences in the string an empty string is
75386>>>>>>>// returned.
75386>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75388>>>>>>>    String  sRetVal
75388>>>>>>>    String  sChar
75388>>>>>>>    Integer iLength
75388>>>>>>>    Integer iPos
75388>>>>>>>    Boolean bStopChar
75388>>>>>>>    Move "" to sRetval
75389>>>>>>>    Move (Length(sFrom)) to iLength
75390>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75392>>>>>>>        Move iLength   to iPos
75393>>>>>>>        Move (False)   to bStopChar
75394>>>>>>>        While Not bStopChar
75398>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75399>>>>>>>            Decrement iPos
75400>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75402>>>>>>>                Move (True) to bStopChar
75403>>>>>>>            End
75403>>>>>>>>
75403>>>>>>>            Else Begin
75404>>>>>>>                Move (sChar+sRetVal) to sRetVal
75405>>>>>>>            End
75405>>>>>>>>
75405>>>>>>>        Loop
75406>>>>>>>>
75406>>>>>>>    End
75406>>>>>>>>
75406>>>>>>>    Function_Return sRetVal
75407>>>>>>>End_Function
75408>>>>>>>
75408>>>>>>>// Pre:  sFileName contains the complete path of the file.
75408>>>>>>>// Post: returns the complete path of the file.
75408>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75408>>>>>>>Function ParseFolderName Global String sFileName Returns String
75410>>>>>>>    String sFile
75410>>>>>>>    String sFolderName
75410>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75410>>>>>>>
75410>>>>>>>    Move "" to sFolderName
75411>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75412>>>>>>>    If sDirSep In sFileName Begin
75414>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75415>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75416>>>>>>>    End
75416>>>>>>>>
75416>>>>>>>    Else If ":" In sFileName Begin
75419>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75420>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75421>>>>>>>    End
75421>>>>>>>>
75421>>>>>>>    Function_Return sFolderName
75422>>>>>>>End_Function
75423>>>>>>>
75423>>>>>>>// Pre:  sFileName contains the complete path of the file.
75423>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75423>>>>>>>Function ParseFileName Global String sFileName Returns String
75425>>>>>>>    String sFolderName
75425>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75425>>>>>>>
75425>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75426>>>>>>>    Get ParseFolderName sFileName to sFolderName
75427>>>>>>>    If (sFolderName <> "") Begin
75429>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75430>>>>>>>    End
75430>>>>>>>>
75430>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75431>>>>>>>    Function_Return sFilename
75432>>>>>>>End_Function
75433>>>>>>>
75433>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75433>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75433>>>>>>>//       return "bak" as the extension and not "gif"
75433>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75433>>>>>>>//       such as "html" or "java"
75433>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75435>>>>>>>    String  sFileExtension
75435>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75436>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75437>>>>>>>    Function_Return sFileExtension
75438>>>>>>>End_Function
75439>>>>>>>
75439>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75439>>>>>>>
75439>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75441>>>>>>>    String sMessage
75441>>>>>>>    Case Begin
75441>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75443>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75444>>>>>>>            Case Break
75445>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75448>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75449>>>>>>>            Case Break
75450>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75453>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75454>>>>>>>            Case Break
75455>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75458>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75459>>>>>>>            Case Break
75460>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75463>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75464>>>>>>>            Case Break
75465>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75468>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75469>>>>>>>            Case Break
75470>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75473>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75474>>>>>>>            Case Break
75475>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75478>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75479>>>>>>>            Case Break
75480>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75483>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75484>>>>>>>            Case Break
75485>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75488>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75489>>>>>>>            Case Break
75490>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75493>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75494>>>>>>>            Case Break
75495>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75498>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75499>>>>>>>            Case Break
75500>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75503>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75504>>>>>>>            Case Break
75505>>>>>>>        Case Else
75505>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75506>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75507>>>>>>>            Case Break
75508>>>>>>>    Case End
75508>>>>>>>    Function_Return sMessage
75509>>>>>>>End_Function
75510>>>>>>>
75510>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75512>>>>>>>    String sMessage
75512>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75513>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75514>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75515>>>>>>>End_Procedure
75516>>>>>>>
75516>>>>>>>
75516>>>>>>>// This function informs the user that he entered a yet unknown folder and
75516>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75516>>>>>>>// Choice: "Yes" - this creates the folder
75516>>>>>>>//                 if successful, the function returns false
75516>>>>>>>//                 else it will be true.
75516>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75516>>>>>>>//                 For example: to stop a save
75516>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75516>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75516>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75518>>>>>>>    Integer bIsNotValid
75518>>>>>>>    Integer iUsers_Choice
75518>>>>>>>    String  sMessage
75518>>>>>>>
75518>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75520>>>>>>>        Move "The folder '" to sMessage
75521>>>>>>>        Append sMessage sFolderName
75522>>>>>>>        Append sMessage "' does not yet exist,\n"
75523>>>>>>>        Append sMessage "Do you want to create it now?"
75524>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75525>>>>>>>        Case Begin
75525>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75527>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75528>>>>>>>                If bIsNotValid Begin
75530>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75531>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75533>>>>>>>                    Send Info_Box sMessage "Info"
75534>>>>>>>                End
75534>>>>>>>>
75534>>>>>>>                Case Break
75535>>>>>>>            Case (iUsers_Choice = MBR_No)
75538>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75539>>>>>>>                Case Break
75540>>>>>>>        Case End
75540>>>>>>>    End
75540>>>>>>>>
75540>>>>>>>    Function_Return bIsNotValid
75541>>>>>>>End_Function
75542>>>>>>>
75542>>>>>>>// **WvA
75542>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75542>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75542>>>>>>>// The folder may contain a drive letter or UNC encoding.
75542>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75544>>>>>>>    String sDirSep
75544>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75545>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75546>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75548>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75549>>>>>>>    End
75549>>>>>>>>
75549>>>>>>>    Function_Return sFolderName
75550>>>>>>>End_Function
75551>>>>>>>
75551>>>>>>>//
75551>>>>>>>// Gets the parent path of the currently supplied path
75551>>>>>>>// Returns "" when we are at the root folder.
75551>>>>>>>//
75551>>>>>>>Function vParentPath Global String sPath Returns String
75553>>>>>>>    String sStrip sDirSep
75553>>>>>>>
75553>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75554>>>>>>>    Move (Trim(sPath)) to sPath
75555>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75557>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75558>>>>>>>    End
75558>>>>>>>>
75558>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75560>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75561>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75562>>>>>>>    End
75562>>>>>>>>
75562>>>>>>>    Else Begin
75563>>>>>>>        Move "" to sPath
75564>>>>>>>    End
75564>>>>>>>>
75564>>>>>>>    Function_Return sPath
75565>>>>>>>End_Function
75566>>>>>Use DUFLanguageConstants.inc
75566>>>>>
75566>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75566>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75566>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75566>>>>>
75566>>>>>Struct tDUFIntFile
75566>>>>>    Integer iID
75566>>>>>    String sIntFileName
75566>>>>>    String sIntLineText
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbVersionInfo
75566>>>>>    Number nVersionNumber
75566>>>>>    Handle hObject
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbUpdateError
75566>>>>>    Number nUpdateVersion
75566>>>>>    Integer iError
75566>>>>>    String  sOrgErrorText
75566>>>>>    String  sErrorText
75566>>>>>    Integer iErrorLine
75566>>>>>    Boolean bError  
75566>>>>>    Handle  hTable 
75566>>>>>    String  sTableRootName
75566>>>>>    Integer iField
75566>>>>>    Boolean bShortFormat
75566>>>>>End_Struct
75566>>>>>
75566>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75566>>>>>//  DF_FILE_IS_MASTER if master
75566>>>>>//  DF_FILE_IS_ALIAS if alias
75566>>>>>Struct tDbUpdateHandlerMasterAlias
75566>>>>>    Handle hTable
75566>>>>>    Integer iMode
75566>>>>>End_Struct
75566>>>>>
75566>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75566>>>>>Enumeration_List
75566>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75566>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75566>>>>>End_Enumeration_List
75566>>>>>
75566>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75566>>>>>
75566>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75566>>>>>// communicate with the object from anywhere in a program.
75566>>>>>    Global_Variable Handle ghoDbUpdateHandler
75566>>>>>    Move 0 to ghoDbUpdateHandler
75567>>>>>
75567>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75567>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75567>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75567>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75567>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75567>>>>>//    Declare_Datafile DbVersion
75567>>>>>//#ENDIF
75567>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75567>>>>>//****************************************************************************
75567>>>>>// $Module type: Class
75567>>>>>// $Module name: cDbUpdateLogFile
75567>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75567>>>>>// Web-site    : http://www.rdctools.com
75567>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75567>>>>>//
75567>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75567>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75567>>>>>//               that this class is to change; each developer can decide if the errors instead
75567>>>>>//               should be saved to a database table, or something entirely different.
75567>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75567>>>>>//
75567>>>>>// $Rev History:
75567>>>>>//    2016-10-05  Module header created
75567>>>>>//****************************************************************************
75567>>>>>Use UI
75567>>>>>Use vWin32fh.pkg
75567>>>>>
75567>>>>>
75567>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75567>>>>>
75567>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75567>>>>>
75567>>>>>Class cDbUpdateLogFile is a cObject
75568>>>>>
75568>>>>>    Procedure Construct_Object
75570>>>>>        Forward Send Construct_Object
75572>>>>>
75572>>>>>        // Error handling:
75572>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75573>>>>>        Property Integer piChannel -1
75574>>>>>
75574>>>>>        // This property is set by the cDbUpdateHandler object,
75574>>>>>        // when the update process starts.
75574>>>>>        Property DateTime pdtUpdateStart
75575>>>>>
75575>>>>>        // Gets set to False if the log contains data
75575>>>>>        Property Boolean pbEmptyLogFile True
75576>>>>>
75576>>>>>        // Gets set to True after the error log header text
75576>>>>>        // has been written.
75576>>>>>        Property Boolean pbHeaderWritten False
75577>>>>>
75577>>>>>        // If all activities should be logged- not just errors.
75577>>>>>        Property Boolean pbVerboseState False
75578>>>>>
75578>>>>>        // File name for the error log where all errors
75578>>>>>        // after a run is written to (appended).
75578>>>>>        // It is saved in the Data folder.
75578>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75579>>>>>        // If this property is set to "" in object code, the
75579>>>>>        // "shell" command parameter will be used to let Windows decide
75579>>>>>        // with which program to open the logfile.
75579>>>>>        Property String psEditorProgram ""
75580>>>>>
75580>>>>>        Property Boolean pbUseDataTableLog False
75581>>>>>
75581>>>>>        // If true an error will be written to file immediately when
75581>>>>>        // it occurs. This can be handy if a large update generates a lots
75581>>>>>        // of errors and the application crasches before finished, thus
75581>>>>>        // the errors will not be written.
75581>>>>>        Property Boolean pbQuickWrite True
75582>>>>>    End_Procedure
75583>>>>>
75583>>>>>    Procedure End_Construct_Object
75585>>>>>        Forward Send End_Construct_Object
75587>>>>>
75587>>>>>    End_Procedure
75588>>>>>
75588>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75592>>>>>        Boolean bShortFormat
75592>>>>>        Integer iSize
75592>>>>>        Handle hCurrentTable
75592>>>>>        Integer iCurrentField           
75592>>>>>        String sOrgErrorText sTableRootName
75592>>>>>        
75592>>>>>        Move False to bShortFormat
75593>>>>>        If (num_arguments > 5) Begin
75595>>>>>            Move bShortFormatIn to bShortFormat
75596>>>>>        End
75596>>>>>>
75596>>>>>        // Only do once.
75596>>>>>        If (pbHeaderWritten(Self) = False) Begin
75598>>>>>            Send WriteHeaderData
75599>>>>>            Set pbHeaderWritten to True
75600>>>>>        End
75600>>>>>>
75600>>>>>
75600>>>>>        Get Private.phCurrentTable to hCurrentTable  
75601>>>>>        Get Private.piCurrentField to iCurrentField  
75602>>>>>        If (iError > 0) Begin
75604>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75607>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75608>>>>>        End
75608>>>>>>
75608>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75609>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75610>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75611>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75612>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75613>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75614>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75615>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75616>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75617>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75618>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75619>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75620>>>>>
75620>>>>>        If (bError = False) Begin
75622>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75623>>>>>        End
75623>>>>>>
75623>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75624>>>>>
75624>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75626>>>>>            If (pbQuickWrite(Self) = True) Begin
75628>>>>>                Send OnWriteRow_DataTable
75629>>>>>                // If we are writing error for error flush the
75629>>>>>                // error array when latest error has been written.
75629>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75630>>>>>            End
75630>>>>>>
75630>>>>>            Procedure_Return
75631>>>>>        End
75631>>>>>>
75631>>>>>        Else Begin
75632>>>>>            If (pbQuickWrite(Self) = True) Begin
75634>>>>>                Send WriteErrorLog
75635>>>>>                // Flush the error log array
75635>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75636>>>>>            End
75636>>>>>>
75636>>>>>        End
75636>>>>>>
75636>>>>>    End_Procedure   
75637>>>>>    
75637>>>>>    Function FetchErrorDescription Integer iError Returns String
75639>>>>>        String sErrorText         
75639>>>>>        Move "" to sErrorText
75640>>>>>        If (iError > 0) Begin
75642>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75643>>>>>        End
75643>>>>>>
75643>>>>>        Function_Return sErrorText
75644>>>>>    End_Function
75645>>>>>
75645>>>>>    // Hook procedure for writing header text prior starting the update work to
75645>>>>>    // a database table. This does nothing by default.
75645>>>>>    // Don't forget to Open your "error log table" first (!) as all
75645>>>>>    // tables have been closed at this stage. Put anything
75645>>>>>    // you want to indicate that the update process is just started.
75645>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75647>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75649>>>>>    End_Procedure
75650>>>>>
75650>>>>>    Procedure OnWriteRow_DataTable
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75653>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75654>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75656>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75658>>>>>        End
75658>>>>>>
75658>>>>>    End_Procedure
75659>>>>>
75659>>>>>    Function psLogTextFileWithPath Returns String
75661>>>>>        String sPath sFileName sFullFileName
75661>>>>>        
75661>>>>>        Get psDataPathFirstPart to sPath
75662>>>>>        Get psLogTextFile to sFileName
75663>>>>>        Move (sPath + sFileName) to sFullFileName
75664>>>>>        Function_Return sFullFileName
75665>>>>>    End_Function                     
75666>>>>>    
75666>>>>>    Procedure WriteHeaderData
75668>>>>>        String sFileName
75668>>>>>        Integer iCh iSize
75668>>>>>        Boolean bQuickWrite
75668>>>>>        DateTime dtUpdateStart
75668>>>>>
75668>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75669>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75671>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75672>>>>>            Procedure_Return
75673>>>>>        End
75673>>>>>>
75673>>>>>
75673>>>>>        Get piChannel to iCh
75674>>>>>        If (iCh < 0) Begin
75676>>>>>            Get Seq_New_Channel to iCh
75677>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75679>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75680>>>>>>
75680>>>>>                Procedure_Return
75681>>>>>            End
75681>>>>>>
75681>>>>>            Set piChannel to iCh
75682>>>>>        End
75682>>>>>>
75682>>>>>
75682>>>>>        Get psLogTextFileWithPath to sFileName
75683>>>>>        Get vWin32_APIFileSize sFileName to iSize
75684>>>>>        Get pbQuickWrite to bQuickWrite
75685>>>>>        
75685>>>>>        If (bQuickWrite = True) Begin
75687>>>>>            Append_Output channel iCh sFileName
75689>>>>>                If (bQuickWrite = True) Begin
75691>>>>>                    If (iSize = 0) Begin
75693>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75696>>>>>                        Set pbEmptyLogFile to False
75697>>>>>                    End
75697>>>>>>
75697>>>>>                    Writeln channel iCh
75699>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75702>>>>>                End
75702>>>>>>
75702>>>>>            Close_Output channel iCh
75704>>>>>        End
75704>>>>>>
75704>>>>>    End_Procedure
75705>>>>>
75705>>>>>    // Returns the first datapath found in the psDataPath property.
75705>>>>>    // The returned path always ends with a "\"
75705>>>>>    Function psDataPathFirstPart Returns String
75707>>>>>        String sDataPath
75707>>>>>        Integer iCount
75707>>>>>
75707>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75708>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75709>>>>>        If (iCount > 1) Begin
75711>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75712>>>>>        End
75712>>>>>>
75712>>>>>        If (sDataPath <> "") Begin
75714>>>>>            Get vFolderFormat sDataPath to sDataPath
75715>>>>>        End
75715>>>>>>
75715>>>>>
75715>>>>>        Function_Return sDataPath
75716>>>>>    End_Function
75717>>>>>
75717>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75717>>>>>    Procedure WriteErrorLog
75719>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75719>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75720>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75720>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75720>>>>>        Boolean bUseDataTable bQuickWrite
75720>>>>>        DateTime dtUpdateStart dtUpdateEnd
75720>>>>>        TimeSpan tsElapsed
75720>>>>>        Number nVersion                                  
75720>>>>>        Handle hTable
75720>>>>>
75720>>>>>        If (pbHeaderWritten(Self) = False) Begin
75722>>>>>            Send WriteHeaderData
75723>>>>>            Set pbHeaderWritten to True
75724>>>>>        End
75724>>>>>>
75724>>>>>
75724>>>>>        Get pbUseDataTableLog to bUseDataTable
75725>>>>>        If (bUseDataTable = True) Begin
75727>>>>>            Send OnWriteRow_DataTable
75728>>>>>            Procedure_Return
75729>>>>>        End
75729>>>>>>
75729>>>>>
75729>>>>>        Get piChannel to iCh
75730>>>>>        If (iCh < 0) Begin
75732>>>>>            Get Seq_New_Channel to iCh
75733>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75735>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75736>>>>>>
75736>>>>>                Procedure_Return
75737>>>>>            End
75737>>>>>>
75737>>>>>            Set piChannel to iCh
75738>>>>>        End
75738>>>>>>
75738>>>>>
75738>>>>>        Get psLogTextFileWithPath to sFileName
75739>>>>>
75739>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75740>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75741>>>>>        Decrement iSize
75742>>>>>
75742>>>>>        Get pdtUpdateStart to dtUpdateStart
75743>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75745>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75746>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75747>>>>>        End
75747>>>>>>
75747>>>>>        Get pbQuickWrite to bQuickWrite
75748>>>>>
75748>>>>>        Append_Output channel iCh sFileName
75750>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75752>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75755>>>>>        End
75755>>>>>>
75755>>>>>        Else If (bQuickWrite = False) Begin
75758>>>>>            Writeln channel iCh
75760>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75763>>>>>        End   
75763>>>>>>
75763>>>>>        If (iSize >= 0) Begin
75765>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75767>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75770>>>>>            End
75770>>>>>>
75770>>>>>        End
75770>>>>>>
75770>>>>>
75770>>>>>        For iCount from 0 to iSize  
75776>>>>>>
75776>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75777>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75778>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75779>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75780>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75781>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75782>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75783>>>>>            
75783>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75784>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75786>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75787>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75788>>>>>            End
75788>>>>>>
75788>>>>>            Else Begin
75789>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75790>>>>>                Move (sVersion + "   " + sErrorText) to sText
75791>>>>>            End
75791>>>>>>
75791>>>>>            Writeln channel iCh sText
75794>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75796>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75797>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75798>>>>>                Writeln channel iCh sOrgErrorText
75801>>>>>            End
75801>>>>>>
75801>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75803>>>>>                Writeln channel iCh
75805>>>>>            End
75805>>>>>>
75805>>>>>        Loop
75806>>>>>>
75806>>>>>        Close_Output channel iCh
75808>>>>>
75808>>>>>        Send Seq_Release_Channel iCh
75809>>>>>        Set piChannel to -1
75810>>>>>
75810>>>>>    End_Procedure
75811>>>>>
75811>>>>>    // The character to pad is optional. If nothing, spaces are used.
75811>>>>>    // Example:
75811>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75811>>>>>    //  or:
75811>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75811>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75811>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75813>>>>>        String sChar
75813>>>>>
75813>>>>>        If (Num_Arguments >= 3) Begin
75815>>>>>            Move sOptChar to sChar
75816>>>>>        End
75816>>>>>>
75816>>>>>        Else Begin
75817>>>>>            Move " " to sChar
75818>>>>>        End
75818>>>>>>
75818>>>>>
75818>>>>>        While (Length(sString) < iLength)
75822>>>>>            Move (sChar + sString) to sString
75823>>>>>        Loop
75824>>>>>>
75824>>>>>
75824>>>>>        Function_Return sString
75825>>>>>    End_Function
75826>>>>>
75826>>>>>    Procedure ShowErrorLog
75828>>>>>        String sPath sFileName sEditorProgram
75828>>>>>        Boolean bExists
75828>>>>>
75828>>>>>        Get psLogTextFileWithPath to sFileName
75829>>>>>        Get vFilePathExists sFileName to bExists
75830>>>>>        If (bExists = True) Begin
75832>>>>>            Get psEditorProgram to sEditorProgram
75833>>>>>            If (sEditorProgram <> "") Begin
75835>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75836>>>>>            End
75836>>>>>>
75836>>>>>            Else Begin
75837>>>>>                Runprogram Shell Background sFileName
75838>>>>>            End
75838>>>>>>
75838>>>>>        End
75838>>>>>>
75838>>>>>        Else Begin
75839>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75840>>>>>        End
75840>>>>>>
75840>>>>>    End_Procedure
75841>>>>>
75841>>>>>End_Class
75842>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75842>>>>>//****************************************************************************
75842>>>>>// $Module type: Class
75842>>>>>// $Module name: cDbUpdateVersion
75842>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75842>>>>>// Web-site    : http://www.rdctools.com
75842>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75842>>>>>//
75842>>>>>// Description : Child class to cDbUpdateHandler.
75842>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75842>>>>>//               Set the pnVersionNumber to a version number.
75842>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75842>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75842>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75842>>>>>//
75842>>>>>// $Rev History:
75842>>>>>//    2016-09-27  Module header created
75842>>>>>//****************************************************************************
75842>>>>>Use UI
75842>>>>>Use DUFLanguageConstants.inc
75842>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75842>>>>>>>//****************************************************************************
75842>>>>>>>// $Module type: Class
75842>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75842>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75842>>>>>>>// Web-site    : http://www.rdctools.com
75842>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75842>>>>>>>//
75842>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75842>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75842>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75842>>>>>>>//               with the help of Sql-scripts.
75842>>>>>>>//
75842>>>>>>>// $Rev History:
75842>>>>>>>//    2014-09-05  Module header created
75842>>>>>>>//
75842>>>>>>>//****************************************************************************
75842>>>>>>>//
75842>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75842>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75842>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75842>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75842>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75842>>>>>>>//
75842>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75842>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75842>>>>>>>
75842>>>>>>>
75842>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75842>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
75842>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75842>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75842>>>>>>>//
75842>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75842>>>>>>>>>//****************************************************************************
75842>>>>>>>>>// $Module type: Class
75842>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75842>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75842>>>>>>>>>// Web-site    : http://www.rdctools.com
75842>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75842>>>>>>>>>//
75842>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75842>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75842>>>>>>>>>//
75842>>>>>>>>>// $Rev History:
75842>>>>>>>>>//    2023-11-06  Module header created
75842>>>>>>>>>//
75842>>>>>>>>>//****************************************************************************
75842>>>>>>>>>Use cApplication.pkg
75842>>>>>>>>>Use seq_chnl.pkg
75842>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75842>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75842>>>>>>>>>Use Dfcursor.pkg
75842>>>>>>>>>Use DUFStatusPanel.pkg
75842>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75842>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// We need to create a mixin class for the library.
75842>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75842>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75842>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75842>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75842>>>>>>>>>>>//
75842>>>>>>>>>>>Use VdfBase.pkg
75842>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75842>>>>>>>>>>>>>Use Unicode.Pkg
75842>>>>>>>>>>>>>
75842>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75843>>>>>>>>>>>>>
75843>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75844>>>>>>>>>>>>>
75844>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75845>>>>>>>>>>>>>
75845>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75846>>>>>>>>>>>>>
75846>>>>>>>>>>>>>
75846>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75846>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75848>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75848>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75848>>>>>>>>>>>>>    String sUUID
75848>>>>>>>>>>>>>    
75848>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75849>>>>>>>>>>>>>    
75849>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75850>>>>>>>>>>>>>    
75850>>>>>>>>>>>>>    If (iRetval = 0) Begin
75852>>>>>>>>>>>>>        Move 0 to pUUIDStr
75853>>>>>>>>>>>>>        
75853>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75854>>>>>>>>>>>>>        If (iRetval = 0) Begin
75856>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75857>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75858>>>>>>>>>>>>>            
75858>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75859>>>>>>>>>>>>>        End
75859>>>>>>>>>>>>>>
75859>>>>>>>>>>>>>    End
75859>>>>>>>>>>>>>>
75859>>>>>>>>>>>>>    
75859>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75860>>>>>>>>>>>>>    
75860>>>>>>>>>>>>>    Function_Return sUUID
75861>>>>>>>>>>>>>End_Function
75862>>>>>>>>>>>>>
75862>>>>>>>>>>>>>
75862>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75862>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75864>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75864>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75864>>>>>>>>>>>>>    String sUUID
75864>>>>>>>>>>>>>    
75864>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75865>>>>>>>>>>>>>    
75865>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75866>>>>>>>>>>>>>    
75866>>>>>>>>>>>>>    If (iRetval = 0) Begin
75868>>>>>>>>>>>>>        Move 0 to pUUIDStr
75869>>>>>>>>>>>>>        
75869>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75870>>>>>>>>>>>>>        If (iRetval = 0) Begin
75872>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75873>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75874>>>>>>>>>>>>>            
75874>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75875>>>>>>>>>>>>>        End
75875>>>>>>>>>>>>>>
75875>>>>>>>>>>>>>    End
75875>>>>>>>>>>>>>>
75875>>>>>>>>>>>>>    
75875>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75876>>>>>>>>>>>>>    
75876>>>>>>>>>>>>>    Function_Return sUUID
75877>>>>>>>>>>>>>End_Function
75878>>>>>>>>>>>Use cli.pkg
75878>>>>>>>>>>>Use sql.pkg
75878>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75878>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75878>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75878>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>Use Cli.pkg
75878>>>>>>>>>>>>>Use SQL.pkg
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>//   Driver Indentification
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>//   Error number constants
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>// SQL Server spcific types.
75878>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75878>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75878>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75878>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>// SQL Server spcific types.
75878>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75878>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75878>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75878>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75878>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75878>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75878>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75878>>>>>>>>>>>>>//
75878>>>>>>>>>>>>>//     Setup a constraint for a file.
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>
75878>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75879>>>>>>>>>>>>>    
75879>>>>>>>>>>>>>    Procedure Construct_Object
75881>>>>>>>>>>>>>        Forward Send Construct_Object
75883>>>>>>>>>>>>>        
75883>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75884>>>>>>>>>>>>>    End_Procedure
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75885>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75887>>>>>>>>>>>>>        String  sItem
75887>>>>>>>>>>>>>        Integer iStart
75887>>>>>>>>>>>>>        Integer iEnd
75887>>>>>>>>>>>>>        
75887>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75890>>>>>>>>>>>>>        
75890>>>>>>>>>>>>>        Send Delete_Data to hoStore
75891>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75892>>>>>>>>>>>>>        While (iStart > 0)
75896>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75897>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75900>>>>>>>>>>>>>            Else Begin
75901>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75902>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75903>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75906>>>>>>>>>>>>>                
75906>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75909>>>>>>>>>>>>>                
75909>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75912>>>>>>>>>>>>>            End
75912>>>>>>>>>>>>>>
75912>>>>>>>>>>>>>        Loop
75913>>>>>>>>>>>>>>
75913>>>>>>>>>>>>>        
75913>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75914>>>>>>>>>>>>>    End_Procedure
75915>>>>>>>>>>>>>    
75915>>>>>>>>>>>>>    
75915>>>>>>>>>>>>>    
75915>>>>>>>>>>>>>    //   Call the driver's browse connect function
75915>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75917>>>>>>>>>>>>>        String  sDriver
75917>>>>>>>>>>>>>        String  sOutConnStr
75917>>>>>>>>>>>>>        Integer iArg
75917>>>>>>>>>>>>>        Integer iRetval
75917>>>>>>>>>>>>>        
75917>>>>>>>>>>>>>        Get psDriverID to sDriver
75918>>>>>>>>>>>>>        If (sDriver <> "") Begin
75920>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75921>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75926>>>>>>>>>>>>>        End
75926>>>>>>>>>>>>>>
75926>>>>>>>>>>>>>        
75926>>>>>>>>>>>>>        Function_Return sOutConnStr
75927>>>>>>>>>>>>>    End_Function// BrowseConnect
75928>>>>>>>>>>>>>    
75928>>>>>>>>>>>>>    
75928>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75930>>>>>>>>>>>>>        String  sDriver
75930>>>>>>>>>>>>>        String  sOutConnStr
75930>>>>>>>>>>>>>        Integer iArg
75930>>>>>>>>>>>>>        Integer iRetval
75930>>>>>>>>>>>>>        
75930>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75931>>>>>>>>>>>>>        
75931>>>>>>>>>>>>>        Get psDriverID to sDriver
75932>>>>>>>>>>>>>        If (sDriver <> "") Begin
75934>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75935>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75940>>>>>>>>>>>>>        End
75940>>>>>>>>>>>>>>
75940>>>>>>>>>>>>>        
75940>>>>>>>>>>>>>        Function_Return sOutConnStr
75941>>>>>>>>>>>>>    End_Function// BrowseConnect
75942>>>>>>>>>>>>>    
75942>>>>>>>>>>>>>    
75942>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75944>>>>>>>>>>>>>        String  sServerList
75944>>>>>>>>>>>>>        Integer iNumServers
75944>>>>>>>>>>>>>        Integer iDriver
75944>>>>>>>>>>>>>        Integer iClientVersion
75944>>>>>>>>>>>>>        String  sDriver
75944>>>>>>>>>>>>>        
75944>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75945>>>>>>>>>>>>>        
75945>>>>>>>>>>>>>        If (iDriver) Begin
75947>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75950>>>>>>>>>>>>>            
75950>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75951>>>>>>>>>>>>>            
75951>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75952>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75954>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75955>>>>>>>>>>>>>            End
75955>>>>>>>>>>>>>>
75955>>>>>>>>>>>>>            Else Begin
75956>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75957>>>>>>>>>>>>>            End
75957>>>>>>>>>>>>>>
75957>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75958>>>>>>>>>>>>>        End
75958>>>>>>>>>>>>>>
75958>>>>>>>>>>>>>        
75958>>>>>>>>>>>>>        Function_Return iNumServers
75959>>>>>>>>>>>>>    End_Function
75960>>>>>>>>>>>>>    
75960>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75960>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75960>>>>>>>>>>>>>    //   This may take a long time.
75960>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75960>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75962>>>>>>>>>>>>>        Integer iNumServers
75962>>>>>>>>>>>>>        Integer iNetworkLocal
75962>>>>>>>>>>>>>        
75962>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75963>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75964>>>>>>>>>>>>>
75964>>>>>>>>>>>>>        Function_Return iNumServers
75965>>>>>>>>>>>>>    End_Function
75966>>>>>>>>>>>>>    
75966>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75966>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75966>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75966>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75968>>>>>>>>>>>>>        Integer iNumServers
75968>>>>>>>>>>>>>        Integer iNetworkLocal
75968>>>>>>>>>>>>>        
75968>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75969>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75970>>>>>>>>>>>>>        
75970>>>>>>>>>>>>>        Function_Return iNumServers
75971>>>>>>>>>>>>>    End_Function
75972>>>>>>>>>>>>>    
75972>>>>>>>>>>>>>    //   Enumerate database in a given server.
75972>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75974>>>>>>>>>>>>>        Integer hoSQL
75974>>>>>>>>>>>>>        String  sConnect
75974>>>>>>>>>>>>>        String  sDatabase
75974>>>>>>>>>>>>>        Integer hdbc
75974>>>>>>>>>>>>>        Integer hstmt
75974>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75974>>>>>>>>>>>>>        
75974>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75977>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75980>>>>>>>>>>>>>        
75980>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75983>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75985>>>>>>>>>>>>>
75985>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75986>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75989>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
75991>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
75992>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
75993>>>>>>>>>>>>>        End
75993>>>>>>>>>>>>>>
75993>>>>>>>>>>>>>        
75993>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75995>>>>>>>>>>>>>            Move Current_Object to hoSQL
75996>>>>>>>>>>>>>        End_Object
75997>>>>>>>>>>>>>        
75997>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
75999>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76000>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76002>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76003>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76005>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76005>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76005>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76005>>>>>>>>>>>>>                    //   stay the same.
76005>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76006>>>>>>>>>>>>>                    Send SQLCall to hstmt
76007>>>>>>>>>>>>>                    Repeat
76007>>>>>>>>>>>>>>
76007>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76008>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76010>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76011>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76012>>>>>>>>>>>>>                        End
76012>>>>>>>>>>>>>>
76012>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76014>>>>>>>>>>>>>                    
76014>>>>>>>>>>>>>                    Send SQLClose to hstmt
76015>>>>>>>>>>>>>                End
76015>>>>>>>>>>>>>>
76015>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76016>>>>>>>>>>>>>            End
76016>>>>>>>>>>>>>>
76016>>>>>>>>>>>>>        End
76016>>>>>>>>>>>>>>
76016>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76017>>>>>>>>>>>>>        
76017>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76018>>>>>>>>>>>>>    End_Function
76019>>>>>>>>>>>>>    
76019>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76021>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76021>>>>>>>>>>>>>        
76021>>>>>>>>>>>>>        Case Begin
76021>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76023>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76024>>>>>>>>>>>>>                Case Break
76025>>>>>>>>>>>>>            
76025>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76028>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76029>>>>>>>>>>>>>                Case Break
76030>>>>>>>>>>>>>                
76030>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76033>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76034>>>>>>>>>>>>>                Case Break
76035>>>>>>>>>>>>>            
76035>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76038>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76039>>>>>>>>>>>>>                Case Break
76040>>>>>>>>>>>>>            
76040>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76043>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76044>>>>>>>>>>>>>                Case Break
76045>>>>>>>>>>>>>            
76045>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76048>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76049>>>>>>>>>>>>>                Case Break
76050>>>>>>>>>>>>>            
76050>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76053>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76054>>>>>>>>>>>>>                Case Break
76055>>>>>>>>>>>>>            
76055>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76058>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76059>>>>>>>>>>>>>                Case Break
76060>>>>>>>>>>>>>            
76060>>>>>>>>>>>>>            Case Else
76060>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76061>>>>>>>>>>>>>        Case End
76061>>>>>>>>>>>>>        
76061>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76062>>>>>>>>>>>>>    End_Function
76063>>>>>>>>>>>>>
76063>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76065>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76065>>>>>>>>>>>>>        
76065>>>>>>>>>>>>>        Case Begin
76065>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76067>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76068>>>>>>>>>>>>>                Case Break
76069>>>>>>>>>>>>>
76069>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76072>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76073>>>>>>>>>>>>>                Case Break
76074>>>>>>>>>>>>>                
76074>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76077>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76078>>>>>>>>>>>>>                Case Break
76079>>>>>>>>>>>>>            
76079>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76082>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76083>>>>>>>>>>>>>                Case Break
76084>>>>>>>>>>>>>            
76084>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76087>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76088>>>>>>>>>>>>>                Case Break
76089>>>>>>>>>>>>>            
76089>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76092>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76093>>>>>>>>>>>>>                Case Break
76094>>>>>>>>>>>>>            
76094>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76097>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76098>>>>>>>>>>>>>                Case Break
76099>>>>>>>>>>>>>            
76099>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76102>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76103>>>>>>>>>>>>>                Case Break
76104>>>>>>>>>>>>>            
76104>>>>>>>>>>>>>            Case Else
76104>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76105>>>>>>>>>>>>>        Case End
76105>>>>>>>>>>>>>        
76105>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76106>>>>>>>>>>>>>    End_Function
76107>>>>>>>>>>>>>    
76107>>>>>>>>>>>>>End_Class
76108>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76108>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76108>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76108>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76108>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>Use Cli.pkg
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// Driver attributes
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// Driver Indentification
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// Error number constants
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// Call driver function identifiers
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// DB2 specific data types
76108>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76108>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76108>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76108>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76108>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76108>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76108>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76108>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// Extra DB2 commands
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76108>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>
76108>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76109>>>>>>>>>>>>>    
76109>>>>>>>>>>>>>    Procedure Construct_Object
76111>>>>>>>>>>>>>        Forward Send Construct_Object
76113>>>>>>>>>>>>>        
76113>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76114>>>>>>>>>>>>>    End_Procedure
76115>>>>>>>>>>>>>    
76115>>>>>>>>>>>>>    
76115>>>>>>>>>>>>>    
76115>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76115>>>>>>>>>>>>>    Procedure SeedDataSources
76117>>>>>>>>>>>>>        String  sDriver
76117>>>>>>>>>>>>>        String  sVoid
76117>>>>>>>>>>>>>        Integer iRetval
76117>>>>>>>>>>>>>        
76117>>>>>>>>>>>>>        Get psDriverID to sDriver
76118>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76125>>>>>>>>>>>>>    End_Procedure
76126>>>>>>>>>>>>>    
76126>>>>>>>>>>>>>    
76126>>>>>>>>>>>>>    
76126>>>>>>>>>>>>>    // Call the driver's data sources function
76126>>>>>>>>>>>>>    Function DataSources Returns String
76128>>>>>>>>>>>>>        String  sDriver
76128>>>>>>>>>>>>>        String  sDataSource
76128>>>>>>>>>>>>>        String  sDescription
76128>>>>>>>>>>>>>        Integer iLength
76128>>>>>>>>>>>>>        Integer iRetval
76128>>>>>>>>>>>>>        
76128>>>>>>>>>>>>>        Get psDriverID to sDriver
76129>>>>>>>>>>>>>        If (sDriver <> "") Begin
76131>>>>>>>>>>>>>            Move 8192 to iLength
76132>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76133>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76134>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76139>>>>>>>>>>>>>        End
76139>>>>>>>>>>>>>>
76139>>>>>>>>>>>>>        
76139>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76142>>>>>>>>>>>>>        Else ;            Function_Return ""
76144>>>>>>>>>>>>>    End_Function
76145>>>>>>>>>>>>>    
76145>>>>>>>>>>>>>End_Class
76146>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76146>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76146>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76146>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76146>>>>>>>>>>>>>
76146>>>>>>>>>>>>>Use Cli.pkg
76146>>>>>>>>>>>>>
76146>>>>>>>>>>>>>// Driver Indentification
76146>>>>>>>>>>>>>
76146>>>>>>>>>>>>>// Error number constants
76146>>>>>>>>>>>>>
76146>>>>>>>>>>>>>// Call driver function identifiers
76146>>>>>>>>>>>>>
76146>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    Procedure Construct_Object
76149>>>>>>>>>>>>>        Forward Send Construct_Object
76151>>>>>>>>>>>>>        
76151>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76152>>>>>>>>>>>>>    End_Procedure
76153>>>>>>>>>>>>>    
76153>>>>>>>>>>>>>    
76153>>>>>>>>>>>>>    
76153>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76153>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76155>>>>>>>>>>>>>        String  sDriver
76155>>>>>>>>>>>>>        String  sVoid
76155>>>>>>>>>>>>>        Integer iRetval
76155>>>>>>>>>>>>>        
76155>>>>>>>>>>>>>        Get psDriverID to sDriver
76156>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76163>>>>>>>>>>>>>    End_Procedure
76164>>>>>>>>>>>>>    
76164>>>>>>>>>>>>>    
76164>>>>>>>>>>>>>    // Call the driver's data sources function
76164>>>>>>>>>>>>>    Function DataSources Returns String
76166>>>>>>>>>>>>>        String  sDriver
76166>>>>>>>>>>>>>        String  sDataSource
76166>>>>>>>>>>>>>        String  sDescription
76166>>>>>>>>>>>>>        Integer iLength
76166>>>>>>>>>>>>>        Integer iRetval
76166>>>>>>>>>>>>>        
76166>>>>>>>>>>>>>        Get psDriverID to sDriver
76167>>>>>>>>>>>>>        If (sDriver <> "") Begin
76169>>>>>>>>>>>>>            Move 8192 to iLength
76170>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76171>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76172>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76177>>>>>>>>>>>>>        End
76177>>>>>>>>>>>>>>
76177>>>>>>>>>>>>>        
76177>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76180>>>>>>>>>>>>>        Else ;            Function_Return ""
76182>>>>>>>>>>>>>    End_Function
76183>>>>>>>>>>>>>    
76183>>>>>>>>>>>>>End_Class
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76184>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76184>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76184>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76184>>>>>>>>>>>>>Use Ui
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Driver Indentification
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>// Driver attributes
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Call_Driver functions ID's
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to create all vars which may be needed
76184>>>>>>>>>>>>>// in other commands.
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76184>>>>>>>>>>>>>// File must have been opened.
76184>>>>>>>>>>>>>// Filenumber needs to be passed.
76184>>>>>>>>>>>>>// To clear set the owner to "".
76184>>>>>>>>>>>>>// Examples:
76184>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76184>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76184>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76184>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76184>>>>>>>>>>>>>// To clear:
76184>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76184>>>>>>>>>>>>>// options.
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to parse for Callback
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76184>>>>>>>>>>>>>// File must have been opened.
76184>>>>>>>>>>>>>// Filenumber needs to be passed.
76184>>>>>>>>>>>>>// Examples:
76184>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76184>>>>>>>>>>>>>// which will be tries when opening files.
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76184>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76184>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76184>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to change the transaction type.
76184>>>>>>>>>>>>>// Valid types are:
76184>>>>>>>>>>>>>//     DFBTRTT_NONE
76184>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76184>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to get the current transaction type.
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to set explicit_locking
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to get explicit locking
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76184>>>>>>>>>>>>>//
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76184>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76184>>>>>>>>>>>>>
76184>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76187>>>>>>>>>>>>>        Forward Send Construct_object iImage
76189>>>>>>>>>>>>>        
76189>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76190>>>>>>>>>>>>>    End_Procedure
76191>>>>>>>>>>>>>    
76191>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76191>>>>>>>>>>>>>    //
76191>>>>>>>>>>>>>    
76191>>>>>>>>>>>>>    Function CKRevision Returns String
76193>>>>>>>>>>>>>        String  sDriverID
76193>>>>>>>>>>>>>        String  sRevision
76193>>>>>>>>>>>>>        String  sVoid
76193>>>>>>>>>>>>>        Integer iRetval
76193>>>>>>>>>>>>>        
76193>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76193>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76193>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76193>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76194>>>>>>>>>>>>>        Get psDriverID to sDriverID
76195>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76196>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76201>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76202>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76204>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76204>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76205>>>>>>>>>>>>>        End
76205>>>>>>>>>>>>>>
76205>>>>>>>>>>>>>        Function_Return sRevision
76206>>>>>>>>>>>>>    End_Function
76207>>>>>>>>>>>>>    
76207>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76209>>>>>>>>>>>>>        String  sDriverID
76209>>>>>>>>>>>>>        String  sVoid1
76209>>>>>>>>>>>>>        String  sVoid2
76209>>>>>>>>>>>>>        Integer iRetval
76209>>>>>>>>>>>>>        
76209>>>>>>>>>>>>>        Get psDriverID to sDriverID
76210>>>>>>>>>>>>>        
76210>>>>>>>>>>>>>        Move 0 to iRetval
76211>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76211>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76211>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76211>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76212>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76217>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76218>>>>>>>>>>>>>        
76218>>>>>>>>>>>>>        Function_Return iRetval
76219>>>>>>>>>>>>>    End_Function
76220>>>>>>>>>>>>>    
76220>>>>>>>>>>>>>    
76220>>>>>>>>>>>>>    
76220>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76220>>>>>>>>>>>>>    //
76220>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76220>>>>>>>>>>>>>    //
76220>>>>>>>>>>>>>    
76220>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76222>>>>>>>>>>>>>        Integer iPartRev
76222>>>>>>>>>>>>>        Integer iCurrentPart
76222>>>>>>>>>>>>>        Integer iSeparatorPos
76222>>>>>>>>>>>>>        
76222>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76225>>>>>>>>>>>>>        
76225>>>>>>>>>>>>>        Move 0 to iCurrentPart
76226>>>>>>>>>>>>>        Repeat
76226>>>>>>>>>>>>>>
76226>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76227>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76229>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76230>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76231>>>>>>>>>>>>>                Increment iCurrentPart
76232>>>>>>>>>>>>>            End
76232>>>>>>>>>>>>>>
76232>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76235>>>>>>>>>>>>>                Move sRevision to iPartRev
76236>>>>>>>>>>>>>                Move "" to sRevision
76237>>>>>>>>>>>>>                Increment iCurrentPart
76238>>>>>>>>>>>>>            End
76238>>>>>>>>>>>>>>
76238>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76240>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76242>>>>>>>>>>>>>        
76242>>>>>>>>>>>>>        Function_Return iPartRev
76243>>>>>>>>>>>>>    End_Function
76244>>>>>>>>>>>>>    
76244>>>>>>>>>>>>>    
76244>>>>>>>>>>>>>    
76244>>>>>>>>>>>>>    //
76244>>>>>>>>>>>>>    //  Returns the major revision of the CK
76244>>>>>>>>>>>>>    //
76244>>>>>>>>>>>>>    
76244>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76246>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76247>>>>>>>>>>>>>    End_Function
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76248>>>>>>>>>>>>>    //
76248>>>>>>>>>>>>>    
76248>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76250>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76251>>>>>>>>>>>>>    End_Function
76252>>>>>>>>>>>>>    
76252>>>>>>>>>>>>>    
76252>>>>>>>>>>>>>    //  Returns the release revision of the CK
76252>>>>>>>>>>>>>    //
76252>>>>>>>>>>>>>    
76252>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76254>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76255>>>>>>>>>>>>>    End_Function
76256>>>>>>>>>>>>>    
76256>>>>>>>>>>>>>    
76256>>>>>>>>>>>>>    //  Returns the major revision of the CK
76256>>>>>>>>>>>>>    //
76256>>>>>>>>>>>>>    
76256>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76258>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76259>>>>>>>>>>>>>    End_Function
76260>>>>>>>>>>>>>    
76260>>>>>>>>>>>>>    
76260>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76260>>>>>>>>>>>>>    //
76260>>>>>>>>>>>>>    
76260>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76262>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76265>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76268>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76271>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76274>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76277>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76281>>>>>>>>>>>>>            End
76281>>>>>>>>>>>>>>
76281>>>>>>>>>>>>>        End
76281>>>>>>>>>>>>>>
76281>>>>>>>>>>>>>        
76281>>>>>>>>>>>>>        Function_Return (False)
76282>>>>>>>>>>>>>    End_Function
76283>>>>>>>>>>>>>    
76283>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76283>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76283>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76283>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76283>>>>>>>>>>>>>    //
76283>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76283>>>>>>>>>>>>>    //   in the following format:
76283>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76283>>>>>>>>>>>>>    //   possible values for <type>:
76283>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76283>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76283>>>>>>>>>>>>>    //       C for client cache engine
76283>>>>>>>>>>>>>    //       D for DOS workstation
76283>>>>>>>>>>>>>    //       N for client Requester
76283>>>>>>>>>>>>>    //       S for NetWare server
76283>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76283>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76283>>>>>>>>>>>>>    //
76283>>>>>>>>>>>>>    //   example:
76283>>>>>>>>>>>>>    //       8.50.T
76283>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76283>>>>>>>>>>>>>    //   32-bits Windows server.
76283>>>>>>>>>>>>>    //
76283>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76283>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76283>>>>>>>>>>>>>    //
76283>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76283>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76283>>>>>>>>>>>>>    
76283>>>>>>>>>>>>>    //  Returns the version information of the
76283>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76283>>>>>>>>>>>>>    
76283>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76285>>>>>>>>>>>>>        
76285>>>>>>>>>>>>>        String  sDriverID
76285>>>>>>>>>>>>>        String  sVersion
76285>>>>>>>>>>>>>        String  sVoid
76285>>>>>>>>>>>>>        Integer iRetval
76285>>>>>>>>>>>>>        
76285>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76285>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76285>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76285>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76286>>>>>>>>>>>>>        Get psDriverID to sDriverID
76287>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76288>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76293>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76294>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76296>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76296>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76297>>>>>>>>>>>>>        End
76297>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>        Function_Return sVersion
76298>>>>>>>>>>>>>    End_Function
76299>>>>>>>>>>>>>    
76299>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76299>>>>>>>>>>>>>    
76299>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76301>>>>>>>>>>>>>        
76301>>>>>>>>>>>>>        String  sDriverID
76301>>>>>>>>>>>>>        String  sVersion
76301>>>>>>>>>>>>>        String  sVoid
76301>>>>>>>>>>>>>        Integer iRetval
76301>>>>>>>>>>>>>        
76301>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76301>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76301>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76301>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76302>>>>>>>>>>>>>        Get psDriverID to sDriverID
76303>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76304>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76309>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76310>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76312>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76312>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76313>>>>>>>>>>>>>        End
76313>>>>>>>>>>>>>>
76313>>>>>>>>>>>>>        Function_Return sVersion
76314>>>>>>>>>>>>>    End_Function
76315>>>>>>>>>>>>>    
76315>>>>>>>>>>>>>    //  Returns the version information of the
76315>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76315>>>>>>>>>>>>>    
76315>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76317>>>>>>>>>>>>>        
76317>>>>>>>>>>>>>        String  sDriverID
76317>>>>>>>>>>>>>        String  sVersion
76317>>>>>>>>>>>>>        String  sVoid
76317>>>>>>>>>>>>>        Integer iRetval
76317>>>>>>>>>>>>>        
76317>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76317>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76317>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76317>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76318>>>>>>>>>>>>>        Get psDriverID to sDriverID
76319>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76320>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76325>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76326>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76328>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76328>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76329>>>>>>>>>>>>>        End
76329>>>>>>>>>>>>>>
76329>>>>>>>>>>>>>        Function_Return sVersion
76330>>>>>>>>>>>>>    End_Function
76331>>>>>>>>>>>>>    
76331>>>>>>>>>>>>>End_Class
76332>>>>>>>>>>>>>
76332>>>>>>>>>>>>>
76332>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76332>>>>>>>>>>>>>//****************************************************************************
76332>>>>>>>>>>>>>// $Module type: Include file
76332>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76332>>>>>>>>>>>>>//
76332>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76332>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76332>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76332>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76332>>>>>>>>>>>>>//
76332>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76332>>>>>>>>>>>>>//
76332>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76332>>>>>>>>>>>>>//
76332>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76332>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76332>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76332>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76332>>>>>>>>>>>>>// in the help folder for more details.
76332>>>>>>>>>>>>>//
76332>>>>>>>>>>>>>Use Winkern.pkg
76332>>>>>>>>>>>>>Use cIniFile.pkg
76332>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76332>>>>>>>>>>>>>>>Use VdfBase.pkg
76332>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76332>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76332>>>>>>>>>>>>>>>>>// Algorithm classes
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76332>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Algorithm types
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76332>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Generic sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// RSA sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// DSS sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// DES sub_ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76332>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76332>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76332>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76332>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76332>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76332>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76332>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76332>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76332>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// RC2 sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76332>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76332>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Hash sub ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76332>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76332>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76332>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76332>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76332>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76332>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// secure channel sub ids
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76332>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76332>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76332>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76332>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76332>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76332>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76332>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76332>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76332>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76332>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76332>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76332>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76332>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76332>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76332>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76332>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76332>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76332>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76332>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76332>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76332>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76332>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76332>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76332>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76332>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76332>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76332>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76332>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76332>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76332>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76332>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76332>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76332>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76332>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76332>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76332>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76332>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76332>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76332>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76332>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76332>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76332>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76332>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76332>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76332>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76332>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76332>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Providers
76332>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76332>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76332>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76332>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76332>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76332>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76332>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76332>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76332>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76332>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76332>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76332>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76332>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76332>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76332>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76332>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76332>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76332>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76332>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76332>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76332>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76332>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76332>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76332>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76332>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Provider types
76332>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76332>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76332>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76332>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76332>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76332>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76332>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76332>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76332>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76332>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76332>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76332>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76332>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76332>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76332>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76332>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76332>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76332>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// KP_MODE
76332>>>>>>>>>>>>>>>>>// KP_MODE
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76332>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76332>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76332>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76332>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76332>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76332>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76332>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76332>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76332>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76332>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76332>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76332>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76332>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76332>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76332>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76332>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76332>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76332>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76332>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76332>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76332>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76332>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76332>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76332>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76332>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76332>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76332>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76332>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76332>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76332>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76332>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76332>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76332>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76332>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76332>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76332>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76332>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76332>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76332>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76332>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76332>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76332>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76332>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76332>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76332>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76332>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76332>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// key BLOB types
76332>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76332>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76332>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76332>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76332>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76332>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76332>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76332>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// KP_PADDING
76332>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76332>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76332>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76332>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76332>>>>>>>>>>>>>>>>>    UChar    bType
76332>>>>>>>>>>>>>>>>>    UChar    bVersion
76332>>>>>>>>>>>>>>>>>    UShort   reserved
76332>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76332>>>>>>>>>>>>>>>>>End_Struct
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76332>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76332>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76332>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76332>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76332>>>>>>>>>>>>>>>>>End_Struct
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76332>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76332>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76332>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76332>>>>>>>>>>>>>>>>>    DWord cbInnerString
76332>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76332>>>>>>>>>>>>>>>>>    DWord cbOuterString
76332>>>>>>>>>>>>>>>>>End_Struct
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76332>>>>>>>>>>>>>>>>>    UChar   bType
76332>>>>>>>>>>>>>>>>>    UChar   bVersion
76332>>>>>>>>>>>>>>>>>    Short   reserved
76332>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76332>>>>>>>>>>>>>>>>>End_Struct
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>Struct CryptoBlob
76332>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76332>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76332>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76332>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76332>>>>>>>>>>>>>>>>>End_Struct
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>
76332>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76332>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76333>>>>>>>>>>>>>>>>>
76333>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76333>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76335>>>>>>>>>>>>>>>>>    
76335>>>>>>>>>>>>>>>>>    Boolean bResult
76335>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76335>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76335>>>>>>>>>>>>>>>>>
76335>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76336>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76337>>>>>>>>>>>>>>>>>    
76337>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76338>>>>>>>>>>>>>>>>>
76338>>>>>>>>>>>>>>>>>    Function_Return bResult
76339>>>>>>>>>>>>>>>>>End_Function
76340>>>>>>>>>>>>>>>>>
76340>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76341>>>>>>>>>>>>>>>>>
76341>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76342>>>>>>>>>>>>>>>>>
76342>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76343>>>>>>>>>>>>>>>>>
76343>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76344>>>>>>>>>>>>>>>>>
76344>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76345>>>>>>>>>>>>>>>>>
76345>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76346>>>>>>>>>>>>>>>>>
76346>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76347>>>>>>>>>>>>>>>>>
76347>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76348>>>>>>>>>>>>>>>>>
76348>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76349>>>>>>>>>>>>>>>>>    
76349>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76350>>>>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76351>>>>>>>>>>>>>>>>>
76351>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76352>>>>>>>>>>>>>>>>>
76352>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76353>>>>>>>>>>>>>>>>>    
76353>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76354>>>>>>>>>>>>>>>>>    
76354>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76355>>>>>>>>>>>>>>>>>    
76355>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76356>>>>>>>>>>>>>>>
76356>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76357>>>>>>>>>>>>>>>    
76357>>>>>>>>>>>>>>>    Procedure Construct_Object
76359>>>>>>>>>>>>>>>        Forward Send Construct_Object
76361>>>>>>>>>>>>>>>        
76361>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76362>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76363>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76364>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76365>>>>>>>>>>>>>>>        
76365>>>>>>>>>>>>>>>        // Private properties
76365>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76366>>>>>>>>>>>>>>>        
76366>>>>>>>>>>>>>>>        // Block cipher properties
76366>>>>>>>>>>>>>>>        Property UChar[]    paKey
76367>>>>>>>>>>>>>>>        Property UChar[]    paIV
76368>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76369>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76370>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76371>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76372>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76373>>>>>>>>>>>>>>>    End_Procedure
76374>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>    // Acquire key container handle
76374>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76376>>>>>>>>>>>>>>>        Integer iProvider
76376>>>>>>>>>>>>>>>        WString wProvider
76376>>>>>>>>>>>>>>>        Handle hProv
76376>>>>>>>>>>>>>>>        Boolean bOk
76376>>>>>>>>>>>>>>>        Pointer pProv
76376>>>>>>>>>>>>>>>        
76376>>>>>>>>>>>>>>>        Move 0 to hProv
76377>>>>>>>>>>>>>>>        Get piProvider to iProvider
76378>>>>>>>>>>>>>>>        Get psProvider to wProvider
76379>>>>>>>>>>>>>>>        
76379>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76379>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76381>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76382>>>>>>>>>>>>>>>        End
76382>>>>>>>>>>>>>>>>
76382>>>>>>>>>>>>>>>        Else Begin
76383>>>>>>>>>>>>>>>            Move 0 to pProv
76384>>>>>>>>>>>>>>>        End
76384>>>>>>>>>>>>>>>>
76384>>>>>>>>>>>>>>>        
76384>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76384>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76385>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76387>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76388>>>>>>>>>>>>>>>        End
76388>>>>>>>>>>>>>>>>
76388>>>>>>>>>>>>>>>        
76388>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76390>>>>>>>>>>>>>>>            // Fallback to original
76390>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76391>>>>>>>>>>>>>>>            
76391>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76393>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76394>>>>>>>>>>>>>>>            End
76394>>>>>>>>>>>>>>>>
76394>>>>>>>>>>>>>>>        End
76394>>>>>>>>>>>>>>>>
76394>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76395>>>>>>>>>>>>>>>        
76395>>>>>>>>>>>>>>>        Function_Return hProv
76396>>>>>>>>>>>>>>>    End_Function
76397>>>>>>>>>>>>>>>    
76397>>>>>>>>>>>>>>>    // Releases key container handle
76397>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76399>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76400>>>>>>>>>>>>>>>    End_Function
76401>>>>>>>>>>>>>>>    
76401>>>>>>>>>>>>>>>    // Creates hash object
76401>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76403>>>>>>>>>>>>>>>        Integer iAlgorithm
76403>>>>>>>>>>>>>>>        Handle hHash
76403>>>>>>>>>>>>>>>        Boolean bOk
76403>>>>>>>>>>>>>>>        
76403>>>>>>>>>>>>>>>        Move 0 to hHash
76404>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76405>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76406>>>>>>>>>>>>>>>        
76406>>>>>>>>>>>>>>>        Function_Return hHash
76407>>>>>>>>>>>>>>>    End_Function
76408>>>>>>>>>>>>>>>    
76408>>>>>>>>>>>>>>>    // Destroys the hash object
76408>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76410>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76411>>>>>>>>>>>>>>>    End_Function
76412>>>>>>>>>>>>>>>    
76412>>>>>>>>>>>>>>>    // Adds data to hash object
76412>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76414>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76415>>>>>>>>>>>>>>>    End_Function
76416>>>>>>>>>>>>>>>    
76416>>>>>>>>>>>>>>>    // Generates session key
76416>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76418>>>>>>>>>>>>>>>        Integer iAlgorithm
76418>>>>>>>>>>>>>>>        Handle hKey
76418>>>>>>>>>>>>>>>        Boolean bOk
76418>>>>>>>>>>>>>>>        
76418>>>>>>>>>>>>>>>        Move 0 to hKey
76419>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76420>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76421>>>>>>>>>>>>>>>        
76421>>>>>>>>>>>>>>>        Function_Return hKey
76422>>>>>>>>>>>>>>>    End_Function
76423>>>>>>>>>>>>>>>    
76423>>>>>>>>>>>>>>>    // Imports a plain text key
76423>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76425>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76425>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76425>>>>>>>>>>>>>>>        Boolean   bSuccess
76425>>>>>>>>>>>>>>>        Handle    hKey
76425>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76425>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76426>>>>>>>>>>>>>>>        Integer iVoid
76426>>>>>>>>>>>>>>>        
76426>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76427>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76428>>>>>>>>>>>>>>>        
76428>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76429>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76430>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76431>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76432>>>>>>>>>>>>>>>        
76432>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76433>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76434>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76435>>>>>>>>>>>>>>>        
76435>>>>>>>>>>>>>>>        Move 0 to hKey
76436>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76437>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76439>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76440>>>>>>>>>>>>>>>        End
76440>>>>>>>>>>>>>>>>
76440>>>>>>>>>>>>>>>        
76440>>>>>>>>>>>>>>>        Function_Return hKey
76441>>>>>>>>>>>>>>>    End_Function
76442>>>>>>>>>>>>>>>    
76442>>>>>>>>>>>>>>>    // Destroys the key
76442>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76444>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76445>>>>>>>>>>>>>>>    End_Function
76446>>>>>>>>>>>>>>>    
76446>>>>>>>>>>>>>>>    // Retrieves key data
76446>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76448>>>>>>>>>>>>>>>        Integer iBuffer iLen
76448>>>>>>>>>>>>>>>        Boolean bOk
76448>>>>>>>>>>>>>>>        
76448>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76449>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76450>>>>>>>>>>>>>>>        Function_Return iBuffer
76451>>>>>>>>>>>>>>>    End_Function
76452>>>>>>>>>>>>>>>    
76452>>>>>>>>>>>>>>>    // Retrieves a hash value
76452>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76454>>>>>>>>>>>>>>>        UChar[] ucHash
76455>>>>>>>>>>>>>>>        Integer liResult
76455>>>>>>>>>>>>>>>        DWord   dwDataLen
76455>>>>>>>>>>>>>>>        
76455>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76456>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76457>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76460>>>>>>>>>>>>>>>        
76460>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76461>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76462>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76465>>>>>>>>>>>>>>>        
76465>>>>>>>>>>>>>>>        Function_Return ucHash
76466>>>>>>>>>>>>>>>    End_Function
76467>>>>>>>>>>>>>>>
76467>>>>>>>>>>>>>>>    // Encrypts data
76467>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76469>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76469>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76469>>>>>>>>>>>>>>>        Boolean bOk
76469>>>>>>>>>>>>>>>        
76469>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76470>>>>>>>>>>>>>>>        If (hProv) Begin
76472>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76473>>>>>>>>>>>>>>>            If (hHash) Begin
76475>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76476>>>>>>>>>>>>>>>                If (bOk) Begin
76478>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76479>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76480>>>>>>>>>>>>>>>                End
76480>>>>>>>>>>>>>>>>
76480>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76481>>>>>>>>>>>>>>>            End
76481>>>>>>>>>>>>>>>>
76481>>>>>>>>>>>>>>>            
76481>>>>>>>>>>>>>>>            If (hKey) Begin
76483>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76483>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76484>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76485>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76486>>>>>>>>>>>>>>>                
76486>>>>>>>>>>>>>>>                //  Reserve space in string
76486>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76488>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76489>>>>>>>>>>>>>>>                End
76489>>>>>>>>>>>>>>>>
76489>>>>>>>>>>>>>>>                
76489>>>>>>>>>>>>>>>                //  Call to really decrypt
76489>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76490>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76490>>>>>>>>>>>>>>>                //Move "" to sData
76490>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76490>>>>>>>>>>>>>>>                //End
76490>>>>>>>>>>>>>>>                
76490>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76491>>>>>>>>>>>>>>>            End 
76491>>>>>>>>>>>>>>>>
76491>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76492>>>>>>>>>>>>>>>        End 
76492>>>>>>>>>>>>>>>>
76492>>>>>>>>>>>>>>>        Function_Return ucData
76493>>>>>>>>>>>>>>>    End_Function
76494>>>>>>>>>>>>>>>    
76494>>>>>>>>>>>>>>>    // Decrypts data
76494>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76496>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76496>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76496>>>>>>>>>>>>>>>        Boolean bOk
76496>>>>>>>>>>>>>>>        
76496>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76497>>>>>>>>>>>>>>>        If (hProv) Begin
76499>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76500>>>>>>>>>>>>>>>            If (hHash) Begin
76502>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76503>>>>>>>>>>>>>>>                If (bOk) Begin
76505>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76506>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76507>>>>>>>>>>>>>>>                End
76507>>>>>>>>>>>>>>>>
76507>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76508>>>>>>>>>>>>>>>            End
76508>>>>>>>>>>>>>>>>
76508>>>>>>>>>>>>>>>            
76508>>>>>>>>>>>>>>>            If (hKey) Begin
76510>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76511>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76512>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76512>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76514>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76515>>>>>>>>>>>>>>>                End
76515>>>>>>>>>>>>>>>>
76515>>>>>>>>>>>>>>>                
76515>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76516>>>>>>>>>>>>>>>            End
76516>>>>>>>>>>>>>>>>
76516>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76517>>>>>>>>>>>>>>>        End
76517>>>>>>>>>>>>>>>>
76517>>>>>>>>>>>>>>>        Function_Return ucData
76518>>>>>>>>>>>>>>>    End_Function
76519>>>>>>>>>>>>>>>    
76519>>>>>>>>>>>>>>>    // Creates a key
76519>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76521>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76521>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76521>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76521>>>>>>>>>>>>>>>        Boolean bOk
76521>>>>>>>>>>>>>>>        Handle hKey
76521>>>>>>>>>>>>>>>        UChar[] aKey
76522>>>>>>>>>>>>>>>
76522>>>>>>>>>>>>>>>        Get paKey to aKey
76523>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76524>>>>>>>>>>>>>>>        Get piKeyType to iType
76525>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76526>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76527>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76528>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76529>>>>>>>>>>>>>>>        
76529>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76530>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76536>>>>>>>>>>>>>>>>
76536>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76537>>>>>>>>>>>>>>>        Loop
76538>>>>>>>>>>>>>>>>
76538>>>>>>>>>>>>>>>        
76538>>>>>>>>>>>>>>>        Move 0 to hKey
76539>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76540>>>>>>>>>>>>>>>        Function_Return hKey
76541>>>>>>>>>>>>>>>    End_Function
76542>>>>>>>>>>>>>>>    
76542>>>>>>>>>>>>>>>    // Sets the key parameters
76542>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76544>>>>>>>>>>>>>>>        Integer iPadding iMode
76544>>>>>>>>>>>>>>>        Boolean bOk
76544>>>>>>>>>>>>>>>        UChar[] aIV
76545>>>>>>>>>>>>>>>        
76545>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76545>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76545>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76545>>>>>>>>>>>>>>>        //Loop
76545>>>>>>>>>>>>>>>
76545>>>>>>>>>>>>>>>        // Set initialization vector
76545>>>>>>>>>>>>>>>        Get paIV to aIV
76546>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76547>>>>>>>>>>>>>>>        If (bOk) Begin
76549>>>>>>>>>>>>>>>            // Set padding
76549>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76550>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76551>>>>>>>>>>>>>>>            If (bOk) Begin
76553>>>>>>>>>>>>>>>                // Set move
76553>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76554>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76555>>>>>>>>>>>>>>>            End
76555>>>>>>>>>>>>>>>>
76555>>>>>>>>>>>>>>>        End
76555>>>>>>>>>>>>>>>>
76555>>>>>>>>>>>>>>>        Function_Return bOk        
76556>>>>>>>>>>>>>>>    End_Function
76557>>>>>>>>>>>>>>>    
76557>>>>>>>>>>>>>>>    // Encrypts using block cipher
76557>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76559>>>>>>>>>>>>>>>        Handle hProv hKey
76559>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76559>>>>>>>>>>>>>>>        Boolean bOk
76559>>>>>>>>>>>>>>>        
76559>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76560>>>>>>>>>>>>>>>        If (hProv) Begin
76562>>>>>>>>>>>>>>>            // Create key
76562>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76563>>>>>>>>>>>>>>>            If (hKey) Begin
76565>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76566>>>>>>>>>>>>>>>                If (bOk) Begin
76568>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76568>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76569>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76570>>>>>>>>>>>>>>>                    
76570>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76571>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76572>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76573>>>>>>>>>>>>>>>                End
76573>>>>>>>>>>>>>>>>
76573>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76574>>>>>>>>>>>>>>>            End
76574>>>>>>>>>>>>>>>>
76574>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76575>>>>>>>>>>>>>>>        End
76575>>>>>>>>>>>>>>>>
76575>>>>>>>>>>>>>>>        Function_Return ucData
76576>>>>>>>>>>>>>>>    End_Function
76577>>>>>>>>>>>>>>>    
76577>>>>>>>>>>>>>>>    // Decrypts using block cipher
76577>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76579>>>>>>>>>>>>>>>        Handle hProv hKey
76579>>>>>>>>>>>>>>>        Integer iLen
76579>>>>>>>>>>>>>>>        Boolean bOk
76579>>>>>>>>>>>>>>>        
76579>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76580>>>>>>>>>>>>>>>        If (hProv) Begin
76582>>>>>>>>>>>>>>>            // Create key
76582>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76583>>>>>>>>>>>>>>>            If (hKey) Begin
76585>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76586>>>>>>>>>>>>>>>                If (bOk) Begin
76588>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76589>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76590>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76591>>>>>>>>>>>>>>>                End
76591>>>>>>>>>>>>>>>>
76591>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76592>>>>>>>>>>>>>>>            End
76592>>>>>>>>>>>>>>>>
76592>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76593>>>>>>>>>>>>>>>        End
76593>>>>>>>>>>>>>>>>
76593>>>>>>>>>>>>>>>        Function_Return ucData
76594>>>>>>>>>>>>>>>    End_Function
76595>>>>>>>>>>>>>>>    
76595>>>>>>>>>>>>>>>    
76595>>>>>>>>>>>>>>>    //  Generates random data.
76595>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76597>>>>>>>>>>>>>>>        Handle hProv
76597>>>>>>>>>>>>>>>        UChar[] uaResult
76598>>>>>>>>>>>>>>>        Boolean bRes
76598>>>>>>>>>>>>>>>        
76598>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76599>>>>>>>>>>>>>>>        
76599>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76600>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76601>>>>>>>>>>>>>>>        
76601>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76602>>>>>>>>>>>>>>>        
76602>>>>>>>>>>>>>>>        Function_Return uaResult
76603>>>>>>>>>>>>>>>    End_Function
76604>>>>>>>>>>>>>>>    
76604>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76604>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76606>>>>>>>>>>>>>>>        String sResult
76606>>>>>>>>>>>>>>>        UChar[] ucData
76607>>>>>>>>>>>>>>>        Pointer pBase64
76607>>>>>>>>>>>>>>>        Integer iVoid
76607>>>>>>>>>>>>>>>        
76607>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76608>>>>>>>>>>>>>>>        
76608>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76609>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76610>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76611>>>>>>>>>>>>>>>        
76611>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76612>>>>>>>>>>>>>>>    End_Function
76613>>>>>>>>>>>>>>>    
76613>>>>>>>>>>>>>>>End_Class
76614>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76614>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76614>>>>>>>>>>>>>>>//>
76614>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76614>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76614>>>>>>>>>>>>>>>//>
76614>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76614>>>>>>>>>>>>>>>//> strings.
76614>>>>>>>>>>>>>>>//>
76614>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76614>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76614>>>>>>>>>>>>>>>//>
76614>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76614>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76614>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76614>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76614>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>Use VdfBase.pkg
76614>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76614>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76615>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76616>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76617>>>>>>>>>>>>>>>
76617>>>>>>>>>>>>>>>// Structure
76617>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76617>>>>>>>>>>>>>>>    Pointer pData
76617>>>>>>>>>>>>>>>    Integer iLength
76617>>>>>>>>>>>>>>>End_Struct 
76617>>>>>>>>>>>>>>>
76617>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76617>>>>>>>>>>>>>>>
76617>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76619>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76620>>>>>>>>>>>>>>>
76620>>>>>>>>>>>>>>>
76620>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76623>>>>>>>>>>>>>>>        Address pBase64
76623>>>>>>>>>>>>>>>        String sResult
76623>>>>>>>>>>>>>>>        Integer iVoid
76623>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76624>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76625>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76626>>>>>>>>>>>>>>>        Function_Return sResult
76627>>>>>>>>>>>>>>>    End_Function
76628>>>>>>>>>>>>>>>
76628>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76631>>>>>>>>>>>>>>>        Address pBinary
76631>>>>>>>>>>>>>>>        String sBinary
76631>>>>>>>>>>>>>>>        Integer iVoid iLen
76631>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76632>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76633>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76634>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76635>>>>>>>>>>>>>>>        Function_Return sBinary
76636>>>>>>>>>>>>>>>    End_Function
76637>>>>>>>>>>>>>>>
76637>>>>>>>>>>>>>>>End_Object
76638>>>>>>>>>>>>>Use MSSqldrv.pkg
76638>>>>>>>>>>>>>Use db2_drv.pkg
76638>>>>>>>>>>>>>Use odbc_drv.pkg
76638>>>>>>>>>>>>>Use DFBtrDrv.pkg
76638>>>>>>>>>>>>>Use vWin32fh.pkg
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76638>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76638>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76638>>>>>>>>>>>>>// Note: If a new type is added to the list,
76638>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76638>>>>>>>>>>>>>//       so that it is filled with all SQL
76638>>>>>>>>>>>>>//       keywords for that new type.
76638>>>>>>>>>>>>>Enum_List  
76638>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76638>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76638>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76638>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76638>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76638>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76638>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76638>>>>>>>>>>>>>End_Enum_List
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76638>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76638>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76638>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76638>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76638>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76638>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76638>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76638>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76638>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// SQLConnection.ini constants:
76638>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76638>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76638>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76638>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// DF 19 ini-file settings:
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76638>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76638>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76638>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76638>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76638>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76638>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76638>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76638>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76638>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76638>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// Database Update Framework extended settings:
76638>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76638>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76638>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76638>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76638>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76638>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76638>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76638>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>Struct tSQLConnection
76638>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76638>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76638>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76638>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76638>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76638>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76638>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76638>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76638>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76638>>>>>>>>>>>>>    String sPassword                // 10. Password
76638>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76638>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76638>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76638>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76638>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76638>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76638>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76638>>>>>>>>>>>>>End_Struct
76638>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76638>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76638>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76638>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76638>>>>>>>>>>>>>
76638>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76638>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSQLScriptArray
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76639>>>>>>>>>>>>>    Integer iOrgArgumentSize
76639>>>>>>>>>>>>>    String[] sSQLScriptArray
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSqlErrorArray
76639>>>>>>>>>>>>>    String[]  sSqlErrorArray
76639>>>>>>>>>>>>>    String[]  sSqlStatementArray
76639>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSqlColumnNew
76639>>>>>>>>>>>>>    String  sBaseColumnName
76639>>>>>>>>>>>>>    String  sBaseTableName
76639>>>>>>>>>>>>>    String  sLabel
76639>>>>>>>>>>>>>    Integer iSqlType
76639>>>>>>>>>>>>>    Integer iSize
76639>>>>>>>>>>>>>    Integer iPrecision
76639>>>>>>>>>>>>>    Integer iDFType
76639>>>>>>>>>>>>>    Integer iDFNativeType
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tColumnType
76639>>>>>>>>>>>>>    String  sSQLType
76639>>>>>>>>>>>>>    Integer iSQLType
76639>>>>>>>>>>>>>    Boolean bCanEditSize
76639>>>>>>>>>>>>>    Integer iDefaultSize
76639>>>>>>>>>>>>>    Integer iMinSize
76639>>>>>>>>>>>>>    Number  nMaxSize
76639>>>>>>>>>>>>>    String  sDataFlexType
76639>>>>>>>>>>>>>    Integer iDataFlexType
76639>>>>>>>>>>>>>    Boolean bNativeDataType
76639>>>>>>>>>>>>>    String  sPrecision
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76639>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76639>>>>>>>>>>>>>// keywords.
76639>>>>>>>>>>>>>Struct tSQLKeyWords
76639>>>>>>>>>>>>>    Integer iSQLWord
76639>>>>>>>>>>>>>    Integer iSQLDbType
76639>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSQLRelation
76639>>>>>>>>>>>>>    Integer iFileNumber
76639>>>>>>>>>>>>>    Integer iFieldNumber
76639>>>>>>>>>>>>>    String  sFileName
76639>>>>>>>>>>>>>    String  sFieldName
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSQLLoggedInUser
76639>>>>>>>>>>>>>    String sUser
76639>>>>>>>>>>>>>    String sProgram
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76639>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76639>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76639>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76639>>>>>>>>>>>>>// Note: If a new type is added to the list,
76639>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76639>>>>>>>>>>>>>//       so that it is filled with all SQL
76639>>>>>>>>>>>>>//       keywords for that new type.
76639>>>>>>>>>>>>>Enum_List
76639>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76639>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76639>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76639>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76639>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76639>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76639>>>>>>>>>>>>>End_Enum_List
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76639>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76639>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76639>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76639>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76639>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76639>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76639>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76639>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76639>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76639>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76639>>>>>>>>>>>>>Enum_List
76639>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76639>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76639>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76639>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76639>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76639>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76639>>>>>>>>>>>>>End_Enum_List
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76639>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76639>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// These are not defined pre DF 18:
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSQLIntTableInfo
76639>>>>>>>>>>>>>    String sDriverName
76639>>>>>>>>>>>>>    String sServerName
76639>>>>>>>>>>>>>    String sDatabaseName
76639>>>>>>>>>>>>>    String sSchemaName
76639>>>>>>>>>>>>>    Boolean bRecnumTable
76639>>>>>>>>>>>>>    Integer iPrimaryIndex
76639>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76639>>>>>>>>>>>>>    String sTableCharacterFormat
76639>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76639>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76639>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76639>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76639>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76639>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76639>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76639>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76639>>>>>>>>>>>>>    String sFileIndexTablespace
76639>>>>>>>>>>>>>    String sFileLongTablespace
76639>>>>>>>>>>>>>    String sTableTablespace
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76639>>>>>>>>>>>>>    Integer iFieldNumber
76639>>>>>>>>>>>>>    Integer iFieldIndex
76639>>>>>>>>>>>>>    Integer iFieldRelatedFile
76639>>>>>>>>>>>>>    Integer iFieldRelatedField
76639>>>>>>>>>>>>>    Integer iIndexNumber
76639>>>>>>>>>>>>>    Integer iIndexNumberSegments
76639>>>>>>>>>>>>>    Integer iIndexSegmentField1
76639>>>>>>>>>>>>>    Integer iIndexSegmentField2
76639>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76639>>>>>>>>>>>>>    String  sIndexName
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIColumn
76639>>>>>>>>>>>>>    Integer iFieldNumber
76639>>>>>>>>>>>>>    String  sFieldName
76639>>>>>>>>>>>>>    Integer iType
76639>>>>>>>>>>>>>    String  sType
76639>>>>>>>>>>>>>    Integer iLength
76639>>>>>>>>>>>>>    Integer iPrecision
76639>>>>>>>>>>>>>    Integer iOptions
76639>>>>>>>>>>>>>    Boolean bIsSQLType
76639>>>>>>>>>>>>>    Boolean bAllowNULL
76639>>>>>>>>>>>>>    String  sDefaultValue
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIColumnCompare
76639>>>>>>>>>>>>>    Integer iFieldNumber
76639>>>>>>>>>>>>>    // FROM database:
76639>>>>>>>>>>>>>    Boolean bExistsFrom
76639>>>>>>>>>>>>>    String  sFieldNameFrom
76639>>>>>>>>>>>>>    Integer iTypeFrom
76639>>>>>>>>>>>>>    String  sTypeFrom
76639>>>>>>>>>>>>>    Integer iLengthFrom
76639>>>>>>>>>>>>>    Integer iPrecisionFrom
76639>>>>>>>>>>>>>    Integer iOptionsFrom
76639>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76639>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76639>>>>>>>>>>>>>    String  sDefaultValueFrom
76639>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76639>>>>>>>>>>>>>    Boolean bCancelFrom
76639>>>>>>>>>>>>>    Boolean bErrorFrom
76639>>>>>>>>>>>>>    // TO database:
76639>>>>>>>>>>>>>    Boolean bExistsTo
76639>>>>>>>>>>>>>    Integer iFieldNumberTo
76639>>>>>>>>>>>>>    String  sFieldNameTo
76639>>>>>>>>>>>>>    Integer iTypeTo
76639>>>>>>>>>>>>>    String  sTypeTo
76639>>>>>>>>>>>>>    Integer iLengthTo
76639>>>>>>>>>>>>>    Integer iPrecisionTo
76639>>>>>>>>>>>>>    Integer iOptionsTo
76639>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76639>>>>>>>>>>>>>    Boolean bAllowNULLTo
76639>>>>>>>>>>>>>    String  sDefaultValueTo
76639>>>>>>>>>>>>>    Boolean bShouldChangeTo
76639>>>>>>>>>>>>>    Boolean bCancelTo
76639>>>>>>>>>>>>>    Boolean bErrorTo
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIRelation
76639>>>>>>>>>>>>>    Handle  hTableFrom
76639>>>>>>>>>>>>>    Integer iColumnFrom
76639>>>>>>>>>>>>>    Handle  hTableTo
76639>>>>>>>>>>>>>    Integer iColumnTo
76639>>>>>>>>>>>>>    String  sLogicalNameFrom
76639>>>>>>>>>>>>>    String  sLogicalNameTo
76639>>>>>>>>>>>>>    String  sFieldNameFrom
76639>>>>>>>>>>>>>    String  sFieldNameTo
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIRelationCompare
76639>>>>>>>>>>>>>    // Common:
76639>>>>>>>>>>>>>    Handle  hTableFrom
76639>>>>>>>>>>>>>    Integer iColumnFrom
76639>>>>>>>>>>>>>    Handle  hTableTo
76639>>>>>>>>>>>>>    Integer iColumnTo
76639>>>>>>>>>>>>>    // FROM database:
76639>>>>>>>>>>>>>    Boolean bExistsFrom
76639>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76639>>>>>>>>>>>>>    String  sLogicalNameTo_From
76639>>>>>>>>>>>>>    String  sFieldNameFrom_From
76639>>>>>>>>>>>>>    String  sFieldNameTo_From
76639>>>>>>>>>>>>>    Boolean bShouldChange_From
76639>>>>>>>>>>>>>    Boolean bCancel_From
76639>>>>>>>>>>>>>    Boolean bError_From
76639>>>>>>>>>>>>>    // TO database:
76639>>>>>>>>>>>>>    Boolean bExistsTo
76639>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76639>>>>>>>>>>>>>    String  sLogicalNameTo_To
76639>>>>>>>>>>>>>    String  sFieldNameFrom_To
76639>>>>>>>>>>>>>    String  sFieldNameTo_To
76639>>>>>>>>>>>>>    Boolean bShouldChange_To
76639>>>>>>>>>>>>>    Boolean bCancel_To
76639>>>>>>>>>>>>>    Boolean bError_To
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIIndexSegment
76639>>>>>>>>>>>>>    Integer iFieldNumber
76639>>>>>>>>>>>>>    String  sFieldName
76639>>>>>>>>>>>>>    Boolean bUppercase
76639>>>>>>>>>>>>>    Boolean bAscending
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIIndex
76639>>>>>>>>>>>>>    Integer iIndexNumber
76639>>>>>>>>>>>>>    Integer iPrimaryIndex
76639>>>>>>>>>>>>>    String  sSQLIndexName
76639>>>>>>>>>>>>>    Integer iSQLIndexType
76639>>>>>>>>>>>>>    Boolean bIsSQLClustered
76639>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPIIndexCompare
76639>>>>>>>>>>>>>    // Common:
76639>>>>>>>>>>>>>    Integer iIndexNumber
76639>>>>>>>>>>>>>    // FROM database:
76639>>>>>>>>>>>>>    Boolean bExistsFrom
76639>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76639>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76639>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76639>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76639>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76639>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76639>>>>>>>>>>>>>    Boolean bCancelFrom
76639>>>>>>>>>>>>>    Boolean bErrorFrom
76639>>>>>>>>>>>>>    // TO database:
76639>>>>>>>>>>>>>    Boolean bExistsTo
76639>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76639>>>>>>>>>>>>>    String  sSQLIndexNameTo
76639>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76639>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76639>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76639>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76639>>>>>>>>>>>>>    Boolean bShouldChangeTo
76639>>>>>>>>>>>>>    Boolean bCancelTo
76639>>>>>>>>>>>>>    Boolean bErrorTo
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPITableNameInfo
76639>>>>>>>>>>>>>    Integer iTableNumber
76639>>>>>>>>>>>>>    String  sRootName
76639>>>>>>>>>>>>>    String  sLogicalName
76639>>>>>>>>>>>>>    String  sDisplayName
76639>>>>>>>>>>>>>    String  sDriverID
76639>>>>>>>>>>>>>    Boolean bIsAlias
76639>>>>>>>>>>>>>    Boolean bIsSQL
76639>>>>>>>>>>>>>    Boolean bIsSystemFile
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76639>>>>>>>>>>>>>    Integer iTableNumber
76639>>>>>>>>>>>>>    // FROM
76639>>>>>>>>>>>>>    Boolean bExistsFrom
76639>>>>>>>>>>>>>    String  sRootNameFrom
76639>>>>>>>>>>>>>    String  sLogicalNameFrom
76639>>>>>>>>>>>>>    String  sDisplayNameFrom
76639>>>>>>>>>>>>>    String  sDriverIDFrom
76639>>>>>>>>>>>>>    Boolean bIsAliasFrom
76639>>>>>>>>>>>>>    Boolean bIsSQLFrom
76639>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76639>>>>>>>>>>>>>    // TO database:
76639>>>>>>>>>>>>>    Boolean bExistsTo
76639>>>>>>>>>>>>>    String  sRootNameTo
76639>>>>>>>>>>>>>    String  sLogicalNameTo
76639>>>>>>>>>>>>>    String  sDisplayNameTo
76639>>>>>>>>>>>>>    String  sDriverIDTo
76639>>>>>>>>>>>>>    Boolean bIsAliasTo
76639>>>>>>>>>>>>>    Boolean bIsSQLTo
76639>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPITable
76639>>>>>>>>>>>>>    Handle hTable
76639>>>>>>>>>>>>>    Boolean bFromTable
76639>>>>>>>>>>>>>    Boolean bToTable
76639>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76639>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76639>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76639>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76639>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76639>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76639>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76639>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76639>>>>>>>>>>>>>    Boolean bShouldChange
76639>>>>>>>>>>>>>    Boolean bCancel
76639>>>>>>>>>>>>>    Boolean bError
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPITableCompare
76639>>>>>>>>>>>>>    Handle hTable
76639>>>>>>>>>>>>>    // FROM database:
76639>>>>>>>>>>>>>    Boolean bExistsFrom
76639>>>>>>>>>>>>>    // TO database:
76639>>>>>>>>>>>>>    Boolean bExistsTo
76639>>>>>>>>>>>>>    // Both:
76639>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76639>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76639>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76639>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76639>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76639>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76639>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76639>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76639>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76639>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76639>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Struct tAPITableBooleans
76639>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76639>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76639>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76639>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76639>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76639>>>>>>>>>>>>>End_Struct
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76639>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76639>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76639>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76639>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76639>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76639>>>>>>>>>>>>>Enum_List
76639>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76639>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76639>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76639>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76639>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76639>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76639>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76639>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76639>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76639>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76639>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76639>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76639>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76639>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76639>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76639>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76639>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76639>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76639>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76639>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76639>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76639>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76639>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76639>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76639>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76639>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76639>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76639>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76639>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76639>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76639>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76639>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76639>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76639>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76639>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76639>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76639>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76639>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76639>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76639>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76639>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76639>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76639>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76639>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76639>>>>>>>>>>>>>End_Enum_List
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>>>
76639>>>>>>>>>>>
76639>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76640>>>>>>>>>>>
76640>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76642>>>>>>>>>>>        Handle hoSQLManagerMT
76642>>>>>>>>>>>
76642>>>>>>>>>>>        Property String private.psUseDatabase ""
76643>>>>>>>>>>>
76643>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76643>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76644>>>>>>>>>>>        Property Integer private.piCurrentField 0
76645>>>>>>>>>>>
76645>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76646>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76647>>>>>>>>>>>
76647>>>>>>>>>>>        Property Handle phoSQLManagerMT
76648>>>>>>>>>>>
76648>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76649>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76650>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76651>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76652>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76653>>>>>>>>>>>
76653>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76654>>>>>>>>>>>
76654>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76655>>>>>>>>>>>        Property String[] paSQLFetchResults
76656>>>>>>>>>>>
76656>>>>>>>>>>>        // Error handling
76656>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76657>>>>>>>>>>>        Property Boolean pbSqlError False
76658>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76659>>>>>>>>>>>        Property Boolean pbProcessingError False
76660>>>>>>>>>>>
76660>>>>>>>>>>>        // Statistics on query
76660>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76661>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76662>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76663>>>>>>>>>>>        Property Integer piColumns 0
76664>>>>>>>>>>>        Property Integer piRows 0
76665>>>>>>>>>>>        Property Integer piRowType 0
76666>>>>>>>>>>>        Property String[] paQueryMessages
76667>>>>>>>>>>>        Property String psSQLStatementString
76668>>>>>>>>>>>
76668>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76669>>>>>>>>>>>
76669>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76670>>>>>>>>>>>
76670>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76670>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76670>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76670>>>>>>>>>>>        Property Integer piChunkMax 500
76671>>>>>>>>>>>
76671>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76671>>>>>>>>>>>        Send SetupSQLKeywordArray
76672>>>>>>>>>>>    End_Procedure
76673>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76673>>>>>>>>>>>>
76673>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76675>>>>>>>>>>>>    Integer iStart iEnd
76675>>>>>>>>>>>>    String sRetval
76675>>>>>>>>>>>>
76675>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76676>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76677>>>>>>>>>>>>    If (iStart = 0) Begin
76679>>>>>>>>>>>>        Function_Return ""
76680>>>>>>>>>>>>    End
76680>>>>>>>>>>>>>
76680>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76681>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76682>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76684>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76685>>>>>>>>>>>>    End
76685>>>>>>>>>>>>>
76685>>>>>>>>>>>>    Else Begin
76686>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76687>>>>>>>>>>>>    End
76687>>>>>>>>>>>>>
76687>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76689>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76690>>>>>>>>>>>>        Decrement iEnd
76691>>>>>>>>>>>>    End
76691>>>>>>>>>>>>>
76691>>>>>>>>>>>>    If (iEnd <> 0) Begin
76693>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76694>>>>>>>>>>>>    End
76694>>>>>>>>>>>>>
76694>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76695>>>>>>>>>>>>
76695>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76696>>>>>>>>>>>>End_Function
76697>>>>>>>>>>>>
76697>>>>>>>>>>>>
76697>>>>>>>>>>>
76697>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76697>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76699>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76701>>>>>>>>>>>            Function_Return (EQ)
76702>>>>>>>>>>>        End
76702>>>>>>>>>>>>
76702>>>>>>>>>>>        Function_Return (GT)
76703>>>>>>>>>>>    End_Function
76704>>>>>>>>>>>
76704>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76704>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76706>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76709>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76712>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76715>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76718>>>>>>>>>>>
76718>>>>>>>>>>>        Function_Return (EQ)
76719>>>>>>>>>>>    End_Function
76720>>>>>>>>>>>
76720>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76722>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76722>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76723>>>>>>>>>>>        Integer iSize
76723>>>>>>>>>>>
76723>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76724>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76725>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76726>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76727>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76728>>>>>>>>>>>
76728>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76729>>>>>>>>>>>    End_Procedure
76730>>>>>>>>>>>
76730>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76730>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76730>>>>>>>>>>>    // have slightly different wording.
76730>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76730>>>>>>>>>>>    // needs to be done for every keyword group below.
76730>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76732>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76732>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76734>>>>>>>>>>>
76734>>>>>>>>>>>        // This should only be called once; but in case it is
76734>>>>>>>>>>>        // we delete the array first.
76734>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76735>>>>>>>>>>>
76735>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76735>>>>>>>>>>>        //
76735>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76736>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76737>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76738>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76739>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76740>>>>>>>>>>>
76740>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76741>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76742>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76743>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76744>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76745>>>>>>>>>>>
76745>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76746>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76747>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76748>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76749>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76750>>>>>>>>>>>
76750>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76751>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76752>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76753>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76754>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76755>>>>>>>>>>>
76755>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76756>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76757>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76758>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76759>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76760>>>>>>>>>>>
76760>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76761>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76762>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76763>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76764>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76765>>>>>>>>>>>
76765>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76766>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76767>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76768>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76769>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76770>>>>>>>>>>>
76770>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76771>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76772>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76773>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76774>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76775>>>>>>>>>>>
76775>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76776>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76777>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76778>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76779>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76780>>>>>>>>>>>
76780>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76781>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76782>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76783>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76784>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76785>>>>>>>>>>>
76785>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76786>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76787>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76788>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76789>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76790>>>>>>>>>>>
76790>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76791>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76792>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76793>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76794>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76795>>>>>>>>>>>
76795>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76796>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76797>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76798>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76799>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76800>>>>>>>>>>>
76800>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76801>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76802>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76803>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76804>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76805>>>>>>>>>>>
76805>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76806>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76807>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76808>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76809>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76810>>>>>>>>>>>
76810>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76811>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76812>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76813>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76814>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76815>>>>>>>>>>>
76815>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76819>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76820>>>>>>>>>>>
76820>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76821>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76822>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76824>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76825>>>>>>>>>>>
76825>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76826>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76827>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76828>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76829>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76830>>>>>>>>>>>
76830>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76831>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76832>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76833>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76834>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76835>>>>>>>>>>>
76835>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76836>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76837>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76838>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76839>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76840>>>>>>>>>>>
76840>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76841>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76842>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76843>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76844>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76845>>>>>>>>>>>
76845>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76846>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76847>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76848>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76849>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76850>>>>>>>>>>>
76850>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76851>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76852>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76853>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76854>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76855>>>>>>>>>>>
76855>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76856>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76857>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76858>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76859>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76860>>>>>>>>>>>
76860>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76861>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76862>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76863>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76864>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76865>>>>>>>>>>>
76865>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76866>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76867>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76868>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76869>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76870>>>>>>>>>>>
76870>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76871>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76872>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76873>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76874>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76875>>>>>>>>>>>
76875>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76876>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76877>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76878>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76879>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76880>>>>>>>>>>>
76880>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76881>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76882>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76883>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76884>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76885>>>>>>>>>>>
76885>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76886>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76887>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76888>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76889>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76890>>>>>>>>>>>
76890>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76891>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76892>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76893>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76894>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76895>>>>>>>>>>>
76895>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76896>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76897>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76898>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76899>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76900>>>>>>>>>>>
76900>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76901>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76902>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76903>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76904>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76905>>>>>>>>>>>
76905>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76906>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76907>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76908>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76909>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76910>>>>>>>>>>>
76910>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76911>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76912>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76913>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76914>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76915>>>>>>>>>>>
76915>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76916>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76917>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76918>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76919>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76920>>>>>>>>>>>
76920>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76921>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76922>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76923>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76924>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76925>>>>>>>>>>>
76925>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76926>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76927>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76928>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76929>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76930>>>>>>>>>>>
76930>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76931>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76932>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76933>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76934>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76935>>>>>>>>>>>
76935>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76936>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76937>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76938>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76939>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76940>>>>>>>>>>>
76940>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76941>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76942>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76943>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76944>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76945>>>>>>>>>>>
76945>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76946>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76947>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76948>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76949>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76950>>>>>>>>>>>
76950>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76951>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76952>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76953>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76954>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76955>>>>>>>>>>>
76955>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76955>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76956>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76957>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76958>>>>>>>>>>>
76958>>>>>>>>>>>    End_Procedure
76959>>>>>>>>>>>
76959>>>>>>>>>>>End_Class
76960>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76960>>>>>>>>>>>//****************************************************************************
76960>>>>>>>>>>>// $Module type: Class
76960>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76960>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76960>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76960>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76960>>>>>>>>>>>//
76960>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76960>>>>>>>>>>>//
76960>>>>>>>>>>>// $Rev History:
76960>>>>>>>>>>>//    2015-08-11  Module header created
76960>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76960>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76960>>>>>>>>>>>//                Added better error handling.
76960>>>>>>>>>>>//                Added a decompose message for the connection string.
76960>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76960>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76960>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76960>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76960>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76960>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76960>>>>>>>>>>>//****************************************************************************
76960>>>>>>>>>>>Use cli.pkg
76960>>>>>>>>>>>Use MSSqldrv.pkg
76960>>>>>>>>>>>Use db2_drv.pkg
76960>>>>>>>>>>>Use odbc_drv.pkg
76960>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76960>>>>>>>>>>>>>//****************************************************************************
76960>>>>>>>>>>>>>// $Module type: Class
76960>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76960>>>>>>>>>>>>>//
76960>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76960>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76960>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76960>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76960>>>>>>>>>>>>>//
76960>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76960>>>>>>>>>>>>>//
76960>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76960>>>>>>>>>>>>>//               properties of that object.
76960>>>>>>>>>>>>>//
76960>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76960>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76960>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76960>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76960>>>>>>>>>>>>>// in the help folder for more details.
76960>>>>>>>>>>>>>//
76960>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76960>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76960>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76960>>>>>>>>>>>>>>>
76960>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76961>>>>>>>>>>>>>>>    Procedure Construct_Object
76963>>>>>>>>>>>>>>>        Forward Send Construct_Object
76965>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76966>>>>>>>>>>>>>>>    End_Procedure
76967>>>>>>>>>>>>>>>
76967>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76969>>>>>>>>>>>>>>>        String sRetval
76969>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76971>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76972>>>>>>>>>>>>>>>        End                                        
76972>>>>>>>>>>>>>>>>
76972>>>>>>>>>>>>>>>        Else Begin
76973>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76974>>>>>>>>>>>>>>>        End
76974>>>>>>>>>>>>>>>>
76974>>>>>>>>>>>>>>>            
76974>>>>>>>>>>>>>>>        Function_Return sRetval
76975>>>>>>>>>>>>>>>    End_Function
76976>>>>>>>>>>>>>>>
76976>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76978>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76978>>>>>>>>>>>>>>>        Integer iClientVersion
76978>>>>>>>>>>>>>>>        
76978>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76979>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76980>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76981>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76983>>>>>>>>>>>>>>>            Move "" to sDatabase
76984>>>>>>>>>>>>>>>        End
76984>>>>>>>>>>>>>>>>
76984>>>>>>>>>>>>>>>        
76984>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
76986>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76987>>>>>>>>>>>>>>>        End
76987>>>>>>>>>>>>>>>>
76987>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
76989>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76990>>>>>>>>>>>>>>>        End
76990>>>>>>>>>>>>>>>>
76990>>>>>>>>>>>>>>>        Else Begin
76991>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76992>>>>>>>>>>>>>>>        End
76992>>>>>>>>>>>>>>>>
76992>>>>>>>>>>>>>>>        
76992>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
76994>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
76995>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
76997>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76998>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
76999>>>>>>>>>>>>>>>            End
76999>>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>        End
76999>>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>        
76999>>>>>>>>>>>>>>>        Function_Return sConnect
77000>>>>>>>>>>>>>>>    End_Function
77001>>>>>>>>>>>>>>>
77001>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77003>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77003>>>>>>>>>>>>>>>        String sDriverID
77003>>>>>>>>>>>>>>>
77003>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77004>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77006>>>>>>>>>>>>>>>            Function_Return True
77007>>>>>>>>>>>>>>>        End
77007>>>>>>>>>>>>>>>>
77007>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77008>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77010>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77011>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77013>>>>>>>>>>>>>>>        End
77013>>>>>>>>>>>>>>>>
77013>>>>>>>>>>>>>>>        Else Begin
77014>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77016>>>>>>>>>>>>>>>        End
77016>>>>>>>>>>>>>>>>
77016>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77017>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77018>>>>>>>>>>>>>>>    End_Function
77019>>>>>>>>>>>>>>>
77019>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77021>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77021>>>>>>>>>>>>>>>        String sDriver
77021>>>>>>>>>>>>>>>        
77021>>>>>>>>>>>>>>>        Move 0 to iDriver
77022>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77025>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77027>>>>>>>>>>>>>>>            Load_Driver sDriverID
77028>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77031>>>>>>>>>>>>>>>        End
77031>>>>>>>>>>>>>>>>
77031>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77037>>>>>>>>>>>>>>>>
77037>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77040>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77042>>>>>>>>>>>>>>>                Move iCount to iDriver
77043>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77044>>>>>>>>>>>>>>>            End
77044>>>>>>>>>>>>>>>>
77044>>>>>>>>>>>>>>>        Loop
77045>>>>>>>>>>>>>>>>
77045>>>>>>>>>>>>>>>    
77045>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77045>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77047>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77050>>>>>>>>>>>>>>>        End
77050>>>>>>>>>>>>>>>>
77050>>>>>>>>>>>>>>>        Function_Return iClientVersion
77051>>>>>>>>>>>>>>>    End_Function
77052>>>>>>>>>>>>>>>    
77052>>>>>>>>>>>>>>>End_Class
77053>>>>>>>>>>>>>>>
77053>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77054>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77056>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77057>>>>>>>>>>>>>>>    End_Function
77058>>>>>>>>>>>>>>>
77058>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77060>>>>>>>>>>>>>>>        Integer iClientVersion
77060>>>>>>>>>>>>>>>        String sConnect
77060>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77060>>>>>>>>>>>>>>>        
77060>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77061>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77063>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77064>>>>>>>>>>>>>>>        End
77064>>>>>>>>>>>>>>>>
77064>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77066>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77067>>>>>>>>>>>>>>>        End
77067>>>>>>>>>>>>>>>>
77067>>>>>>>>>>>>>>>        Else Begin
77068>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77069>>>>>>>>>>>>>>>        End
77069>>>>>>>>>>>>>>>>
77069>>>>>>>>>>>>>>>
77069>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77070>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77072>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77073>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77074>>>>>>>>>>>>>>>        End
77074>>>>>>>>>>>>>>>>
77074>>>>>>>>>>>>>>>        
77074>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77076>>>>>>>>>>>>>>>
77076>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77077>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77078>>>>>>>>>>>>>>>    End_Function
77079>>>>>>>>>>>>>>>
77079>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77081>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77081>>>>>>>>>>>>>>>        String sDriver
77081>>>>>>>>>>>>>>>        
77081>>>>>>>>>>>>>>>        Move 0 to iDriver
77082>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77085>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77087>>>>>>>>>>>>>>>            Load_Driver sDriverID
77088>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77091>>>>>>>>>>>>>>>        End
77091>>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77097>>>>>>>>>>>>>>>>
77097>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77100>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77102>>>>>>>>>>>>>>>                Move iCount to iDriver
77103>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77104>>>>>>>>>>>>>>>            End
77104>>>>>>>>>>>>>>>>
77104>>>>>>>>>>>>>>>        Loop
77105>>>>>>>>>>>>>>>>
77105>>>>>>>>>>>>>>>    
77105>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77105>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77107>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77110>>>>>>>>>>>>>>>        End
77110>>>>>>>>>>>>>>>>
77110>>>>>>>>>>>>>>>        Function_Return iClientVersion
77111>>>>>>>>>>>>>>>    End_Function
77112>>>>>>>>>>>>>>>    
77112>>>>>>>>>>>>>>>End_Class
77113>>>>>>>>>>>>>>>
77113>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77114>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77116>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77116>>>>>>>>>>>>>>>        String sDriverID
77116>>>>>>>>>>>>>>>
77116>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77117>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77118>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77120>>>>>>>>>>>>>>>            Function_Return True
77121>>>>>>>>>>>>>>>        End
77121>>>>>>>>>>>>>>>>
77121>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77122>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77124>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77126>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77127>>>>>>>>>>>>>>>            End
77127>>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77130>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77131>>>>>>>>>>>>>>>            End
77131>>>>>>>>>>>>>>>>
77131>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77133>>>>>>>>>>>>>>>        End
77133>>>>>>>>>>>>>>>>
77133>>>>>>>>>>>>>>>        Else Begin
77134>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77136>>>>>>>>>>>>>>>        End
77136>>>>>>>>>>>>>>>>
77136>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77137>>>>>>>>>>>>>>>
77137>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77138>>>>>>>>>>>>>>>    End_Function
77139>>>>>>>>>>>>>>>End_Class
77140>>>>>>>>>>>>>>>
77140>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77141>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77143>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77143>>>>>>>>>>>>>>>        String sDriverID
77143>>>>>>>>>>>>>>>
77143>>>>>>>>>>>>>>>        Move False to Err
77144>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77145>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77147>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77148>>>>>>>>>>>>>>>        End
77148>>>>>>>>>>>>>>>>
77148>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77150>>>>>>>>>>>>>>>
77150>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77151>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77152>>>>>>>>>>>>>>>    End_Function
77153>>>>>>>>>>>>>>>End_Class
77154>>>>>>>>>>>>>>>
77154>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77155>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77157>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77157>>>>>>>>>>>>>>>        String sDriverID
77157>>>>>>>>>>>>>>>
77157>>>>>>>>>>>>>>>        Move False to Err
77158>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77159>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77159>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77159>>>>>>>>>>>>>>>//        End
77159>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77161>>>>>>>>>>>>>>>
77161>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77162>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77163>>>>>>>>>>>>>>>    End_Function
77164>>>>>>>>>>>>>>>End_Class
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77166>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77168>>>>>>>>>>>>>>>        Function_Return ""
77169>>>>>>>>>>>>>>>    End_Function
77170>>>>>>>>>>>>>>>End_Class
77171>>>>>>>>>>>>>>>
77171>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77172>>>>>>>>>>>>>>>    Procedure Construct_Object
77174>>>>>>>>>>>>>>>        Forward Send Construct_Object
77176>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77177>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77178>>>>>>>>>>>>>>>    End_Procedure
77179>>>>>>>>>>>>>>>
77179>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77181>>>>>>>>>>>>>>>        String sDriverID sObjectName
77181>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77181>>>>>>>>>>>>>>>
77181>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77182>>>>>>>>>>>>>>>        Case Begin
77182>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77184>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77185>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77186>>>>>>>>>>>>>>>                Case Break
77187>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77190>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77191>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77192>>>>>>>>>>>>>>>                Case Break
77193>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77196>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77197>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77198>>>>>>>>>>>>>>>                Case Break               
77199>>>>>>>>>>>>>>>            Case Else
77199>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77199>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77200>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77201>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77202>>>>>>>>>>>>>>>        Case End
77202>>>>>>>>>>>>>>>
77202>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77203>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77204>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77205>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77206>>>>>>>>>>>>>>>
77206>>>>>>>>>>>>>>>        Function_Return hoDriver
77207>>>>>>>>>>>>>>>    End_Function
77208>>>>>>>>>>>>>>>
77208>>>>>>>>>>>>>>>    Procedure DestroyDriver
77210>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77212>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77213>>>>>>>>>>>>>>>        End
77213>>>>>>>>>>>>>>>>
77213>>>>>>>>>>>>>>>    End_Procedure
77214>>>>>>>>>>>>>>>
77214>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77216>>>>>>>>>>>>>>>        String sConnect
77216>>>>>>>>>>>>>>>        Handle hoDriver
77216>>>>>>>>>>>>>>>
77216>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77217>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77219>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77220>>>>>>>>>>>>>>>        End
77220>>>>>>>>>>>>>>>>
77220>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77221>>>>>>>>>>>>>>>        Send DestroyDriver
77222>>>>>>>>>>>>>>>        Function_Return sConnect
77223>>>>>>>>>>>>>>>    End_Function
77224>>>>>>>>>>>>>>>
77224>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77226>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77226>>>>>>>>>>>>>>>        Handle hoDriver
77226>>>>>>>>>>>>>>>
77226>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77227>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77229>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77230>>>>>>>>>>>>>>>        End
77230>>>>>>>>>>>>>>>>
77230>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77231>>>>>>>>>>>>>>>        Send DestroyDriver
77232>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77233>>>>>>>>>>>>>>>    End_Function
77234>>>>>>>>>>>>>>>
77234>>>>>>>>>>>>>>>End_Class
77235>>>>>>>>>>>>>
77235>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77235>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77235>>>>>>>>>>>>>>>
77235>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77236>>>>>>>>>>>>>>>    
77236>>>>>>>>>>>>>>>    Procedure Construct_Object
77238>>>>>>>>>>>>>>>        Forward Send Construct_Object
77240>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77240>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77241>>>>>>>>>>>>>>>        
77241>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77243>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77244>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77245>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77246>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77247>>>>>>>>>>>>>>>        End_Object
77248>>>>>>>>>>>>>>>    End_Procedure
77249>>>>>>>>>>>>>>>    
77249>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77249>>>>>>>>>>>>>>>    // hidden mechanism desired.
77249>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77251>>>>>>>>>>>>>>>        String sPassword
77251>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77252>>>>>>>>>>>>>>>        Function_Return sPassword
77253>>>>>>>>>>>>>>>    End_Function
77254>>>>>>>>>>>>>>>    
77254>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77254>>>>>>>>>>>>>>>    //
77254>>>>>>>>>>>>>>>    // Params:
77254>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77254>>>>>>>>>>>>>>>    // Returns:
77254>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77254>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77256>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77256>>>>>>>>>>>>>>>        UChar[] ucBinary
77257>>>>>>>>>>>>>>>        Pointer pBase64
77257>>>>>>>>>>>>>>>        Integer iVoid
77257>>>>>>>>>>>>>>>        
77257>>>>>>>>>>>>>>>        //  Encrypt Key
77257>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77258>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77260>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77261>>>>>>>>>>>>>>>>
77261>>>>>>>>>>>>>>>        End
77261>>>>>>>>>>>>>>>>
77261>>>>>>>>>>>>>>>        
77261>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77262>>>>>>>>>>>>>>>        
77262>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77264>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77265>>>>>>>>>>>>>>>>
77265>>>>>>>>>>>>>>>            Function_Return ""
77266>>>>>>>>>>>>>>>        End
77266>>>>>>>>>>>>>>>>
77266>>>>>>>>>>>>>>>        
77266>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77266>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77267>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77268>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77269>>>>>>>>>>>>>>>        
77269>>>>>>>>>>>>>>>        Function_Return sBase64
77270>>>>>>>>>>>>>>>    End_Function
77271>>>>>>>>>>>>>>>    
77271>>>>>>>>>>>>>>>    
77271>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77271>>>>>>>>>>>>>>>    //
77271>>>>>>>>>>>>>>>    // Params:
77271>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77271>>>>>>>>>>>>>>>    // Returns:
77271>>>>>>>>>>>>>>>    //   Readable plain text password
77271>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77273>>>>>>>>>>>>>>>        String sEncryptPassword
77273>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77275>>>>>>>>>>>>>>>        Boolean bIsHex
77275>>>>>>>>>>>>>>>        Integer iLen iVoid
77275>>>>>>>>>>>>>>>        Pointer pBinary
77275>>>>>>>>>>>>>>>        
77275>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77277>>>>>>>>>>>>>>>            //  Decode from Base64
77277>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77278>>>>>>>>>>>>>>>            
77278>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77279>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77280>>>>>>>>>>>>>>>                        
77280>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77281>>>>>>>>>>>>>>>            
77281>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77281>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77282>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77283>>>>>>>>>>>>>>>        End
77283>>>>>>>>>>>>>>>>
77283>>>>>>>>>>>>>>>        
77283>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77284>>>>>>>>>>>>>>>    End_Function
77285>>>>>>>>>>>>>>>End_Class
77286>>>>>>>>>>>>>
77286>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77287>>>>>>>>>>>>>    Procedure Construct_Object
77289>>>>>>>>>>>>>        Forward Send Construct_Object
77291>>>>>>>>>>>>>
77291>>>>>>>>>>>>>        Property String Private_psIniFilePath
77292>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77293>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77294>>>>>>>>>>>>>
77294>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77295>>>>>>>>>>>>>
77295>>>>>>>>>>>>>        // *** You really want to change this value! ***
77295>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77295>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77296>>>>>>>>>>>>>
77296>>>>>>>>>>>>>    End_Procedure
77297>>>>>>>>>>>>>
77297>>>>>>>>>>>>>    Procedure End_Construct_Object
77299>>>>>>>>>>>>>        Forward Send End_Construct_Object
77301>>>>>>>>>>>>>    End_Procedure
77302>>>>>>>>>>>>>
77302>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77304>>>>>>>>>>>>>        String sIniFile
77304>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77305>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77306>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77307>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77308>>>>>>>>>>>>>    End_Procedure
77309>>>>>>>>>>>>>
77309>>>>>>>>>>>>>    Function psIniFilePath Returns String
77311>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77312>>>>>>>>>>>>>    End_Function
77313>>>>>>>>>>>>>
77313>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77315>>>>>>>>>>>>>        String sPath
77315>>>>>>>>>>>>>        Get psIniFilePath to sPath
77316>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77317>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77318>>>>>>>>>>>>>    End_Procedure
77319>>>>>>>>>>>>>
77319>>>>>>>>>>>>>    Function psIniFileName Returns String
77321>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77322>>>>>>>>>>>>>    End_Function
77323>>>>>>>>>>>>>
77323>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77323>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77323>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77323>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77325>>>>>>>>>>>>>        String sIniFile sPath
77325>>>>>>>>>>>>>
77325>>>>>>>>>>>>>        Get psIniFilePath to sPath
77326>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77327>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77328>>>>>>>>>>>>>        Set psFileName to sIniFile
77329>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77330>>>>>>>>>>>>>    End_Procedure
77331>>>>>>>>>>>>>
77331>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77331>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77331>>>>>>>>>>>>>    // Returns the value
77331>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77333>>>>>>>>>>>>>        String sValue sIniFile sPath
77333>>>>>>>>>>>>>
77333>>>>>>>>>>>>>        Get psIniFilePath to sPath
77334>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77335>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77336>>>>>>>>>>>>>        Set psFileName to sIniFile
77337>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77338>>>>>>>>>>>>>
77338>>>>>>>>>>>>>        Function_Return sValue
77339>>>>>>>>>>>>>    End_Function
77340>>>>>>>>>>>>>
77340>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77340>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77342>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77345>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77348>>>>>>>>>>>>>
77348>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77351>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77354>>>>>>>>>>>>>
77354>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77357>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77360>>>>>>>>>>>>>
77360>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77363>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77366>>>>>>>>>>>>>
77366>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77369>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77372>>>>>>>>>>>>>
77372>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77375>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77378>>>>>>>>>>>>>
77378>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77381>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77384>>>>>>>>>>>>>
77384>>>>>>>>>>>>>        Function_Return (EQ)
77385>>>>>>>>>>>>>    End_Function
77386>>>>>>>>>>>>>
77386>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77388>>>>>>>>>>>>>        Handle hoSections
77388>>>>>>>>>>>>>        Integer iItems
77388>>>>>>>>>>>>>
77388>>>>>>>>>>>>>        Send ReadSections hoSections
77389>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77390>>>>>>>>>>>>>        Function_Return iItems
77391>>>>>>>>>>>>>    End_Function
77392>>>>>>>>>>>>>
77392>>>>>>>>>>>>>    // The normal connection string looks something like this;
77392>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77392>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77392>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77392>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77392>>>>>>>>>>>>>//        String sSection
77392>>>>>>>>>>>>>//        Integer iCount
77392>>>>>>>>>>>>>//
77392>>>>>>>>>>>>>//        Move False to Err
77392>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77392>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77392>>>>>>>>>>>>>//        Increment iCount
77392>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77392>>>>>>>>>>>>>//
77392>>>>>>>>>>>>>//        Function_Return (Err = False)
77392>>>>>>>>>>>>>//    End_Function
77392>>>>>>>>>>>>>
77392>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77394>>>>>>>>>>>>>        Integer iCount
77394>>>>>>>>>>>>>        Boolean bExists
77394>>>>>>>>>>>>>        String sSection
77394>>>>>>>>>>>>>
77394>>>>>>>>>>>>>        Move False to Err
77395>>>>>>>>>>>>>        Move 1 to iCount
77396>>>>>>>>>>>>>        Get psIniSectionName to sSection
77397>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77398>>>>>>>>>>>>>        While (bExists = True)
77402>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77403>>>>>>>>>>>>>            Increment iCount
77404>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77405>>>>>>>>>>>>>        Loop
77406>>>>>>>>>>>>>>
77406>>>>>>>>>>>>>        Function_Return (Err = False)
77407>>>>>>>>>>>>>    End_Function
77408>>>>>>>>>>>>>
77408>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77410>>>>>>>>>>>>>        Integer iCount
77410>>>>>>>>>>>>>        String sSection
77410>>>>>>>>>>>>>        Boolean bExists
77410>>>>>>>>>>>>>
77410>>>>>>>>>>>>>        Move False to Err
77411>>>>>>>>>>>>>        Move 1 to iCount
77412>>>>>>>>>>>>>        Get psIniSectionName to sSection
77413>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77414>>>>>>>>>>>>>        While (bExists = True)
77418>>>>>>>>>>>>>            If (iCount = iItem) Begin
77420>>>>>>>>>>>>>                Send DeleteSection sSection
77421>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77421>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77422>>>>>>>>>>>>>            End
77422>>>>>>>>>>>>>>
77422>>>>>>>>>>>>>            Increment iCount
77423>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77424>>>>>>>>>>>>>        Loop
77425>>>>>>>>>>>>>>
77425>>>>>>>>>>>>>
77425>>>>>>>>>>>>>        Function_Return (Err = False)
77426>>>>>>>>>>>>>    End_Function
77427>>>>>>>>>>>>>
77427>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77427>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77427>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77429>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77429>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77430>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77430>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77430>>>>>>>>>>>>>        Integer iIndex
77430>>>>>>>>>>>>>
77430>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77431>>>>>>>>>>>>>        If (iIndex = -1) Begin
77433>>>>>>>>>>>>>            Move True to SQLConnection.bError
77434>>>>>>>>>>>>>            Function_Return SQLConnection
77435>>>>>>>>>>>>>        End
77435>>>>>>>>>>>>>>
77435>>>>>>>>>>>>>
77435>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77436>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77437>>>>>>>>>>>>>
77437>>>>>>>>>>>>>        Function_Return SQLConnection
77438>>>>>>>>>>>>>    End_Function
77439>>>>>>>>>>>>>
77439>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77439>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77441>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77441>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77442>>>>>>>>>>>>>        Integer iRetval iCount iSize
77442>>>>>>>>>>>>>        String sValue
77442>>>>>>>>>>>>>        Boolean bExists
77442>>>>>>>>>>>>>
77442>>>>>>>>>>>>>        Move -1 to iRetval
77443>>>>>>>>>>>>>
77443>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77444>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77445>>>>>>>>>>>>>        Decrement iSize
77446>>>>>>>>>>>>>        For iCount from 0 to iSize
77452>>>>>>>>>>>>>>
77452>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77453>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77454>>>>>>>>>>>>>            If (bExists) Begin
77456>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77457>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77458>>>>>>>>>>>>>            End
77458>>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Loop
77459>>>>>>>>>>>>>>
77459>>>>>>>>>>>>>
77459>>>>>>>>>>>>>        Function_Return iRetval
77460>>>>>>>>>>>>>    End_Function
77461>>>>>>>>>>>>>
77461>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77461>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77461>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77463>>>>>>>>>>>>>        Integer iCount iSize iItems
77463>>>>>>>>>>>>>        String sValue
77463>>>>>>>>>>>>>        Boolean bExists
77463>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77463>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77464>>>>>>>>>>>>>
77464>>>>>>>>>>>>>        Move 0 to iItems
77465>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77466>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77467>>>>>>>>>>>>>        Decrement iSize
77468>>>>>>>>>>>>>        For iCount from 0 to iSize
77474>>>>>>>>>>>>>>
77474>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77475>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77476>>>>>>>>>>>>>            If (bExists) Begin
77478>>>>>>>>>>>>>                Increment iItems
77479>>>>>>>>>>>>>            End
77479>>>>>>>>>>>>>>
77479>>>>>>>>>>>>>        Loop
77480>>>>>>>>>>>>>>
77480>>>>>>>>>>>>>
77480>>>>>>>>>>>>>        Function_Return (iItems > 1)
77481>>>>>>>>>>>>>    End_Function
77482>>>>>>>>>>>>>
77482>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77482>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77484>>>>>>>>>>>>>        Boolean bOK
77484>>>>>>>>>>>>>        Integer iSize iCount
77484>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77484>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77485>>>>>>>>>>>>>        tSQLConnection SQLConnection
77485>>>>>>>>>>>>>        tSQLConnection SQLConnection
77485>>>>>>>>>>>>>        String sConnectionString
77485>>>>>>>>>>>>>
77485>>>>>>>>>>>>>        Move False to Err
77486>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77487>>>>>>>>>>>>>
77487>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77488>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77489>>>>>>>>>>>>>        Decrement iSize
77490>>>>>>>>>>>>>        // Set all current connection to inactive.
77490>>>>>>>>>>>>>        For iCount from 0 to iSize
77496>>>>>>>>>>>>>>
77496>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77497>>>>>>>>>>>>>        Loop
77498>>>>>>>>>>>>>>
77498>>>>>>>>>>>>>
77498>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77499>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77500>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77501>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77502>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77503>>>>>>>>>>>>>
77503>>>>>>>>>>>>>        Function_Return (bOK = True)
77504>>>>>>>>>>>>>    End_Function
77505>>>>>>>>>>>>>
77505>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77505>>>>>>>>>>>>>    // Returns True if successful.
77505>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77507>>>>>>>>>>>>>        Boolean bOK
77507>>>>>>>>>>>>>        Integer iItem iSize iCount
77507>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77507>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77508>>>>>>>>>>>>>
77508>>>>>>>>>>>>>        Move False to Err
77509>>>>>>>>>>>>>        Move -1 to iItem
77510>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77511>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77512>>>>>>>>>>>>>        Decrement iSize
77513>>>>>>>>>>>>>        // Set all current connection to inactive.
77513>>>>>>>>>>>>>        For iCount from 0 to iSize
77519>>>>>>>>>>>>>>
77519>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77520>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77522>>>>>>>>>>>>>                Move iCount to iItem
77523>>>>>>>>>>>>>            End
77523>>>>>>>>>>>>>>
77523>>>>>>>>>>>>>        Loop
77524>>>>>>>>>>>>>>
77524>>>>>>>>>>>>>
77524>>>>>>>>>>>>>        If (iItem <> -1) Begin
77526>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77527>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77528>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77529>>>>>>>>>>>>>        End
77529>>>>>>>>>>>>>>
77529>>>>>>>>>>>>>
77529>>>>>>>>>>>>>        Function_Return (bOK = True)
77530>>>>>>>>>>>>>    End_Function
77531>>>>>>>>>>>>>
77531>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77533>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77533>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77534>>>>>>>>>>>>>        String sSection sValue
77534>>>>>>>>>>>>>        Integer iCount
77534>>>>>>>>>>>>>        Boolean bExists
77534>>>>>>>>>>>>>
77534>>>>>>>>>>>>>        Get psIniSectionName to sSection
77535>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77536>>>>>>>>>>>>>        If (bExists = False) Begin
77538>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77539>>>>>>>>>>>>>        End
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77540>>>>>>>>>>>>>        If (bExists = True) Begin
77542>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77543>>>>>>>>>>>>>>
77543>>>>>>>>>>>>>        End
77543>>>>>>>>>>>>>>
77543>>>>>>>>>>>>>
77543>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77544>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77545>>>>>>>>>>>>>
77545>>>>>>>>>>>>>        While (bExists = True)                 
77549>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77549>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77549>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77549>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77550>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77551>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77552>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77553>>>>>>>>>>>>>
77553>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77553>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77554>>>>>>>>>>>>>            If (sValue = "99") Begin
77556>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77557>>>>>>>>>>>>>            End
77557>>>>>>>>>>>>>>
77557>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77558>>>>>>>>>>>>>
77558>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77559>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77560>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77562>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77563>>>>>>>>>>>>>            End
77563>>>>>>>>>>>>>>
77563>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77565>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77566>>>>>>>>>>>>>            End
77566>>>>>>>>>>>>>>
77566>>>>>>>>>>>>>
77566>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77567>>>>>>>>>>>>>
77567>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77568>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77569>>>>>>>>>>>>>
77569>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77570>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77571>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77573>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77574>>>>>>>>>>>>>            End
77574>>>>>>>>>>>>>>
77574>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77575>>>>>>>>>>>>>
77575>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77575>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77576>>>>>>>>>>>>>
77576>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77577>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77578>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77579>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77580>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77581>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77582>>>>>>>>>>>>>
77582>>>>>>>>>>>>>            Increment iCount
77583>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77584>>>>>>>>>>>>>        Loop
77585>>>>>>>>>>>>>>
77585>>>>>>>>>>>>>
77585>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77585>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77587>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77588>>>>>>>>>>>>>        End
77588>>>>>>>>>>>>>>
77588>>>>>>>>>>>>>
77588>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77589>>>>>>>>>>>>>    End_Function
77590>>>>>>>>>>>>>
77590>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77592>>>>>>>>>>>>>        Integer iCount iSize
77592>>>>>>>>>>>>>        Boolean bOK
77592>>>>>>>>>>>>>        String sSection sValue
77592>>>>>>>>>>>>>
77592>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77592>>>>>>>>>>>>>        Move 0 to iCount
77593>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77594>>>>>>>>>>>>>        If (bOK = False) Begin
77596>>>>>>>>>>>>>            Function_Return False
77597>>>>>>>>>>>>>        End
77597>>>>>>>>>>>>>>
77597>>>>>>>>>>>>>
77597>>>>>>>>>>>>>        Move False to Err
77598>>>>>>>>>>>>>        Get psIniSectionName to sSection
77599>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77599>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77600>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77601>>>>>>>>>>>>>        Decrement iSize
77602>>>>>>>>>>>>>
77602>>>>>>>>>>>>>        For iCount from 0 to iSize
77608>>>>>>>>>>>>>>
77608>>>>>>>>>>>>>            // DF 19 compatible settings:
77608>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77609>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77610>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77611>>>>>>>>>>>>>            
77611>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77612>>>>>>>>>>>>>
77612>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77613>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77615>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77616>>>>>>>>>>>>>            End
77616>>>>>>>>>>>>>>
77616>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77617>>>>>>>>>>>>>
77617>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77619>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77620>>>>>>>>>>>>>            End
77620>>>>>>>>>>>>>>
77620>>>>>>>>>>>>>
77620>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77621>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77622>>>>>>>>>>>>>
77622>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77622>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77623>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77624>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77625>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77626>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77627>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77628>>>>>>>>>>>>>        Loop
77629>>>>>>>>>>>>>>
77629>>>>>>>>>>>>>
77629>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77630>>>>>>>>>>>>>    End_Function
77631>>>>>>>>>>>>>
77631>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77631>>>>>>>>>>>>>    //
77631>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77631>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77631>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77633>>>>>>>>>>>>>        String sRetval
77633>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77635>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77636>>>>>>>>>>>>>        End
77636>>>>>>>>>>>>>>
77636>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77638>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77639>>>>>>>>>>>>>        End
77639>>>>>>>>>>>>>>
77639>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77641>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77642>>>>>>>>>>>>>        End
77642>>>>>>>>>>>>>>
77642>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77644>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77645>>>>>>>>>>>>>        End
77645>>>>>>>>>>>>>>
77645>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77647>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77648>>>>>>>>>>>>>        End
77648>>>>>>>>>>>>>>
77648>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77650>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77651>>>>>>>>>>>>>        End
77651>>>>>>>>>>>>>>
77651>>>>>>>>>>>>>        Function_Return sRetval
77652>>>>>>>>>>>>>    End_Function
77653>>>>>>>>>>>>>
77653>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77653>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77653>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77655>>>>>>>>>>>>>        Integer iRetval
77655>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77657>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77658>>>>>>>>>>>>>        End
77658>>>>>>>>>>>>>>
77658>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77660>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77661>>>>>>>>>>>>>        End
77661>>>>>>>>>>>>>>
77661>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77663>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77664>>>>>>>>>>>>>        End
77664>>>>>>>>>>>>>>
77664>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77666>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77667>>>>>>>>>>>>>        End
77667>>>>>>>>>>>>>>
77667>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77669>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77670>>>>>>>>>>>>>        End
77670>>>>>>>>>>>>>>
77670>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77672>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77673>>>>>>>>>>>>>        End
77673>>>>>>>>>>>>>>
77673>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77675>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77676>>>>>>>>>>>>>        End
77676>>>>>>>>>>>>>>
77676>>>>>>>>>>>>>        Function_Return iRetval
77677>>>>>>>>>>>>>    End_Function
77678>>>>>>>>>>>>>
77678>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77678>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77678>>>>>>>>>>>>>    // the SQL Connection program's grid.
77678>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77680>>>>>>>>>>>>>        String sRetval
77680>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77682>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77683>>>>>>>>>>>>>        End
77683>>>>>>>>>>>>>>
77683>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77685>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77686>>>>>>>>>>>>>        End
77686>>>>>>>>>>>>>>
77686>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77688>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77689>>>>>>>>>>>>>        End
77689>>>>>>>>>>>>>>
77689>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77691>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77692>>>>>>>>>>>>>        End
77692>>>>>>>>>>>>>>
77692>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77694>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77695>>>>>>>>>>>>>        End
77695>>>>>>>>>>>>>>
77695>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77697>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77698>>>>>>>>>>>>>        End
77698>>>>>>>>>>>>>>
77698>>>>>>>>>>>>>        Function_Return sRetval
77699>>>>>>>>>>>>>    End_Function
77700>>>>>>>>>>>>>
77700>>>>>>>>>>>>>    // Pass a driver id and the function will return
77700>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77700>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77700>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77702>>>>>>>>>>>>>        Integer iRetval
77702>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77704>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77705>>>>>>>>>>>>>        End
77705>>>>>>>>>>>>>>
77705>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77707>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77708>>>>>>>>>>>>>        End
77708>>>>>>>>>>>>>>
77708>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77710>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77711>>>>>>>>>>>>>        End
77711>>>>>>>>>>>>>>
77711>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77713>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77714>>>>>>>>>>>>>        End
77714>>>>>>>>>>>>>>
77714>>>>>>>>>>>>>        Function_Return iRetval
77715>>>>>>>>>>>>>    End_Function
77716>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77716>>>>>>>>>>>>>>
77716>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77718>>>>>>>>>>>>>>    Integer iStart iEnd
77718>>>>>>>>>>>>>>    String sRetval
77718>>>>>>>>>>>>>>
77718>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77719>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77720>>>>>>>>>>>>>>    If (iStart = 0) Begin
77722>>>>>>>>>>>>>>        Function_Return ""
77723>>>>>>>>>>>>>>    End
77723>>>>>>>>>>>>>>>
77723>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77724>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77725>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77727>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77728>>>>>>>>>>>>>>    End
77728>>>>>>>>>>>>>>>
77728>>>>>>>>>>>>>>    Else Begin
77729>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77730>>>>>>>>>>>>>>    End
77730>>>>>>>>>>>>>>>
77730>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77732>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77733>>>>>>>>>>>>>>        Decrement iEnd
77734>>>>>>>>>>>>>>    End
77734>>>>>>>>>>>>>>>
77734>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77736>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77737>>>>>>>>>>>>>>    End
77737>>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77738>>>>>>>>>>>>>>
77738>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77739>>>>>>>>>>>>>>End_Function
77740>>>>>>>>>>>>>>
77740>>>>>>>>>>>>>>
77740>>>>>>>>>>>>>
77740>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77742>>>>>>>>>>>>>        String sConnect
77742>>>>>>>>>>>>>        Handle hoDriver
77742>>>>>>>>>>>>>
77742>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77743>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77744>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77745>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77746>>>>>>>>>>>>>        Send Destroy of hoDriver
77747>>>>>>>>>>>>>
77747>>>>>>>>>>>>>        Function_Return sConnect
77748>>>>>>>>>>>>>    End_Function
77749>>>>>>>>>>>>>
77749>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77749>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77751>>>>>>>>>>>>>        String sConnect
77751>>>>>>>>>>>>>
77751>>>>>>>>>>>>>        Case Begin
77751>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77753>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77754>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77756>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77757>>>>>>>>>>>>>                End
77757>>>>>>>>>>>>>>
77757>>>>>>>>>>>>>                Case Break
77758>>>>>>>>>>>>>
77758>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77761>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77763>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77764>>>>>>>>>>>>>                End
77764>>>>>>>>>>>>>>
77764>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77767>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77768>>>>>>>>>>>>>                End
77768>>>>>>>>>>>>>>
77768>>>>>>>>>>>>>
77768>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77770>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77771>>>>>>>>>>>>>                End
77771>>>>>>>>>>>>>>
77771>>>>>>>>>>>>>                Case Break
77772>>>>>>>>>>>>>
77772>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77775>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77776>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77778>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77779>>>>>>>>>>>>>                End
77779>>>>>>>>>>>>>>
77779>>>>>>>>>>>>>                Case Break
77780>>>>>>>>>>>>>
77780>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77783>>>>>>>>>>>>>                Break
77784>>>>>>>>>>>>>
77784>>>>>>>>>>>>>            Case Else
77784>>>>>>>>>>>>>                Move "" to sConnect
77785>>>>>>>>>>>>>        Case End
77785>>>>>>>>>>>>>
77785>>>>>>>>>>>>>        Function_Return sConnect
77786>>>>>>>>>>>>>    End_Function
77787>>>>>>>>>>>>>
77787>>>>>>>>>>>>>    // Use Base64
77787>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77789>>>>>>>>>>>>>        String sRetval
77789>>>>>>>>>>>>>        Handle hoLoginEncryption
77789>>>>>>>>>>>>>
77789>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77790>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77791>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77792>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77793>>>>>>>>>>>>>          
77793>>>>>>>>>>>>>        Function_Return sRetval
77794>>>>>>>>>>>>>    End_Function
77795>>>>>>>>>>>>>
77795>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77797>>>>>>>>>>>>>        String sRetval
77797>>>>>>>>>>>>>        Handle hoLoginEncryption
77797>>>>>>>>>>>>>
77797>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77798>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77799>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77800>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77801>>>>>>>>>>>>>
77801>>>>>>>>>>>>>        Function_Return sRetval
77802>>>>>>>>>>>>>    End_Function
77803>>>>>>>>>>>>>
77803>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77803>>>>>>>>>>>>>    Function ApplicationPath Returns String
77805>>>>>>>>>>>>>        String sApplicationFileName sPath
77805>>>>>>>>>>>>>        Integer iNumChars iRetval
77805>>>>>>>>>>>>>
77805>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77806>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77807>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77808>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77809>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77810>>>>>>>>>>>>>
77810>>>>>>>>>>>>>        Function_Return sPath
77811>>>>>>>>>>>>>    End_Function
77812>>>>>>>>>>>>>
77812>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77812>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77812>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77812>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77814>>>>>>>>>>>>>        Boolean bExists
77814>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77814>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77815>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77815>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77815>>>>>>>>>>>>>        
77815>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77816>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77817>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77818>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77819>>>>>>>>>>>>>        If (bExists = True) Begin
77821>>>>>>>>>>>>>            Function_Return sProgramsPath
77822>>>>>>>>>>>>>        End                      
77822>>>>>>>>>>>>>>
77822>>>>>>>>>>>>>    
77822>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77823>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77825>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77826>>>>>>>>>>>>>        End                                              
77826>>>>>>>>>>>>>>
77826>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77827>>>>>>>>>>>>>        
77827>>>>>>>>>>>>>        Move False to bExists
77828>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77829>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77830>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77831>>>>>>>>>>>>>        Decrement iSize       
77832>>>>>>>>>>>>>        
77832>>>>>>>>>>>>>        For iCount from 0 to iSize
77838>>>>>>>>>>>>>>
77838>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77839>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77840>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77841>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77842>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77848>>>>>>>>>>>>>>
77848>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77849>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77850>>>>>>>>>>>>>                // Check if there are more than one path specified;
77850>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77851>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77853>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77854>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77860>>>>>>>>>>>>>>
77860>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77861>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77862>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77863>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77864>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77865>>>>>>>>>>>>>                        If (bExists = True) Begin
77867>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77868>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77869>>>>>>>>>>>>>                            Move iSize to iCount
77870>>>>>>>>>>>>>                        End                                                    
77870>>>>>>>>>>>>>>
77870>>>>>>>>>>>>>                    Loop
77871>>>>>>>>>>>>>>
77871>>>>>>>>>>>>>                End
77871>>>>>>>>>>>>>>
77871>>>>>>>>>>>>>                Else Begin
77872>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77873>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77874>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77875>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77876>>>>>>>>>>>>>                    If (bExists = True) Begin
77878>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77879>>>>>>>>>>>>>                        Move iSize to iCount
77880>>>>>>>>>>>>>                    End                                                    
77880>>>>>>>>>>>>>>
77880>>>>>>>>>>>>>                End
77880>>>>>>>>>>>>>>
77880>>>>>>>>>>>>>            Loop
77881>>>>>>>>>>>>>>
77881>>>>>>>>>>>>>            If (bExists = False) Begin
77883>>>>>>>>>>>>>                Move "" to sPath    
77884>>>>>>>>>>>>>            End
77884>>>>>>>>>>>>>>
77884>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77885>>>>>>>>>>>>>        Loop        
77886>>>>>>>>>>>>>>
77886>>>>>>>>>>>>>        Send Destroy of hoPaths
77887>>>>>>>>>>>>>        
77887>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77887>>>>>>>>>>>>>        If (sPath = "") Begin
77889>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77890>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77891>>>>>>>>>>>>>        End                  
77891>>>>>>>>>>>>>>
77891>>>>>>>>>>>>>        
77891>>>>>>>>>>>>>        Function_Return sPath    
77892>>>>>>>>>>>>>    End_Function
77893>>>>>>>>>>>>>    
77893>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77893>>>>>>>>>>>>>    // with one or more .ws file names.
77893>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77893>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77893>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77893>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77895>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77897>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77897>>>>>>>>>>>>>        Integer iCh iSize
77897>>>>>>>>>>>>>        Boolean bExists      
77897>>>>>>>>>>>>>        Handle hoIniFile 
77897>>>>>>>>>>>>>        
77897>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77898>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77899>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77901>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77902>>>>>>>>>>>>>        End                                              
77902>>>>>>>>>>>>>>
77902>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77903>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77904>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77905>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77906>>>>>>>>>>>>>        
77906>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77906>>>>>>>>>>>>>        // read the name of the .ws file name.
77906>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77907>>>>>>>>>>>>>        If (bExists = True) Begin
77909>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77910>>>>>>>>>>>>>            If (iCh < 0) Begin
77912>>>>>>>>>>>>>                Function_Return asSWSFiles
77913>>>>>>>>>>>>>            End                                 
77913>>>>>>>>>>>>>>
77913>>>>>>>>>>>>>            
77913>>>>>>>>>>>>>            Repeat
77913>>>>>>>>>>>>>>
77913>>>>>>>>>>>>>                Readln channel iCh sFile
77915>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77917>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77918>>>>>>>>>>>>>                End
77918>>>>>>>>>>>>>>
77918>>>>>>>>>>>>>            Until (SeqEof = True)
77920>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77921>>>>>>>>>>>>>            
77921>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77922>>>>>>>>>>>>>            If (iSize <> 0) Begin
77924>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77925>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77925>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77925>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77926>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77927>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77928>>>>>>>>>>>>>                If (sFile <> "") Begin
77930>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77931>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77932>>>>>>>>>>>>>                    File_Exist sFile bExists
77933>>>>>>>>>>>>>                    If (bExists = True) Begin
77935>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77936>>>>>>>>>>>>>                    End
77936>>>>>>>>>>>>>>
77936>>>>>>>>>>>>>                End
77936>>>>>>>>>>>>>>
77936>>>>>>>>>>>>>                Send Destroy of hoIniFile
77937>>>>>>>>>>>>>            End
77937>>>>>>>>>>>>>>
77937>>>>>>>>>>>>>        End
77937>>>>>>>>>>>>>>
77937>>>>>>>>>>>>>        
77937>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77937>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77939>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77940>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77941>>>>>>>>>>>>>            If (bExists = False) Begin
77943>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77944>>>>>>>>>>>>>            End
77944>>>>>>>>>>>>>>
77944>>>>>>>>>>>>>        
77944>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77945>>>>>>>>>>>>>            If (iCh < 0) Begin
77947>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77948>>>>>>>>>>>>>            End                                 
77948>>>>>>>>>>>>>>
77948>>>>>>>>>>>>>            
77948>>>>>>>>>>>>>            Repeat
77948>>>>>>>>>>>>>>
77948>>>>>>>>>>>>>                Readln channel iCh sFile
77950>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77952>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77953>>>>>>>>>>>>>                End
77953>>>>>>>>>>>>>>
77953>>>>>>>>>>>>>            Until (SeqEof = True)
77955>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77956>>>>>>>>>>>>>        End
77956>>>>>>>>>>>>>>
77956>>>>>>>>>>>>>        
77956>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77957>>>>>>>>>>>>>    End_Function
77958>>>>>>>>>>>>>
77958>>>>>>>>>>>>>End_Class
77959>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77959>>>>>>>>>>>Use vWin32fh.pkg
77959>>>>>>>>>>>
77959>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77959>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77959>>>>>>>>>>>
77959>>>>>>>>>>>// We're making references to this object handle so we need it defined
77959>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77959>>>>>>>>>>>
77959>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77959>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77960>>>>>>>>>>>
77960>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77961>>>>>>>>>>>
77961>>>>>>>>>>>    Procedure Construct_Object
77963>>>>>>>>>>>        Handle ho
77963>>>>>>>>>>>        Forward Send Construct_Object
77965>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77966>>>>>>>>>>>
77966>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77967>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77968>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77969>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77970>>>>>>>>>>>        
77970>>>>>>>>>>>
77970>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77970>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77970>>>>>>>>>>>        // methods to this class.
77970>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77971>>>>>>>>>>>        Property Boolean pbToANSI          True
77972>>>>>>>>>>>        Property Boolean pbRecnum          True
77973>>>>>>>>>>>        Property Boolean pbCopyData        True
77974>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77975>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77976>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77977>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77978>>>>>>>>>>>
77978>>>>>>>>>>>        // Driver default value settings:
77978>>>>>>>>>>>        // Note: When the object is created the corresponding values
77978>>>>>>>>>>>        // from the driver .int files are read.
77978>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77978>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77979>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77980>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77981>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77982>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77983>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77984>>>>>>>>>>>
77984>>>>>>>>>>>        // Driver "nullability" settings:
77984>>>>>>>>>>>        // Note: When the object is created the corresponding values
77984>>>>>>>>>>>        // from the driver .int files are read.
77984>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77984>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77985>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77986>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77987>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77988>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77989>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77990>>>>>>>>>>>
77990>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77990>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
77990>>>>>>>>>>>        //     driver interfaces.
77990>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77990>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77990>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77991>>>>>>>>>>>
77991>>>>>>>>>>>    End_Procedure
77992>>>>>>>>>>>
77992>>>>>>>>>>>    Procedure End_Construct_Object
77994>>>>>>>>>>>        tSQLConnection SQLConnection
77994>>>>>>>>>>>        tSQLConnection SQLConnection
77994>>>>>>>>>>>
77994>>>>>>>>>>>        Forward Send End_Construct_Object
77996>>>>>>>>>>>
77996>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77996>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77997>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77998>>>>>>>>>>>    End_Procedure
77999>>>>>>>>>>>
77999>>>>>>>>>>>    // *** Properties ***
77999>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77999>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77999>>>>>>>>>>>    // merely here for conveniance.
77999>>>>>>>>>>>    //
77999>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77999>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77999>>>>>>>>>>>    // This struct property contains all the connection data.
77999>>>>>>>>>>>    //
77999>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78001>>>>>>>>>>>        Boolean bOK
78001>>>>>>>>>>>
78001>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78002>>>>>>>>>>>
78002>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78002>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78004>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78004>>>>>>>>>>>            Procedure_Return
78005>>>>>>>>>>>        End
78005>>>>>>>>>>>>
78005>>>>>>>>>>>
78005>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78005>>>>>>>>>>>        // be logged in already and don't want to do it again.
78005>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78007>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78007>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78007>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78008>>>>>>>>>>>            If (bOK = False) Begin
78010>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78011>>>>>>>>>>>>
78011>>>>>>>>>>>            End
78011>>>>>>>>>>>>
78011>>>>>>>>>>>        End
78011>>>>>>>>>>>>
78011>>>>>>>>>>>
78011>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78011>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78012>>>>>>>>>>>
78012>>>>>>>>>>>    End_Procedure
78013>>>>>>>>>>>
78013>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78013>>>>>>>>>>>    // attempt to load the driver.
78013>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78013>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78015>>>>>>>>>>>        Boolean bOK
78015>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78016>>>>>>>>>>>        Function_Return bOK
78017>>>>>>>>>>>    End_Function
78018>>>>>>>>>>>
78018>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78018>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78020>>>>>>>>>>>        String sAttributeValue
78020>>>>>>>>>>>        Integer iDriverID
78020>>>>>>>>>>>        Boolean bNULL bSQLDriver
78020>>>>>>>>>>>
78020>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78021>>>>>>>>>>>        If (bSQLDriver = False) Begin
78023>>>>>>>>>>>            Procedure_Return
78024>>>>>>>>>>>        End                                      
78024>>>>>>>>>>>>
78024>>>>>>>>>>>        
78024>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
78025>>>>>>>>>>>
78025>>>>>>>>>>>        // Driver default values for various data types:
78025>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78028>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78029>>>>>>>>>>>
78029>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78032>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78033>>>>>>>>>>>
78033>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78036>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78037>>>>>>>>>>>
78037>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78040>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78041>>>>>>>>>>>
78041>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78044>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78045>>>>>>>>>>>
78045>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78048>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78049>>>>>>>>>>>
78049>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78049>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78052>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78053>>>>>>>>>>>
78053>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78056>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78057>>>>>>>>>>>
78057>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78060>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78061>>>>>>>>>>>
78061>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78064>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78065>>>>>>>>>>>
78065>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78068>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78069>>>>>>>>>>>
78069>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78072>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78073>>>>>>>>>>>
78073>>>>>>>>>>>    End_Procedure
78074>>>>>>>>>>>
78074>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78076>>>>>>>>>>>        Boolean bOK bIsDaw
78076>>>>>>>>>>>        String sConnectionString
78076>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78076>>>>>>>>>>>        Integer iDriverID
78076>>>>>>>>>>>
78076>>>>>>>>>>>        Move False to bOK
78077>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78078>>>>>>>>>>>
78078>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78079>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78080>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78081>>>>>>>>>>>        If (iDriverID = 0) Begin
78083>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78084>>>>>>>>>>>            Function_Return False
78085>>>>>>>>>>>        End
78085>>>>>>>>>>>>
78085>>>>>>>>>>>
78085>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78088>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78089>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78090>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78091>>>>>>>>>>>        Send Destroy   of hoDriver
78092>>>>>>>>>>>
78092>>>>>>>>>>>        Function_Return bOK
78093>>>>>>>>>>>    End_Function
78094>>>>>>>>>>>
78094>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78096>>>>>>>>>>>        tSQLConnection SQLConnection
78096>>>>>>>>>>>        tSQLConnection SQLConnection
78096>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78097>>>>>>>>>>>        Function_Return SQLConnection
78098>>>>>>>>>>>    End_Function
78099>>>>>>>>>>>
78099>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78101>>>>>>>>>>>        tSQLConnection SQLConnection
78101>>>>>>>>>>>        tSQLConnection SQLConnection
78101>>>>>>>>>>>
78101>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78102>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78104>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78105>>>>>>>>>>>        End
78105>>>>>>>>>>>>
78105>>>>>>>>>>>
78105>>>>>>>>>>>        // Else we might want to change the current connection ID
78105>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78108>>>>>>>>>>>            Move False to Err
78109>>>>>>>>>>>            Logout SQLConnection.sDriverID
78110>>>>>>>>>>>            // This will also make a login to the new server.
78110>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78111>>>>>>>>>>>        End
78111>>>>>>>>>>>>
78111>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78112>>>>>>>>>>>    End_Procedure
78113>>>>>>>>>>>
78113>>>>>>>>>>>    Function psConnectionID Returns String
78115>>>>>>>>>>>        tSQLConnection SQLConnection
78115>>>>>>>>>>>        tSQLConnection SQLConnection
78115>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78116>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78117>>>>>>>>>>>    End_Function
78118>>>>>>>>>>>
78118>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78118>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78118>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78118>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78118>>>>>>>>>>>    Procedure Set psDriverID String sValue
78120>>>>>>>>>>>        tSQLConnection SQLConnection
78120>>>>>>>>>>>        tSQLConnection SQLConnection
78120>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78121>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78122>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78123>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78125>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78126>>>>>>>>>>>        End
78126>>>>>>>>>>>>
78126>>>>>>>>>>>    End_Procedure
78127>>>>>>>>>>>
78127>>>>>>>>>>>    Function psDriverID Returns String
78129>>>>>>>>>>>        tSQLConnection SQLConnection
78129>>>>>>>>>>>        tSQLConnection SQLConnection
78129>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78130>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78132>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78133>>>>>>>>>>>        End
78133>>>>>>>>>>>>
78133>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78134>>>>>>>>>>>    End_Function
78135>>>>>>>>>>>
78135>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78137>>>>>>>>>>>        tSQLConnection SQLConnection
78137>>>>>>>>>>>        tSQLConnection SQLConnection
78137>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78138>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78139>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78140>>>>>>>>>>>    End_Procedure
78141>>>>>>>>>>>
78141>>>>>>>>>>>    Function psConnectionString Returns String
78143>>>>>>>>>>>        tSQLConnection SQLConnection
78143>>>>>>>>>>>        tSQLConnection SQLConnection
78143>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78144>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78145>>>>>>>>>>>    End_Function
78146>>>>>>>>>>>
78146>>>>>>>>>>>    Procedure Set psServer String sValue
78148>>>>>>>>>>>        tSQLConnection SQLConnection
78148>>>>>>>>>>>        tSQLConnection SQLConnection
78148>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78149>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78150>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78151>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78152>>>>>>>>>>>    End_Procedure
78153>>>>>>>>>>>
78153>>>>>>>>>>>    Function psServer Returns String
78155>>>>>>>>>>>        tSQLConnection SQLConnection
78155>>>>>>>>>>>        tSQLConnection SQLConnection
78155>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78156>>>>>>>>>>>        Function_Return SQLConnection.sServer
78157>>>>>>>>>>>    End_Function
78158>>>>>>>>>>>
78158>>>>>>>>>>>    Procedure Set psDatabase String sValue
78160>>>>>>>>>>>        tSQLConnection SQLConnection
78160>>>>>>>>>>>        tSQLConnection SQLConnection
78160>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78161>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78162>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78163>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78164>>>>>>>>>>>    End_Procedure
78165>>>>>>>>>>>
78165>>>>>>>>>>>    Function psDatabase Returns String
78167>>>>>>>>>>>        tSQLConnection SQLConnection
78167>>>>>>>>>>>        tSQLConnection SQLConnection
78167>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78168>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78169>>>>>>>>>>>    End_Function
78170>>>>>>>>>>>
78170>>>>>>>>>>>    Procedure Set psUserID String sValue
78172>>>>>>>>>>>        tSQLConnection SQLConnection
78172>>>>>>>>>>>        tSQLConnection SQLConnection
78172>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78173>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78174>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78175>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78176>>>>>>>>>>>    End_Procedure
78177>>>>>>>>>>>
78177>>>>>>>>>>>    Function psUserID Returns String
78179>>>>>>>>>>>        tSQLConnection SQLConnection
78179>>>>>>>>>>>        tSQLConnection SQLConnection
78179>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78180>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78181>>>>>>>>>>>    End_Function
78182>>>>>>>>>>>
78182>>>>>>>>>>>    // This is the uncrypted password
78182>>>>>>>>>>>    Procedure Set psPassword String sValue
78184>>>>>>>>>>>        tSQLConnection SQLConnection
78184>>>>>>>>>>>        tSQLConnection SQLConnection
78184>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78185>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78186>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78187>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78188>>>>>>>>>>>    End_Procedure
78189>>>>>>>>>>>
78189>>>>>>>>>>>    Function psPassword Returns String
78191>>>>>>>>>>>        tSQLConnection SQLConnection
78191>>>>>>>>>>>        tSQLConnection SQLConnection
78191>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78192>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78193>>>>>>>>>>>    End_Function
78194>>>>>>>>>>>
78194>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78196>>>>>>>>>>>        tSQLConnection SQLConnection
78196>>>>>>>>>>>        tSQLConnection SQLConnection
78196>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78197>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78198>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78199>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78200>>>>>>>>>>>    End_Procedure
78201>>>>>>>>>>>
78201>>>>>>>>>>>    Function pbTrusted Returns Boolean
78203>>>>>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>>>>>        tSQLConnection SQLConnection
78203>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78204>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78205>>>>>>>>>>>    End_Function
78206>>>>>>>>>>>
78206>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78206>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78206>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78206>>>>>>>>>>>    //     the central pSQLConnection "hub".
78206>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78208>>>>>>>>>>>        tSQLConnection SQLConnection
78208>>>>>>>>>>>        tSQLConnection SQLConnection
78208>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78209>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78210>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78211>>>>>>>>>>>    End_Procedure
78212>>>>>>>>>>>
78212>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78214>>>>>>>>>>>        tSQLConnection SQLConnection
78214>>>>>>>>>>>        tSQLConnection SQLConnection
78214>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78215>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78216>>>>>>>>>>>    End_Function
78217>>>>>>>>>>>
78217>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78219>>>>>>>>>>>        tSQLConnection SQLConnection
78219>>>>>>>>>>>        tSQLConnection SQLConnection
78219>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78220>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78221>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78222>>>>>>>>>>>    End_Procedure
78223>>>>>>>>>>>
78223>>>>>>>>>>>    Function piDbType Returns Integer
78225>>>>>>>>>>>        tSQLConnection SQLConnection
78225>>>>>>>>>>>        tSQLConnection SQLConnection
78225>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78226>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78227>>>>>>>>>>>    End_Function
78228>>>>>>>>>>>
78228>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78230>>>>>>>>>>>        tSQLConnection SQLConnection
78230>>>>>>>>>>>        tSQLConnection SQLConnection
78230>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78231>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78232>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78233>>>>>>>>>>>    End_Procedure
78234>>>>>>>>>>>
78234>>>>>>>>>>>    Function psBaseTableSpace Returns String
78236>>>>>>>>>>>        tSQLConnection SQLConnection
78236>>>>>>>>>>>        tSQLConnection SQLConnection
78236>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78237>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78238>>>>>>>>>>>    End_Function
78239>>>>>>>>>>>
78239>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78242>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78243>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78244>>>>>>>>>>>    End_Procedure
78245>>>>>>>>>>>
78245>>>>>>>>>>>    Function psIndexTableSpace Returns String
78247>>>>>>>>>>>        tSQLConnection SQLConnection
78247>>>>>>>>>>>        tSQLConnection SQLConnection
78247>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78248>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78249>>>>>>>>>>>    End_Function
78250>>>>>>>>>>>
78250>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78252>>>>>>>>>>>        tSQLConnection SQLConnection
78252>>>>>>>>>>>        tSQLConnection SQLConnection
78252>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78253>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78254>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78255>>>>>>>>>>>    End_Procedure
78256>>>>>>>>>>>
78256>>>>>>>>>>>    Function psLongTableSpace Returns String
78258>>>>>>>>>>>        tSQLConnection SQLConnection
78258>>>>>>>>>>>        tSQLConnection SQLConnection
78258>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78259>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78260>>>>>>>>>>>    End_Function
78261>>>>>>>>>>>
78261>>>>>>>>>>>    Procedure Set psSchema String sValue
78263>>>>>>>>>>>        tSQLConnection SQLConnection
78263>>>>>>>>>>>        tSQLConnection SQLConnection
78263>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78264>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78265>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78266>>>>>>>>>>>    End_Procedure
78267>>>>>>>>>>>
78267>>>>>>>>>>>    Function psSchema Returns String
78269>>>>>>>>>>>        tSQLConnection SQLConnection
78269>>>>>>>>>>>        tSQLConnection SQLConnection
78269>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78270>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78271>>>>>>>>>>>    End_Function
78272>>>>>>>>>>>
78272>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78274>>>>>>>>>>>        tSQLConnection SQLConnection
78274>>>>>>>>>>>        tSQLConnection SQLConnection
78274>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78275>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78276>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78277>>>>>>>>>>>    End_Procedure
78278>>>>>>>>>>>
78278>>>>>>>>>>>    Function pbEnabled Returns Boolean
78280>>>>>>>>>>>        tSQLConnection SQLConnection
78280>>>>>>>>>>>        tSQLConnection SQLConnection
78280>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78281>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78282>>>>>>>>>>>    End_Function
78283>>>>>>>>>>>
78283>>>>>>>>>>>
78283>>>>>>>>>>>    // ************************************
78283>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78285>>>>>>>>>>>        tSQLConnection SQLConnection
78285>>>>>>>>>>>        tSQLConnection SQLConnection
78285>>>>>>>>>>>
78285>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78285>>>>>>>>>>>        // deferr reading SQL connection values until later.
78285>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78287>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78287>>>>>>>>>>>            If (ghoConnection > 0) Begin
78289>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78290>>>>>>>>>>>            End
78290>>>>>>>>>>>>
78290>>>>>>>>>>>
78290>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78290>>>>>>>>>>>            // object is used.
78290>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78292>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78293>>>>>>>>>>>            End
78293>>>>>>>>>>>>
78293>>>>>>>>>>>        End
78293>>>>>>>>>>>>
78293>>>>>>>>>>>
78293>>>>>>>>>>>        Function_Return SQLConnection
78294>>>>>>>>>>>    End_Function
78295>>>>>>>>>>>
78295>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78295>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78297>>>>>>>>>>>        tConnection Connection
78297>>>>>>>>>>>        tConnection Connection
78297>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78297>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78297>>>>>>>>>>>        Integer iRetval iDbType
78297>>>>>>>>>>>        Boolean bOK bConnected
78297>>>>>>>>>>>        String sConnectionID
78297>>>>>>>>>>>
78297>>>>>>>>>>>            tConnection[] Connections
78297>>>>>>>>>>>            tConnection[] Connections
78298>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78298>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78298>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78298>>>>>>>>>>>            //   we then generate an error and abort the program...
78298>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78299>>>>>>>>>>>            If (bOK = False) Begin
78301>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78302>>>>>>>>>>>>
78302>>>>>>>>>>>                Abort
78303>>>>>>>>>>>>
78303>>>>>>>>>>>            End
78303>>>>>>>>>>>>
78303>>>>>>>>>>>            If (sConnectionID = "") Begin
78305>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78306>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78308>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78309>>>>>>>>>>>                End
78309>>>>>>>>>>>>
78309>>>>>>>>>>>            End
78309>>>>>>>>>>>>
78309>>>>>>>>>>>
78309>>>>>>>>>>>            Move 0 to iRetval
78310>>>>>>>>>>>            // DAW DF19 connection info:
78310>>>>>>>>>>>            // We first check that the connection is OK:
78310>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78311>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78311>>>>>>>>>>>            If (iRetval = -1) Begin
78313>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78314>>>>>>>>>>>            End
78314>>>>>>>>>>>>
78314>>>>>>>>>>>
78314>>>>>>>>>>>            If (sConnectionID <> "") Begin
78316>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78317>>>>>>>>>>>            End
78317>>>>>>>>>>>>
78317>>>>>>>>>>>            If (Connection.sId = "") Begin
78319>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78320>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78321>>>>>>>>>>>            End
78321>>>>>>>>>>>>
78321>>>>>>>>>>>
78321>>>>>>>>>>>            // DUF connection info struct property:
78321>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78322>>>>>>>>>>>
78322>>>>>>>>>>>            Move Connection.sId to sConnectionID
78323>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78324>>>>>>>>>>>
78324>>>>>>>>>>>            If (bConnected = False) Begin
78326>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78327>>>>>>>>>>>                If (iRetval <> 0) Begin
78329>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78330>>>>>>>>>>>                    Send Exit_Application
78331>>>>>>>>>>>                End
78331>>>>>>>>>>>>
78331>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78332>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78332>>>>>>>>>>>                // been changed in the DAW db login dialog.
78332>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78333>>>>>>>>>>>            End
78333>>>>>>>>>>>>
78333>>>>>>>>>>>
78333>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78334>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78335>>>>>>>>>>>
78335>>>>>>>>>>>            // Not used in DUF:
78335>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78335>>>>>>>>>>>
78335>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78336>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78337>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78338>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78339>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78340>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78341>>>>>>>>>>>
78341>>>>>>>>>>>            // Not used in DUF:
78341>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78341>>>>>>>>>>>
78341>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78341>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78341>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78343>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78344>>>>>>>>>>>            End
78344>>>>>>>>>>>>
78344>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78346>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78347>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78349>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78350>>>>>>>>>>>                End
78350>>>>>>>>>>>>
78350>>>>>>>>>>>            End
78350>>>>>>>>>>>>
78350>>>>>>>>>>>
78350>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78351>>>>>>>>>>>
78351>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78351>>>>>>>>>>>            // the value from the driver id:
78351>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78352>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78352>>>>>>>>>>>            Get piDbType                                     to iDbType
78353>>>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78355>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78356>>>>>>>>>>>            End
78356>>>>>>>>>>>>
78356>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78357>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78358>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78359>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78360>>>>>>>>>>>
78360>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78360>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78361>>>>>>>>>>>
78361>>>>>>>>>>>        Function_Return SQLConnection
78362>>>>>>>>>>>    End_Function
78363>>>>>>>>>>>
78363>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78363>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78363>>>>>>>>>>>    // connection id for a particular driver.
78363>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78363>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78363>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78363>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78363>>>>>>>>>>>    // connections of the DAW cConnect class.
78363>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78365>>>>>>>>>>>        tConnection[] ConnIdArray
78365>>>>>>>>>>>        tConnection[] ConnIdArray
78366>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78366>>>>>>>>>>>        Boolean bEnabled bFound
78366>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78366>>>>>>>>>>>
78366>>>>>>>>>>>        Move False to bFound
78367>>>>>>>>>>>        If (ghoConnection > 0) Begin
78369>>>>>>>>>>>
78369>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78369>>>>>>>>>>>            Get psDriverID to sDriverID
78370>>>>>>>>>>>
78370>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78371>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78371>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78372>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78373>>>>>>>>>>>            Decrement iSize
78374>>>>>>>>>>>            For iCount from 0 to iSize
78380>>>>>>>>>>>>
78380>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78381>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78382>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78383>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78383>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78383>>>>>>>>>>>                If (sConnectionID = "") Begin
78385>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78386>>>>>>>>>>>                End
78386>>>>>>>>>>>>
78386>>>>>>>>>>>                Else Begin
78387>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78389>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78390>>>>>>>>>>>                    End
78390>>>>>>>>>>>>
78390>>>>>>>>>>>                End
78390>>>>>>>>>>>>
78390>>>>>>>>>>>
78390>>>>>>>>>>>                If (bFound = True) Begin
78392>>>>>>>>>>>                    Increment iConnectionIDCounter
78393>>>>>>>>>>>                End
78393>>>>>>>>>>>>
78393>>>>>>>>>>>            Loop
78394>>>>>>>>>>>>
78394>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78395>>>>>>>>>>>            If (bFound = True) Begin
78397>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78398>>>>>>>>>>>            End
78398>>>>>>>>>>>>
78398>>>>>>>>>>>        End
78398>>>>>>>>>>>>
78398>>>>>>>>>>>
78398>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78398>>>>>>>>>>>        // but no DFConn.ini record has been created.
78398>>>>>>>>>>>        If (iSize = -1) Begin
78400>>>>>>>>>>>            Move True to bFound
78401>>>>>>>>>>>        End
78401>>>>>>>>>>>>
78401>>>>>>>>>>>
78401>>>>>>>>>>>        Function_Return bFound
78402>>>>>>>>>>>    End_Function
78403>>>>>>>>>>>
78403>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78403>>>>>>>>>>>    // create a connection to the server.
78403>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78405>>>>>>>>>>>        String sPath sFileName
78405>>>>>>>>>>>        Boolean bExists bActive
78405>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78405>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78406>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78406>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78406>>>>>>>>>>>        Handle hoIniFile
78406>>>>>>>>>>>        Integer iSize iCount iRetval
78406>>>>>>>>>>>
78406>>>>>>>>>>>        Get psIniFilePath to sPath
78407>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78408>>>>>>>>>>>        If (sPath = "") Begin
78410>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78411>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78412>>>>>>>>>>>        End
78412>>>>>>>>>>>>
78412>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78413>>>>>>>>>>>        Get psIniFileName to sFileName
78414>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78415>>>>>>>>>>>
78415>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78416>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78417>>>>>>>>>>>        If (iSize = 0) Begin
78419>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78419>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78419>>>>>>>>>>>            // in the cApplication object.
78419>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78420>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78422>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78423>>>>>>>>>>>            End
78423>>>>>>>>>>>>
78423>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78424>>>>>>>>>>>            Move 1 to iSize
78425>>>>>>>>>>>        End
78425>>>>>>>>>>>>
78425>>>>>>>>>>>
78425>>>>>>>>>>>        Move False to bActive
78426>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78426>>>>>>>>>>>        Decrement iSize
78427>>>>>>>>>>>        For iCount from 0 to iSize
78433>>>>>>>>>>>>
78433>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78434>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78436>>>>>>>>>>>                Move True to bActive
78437>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78438>>>>>>>>>>>            End
78438>>>>>>>>>>>>
78438>>>>>>>>>>>        Loop
78439>>>>>>>>>>>>
78439>>>>>>>>>>>
78439>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78439>>>>>>>>>>>        If (bActive = False) Begin
78441>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78442>>>>>>>>>>>        End
78442>>>>>>>>>>>>
78442>>>>>>>>>>>
78442>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78443>>>>>>>>>>>
78443>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78444>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78445>>>>>>>>>>>
78445>>>>>>>>>>>        Function_Return SQLConnection
78446>>>>>>>>>>>    End_Function
78447>>>>>>>>>>>
78447>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78449>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78450>>>>>>>>>>>    End_Procedure
78451>>>>>>>>>>>
78451>>>>>>>>>>>    Function psIniFilePath Returns String
78453>>>>>>>>>>>        String sRetval
78453>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78454>>>>>>>>>>>        Function_Return sRetval
78455>>>>>>>>>>>    End_Function
78456>>>>>>>>>>>
78456>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78458>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78459>>>>>>>>>>>    End_Procedure
78460>>>>>>>>>>>
78460>>>>>>>>>>>    Function psIniFileName Returns String
78462>>>>>>>>>>>        String sRetval
78462>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78463>>>>>>>>>>>        Function_Return sRetval
78464>>>>>>>>>>>    End_Function
78465>>>>>>>>>>>
78465>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78467>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78468>>>>>>>>>>>    End_Procedure
78469>>>>>>>>>>>
78469>>>>>>>>>>>    Function psIniSectionName Returns String
78471>>>>>>>>>>>        String sRetval
78471>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78472>>>>>>>>>>>        Function_Return sRetval
78473>>>>>>>>>>>    End_Function
78474>>>>>>>>>>>
78474>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78476>>>>>>>>>>>        Handle ho
78476>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78477>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78478>>>>>>>>>>>    End_Procedure
78479>>>>>>>>>>>
78479>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78481>>>>>>>>>>>        Handle ho
78481>>>>>>>>>>>        String sRetval
78481>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78482>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78483>>>>>>>>>>>        Function_Return sRetval
78484>>>>>>>>>>>    End_Function
78485>>>>>>>>>>>
78485>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78487>>>>>>>>>>>        Handle ho
78487>>>>>>>>>>>        Boolean bRetval
78487>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78488>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78489>>>>>>>>>>>        Function_Return bRetval
78490>>>>>>>>>>>    End_Function
78491>>>>>>>>>>>
78491>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78493>>>>>>>>>>>        Handle ho
78493>>>>>>>>>>>        Boolean bRetval
78493>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78494>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78495>>>>>>>>>>>        Function_Return bRetval
78496>>>>>>>>>>>    End_Function
78497>>>>>>>>>>>
78497>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78499>>>>>>>>>>>        Handle ho
78499>>>>>>>>>>>        String sRetval
78499>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78500>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78501>>>>>>>>>>>        Function_Return sRetval
78502>>>>>>>>>>>    End_Function
78503>>>>>>>>>>>
78503>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78505>>>>>>>>>>>        Handle ho
78505>>>>>>>>>>>        String sRetval
78505>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78506>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78507>>>>>>>>>>>        Function_Return sRetval
78508>>>>>>>>>>>    End_Function
78509>>>>>>>>>>>
78509>>>>>>>>>>>    // *** Main Connection Message ***
78509>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78511>>>>>>>>>>>        Handle hoDriver
78511>>>>>>>>>>>        String sConnectionString sError
78511>>>>>>>>>>>        Boolean bLoginSuccessful
78511>>>>>>>>>>>
78511>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78512>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78513>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78514>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78515>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78517>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78518>>>>>>>>>>>>
78518>>>>>>>>>>>            If (bExitProgram = True) Begin
78520>>>>>>>>>>>                Send Exit_Application
78521>>>>>>>>>>>            End
78521>>>>>>>>>>>>
78521>>>>>>>>>>>        End
78521>>>>>>>>>>>>
78521>>>>>>>>>>>        Send Destroy of hoDriver
78522>>>>>>>>>>>    End_Procedure
78523>>>>>>>>>>>
78523>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78525>>>>>>>>>>>        Integer iRetval
78525>>>>>>>>>>>        Handle hoCLI
78525>>>>>>>>>>>        String sDriverID
78525>>>>>>>>>>>
78525>>>>>>>>>>>        Get psDriverID to sDriverID
78526>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78527>>>>>>>>>>>        If (hoCLI <> 0) Begin
78529>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78530>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78531>>>>>>>>>>>            Send Destroy of hoCLI
78532>>>>>>>>>>>        End
78532>>>>>>>>>>>>
78532>>>>>>>>>>>
78532>>>>>>>>>>>        Function_Return iRetval
78533>>>>>>>>>>>    End_Function
78534>>>>>>>>>>>
78534>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78536>>>>>>>>>>>        tSQLConnection SQLConnection
78536>>>>>>>>>>>        tSQLConnection SQLConnection
78536>>>>>>>>>>>
78536>>>>>>>>>>>        Set psDriverID to sDriverID
78537>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78538>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78539>>>>>>>>>>>    End_Procedure
78540>>>>>>>>>>>
78540>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78540>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78540>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78540>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78540>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78540>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78540>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78540>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78542>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78542>>>>>>>>>>>        Handle hoCLI
78542>>>>>>>>>>>        String sID
78542>>>>>>>>>>>
78542>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78544>>>>>>>>>>>            Procedure_Return
78545>>>>>>>>>>>        End
78545>>>>>>>>>>>>
78545>>>>>>>>>>>
78545>>>>>>>>>>>        Move 0 to iResult
78546>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78547>>>>>>>>>>>        If (hoCLI <> 0) Begin
78549>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78550>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78551>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78554>>>>>>>>>>>            Decrement iNumConn
78555>>>>>>>>>>>            For iConn from 0 to iNumConn
78561>>>>>>>>>>>>
78561>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78564>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78566>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78567>>>>>>>>>>>                End
78567>>>>>>>>>>>>
78567>>>>>>>>>>>            Loop
78568>>>>>>>>>>>>
78568>>>>>>>>>>>            Send Destroy of hoCLI
78569>>>>>>>>>>>        End
78569>>>>>>>>>>>>
78569>>>>>>>>>>>
78569>>>>>>>>>>>    End_Procedure
78570>>>>>>>>>>>
78570>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78572>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78572>>>>>>>>>>>        Handle hoCLI
78572>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78572>>>>>>>>>>>        tSQLConnection SQLConnection
78572>>>>>>>>>>>        tSQLConnection SQLConnection
78572>>>>>>>>>>>        Boolean bTrusted
78572>>>>>>>>>>>
78572>>>>>>>>>>>        Move 0 to iResult
78573>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78574>>>>>>>>>>>        If (hoCLI <> 0) Begin
78576>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78577>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78578>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78581>>>>>>>>>>>            Decrement iNumConn
78582>>>>>>>>>>>            For iConn from 0 to iNumConn
78588>>>>>>>>>>>>
78588>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78591>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78593>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78594>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78597>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78600>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78601>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78604>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78605>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78606>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78607>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78608>>>>>>>>>>>
78608>>>>>>>>>>>                    Case Begin
78608>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78610>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78611>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78612>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78613>>>>>>>>>>>                            Case Break
78614>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78617>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78618>>>>>>>>>>>                            Case Break
78619>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78622>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78623>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78625>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78626>>>>>>>>>>>                            End
78626>>>>>>>>>>>>
78626>>>>>>>>>>>                            Case Break
78627>>>>>>>>>>>                        Case Else
78627>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78628>>>>>>>>>>>>
78628>>>>>>>>>>>                            Case Break
78629>>>>>>>>>>>                    Case End
78629>>>>>>>>>>>                End
78629>>>>>>>>>>>>
78629>>>>>>>>>>>            Loop
78630>>>>>>>>>>>>
78630>>>>>>>>>>>            Send Destroy of hoCLI
78631>>>>>>>>>>>        End
78631>>>>>>>>>>>>
78631>>>>>>>>>>>
78631>>>>>>>>>>>        Function_Return SQLConnection
78632>>>>>>>>>>>    End_Function
78633>>>>>>>>>>>
78633>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78635>>>>>>>>>>>        String  sCurrentDriver
78635>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78635>>>>>>>>>>>
78635>>>>>>>>>>>        Move 0 to iDriver
78636>>>>>>>>>>>        Move 0 to iCount
78637>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78640>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78646>>>>>>>>>>>>
78646>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78649>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78651>>>>>>>>>>>                Function_Return iCount
78652>>>>>>>>>>>            End
78652>>>>>>>>>>>>
78652>>>>>>>>>>>        Loop
78653>>>>>>>>>>>>
78653>>>>>>>>>>>
78653>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78653>>>>>>>>>>>        If (iDriver = 0) Begin
78655>>>>>>>>>>>            Move 0 to LastErr
78656>>>>>>>>>>>            Load_Driver sDriverID
78657>>>>>>>>>>>            // If driver could not be loaded.
78657>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78659>>>>>>>>>>>                Move -1 to iCount
78660>>>>>>>>>>>            End
78660>>>>>>>>>>>>
78660>>>>>>>>>>>        End
78660>>>>>>>>>>>>
78660>>>>>>>>>>>        Function_Return iCount
78661>>>>>>>>>>>    End_Function
78662>>>>>>>>>>>
78662>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78662>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78664>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78664>>>>>>>>>>>        Boolean bTrusted bSilent
78664>>>>>>>>>>>        Integer iRetval
78664>>>>>>>>>>>
78664>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78665>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78666>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78667>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78668>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78669>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78670>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78671>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78672>>>>>>>>>>>
78672>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78673>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78673>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78674>>>>>>>>>>>    End_Procedure
78675>>>>>>>>>>>
78675>>>>>>>>>>>    // Called when the object is constructed.
78675>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78675>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78675>>>>>>>>>>>    // the database is needed.
78675>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78677>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78677>>>>>>>>>>>        Integer iDriver iRetval
78677>>>>>>>>>>>        Handle hoCLI
78677>>>>>>>>>>>        Boolean bOK bSilent
78677>>>>>>>>>>>
78677>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78678>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78679>>>>>>>>>>>        Get psConnectionString to sConnectionString
78680>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78680>>>>>>>>>>>        Get psDriverID to sDriverID
78681>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78682>>>>>>>>>>>        If (bOK = False) Begin
78684>>>>>>>>>>>            Function_Return False
78685>>>>>>>>>>>        End
78685>>>>>>>>>>>>
78685>>>>>>>>>>>
78685>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78686>>>>>>>>>>>        // If driver not loaded; load it.
78686>>>>>>>>>>>        If (iDriver = 0) Begin
78688>>>>>>>>>>>            Load_Driver sDriverID
78689>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78690>>>>>>>>>>>        End
78690>>>>>>>>>>>>
78690>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78690>>>>>>>>>>>        If (iDriver = 0) Begin
78692>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78693>>>>>>>>>>>>
78693>>>>>>>>>>>            Function_Return False
78694>>>>>>>>>>>        End           
78694>>>>>>>>>>>>
78694>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78697>>>>>>>>>>>        
78697>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78698>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78699>>>>>>>>>>>        // Delete the connection first; in case it exists
78699>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78700>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78701>>>>>>>>>>>        Send Destroy of hoCLI
78702>>>>>>>>>>>
78702>>>>>>>>>>>        Function_Return (iRetval = 0)
78703>>>>>>>>>>>    End_Function
78704>>>>>>>>>>>
78704>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78706>>>>>>>>>>>        Boolean bOK
78706>>>>>>>>>>>
78706>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78707>>>>>>>>>>>
78707>>>>>>>>>>>        If (bOK = False) Begin
78709>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78710>>>>>>>>>>>>
78710>>>>>>>>>>>            Function_Return False
78711>>>>>>>>>>>        End
78711>>>>>>>>>>>>
78711>>>>>>>>>>>
78711>>>>>>>>>>>        Function_Return True
78712>>>>>>>>>>>    End_Function
78713>>>>>>>>>>>
78713>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78715>>>>>>>>>>>        Boolean bOK
78715>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78716>>>>>>>>>>>        Function_Return bOK
78717>>>>>>>>>>>    End_Function
78718>>>>>>>>>>>
78718>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78720>>>>>>>>>>>        Handle hoIniFile
78720>>>>>>>>>>>        String sConnect
78720>>>>>>>>>>>
78720>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78721>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78722>>>>>>>>>>>
78722>>>>>>>>>>>        Function_Return sConnect
78723>>>>>>>>>>>    End_Function
78724>>>>>>>>>>>
78724>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78724>>>>>>>>>>>    // Pass a complete driver connection string
78724>>>>>>>>>>>    // Returns the following as a struct:
78724>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78724>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78724>>>>>>>>>>>    //
78724>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78726>>>>>>>>>>>        tSQLConnection SQLConnection
78726>>>>>>>>>>>        tSQLConnection SQLConnection
78726>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78726>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78726>>>>>>>>>>>        Integer iPos
78726>>>>>>>>>>>
78726>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78727>>>>>>>>>>>        If (bOK = False) Begin
78729>>>>>>>>>>>            Function_Return SQLConnection
78730>>>>>>>>>>>        End
78730>>>>>>>>>>>>
78730>>>>>>>>>>>
78730>>>>>>>>>>>        Move False to bTrusted
78731>>>>>>>>>>>        Move False to bSilent
78732>>>>>>>>>>>
78732>>>>>>>>>>>        Case Begin
78732>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78734>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78735>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78736>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78737>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78738>>>>>>>>>>>                If (bTrusted = False) Begin
78740>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78741>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78742>>>>>>>>>>>                End
78742>>>>>>>>>>>>
78742>>>>>>>>>>>                Case Break
78743>>>>>>>>>>>
78743>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78746>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78748>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78749>>>>>>>>>>>                End
78749>>>>>>>>>>>>
78749>>>>>>>>>>>                Else Begin
78750>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78751>>>>>>>>>>>                End
78751>>>>>>>>>>>>
78751>>>>>>>>>>>
78751>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78752>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78753>>>>>>>>>>>                If (bTrusted = False) Begin
78755>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78756>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78757>>>>>>>>>>>                End
78757>>>>>>>>>>>>
78757>>>>>>>>>>>                Case Break
78758>>>>>>>>>>>
78758>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78761>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78762>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78763>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78764>>>>>>>>>>>                Case Break
78765>>>>>>>>>>>
78765>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78768>>>>>>>>>>>                Break
78769>>>>>>>>>>>        Case End
78769>>>>>>>>>>>
78769>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78770>>>>>>>>>>>
78770>>>>>>>>>>>        // bSilent?
78770>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78771>>>>>>>>>>>        If (iPos = 0) Begin
78773>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78774>>>>>>>>>>>        End
78774>>>>>>>>>>>>
78774>>>>>>>>>>>        If (iPos = 0) Begin
78776>>>>>>>>>>>            Move "0"                                                            to sValue
78777>>>>>>>>>>>        End
78777>>>>>>>>>>>>
78777>>>>>>>>>>>        Else Begin
78778>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78779>>>>>>>>>>>        End
78779>>>>>>>>>>>>
78779>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78780>>>>>>>>>>>
78780>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78781>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78782>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78783>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78784>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78785>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78786>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78787>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78788>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78789>>>>>>>>>>>
78789>>>>>>>>>>>        Function_Return SQLConnection
78790>>>>>>>>>>>    End_Function
78791>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78791>>>>>>>>>>>>
78791>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78793>>>>>>>>>>>>    Integer iStart iEnd
78793>>>>>>>>>>>>    String sRetval
78793>>>>>>>>>>>>
78793>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78794>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78795>>>>>>>>>>>>    If (iStart = 0) Begin
78797>>>>>>>>>>>>        Function_Return ""
78798>>>>>>>>>>>>    End
78798>>>>>>>>>>>>>
78798>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78799>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78800>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78802>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78803>>>>>>>>>>>>    End
78803>>>>>>>>>>>>>
78803>>>>>>>>>>>>    Else Begin
78804>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78805>>>>>>>>>>>>    End
78805>>>>>>>>>>>>>
78805>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78807>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78808>>>>>>>>>>>>        Decrement iEnd
78809>>>>>>>>>>>>    End
78809>>>>>>>>>>>>>
78809>>>>>>>>>>>>    If (iEnd <> 0) Begin
78811>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78812>>>>>>>>>>>>    End
78812>>>>>>>>>>>>>
78812>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78813>>>>>>>>>>>>
78813>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78814>>>>>>>>>>>>End_Function
78815>>>>>>>>>>>>
78815>>>>>>>>>>>>
78815>>>>>>>>>>>
78815>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78815>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78817>>>>>>>>>>>        Handle ho
78817>>>>>>>>>>>        Integer iIndex
78817>>>>>>>>>>>        Boolean bRetval bOK
78817>>>>>>>>>>>        tSQLConnection SQLConnection
78817>>>>>>>>>>>        tSQLConnection SQLConnection
78817>>>>>>>>>>>
78817>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78818>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78819>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78820>>>>>>>>>>>        If (iIndex = -1) Begin
78822>>>>>>>>>>>            Function_Return False
78823>>>>>>>>>>>        End
78823>>>>>>>>>>>>
78823>>>>>>>>>>>
78823>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78824>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78825>>>>>>>>>>>        If (ghoConnection > 0) Begin
78827>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78828>>>>>>>>>>>            If (iIndex <> -1) Begin
78830>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78831>>>>>>>>>>>            End
78831>>>>>>>>>>>>
78831>>>>>>>>>>>        End
78831>>>>>>>>>>>>
78831>>>>>>>>>>>
78831>>>>>>>>>>>        Function_Return bRetval
78832>>>>>>>>>>>    End_Function
78833>>>>>>>>>>>
78833>>>>>>>>>>>End_Class
78834>>>>>>>>>Use vWin32fh.pkg
78834>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78834>>>>>>>>>>>Use LanguageText.pkg
78834>>>>>>>>>>>Use Windows.pkg
78834>>>>>>>>>>>Use Dfclient.pkg
78834>>>>>>>>>>>Use DFbitmap.pkg
78834>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78834>>>>>>>>>>>Use cRichEdit.pkg
78834>>>>>>>>>>>Use cTextEdit.pkg
78834>>>>>>>>>>>Use cRichEdit.pkg
78834>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78834>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78834>>>>>>>>>>>>>>>Use VDFBase.pkg
78834>>>>>>>>>>>>>>>
78834>>>>>>>>>>>>>>>Class cFormatter is an cObject
78835>>>>>>>>>>>>>>>    
78835>>>>>>>>>>>>>>>    Procedure Construct_object
78837>>>>>>>>>>>>>>>        Integer iCh
78837>>>>>>>>>>>>>>>        Forward Send construct_object
78839>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78840>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78841>>>>>>>>>>>>>>>        
78841>>>>>>>>>>>>>>>        Property String  psLeft
78842>>>>>>>>>>>>>>>        Property String  psright
78843>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78844>>>>>>>>>>>>>>>        Property Integer piPoints
78845>>>>>>>>>>>>>>>        
78845>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78846>>>>>>>>>>>>>>>        Property String  psCurPosright
78847>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78848>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78849>>>>>>>>>>>>>>>        
78849>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78850>>>>>>>>>>>>>>>        Property String  psCurNegright
78851>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78852>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78853>>>>>>>>>>>>>>>        
78853>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78854>>>>>>>>>>>>>>>        Property String  psNumPosright
78855>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78856>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78857>>>>>>>>>>>>>>>        
78857>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78858>>>>>>>>>>>>>>>        Property String  psNumNegright
78859>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78860>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78861>>>>>>>>>>>>>>>        
78861>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78862>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78863>>>>>>>>>>>>>>>        
78863>>>>>>>>>>>>>>>    End_Procedure
78864>>>>>>>>>>>>>>>    
78864>>>>>>>>>>>>>>>    // internal
78864>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78864>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78866>>>>>>>>>>>>>>>        
78866>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78866>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78866>>>>>>>>>>>>>>>        
78866>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78866>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78866>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78867>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78868>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78869>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78870>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78871>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78872>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78873>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78874>>>>>>>>>>>>>>>        
78874>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78875>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78878>>>>>>>>>>>>>>>        
78878>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78879>>>>>>>>>>>>>>>        
78879>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78880>>>>>>>>>>>>>>>        
78880>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78880>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78881>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78882>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78883>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78884>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78885>>>>>>>>>>>>>>>        
78885>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78887>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78888>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78890>>>>>>>>>>>>>>>                Move -2 to iDigits
78891>>>>>>>>>>>>>>>                Increment i
78892>>>>>>>>>>>>>>>            End
78892>>>>>>>>>>>>>>>>
78892>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78896>>>>>>>>>>>>>>>                Increment i
78897>>>>>>>>>>>>>>>            Loop
78898>>>>>>>>>>>>>>>>
78898>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78899>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78902>>>>>>>>>>>>>>>            //
78902>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78903>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78907>>>>>>>>>>>>>>>                Increment i
78908>>>>>>>>>>>>>>>            Loop
78909>>>>>>>>>>>>>>>>
78909>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78910>>>>>>>>>>>>>>>        End
78910>>>>>>>>>>>>>>>>
78910>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78911>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78912>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78913>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78915>>>>>>>>>>>>>>>                Move sFmt to sLeft
78916>>>>>>>>>>>>>>>                Move ""   to sRight
78917>>>>>>>>>>>>>>>            End
78917>>>>>>>>>>>>>>>>
78917>>>>>>>>>>>>>>>            Else Begin
78918>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78919>>>>>>>>>>>>>>>                Move 1 to i
78920>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78924>>>>>>>>>>>>>>>                    Increment i
78925>>>>>>>>>>>>>>>                Loop
78926>>>>>>>>>>>>>>>>
78926>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78927>>>>>>>>>>>>>>>            End
78927>>>>>>>>>>>>>>>>
78927>>>>>>>>>>>>>>>        End
78927>>>>>>>>>>>>>>>>
78927>>>>>>>>>>>>>>>        // set temporary format properties and exit
78927>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78928>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78929>>>>>>>>>>>>>>>        Set psRight        to sRight
78930>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78931>>>>>>>>>>>>>>>    End_Procedure
78932>>>>>>>>>>>>>>>    
78932>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78932>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78932>>>>>>>>>>>>>>>    //
78932>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78932>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78934>>>>>>>>>>>>>>>        String sPos sNeg
78934>>>>>>>>>>>>>>>        Integer iPos
78934>>>>>>>>>>>>>>>        
78934>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78935>>>>>>>>>>>>>>>        If iPos Begin
78937>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78938>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78939>>>>>>>>>>>>>>>        End
78939>>>>>>>>>>>>>>>>
78939>>>>>>>>>>>>>>>        Else Begin
78940>>>>>>>>>>>>>>>            Move sFmt         to sPos
78941>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78942>>>>>>>>>>>>>>>        End
78942>>>>>>>>>>>>>>>>
78942>>>>>>>>>>>>>>>        Send ParseFormat sPos
78943>>>>>>>>>>>>>>>        If bCurrency Begin
78945>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78946>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78947>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78948>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78949>>>>>>>>>>>>>>>        End
78949>>>>>>>>>>>>>>>>
78949>>>>>>>>>>>>>>>        Else Begin
78950>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78951>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78952>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78953>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78954>>>>>>>>>>>>>>>        End
78954>>>>>>>>>>>>>>>>
78954>>>>>>>>>>>>>>>        
78954>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78955>>>>>>>>>>>>>>>        If bCurrency Begin
78957>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78958>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78959>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78960>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78961>>>>>>>>>>>>>>>        End
78961>>>>>>>>>>>>>>>>
78961>>>>>>>>>>>>>>>        Else Begin
78962>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78963>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78964>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78965>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78966>>>>>>>>>>>>>>>        End
78966>>>>>>>>>>>>>>>>
78966>>>>>>>>>>>>>>>    End_Procedure
78967>>>>>>>>>>>>>>>    
78967>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78967>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78969>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78969>>>>>>>>>>>>>>>        Integer iDec iLen iCh
78969>>>>>>>>>>>>>>>        
78969>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78972>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78973>>>>>>>>>>>>>>>        
78973>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78974>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78975>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78976>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78977>>>>>>>>>>>>>>>        // format for decimal separator
78977>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78980>>>>>>>>>>>>>>>        
78980>>>>>>>>>>>>>>>        // format for thousand sep.
78980>>>>>>>>>>>>>>>        If bSep Begin
78982>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78985>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78986>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78987>>>>>>>>>>>>>>>            While (iLen>3)
78991>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78992>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
78993>>>>>>>>>>>>>>>            Loop
78994>>>>>>>>>>>>>>>>
78994>>>>>>>>>>>>>>>        End
78994>>>>>>>>>>>>>>>>
78994>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78994>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78997>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78998>>>>>>>>>>>>>>>    End_Function
78999>>>>>>>>>>>>>>>    
78999>>>>>>>>>>>>>>>    // Public: Format for currency
78999>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79001>>>>>>>>>>>>>>>        String  sLeft sRight
79001>>>>>>>>>>>>>>>        Integer bSep
79001>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79003>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79004>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79005>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79006>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79009>>>>>>>>>>>>>>>        End
79009>>>>>>>>>>>>>>>>
79009>>>>>>>>>>>>>>>        Else Begin
79010>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79011>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79012>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79013>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79016>>>>>>>>>>>>>>>        End
79016>>>>>>>>>>>>>>>>
79016>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79017>>>>>>>>>>>>>>>    End_Function
79018>>>>>>>>>>>>>>>    
79018>>>>>>>>>>>>>>>    // Public: Format for numeric
79018>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79020>>>>>>>>>>>>>>>        String  sLeft sRight
79020>>>>>>>>>>>>>>>        Integer bSep
79020>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79022>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79023>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79024>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79025>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79028>>>>>>>>>>>>>>>        End
79028>>>>>>>>>>>>>>>>
79028>>>>>>>>>>>>>>>        Else Begin
79029>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79030>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79031>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79032>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79035>>>>>>>>>>>>>>>        End
79035>>>>>>>>>>>>>>>>
79035>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79036>>>>>>>>>>>>>>>    End_Function
79037>>>>>>>>>>>>>>>    
79037>>>>>>>>>>>>>>>    
79037>>>>>>>>>>>>>>>    // Public: Format passing format string
79037>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79039>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79039>>>>>>>>>>>>>>>        String  sLeft sRight
79039>>>>>>>>>>>>>>>        Integer iPoints bSep
79039>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79040>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79041>>>>>>>>>>>>>>>        Case Begin
79041>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79044>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79048>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79052>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79054>>>>>>>>>>>>>>>        Case End
79054>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79055>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79056>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79057>>>>>>>>>>>>>>>        Get psRight        to sRight
79058>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79059>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79060>>>>>>>>>>>>>>>    End_Function
79061>>>>>>>>>>>>>>>    
79061>>>>>>>>>>>>>>>End_Class
79062>>>>>>>>>>>>>
79062>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79062>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79063>>>>>>>>>>>>>
79063>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79065>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79066>>>>>>>>>>>>>End_Function
79067>>>>>>>>>>>>>
79067>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79069>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79070>>>>>>>>>>>>>End_Function
79071>>>>>>>>>>>>>
79071>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79073>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79074>>>>>>>>>>>>>End_Function
79075>>>>>>>>>>>>>
79075>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79077>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79078>>>>>>>>>>>>>End_Procedure
79079>>>>>>>>>>>>>
79079>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79081>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79082>>>>>>>>>>>>>End_Procedure
79083>>>>>>>>>>>>>
79083>>>>>>>>>>>>>
79083>>>>>>>>>>>Use tWinStructs.pkg
79083>>>>>>>>>>>
79083>>>>>>>>>>>Use cli.pkg
79083>>>>>>>>>>>Use DFBTRDRV.PKG
79083>>>>>>>>>>>Use MSSqldrv.pkg
79083>>>>>>>>>>>Use db2_drv.pkg
79083>>>>>>>>>>>Use odbc_drv.pkg
79083>>>>>>>>>>>Use seq_chnl.pkg
79083>>>>>>>>>>>
79083>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79083>>>>>>>>>>>Register_Function Help_filename Returns String
79083>>>>>>>>>>>Register_Function GetHelpFile Returns String
79083>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79083>>>>>>>>>>>
79083>>>>>>>>>>>// *** Constant Declarations: ***
79083>>>>>>>>>>>//
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>// System icon menu constants. If the upper left hand
79083>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79083>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79083>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79083>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79083>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79083>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79083>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79083>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79083>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79083>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79083>>>>>>>>>>>
79083>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79083>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79083>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79083>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79083>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79083>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79083>>>>>>>>>>>
79083>>>>>>>>>>>// *** Struct Declarations: ***
79083>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79083>>>>>>>>>>>    DWord   cbSize
79083>>>>>>>>>>>    Integer fMask
79083>>>>>>>>>>>    Handle  hwnd
79083>>>>>>>>>>>    Pointer lpVerb
79083>>>>>>>>>>>    Pointer lpFile
79083>>>>>>>>>>>    Pointer lpParameters
79083>>>>>>>>>>>    Pointer lpDirectory
79083>>>>>>>>>>>    Integer nShow
79083>>>>>>>>>>>    Pointer hInstApp
79083>>>>>>>>>>>    Pointer lpIDList
79083>>>>>>>>>>>    Pointer lpClass
79083>>>>>>>>>>>    Handle  hkeyClass
79083>>>>>>>>>>>    DWord   dwHotKey
79083>>>>>>>>>>>    Handle  hIconMonitor // Union
79083>>>>>>>>>>>    //Handle  hMonitor     // Union
79083>>>>>>>>>>>    Handle  hProcess
79083>>>>>>>>>>>End_Struct
79083>>>>>>>>>>>
79083>>>>>>>>>>>
79083>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79083>>>>>>>>>>>//Type MEMORYSTATUS
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79083>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79083>>>>>>>>>>>//End_Type
79083>>>>>>>>>>>
79083>>>>>>>>>>>// *** External Function calls: ***
79083>>>>>>>>>>>//
79083>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79084>>>>>>>>>>>
79084>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79085>>>>>>>>>>>
79085>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79085>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79086>>>>>>>>>>>
79086>>>>>>>>>>>    // Wrapper Function WNetGetUser
79086>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79088>>>>>>>>>>>
79088>>>>>>>>>>>        DWord   dwResult
79088>>>>>>>>>>>        UWide   uwName uwUserName
79088>>>>>>>>>>>        UWide   uwName uwUserName
79088>>>>>>>>>>>
79088>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79089>>>>>>>>>>>
79089>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79090>>>>>>>>>>>
79090>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79091>>>>>>>>>>>
79091>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79092>>>>>>>>>>>
79092>>>>>>>>>>>        Function_Return dwResult
79093>>>>>>>>>>>    End_Function
79094>>>>>>>>>>>
79094>>>>>>>>>>>
79094>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79095>>>>>>>>>>>
79095>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79096>>>>>>>>>>>
79096>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79097>>>>>>>>>>>
79097>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79098>>>>>>>>>>>
79098>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79099>>>>>>>>>>>
79099>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79099>>>>>>>>>>>
79099>>>>>>>>>>>Function ComputerName Desktop Returns String
79101>>>>>>>>>>>    String sName
79101>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79102>>>>>>>>>>>>
79102>>>>>>>>>>>    Function_Return sName
79103>>>>>>>>>>>End_Function
79104>>>>>>>>>>>
79104>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79106>>>>>>>>>>>    WString wName
79106>>>>>>>>>>>    Integer iRetval iLength
79106>>>>>>>>>>>
79106>>>>>>>>>>>    Move 0 to iLength
79107>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79108>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79109>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79110>>>>>>>>>>>
79110>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79112>>>>>>>>>>>        Function_Return (CString (wName))
79113>>>>>>>>>>>    End
79113>>>>>>>>>>>>
79113>>>>>>>>>>>
79113>>>>>>>>>>>    Function_Return "User Unknown"
79114>>>>>>>>>>>End_Function
79115>>>>>>>>>>>
79115>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79117>>>>>>>>>>>    String sClient sDriver sClientDriver
79117>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79117>>>>>>>>>>>    Handle hoMsqlDrv
79117>>>>>>>>>>>
79117>>>>>>>>>>>    Move 0 to iDriver
79118>>>>>>>>>>>    Move "" to sClient
79119>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79122>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79128>>>>>>>>>>>>
79128>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79131>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79133>>>>>>>>>>>            Move iCount to iDriver
79134>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79135>>>>>>>>>>>        End
79135>>>>>>>>>>>>
79135>>>>>>>>>>>    Loop
79136>>>>>>>>>>>>
79136>>>>>>>>>>>
79136>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79136>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79138>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79141>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79142>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79143>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79144>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79145>>>>>>>>>>>    End
79145>>>>>>>>>>>>
79145>>>>>>>>>>>
79145>>>>>>>>>>>    Function_Return sClient
79146>>>>>>>>>>>End_Function
79147>>>>>>>>>>>
79147>>>>>>>>>>>// *** Class Declarations: ***
79147>>>>>>>>>>>//
79147>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79148>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79150>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79151>>>>>>>>>>>    End_Procedure
79152>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79154>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79156>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79157>>>>>>>>>>>    End_Procedure
79158>>>>>>>>>>>End_Class
79159>>>>>>>>>>>
79159>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79160>>>>>>>>>>>    Procedure Construct_Object
79162>>>>>>>>>>>        Forward Send Construct_Object
79164>>>>>>>>>>>        Property Handle phoEditorHandle
79165>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79166>>>>>>>>>>>    End_Procedure
79167>>>>>>>>>>>
79167>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79169>>>>>>>>>>>        Handle hoEditor
79169>>>>>>>>>>>        Boolean bCanCopy
79169>>>>>>>>>>>        Address aEditorAddress
79169>>>>>>>>>>>
79169>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79170>>>>>>>>>>>        Send Select_All of hoEditor
79171>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79172>>>>>>>>>>>        If (bCanCopy = True) Begin
79174>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79175>>>>>>>>>>>            Send Copy   of hoEditor
79176>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79176>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79177>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79178>>>>>>>>>>>        End
79178>>>>>>>>>>>>
79178>>>>>>>>>>>    End_Procedure
79179>>>>>>>>>>>End_Class
79180>>>>>>>>>>>
79180>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79181>>>>>>>>>>>    Procedure Construct_Object
79183>>>>>>>>>>>        Forward Send Construct_Object
79185>>>>>>>>>>>
79185>>>>>>>>>>>        Set Size to 100 245
79186>>>>>>>>>>>        Set Location to 6 6
79187>>>>>>>>>>>        Set Border_Style to Border_None
79188>>>>>>>>>>>        Set Read_Only_State to True
79189>>>>>>>>>>>        Set pbWrap to True
79190>>>>>>>>>>>        Set peAnchors to anAll
79191>>>>>>>>>>>    End_Procedure
79192>>>>>>>>>>>
79192>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79192>>>>>>>>>>>
79192>>>>>>>>>>>    Procedure AppendTextLn String sText
79194>>>>>>>>>>>        String sWorkspaceWSFile
79194>>>>>>>>>>>
79194>>>>>>>>>>>        // Only works for English:
79194>>>>>>>>>>>        If (ghoApplication > 0) Begin
79196>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79198>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79199>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79200>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79201>>>>>>>>>>>            End
79201>>>>>>>>>>>>
79201>>>>>>>>>>>        End
79201>>>>>>>>>>>>
79201>>>>>>>>>>>        Send AppendText sText
79202>>>>>>>>>>>        Send AppendText (character(10))
79203>>>>>>>>>>>    End_Procedure
79204>>>>>>>>>>>
79204>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79204>>>>>>>>>>>    //    information box
79204>>>>>>>>>>>    Procedure Show_Current_Directory
79206>>>>>>>>>>>        String sDir
79206>>>>>>>>>>>
79206>>>>>>>>>>>        Get_Current_Directory To sDir
79207>>>>>>>>>>>
79207>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79208>>>>>>>>>>>    End_Procedure
79209>>>>>>>>>>>
79209>>>>>>>>>>>    Procedure Show_Windows_Directory
79211>>>>>>>>>>>        String sWindir
79211>>>>>>>>>>>
79211>>>>>>>>>>>        Get_Windows_Directory To sWindir
79212>>>>>>>>>>>
79212>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79213>>>>>>>>>>>    End_Procedure
79214>>>>>>>>>>>
79214>>>>>>>>>>>    Procedure Show_Current_User
79216>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79217>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79218>>>>>>>>>>>    End_Procedure
79219>>>>>>>>>>>
79219>>>>>>>>>>>    Procedure Show_Number_Format
79221>>>>>>>>>>>        Integer iFormat
79221>>>>>>>>>>>        String sFormatText
79221>>>>>>>>>>>
79221>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79224>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79225>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79226>>>>>>>>>>>
79226>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79229>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79230>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79231>>>>>>>>>>>    End_Procedure
79232>>>>>>>>>>>
79232>>>>>>>>>>>    Procedure Show_Filelist_Name
79234>>>>>>>>>>>        String sFilename
79234>>>>>>>>>>>
79234>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79237>>>>>>>>>>>
79237>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79238>>>>>>>>>>>    End_Procedure
79239>>>>>>>>>>>
79239>>>>>>>>>>>    Procedure Show_Lock_Delay
79241>>>>>>>>>>>        Integer iLockdelay
79241>>>>>>>>>>>
79241>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79244>>>>>>>>>>>
79244>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79245>>>>>>>>>>>    End_Procedure
79246>>>>>>>>>>>
79246>>>>>>>>>>>    Procedure Show_Lock_Timeout
79248>>>>>>>>>>>        Integer iLockTimeout
79248>>>>>>>>>>>
79248>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79251>>>>>>>>>>>
79251>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79252>>>>>>>>>>>    End_Procedure
79253>>>>>>>>>>>
79253>>>>>>>>>>>    Procedure Show_Screen_Size
79255>>>>>>>>>>>        Integer iYscreensize iXscreensize
79255>>>>>>>>>>>
79255>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79256>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79257>>>>>>>>>>>
79257>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79258>>>>>>>>>>>    End_Procedure
79259>>>>>>>>>>>
79259>>>>>>>>>>>    Procedure Show_Page_Size
79261>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79262>>>>>>>>>>>    End_procedure
79263>>>>>>>>>>>
79263>>>>>>>>>>>    Procedure Show_Date
79265>>>>>>>>>>>        Date dToday
79265>>>>>>>>>>>
79265>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79266>>>>>>>>>>>
79266>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79267>>>>>>>>>>>    End_procedure
79268>>>>>>>>>>>
79268>>>>>>>>>>>    Procedure Show_Date_Format
79270>>>>>>>>>>>        Integer iDateFormat
79270>>>>>>>>>>>        String sDateFormat
79270>>>>>>>>>>>
79270>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79273>>>>>>>>>>>        Case Begin
79273>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79275>>>>>>>>>>>                Move C_$USA To sDateFormat
79276>>>>>>>>>>>                Case Break
79277>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79280>>>>>>>>>>>                Move C_$European To sDateFormat
79281>>>>>>>>>>>                Case Break
79282>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79285>>>>>>>>>>>                Move C_$Military To sDateFormat
79286>>>>>>>>>>>                Case Break
79287>>>>>>>>>>>            Case Else
79287>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79288>>>>>>>>>>>                Case Break
79289>>>>>>>>>>>        Case End
79289>>>>>>>>>>>
79289>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79290>>>>>>>>>>>    End_Procedure
79291>>>>>>>>>>>
79291>>>>>>>>>>>    // 2013-08-14 NGS
79291>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79291>>>>>>>>>>>    Procedure Show_Systemresources
79293>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79293>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79293>>>>>>>>>>>        Integer iRetval
79293>>>>>>>>>>>        Number nValue
79293>>>>>>>>>>>        String sValue
79293>>>>>>>>>>>
79293>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79294>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79295>>>>>>>>>>>        If (iRetval = 0) Begin
79297>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79298>>>>>>>>>>>            Procedure_Return
79299>>>>>>>>>>>        End
79299>>>>>>>>>>>>
79299>>>>>>>>>>>
79299>>>>>>>>>>>        Send AppendTextLn ""
79300>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79301>>>>>>>>>>>
79301>>>>>>>>>>>        // Show memory in Gigabytes:
79301>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79302>>>>>>>>>>>        Move (Round(nValue)) to nValue
79303>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79304>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79305>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79306>>>>>>>>>>>
79306>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79306>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79307>>>>>>>>>>>        Move (Round(nValue)) to nValue
79308>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79309>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79310>>>>>>>>>>>
79310>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79310>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79311>>>>>>>>>>>        Move (Round(nValue)) to nValue
79312>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79313>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79314>>>>>>>>>>>
79314>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79314>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79315>>>>>>>>>>>        Move (Round(nValue)) to nValue
79316>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79317>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79318>>>>>>>>>>>
79318>>>>>>>>>>>        // Add an empty row after the memory information:
79318>>>>>>>>>>>        Send AppendTextLn ""
79319>>>>>>>>>>>    End_Procedure
79320>>>>>>>>>>>
79320>>>>>>>>>>>    Procedure Show_Registration
79322>>>>>>>>>>>        String sRegName
79322>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79322>>>>>>>>>>>
79322>>>>>>>>>>>        Registration sRegName iSN
79323>>>>>>>>>>>>
79323>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79324>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79325>>>>>>>>>>>
79325>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79326>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79327>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79328>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79329>>>>>>>>>>>    End_Procedure
79330>>>>>>>>>>>
79330>>>>>>>>>>>    //****************************************************************************
79330>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79330>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79330>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79330>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79330>>>>>>>>>>>    // information To be displayed
79330>>>>>>>>>>>    //****************************************************************************
79330>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79330>>>>>>>>>>>
79330>>>>>>>>>>>    Procedure Show_ServicePack
79332>>>>>>>>>>>        String sKey sVersion sDataFlex
79332>>>>>>>>>>>        Handle hoRegistry
79332>>>>>>>>>>>        Boolean bExists bOpened
79332>>>>>>>>>>>
79332>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79333>>>>>>>>>>>
79333>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79334>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79335>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79336>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79337>>>>>>>>>>>
79337>>>>>>>>>>>        If (bExists) Begin
79339>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79340>>>>>>>>>>>        End
79340>>>>>>>>>>>>
79340>>>>>>>>>>>        Else Begin
79341>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79342>>>>>>>>>>>        End
79342>>>>>>>>>>>>
79342>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79343>>>>>>>>>>>        If (bExists) Begin
79345>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79346>>>>>>>>>>>            If (bOpened) Begin
79348>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79349>>>>>>>>>>>                If (bExists) Begin
79351>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79352>>>>>>>>>>>                End
79352>>>>>>>>>>>>
79352>>>>>>>>>>>                Send CloseKey of hoRegistry
79353>>>>>>>>>>>            End
79353>>>>>>>>>>>>
79353>>>>>>>>>>>        End
79353>>>>>>>>>>>>
79353>>>>>>>>>>>        Send Destroy of hoRegistry
79354>>>>>>>>>>>
79354>>>>>>>>>>>        If (sVersion <> "") Begin
79356>>>>>>>>>>>           Send AppendTextLn sVersion
79357>>>>>>>>>>>           Send AppendTextLn ""
79358>>>>>>>>>>>        End
79358>>>>>>>>>>>>
79358>>>>>>>>>>>    End_Procedure
79359>>>>>>>>>>>
79359>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79361>>>>>>>>>>>        Integer hoWorkspace
79361>>>>>>>>>>>
79361>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79363>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79364>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79366>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79367>>>>>>>>>>>            End
79367>>>>>>>>>>>>
79367>>>>>>>>>>>        End
79367>>>>>>>>>>>>
79367>>>>>>>>>>>    End_Procedure
79368>>>>>>>>>>>
79368>>>>>>>>>>>    //****************************************************************************
79368>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79368>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79368>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79368>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79368>>>>>>>>>>>    // the information To be displayed
79368>>>>>>>>>>>    //****************************************************************************
79368>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79368>>>>>>>>>>>
79368>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79370>>>>>>>>>>>        If (ghoConnection > 0) Begin
79372>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79373>>>>>>>>>>>            Send AppendTextLn ""
79374>>>>>>>>>>>        End
79374>>>>>>>>>>>>
79374>>>>>>>>>>>    End_Procedure
79375>>>>>>>>>>>
79375>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79377>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79378>>>>>>>>>>>    End_Function
79379>>>>>>>>>>>
79379>>>>>>>>>>>    Procedure Show_Versions
79381>>>>>>>>>>>        Integer iVersion iRevision iBuild
79381>>>>>>>>>>>
79381>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79383>>>>>>>>>>>
79383>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79384>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79385>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79386>>>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79387>>>>>>>>>>>    End_Procedure
79388>>>>>>>>>>>
79388>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79390>>>>>>>>>>>        Boolean bOK
79390>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79391>>>>>>>>>>>        Function_Return bOK
79392>>>>>>>>>>>    End_Function
79393>>>>>>>>>>>
79393>>>>>>>>>>>    //***
79393>>>>>>>>>>>    //*** BW
79393>>>>>>>>>>>    //*** Procedure: Show_Drivers
79393>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79393>>>>>>>>>>>    //***
79393>>>>>>>>>>>
79393>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79393>>>>>>>>>>>//    #Warning -3
79393>>>>>>>>>>>//#ENDIF
79393>>>>>>>>>>>    Procedure Show_Drivers
79395>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79395>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79395>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79395>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79395>>>>>>>>>>>
79395>>>>>>>>>>>        Move False to bStudioLicense
79396>>>>>>>>>>>
79396>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79397>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79398>>>>>>>>>>>
79398>>>>>>>>>>>        // For testing purposes:
79398>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79398>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79398>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79398>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79398>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79398>>>>>>>>>>>//
79398>>>>>>>>>>>        Move False to Err
79399>>>>>>>>>>>
79399>>>>>>>>>>>        // Loop through all loaded drivers.
79399>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79402>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79404>>>>>>>>>>>            Send AppendTextLn ""
79405>>>>>>>>>>>        End
79405>>>>>>>>>>>>
79405>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79411>>>>>>>>>>>>
79411>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79412>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79415>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79416>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79417>>>>>>>>>>>
79417>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79419>>>>>>>>>>>
79419>>>>>>>>>>>                // Pervasive/Btrieve database
79419>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79421>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79422>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79423>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79425>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79426>>>>>>>>>>>                    End
79426>>>>>>>>>>>>
79426>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79427>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79429>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79430>>>>>>>>>>>                    End
79430>>>>>>>>>>>>
79430>>>>>>>>>>>                End
79430>>>>>>>>>>>>
79430>>>>>>>>>>>
79430>>>>>>>>>>>                Else Begin
79431>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79432>>>>>>>>>>>                    Move 0 to iNumServers
79433>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79435>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79438>>>>>>>>>>>                    End
79438>>>>>>>>>>>>
79438>>>>>>>>>>>
79438>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79440>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79442>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79443>>>>>>>>>>>                        End
79443>>>>>>>>>>>>
79443>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79444>>>>>>>>>>>                    End
79444>>>>>>>>>>>>
79444>>>>>>>>>>>
79444>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79444>>>>>>>>>>>                    // Studio licens is in use and there is no
79444>>>>>>>>>>>                    // number of max users defined because the driver is
79444>>>>>>>>>>>                    // relying on the info from the VDF license.
79444>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79446>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79447>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79448>>>>>>>>>>>                    End
79448>>>>>>>>>>>>
79448>>>>>>>>>>>                End
79448>>>>>>>>>>>>
79448>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79449>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79451>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79452>>>>>>>>>>>                End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>                If (iNumServers <> 0) Begin
79454>>>>>>>>>>>                    For iCount from 1 to iNumServers
79460>>>>>>>>>>>>
79460>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79463>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79465>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79466>>>>>>>>>>>                        End
79466>>>>>>>>>>>>
79466>>>>>>>>>>>                    Loop
79467>>>>>>>>>>>>
79467>>>>>>>>>>>                End
79467>>>>>>>>>>>>
79467>>>>>>>>>>>            End
79467>>>>>>>>>>>>
79467>>>>>>>>>>>        Loop
79468>>>>>>>>>>>>
79468>>>>>>>>>>>
79468>>>>>>>>>>>        Send AppendTextLn ""
79469>>>>>>>>>>>        If (bStudioLicense = False) Begin
79471>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79472>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79473>>>>>>>>>>>        End
79473>>>>>>>>>>>>
79473>>>>>>>>>>>        Else Begin
79474>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79475>>>>>>>>>>>        End
79475>>>>>>>>>>>>
79475>>>>>>>>>>>        Send Destroy of hoCLIHandler
79476>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79477>>>>>>>>>>>    End_Procedure
79478>>>>>>>>>>>
79478>>>>>>>>>>>    Procedure Show_HelpFile
79480>>>>>>>>>>>        String sHelpFile
79480>>>>>>>>>>>        Integer eHelpType
79480>>>>>>>>>>>
79480>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79482>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79483>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79485>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79486>>>>>>>>>>>            End
79486>>>>>>>>>>>>
79486>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79489>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79490>>>>>>>>>>>            End
79490>>>>>>>>>>>>
79490>>>>>>>>>>>            Else Begin
79491>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79492>>>>>>>>>>>            End
79492>>>>>>>>>>>>
79492>>>>>>>>>>>
79492>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79493>>>>>>>>>>>        End
79493>>>>>>>>>>>>
79493>>>>>>>>>>>    End_Procedure
79494>>>>>>>>>>>
79494>>>>>>>>>>>    Procedure Show_EnterAsTab
79496>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79496>>>>>>>>>>>        String sText
79496>>>>>>>>>>>
79496>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79498>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79499>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79501>>>>>>>>>>>                Move "True" To sText
79502>>>>>>>>>>>            End
79502>>>>>>>>>>>>
79502>>>>>>>>>>>            Else Begin
79503>>>>>>>>>>>                Move "False" To sText
79504>>>>>>>>>>>            End
79504>>>>>>>>>>>>
79504>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79505>>>>>>>>>>>        End
79505>>>>>>>>>>>>
79505>>>>>>>>>>>    End_Procedure
79506>>>>>>>>>>>
79506>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79506>>>>>>>>>>>    //    found systeminformation
79506>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79508>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79510>>>>>>>>>>>
79510>>>>>>>>>>>        Send Delete_Data
79511>>>>>>>>>>>
79511>>>>>>>>>>>        Set Changed_State To False
79512>>>>>>>>>>>        Set Read_Only_State To True
79513>>>>>>>>>>>
79513>>>>>>>>>>>        Send Show_Registration
79514>>>>>>>>>>>        Send Show_Drivers
79515>>>>>>>>>>>        Send Show_ServicePack
79516>>>>>>>>>>>        Send Show_Versions
79517>>>>>>>>>>>        Send AppendTextLn ""
79518>>>>>>>>>>>
79518>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79520>>>>>>>>>>>            Send Show_WorkSpaceInformation
79521>>>>>>>>>>>            Send Show_HelpFile
79522>>>>>>>>>>>            Send AppendTextLn ""
79523>>>>>>>>>>>        End
79523>>>>>>>>>>>>
79523>>>>>>>>>>>        Else Begin
79524>>>>>>>>>>>            Send AppendTextLn ""
79525>>>>>>>>>>>        End
79525>>>>>>>>>>>>
79525>>>>>>>>>>>
79525>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79527>>>>>>>>>>>            Send Show_ConnectionIdInformation
79528>>>>>>>>>>>        End
79528>>>>>>>>>>>>
79528>>>>>>>>>>>
79528>>>>>>>>>>>        Send Show_Current_User
79529>>>>>>>>>>>        Send Show_Windows_Directory
79530>>>>>>>>>>>        Send Show_Current_Directory
79531>>>>>>>>>>>
79531>>>>>>>>>>>        // This is already shown in the workspace details,
79531>>>>>>>>>>>        // unless no workspace object is present:
79531>>>>>>>>>>>        If (ghoApplication = 0) Begin
79533>>>>>>>>>>>            Send Show_Filelist_Name
79534>>>>>>>>>>>        End
79534>>>>>>>>>>>>
79534>>>>>>>>>>>
79534>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79536>>>>>>>>>>>            Send AppendTextLn ""
79537>>>>>>>>>>>            Send Show_EnterAsTab
79538>>>>>>>>>>>        End
79538>>>>>>>>>>>>
79538>>>>>>>>>>>
79538>>>>>>>>>>>        Send Show_Screen_Size
79539>>>>>>>>>>>        Send Show_Page_Size
79540>>>>>>>>>>>        Send Show_Number_Format
79541>>>>>>>>>>>        Send Show_Date_Format
79542>>>>>>>>>>>        Send Show_Lock_Delay
79543>>>>>>>>>>>        Send Show_Lock_Timeout
79544>>>>>>>>>>>        Send Show_Date
79545>>>>>>>>>>>        Send Show_Systemresources
79546>>>>>>>>>>>        Send Beginning_of_Data
79547>>>>>>>>>>>
79547>>>>>>>>>>>        Set Icon to 'default.ico'
79548>>>>>>>>>>>    End_Procedure
79549>>>>>>>>>>>End_Class
79550>>>>>>>>>>>
79550>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79551>>>>>>>>>>>    Procedure Construct_Object
79553>>>>>>>>>>>        Forward Send Construct_Object
79555>>>>>>>>>>>
79555>>>>>>>>>>>        Set Label to C_$SystemInformation
79556>>>>>>>>>>>        Set Size to 140 267
79557>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79558>>>>>>>>>>>        Set Border_Style to Border_Thick
79559>>>>>>>>>>>        Set Sysmenu_Icon to False
79560>>>>>>>>>>>
79560>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79560>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79561>>>>>>>>>>>
79561>>>>>>>>>>>        // 2014-09-14 NGS
79561>>>>>>>>>>>        // Added a container object around the cTexteditor
79561>>>>>>>>>>>        // object to get a border around the text.
79561>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79563>>>>>>>>>>>            Set Location to 2 4
79564>>>>>>>>>>>            Set Size to 110 255
79565>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79566>>>>>>>>>>>            Set Color to clWhite
79567>>>>>>>>>>>            Set peAnchors to anAll
79568>>>>>>>>>>>
79568>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79570>>>>>>>>>>>            End_Object
79571>>>>>>>>>>>
79571>>>>>>>>>>>        End_Object
79572>>>>>>>>>>>
79572>>>>>>>>>>>        Object oCloseButton is a Button
79574>>>>>>>>>>>            Set Label to C_$Close
79575>>>>>>>>>>>            Set Location to 120 210
79576>>>>>>>>>>>            CompilerWarnings Off
79576>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79577>>>>>>>>>>>            CompilerWarnings On
79577>>>>>>>>>>>            Set Default_State To True
79578>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79578>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79578>>>>>>>>>>>            // for that situation.
79578>>>>>>>>>>>            Set peAnchors to anBottomRight
79579>>>>>>>>>>>        End_Object
79580>>>>>>>>>>>
79580>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79582>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79583>>>>>>>>>>>            Set Size to 14 50
79584>>>>>>>>>>>            Set Location to 120 158
79585>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79585>>>>>>>>>>>            // we might as well prepare the object for it.
79585>>>>>>>>>>>            Set peAnchors to anBottomRight
79586>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79587>>>>>>>>>>>        End_Object
79588>>>>>>>>>>>
79588>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79589>>>>>>>>>>>    End_Procedure
79590>>>>>>>>>>>
79590>>>>>>>>>>>    Procedure Page Integer iPageObject
79592>>>>>>>>>>>        Handle hMenu
79592>>>>>>>>>>>        Integer iPrevState
79592>>>>>>>>>>>
79592>>>>>>>>>>>        Forward Send Page iPageObject
79594>>>>>>>>>>>
79594>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79594>>>>>>>>>>>        //
79594>>>>>>>>>>>    End_Procedure
79595>>>>>>>>>>>
79595>>>>>>>>>>>End_Class
79596>>>>>>>>>>>
79596>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79597>>>>>>>>>>>    Procedure Construct_Object
79599>>>>>>>>>>>        Forward Send Construct_Object
79601>>>>>>>>>>>
79601>>>>>>>>>>>        Property String psContentText
79602>>>>>>>>>>>
79602>>>>>>>>>>>        Set Size to 77 153
79603>>>>>>>>>>>        Set Location to 8 60
79604>>>>>>>>>>>        Set Read_Only_State to True
79605>>>>>>>>>>>        Set Skip_State to True
79606>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79606>>>>>>>>>>>        // or 1/20 of a printer's point.
79606>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79607>>>>>>>>>>>        Set Border_Style  to Border_None
79608>>>>>>>>>>>    End_Procedure
79609>>>>>>>>>>>
79609>>>>>>>>>>>    // Adds a line of text to the edit object
79609>>>>>>>>>>>    Procedure Add_Line String sText
79611>>>>>>>>>>>        String sContentText
79611>>>>>>>>>>>        Get psContentText to sContentText
79612>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79613>>>>>>>>>>>        Set psContentText to sContentText
79614>>>>>>>>>>>    End_Procedure
79615>>>>>>>>>>>
79615>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79615>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79615>>>>>>>>>>>    // because the object isn't paged yet when we add these
79615>>>>>>>>>>>    // values and the COM edit object needs to be paged
79615>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79615>>>>>>>>>>>    Procedure Add_LineLn String sText
79617>>>>>>>>>>>        String sContentText sCR
79617>>>>>>>>>>>
79617>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79618>>>>>>>>>>>        Get psContentText to sContentText
79619>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79620>>>>>>>>>>>        Set psContentText to sContentText
79621>>>>>>>>>>>    End_Procedure
79622>>>>>>>>>>>
79622>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79624>>>>>>>>>>>        String sLinkText
79624>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79625>>>>>>>>>>>        Send Show_HomePage sLinkText
79626>>>>>>>>>>>    End_Procedure
79627>>>>>>>>>>>
79627>>>>>>>>>>>    Procedure Page Integer iPageObject
79629>>>>>>>>>>>        String sContentText
79629>>>>>>>>>>>
79629>>>>>>>>>>>        Forward Send Page iPageObject
79631>>>>>>>>>>>        Get psContentText to sContentText
79632>>>>>>>>>>>        Send AppendText sContentText
79633>>>>>>>>>>>        send Beginning_of_Data
79634>>>>>>>>>>>    End_Procedure
79635>>>>>>>>>>>
79635>>>>>>>>>>>End_Class
79636>>>>>>>>>>>
79636>>>>>>>>>>>Class AboutDialog is a ModalPanel
79637>>>>>>>>>>>    Procedure Construct_Object
79639>>>>>>>>>>>
79639>>>>>>>>>>>        Forward Send Construct_Object
79641>>>>>>>>>>>
79641>>>>>>>>>>>        Set Label to C_$About
79642>>>>>>>>>>>        Set Size to 118 230
79643>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79644>>>>>>>>>>>        Set Border_Style to Border_Thick
79645>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79646>>>>>>>>>>>
79646>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79648>>>>>>>>>>>        End_Object
79649>>>>>>>>>>>
79649>>>>>>>>>>>        Object oBox is a Container3d
79651>>>>>>>>>>>            Set Border_Style to Border_Normal
79652>>>>>>>>>>>            Set Size to 90 220
79653>>>>>>>>>>>            Set Location to 4 5
79654>>>>>>>>>>>            Set Color to clWhite
79655>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79655>>>>>>>>>>>            // we might as well prepare the object for it.
79655>>>>>>>>>>>            Set peAnchors to anAll
79656>>>>>>>>>>>
79656>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79658>>>>>>>>>>>                Set Border_Style To Border_None
79659>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79660>>>>>>>>>>>                Set Color to clWhite
79661>>>>>>>>>>>                Set Size to 45 50
79662>>>>>>>>>>>                Set Location to 0 3
79663>>>>>>>>>>>            End_Object
79664>>>>>>>>>>>
79664>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79666>>>>>>>>>>>                Set Border_Style to Border_None
79667>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79668>>>>>>>>>>>                Set Color to clWhite
79669>>>>>>>>>>>                Set Size to 30 55
79670>>>>>>>>>>>                Set Location to 50 3
79671>>>>>>>>>>>            End_Object
79672>>>>>>>>>>>
79672>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79674>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79674>>>>>>>>>>>                // we might as well prepare the object for it.
79674>>>>>>>>>>>                Set peAnchors to anAll
79675>>>>>>>>>>>            End_Object
79676>>>>>>>>>>>
79676>>>>>>>>>>>            // These objects are here for backwards compatability only.
79676>>>>>>>>>>>            // They are not used.
79676>>>>>>>>>>>            Object oProductName is a TextBox
79678>>>>>>>>>>>                Set Label To C_$ProductName
79679>>>>>>>>>>>                Set Size To 10 45
79680>>>>>>>>>>>                Set Location To 8 53
79681>>>>>>>>>>>                Set Visible_State to False
79682>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79683>>>>>>>>>>>            End_Object
79684>>>>>>>>>>>
79684>>>>>>>>>>>            Object oVersion is a TextBox
79686>>>>>>>>>>>                Set Label To C_$Version
79687>>>>>>>>>>>                Set Size To 10 25
79688>>>>>>>>>>>                Set Location To 21 53
79689>>>>>>>>>>>                Set Visible_State to False
79690>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79691>>>>>>>>>>>            End_Object
79692>>>>>>>>>>>
79692>>>>>>>>>>>            Object oCopyright is a TextBox
79694>>>>>>>>>>>                Set Label To C_$Copyright
79695>>>>>>>>>>>                Set Size To 10 31
79696>>>>>>>>>>>                Set Location To 34 53
79697>>>>>>>>>>>                Set Visible_State to False
79698>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79699>>>>>>>>>>>            End_Object
79700>>>>>>>>>>>
79700>>>>>>>>>>>            Object oAuthor is a TextBox
79702>>>>>>>>>>>                Set Label To C_$Author
79703>>>>>>>>>>>                Set Size To 10 22
79704>>>>>>>>>>>                Set Location To 46 53
79705>>>>>>>>>>>                Set Visible_State to False
79706>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79707>>>>>>>>>>>            End_Object
79708>>>>>>>>>>>
79708>>>>>>>>>>>        End_Object
79709>>>>>>>>>>>
79709>>>>>>>>>>>        Object oOKButton is a Button
79711>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79712>>>>>>>>>>>            Set Location to 98 176
79713>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79713>>>>>>>>>>>            // we might as well prepare the object for it.
79713>>>>>>>>>>>            Set peAnchors to anBottomRight
79714>>>>>>>>>>>        End_Object
79715>>>>>>>>>>>
79715>>>>>>>>>>>        Object oSysInfoButton is a Button
79717>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79718>>>>>>>>>>>            Set Location to 98 123
79719>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79719>>>>>>>>>>>            // we might as well prepare the object for it.
79719>>>>>>>>>>>            Set peAnchors to anBottomRight
79720>>>>>>>>>>>        End_Object
79721>>>>>>>>>>>
79721>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79723>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79724>>>>>>>>>>>            Set Size to 14 50
79725>>>>>>>>>>>            Set Location to 98 70
79726>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79726>>>>>>>>>>>            // we might as well prepare the object for it.
79726>>>>>>>>>>>            Set peAnchors to anBottomRight
79727>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79728>>>>>>>>>>>        End_Object
79729>>>>>>>>>>>
79729>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79730>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79731>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79732>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79732>>>>>>>>>>>    End_Procedure
79733>>>>>>>>>>>
79733>>>>>>>>>>>    Procedure Page Integer iPageObject
79735>>>>>>>>>>>        Handle hMenu
79735>>>>>>>>>>>        Integer iPrevState
79735>>>>>>>>>>>
79735>>>>>>>>>>>        Forward Send Page iPageObject
79737>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79737>>>>>>>>>>>        Set Icon to "Default.ico"
79738>>>>>>>>>>>
79738>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79738>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79739>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79740>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79740>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79740>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79741>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79742>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79743>>>>>>>>>>>        // The "Close" menu command may be good to have.
79743>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79743>>>>>>>>>>>    End_Procedure
79744>>>>>>>>>>>
79744>>>>>>>>>>>    Procedure Set ProductName String sText
79746>>>>>>>>>>>        Set Value of oProductName to sText
79747>>>>>>>>>>>    End_Procedure
79748>>>>>>>>>>>
79748>>>>>>>>>>>    Procedure Set Copyright String sText
79750>>>>>>>>>>>        Set Value of oCopyright to sText
79751>>>>>>>>>>>    End_Procedure
79752>>>>>>>>>>>
79752>>>>>>>>>>>    Procedure Set Author String sText
79754>>>>>>>>>>>        Set Value of oAuthor to sText
79755>>>>>>>>>>>    End_Procedure
79756>>>>>>>>>>>
79756>>>>>>>>>>>    Procedure Set Version String sVersion
79758>>>>>>>>>>>        Handle hoVersionInfo
79758>>>>>>>>>>>        Boolean bIncluded
79758>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
79758>>>>>>>>>>>//        Date dCompileDate
79758>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79758>>>>>>>>>>>
79758>>>>>>>>>>>        If (sVersion = "") Begin
79760>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79760>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79760>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79762>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79763>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79765>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79766>>>>>>>>>>>                    If (bIncluded) Begin
79768>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79769>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79770>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79771>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79772>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79773>>>>>>>>>>>                    End
79773>>>>>>>>>>>>
79773>>>>>>>>>>>                End
79773>>>>>>>>>>>>
79773>>>>>>>>>>>            End
79773>>>>>>>>>>>>
79773>>>>>>>>>>>        End
79773>>>>>>>>>>>>
79773>>>>>>>>>>>
79773>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79773>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79774>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79776>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79777>>>>>>>>>>>        End
79777>>>>>>>>>>>>
79777>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
79777>>>>>>>>>>>//        If (sVersion <> "") Begin
79777>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79777>>>>>>>>>>>//        End
79777>>>>>>>>>>>
79777>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79778>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79780>>>>>>>>>>>            If (sCertInfo <> "") Begin
79782>>>>>>>>>>>                Send Add_LineLn sCertInfo
79783>>>>>>>>>>>            End
79783>>>>>>>>>>>>
79783>>>>>>>>>>>            Else Begin
79784>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79785>>>>>>>>>>>            End
79785>>>>>>>>>>>>
79785>>>>>>>>>>>        End
79785>>>>>>>>>>>>
79785>>>>>>>>>>>    End_Procedure
79786>>>>>>>>>>>
79786>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79788>>>>>>>>>>>        Boolean bIsDate
79788>>>>>>>>>>>        String sGoodCharacters sChar
79788>>>>>>>>>>>        Integer iCount iLength
79788>>>>>>>>>>>
79788>>>>>>>>>>>        Move True to bIsDate
79789>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79790>>>>>>>>>>>        Move (Length(sDate)) to iLength
79791>>>>>>>>>>>        For iCount from 1 to iLength
79797>>>>>>>>>>>>
79797>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79798>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79799>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79800>>>>>>>>>>>            If (bIsDate = False) Begin
79802>>>>>>>>>>>                Move iLength to iCount
79803>>>>>>>>>>>            End
79803>>>>>>>>>>>>
79803>>>>>>>>>>>        Loop
79804>>>>>>>>>>>>
79804>>>>>>>>>>>        Function_Return bIsDate
79805>>>>>>>>>>>    End_Function
79806>>>>>>>>>>>
79806>>>>>>>>>>>    Function GetCompileDate Returns Date
79808>>>>>>>>>>>        Date dCompileDate
79808>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79808>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79808>>>>>>>>>>>        Boolean bIsValid   
79808>>>>>>>>>>>        
79808>>>>>>>>>>>        Move 0 to dCompileDate
79809>>>>>>>>>>>        // Get full path to the current running executable
79809>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79810>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79811>>>>>>>>>>>
79811>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79811>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79812>>>>>>>>>>>
79812>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79814>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79815>>>>>>>>>>>        If (iPos > 0) Begin
79817>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79817>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79818>>>>>>>>>>>
79818>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79818>>>>>>>>>>>            // change the format and then move the string to the date variable.
79818>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79821>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79824>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79825>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79827>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79828>>>>>>>>>>>            End
79828>>>>>>>>>>>>
79828>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79829>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79830>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79833>>>>>>>>>>>        End
79833>>>>>>>>>>>>
79833>>>>>>>>>>>        Else Begin
79834>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79835>>>>>>>>>>>>
79835>>>>>>>>>>>        End
79835>>>>>>>>>>>>
79835>>>>>>>>>>>
79835>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79836>>>>>>>>>>>
79836>>>>>>>>>>>        Function_Return dCompileDate
79837>>>>>>>>>>>    End_Function
79838>>>>>>>>>>>
79838>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79838>>>>>>>>>>>    // (the passed program), has been finished
79838>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79838>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79840>>>>>>>>>>>        Handle hProcess
79840>>>>>>>>>>>        Integer iVoid
79840>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79840>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79840>>>>>>>>>>>
79840>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79841>>>>>>>>>>>
79841>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79842>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79843>>>>>>>>>>>
79843>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79844>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79845>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79845>>>>>>>>>>>        Move 0                       to sInfo.nShow
79846>>>>>>>>>>>
79846>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79847>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79848>>>>>>>>>>>        If (hProcess) Begin
79850>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79851>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79852>>>>>>>>>>>        End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>    End_Procedure
79853>>>>>>>>>>>
79853>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79855>>>>>>>>>>>        String sDirSep
79855>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79856>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79857>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79859>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79860>>>>>>>>>>>        End
79860>>>>>>>>>>>>
79860>>>>>>>>>>>        Function_Return sPath
79861>>>>>>>>>>>    End_Function
79862>>>>>>>>>>>
79862>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79862>>>>>>>>>>>    // or there is a problem with the certificate.
79862>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79862>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79862>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79864>>>>>>>>>>>        Boolean bExists
79864>>>>>>>>>>>        String sPath sProgram sParams sRetval
79864>>>>>>>>>>>        Integer iCh
79864>>>>>>>>>>>
79864>>>>>>>>>>>        Move "" to sRetval
79865>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79866>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79867>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79868>>>>>>>>>>>        If (bExists = False) Begin
79870>>>>>>>>>>>            Function_Return "-1"
79871>>>>>>>>>>>        End
79871>>>>>>>>>>>>
79871>>>>>>>>>>>
79871>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79872>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79873>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79874>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79875>>>>>>>>>>>        Get Seq_New_Channel to iCh
79876>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79878>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79881>>>>>>>>>>>        Close_Output channel iCh
79883>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79883>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79884>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79886>>>>>>>>>>>            Readln channel iCh sRetval
79888>>>>>>>>>>>            Readln channel iCh sRetval
79890>>>>>>>>>>>            Readln channel iCh sRetval
79892>>>>>>>>>>>            Readln channel iCh sRetval
79894>>>>>>>>>>>        Close_Input channel iCh
79896>>>>>>>>>>>        Send Seq_Release_Channel iCh
79897>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79899>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79900>>>>>>>>>>>        End
79900>>>>>>>>>>>>
79900>>>>>>>>>>>        Else Begin
79901>>>>>>>>>>>            Move "" to sRetval
79902>>>>>>>>>>>        End
79902>>>>>>>>>>>>
79902>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79902>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79903>>>>>>>>>>>>
79903>>>>>>>>>>>        Function_Return sRetval
79904>>>>>>>>>>>    End_Function
79905>>>>>>>>>>>
79905>>>>>>>>>>>    Procedure Add_LineLn String sValue
79907>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79908>>>>>>>>>>>    End_Procedure
79909>>>>>>>>>>>
79909>>>>>>>>>>>    Procedure Add_Line String sValue
79911>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79912>>>>>>>>>>>    End_Procedure
79913>>>>>>>>>>>
79913>>>>>>>>>>>    Procedure Set Logo string sLogo
79915>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79915>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79916>>>>>>>>>>>    End_Procedure
79917>>>>>>>>>>>
79917>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79919>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79920>>>>>>>>>>>    End_Procedure
79921>>>>>>>>>>>
79921>>>>>>>>>>>    Procedure Show_Sysinfo
79923>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79924>>>>>>>>>>>    End_Procedure
79925>>>>>>>>>>>
79925>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79927>>>>>>>>>>>        Handle hWnd
79927>>>>>>>>>>>        Get Window_Handle to hWnd
79928>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79929>>>>>>>>>>>    End_Procedure
79930>>>>>>>>>>>
79930>>>>>>>>>>>End_Class
79931>>>>>>>>>
79931>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79933>>>>>>>>>    End_Function
79934>>>>>>>>>
79934>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79935>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79936>>>>>>>>>>
79936>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79938>>>>>>>>>>    Integer iStart iEnd
79938>>>>>>>>>>    String sRetval
79938>>>>>>>>>>
79938>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79939>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79940>>>>>>>>>>    If (iStart = 0) Begin
79942>>>>>>>>>>        Function_Return ""
79943>>>>>>>>>>    End
79943>>>>>>>>>>>
79943>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79944>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79945>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79947>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79948>>>>>>>>>>    End
79948>>>>>>>>>>>
79948>>>>>>>>>>    Else Begin
79949>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79950>>>>>>>>>>    End
79950>>>>>>>>>>>
79950>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79952>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79953>>>>>>>>>>        Decrement iEnd
79954>>>>>>>>>>    End
79954>>>>>>>>>>>
79954>>>>>>>>>>    If (iEnd <> 0) Begin
79956>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79957>>>>>>>>>>    End
79957>>>>>>>>>>>
79957>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79958>>>>>>>>>>
79958>>>>>>>>>>    Function_Return (Trim(sRetval))
79959>>>>>>>>>>End_Function
79960>>>>>>>>>>
79960>>>>>>>>>>
79960>>>>>>>>>    
79960>>>>>>>>>    Procedure Construct_Object
79962>>>>>>>>>        Handle ho
79962>>>>>>>>>        Forward Send Construct_Object
79964>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79965>>>>>>>>>        
79965>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79966>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79967>>>>>>>>>
79967>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79967>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79967>>>>>>>>>        // etc settings.
79967>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79969>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79970>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
79971>>>>>>>>>            Set phoSQLConnectionHandler to ho
79972>>>>>>>>>        End
79972>>>>>>>>>>
79972>>>>>>>>>
79972>>>>>>>>>    End_Procedure
79973>>>>>>>>>
79973>>>>>>>>>    Procedure End_Construct_Object
79975>>>>>>>>>        Forward Send End_Construct_Object
79977>>>>>>>>>
79977>>>>>>>>>    End_Procedure
79978>>>>>>>>>
79978>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79978>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79978>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79978>>>>>>>>>    // Good read about which collation to select:
79978>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79978>>>>>>>>>    Procedure Set psCollation String sCollation
79980>>>>>>>>>        Set private.psCollation to sCollation
79981>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79983>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79984>>>>>>>>>        End
79984>>>>>>>>>>
79984>>>>>>>>>    End_Procedure
79985>>>>>>>>>
79985>>>>>>>>>    Function psCollation Returns String
79987>>>>>>>>>        String sCollation
79987>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79989>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79990>>>>>>>>>        End   
79990>>>>>>>>>>
79990>>>>>>>>>        Else Begin
79991>>>>>>>>>            Get private.psCollation to sCollation
79992>>>>>>>>>        End
79992>>>>>>>>>>
79992>>>>>>>>>        Function_Return sCollation
79993>>>>>>>>>    End_Function
79994>>>>>>>>>
79994>>>>>>>>>    // Array sorting helper functions:
79994>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
79996>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
79998>>>>>>>>>            Function_Return (EQ)
79999>>>>>>>>>        End
79999>>>>>>>>>>
79999>>>>>>>>>
79999>>>>>>>>>        Function_Return (GT)
80000>>>>>>>>>    End_Function
80001>>>>>>>>>
80001>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80003>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80006>>>>>>>>>
80006>>>>>>>>>        Function_Return (GT)
80007>>>>>>>>>    End_Function
80008>>>>>>>>>
80008>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80008>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80008>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80010>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80010>>>>>>>>>        Handle hTable
80010>>>>>>>>>        Boolean bIsSame
80010>>>>>>>>>
80010>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80011>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80012>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80015>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80016>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80019>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80022>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80023>>>>>>>>>
80023>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80025>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80026>>>>>>>>>        End
80026>>>>>>>>>>
80026>>>>>>>>>        Else Begin
80027>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80028>>>>>>>>>        End
80028>>>>>>>>>>
80028>>>>>>>>>
80028>>>>>>>>>        Function_Return bIsSame
80029>>>>>>>>>    End_Function
80030>>>>>>>>>
80030>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80032>>>>>>>>>        Integer iRetval
80032>>>>>>>>>        Move 1 to iRetval
80033>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80035>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80036>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80037>>>>>>>>>        End
80037>>>>>>>>>>
80037>>>>>>>>>        Function_Return (iRetval = 0)
80038>>>>>>>>>    End_Function
80039>>>>>>>>>
80039>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80041>>>>>>>>>        String sDirSep
80041>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80042>>>>>>>>>        Move (Trim(sPath)) to sPath
80043>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80045>>>>>>>>>            Move (sPath + sDirSep) to sPath
80046>>>>>>>>>        End
80046>>>>>>>>>>
80046>>>>>>>>>        Function_Return sPath
80047>>>>>>>>>    End_Function
80048>>>>>>>>>
80048>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80050>>>>>>>>>        Integer i iCols iItem
80050>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80050>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80051>>>>>>>>>
80051>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80052>>>>>>>>>        For i from 1 to iCols
80058>>>>>>>>>>
80058>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80059>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80060>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80061>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80062>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80063>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80064>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80065>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80066>>>>>>>>>        Loop
80067>>>>>>>>>>
80067>>>>>>>>>        Set piColumns to iCols
80068>>>>>>>>>        Set paQueryColumns to aQueryColumns
80069>>>>>>>>>    End_Procedure
80070>>>>>>>>>
80070>>>>>>>>>    // *** Property Messages ***
80070>>>>>>>>>    //
80070>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80070>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80070>>>>>>>>>    //
80070>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80072>>>>>>>>>        tSQLConnection SQLConnection
80072>>>>>>>>>        tSQLConnection SQLConnection
80072>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80074>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80074>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80075>>>>>>>>>>
80075>>>>>>>>>            Function_Return
80076>>>>>>>>>        End
80076>>>>>>>>>>
80076>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80077>>>>>>>>>        Function_Return SQLConnection
80078>>>>>>>>>    End_Function
80079>>>>>>>>>
80079>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80079>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80081>>>>>>>>>        Function_Return False
80082>>>>>>>>>    End_Function
80083>>>>>>>>>
80083>>>>>>>>>    Procedure Set psServer String sValue
80085>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80087>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80087>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80088>>>>>>>>>>
80088>>>>>>>>>            Procedure_Return
80089>>>>>>>>>        End
80089>>>>>>>>>>
80089>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80090>>>>>>>>>    End_Procedure
80091>>>>>>>>>
80091>>>>>>>>>    Function psServer Returns String
80093>>>>>>>>>        String sValue
80093>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80095>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80096>>>>>>>>>>
80096>>>>>>>>>            Function_Return
80097>>>>>>>>>        End
80097>>>>>>>>>>
80097>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80098>>>>>>>>>        Function_Return sValue
80099>>>>>>>>>    End_Function
80100>>>>>>>>>
80100>>>>>>>>>    Procedure Set psDatabase String sValue
80102>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80104>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80105>>>>>>>>>>
80105>>>>>>>>>            Procedure_Return
80106>>>>>>>>>        End
80106>>>>>>>>>>
80106>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80107>>>>>>>>>    End_Procedure
80108>>>>>>>>>
80108>>>>>>>>>    Function psDatabase Returns String
80110>>>>>>>>>        String sValue
80110>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80112>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80113>>>>>>>>>>
80113>>>>>>>>>            Function_Return
80114>>>>>>>>>        End
80114>>>>>>>>>>
80114>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80115>>>>>>>>>        Function_Return sValue
80116>>>>>>>>>    End_Function
80117>>>>>>>>>
80117>>>>>>>>>    Procedure Set psUserID String sValue
80119>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80121>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80122>>>>>>>>>>
80122>>>>>>>>>            Procedure_Return
80123>>>>>>>>>        End
80123>>>>>>>>>>
80123>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80124>>>>>>>>>    End_Procedure
80125>>>>>>>>>
80125>>>>>>>>>    Function psUserID Returns String
80127>>>>>>>>>        String sValue
80127>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80129>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80130>>>>>>>>>>
80130>>>>>>>>>            Function_Return
80131>>>>>>>>>        End
80131>>>>>>>>>>
80131>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80132>>>>>>>>>        Function_Return sValue
80133>>>>>>>>>    End_Function
80134>>>>>>>>>
80134>>>>>>>>>    Procedure Set psPassword String sValue
80136>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80138>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80139>>>>>>>>>>
80139>>>>>>>>>            Procedure_Return
80140>>>>>>>>>        End
80140>>>>>>>>>>
80140>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80141>>>>>>>>>    End_Procedure
80142>>>>>>>>>
80142>>>>>>>>>    Function psPassword Returns String
80144>>>>>>>>>        String sValue
80144>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80146>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80147>>>>>>>>>>
80147>>>>>>>>>            Function_Return
80148>>>>>>>>>        End
80148>>>>>>>>>>
80148>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80149>>>>>>>>>        Function_Return sValue
80150>>>>>>>>>    End_Function
80151>>>>>>>>>
80151>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80153>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80155>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80156>>>>>>>>>>
80156>>>>>>>>>            Procedure_Return
80157>>>>>>>>>        End
80157>>>>>>>>>>
80157>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80158>>>>>>>>>    End_Procedure
80159>>>>>>>>>
80159>>>>>>>>>    Function pbTrusted Returns Boolean
80161>>>>>>>>>        Boolean bValue
80161>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80163>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80164>>>>>>>>>>
80164>>>>>>>>>            Function_Return
80165>>>>>>>>>        End
80165>>>>>>>>>>
80165>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80166>>>>>>>>>        Function_Return bValue
80167>>>>>>>>>    End_Function
80168>>>>>>>>>
80168>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80170>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80172>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80173>>>>>>>>>>
80173>>>>>>>>>            Procedure_Return
80174>>>>>>>>>        End
80174>>>>>>>>>>
80174>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80175>>>>>>>>>    End_Procedure
80176>>>>>>>>>
80176>>>>>>>>>    Function pbSilentLogin Returns Boolean
80178>>>>>>>>>        Boolean bValue
80178>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80180>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80181>>>>>>>>>>
80181>>>>>>>>>            Function_Return
80182>>>>>>>>>        End
80182>>>>>>>>>>
80182>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80183>>>>>>>>>        Function_Return bValue
80184>>>>>>>>>    End_Function
80185>>>>>>>>>
80185>>>>>>>>>    Procedure Set psConnectionID String sValue
80187>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80189>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80190>>>>>>>>>>
80190>>>>>>>>>            Procedure_Return
80191>>>>>>>>>        End
80191>>>>>>>>>>
80191>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80192>>>>>>>>>    End_Procedure
80193>>>>>>>>>
80193>>>>>>>>>    Function psConnectionID Returns String
80195>>>>>>>>>        String sValue
80195>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80197>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80198>>>>>>>>>>
80198>>>>>>>>>            Function_Return
80199>>>>>>>>>        End
80199>>>>>>>>>>
80199>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80200>>>>>>>>>        Function_Return sValue
80201>>>>>>>>>    End_Function
80202>>>>>>>>>
80202>>>>>>>>>    Procedure Set psConnectionString String sValue
80204>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80206>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80207>>>>>>>>>>
80207>>>>>>>>>            Procedure_Return
80208>>>>>>>>>        End
80208>>>>>>>>>>
80208>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80209>>>>>>>>>    End_Procedure
80210>>>>>>>>>
80210>>>>>>>>>    Function psConnectionString Returns String
80212>>>>>>>>>        String sValue
80212>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80214>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80215>>>>>>>>>>
80215>>>>>>>>>            Function_Return
80216>>>>>>>>>        End
80216>>>>>>>>>>
80216>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80217>>>>>>>>>        Function_Return sValue
80218>>>>>>>>>    End_Function
80219>>>>>>>>>
80219>>>>>>>>>    // The normal connection string looks something like this;
80219>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80219>>>>>>>>>    // ...and the full connection string looks like this;
80219>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80219>>>>>>>>>    Function psFullConnectionString Returns String
80221>>>>>>>>>        String sConnectionID sConnectionString
80221>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80223>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80224>>>>>>>>>>
80224>>>>>>>>>            Function_Return
80225>>>>>>>>>        End
80225>>>>>>>>>>
80225>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80226>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80227>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80228>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80229>>>>>>>>>    End_Function
80230>>>>>>>>>
80230>>>>>>>>>    Function piConnectionOptions Returns Integer
80232>>>>>>>>>        Integer iValue
80232>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80234>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80235>>>>>>>>>>
80235>>>>>>>>>            Function_Return
80236>>>>>>>>>        End
80236>>>>>>>>>>
80236>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80237>>>>>>>>>        Function_Return iValue
80238>>>>>>>>>    End_Function
80239>>>>>>>>>
80239>>>>>>>>>    Procedure Set psSchema String sValue
80241>>>>>>>>>        tSQLConnection SQLConnection
80241>>>>>>>>>        tSQLConnection SQLConnection
80241>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80243>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80244>>>>>>>>>>
80244>>>>>>>>>            Procedure_Return
80245>>>>>>>>>        End
80245>>>>>>>>>>
80245>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80246>>>>>>>>>    End_Procedure
80247>>>>>>>>>
80247>>>>>>>>>    Function psSchema Returns String
80249>>>>>>>>>        String sRetval
80249>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80251>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80252>>>>>>>>>>
80252>>>>>>>>>            Function_Return
80253>>>>>>>>>        End
80253>>>>>>>>>>
80253>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80254>>>>>>>>>        Function_Return sRetval
80255>>>>>>>>>    End_Function
80256>>>>>>>>>
80256>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80258>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80260>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80261>>>>>>>>>>
80261>>>>>>>>>            Procedure_Return
80262>>>>>>>>>        End
80262>>>>>>>>>>
80262>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80263>>>>>>>>>    End_Procedure
80264>>>>>>>>>
80264>>>>>>>>>    Function psBaseTableSpace Returns String
80266>>>>>>>>>        String sRetval
80266>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80268>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80269>>>>>>>>>>
80269>>>>>>>>>            Function_Return
80270>>>>>>>>>        End
80270>>>>>>>>>>
80270>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80271>>>>>>>>>        Function_Return sRetval
80272>>>>>>>>>    End_Function
80273>>>>>>>>>
80273>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80275>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80277>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80278>>>>>>>>>>
80278>>>>>>>>>            Procedure_Return
80279>>>>>>>>>        End
80279>>>>>>>>>>
80279>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80280>>>>>>>>>    End_Procedure
80281>>>>>>>>>
80281>>>>>>>>>    Function psLongTableSpace Returns String
80283>>>>>>>>>        String sRetval
80283>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80285>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80286>>>>>>>>>>
80286>>>>>>>>>            Function_Return
80287>>>>>>>>>        End
80287>>>>>>>>>>
80287>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80288>>>>>>>>>        Function_Return sRetval
80289>>>>>>>>>    End_Function
80290>>>>>>>>>
80290>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80292>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80294>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80295>>>>>>>>>>
80295>>>>>>>>>            Procedure_Return
80296>>>>>>>>>        End
80296>>>>>>>>>>
80296>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80297>>>>>>>>>    End_Procedure
80298>>>>>>>>>
80298>>>>>>>>>    Function psIndexTableSpace Returns String
80300>>>>>>>>>        String sRetval
80300>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80302>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80303>>>>>>>>>>
80303>>>>>>>>>            Function_Return
80304>>>>>>>>>        End
80304>>>>>>>>>>
80304>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80305>>>>>>>>>        Function_Return sRetval
80306>>>>>>>>>    End_Function
80307>>>>>>>>>
80307>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80309>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80311>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80312>>>>>>>>>>
80312>>>>>>>>>            Procedure_Return
80313>>>>>>>>>        End
80313>>>>>>>>>>
80313>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80314>>>>>>>>>    End_Procedure
80315>>>>>>>>>
80315>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80317>>>>>>>>>        Boolean bState
80317>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80319>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80320>>>>>>>>>>
80320>>>>>>>>>            Function_Return
80321>>>>>>>>>        End
80321>>>>>>>>>>
80321>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80322>>>>>>>>>        Function_Return bState
80323>>>>>>>>>    End_Function
80324>>>>>>>>>
80324>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80326>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80328>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80329>>>>>>>>>>
80329>>>>>>>>>            Procedure_Return
80330>>>>>>>>>        End
80330>>>>>>>>>>
80330>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80331>>>>>>>>>    End_Procedure
80332>>>>>>>>>
80332>>>>>>>>>    Function pbToANSI Returns Boolean
80334>>>>>>>>>        Boolean bState
80334>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80336>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80337>>>>>>>>>>
80337>>>>>>>>>            Function_Return
80338>>>>>>>>>        End
80338>>>>>>>>>>
80338>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80339>>>>>>>>>        Function_Return bState
80340>>>>>>>>>    End_Function
80341>>>>>>>>>
80341>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80343>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80345>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80346>>>>>>>>>>
80346>>>>>>>>>            Procedure_Return
80347>>>>>>>>>        End
80347>>>>>>>>>>
80347>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80348>>>>>>>>>    End_Procedure
80349>>>>>>>>>
80349>>>>>>>>>    Function pbRecnum Returns Boolean
80351>>>>>>>>>        Boolean bState
80351>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80353>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80354>>>>>>>>>>
80354>>>>>>>>>            Function_Return
80355>>>>>>>>>        End
80355>>>>>>>>>>
80355>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80356>>>>>>>>>        Function_Return bState
80357>>>>>>>>>    End_Function
80358>>>>>>>>>
80358>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80360>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80362>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80363>>>>>>>>>>
80363>>>>>>>>>            Procedure_Return
80364>>>>>>>>>        End
80364>>>>>>>>>>
80364>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80365>>>>>>>>>    End_Procedure
80366>>>>>>>>>
80366>>>>>>>>>    Function pbCopyData Returns Boolean
80368>>>>>>>>>        Boolean bState
80368>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80370>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80371>>>>>>>>>>
80371>>>>>>>>>            Function_Return
80372>>>>>>>>>        End
80372>>>>>>>>>>
80372>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80373>>>>>>>>>        Function_Return bState
80374>>>>>>>>>    End_Function
80375>>>>>>>>>
80375>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80377>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80379>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80380>>>>>>>>>>
80380>>>>>>>>>            Procedure_Return
80381>>>>>>>>>        End
80381>>>>>>>>>>
80381>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80382>>>>>>>>>    End_Procedure
80383>>>>>>>>>
80383>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80385>>>>>>>>>        Boolean bState
80385>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80387>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80388>>>>>>>>>>
80388>>>>>>>>>            Function_Return
80389>>>>>>>>>        End
80389>>>>>>>>>>
80389>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80390>>>>>>>>>        Function_Return bState
80391>>>>>>>>>    End_Function
80392>>>>>>>>>
80392>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80394>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80396>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80397>>>>>>>>>>
80397>>>>>>>>>            Procedure_Return
80398>>>>>>>>>        End
80398>>>>>>>>>>
80398>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80399>>>>>>>>>    End_Procedure
80400>>>>>>>>>
80400>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80402>>>>>>>>>        Boolean bState
80402>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80404>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80405>>>>>>>>>>
80405>>>>>>>>>            Function_Return
80406>>>>>>>>>        End
80406>>>>>>>>>>
80406>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80407>>>>>>>>>        Function_Return bState
80408>>>>>>>>>    End_Function
80409>>>>>>>>>
80409>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80411>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80413>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80414>>>>>>>>>>
80414>>>>>>>>>            Procedure_Return
80415>>>>>>>>>        End
80415>>>>>>>>>>
80415>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80416>>>>>>>>>    End_Procedure
80417>>>>>>>>>
80417>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80419>>>>>>>>>        Boolean bState
80419>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80421>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80422>>>>>>>>>>
80422>>>>>>>>>            Function_Return
80423>>>>>>>>>        End
80423>>>>>>>>>>
80423>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80424>>>>>>>>>        Function_Return bState
80425>>>>>>>>>    End_Function
80426>>>>>>>>>
80426>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80428>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80430>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80431>>>>>>>>>>
80431>>>>>>>>>            Procedure_Return
80432>>>>>>>>>        End
80432>>>>>>>>>>
80432>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80433>>>>>>>>>    End_Procedure
80434>>>>>>>>>
80434>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80436>>>>>>>>>        Boolean bState
80436>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80438>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80439>>>>>>>>>>
80439>>>>>>>>>            Function_Return
80440>>>>>>>>>        End
80440>>>>>>>>>>
80440>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80441>>>>>>>>>        Function_Return bState
80442>>>>>>>>>    End_Function
80443>>>>>>>>>
80443>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80445>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80447>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80448>>>>>>>>>>
80448>>>>>>>>>            Procedure_Return
80449>>>>>>>>>        End
80449>>>>>>>>>>
80449>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80450>>>>>>>>>    End_Procedure
80451>>>>>>>>>
80451>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80453>>>>>>>>>        String sRetval
80453>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80455>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80456>>>>>>>>>>
80456>>>>>>>>>            Function_Return
80457>>>>>>>>>        End
80457>>>>>>>>>>
80457>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80458>>>>>>>>>        Function_Return sRetval
80459>>>>>>>>>    End_Function
80460>>>>>>>>>
80460>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80462>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80464>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80465>>>>>>>>>>
80465>>>>>>>>>            Procedure_Return
80466>>>>>>>>>        End
80466>>>>>>>>>>
80466>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80467>>>>>>>>>    End_Procedure
80468>>>>>>>>>
80468>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80470>>>>>>>>>        String sRetval
80470>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80472>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80473>>>>>>>>>>
80473>>>>>>>>>            Function_Return
80474>>>>>>>>>        End
80474>>>>>>>>>>
80474>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80475>>>>>>>>>        Function_Return sRetval
80476>>>>>>>>>    End_Function
80477>>>>>>>>>
80477>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80479>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80481>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80482>>>>>>>>>>
80482>>>>>>>>>            Procedure_Return
80483>>>>>>>>>        End
80483>>>>>>>>>>
80483>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80484>>>>>>>>>    End_Procedure
80485>>>>>>>>>
80485>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80487>>>>>>>>>        String sRetval
80487>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80489>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80490>>>>>>>>>>
80490>>>>>>>>>            Function_Return
80491>>>>>>>>>        End
80491>>>>>>>>>>
80491>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80492>>>>>>>>>        Function_Return sRetval
80493>>>>>>>>>    End_Function
80494>>>>>>>>>
80494>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80496>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80498>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80499>>>>>>>>>>
80499>>>>>>>>>            Procedure_Return
80500>>>>>>>>>        End
80500>>>>>>>>>>
80500>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80501>>>>>>>>>    End_Procedure
80502>>>>>>>>>
80502>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80504>>>>>>>>>        String sRetval
80504>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80506>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80507>>>>>>>>>>
80507>>>>>>>>>            Function_Return
80508>>>>>>>>>        End
80508>>>>>>>>>>
80508>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80509>>>>>>>>>        Function_Return sRetval
80510>>>>>>>>>    End_Function
80511>>>>>>>>>
80511>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80513>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80515>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80516>>>>>>>>>>
80516>>>>>>>>>            Procedure_Return
80517>>>>>>>>>        End
80517>>>>>>>>>>
80517>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80518>>>>>>>>>    End_Procedure
80519>>>>>>>>>
80519>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80521>>>>>>>>>        String sRetval
80521>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80523>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80524>>>>>>>>>>
80524>>>>>>>>>            Function_Return
80525>>>>>>>>>        End
80525>>>>>>>>>>
80525>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80526>>>>>>>>>        Function_Return sRetval
80527>>>>>>>>>    End_Function
80528>>>>>>>>>
80528>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80530>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80532>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80533>>>>>>>>>>
80533>>>>>>>>>            Procedure_Return
80534>>>>>>>>>        End
80534>>>>>>>>>>
80534>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80535>>>>>>>>>    End_Procedure
80536>>>>>>>>>
80536>>>>>>>>>    Function psDriverDefaultValueText Returns String
80538>>>>>>>>>        String sRetval
80538>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80540>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80541>>>>>>>>>>
80541>>>>>>>>>            Function_Return
80542>>>>>>>>>        End
80542>>>>>>>>>>
80542>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80543>>>>>>>>>        Function_Return sRetval
80544>>>>>>>>>    End_Function
80545>>>>>>>>>
80545>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80547>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80549>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80550>>>>>>>>>>
80550>>>>>>>>>            Procedure_Return
80551>>>>>>>>>        End
80551>>>>>>>>>>
80551>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80552>>>>>>>>>    End_Procedure
80553>>>>>>>>>
80553>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80555>>>>>>>>>        Boolean bState
80555>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80557>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80558>>>>>>>>>>
80558>>>>>>>>>            Function_Return
80559>>>>>>>>>        End
80559>>>>>>>>>>
80559>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80560>>>>>>>>>        Function_Return bState
80561>>>>>>>>>    End_Function
80562>>>>>>>>>
80562>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80564>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80566>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80567>>>>>>>>>>
80567>>>>>>>>>            Procedure_Return
80568>>>>>>>>>        End
80568>>>>>>>>>>
80568>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80569>>>>>>>>>    End_Procedure
80570>>>>>>>>>
80570>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80572>>>>>>>>>        Boolean bState
80572>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80574>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80575>>>>>>>>>>
80575>>>>>>>>>            Function_Return
80576>>>>>>>>>        End
80576>>>>>>>>>>
80576>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80577>>>>>>>>>        Function_Return bState
80578>>>>>>>>>    End_Function
80579>>>>>>>>>
80579>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80581>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80583>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80584>>>>>>>>>>
80584>>>>>>>>>            Procedure_Return
80585>>>>>>>>>        End
80585>>>>>>>>>>
80585>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80586>>>>>>>>>    End_Procedure
80587>>>>>>>>>
80587>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80589>>>>>>>>>        Boolean bState
80589>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80591>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80592>>>>>>>>>>
80592>>>>>>>>>            Function_Return
80593>>>>>>>>>        End
80593>>>>>>>>>>
80593>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80594>>>>>>>>>        Function_Return bState
80595>>>>>>>>>    End_Function
80596>>>>>>>>>
80596>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80598>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80600>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80601>>>>>>>>>>
80601>>>>>>>>>            Procedure_Return
80602>>>>>>>>>        End
80602>>>>>>>>>>
80602>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80603>>>>>>>>>    End_Procedure
80604>>>>>>>>>
80604>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80606>>>>>>>>>        Boolean bState
80606>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80608>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80609>>>>>>>>>>
80609>>>>>>>>>            Function_Return
80610>>>>>>>>>        End
80610>>>>>>>>>>
80610>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80611>>>>>>>>>        Function_Return bState
80612>>>>>>>>>    End_Function
80613>>>>>>>>>
80613>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80615>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80617>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80618>>>>>>>>>>
80618>>>>>>>>>            Procedure_Return
80619>>>>>>>>>        End
80619>>>>>>>>>>
80619>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80620>>>>>>>>>    End_Procedure
80621>>>>>>>>>
80621>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80623>>>>>>>>>        Boolean bState
80623>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80625>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80626>>>>>>>>>>
80626>>>>>>>>>            Function_Return
80627>>>>>>>>>        End
80627>>>>>>>>>>
80627>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80628>>>>>>>>>        Function_Return bState
80629>>>>>>>>>    End_Function
80630>>>>>>>>>
80630>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80632>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80634>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80635>>>>>>>>>>
80635>>>>>>>>>            Procedure_Return
80636>>>>>>>>>        End
80636>>>>>>>>>>
80636>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80637>>>>>>>>>    End_Procedure
80638>>>>>>>>>
80638>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80640>>>>>>>>>        Boolean bState
80640>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80642>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80643>>>>>>>>>>
80643>>>>>>>>>            Function_Return
80644>>>>>>>>>        End
80644>>>>>>>>>>
80644>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80645>>>>>>>>>        Function_Return bState
80646>>>>>>>>>    End_Function
80647>>>>>>>>>
80647>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80647>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80647>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80647>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80647>>>>>>>>>    Procedure Set psDriverID String sValue
80649>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80650>>>>>>>>>        Delegate Set psDriverID to sValue
80652>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80653>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80654>>>>>>>>>    End_Procedure
80655>>>>>>>>>
80655>>>>>>>>>    Function psDriverID Returns String
80657>>>>>>>>>        String sDriverID
80657>>>>>>>>>
80657>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80658>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80658>>>>>>>>>        Delegate Get psDriverID to sDriverID
80660>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80661>>>>>>>>>        Move False to Err
80662>>>>>>>>>
80662>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80662>>>>>>>>>        // probably used as "utilites" from a special made program and
80662>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80662>>>>>>>>>        If (sDriverID = "") Begin
80664>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80665>>>>>>>>>        End
80665>>>>>>>>>>
80665>>>>>>>>>        Function_Return sDriverID
80666>>>>>>>>>    End_Function
80667>>>>>>>>>
80667>>>>>>>>>    Procedure Set piDbType Integer iValue
80669>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80670>>>>>>>>>        Delegate Set piDbType to iValue
80672>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80673>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80674>>>>>>>>>    End_Procedure
80675>>>>>>>>>
80675>>>>>>>>>    Function piDbType Returns Integer
80677>>>>>>>>>        Integer iRetval
80677>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80678>>>>>>>>>        Function_Return iRetval
80679>>>>>>>>>    End_Function
80680>>>>>>>>>
80680>>>>>>>>>    // Returns the index for the passed sTableName
80680>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80680>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80682>>>>>>>>>        Integer iIndex iSize iCount
80682>>>>>>>>>        String[] sTablesArray
80683>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80683>>>>>>>>>
80683>>>>>>>>>        Move -1 to iIndex
80684>>>>>>>>>        Get psConnectionString to sConnectionString
80685>>>>>>>>>        Get psDatabase to sDatabase
80686>>>>>>>>>        Get psSchema   to sSchema
80687>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80688>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80689>>>>>>>>>        Decrement iSize
80690>>>>>>>>>        For iCount from 0 to iSize
80696>>>>>>>>>>
80696>>>>>>>>>            Move sTablesArray[iCount] to sVal
80697>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80699>>>>>>>>>                Move iCount to iIndex // We found it!
80700>>>>>>>>>                Move iSize to iCount  // End the loop
80701>>>>>>>>>            End
80701>>>>>>>>>>
80701>>>>>>>>>        Loop
80702>>>>>>>>>>
80702>>>>>>>>>
80702>>>>>>>>>        Function_Return iIndex
80703>>>>>>>>>    End_Function
80704>>>>>>>>>
80704>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80704>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80706>>>>>>>>>        String[] sReturnArray
80707>>>>>>>>>        Boolean bOK
80707>>>>>>>>>
80707>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80708>>>>>>>>>        If (bOK = False) Begin
80710>>>>>>>>>            Function_Return sReturnArray
80711>>>>>>>>>        End
80711>>>>>>>>>>
80711>>>>>>>>>
80711>>>>>>>>>        Case Begin
80711>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80713>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80714>>>>>>>>>                Case Break
80715>>>>>>>>>
80715>>>>>>>>>            Case Else
80715>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80716>>>>>>>>>>
80716>>>>>>>>>                Case Break
80717>>>>>>>>>        Case End
80717>>>>>>>>>
80717>>>>>>>>>        Function_Return sReturnArray
80718>>>>>>>>>    End_Function
80719>>>>>>>>>
80719>>>>>>>>>    // Returns a string array with all tables for the current database.
80719>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80721>>>>>>>>>        String[] sReturnArray sArray
80723>>>>>>>>>        String sConnectionString sSelect
80723>>>>>>>>>        Integer iSize iCount iDbType
80723>>>>>>>>>        Boolean bOK
80723>>>>>>>>>
80723>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80725>>>>>>>>>            Function_Return sArray
80726>>>>>>>>>        End
80726>>>>>>>>>>
80726>>>>>>>>>
80726>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80727>>>>>>>>>        If (bOK = False) Begin
80729>>>>>>>>>            Function_Return sReturnArray
80730>>>>>>>>>        End
80730>>>>>>>>>>
80730>>>>>>>>>        If (sSchema = "") Begin
80732>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80733>>>>>>>>>        End
80733>>>>>>>>>>
80733>>>>>>>>>
80733>>>>>>>>>        Get psConnectionString to sConnectionString
80734>>>>>>>>>
80734>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80734>>>>>>>>>        // the dbType.
80734>>>>>>>>>        Get piDbType to iDbType
80735>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80737>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80739>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80740>>>>>>>>>            End
80740>>>>>>>>>>
80740>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80742>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80743>>>>>>>>>            End
80743>>>>>>>>>>
80743>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80745>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80746>>>>>>>>>            End
80746>>>>>>>>>>
80746>>>>>>>>>        End
80746>>>>>>>>>>
80746>>>>>>>>>
80746>>>>>>>>>        Case Begin
80746>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80748>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80749>>>>>>>>>                Case Break
80750>>>>>>>>>
80750>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80753>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80754>>>>>>>>>                Case Break
80755>>>>>>>>>
80755>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80758>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80759>>>>>>>>>                Case Break
80760>>>>>>>>>
80760>>>>>>>>>            Case Else
80760>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80761>>>>>>>>>>
80761>>>>>>>>>                Case Break
80762>>>>>>>>>        Case End
80762>>>>>>>>>
80762>>>>>>>>>        Function_Return sReturnArray
80763>>>>>>>>>    End_Function
80764>>>>>>>>>
80764>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80764>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80766>>>>>>>>>        String[] sReturnArray
80767>>>>>>>>>        Boolean bOK
80767>>>>>>>>>
80767>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80768>>>>>>>>>        If (bOK = False) Begin
80770>>>>>>>>>            Function_Return sReturnArray
80771>>>>>>>>>        End
80771>>>>>>>>>>
80771>>>>>>>>>
80771>>>>>>>>>        Case Begin
80771>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80773>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80774>>>>>>>>>                Case Break
80775>>>>>>>>>
80775>>>>>>>>>            Case Else
80775>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80776>>>>>>>>>>
80776>>>>>>>>>                Case Break
80777>>>>>>>>>        Case End
80777>>>>>>>>>
80777>>>>>>>>>        Function_Return sReturnArray
80778>>>>>>>>>    End_Function
80779>>>>>>>>>
80779>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80779>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80781>>>>>>>>>        String[] sReturnArray
80782>>>>>>>>>        String sConnectionString sSelect sSchema
80782>>>>>>>>>        Boolean bOK
80782>>>>>>>>>        Integer iDbType
80782>>>>>>>>>
80782>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80783>>>>>>>>>        If (bOK = False) Begin
80785>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80786>>>>>>>>>>
80786>>>>>>>>>            Function_Return sReturnArray
80787>>>>>>>>>        End
80787>>>>>>>>>>
80787>>>>>>>>>
80787>>>>>>>>>        Get psConnectionString to sConnectionString
80788>>>>>>>>>        Get psSchema to sSchema
80789>>>>>>>>>
80789>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80789>>>>>>>>>        // the dbType.
80789>>>>>>>>>        Get piDbType to iDbType
80790>>>>>>>>>
80790>>>>>>>>>        Case Begin
80790>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80792>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80794>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80795>>>>>>>>>                End
80795>>>>>>>>>>
80795>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80797>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80798>>>>>>>>>                End
80798>>>>>>>>>>
80798>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80800>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80801>>>>>>>>>                End
80801>>>>>>>>>>
80801>>>>>>>>>
80801>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80802>>>>>>>>>                Case Break
80803>>>>>>>>>
80803>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80806>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80807>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80808>>>>>>>>>                Case Break
80809>>>>>>>>>
80809>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80812>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80813>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80814>>>>>>>>>                Case Break
80815>>>>>>>>>
80815>>>>>>>>>            Case Else
80815>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80816>>>>>>>>>>
80816>>>>>>>>>                Case Break
80817>>>>>>>>>        Case End
80817>>>>>>>>>
80817>>>>>>>>>        Function_Return sReturnArray
80818>>>>>>>>>    End_Function
80819>>>>>>>>>
80819>>>>>>>>>
80819>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80819>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80821>>>>>>>>>        String[] sReturnArray sReturnArray2
80823>>>>>>>>>        String sConnectionString sSelect sSchema
80823>>>>>>>>>        Boolean bOK
80823>>>>>>>>>        Integer iCount iSize
80823>>>>>>>>>
80823>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80824>>>>>>>>>        If (bOK = False) Begin
80826>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80827>>>>>>>>>>
80827>>>>>>>>>            Function_Return sReturnArray
80828>>>>>>>>>        End
80828>>>>>>>>>>
80828>>>>>>>>>
80828>>>>>>>>>        Get psConnectionString to sConnectionString
80829>>>>>>>>>        Get psSchema to sSchema
80830>>>>>>>>>
80830>>>>>>>>>        Case Begin
80830>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80832>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80833>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80834>>>>>>>>>                Case Break
80835>>>>>>>>>
80835>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80838>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80839>>>>>>>>>>
80839>>>>>>>>>//                Move () to sSelect
80839>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80839>>>>>>>>>                Case Break
80840>>>>>>>>>
80840>>>>>>>>>            Case Else
80840>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80841>>>>>>>>>>
80841>>>>>>>>>                Case Break
80842>>>>>>>>>        Case End
80842>>>>>>>>>
80842>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80843>>>>>>>>>        Decrement iSize
80844>>>>>>>>>        For iCount from 0 to iSize
80850>>>>>>>>>>
80850>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80852>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80853>>>>>>>>>            End
80853>>>>>>>>>>
80853>>>>>>>>>        Loop
80854>>>>>>>>>>
80854>>>>>>>>>
80854>>>>>>>>>        Function_Return sReturnArray2
80855>>>>>>>>>    End_Function
80856>>>>>>>>>
80856>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80856>>>>>>>>>    // The format of the array is "TableName.FieldName"
80856>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80858>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80860>>>>>>>>>        tSQLRelation[] sRelationsArray
80860>>>>>>>>>        tSQLRelation[] sRelationsArray
80861>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80861>>>>>>>>>        Boolean bOK
80861>>>>>>>>>        Integer iCount iSize iLength
80861>>>>>>>>>
80861>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80862>>>>>>>>>        If (bOK = False) Begin
80864>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80865>>>>>>>>>>
80865>>>>>>>>>            Function_Return sRelationsArray
80866>>>>>>>>>        End
80866>>>>>>>>>>
80866>>>>>>>>>
80866>>>>>>>>>        Get psConnectionString to sConnectionString
80867>>>>>>>>>        Get psSchema to sSchema
80868>>>>>>>>>
80868>>>>>>>>>        Case Begin
80868>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80870>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80871>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80872>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80873>>>>>>>>>                Case Break
80874>>>>>>>>>
80874>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80877>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80878>>>>>>>>>>
80878>>>>>>>>>//                Move () to sSelect
80878>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80878>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80878>>>>>>>>>                Case Break
80879>>>>>>>>>
80879>>>>>>>>>            Case Else
80879>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80880>>>>>>>>>>
80880>>>>>>>>>                Case Break
80881>>>>>>>>>        Case End
80881>>>>>>>>>
80881>>>>>>>>>        Move (Length(sTableName)) to iLength
80882>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80883>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80884>>>>>>>>>        Decrement iSize
80885>>>>>>>>>        For iCount from 0 to iSize
80891>>>>>>>>>>
80891>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80893>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80894>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80895>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80896>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80897>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80898>>>>>>>>>            End
80898>>>>>>>>>>
80898>>>>>>>>>        Loop
80899>>>>>>>>>>
80899>>>>>>>>>
80899>>>>>>>>>        Function_Return sRelationsArray
80900>>>>>>>>>    End_Function
80901>>>>>>>>>
80901>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80903>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80903>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80904>>>>>>>>>        String[] sUsers sPrograms
80906>>>>>>>>>        String sSelect
80906>>>>>>>>>        Integer iSize iCount
80906>>>>>>>>>
80906>>>>>>>>>        Case Begin
80906>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80908>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80909>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80910>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80911>>>>>>>>>                Case Break
80912>>>>>>>>>            Case Else
80912>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80913>>>>>>>>>>
80913>>>>>>>>>        Case End
80913>>>>>>>>>
80913>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80914>>>>>>>>>        Decrement iSize
80915>>>>>>>>>        For iCount from 0 to iSize
80921>>>>>>>>>>
80921>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80922>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80923>>>>>>>>>        Loop
80924>>>>>>>>>>
80924>>>>>>>>>
80924>>>>>>>>>        Function_Return SQLLoggedInUser
80925>>>>>>>>>    End_Function
80926>>>>>>>>>
80926>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80926>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80926>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80928>>>>>>>>>        String[] sFilesData
80929>>>>>>>>>        Boolean bExists
80929>>>>>>>>>        Integer iCh
80929>>>>>>>>>        String sFileName sExt
80929>>>>>>>>>
80929>>>>>>>>>        Get vFolderExists sDataPath to bExists
80930>>>>>>>>>        If (bExists = True) Begin
80932>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80933>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80934>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80935>>>>>>>>>            Direct_Input channel iCh sDataPath
80937>>>>>>>>>                Repeat
80937>>>>>>>>>>
80937>>>>>>>>>                    Readln channel iCh sFileName
80939>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80940>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80942>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80944>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80945>>>>>>>>>                        End
80945>>>>>>>>>>
80945>>>>>>>>>                    End
80945>>>>>>>>>>
80945>>>>>>>>>                Until (SeqEof = True)
80947>>>>>>>>>            Close_Input channel iCh
80949>>>>>>>>>            Send Seq_Release_Channel iCh
80950>>>>>>>>>        End
80950>>>>>>>>>>
80950>>>>>>>>>        Function_Return sFilesData
80951>>>>>>>>>    End_Function
80952>>>>>>>>>
80952>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80952>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80954>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80954>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80954>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80954>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80954>>>>>>>>>        tSQLConnection SQLConnection
80954>>>>>>>>>        tSQLConnection SQLConnection
80954>>>>>>>>>        String[] asCollations
80955>>>>>>>>>        
80955>>>>>>>>>        If (sDriverID = "") Begin
80957>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80958>>>>>>>>>>
80958>>>>>>>>>            Function_Return asCollations
80959>>>>>>>>>        End
80959>>>>>>>>>>
80959>>>>>>>>>
80959>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80959>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80961>>>>>>>>>            Function_Return asCollations
80962>>>>>>>>>        End                 
80962>>>>>>>>>>
80962>>>>>>>>>
80962>>>>>>>>>        Get phoSQLManager to hoSQLManager
80963>>>>>>>>>        Get psConnectionID     to sConnectionID
80964>>>>>>>>>        Get psConnectionString to sConnectionString
80965>>>>>>>>>        Move 0 to LastErr
80966>>>>>>>>>
80966>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80967>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80968>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80969>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80971>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80972>>>>>>>>>>
80972>>>>>>>>>            Function_Return asCollations
80973>>>>>>>>>        End
80973>>>>>>>>>>
80973>>>>>>>>>
80973>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80974>>>>>>>>>
80974>>>>>>>>>        If (hStmt = 0) Begin
80976>>>>>>>>>            Send SqlDisconnect of hoSQLManager
80977>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80978>>>>>>>>>>
80978>>>>>>>>>            Function_Return asCollations
80979>>>>>>>>>        End
80979>>>>>>>>>>
80979>>>>>>>>>
80979>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80980>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80981>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80982>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80983>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80984>>>>>>>>>
80984>>>>>>>>>        // MS-SQL Syntax:  
80984>>>>>>>>>        // SELECT name, description
80984>>>>>>>>>        //   from sys.fn_helpcollations();
80984>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80985>>>>>>>>>
80985>>>>>>>>>        Move 1 to iColumn
80986>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
80987>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80988>>>>>>>>>        Repeat
80988>>>>>>>>>>
80988>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
80989>>>>>>>>>            If (iFetchResult <> 0) Begin
80991>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80992>>>>>>>>>                If (sValue <> sPrevious) Begin         
80994>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
80994>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
80994>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80995>>>>>>>>>                    If (iPos <> 1) Begin
80997>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
80998>>>>>>>>>                    End
80998>>>>>>>>>>
80998>>>>>>>>>                End
80998>>>>>>>>>>
80998>>>>>>>>>                Move sValue to sPrevious
80999>>>>>>>>>            End
80999>>>>>>>>>>
80999>>>>>>>>>        Until (iFetchResult = 0)
81001>>>>>>>>>        Send SQLClose of hStmt
81002>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81003>>>>>>>>>
81003>>>>>>>>>        Function_Return asCollations
81004>>>>>>>>>    End_Function
81005>>>>>>>>>
81005>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81005>>>>>>>>>    // for DAW drivers.
81005>>>>>>>>>    // Returns: A string array.
81005>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81007>>>>>>>>>        String[] sReturnArray
81008>>>>>>>>>        String sValue sPrevious
81008>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81008>>>>>>>>>        Integer iFetchResult iRows
81008>>>>>>>>>        tSQLConnection SQLConnection
81008>>>>>>>>>        tSQLConnection SQLConnection
81008>>>>>>>>>
81008>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81009>>>>>>>>>
81009>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81011>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81012>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81013>>>>>>>>>
81013>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81015>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81016>>>>>>>>>                If (hstmt <> 0) Begin
81018>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81019>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81020>>>>>>>>>                    Repeat
81020>>>>>>>>>>
81020>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81021>>>>>>>>>                        If (iFetchResult <> 0) Begin
81023>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81024>>>>>>>>>                            If (sValue <> sPrevious) Begin
81026>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81027>>>>>>>>>                            End
81027>>>>>>>>>>
81027>>>>>>>>>                            Move sValue to sPrevious
81028>>>>>>>>>                        End
81028>>>>>>>>>>
81028>>>>>>>>>                    Until (iFetchResult = 0)
81030>>>>>>>>>                    Send SQLClose of hstmt
81031>>>>>>>>>                End
81031>>>>>>>>>>
81031>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81032>>>>>>>>>            End
81032>>>>>>>>>>
81032>>>>>>>>>        End
81032>>>>>>>>>>
81032>>>>>>>>>
81032>>>>>>>>>        Function_Return sReturnArray
81033>>>>>>>>>    End_Function
81034>>>>>>>>>
81034>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81036>>>>>>>>>        String[] sReturnArray
81037>>>>>>>>>        String sDataSource
81037>>>>>>>>>        Handle hoSQLHandler
81037>>>>>>>>>        Integer iItem
81037>>>>>>>>>
81037>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81038>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81039>>>>>>>>>
81039>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81040>>>>>>>>>
81040>>>>>>>>>        Repeat
81040>>>>>>>>>>
81040>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81041>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81042>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81043>>>>>>>>>            Increment iItem
81044>>>>>>>>>        Until (sDataSource = "")
81046>>>>>>>>>
81046>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81047>>>>>>>>>
81047>>>>>>>>>        Function_Return sReturnArray
81048>>>>>>>>>    End_Function
81049>>>>>>>>>
81049>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81051>>>>>>>>>        String[] sReturnArray
81052>>>>>>>>>        String sDataSource
81052>>>>>>>>>        Handle hoSQLHandler
81052>>>>>>>>>        Integer iItem
81052>>>>>>>>>
81052>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81053>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81054>>>>>>>>>
81054>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81055>>>>>>>>>
81055>>>>>>>>>        Repeat
81055>>>>>>>>>>
81055>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81056>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81058>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81059>>>>>>>>>                Increment iItem
81060>>>>>>>>>            End
81060>>>>>>>>>>
81060>>>>>>>>>        Until (sDataSource = "")
81062>>>>>>>>>
81062>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81063>>>>>>>>>
81063>>>>>>>>>        Function_Return sReturnArray
81064>>>>>>>>>    End_Function
81065>>>>>>>>>
81065>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81067>>>>>>>>>        String[] sDataSources
81068>>>>>>>>>        tSQLConnection SQLConnection
81068>>>>>>>>>        tSQLConnection SQLConnection
81068>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81068>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81069>>>>>>>>>        Integer iDataSources iCount iItem
81069>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81069>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81069>>>>>>>>>        Boolean bExists bKeyOpened
81069>>>>>>>>>
81069>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81070>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81071>>>>>>>>>        Move SQLConnection.sServer           to sServer
81072>>>>>>>>>
81072>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81072>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81074>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81075>>>>>>>>>            Set psFileName of hoIniFile to sServer
81076>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81077>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81078>>>>>>>>>            Send Destroy of hoIniFile
81079>>>>>>>>>        End
81079>>>>>>>>>>
81079>>>>>>>>>
81079>>>>>>>>>        // DSN - read DATABASE name from the registry
81079>>>>>>>>>        Else Begin
81080>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81081>>>>>>>>>
81081>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81081>>>>>>>>>            // most probably place the info is kept that we're after.
81081>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81082>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81083>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81084>>>>>>>>>            If (bExists = True) Begin
81086>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81087>>>>>>>>>            End
81087>>>>>>>>>>
81087>>>>>>>>>            Else Begin
81088>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81089>>>>>>>>>            End
81089>>>>>>>>>>
81089>>>>>>>>>
81089>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81090>>>>>>>>>            If (bExists) Begin
81092>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81093>>>>>>>>>                If (bKeyOpened) Begin
81095>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81096>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81097>>>>>>>>>                    If (iDataSources > 0) Begin
81099>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81100>>>>>>>>>                        Decrement iDataSources
81101>>>>>>>>>                        for iCount from 0 to iDataSources
81107>>>>>>>>>>
81107>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81108>>>>>>>>>                        Loop
81109>>>>>>>>>>
81109>>>>>>>>>                        Move 0 to iItem
81110>>>>>>>>>                        for iCount from 0 to iDataSources
81116>>>>>>>>>>
81116>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81117>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81118>>>>>>>>>                            If (bKeyOpened = True) Begin
81120>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81121>>>>>>>>>                                If (bExists = True) Begin
81123>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81124>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81125>>>>>>>>>                                    Increment iItem
81126>>>>>>>>>                                End
81126>>>>>>>>>>
81126>>>>>>>>>                            End
81126>>>>>>>>>>
81126>>>>>>>>>                        Loop
81127>>>>>>>>>>
81127>>>>>>>>>                    End
81127>>>>>>>>>>
81127>>>>>>>>>                    Send CloseKey of hoRegistry
81128>>>>>>>>>                    Send Destroy of hoODBCDataSources
81129>>>>>>>>>                End
81129>>>>>>>>>>
81129>>>>>>>>>            End
81129>>>>>>>>>>
81129>>>>>>>>>
81129>>>>>>>>>            // We then check the "User DNS" area in the registry.
81129>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81130>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81131>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81132>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81133>>>>>>>>>
81133>>>>>>>>>            If (bExists) Begin
81135>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81136>>>>>>>>>                If (bKeyOpened) Begin
81138>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81139>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81140>>>>>>>>>                    If (iDataSources > 0) Begin
81142>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81143>>>>>>>>>                        Decrement iDataSources
81144>>>>>>>>>                        for iCount from 0 to iDataSources
81150>>>>>>>>>>
81150>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81151>>>>>>>>>                        Loop
81152>>>>>>>>>>
81152>>>>>>>>>                        for iCount from 0 to iDataSources
81158>>>>>>>>>>
81158>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81159>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81160>>>>>>>>>                            If (bKeyOpened = True) Begin
81162>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81163>>>>>>>>>                                If (bExists = True) Begin
81165>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81166>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81167>>>>>>>>>                                    Increment iItem
81168>>>>>>>>>                                End
81168>>>>>>>>>>
81168>>>>>>>>>                            End
81168>>>>>>>>>>
81168>>>>>>>>>                        Loop
81169>>>>>>>>>>
81169>>>>>>>>>                    End
81169>>>>>>>>>>
81169>>>>>>>>>                    Send CloseKey of hoRegistry
81170>>>>>>>>>                    Send Destroy of hoODBCDataSources
81171>>>>>>>>>                End
81171>>>>>>>>>>
81171>>>>>>>>>            End
81171>>>>>>>>>>
81171>>>>>>>>>
81171>>>>>>>>>            Send Destroy of hoRegistry
81172>>>>>>>>>        End
81172>>>>>>>>>>
81172>>>>>>>>>
81172>>>>>>>>>        Function_Return sReturnArray
81173>>>>>>>>>    End_Function
81174>>>>>>>>>
81174>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81174>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81174>>>>>>>>>    // insert it for scriplets to come after the first one.
81174>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81176>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81176>>>>>>>>>        Integer iStart iEnd iDbType
81176>>>>>>>>>        Boolean bOK
81176>>>>>>>>>
81176>>>>>>>>>        Get piDbType to iDbType
81177>>>>>>>>>        Get psDriverID to sDriverID
81178>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81179>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81180>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81181>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81182>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81183>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81185>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81186>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81187>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81188>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81189>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81190>>>>>>>>>        End
81190>>>>>>>>>>
81190>>>>>>>>>        Else Begin
81191>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81192>>>>>>>>>
81192>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81192>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81194>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81195>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81196>>>>>>>>>            End
81196>>>>>>>>>>
81196>>>>>>>>>
81196>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81196>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81196>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81196>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81199>>>>>>>>>                // Make sure we only have one space between statements/words.
81199>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81200>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81201>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81202>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81203>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81204>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81206>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81207>>>>>>>>>                End
81207>>>>>>>>>>
81207>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81208>>>>>>>>>                // Remove data view as it already exists!
81208>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81209>>>>>>>>>            End
81209>>>>>>>>>>
81209>>>>>>>>>        End
81209>>>>>>>>>>
81209>>>>>>>>>
81209>>>>>>>>>        Function_Return sStmt
81210>>>>>>>>>    End_Function
81211>>>>>>>>>
81211>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81211>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81213>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81213>>>>>>>>>        Integer iRetval
81213>>>>>>>>>        Boolean bOK
81213>>>>>>>>>
81213>>>>>>>>>        Get psDriverID to sDriverID
81214>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81215>>>>>>>>>
81215>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81216>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81217>>>>>>>>>        Set psSQLStatementString to sSQLString
81218>>>>>>>>>
81218>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81218>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81218>>>>>>>>>        Move False to Err
81219>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81220>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81221>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81222>>>>>>>>>        Move 0 to LastErr
81223>>>>>>>>>
81223>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81223>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81224>>>>>>>>>
81224>>>>>>>>>        Function_Return (Err = False)
81225>>>>>>>>>    End_Function
81226>>>>>>>>>
81226>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81226>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81228>>>>>>>>>        String sRetval
81228>>>>>>>>>        Integer iDbType iIndex
81228>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81228>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81229>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81229>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81229>>>>>>>>>
81229>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81229>>>>>>>>>        Move "" to sRetval
81230>>>>>>>>>        Get piDbType to iDbType
81231>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81232>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81233>>>>>>>>>
81233>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81234>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81235>>>>>>>>>        If (iIndex >= 0) Begin
81237>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81238>>>>>>>>>        End
81238>>>>>>>>>>
81238>>>>>>>>>
81238>>>>>>>>>        Function_Return sRetval
81239>>>>>>>>>    End_Function
81240>>>>>>>>>
81240>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81240>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81242>>>>>>>>>        String[] sSQLScriptArray
81243>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81243>>>>>>>>>        Integer iSize iCount
81243>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81243>>>>>>>>>
81243>>>>>>>>>        Move False to bCommentStart
81244>>>>>>>>>        Move False to bCommentEnd
81245>>>>>>>>>        Move False to bDashComment
81246>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81247>>>>>>>>>        Move "*/"  to sCommentEnd
81248>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81249>>>>>>>>>
81249>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81250>>>>>>>>>        Decrement iSize
81251>>>>>>>>>        Move "" to sText
81252>>>>>>>>>
81252>>>>>>>>>        for iCount from 0 to iSize
81258>>>>>>>>>>
81258>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81259>>>>>>>>>            Move (Trim(sLine)) to sTmp
81260>>>>>>>>>            If (sTmp <> "") Begin
81262>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81263>>>>>>>>>                If (bCommentStart = False) Begin
81265>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81266>>>>>>>>>                    If (bCommentStart = False) Begin
81268>>>>>>>>>                    End
81268>>>>>>>>>>
81268>>>>>>>>>                End
81268>>>>>>>>>>
81268>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81269>>>>>>>>>                If (bCommentEnd = True) Begin
81271>>>>>>>>>                    Move False to bCommentStart
81272>>>>>>>>>                End
81272>>>>>>>>>>
81272>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81274>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81275>>>>>>>>>                End
81275>>>>>>>>>>
81275>>>>>>>>>            End
81275>>>>>>>>>>
81275>>>>>>>>>        Loop
81276>>>>>>>>>>
81276>>>>>>>>>
81276>>>>>>>>>        // Update the retval struct array:
81276>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81277>>>>>>>>>        Function_Return SqlScriptArray
81278>>>>>>>>>    End_Function
81279>>>>>>>>>
81279>>>>>>>>>    // Helper function that builds a string like;
81279>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81279>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81281>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81281>>>>>>>>>
81281>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81282>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81283>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81284>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81285>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81286>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81287>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81288>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81289>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81290>>>>>>>>>        Function_Return sRetval
81291>>>>>>>>>    End_Function
81292>>>>>>>>>
81292>>>>>>>>>    // Helper function to create a SQL statement like;
81292>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81292>>>>>>>>>    // Used for checking if an index exists.
81292>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81294>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81294>>>>>>>>>
81294>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81295>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81296>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81297>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81298>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81299>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81300>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81301>>>>>>>>>
81301>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81302>>>>>>>>>
81302>>>>>>>>>        Function_Return sRetval
81303>>>>>>>>>    End_Function
81304>>>>>>>>>
81304>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81304>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81304>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81306>>>>>>>>>        String sRetval
81306>>>>>>>>>        If (iLength <> 0) Begin
81308>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81309>>>>>>>>>            If (iDecimals <> 0) Begin
81311>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81312>>>>>>>>>            End
81312>>>>>>>>>>
81312>>>>>>>>>            Move (sRetval + ")") to sRetval
81313>>>>>>>>>        End
81313>>>>>>>>>>
81313>>>>>>>>>        Function_Return sRetval
81314>>>>>>>>>    End_Function
81315>>>>>>>>>
81315>>>>>>>>>    // Checks that the passed sDriverID is defined.
81315>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81315>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81317>>>>>>>>>        Boolean bOK
81317>>>>>>>>>        Integer iDriver
81317>>>>>>>>>
81317>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81319>>>>>>>>>            Function_Return False
81320>>>>>>>>>        End
81320>>>>>>>>>>
81320>>>>>>>>>
81320>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81321>>>>>>>>>
81321>>>>>>>>>        If (bOK = False) Begin
81323>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81324>>>>>>>>>>
81324>>>>>>>>>            Function_Return False
81325>>>>>>>>>        End
81325>>>>>>>>>>
81325>>>>>>>>>
81325>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81326>>>>>>>>>        If (iDriver = 0) Begin
81328>>>>>>>>>            Load_Driver sDriverID
81329>>>>>>>>>        End
81329>>>>>>>>>>
81329>>>>>>>>>
81329>>>>>>>>>        Function_Return True
81330>>>>>>>>>    End_Function
81331>>>>>>>>>
81331>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81331>>>>>>>>>    // This is only of concern for certain SQL data types.
81331>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81333>>>>>>>>>        Integer iLength
81333>>>>>>>>>        Boolean bOK bCheckTypeLength
81333>>>>>>>>>
81333>>>>>>>>>        If (num_arguments > 1) Begin
81335>>>>>>>>>            Move iLen to iLength
81336>>>>>>>>>        End
81336>>>>>>>>>>
81336>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81337>>>>>>>>>
81337>>>>>>>>>        If (bCheckTypeLength = True) Begin
81339>>>>>>>>>            Move (iLength > 0) to bOK
81340>>>>>>>>>        End
81340>>>>>>>>>>
81340>>>>>>>>>
81340>>>>>>>>>        Function_Return (bOK = True)
81341>>>>>>>>>    End_Function
81342>>>>>>>>>
81342>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81344>>>>>>>>>        String sVal sSchema sDriverID
81344>>>>>>>>>        Integer iDbType
81344>>>>>>>>>
81344>>>>>>>>>        If (Trim(sTableName) = "") Begin
81346>>>>>>>>>            Function_Return ""
81347>>>>>>>>>        End
81347>>>>>>>>>>
81347>>>>>>>>>
81347>>>>>>>>>        Get psDriverID to sDriverID
81348>>>>>>>>>        Get piDbType   to iDbType
81349>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81351>>>>>>>>>            Get psUserID to sSchema
81352>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81352>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81353>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81354>>>>>>>>>            Function_Return sTableName
81355>>>>>>>>>        End
81355>>>>>>>>>>
81355>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81357>>>>>>>>>            Get psDatabase to sVal
81358>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81359>>>>>>>>>            Function_Return sTableName
81360>>>>>>>>>        End
81360>>>>>>>>>>
81360>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81362>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81363>>>>>>>>>            Function_Return sTableName
81364>>>>>>>>>        End
81364>>>>>>>>>>
81364>>>>>>>>>
81364>>>>>>>>>        Get psSchema to sSchema
81365>>>>>>>>>        If (sSchema = "") Begin
81367>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81368>>>>>>>>>        End
81368>>>>>>>>>>
81368>>>>>>>>>
81368>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81369>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81371>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81373>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81374>>>>>>>>>            End
81374>>>>>>>>>>
81374>>>>>>>>>            Else Begin
81375>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81376>>>>>>>>>            End
81376>>>>>>>>>>
81376>>>>>>>>>        End
81376>>>>>>>>>>
81376>>>>>>>>>
81376>>>>>>>>>        Function_Return sTableName
81377>>>>>>>>>    End_Function
81378>>>>>>>>>
81378>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81378>>>>>>>>>    // the passed sFieldName has the correct spelling.
81378>>>>>>>>>    // Used with Embedded SQL statement calls.
81378>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81378>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81380>>>>>>>>>        String sRetval sValue sDriverID
81380>>>>>>>>>        String[] sColumnNamesArray
81381>>>>>>>>>        Integer iCount iColumns
81381>>>>>>>>>
81381>>>>>>>>>        Move "" to sRetval
81382>>>>>>>>>        Get psDriverID to sDriverID
81383>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81384>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81385>>>>>>>>>        Decrement iColumns
81386>>>>>>>>>
81386>>>>>>>>>        For iCount from 0 to iColumns
81392>>>>>>>>>>
81392>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81393>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81395>>>>>>>>>                Move sValue to sRetval
81396>>>>>>>>>                Move iColumns to iCount // We're done.
81397>>>>>>>>>            End
81397>>>>>>>>>>
81397>>>>>>>>>        Loop
81398>>>>>>>>>>
81398>>>>>>>>>
81398>>>>>>>>>        Function_Return sRetval
81399>>>>>>>>>    End_Function
81400>>>>>>>>>
81400>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81402>>>>>>>>>        String[] sReturnArray
81403>>>>>>>>>        Handle hoSQLHandler
81403>>>>>>>>>        Integer iCount iSize iItem
81403>>>>>>>>>        String sServer
81403>>>>>>>>>        tSQLConnection SQLConnection
81403>>>>>>>>>        tSQLConnection SQLConnection
81403>>>>>>>>>
81403>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81404>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81405>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81406>>>>>>>>>
81406>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81407>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81408>>>>>>>>>        Decrement iSize
81409>>>>>>>>>
81409>>>>>>>>>        For iCount from 0 to iSize
81415>>>>>>>>>>
81415>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81416>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81417>>>>>>>>>            Increment iItem
81418>>>>>>>>>        Loop
81419>>>>>>>>>>
81419>>>>>>>>>
81419>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81420>>>>>>>>>
81420>>>>>>>>>        Function_Return sReturnArray
81421>>>>>>>>>    End_Function
81422>>>>>>>>>
81422>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81424>>>>>>>>>        String[] sReturnArray
81425>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81425>>>>>>>>>        Handle hoSQLHandler
81425>>>>>>>>>        Integer iCount iSize iItem iPos
81425>>>>>>>>>        Boolean bOK
81425>>>>>>>>>        tSQLConnection SQLConnection
81425>>>>>>>>>        tSQLConnection SQLConnection
81425>>>>>>>>>
81425>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81426>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81428>>>>>>>>>            Function_Return sReturnArray
81429>>>>>>>>>        End
81429>>>>>>>>>>
81429>>>>>>>>>
81429>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81430>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81431>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81432>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81433>>>>>>>>>
81433>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81434>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81435>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81436>>>>>>>>>
81436>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81437>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81438>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81438>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81438>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81438>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81438>>>>>>>>>//                If (iPos > 0) Begin
81438>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81438>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81438>>>>>>>>>//                End
81438>>>>>>>>>//            End
81438>>>>>>>>>//        End
81438>>>>>>>>>
81438>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81439>>>>>>>>>        Move False to Err
81440>>>>>>>>>        Move 0 to iItem
81441>>>>>>>>>
81441>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81441>>>>>>>>>        For iCount from 1 to iSize
81447>>>>>>>>>>
81447>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81448>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81449>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81450>>>>>>>>>            If (sSchema = "") Begin
81452>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81453>>>>>>>>>            End
81453>>>>>>>>>>
81453>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81454>>>>>>>>>            Move (Trim(sTable)) to sTable
81455>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81457>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81458>>>>>>>>>            End
81458>>>>>>>>>>
81458>>>>>>>>>            Else Begin
81459>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81460>>>>>>>>>            End
81460>>>>>>>>>>
81460>>>>>>>>>            If (bOK = True) Begin
81462>>>>>>>>>                Move sTable to sReturnArray[iItem]
81463>>>>>>>>>                Increment iItem
81464>>>>>>>>>            End
81464>>>>>>>>>>
81464>>>>>>>>>        Loop
81465>>>>>>>>>>
81465>>>>>>>>>
81465>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81466>>>>>>>>>
81466>>>>>>>>>        Function_Return sReturnArray
81467>>>>>>>>>    End_Function
81468>>>>>>>>>
81468>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81470>>>>>>>>>        String[] sReturnArray
81471>>>>>>>>>        String sValue
81471>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81471>>>>>>>>>        Integer iRetval iCols iFetchResult
81471>>>>>>>>>        tSQLConnection SQLConnection
81471>>>>>>>>>        tSQLConnection SQLConnection
81471>>>>>>>>>
81471>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81472>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81473>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81474>>>>>>>>>
81474>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81476>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81477>>>>>>>>>            If (hStmt <> 0) Begin
81479>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81480>>>>>>>>>                If (sArgument <> "") Begin
81482>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81483>>>>>>>>>                End
81483>>>>>>>>>>
81483>>>>>>>>>
81483>>>>>>>>>                Send SqlCall             of hStmt
81484>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81485>>>>>>>>>                If (iRetval = 0) Begin
81487>>>>>>>>>                    Repeat
81487>>>>>>>>>>
81487>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81488>>>>>>>>>                        If (iCols > 0) Begin
81490>>>>>>>>>                            Repeat
81490>>>>>>>>>>
81490>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81491>>>>>>>>>                                If (iFetchResult <> 0) Begin
81493>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81494>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81495>>>>>>>>>                                End
81495>>>>>>>>>>
81495>>>>>>>>>                            Until (iFetchResult = 0)
81497>>>>>>>>>                        End
81497>>>>>>>>>>
81497>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81498>>>>>>>>>                    Until (iRetval = 0)
81500>>>>>>>>>                    Send SqlClose of hStmt
81501>>>>>>>>>                End
81501>>>>>>>>>>
81501>>>>>>>>>            End
81501>>>>>>>>>>
81501>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81502>>>>>>>>>        End
81502>>>>>>>>>>
81502>>>>>>>>>        Function_Return sReturnArray
81503>>>>>>>>>    End_Function
81504>>>>>>>>>
81504>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81506>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81506>>>>>>>>>        Boolean bOpened bOK
81506>>>>>>>>>
81506>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81506>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81506>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81506>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81506>>>>>>>>>        // proper .int files for the two tables.
81506>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81508>>>>>>>>>            Function_Return True
81509>>>>>>>>>        End
81509>>>>>>>>>>
81509>>>>>>>>>
81509>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81512>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81513>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81514>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81515>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81516>>>>>>>>>
81516>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81516>>>>>>>>>        Sleep 1
81517>>>>>>>>>
81517>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81520>>>>>>>>>        If (bOpened = False) Begin
81522>>>>>>>>>            Open hTable
81524>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81527>>>>>>>>>        End
81527>>>>>>>>>>
81527>>>>>>>>>        If (bOpened = False) Begin
81529>>>>>>>>>            Function_Return False
81530>>>>>>>>>        End
81530>>>>>>>>>>
81530>>>>>>>>>
81530>>>>>>>>>        Get psDriverID to sDriverID
81531>>>>>>>>>
81531>>>>>>>>>        Move False to Err
81532>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81535>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81536>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81536>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81536>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81537>>>>>>>>>
81537>>>>>>>>>        Move False to Err
81538>>>>>>>>>
81538>>>>>>>>>        If (hTable > 0) Begin
81540>>>>>>>>>            Structure_Start hTable
81541>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81544>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81547>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81549>>>>>>>>>        End
81549>>>>>>>>>>
81549>>>>>>>>>        Else Begin
81550>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81553>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81556>>>>>>>>>        End
81556>>>>>>>>>>
81556>>>>>>>>>        Function_Return (Err = False)
81557>>>>>>>>>    End_Function
81558>>>>>>>>>
81558>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81558>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81560>>>>>>>>>        Handle hTable
81560>>>>>>>>>        String sConnectionID
81560>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81560>>>>>>>>>
81560>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81561>>>>>>>>>        If (bSameTableNames = True) Begin
81563>>>>>>>>>            Function_Return True
81564>>>>>>>>>        End
81564>>>>>>>>>>
81564>>>>>>>>>
81564>>>>>>>>>        Move True to bOK
81565>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81566>>>>>>>>>        Set Private.phCurrentTable              to hTable
81567>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81570>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81573>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81576>>>>>>>>>
81576>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81578>>>>>>>>>            Get psConnectionID to sConnectionID
81579>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81580>>>>>>>>>            If (bTableExists = True) Begin
81582>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81583>>>>>>>>>            End
81583>>>>>>>>>>
81583>>>>>>>>>            Else Begin
81584>>>>>>>>>                Get pbToANSI to bANSI
81585>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81586>>>>>>>>>            End
81586>>>>>>>>>>
81586>>>>>>>>>        End
81586>>>>>>>>>>
81586>>>>>>>>>
81586>>>>>>>>>        Function_Return bOK
81587>>>>>>>>>    End_Function
81588>>>>>>>>>
81588>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81588>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81588>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81590>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81590>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81590>>>>>>>>>        String[] sIndexArray
81591>>>>>>>>>        Integer iCount iCh iSize
81591>>>>>>>>>
81591>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81592>>>>>>>>>        Get psConnectionString to sConnectionString
81593>>>>>>>>>
81593>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81594>>>>>>>>>        If (bANSI = False) Begin
81596>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81597>>>>>>>>>        End
81597>>>>>>>>>>
81597>>>>>>>>>
81597>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81598>>>>>>>>>        Get vFolderExists sDataPath to bOK
81599>>>>>>>>>        If (bOK = False) Begin
81601>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81602>>>>>>>>>>
81602>>>>>>>>>            Function_Return False
81603>>>>>>>>>        End
81603>>>>>>>>>>
81603>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81604>>>>>>>>>
81604>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81607>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81610>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81611>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81612>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81613>>>>>>>>>
81613>>>>>>>>>        Get psSchema hTable to sSchemaName
81614>>>>>>>>>        If (sSchemaName = "") Begin
81616>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81617>>>>>>>>>        End
81617>>>>>>>>>>
81617>>>>>>>>>
81617>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81617>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81618>>>>>>>>>        If (bExists = True) Begin
81620>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81621>>>>>>>>>        End
81621>>>>>>>>>>
81621>>>>>>>>>
81621>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81622>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81623>>>>>>>>>
81623>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81624>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81629>>>>>>>>>            If (bUseConnectionID = True) Begin
81631>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81638>>>>>>>>>            End
81638>>>>>>>>>>
81638>>>>>>>>>            Else Begin
81639>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81646>>>>>>>>>            End
81646>>>>>>>>>>
81646>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81651>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81656>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81656>>>>>>>>>            If (bSysFile = True) Begin
81658>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81663>>>>>>>>>            End
81663>>>>>>>>>>
81663>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81668>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81673>>>>>>>>>            If (bSysFile = True) Begin
81675>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81680>>>>>>>>>            End
81680>>>>>>>>>>
81680>>>>>>>>>
81680>>>>>>>>>            If (bSysFile = False) Begin
81682>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81683>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81684>>>>>>>>>                If (iSize > 0) Begin
81686>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81689>>>>>>>>>                    Writeln channel iCh // Just an empty line
81691>>>>>>>>>                End
81691>>>>>>>>>>
81691>>>>>>>>>                Decrement iSize
81692>>>>>>>>>                for iCount from 0 to iSize
81698>>>>>>>>>>
81698>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81701>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81704>>>>>>>>>                    Writeln channel iCh
81706>>>>>>>>>                Loop
81707>>>>>>>>>>
81707>>>>>>>>>            End
81707>>>>>>>>>>
81707>>>>>>>>>        Send Seq_Close_Channel iCh
81708>>>>>>>>>
81708>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81708>>>>>>>>>        Sleep 1
81709>>>>>>>>>
81709>>>>>>>>>        Function_Return (bOK = True)
81710>>>>>>>>>    End_Function
81711>>>>>>>>>
81711>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81713>>>>>>>>>        String sDataPath sDriverID
81713>>>>>>>>>        Boolean bOK
81713>>>>>>>>>        Integer iPos
81713>>>>>>>>>
81713>>>>>>>>>        If (sTableName contains ".") Begin
81715>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81716>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81717>>>>>>>>>        End
81717>>>>>>>>>>
81717>>>>>>>>>
81717>>>>>>>>>        Get psDriverID to sDriverID
81718>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81719>>>>>>>>>        // First delete the cache file:
81719>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81720>>>>>>>>>
81720>>>>>>>>>        Function_Return bOK
81721>>>>>>>>>    End_Function
81722>>>>>>>>>
81722>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81722>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81722>>>>>>>>>    // if it is an SQL table
81722>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81724>>>>>>>>>        Boolean bExists bIsSQLTable
81724>>>>>>>>>        String sDataPath sRootName
81724>>>>>>>>>
81724>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81725>>>>>>>>>        If (bExists = False) Begin
81727>>>>>>>>>            Function_Return False
81728>>>>>>>>>        End
81728>>>>>>>>>>
81728>>>>>>>>>
81728>>>>>>>>>        Move False to bIsSQLTable
81729>>>>>>>>>        If (hTable > 0) Begin
81731>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81734>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81735>>>>>>>>>        End
81735>>>>>>>>>>
81735>>>>>>>>>        If (bIsSQLTable = True) Begin
81737>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81738>>>>>>>>>            Function_Return bExists
81739>>>>>>>>>        End
81739>>>>>>>>>>
81739>>>>>>>>>        Else Begin
81740>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81741>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81742>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81743>>>>>>>>>        End
81743>>>>>>>>>>
81743>>>>>>>>>
81743>>>>>>>>>        Function_Return bExists
81744>>>>>>>>>    End_Function
81745>>>>>>>>>
81745>>>>>>>>>    // Pass a table handle
81745>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81745>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81747>>>>>>>>>        Handle hTable
81747>>>>>>>>>        Boolean bFound
81747>>>>>>>>>
81747>>>>>>>>>        Move False to bFound
81748>>>>>>>>>        Move 0 to hTable
81749>>>>>>>>>        Repeat
81749>>>>>>>>>>
81749>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81752>>>>>>>>>            If (hTable > 0) Begin
81754>>>>>>>>>                If (hTable = hCheckTable) Begin
81756>>>>>>>>>                    Move True to bFound
81757>>>>>>>>>                End
81757>>>>>>>>>>
81757>>>>>>>>>            End
81757>>>>>>>>>>
81757>>>>>>>>>            If (bFound = True) ;                Break
81760>>>>>>>>>        Until (hTable = 0)
81762>>>>>>>>>
81762>>>>>>>>>        Function_Return (bFound = True)
81763>>>>>>>>>    End_Function
81764>>>>>>>>>
81764>>>>>>>>>    // DataFlex Embedded Database Data Types:
81764>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81764>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81766>>>>>>>>>        tColumnType[] ColumnType
81766>>>>>>>>>        tColumnType[] ColumnType
81767>>>>>>>>>        Integer i
81767>>>>>>>>>
81767>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81768>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81769>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81770>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81771>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81772>>>>>>>>>        Increment i
81773>>>>>>>>>
81773>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81774>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81775>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81776>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81777>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81778>>>>>>>>>        Increment i
81779>>>>>>>>>
81779>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81780>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81781>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81782>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81783>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81784>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81785>>>>>>>>>        Increment i
81786>>>>>>>>>
81786>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81787>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81788>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81789>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81790>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81791>>>>>>>>>        Increment i
81792>>>>>>>>>
81792>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81793>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81794>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81795>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81796>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81797>>>>>>>>>        Increment i
81798>>>>>>>>>
81798>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81799>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81800>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81801>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81802>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81803>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81804>>>>>>>>>        Increment i
81805>>>>>>>>>
81805>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81806>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81807>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81808>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81809>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81810>>>>>>>>>
81810>>>>>>>>>        Function_Return ColumnType
81811>>>>>>>>>    End_Function
81812>>>>>>>>>
81812>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81814>>>>>>>>>        tColumnType[] aColumnType
81814>>>>>>>>>        tColumnType[] aColumnType
81815>>>>>>>>>        Integer i
81815>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81815>>>>>>>>>>// Generated By The Database Update Framework
81815>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81815>>>>>>>>>>// Driver COLUMN DATA TYPES
81815>>>>>>>>>>//
81815>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
81815>>>>>>>>>>
81815>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81816>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81817>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81818>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81819>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81820>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81821>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81822>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81823>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81824>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81825>>>>>>>>>>            Increment i
81826>>>>>>>>>>
81826>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81827>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81828>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81829>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81830>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81831>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81832>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81833>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81834>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81835>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81836>>>>>>>>>>            Increment i
81837>>>>>>>>>>
81837>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81838>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81839>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81840>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81841>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81842>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81843>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81844>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81845>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81846>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81847>>>>>>>>>>            Increment i
81848>>>>>>>>>>
81848>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81849>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81850>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81851>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81852>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81853>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81854>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81855>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81856>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81857>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81858>>>>>>>>>>            Increment i
81859>>>>>>>>>>
81859>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81860>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81861>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81862>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81863>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81864>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81865>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81866>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81867>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81868>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81869>>>>>>>>>>            Increment i
81870>>>>>>>>>>
81870>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81871>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81872>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81873>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81874>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81875>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81876>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81877>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81878>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81879>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81880>>>>>>>>>>            Increment i
81881>>>>>>>>>>
81881>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81882>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81883>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81884>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81885>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81886>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81887>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81888>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81889>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81890>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81891>>>>>>>>>>            Increment i
81892>>>>>>>>>>
81892>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81893>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81894>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81895>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81896>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81897>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81898>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81899>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81900>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81901>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81902>>>>>>>>>>            Increment i
81903>>>>>>>>>>
81903>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81904>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81905>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81906>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81907>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81908>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81909>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81910>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81911>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81912>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81913>>>>>>>>>>            Increment i
81914>>>>>>>>>>
81914>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81915>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81916>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81917>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81918>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81919>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81920>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81921>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81922>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81923>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81924>>>>>>>>>>            Increment i
81925>>>>>>>>>>
81925>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81926>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81927>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81928>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81929>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81930>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81931>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81932>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81933>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81934>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81935>>>>>>>>>>            Increment i
81936>>>>>>>>>>
81936>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81937>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81938>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81939>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81940>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81941>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81942>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81943>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81944>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81945>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81946>>>>>>>>>>            Increment i
81947>>>>>>>>>>
81947>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81948>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81949>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81950>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81951>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81952>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81953>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81954>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81955>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81956>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81957>>>>>>>>>>            Increment i
81958>>>>>>>>>>
81958>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81959>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81960>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81961>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81962>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81963>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81964>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81965>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81966>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81967>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81968>>>>>>>>>>            Increment i
81969>>>>>>>>>>
81969>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81970>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81971>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81972>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81973>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81974>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81975>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81976>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81977>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81978>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81979>>>>>>>>>>            Increment i
81980>>>>>>>>>>
81980>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81981>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81982>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81983>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81984>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81985>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81986>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81987>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81988>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81989>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81990>>>>>>>>>>            Increment i
81991>>>>>>>>>>
81991>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
81992>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
81993>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81994>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81995>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81996>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81997>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81998>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81999>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82000>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82001>>>>>>>>>>            Increment i
82002>>>>>>>>>>
82002>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82003>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82004>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82005>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82006>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82007>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82008>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82009>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82010>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82011>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82012>>>>>>>>>>            Increment i
82013>>>>>>>>>>
82013>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82014>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82015>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82016>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82017>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82018>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82019>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82020>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82021>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82022>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82023>>>>>>>>>>            Increment i
82024>>>>>>>>>>
82024>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82025>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82026>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82027>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82028>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82029>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82030>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82031>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82032>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82033>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82034>>>>>>>>>>            Increment i
82035>>>>>>>>>>
82035>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82036>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82037>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82038>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82039>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82040>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82041>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82042>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82043>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82044>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82045>>>>>>>>>>            Increment i
82046>>>>>>>>>>
82046>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82047>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82048>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82049>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82050>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82051>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82052>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82053>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82054>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82055>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82056>>>>>>>>>>            Increment i
82057>>>>>>>>>>
82057>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82058>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82059>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82060>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82061>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82062>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82063>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82064>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82065>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82066>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82067>>>>>>>>>>            Increment i
82068>>>>>>>>>>
82068>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82069>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82070>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82071>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82072>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82073>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82074>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82075>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82076>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82077>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82078>>>>>>>>>>            Increment i
82079>>>>>>>>>>
82079>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82080>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82081>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82082>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82083>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82084>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82085>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82086>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82087>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82088>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82089>>>>>>>>>>            Increment i
82090>>>>>>>>>>
82090>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82091>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82092>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82093>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82094>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82095>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82096>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82097>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82098>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82099>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82100>>>>>>>>>>            Increment i
82101>>>>>>>>>>
82101>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82102>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82103>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82104>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82105>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82106>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82107>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82108>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82109>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82110>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82111>>>>>>>>>>            Increment i
82112>>>>>>>>>>
82112>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82113>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82114>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82115>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82116>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82117>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82118>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82119>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82120>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82121>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82122>>>>>>>>>>            Increment i
82123>>>>>>>>>>
82123>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82124>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82125>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82126>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82127>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82128>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82129>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82130>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82131>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82132>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82133>>>>>>>>>>            Increment i
82134>>>>>>>>>>
82134>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82135>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82136>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82137>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82138>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82139>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82140>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82141>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82142>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82143>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82144>>>>>>>>>>            Increment i
82145>>>>>>>>>>
82145>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82146>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82147>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82148>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82149>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82150>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82151>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82152>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82153>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82154>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82155>>>>>>>>>>            Increment i
82156>>>>>>>>>>
82156>>>>>>>>>>
82156>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82156>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82156>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82156>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82156>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82156>>>>>>>>>//        Increment i
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>//
82156>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82156>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82156>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82156>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82156>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82156>>>>>>>>>
82156>>>>>>>>>        Function_Return aColumnType
82157>>>>>>>>>    End_Function
82158>>>>>>>>>
82158>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82158>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82158>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82160>>>>>>>>>        tColumnType[] aColumnType
82160>>>>>>>>>        tColumnType[] aColumnType
82161>>>>>>>>>        Integer i
82161>>>>>>>>>
82161>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82163>>>>>>>>>>// Generated By The Database Update Framework
82163>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82163>>>>>>>>>>// Driver COLUMN DATA TYPES
82163>>>>>>>>>>//
82163>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82163>>>>>>>>>>
82163>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82164>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82165>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82166>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82167>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82168>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82169>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82170>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82171>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82172>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82173>>>>>>>>>>            Increment i
82174>>>>>>>>>>
82174>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82175>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82176>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82177>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82178>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82179>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82180>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82181>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82182>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82183>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82184>>>>>>>>>>            Increment i
82185>>>>>>>>>>
82185>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82186>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82187>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82188>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82189>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82190>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82191>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82192>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82193>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82194>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82195>>>>>>>>>>            Increment i
82196>>>>>>>>>>
82196>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82197>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82198>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82199>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82200>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82201>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82202>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82203>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82204>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82205>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82206>>>>>>>>>>            Increment i
82207>>>>>>>>>>
82207>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82208>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82209>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82210>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82211>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82212>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82213>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82214>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82215>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82216>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82217>>>>>>>>>>            Increment i
82218>>>>>>>>>>
82218>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82219>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82220>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82221>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82222>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82223>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82224>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82225>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82226>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82227>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82228>>>>>>>>>>            Increment i
82229>>>>>>>>>>
82229>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82230>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82231>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82232>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82233>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82234>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82235>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82236>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82237>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82238>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82239>>>>>>>>>>            Increment i
82240>>>>>>>>>>
82240>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82241>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82242>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82243>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82244>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82245>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82246>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82247>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82248>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82249>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82250>>>>>>>>>>            Increment i
82251>>>>>>>>>>
82251>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82252>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82253>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82254>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82255>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82256>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82257>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82258>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82259>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82260>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82261>>>>>>>>>>            Increment i
82262>>>>>>>>>>
82262>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82263>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82264>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82265>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82266>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82267>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82268>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82269>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82270>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82271>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82272>>>>>>>>>>            Increment i
82273>>>>>>>>>>
82273>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82274>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82275>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82276>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82277>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82278>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82279>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82280>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82281>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82282>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82283>>>>>>>>>>            Increment i
82284>>>>>>>>>>
82284>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82285>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82286>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82287>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82288>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82289>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82290>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82291>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82292>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82293>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82294>>>>>>>>>>            Increment i
82295>>>>>>>>>>
82295>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82296>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82297>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82298>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82299>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82300>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82301>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82302>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82303>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82304>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82305>>>>>>>>>>            Increment i
82306>>>>>>>>>>
82306>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82307>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82308>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82309>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82310>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82311>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82312>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82313>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82314>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82315>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82316>>>>>>>>>>            Increment i
82317>>>>>>>>>>
82317>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82318>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82319>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82320>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82321>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82322>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82323>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82324>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82325>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82326>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82327>>>>>>>>>>            Increment i
82328>>>>>>>>>>
82328>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82329>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82330>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82331>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82332>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82333>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82334>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82335>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82336>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82337>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82338>>>>>>>>>>            Increment i
82339>>>>>>>>>>
82339>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82340>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82341>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82342>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82343>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82344>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82345>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82346>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82347>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82348>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82349>>>>>>>>>>            Increment i
82350>>>>>>>>>>
82350>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82351>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82352>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82353>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82354>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82355>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82356>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82357>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82358>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82359>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82360>>>>>>>>>>            Increment i
82361>>>>>>>>>>
82361>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82362>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82363>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82364>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82365>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82366>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82367>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82368>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82369>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82370>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82371>>>>>>>>>>            Increment i
82372>>>>>>>>>>
82372>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82373>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82374>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82375>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82376>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82377>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82378>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82379>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82380>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82381>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82382>>>>>>>>>>            Increment i
82383>>>>>>>>>>
82383>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82384>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82385>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82386>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82387>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82388>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82389>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82390>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82391>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82392>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82393>>>>>>>>>>            Increment i
82394>>>>>>>>>>
82394>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82395>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82396>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82397>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82398>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82399>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82400>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82401>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82402>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82403>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82404>>>>>>>>>>            Increment i
82405>>>>>>>>>>
82405>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82406>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82407>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82408>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82409>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82410>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82411>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82412>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82413>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82414>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82415>>>>>>>>>>            Increment i
82416>>>>>>>>>>
82416>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82417>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82418>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82419>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82420>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82421>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82422>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82423>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82424>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82425>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82426>>>>>>>>>>            Increment i
82427>>>>>>>>>>
82427>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82428>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82429>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82430>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82431>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82432>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82433>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82434>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82435>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82436>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82437>>>>>>>>>>            Increment i
82438>>>>>>>>>>
82438>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82439>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82440>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82441>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82442>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82443>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82444>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82445>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82446>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82447>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82448>>>>>>>>>>            Increment i
82449>>>>>>>>>>
82449>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82450>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82451>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82452>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82453>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82454>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82455>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82456>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82457>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82458>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82459>>>>>>>>>>            Increment i
82460>>>>>>>>>>
82460>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82461>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82462>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82463>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82464>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82465>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82466>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82467>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82468>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82469>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82470>>>>>>>>>>            Increment i
82471>>>>>>>>>>
82471>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82472>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82473>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82474>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82475>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82476>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82477>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82478>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82479>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82480>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82481>>>>>>>>>>            Increment i
82482>>>>>>>>>>
82482>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82483>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82484>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82485>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82486>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82487>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82488>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82489>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82490>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82491>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82492>>>>>>>>>>            Increment i
82493>>>>>>>>>>
82493>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82494>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82495>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82496>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82497>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82498>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82499>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82500>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82501>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82502>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82503>>>>>>>>>>            Increment i
82504>>>>>>>>>>
82504>>>>>>>>>>
82504>>>>>>>>>
82504>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>//
82504>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82504>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82504>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82504>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82504>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82504>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82504>>>>>>>>>//            Increment i
82504>>>>>>>>>
82504>>>>>>>>>        End
82504>>>>>>>>>>
82504>>>>>>>>>
82504>>>>>>>>>        Function_Return aColumnType
82505>>>>>>>>>    End_Function
82506>>>>>>>>>
82506>>>>>>>>>    // MySQL Data Types
82506>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82508>>>>>>>>>        tColumnType[] aColumnType
82508>>>>>>>>>        tColumnType[] aColumnType
82509>>>>>>>>>        Integer i
82509>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82509>>>>>>>>>>// Generated By The Database Update Framework
82509>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82509>>>>>>>>>>// Driver COLUMN DATA TYPES
82509>>>>>>>>>>//
82509>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82509>>>>>>>>>>
82509>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82510>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82511>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82512>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82513>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82514>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82515>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82516>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82517>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82518>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82519>>>>>>>>>>            Increment i
82520>>>>>>>>>>
82520>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82521>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82522>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82523>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82524>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82525>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82526>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82527>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82528>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82529>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82530>>>>>>>>>>            Increment i
82531>>>>>>>>>>
82531>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82532>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82533>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82534>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82535>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82536>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82537>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82538>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82539>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82540>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82541>>>>>>>>>>            Increment i
82542>>>>>>>>>>
82542>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82543>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82544>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82545>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82546>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82547>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82548>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82549>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82550>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82551>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82552>>>>>>>>>>            Increment i
82553>>>>>>>>>>
82553>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82554>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82555>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82556>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82557>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82558>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82559>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82560>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82561>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82562>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82563>>>>>>>>>>            Increment i
82564>>>>>>>>>>
82564>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82565>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82566>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82567>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82568>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82569>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82570>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82571>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82572>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82573>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82574>>>>>>>>>>            Increment i
82575>>>>>>>>>>
82575>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82576>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82577>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82578>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82579>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82580>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82581>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82582>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82583>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82584>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82585>>>>>>>>>>            Increment i
82586>>>>>>>>>>
82586>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82587>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82588>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82589>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82590>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82591>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82592>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82593>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82594>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82595>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82596>>>>>>>>>>            Increment i
82597>>>>>>>>>>
82597>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82598>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82599>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82600>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82601>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82602>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82603>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82604>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82605>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82606>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82607>>>>>>>>>>            Increment i
82608>>>>>>>>>>
82608>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82609>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82610>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82611>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82612>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82613>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82614>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82615>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82616>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82617>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82618>>>>>>>>>>            Increment i
82619>>>>>>>>>>
82619>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82620>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82621>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82622>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82623>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82624>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82625>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82626>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82627>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82628>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82629>>>>>>>>>>            Increment i
82630>>>>>>>>>>
82630>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82631>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82632>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82633>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82634>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82635>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82636>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82637>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82638>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82639>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82640>>>>>>>>>>            Increment i
82641>>>>>>>>>>
82641>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82642>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82643>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82644>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82645>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82646>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82647>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82648>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82649>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82650>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82651>>>>>>>>>>            Increment i
82652>>>>>>>>>>
82652>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82653>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82654>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82655>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82656>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82657>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82658>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82659>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82660>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82661>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82662>>>>>>>>>>            Increment i
82663>>>>>>>>>>
82663>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82664>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82665>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82666>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82667>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82668>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82669>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82670>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82671>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82672>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82673>>>>>>>>>>            Increment i
82674>>>>>>>>>>
82674>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82675>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82676>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82677>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82678>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82679>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82680>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82681>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82682>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82683>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82684>>>>>>>>>>            Increment i
82685>>>>>>>>>>
82685>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82686>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82687>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82688>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82689>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82690>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82691>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82692>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82693>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82694>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82695>>>>>>>>>>            Increment i
82696>>>>>>>>>>
82696>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82697>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82698>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82699>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82700>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82701>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82702>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82703>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82704>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82705>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82706>>>>>>>>>>            Increment i
82707>>>>>>>>>>
82707>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82708>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82709>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82710>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82711>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82712>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82713>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82714>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82715>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82716>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82717>>>>>>>>>>            Increment i
82718>>>>>>>>>>
82718>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82719>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82720>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82721>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82722>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82723>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82724>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82725>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82726>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82727>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82728>>>>>>>>>>            Increment i
82729>>>>>>>>>>
82729>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82730>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82731>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82732>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82733>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82734>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82735>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82736>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82737>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82738>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82739>>>>>>>>>>            Increment i
82740>>>>>>>>>>
82740>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82741>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82742>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82743>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82744>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82745>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82746>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82747>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82748>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82749>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82750>>>>>>>>>>            Increment i
82751>>>>>>>>>>
82751>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82752>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82753>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82754>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82755>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82756>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82757>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82758>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82759>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82760>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82761>>>>>>>>>>            Increment i
82762>>>>>>>>>>
82762>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82763>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82764>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82765>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82766>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82767>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82768>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82769>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82770>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82771>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82772>>>>>>>>>>            Increment i
82773>>>>>>>>>>
82773>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82774>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82775>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82776>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82777>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82778>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82779>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82780>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82781>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82782>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82783>>>>>>>>>>            Increment i
82784>>>>>>>>>>
82784>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82785>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82786>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82787>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82788>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82789>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82790>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82791>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82792>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82793>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82794>>>>>>>>>>            Increment i
82795>>>>>>>>>>
82795>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82796>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82797>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82798>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82799>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82800>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82801>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82802>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82803>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82804>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82805>>>>>>>>>>            Increment i
82806>>>>>>>>>>
82806>>>>>>>>>>
82806>>>>>>>>>
82806>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>//
82806>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82806>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82806>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82806>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82806>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82806>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82806>>>>>>>>>//        Increment i
82806>>>>>>>>>
82806>>>>>>>>>        Function_Return aColumnType
82807>>>>>>>>>    End_Function
82808>>>>>>>>>
82808>>>>>>>>>    // Oracle Data Types
82808>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82810>>>>>>>>>        tColumnType[] aColumnType
82810>>>>>>>>>        tColumnType[] aColumnType
82811>>>>>>>>>        Integer i
82811>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82811>>>>>>>>>>// Generated By The Database Update Framework
82811>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82811>>>>>>>>>>// Driver COLUMN DATA TYPES
82811>>>>>>>>>>//
82811>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82811>>>>>>>>>>
82811>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82812>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82813>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82814>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82815>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82816>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82817>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82818>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82819>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82820>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82821>>>>>>>>>>            Increment i
82822>>>>>>>>>>
82822>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82823>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82824>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82825>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82826>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82827>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82828>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82829>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82830>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82831>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82832>>>>>>>>>>            Increment i
82833>>>>>>>>>>
82833>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82834>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82835>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82836>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82837>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82838>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82839>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82840>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82841>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82842>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82843>>>>>>>>>>            Increment i
82844>>>>>>>>>>
82844>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82845>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82846>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82847>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82848>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82849>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82850>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82851>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82852>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82853>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82854>>>>>>>>>>            Increment i
82855>>>>>>>>>>
82855>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82856>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82857>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82858>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82859>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82860>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82861>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82862>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82863>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82864>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82865>>>>>>>>>>            Increment i
82866>>>>>>>>>>
82866>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82867>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82868>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82869>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82870>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82871>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82872>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82873>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82874>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82875>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82876>>>>>>>>>>            Increment i
82877>>>>>>>>>>
82877>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82878>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82879>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82880>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82881>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82882>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82883>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82884>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82885>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82886>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82887>>>>>>>>>>            Increment i
82888>>>>>>>>>>
82888>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82889>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82890>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82891>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82892>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82893>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82894>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82895>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82896>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82897>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82898>>>>>>>>>>            Increment i
82899>>>>>>>>>>
82899>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82900>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82901>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82902>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82903>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82904>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82905>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82906>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82907>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82908>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82909>>>>>>>>>>            Increment i
82910>>>>>>>>>>
82910>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82911>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82912>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82913>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82914>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82915>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82916>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82917>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82918>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82919>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82920>>>>>>>>>>            Increment i
82921>>>>>>>>>>
82921>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82922>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82923>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82924>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82925>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82926>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82927>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82928>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82929>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82930>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82931>>>>>>>>>>            Increment i
82932>>>>>>>>>>
82932>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82933>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82934>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82935>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82936>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82937>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82938>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82939>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82940>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82941>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82942>>>>>>>>>>            Increment i
82943>>>>>>>>>>
82943>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82944>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82945>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82946>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82947>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82948>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82949>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82950>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82951>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82952>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82953>>>>>>>>>>            Increment i
82954>>>>>>>>>>
82954>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82955>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82956>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82957>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82958>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82959>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82960>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82961>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82962>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82963>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82964>>>>>>>>>>            Increment i
82965>>>>>>>>>>
82965>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82966>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82967>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82968>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82969>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82970>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82971>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82972>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82973>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82974>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82975>>>>>>>>>>            Increment i
82976>>>>>>>>>>
82976>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82977>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82978>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82979>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82980>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82981>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82982>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82983>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82984>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82985>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82986>>>>>>>>>>            Increment i
82987>>>>>>>>>>
82987>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
82988>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
82989>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82990>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82991>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82992>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82993>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82994>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82995>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82996>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82997>>>>>>>>>>            Increment i
82998>>>>>>>>>>
82998>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82999>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83000>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83001>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83002>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83003>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83004>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83005>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83006>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83007>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83008>>>>>>>>>>            Increment i
83009>>>>>>>>>>
83009>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83010>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83011>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83012>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83013>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83014>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83015>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83016>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83017>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83018>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83019>>>>>>>>>>            Increment i
83020>>>>>>>>>>
83020>>>>>>>>>>
83020>>>>>>>>>
83020>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83020>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83020>>>>>>>>>//        Increment i
83020>>>>>>>>>//
83020>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83020>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83020>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83020>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83020>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83020>>>>>>>>>
83020>>>>>>>>>        Function_Return aColumnType
83021>>>>>>>>>    End_Function
83022>>>>>>>>>
83022>>>>>>>>>    // PostgreSQL Data Types
83022>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83024>>>>>>>>>        tColumnType[] aColumnType
83024>>>>>>>>>        tColumnType[] aColumnType
83025>>>>>>>>>        Integer i
83025>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83025>>>>>>>>>>// Generated By The Database Update Framework
83025>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83025>>>>>>>>>>// Driver COLUMN DATA TYPES
83025>>>>>>>>>>//
83025>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83025>>>>>>>>>>
83025>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83026>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83027>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83028>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83029>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83030>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83031>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83032>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83033>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83034>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83035>>>>>>>>>>            Increment i
83036>>>>>>>>>>
83036>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83037>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83038>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83039>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83040>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83041>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83042>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83043>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83044>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83045>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83046>>>>>>>>>>            Increment i
83047>>>>>>>>>>
83047>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83048>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83049>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83050>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83051>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83052>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83053>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83054>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83055>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83056>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83057>>>>>>>>>>            Increment i
83058>>>>>>>>>>
83058>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83059>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83060>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83061>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83062>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83063>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83064>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83065>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83066>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83067>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83068>>>>>>>>>>            Increment i
83069>>>>>>>>>>
83069>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83070>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83071>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83072>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83073>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83074>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83075>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83076>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83077>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83078>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83079>>>>>>>>>>            Increment i
83080>>>>>>>>>>
83080>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83081>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83082>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83083>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83084>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83085>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83086>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83087>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83088>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83089>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83090>>>>>>>>>>            Increment i
83091>>>>>>>>>>
83091>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83092>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83093>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83094>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83095>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83096>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83097>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83098>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83099>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83100>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83101>>>>>>>>>>            Increment i
83102>>>>>>>>>>
83102>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83103>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83104>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83105>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83106>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83107>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83108>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83109>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83110>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83111>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83112>>>>>>>>>>            Increment i
83113>>>>>>>>>>
83113>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83114>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83115>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83116>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83117>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83118>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83119>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83120>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83121>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83122>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83123>>>>>>>>>>            Increment i
83124>>>>>>>>>>
83124>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83125>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83126>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83127>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83128>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83129>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83130>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83131>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83132>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83133>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83134>>>>>>>>>>            Increment i
83135>>>>>>>>>>
83135>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83136>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83137>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83138>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83139>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83140>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83141>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83142>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83143>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83144>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83145>>>>>>>>>>            Increment i
83146>>>>>>>>>>
83146>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83147>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83148>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83149>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83150>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83151>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83152>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83153>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83154>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83155>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83156>>>>>>>>>>            Increment i
83157>>>>>>>>>>
83157>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83158>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83159>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83160>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83161>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83162>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83163>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83164>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83165>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83166>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83167>>>>>>>>>>            Increment i
83168>>>>>>>>>>
83168>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83169>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83170>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83171>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83172>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83173>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83174>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83175>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83176>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83177>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83178>>>>>>>>>>            Increment i
83179>>>>>>>>>>
83179>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83180>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83181>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83182>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83183>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83184>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83185>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83186>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83187>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83188>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83189>>>>>>>>>>            Increment i
83190>>>>>>>>>>
83190>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83191>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83192>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83193>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83194>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83195>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83196>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83197>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83198>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83199>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83200>>>>>>>>>>            Increment i
83201>>>>>>>>>>
83201>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83202>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83203>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83204>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83205>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83206>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83207>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83208>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83209>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83210>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83211>>>>>>>>>>            Increment i
83212>>>>>>>>>>
83212>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83213>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83214>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83215>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83216>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83217>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83218>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83219>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83220>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83221>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83222>>>>>>>>>>            Increment i
83223>>>>>>>>>>
83223>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83224>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83225>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83226>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83227>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83228>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83229>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83230>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83231>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83232>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83233>>>>>>>>>>            Increment i
83234>>>>>>>>>>
83234>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83235>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83236>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83237>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83238>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83239>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83240>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83241>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83242>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83243>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83244>>>>>>>>>>            Increment i
83245>>>>>>>>>>
83245>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83246>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83247>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83248>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83249>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83250>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83251>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83252>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83253>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83254>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83255>>>>>>>>>>            Increment i
83256>>>>>>>>>>
83256>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83257>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83258>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83259>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83260>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83261>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83262>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83263>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83264>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83265>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83266>>>>>>>>>>            Increment i
83267>>>>>>>>>>
83267>>>>>>>>>>
83267>>>>>>>>>
83267>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83267>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83267>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83267>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>//
83267>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83267>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83267>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83267>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83267>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83267>>>>>>>>>//        Increment i
83267>>>>>>>>>
83267>>>>>>>>>        Function_Return aColumnType
83268>>>>>>>>>    End_Function
83269>>>>>>>>>
83269>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83269>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83271>>>>>>>>>        Integer iValue iSize iCount iStart
83271>>>>>>>>>        tColumnType[] ColumnTypeArray
83271>>>>>>>>>        tColumnType[] ColumnTypeArray
83272>>>>>>>>>        tColumnType RetvalType
83272>>>>>>>>>        tColumnType RetvalType
83272>>>>>>>>>        String sValue
83272>>>>>>>>>        Boolean bFrameworkDataFlexType
83272>>>>>>>>>
83272>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83273>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83274>>>>>>>>>
83274>>>>>>>>>        Move 0 to iStart
83275>>>>>>>>>        Move (Uppercase(sType)) to sType
83276>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83277>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83279>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83280>>>>>>>>>            Function_Return RetvalType
83281>>>>>>>>>        End
83281>>>>>>>>>>
83281>>>>>>>>>
83281>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83282>>>>>>>>>
83282>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83283>>>>>>>>>        Decrement iSize
83284>>>>>>>>>
83284>>>>>>>>>        For iCount from iStart to iSize
83290>>>>>>>>>>
83290>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
83291>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
83292>>>>>>>>>            If (bIntegerInputType = True) Begin
83294>>>>>>>>>                If (iValue = iType) Begin
83296>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83297>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83298>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83299>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83300>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83301>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83302>>>>>>>>>                    Move iSize to iCount // We're done!
83303>>>>>>>>>                End
83303>>>>>>>>>>
83303>>>>>>>>>            End
83303>>>>>>>>>>
83303>>>>>>>>>            Else Begin
83304>>>>>>>>>                Move (Uppercase(sValue)) to sValue
83305>>>>>>>>>                If (sValue = sType) Begin
83307>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
83308>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
83309>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83310>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83311>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83312>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83313>>>>>>>>>                    Move iSize to iCount // We're done!
83314>>>>>>>>>                End
83314>>>>>>>>>>
83314>>>>>>>>>            End
83314>>>>>>>>>>
83314>>>>>>>>>        Loop
83315>>>>>>>>>>
83315>>>>>>>>>
83315>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
83315>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
83315>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
83317>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83318>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
83319>>>>>>>>>            Decrement iSize
83320>>>>>>>>>
83320>>>>>>>>>            For iCount from iStart to iSize
83326>>>>>>>>>>
83326>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
83327>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
83328>>>>>>>>>                If (iValue = iType) Begin
83330>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83331>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83332>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83333>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83334>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83335>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83336>>>>>>>>>                    Move iSize to iCount // We're done!
83337>>>>>>>>>                End
83337>>>>>>>>>>
83337>>>>>>>>>            Loop
83338>>>>>>>>>>
83338>>>>>>>>>        End
83338>>>>>>>>>>
83338>>>>>>>>>
83338>>>>>>>>>        Function_Return RetvalType
83339>>>>>>>>>    End_Function
83340>>>>>>>>>
83340>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83340>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83342>>>>>>>>>        tColumnType[] ColumnType
83342>>>>>>>>>        tColumnType[] ColumnType
83343>>>>>>>>>
83343>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83343>>>>>>>>>        // the dbType.
83343>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83345>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83347>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83348>>>>>>>>>            End
83348>>>>>>>>>>
83348>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83350>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83351>>>>>>>>>            End
83351>>>>>>>>>>
83351>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83353>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83354>>>>>>>>>            End
83354>>>>>>>>>>
83354>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83356>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83357>>>>>>>>>            End
83357>>>>>>>>>>
83357>>>>>>>>>        End
83357>>>>>>>>>>
83357>>>>>>>>>
83357>>>>>>>>>        Case Begin
83357>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83359>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83360>>>>>>>>>                Case Break
83361>>>>>>>>>
83361>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83364>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83365>>>>>>>>>                Case Break
83366>>>>>>>>>
83366>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83369>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83370>>>>>>>>>                Case Break
83371>>>>>>>>>        Case End
83371>>>>>>>>>
83371>>>>>>>>>        Function_Return ColumnType
83372>>>>>>>>>    End_Function
83373>>>>>>>>>
83373>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83373>>>>>>>>>    // are mapped to a DUF data type.
83373>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83375>>>>>>>>>        tColumnType ColumnType
83375>>>>>>>>>        tColumnType ColumnType
83375>>>>>>>>>        String sDataType
83375>>>>>>>>>        Integer iDriverID iCount
83375>>>>>>>>>
83375>>>>>>>>>        Move 0 to iCount
83376>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83377>>>>>>>>>
83377>>>>>>>>>        Case Begin
83377>>>>>>>>>            // DF_ASCII
83377>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83379>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83381>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83384>>>>>>>>>                End
83384>>>>>>>>>>
83384>>>>>>>>>                Else Begin
83385>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83388>>>>>>>>>                End
83388>>>>>>>>>>
83388>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83389>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83390>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83391>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83392>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83393>>>>>>>>>                Case Break
83394>>>>>>>>>
83394>>>>>>>>>            // DF_BINARY
83394>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83397>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83399>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83402>>>>>>>>>                End
83402>>>>>>>>>>
83402>>>>>>>>>                Else Begin
83403>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83406>>>>>>>>>                End
83406>>>>>>>>>>
83406>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83407>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83408>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83409>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83410>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83411>>>>>>>>>                Case Break
83412>>>>>>>>>
83412>>>>>>>>>            // DF_DATE
83412>>>>>>>>>            Case (iType = DF_DATE_DUF)
83415>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83417>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83420>>>>>>>>>                End
83420>>>>>>>>>>
83420>>>>>>>>>                Else Begin
83421>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83424>>>>>>>>>                End
83424>>>>>>>>>>
83424>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83425>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83426>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83427>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83428>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83429>>>>>>>>>                Case Break
83430>>>>>>>>>
83430>>>>>>>>>            // DF_DATETIME
83430>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83433>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83435>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83438>>>>>>>>>                End
83438>>>>>>>>>>
83438>>>>>>>>>                Else Begin
83439>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83442>>>>>>>>>                End
83442>>>>>>>>>>
83442>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83443>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83444>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83445>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83446>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83447>>>>>>>>>                Case Break
83448>>>>>>>>>
83448>>>>>>>>>            // DF_NUMERIC
83448>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83448>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83448>>>>>>>>>            // we make them here all "Numeric"...
83448>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83448>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83448>>>>>>>>>            // End
83448>>>>>>>>>            // Else Begin
83448>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83448>>>>>>>>>            // End
83448>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83448>>>>>>>>>            Case (iType = DF_BCD_DUF)
83451>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83452>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83453>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83454>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83455>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83456>>>>>>>>>                Case Break
83457>>>>>>>>>
83457>>>>>>>>>            // DF_TEXT
83457>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83460>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83462>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83465>>>>>>>>>                End
83465>>>>>>>>>>
83465>>>>>>>>>                Else Begin
83466>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83469>>>>>>>>>                End
83469>>>>>>>>>>
83469>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83470>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83471>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83472>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83473>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83474>>>>>>>>>                Case Break
83475>>>>>>>>>
83475>>>>>>>>>            Case Else
83475>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83476>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83477>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83478>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83479>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83480>>>>>>>>>
83480>>>>>>>>>        Case End
83480>>>>>>>>>
83480>>>>>>>>>        Function_Return ColumnType
83481>>>>>>>>>    End_Function
83482>>>>>>>>>
83482>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83484>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83486>>>>>>>>>        Handle hTable
83486>>>>>>>>>        Integer iIndex
83486>>>>>>>>>        String sTableName
83486>>>>>>>>>        Boolean bFlexErrs
83486>>>>>>>>>
83486>>>>>>>>>        // a) Get the exception table array the developer has specified
83486>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83487>>>>>>>>>
83487>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83487>>>>>>>>>        Repeat
83487>>>>>>>>>>
83487>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83490>>>>>>>>>            If (hTable <> 0) Begin
83492>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83495>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83496>>>>>>>>>                If (bFlexErrs = False) Begin
83498>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83500>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83501>>>>>>>>>                        If (iIndex = -1) Begin
83503>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83504>>>>>>>>>                        End
83504>>>>>>>>>>
83504>>>>>>>>>                    End
83504>>>>>>>>>>
83504>>>>>>>>>                End
83504>>>>>>>>>>
83504>>>>>>>>>            End
83504>>>>>>>>>>
83504>>>>>>>>>        Until (hTable = 0)
83506>>>>>>>>>
83506>>>>>>>>>        Move 0 to hTable
83507>>>>>>>>>
83507>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83507>>>>>>>>>        Repeat
83507>>>>>>>>>>
83507>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83510>>>>>>>>>            If (hTable > 0) Begin
83512>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83515>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83516>>>>>>>>>                If (bFlexErrs = False) Begin
83518>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83519>>>>>>>>>                    If (iIndex = -1) Begin
83521>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83522>>>>>>>>>                    End
83522>>>>>>>>>>
83522>>>>>>>>>                End
83522>>>>>>>>>>
83522>>>>>>>>>            End
83522>>>>>>>>>>
83522>>>>>>>>>        Until (hTable = 0)
83524>>>>>>>>>
83524>>>>>>>>>        Function_Return iTablesArray
83525>>>>>>>>>    End_Function
83526>>>>>>>>>
83526>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83528>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83530>>>>>>>>>        Handle hTable
83530>>>>>>>>>        Integer iIndex
83530>>>>>>>>>        String sTableName
83530>>>>>>>>>        Boolean bFlexErrs
83530>>>>>>>>>
83530>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83531>>>>>>>>>        Move 0 to hTable
83532>>>>>>>>>
83532>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83532>>>>>>>>>        Repeat
83532>>>>>>>>>>
83532>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83535>>>>>>>>>            If (hTable > 0) Begin
83537>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83540>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83541>>>>>>>>>                If (bFlexErrs = False) Begin
83543>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83544>>>>>>>>>                    If (iIndex = -1) Begin
83546>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83547>>>>>>>>>                    End
83547>>>>>>>>>>
83547>>>>>>>>>                End
83547>>>>>>>>>>
83547>>>>>>>>>            End
83547>>>>>>>>>>
83547>>>>>>>>>        Until (hTable = 0)
83549>>>>>>>>>
83549>>>>>>>>>        Function_Return iTablesArray
83550>>>>>>>>>    End_Function
83551>>>>>>>>>
83551>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83553>>>>>>>>>        tAPIColumn NewAPIColumn
83553>>>>>>>>>        tAPIColumn NewAPIColumn
83553>>>>>>>>>
83553>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83554>>>>>>>>>        Move iType      to NewAPIColumn.iType
83555>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83556>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83557>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83558>>>>>>>>>
83558>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83559>>>>>>>>>
83559>>>>>>>>>        Function_Return aCurrent
83560>>>>>>>>>    End_Function
83561>>>>>>>>>
83561>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83563>>>>>>>>>        String sRetval sFieldName
83563>>>>>>>>>        Integer iCount iSize
83563>>>>>>>>>
83563>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83564>>>>>>>>>        Decrement iSize
83565>>>>>>>>>        For iCount from 0 to iSize
83571>>>>>>>>>>
83571>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83572>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83573>>>>>>>>>        Loop
83574>>>>>>>>>>
83574>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83575>>>>>>>>>
83575>>>>>>>>>        Function_Return sRetval
83576>>>>>>>>>    End_Function
83577>>>>>>>>>
83577>>>>>>>>>    // *** Miscellaneous other functions ***
83577>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83577>>>>>>>>>    //
83577>>>>>>>>>
83577>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83577>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83579>>>>>>>>>        Integer iPerc
83579>>>>>>>>>        Number nReady nTotal
83579>>>>>>>>>
83579>>>>>>>>>        Send DoAdvance of ghoProgressBar
83580>>>>>>>>>
83580>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83582>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83583>>>>>>>>>        End
83583>>>>>>>>>>
83583>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83585>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83586>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83587>>>>>>>>>        End
83587>>>>>>>>>>
83587>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83589>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83590>>>>>>>>>        End
83590>>>>>>>>>>
83590>>>>>>>>>
83590>>>>>>>>>        Case Begin
83590>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83592>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83593>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83594>>>>>>>>>                Case Break
83595>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83598>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83599>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83600>>>>>>>>>                Case Break
83601>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83604>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83605>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83606>>>>>>>>>                Case Break
83607>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83610>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83611>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83612>>>>>>>>>                Case Break
83613>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83616>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83617>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83618>>>>>>>>>                Case Break
83619>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83622>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83623>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83624>>>>>>>>>                Case Break
83625>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83628>>>>>>>>>                Send None
83629>>>>>>>>>                Case Break
83630>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83633>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83634>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83635>>>>>>>>>                Case Break
83636>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83639>>>>>>>>>                //*** Interpret numbers
83639>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83640>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83641>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83642>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83643>>>>>>>>>                Case Break
83644>>>>>>>>>            Case Else
83644>>>>>>>>>                Set Message_Text to ""
83645>>>>>>>>>                Set Action_Text  to ""
83646>>>>>>>>>        Case End
83646>>>>>>>>>
83646>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83647>>>>>>>>>        Function_Return False
83648>>>>>>>>>    End_Function
83649>>>>>>>>>
83649>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83649>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83651>>>>>>>>>        Function_Return False
83652>>>>>>>>>    End_Function
83653>>>>>>>>>
83653>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83653>>>>>>>>>    //
83653>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83653>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83653>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83653>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83653>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83653>>>>>>>>>    //   ALTER TABLE MyTable
83653>>>>>>>>>    //       REBUILD
83653>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83655>>>>>>>>>        Boolean bOK
83655>>>>>>>>>
83655>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83657>>>>>>>>>            Function_Return False
83658>>>>>>>>>        End
83658>>>>>>>>>>
83658>>>>>>>>>
83658>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83658>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83659>>>>>>>>>
83659>>>>>>>>>        Function_Return (bOK = True)
83660>>>>>>>>>    End_Function
83661>>>>>>>>>
83661>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83661>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83661>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83661>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83661>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83661>>>>>>>>>    //   ALTER TABLE MyTable
83661>>>>>>>>>    //       REBUILD
83661>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83663>>>>>>>>>        tSQLScriptArray SQLScriptArray
83663>>>>>>>>>        tSQLScriptArray SQLScriptArray
83663>>>>>>>>>        String sDriverID
83663>>>>>>>>>        Boolean bOK
83663>>>>>>>>>        Integer iSize iCount
83663>>>>>>>>>
83663>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83665>>>>>>>>>            Function_Return False
83666>>>>>>>>>        End
83666>>>>>>>>>>
83666>>>>>>>>>
83666>>>>>>>>>        Get psDriverID to sDriverID
83667>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83668>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83670>>>>>>>>>            Function_Return False
83671>>>>>>>>>        End
83671>>>>>>>>>>
83671>>>>>>>>>
83671>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83672>>>>>>>>>        Decrement iSize
83673>>>>>>>>>
83673>>>>>>>>>        For iCount from 0 to iSize
83679>>>>>>>>>>
83679>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83681>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83682>>>>>>>>>            End
83682>>>>>>>>>>
83682>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83684>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83685>>>>>>>>>            End
83685>>>>>>>>>>
83685>>>>>>>>>        Loop
83686>>>>>>>>>>
83686>>>>>>>>>
83686>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83687>>>>>>>>>
83687>>>>>>>>>        Function_Return (bOK = True)
83688>>>>>>>>>    End_Function
83689>>>>>>>>>
83689>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83689>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83689>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83689>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83691>>>>>>>>>        Integer iChannel iArgumentSize iCount
83691>>>>>>>>>        Number nByteCount
83691>>>>>>>>>        String sSQLScript
83691>>>>>>>>>        tSQLScriptArray SqlScriptArray
83691>>>>>>>>>        tSQLScriptArray SqlScriptArray
83691>>>>>>>>>        UChar[] uCharData
83692>>>>>>>>>
83692>>>>>>>>>        Move False to Err
83693>>>>>>>>>        Get Seq_New_Channel to iChannel
83694>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83696>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83697>>>>>>>>>>
83697>>>>>>>>>            Move True to SqlScriptArray.bError
83698>>>>>>>>>            Function_Return SqlScriptArray
83699>>>>>>>>>        End
83699>>>>>>>>>>
83699>>>>>>>>>
83699>>>>>>>>>        // First decide the size of the script
83699>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83701>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83703>>>>>>>>>        Close_Input channel iChannel
83705>>>>>>>>>
83705>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83706>>>>>>>>>        If (nByteCount  < 1) Begin
83708>>>>>>>>>            Send Seq_Release_Channel iChannel
83709>>>>>>>>>            Move True to SqlScriptArray.bError
83710>>>>>>>>>            Function_Return SqlScriptArray
83711>>>>>>>>>        End
83711>>>>>>>>>>
83711>>>>>>>>>
83711>>>>>>>>>        // If necessary change the string argument_size
83711>>>>>>>>>        // Read the script file from memory line-by-line
83711>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83713>>>>>>>>>            Move 0 to iCount
83714>>>>>>>>>            Repeat
83714>>>>>>>>>>
83714>>>>>>>>>                Readln channel iChannel sSQLScript
83716>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83717>>>>>>>>>                Increment iCount
83718>>>>>>>>>            Until (SeqEof = True)
83720>>>>>>>>>        Close_Input channel iChannel
83722>>>>>>>>>        Send Seq_Release_Channel iChannel
83723>>>>>>>>>
83723>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83723>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83724>>>>>>>>>
83724>>>>>>>>>        Function_Return SqlScriptArray
83725>>>>>>>>>    End_Function
83726>>>>>>>>>
83726>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83728>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83728>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83728>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83728>>>>>>>>>        String[] sMsg aSQLQueryMessages
83730>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83730>>>>>>>>>        TimeSpan tsQuery
83730>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83730>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83730>>>>>>>>>        tSQLConnection SQLConnection
83730>>>>>>>>>        tSQLConnection SQLConnection
83730>>>>>>>>>        Boolean bShowProgress
83730>>>>>>>>>
83730>>>>>>>>>        If (num_arguments > 4) Begin
83732>>>>>>>>>            Move bShowProgr to bShowProgress
83733>>>>>>>>>        End
83733>>>>>>>>>>
83733>>>>>>>>>        Get phoSQLManager to hoSql
83734>>>>>>>>>
83734>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83735>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83735>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83735>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83735>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83735>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83735>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83735>>>>>>>>>        Get piChunkMax to iChunkMax
83736>>>>>>>>>        Move 0 to iChunkCounter
83737>>>>>>>>>        Move "" to sStmt
83738>>>>>>>>>
83738>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83739>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83740>>>>>>>>>
83740>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83741>>>>>>>>>
83741>>>>>>>>>        Get phoSQLManager  to hoSQL
83742>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83744>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83746>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83747>>>>>>>>>                If (iPos > 0) Begin
83749>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83750>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83751>>>>>>>>>                End
83751>>>>>>>>>>
83751>>>>>>>>>            End
83751>>>>>>>>>>
83751>>>>>>>>>        End
83751>>>>>>>>>>
83751>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83752>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83753>>>>>>>>>
83753>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83755>>>>>>>>>            Move False to Err
83756>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83757>>>>>>>>>            If (hoStmt <> 0) Begin
83759>>>>>>>>>
83759>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83759>>>>>>>>>                If (bCreateScriptFile = True) Begin
83761>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83762>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83763>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83764>>>>>>>>>                    Get Seq_New_Channel to iOut
83765>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83767>>>>>>>>>                        Direct_Output channel iOut sExportFile
83769>>>>>>>>>                    End
83769>>>>>>>>>>
83769>>>>>>>>>                End
83769>>>>>>>>>>
83769>>>>>>>>>
83769>>>>>>>>>                // Record starting date/time stamp
83769>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83770>>>>>>>>>                // Turn on error handling if enabled
83770>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83772>>>>>>>>>                    Set pbSqlError to False
83773>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83774>>>>>>>>>                    Move Error_Object_Id to hoError
83775>>>>>>>>>                    Move Self to Error_Object_Id
83776>>>>>>>>>                End
83776>>>>>>>>>>
83776>>>>>>>>>
83776>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83777>>>>>>>>>                Decrement iRows
83778>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83780>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83781>>>>>>>>>                End
83781>>>>>>>>>>
83781>>>>>>>>>
83781>>>>>>>>>                for iCount from 0 to iRows
83787>>>>>>>>>>
83787>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83788>>>>>>>>>
83788>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83790>>>>>>>>>                        If (sSQLVal <> "") Begin
83792>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83793>>>>>>>>>                        End
83793>>>>>>>>>>
83793>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83794>>>>>>>>>                    End
83794>>>>>>>>>>
83794>>>>>>>>>
83794>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83794>>>>>>>>>                    // or if at the very end of the script.
83794>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83796>>>>>>>>>
83796>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83796>>>>>>>>>                        // instead of all in one go.
83796>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83797>>>>>>>>>
83797>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83799>>>>>>>>>                            Write channel iOut sStmt
83801>>>>>>>>>                        End
83801>>>>>>>>>>
83801>>>>>>>>>                        Move "" to sStmt
83802>>>>>>>>>                        Move 0 to iChunkCounter
83803>>>>>>>>>                    End
83803>>>>>>>>>>
83803>>>>>>>>>                    Increment iChunkCounter
83804>>>>>>>>>                Loop
83805>>>>>>>>>>
83805>>>>>>>>>
83805>>>>>>>>>                Repeat
83805>>>>>>>>>>
83805>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83807>>>>>>>>>                        Move hoError to Error_Object_Id
83808>>>>>>>>>                    End
83808>>>>>>>>>>
83808>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83809>>>>>>>>>
83809>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83810>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83811>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83812>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83813>>>>>>>>>                    Set piRows    to iRows
83814>>>>>>>>>                    Set piRowType to iRowType
83815>>>>>>>>>
83815>>>>>>>>>                    If (iMsgs <> 0) Begin
83817>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83819>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83820>>>>>>>>>                        End
83820>>>>>>>>>>
83820>>>>>>>>>                        for i from 1 to iMsgs
83826>>>>>>>>>>
83826>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83827>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83828>>>>>>>>>                            If (bShowProgress = True) Begin
83830>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83832>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83833>>>>>>>>>                                End
83833>>>>>>>>>>
83833>>>>>>>>>                                Else Begin
83834>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83836>>>>>>>>>                                End
83836>>>>>>>>>>
83836>>>>>>>>>                            End
83836>>>>>>>>>>
83836>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83837>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83838>>>>>>>>>                        Loop
83839>>>>>>>>>>
83839>>>>>>>>>
83839>>>>>>>>>
83839>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83841>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83842>>>>>>>>>                        End
83842>>>>>>>>>>
83842>>>>>>>>>                        Set paQueryMessages to sMsg
83843>>>>>>>>>                    End
83843>>>>>>>>>>
83843>>>>>>>>>
83843>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83844>>>>>>>>>                Until (iNextSet = 0)
83846>>>>>>>>>
83846>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83847>>>>>>>>>            End
83847>>>>>>>>>>
83847>>>>>>>>>
83847>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83848>>>>>>>>>            Set ptsQueryExec to tsQuery
83849>>>>>>>>>            Send SqlClose of hoStmt
83850>>>>>>>>>
83850>>>>>>>>>            If (bCreateScriptFile = True) Begin
83852>>>>>>>>>                Close_Output channel iOut
83854>>>>>>>>>                Send Seq_Release_Channel iOut
83855>>>>>>>>>            End
83855>>>>>>>>>>
83855>>>>>>>>>        End
83855>>>>>>>>>>
83855>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83856>>>>>>>>>
83856>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83857>>>>>>>>>    End_Function
83858>>>>>>>>>
83858>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83860>>>>>>>>>        tSQLScriptArray SQLScriptArray
83860>>>>>>>>>        tSQLScriptArray SQLScriptArray
83860>>>>>>>>>        String sDriverID sCollation
83860>>>>>>>>>        Boolean bOK
83860>>>>>>>>>        Integer iSize iCount
83860>>>>>>>>>
83860>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83862>>>>>>>>>            Function_Return False
83863>>>>>>>>>        End
83863>>>>>>>>>>
83863>>>>>>>>>
83863>>>>>>>>>        Get psDriverID  to sDriverID
83864>>>>>>>>>        Get psCollation to sCollation
83865>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83866>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83868>>>>>>>>>            Function_Return False
83869>>>>>>>>>        End
83869>>>>>>>>>>
83869>>>>>>>>>
83869>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83870>>>>>>>>>        Decrement iSize
83871>>>>>>>>>
83871>>>>>>>>>        For iCount from 0 to iSize
83877>>>>>>>>>>
83877>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83879>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83880>>>>>>>>>            End
83880>>>>>>>>>>
83880>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83882>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83883>>>>>>>>>            End
83883>>>>>>>>>>
83883>>>>>>>>>        Loop
83884>>>>>>>>>>
83884>>>>>>>>>
83884>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83885>>>>>>>>>
83885>>>>>>>>>        Function_Return (bOK = True)
83886>>>>>>>>>    End_Function
83887>>>>>>>>>
83887>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83889>>>>>>>>>        tSQLScriptArray SQLScriptArray
83889>>>>>>>>>        tSQLScriptArray SQLScriptArray
83889>>>>>>>>>        String sDriverID sCollation
83889>>>>>>>>>        Boolean bOK
83889>>>>>>>>>        Integer iSize iCount
83889>>>>>>>>>
83889>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83891>>>>>>>>>            Function_Return False
83892>>>>>>>>>        End
83892>>>>>>>>>>
83892>>>>>>>>>
83892>>>>>>>>>        Get psDriverID  to sDriverID
83893>>>>>>>>>        Get psCollation to sCollation
83894>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83895>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83897>>>>>>>>>            Function_Return False
83898>>>>>>>>>        End
83898>>>>>>>>>>
83898>>>>>>>>>
83898>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83899>>>>>>>>>        Decrement iSize
83900>>>>>>>>>
83900>>>>>>>>>        For iCount from 0 to iSize
83906>>>>>>>>>>
83906>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83908>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83909>>>>>>>>>            End
83909>>>>>>>>>>
83909>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83911>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83912>>>>>>>>>            End
83912>>>>>>>>>>
83912>>>>>>>>>        Loop
83913>>>>>>>>>>
83913>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83913>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83914>>>>>>>>>
83914>>>>>>>>>        Function_Return (bOK = True)
83915>>>>>>>>>    End_Function
83916>>>>>>>>>
83916>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83918>>>>>>>>>        Integer iMax iPos
83918>>>>>>>>>        String sName
83918>>>>>>>>>
83918>>>>>>>>>        Move (Lowercase(sField)) to sField
83919>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83922>>>>>>>>>        For iPos from 0 to iMax
83928>>>>>>>>>>
83928>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83931>>>>>>>>>            Move (Lowercase(sName)) to sName
83932>>>>>>>>>            If (sName = sField) Begin
83934>>>>>>>>>                Function_Return iPos
83935>>>>>>>>>            End
83935>>>>>>>>>>
83935>>>>>>>>>        Loop
83936>>>>>>>>>>
83936>>>>>>>>>        Function_Return -1
83937>>>>>>>>>    End_Function
83938>>>>>>>>>
83938>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
83938>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
83938>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83938>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
83938>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83940>>>>>>>>>        String sID sConnString
83940>>>>>>>>>        Integer iDriver iNumConn iCount
83940>>>>>>>>>        Handle hoCLI
83940>>>>>>>>>        Boolean bOK
83940>>>>>>>>>
83940>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83941>>>>>>>>>        If (bOK = False) Begin
83943>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83944>>>>>>>>>>
83944>>>>>>>>>            Function_Return False
83945>>>>>>>>>        End
83945>>>>>>>>>>
83945>>>>>>>>>
83945>>>>>>>>>        Move False to bOK
83946>>>>>>>>>        Get phoCLIHandler to hoCLI
83947>>>>>>>>>        If (hoCLI <> 0) Begin
83949>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83950>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83951>>>>>>>>>
83951>>>>>>>>>            // If driver not loaded; load it.
83951>>>>>>>>>            If (iDriver = 0) Begin
83953>>>>>>>>>                Load_Driver sDriverID
83954>>>>>>>>>                Get DriverIndex sDriverID to iDriver
83955>>>>>>>>>            End
83955>>>>>>>>>>
83955>>>>>>>>>            If (iDriver <> 0) Begin
83957>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83960>>>>>>>>>                Decrement iNumConn
83961>>>>>>>>>                For iCount from 0 to iNumConn
83967>>>>>>>>>>
83967>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83970>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83973>>>>>>>>>                    If (sID = sConnectionID) Begin
83975>>>>>>>>>                        Move True to bOK
83976>>>>>>>>>                    End
83976>>>>>>>>>>
83976>>>>>>>>>                Loop
83977>>>>>>>>>>
83977>>>>>>>>>            End
83977>>>>>>>>>>
83977>>>>>>>>>        End
83977>>>>>>>>>>
83977>>>>>>>>>
83977>>>>>>>>>        Function_Return bOK
83978>>>>>>>>>    End_Function
83979>>>>>>>>>
83979>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83981>>>>>>>>>        Boolean bOK
83981>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
83982>>>>>>>>>        Function_Return bOK
83983>>>>>>>>>    End_Function
83984>>>>>>>>>
83984>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
83986>>>>>>>>>        Integer iDriverIndex
83986>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
83987>>>>>>>>>        Function_Return (iDriverIndex <> 0)
83988>>>>>>>>>    End_Function
83989>>>>>>>>>
83989>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83989>>>>>>>>>    // attempt to load the driver.
83989>>>>>>>>>    // Returns true if the passed driver is SQL based.
83989>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83991>>>>>>>>>        Boolean bOK
83991>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83992>>>>>>>>>        Function_Return bOK
83993>>>>>>>>>    End_Function
83994>>>>>>>>>
83994>>>>>>>>>    // *** Error Handler ***
83994>>>>>>>>>    //
83994>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
83994>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
83994>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
83996>>>>>>>>>        Integer iSize iErrorMode
83996>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83996>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83996>>>>>>>>>
83996>>>>>>>>>        If (pbProcessingError(Self)) Begin
83998>>>>>>>>>            Procedure_Return
83999>>>>>>>>>        End
83999>>>>>>>>>>
83999>>>>>>>>>
83999>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84000>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84002>>>>>>>>>            Procedure_Return
84003>>>>>>>>>        End
84003>>>>>>>>>>
84003>>>>>>>>>
84003>>>>>>>>>        Set pbProcessingError to True
84004>>>>>>>>>        Set pbSqlError to True
84005>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84006>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84007>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84008>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84009>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84010>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84011>>>>>>>>>        Set pbProcessingError to False
84012>>>>>>>>>    End_Procedure
84013>>>>>>>>>
84013>>>>>>>>>    // *** Miscellanous Helper Functions ***
84013>>>>>>>>>    //
84013>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
84013>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
84013>>>>>>>>>    Function _TableNameOnly String sName Returns String
84015>>>>>>>>>        String sPath sExt
84015>>>>>>>>>
84015>>>>>>>>>        Get ParseFolderName sName to sPath
84016>>>>>>>>>        If (sPath <> "") Begin
84018>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
84019>>>>>>>>>        End
84019>>>>>>>>>>
84019>>>>>>>>>        Get ParseFileExtension sName to sExt
84020>>>>>>>>>        If (sExt <> "") Begin
84022>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
84023>>>>>>>>>        End
84023>>>>>>>>>>
84023>>>>>>>>>
84023>>>>>>>>>        Function_Return sName
84024>>>>>>>>>    End_Function
84025>>>>>>>>>
84025>>>>>>>>>    // Removes any prefix to a table name.
84025>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84025>>>>>>>>>    //         dbo.mytable returns mytable
84025>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84027>>>>>>>>>        Integer iPos
84027>>>>>>>>>
84027>>>>>>>>>        Move (Pos(":", sName)) to iPos
84028>>>>>>>>>        If (iPos <> 0) Begin
84030>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84031>>>>>>>>>        End
84031>>>>>>>>>>
84031>>>>>>>>>        Move (Pos(".", sName)) to iPos
84032>>>>>>>>>        If (iPos <> 0) Begin
84034>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84035>>>>>>>>>        End
84035>>>>>>>>>>
84035>>>>>>>>>
84035>>>>>>>>>        Function_Return sName
84036>>>>>>>>>    End_Function
84037>>>>>>>>>
84037>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84037>>>>>>>>>    // The returned path always ends with a "\"
84037>>>>>>>>>    Function psDataPathFirstPart Returns String
84039>>>>>>>>>        String sDataPath
84039>>>>>>>>>        Integer iCount
84039>>>>>>>>>
84039>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84040>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84041>>>>>>>>>        If (iCount > 1) Begin
84043>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84044>>>>>>>>>        End
84044>>>>>>>>>>
84044>>>>>>>>>        If (sDataPath <> "") Begin
84046>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84047>>>>>>>>>        End
84047>>>>>>>>>>
84047>>>>>>>>>
84047>>>>>>>>>        Function_Return sDataPath
84048>>>>>>>>>    End_Function
84049>>>>>>>>>
84049>>>>>>>>>    Function psLogTextFileWithPath Returns String
84051>>>>>>>>>        String sFileName
84051>>>>>>>>>        Handle hoLogFile
84051>>>>>>>>>        Get phoLogFile to hoLogFile
84052>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84053>>>>>>>>>        Function_Return sFileName
84054>>>>>>>>>    End_Function
84055>>>>>>>>>
84055>>>>>>>>>    Function phoLogFile Returns Handle
84057>>>>>>>>>        Handle hoLogFile   
84057>>>>>>>>>        Boolean bErr
84057>>>>>>>>>        
84057>>>>>>>>>        Move Err to bErr
84058>>>>>>>>>        Move 0 to hoLogFile
84059>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84060>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84061>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84063>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84064>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84065>>>>>>>>>        Move bErr to Err
84066>>>>>>>>>        
84066>>>>>>>>>        Function_Return hoLogFile
84067>>>>>>>>>    End_Function
84068>>>>>>>>>
84068>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84070>>>>>>>>>        Number nCurrentVersionUpdate
84070>>>>>>>>>
84070>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84071>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84073>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84074>>>>>>>>>
84074>>>>>>>>>        Function_Return nCurrentVersionUpdate
84075>>>>>>>>>    End_Function
84076>>>>>>>>>
84076>>>>>>>>>    Procedure LogError String sText Boolean bError
84078>>>>>>>>>        Handle hoLogFile
84078>>>>>>>>>        Number nCurrentVersionUpdate
84078>>>>>>>>>
84078>>>>>>>>>        Get phoLogFile to hoLogFile
84079>>>>>>>>>        If (hoLogFile = 0) Begin
84081>>>>>>>>>            Procedure_Return
84082>>>>>>>>>        End
84082>>>>>>>>>>
84082>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84083>>>>>>>>>
84083>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84084>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84085>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84086>>>>>>>>>    End_Procedure
84087>>>>>>>>>
84087>>>>>>>>>    Function pbContinueOnError Returns Boolean
84089>>>>>>>>>        Boolean bContinueOnError
84089>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84091>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84092>>>>>>>>>        End
84092>>>>>>>>>>
84092>>>>>>>>>        Function_Return bContinueOnError
84093>>>>>>>>>    End_Function
84094>>>>>>>>>
84094>>>>>>>>>
84094>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84096>>>>>>>>>        Integer iChIn iChOut // iCount
84096>>>>>>>>>        Boolean bExists
84096>>>>>>>>>        String sExistingColumn
84096>>>>>>>>>
84096>>>>>>>>>        Move False to bExists
84097>>>>>>>>>        Get Seq_New_Channel to iChIn
84098>>>>>>>>>        Get Seq_New_Channel to iChOut
84099>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84101>>>>>>>>>            Function_Return True
84102>>>>>>>>>        End
84102>>>>>>>>>>
84102>>>>>>>>>
84102>>>>>>>>>        Move False to Err
84103>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84103>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84105>>>>>>>>>        While (not(SeqEof))
84109>>>>>>>>>            Readln channel iChIn sExistingColumn
84111>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84113>>>>>>>>>                Move True to bExists
84114>>>>>>>>>            End
84114>>>>>>>>>>
84114>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84116>>>>>>>>>                Move True to SeqEof
84117>>>>>>>>>            End
84117>>>>>>>>>>
84117>>>>>>>>>        Loop
84118>>>>>>>>>>
84118>>>>>>>>>        Close_Input channel iChIn
84120>>>>>>>>>        Send Seq_Release_Channel iChIn
84121>>>>>>>>>
84121>>>>>>>>>        If (bExists = False) Begin
84123>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84125>>>>>>>>>            Writeln channel iChOut sColumnName
84128>>>>>>>>>            Close_Output channel iChOut
84130>>>>>>>>>            Send Seq_Release_Channel iChOut
84131>>>>>>>>>        End
84131>>>>>>>>>>
84131>>>>>>>>>
84131>>>>>>>>>        Function_Return (Err = False)
84132>>>>>>>>>    End_Function
84133>>>>>>>>>
84133>>>>>>>>>    // Changes source code files.
84133>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84133>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84133>>>>>>>>>    // to use a Connection ID.
84133>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84133>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84133>>>>>>>>>    // Returns True if no errors occured.
84133>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84135>>>>>>>>>        Integer iCh iRow iItems iCount
84135>>>>>>>>>        String sValue sRow
84135>>>>>>>>>        String[] sFileArray
84136>>>>>>>>>        Boolean bExists bIsActive
84136>>>>>>>>>
84136>>>>>>>>>        Move False to Err
84137>>>>>>>>>        Move 0 to iRow
84138>>>>>>>>>
84138>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84140>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84141>>>>>>>>>        End
84141>>>>>>>>>>
84141>>>>>>>>>
84141>>>>>>>>>        Get vFilePathExists sFileName to bExists
84142>>>>>>>>>        If (bExists = False) Begin
84144>>>>>>>>>            If (bShowResult = True) Begin
84146>>>>>>>>>                If (bIsActive = True) Begin
84148>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84149>>>>>>>>>                End
84149>>>>>>>>>>
84149>>>>>>>>>                Else Begin
84150>>>>>>>>>                    Showln "File does not exist: " sFileName
84153>>>>>>>>>                End
84153>>>>>>>>>>
84153>>>>>>>>>            End
84153>>>>>>>>>>
84153>>>>>>>>>            Function_Return False
84154>>>>>>>>>        End
84154>>>>>>>>>>
84154>>>>>>>>>
84154>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84155>>>>>>>>>        If (iCh < 1) Begin
84157>>>>>>>>>            Function_Return False
84158>>>>>>>>>        End
84158>>>>>>>>>>
84158>>>>>>>>>
84158>>>>>>>>>        If (bShowResult = True) Begin
84160>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84162>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84163>>>>>>>>>                If (bIsActive = True) Begin
84165>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84166>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84167>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84168>>>>>>>>>                End
84168>>>>>>>>>>
84168>>>>>>>>>            End
84168>>>>>>>>>>
84168>>>>>>>>>            Else Begin
84169>>>>>>>>>                Showln ""
84171>>>>>>>>>                Showln "sFileName = " sFileName
84174>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84179>>>>>>>>>            End
84179>>>>>>>>>>
84179>>>>>>>>>        End
84179>>>>>>>>>>
84179>>>>>>>>>
84179>>>>>>>>>        While (not(SeqEof))
84183>>>>>>>>>            Readln channel iCh sRow
84185>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84187>>>>>>>>>//                If (bShowResult = True) Begin
84187>>>>>>>>>//                    If (bIsActive = True) Begin
84187>>>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
84187>>>>>>>>>//                    End
84187>>>>>>>>>//                    Else Begin
84187>>>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
84187>>>>>>>>>//                    End
84187>>>>>>>>>//                End
84187>>>>>>>>>                // Change the whole line to the new connection id:
84187>>>>>>>>>                Move sChangeTo to sRow
84188>>>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
84188>>>>>>>>>            End
84188>>>>>>>>>>
84188>>>>>>>>>            Move sRow to sFileArray[iRow]
84189>>>>>>>>>            Increment iRow
84190>>>>>>>>>        Loop
84191>>>>>>>>>>
84191>>>>>>>>>        Send Seq_Close_Channel iCh
84192>>>>>>>>>
84192>>>>>>>>>        Sleep 1 // Wait for Windows to close the file
84193>>>>>>>>>
84193>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84194>>>>>>>>>        If (iCh < 1) Begin
84196>>>>>>>>>            Function_Return False
84197>>>>>>>>>        End
84197>>>>>>>>>>
84197>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84198>>>>>>>>>        Decrement iItems
84199>>>>>>>>>
84199>>>>>>>>>        for iCount from 0 to iItems
84205>>>>>>>>>>
84205>>>>>>>>>            Move sFileArray[iCount] to sValue
84206>>>>>>>>>            Writeln channel iCh sValue
84209>>>>>>>>>        Loop
84210>>>>>>>>>>
84210>>>>>>>>>        Send Seq_Close_Channel iCh
84211>>>>>>>>>
84211>>>>>>>>>        Function_Return (Err = False)
84212>>>>>>>>>    End_Function
84213>>>>>>>>>
84213>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84213>>>>>>>>>    // and opens it in "notepad.exe".
84213>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84213>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84213>>>>>>>>>    Procedure _UtilShowErrorList
84215>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84215>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84215>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84215>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84215>>>>>>>>>
84215>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84216>>>>>>>>>        Get vFolderFormat sPath to sPath
84217>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84218>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84219>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84220>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84221>>>>>>>>>            If (iRows > 0) Begin
84223>>>>>>>>>                Decrement iRows
84224>>>>>>>>>                for iCount from 0 to iRows
84230>>>>>>>>>>
84230>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84231>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84232>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84233>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84239>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84243>>>>>>>>>                Loop
84244>>>>>>>>>>
84244>>>>>>>>>            End
84244>>>>>>>>>>
84244>>>>>>>>>        Send Seq_Close_Channel iCh
84245>>>>>>>>>
84245>>>>>>>>>        If (iRows > 0) Begin
84247>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84248>>>>>>>>>        End
84248>>>>>>>>>>
84248>>>>>>>>>    End_Procedure
84249>>>>>>>>>
84249>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84249>>>>>>>>>    // and the table needs to exist as an SQL table.
84249>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84251>>>>>>>>>        String sRootName sDriverID
84251>>>>>>>>>        Boolean bIsSQL
84251>>>>>>>>>
84251>>>>>>>>>        Move False to bIsSQL
84252>>>>>>>>>        If (hTable > 0) Begin
84254>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84257>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84258>>>>>>>>>            If (bIsSQL = True) Begin
84260>>>>>>>>>                Get psDriverID to sDriverID
84261>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84262>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84263>>>>>>>>>            End
84263>>>>>>>>>>
84263>>>>>>>>>        End
84263>>>>>>>>>>
84263>>>>>>>>>
84263>>>>>>>>>        Function_Return bIsSQL
84264>>>>>>>>>    End_Function
84265>>>>>>>>>
84265>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84267>>>>>>>>>        Boolean bIsSQL
84267>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84268>>>>>>>>>        Function_Return bIsSQL
84269>>>>>>>>>    End_Function
84270>>>>>>>>>
84270>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84270>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84272>>>>>>>>>        String sDatabase sSchema sVal
84272>>>>>>>>>        Boolean bExists
84272>>>>>>>>>        String[] sTablesArray
84273>>>>>>>>>        Integer iSize iCount
84273>>>>>>>>>
84273>>>>>>>>>        Move False to bExists
84274>>>>>>>>>        Get psDatabase to sDatabase
84275>>>>>>>>>        Get psSchema   to sSchema
84276>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84277>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
84278>>>>>>>>>        Decrement iSize
84279>>>>>>>>>        for iCount from 0 to iSize
84285>>>>>>>>>>
84285>>>>>>>>>            Move sTablesArray[iCount] to sVal
84286>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
84288>>>>>>>>>                Move True to bExists
84289>>>>>>>>>                Move iSize to iCount // We're done!
84290>>>>>>>>>            End
84290>>>>>>>>>>
84290>>>>>>>>>        Loop
84291>>>>>>>>>>
84291>>>>>>>>>
84291>>>>>>>>>        Function_Return bExists
84292>>>>>>>>>    End_Function
84293>>>>>>>>>
84293>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84293>>>>>>>>>    // that the embedded .dat file exists on disk.
84293>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84295>>>>>>>>>        Boolean bExists bIsEmbedded
84295>>>>>>>>>        String sDataPath sRootName
84295>>>>>>>>>
84295>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84296>>>>>>>>>        If (bExists = False) Begin
84298>>>>>>>>>            Function_Return False
84299>>>>>>>>>        End
84299>>>>>>>>>>
84299>>>>>>>>>
84299>>>>>>>>>        Move False to bIsEmbedded
84300>>>>>>>>>        If (hTable > 0) Begin
84302>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84305>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84306>>>>>>>>>        End
84306>>>>>>>>>>
84306>>>>>>>>>        If (bIsEmbedded = True) Begin
84308>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84309>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84310>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84311>>>>>>>>>        End
84311>>>>>>>>>>
84311>>>>>>>>>
84311>>>>>>>>>        Function_Return bIsEmbedded
84312>>>>>>>>>    End_Function
84313>>>>>>>>>
84313>>>>>>>>>End_Class
84314>>>>>>>
84314>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84315>>>>>>>
84315>>>>>>>    Procedure Construct_Object
84317>>>>>>>        Forward Send Construct_Object
84319>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84320>>>>>>>    End_Procedure
84321>>>>>>>
84321>>>>>>>    Procedure End_Construct_Object
84323>>>>>>>        Forward Send End_Construct_Object
84325>>>>>>>    End_Procedure
84326>>>>>>>
84326>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84326>>>>>>>    //
84326>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84326>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84328>>>>>>>        Function_Return False
84329>>>>>>>    End_Function
84330>>>>>>>
84330>>>>>>>    // Function for creating a new *Database*.
84330>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84330>>>>>>>    // Returns True if successful.
84330>>>>>>>    // ToDo: Currently only works for MS-SQL...
84330>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84332>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84332>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84332>>>>>>>        Handle hConnection hStmt hoSQLManager
84332>>>>>>>        Integer iFetchResult iDbType
84332>>>>>>>        Boolean bOK bExists
84332>>>>>>>
84332>>>>>>>        Get piDbType to iDbType
84333>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84335>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84336>>>>>>>>
84336>>>>>>>            Function_Return False
84337>>>>>>>        End
84337>>>>>>>>
84337>>>>>>>
84337>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84338>>>>>>>        If (bExists = True) Begin
84340>>>>>>>            Function_Return True
84341>>>>>>>        End
84341>>>>>>>>
84341>>>>>>>
84341>>>>>>>        Get phoSQLManager to hoSQLManager
84342>>>>>>>
84342>>>>>>>        Get psConnectionID     to sConnectionID
84343>>>>>>>        Get psConnectionString to sConnectionString
84344>>>>>>>        Move 0 to LastErr
84345>>>>>>>
84345>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84347>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84347>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84347>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84347>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84347>>>>>>>//                If (iPos > 0) Begin
84347>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84347>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84347>>>>>>>//                End
84347>>>>>>>//            End
84347>>>>>>>        End
84347>>>>>>>>
84347>>>>>>>
84347>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84348>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84349>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84350>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84352>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84353>>>>>>>>
84353>>>>>>>            Function_Return False
84354>>>>>>>        End
84354>>>>>>>>
84354>>>>>>>
84354>>>>>>>        Get SqlOpen of hConnection to hStmt
84355>>>>>>>
84355>>>>>>>        If (hStmt = 0) Begin
84357>>>>>>>            Send SqlDisconnect of hoSQLManager
84358>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84359>>>>>>>>
84359>>>>>>>            Function_Return False
84360>>>>>>>        End
84360>>>>>>>>
84360>>>>>>>
84360>>>>>>>        Get psCollation to sCollation
84361>>>>>>>
84361>>>>>>>        Case Begin
84361>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84363>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84364>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84365>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84366>>>>>>>
84366>>>>>>>                // Check if database exists
84366>>>>>>>                Send SqlExecDirect of hStmt sSQL
84367>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84368>>>>>>>                Send SqlClose of hStmt
84369>>>>>>>                Send SqlDisconnect of hConnection
84370>>>>>>>                // If database already exists we're out of here!
84370>>>>>>>                // Note that we return True as this is not an error.
84370>>>>>>>                If (iFetchResult > 0) Begin
84372>>>>>>>                    Function_Return True
84373>>>>>>>                End
84373>>>>>>>>
84373>>>>>>>                // Database doesn't exist, create it.
84373>>>>>>>                If (iFetchResult = 0) Begin
84375>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84376>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84377>>>>>>>                    If (sCollation <> "") Begin
84379>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84380>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84381>>>>>>>                    End
84381>>>>>>>>
84381>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84382>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84383>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84385>>>>>>>                        Function_Return False
84386>>>>>>>                    End
84386>>>>>>>>
84386>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84386>>>>>>>                    Sleep 1
84387>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84388>>>>>>>                End
84388>>>>>>>>
84388>>>>>>>                Case Break
84389>>>>>>>
84389>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84392>>>>>>>                // ToDo: How should this be set/checked?
84392>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84392>>>>>>>//                    Set psCollation to "utf8"
84392>>>>>>>//                End
84392>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84392>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84393>>>>>>>                Case Break
84394>>>>>>>
84394>>>>>>>            Case Else
84394>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84395>>>>>>>>
84395>>>>>>>        Case End
84395>>>>>>>
84395>>>>>>>        If (Err = False) Begin
84397>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84398>>>>>>>        End
84398>>>>>>>>
84398>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84398>>>>>>>        // the one we just created.
84398>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84400>>>>>>>            Set psDatabase to sDatabase
84401>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84401>>>>>>>            If (bPermanantly = True) Begin
84403>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84405>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84406>>>>>>>                End
84406>>>>>>>>
84406>>>>>>>            End
84406>>>>>>>>
84406>>>>>>>        End
84406>>>>>>>>
84406>>>>>>>
84406>>>>>>>        Function_Return (Err = False)
84407>>>>>>>    End_Function
84408>>>>>>>
84408>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84408>>>>>>>    // will be used.
84408>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84410>>>>>>>        Boolean bOK bExists bShowProgress bErr
84410>>>>>>>        String sStatement sDriverID
84410>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84410>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84410>>>>>>>        Integer iDbType
84410>>>>>>>
84410>>>>>>>        If (sDatabase = "") Begin
84412>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84413>>>>>>>>
84413>>>>>>>            Function_Return False
84414>>>>>>>        End
84414>>>>>>>>
84414>>>>>>>        If (sBackupName = "") Begin
84416>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84417>>>>>>>>
84417>>>>>>>            Function_Return False
84418>>>>>>>        End
84418>>>>>>>>
84418>>>>>>>
84418>>>>>>>        // Create backup-folder if it doesn't exist
84418>>>>>>>        Get vFolderExists sPath to bExists
84419>>>>>>>        If (bExists = False) Begin
84421>>>>>>>            Get vCreateDirectory sPath to bErr
84422>>>>>>>            If (bErr = True) Begin
84424>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84425>>>>>>>>
84425>>>>>>>                Function_Return False
84426>>>>>>>            End
84426>>>>>>>>
84426>>>>>>>        End
84426>>>>>>>>
84426>>>>>>>        // Make sure the path ends with a back-slash
84426>>>>>>>        If (sPath <> "") Begin
84428>>>>>>>            Get vFolderFormat sPath to sPath
84429>>>>>>>        End
84429>>>>>>>>
84429>>>>>>>
84429>>>>>>>        Get psDriverID to sDriverID
84430>>>>>>>        Get piDbType   to iDbType
84431>>>>>>>        If (num_arguments > 3) Begin
84433>>>>>>>            Move bShowProg to bShowProgress
84434>>>>>>>        End
84434>>>>>>>>
84434>>>>>>>
84434>>>>>>>        Case Begin
84434>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84436>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84436>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84436>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84437>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84438>>>>>>>
84438>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84439>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84440>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84441>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84442>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84443>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84444>>>>>>>                Case Break
84445>>>>>>>            Case Else
84445>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84446>>>>>>>        Case End
84446>>>>>>>
84446>>>>>>>        Function_Return bOK
84447>>>>>>>    End_Function
84448>>>>>>>
84448>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84450>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84450>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84450>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84450>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84450>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84450>>>>>>>        tSQLConnection SQLConnection
84450>>>>>>>        tSQLConnection SQLConnection
84450>>>>>>>
84450>>>>>>>        If (sDatabase = "") Begin
84452>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84453>>>>>>>>
84453>>>>>>>            Function_Return ""
84454>>>>>>>        End
84454>>>>>>>>
84454>>>>>>>
84454>>>>>>>        Move "" to sRetval
84455>>>>>>>        Get psDriverID to sDriverID
84456>>>>>>>        Get piDbType   to iDbType
84457>>>>>>>
84457>>>>>>>        Case Begin
84457>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84459>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84459>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84460>>>>>>>
84460>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84461>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84462>>>>>>>                Get phoSQLManager to hoSQLHandler
84463>>>>>>>
84463>>>>>>>                If (hoSQLHandler <> 0) Begin
84465>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84466>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84467>>>>>>>
84467>>>>>>>                    If (hoSQLConnect <> 0) Begin
84469>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84470>>>>>>>                        If (hstmt <> 0) Begin
84472>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84473>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84474>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84475>>>>>>>                            If (iFetchResult <> 0) Begin
84477>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84478>>>>>>>                            End
84478>>>>>>>>
84478>>>>>>>                            Send SQLClose of hstmt
84479>>>>>>>                        End
84479>>>>>>>>
84479>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84480>>>>>>>                    End
84480>>>>>>>>
84480>>>>>>>                End
84480>>>>>>>>
84480>>>>>>>                Case Break
84481>>>>>>>            Case Else
84481>>>>>>>                If (bSilent = False) Begin
84483>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84484>>>>>>>                End
84484>>>>>>>>
84484>>>>>>>        Case End
84484>>>>>>>
84484>>>>>>>        Function_Return sRetval
84485>>>>>>>    End_Function
84486>>>>>>>
84486>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84488>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84488>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84488>>>>>>>        Handle hConnection hStmt hoSQLManager
84488>>>>>>>        Integer iDbType // iFetchResult
84488>>>>>>>
84488>>>>>>>        If (sDatabase = "") Begin
84490>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84491>>>>>>>>
84491>>>>>>>            Function_Return False
84492>>>>>>>        End
84492>>>>>>>>
84492>>>>>>>
84492>>>>>>>        If (sSQLCollation = "") Begin
84494>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84495>>>>>>>>
84495>>>>>>>            Function_Return False
84496>>>>>>>        End
84496>>>>>>>>
84496>>>>>>>
84496>>>>>>>        Get psDriverID to sDriverID
84497>>>>>>>        Get piDbType   to iDbType
84498>>>>>>>
84498>>>>>>>        Get phoSQLManager to hoSQLManager
84499>>>>>>>        Get psConnectionID     to sConnectionID
84500>>>>>>>        Get psConnectionString to sConnectionString
84501>>>>>>>        Move 0 to LastErr
84502>>>>>>>
84502>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84503>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84504>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84505>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84507>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84508>>>>>>>>
84508>>>>>>>            Function_Return False
84509>>>>>>>        End
84509>>>>>>>>
84509>>>>>>>
84509>>>>>>>        Get SqlOpen of hConnection to hStmt
84510>>>>>>>
84510>>>>>>>        If (hStmt = 0) Begin
84512>>>>>>>            Send SqlDisconnect of hoSQLManager
84513>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84514>>>>>>>>
84514>>>>>>>            Function_Return False
84515>>>>>>>        End
84515>>>>>>>>
84515>>>>>>>
84515>>>>>>>        // Check if collation already exists
84515>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84516>>>>>>>        // If the current collate is the same as the new; do nothing.
84516>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84518>>>>>>>            Function_Return True
84519>>>>>>>        End
84519>>>>>>>>
84519>>>>>>>
84519>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84520>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84521>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84522>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84523>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84524>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84525>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84526>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84527>>>>>>>
84527>>>>>>>        // MS-SQL Syntax:
84527>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84527>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84527>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84527>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84528>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84529>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84530>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84530>>>>>>>
84530>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84531>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84532>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84533>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84535>>>>>>>           Function_Return False
84536>>>>>>>        End
84536>>>>>>>>
84536>>>>>>>
84536>>>>>>>        Function_Return (Err = False)
84537>>>>>>>    End_Function
84538>>>>>>>
84538>>>>>>>
84538>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84538>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84540>>>>>>>        Function_Return False
84541>>>>>>>    End_Function
84542>>>>>>>
84542>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84542>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84542>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84542>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84542>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84542>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84544>>>>>>>        Handle hToTable
84544>>>>>>>        Boolean bOK bExists bOpened bCopyData
84544>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84544>>>>>>>        tSQLConnection SQLConnection
84544>>>>>>>        tSQLConnection SQLConnection
84544>>>>>>>        Integer iPos iMaxRecords
84544>>>>>>>
84544>>>>>>>        Get psDriverID to sDriverID
84545>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84546>>>>>>>        If (bExists = False) Begin
84548>>>>>>>            Function_Return False
84549>>>>>>>        End
84549>>>>>>>>
84549>>>>>>>
84549>>>>>>>        If (num_arguments > 1) Begin
84551>>>>>>>            Move bCpyDat to bCopyData
84552>>>>>>>        End
84552>>>>>>>>
84552>>>>>>>        Else Begin
84553>>>>>>>            Move False to bCopyData
84554>>>>>>>        End
84554>>>>>>>>
84554>>>>>>>
84554>>>>>>>        Open hTable
84556>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84559>>>>>>>        If (bOpened = False) Begin
84561>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84562>>>>>>>>
84562>>>>>>>            Function_Return False
84563>>>>>>>        End
84563>>>>>>>>
84563>>>>>>>        Move 0 to hToTable
84564>>>>>>>
84564>>>>>>>        Move 16711679 to iMaxRecords
84565>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84568>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84569>>>>>>>        If (iPos > 0) Begin
84571>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84572>>>>>>>        End
84572>>>>>>>>
84572>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84575>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84576>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84577>>>>>>>
84577>>>>>>>        If (ghoProgressBar <> 0) Begin
84579>>>>>>>            Send DoAdvance of ghoProgressBar
84580>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84581>>>>>>>        End
84581>>>>>>>>
84581>>>>>>>
84581>>>>>>>        Move False to Err
84582>>>>>>>
84582>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84583>>>>>>>            Structure_Copy hTable to hToTable
84584>>>>>>>
84584>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84587>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84590>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84593>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84596>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84599>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84600>>>>>>>
84600>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84602>>>>>>>
84602>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84603>>>>>>>        Move (not(Err)) to bOK
84604>>>>>>>        If (bOK = True and bCopyData = True) Begin
84606>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84607>>>>>>>        End
84607>>>>>>>>
84607>>>>>>>
84607>>>>>>>        // This must be after copying data...
84607>>>>>>>        If (Err = False) Begin
84609>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84612>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84615>>>>>>>        End
84615>>>>>>>>
84615>>>>>>>        Move (not(Err)) to bOK
84616>>>>>>>
84616>>>>>>>        Function_Return (bOK = True)
84617>>>>>>>    End_Function
84618>>>>>>>
84618>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84618>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84618>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84620>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84620>>>>>>>        Integer iDbType
84620>>>>>>>        Boolean bExists
84620>>>>>>>
84620>>>>>>>        Get psDriverID to sDriverID
84621>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84622>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84623>>>>>>>        If (bExists = True) Begin
84625>>>>>>>            Function_Return False
84626>>>>>>>        End
84626>>>>>>>>
84626>>>>>>>
84626>>>>>>>        Get psDataPathFirstPart to sPath
84627>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84628>>>>>>>
84628>>>>>>>        Get piDbType to iDbType
84629>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84630>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84631>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84632>>>>>>>
84632>>>>>>>        Move False to Err
84633>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84634>>>>>>>
84634>>>>>>>        Function_Return (Err = False)
84635>>>>>>>    End_Function
84636>>>>>>>
84636>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84636>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84636>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84638>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84638>>>>>>>        Integer iDbType
84638>>>>>>>        Boolean bExists
84638>>>>>>>
84638>>>>>>>        Get psDriverID to sDriverID
84639>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84640>>>>>>>        If (bExists = True) Begin
84642>>>>>>>            Function_Return False
84643>>>>>>>        End
84643>>>>>>>>
84643>>>>>>>
84643>>>>>>>        Get psDataPathFirstPart to sPath
84644>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84645>>>>>>>        If (bExists = True) Begin
84647>>>>>>>            // ToDo: What should we do if an .int file already exists?
84647>>>>>>>        End
84647>>>>>>>>
84647>>>>>>>
84647>>>>>>>        Get piDbType to iDbType
84648>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84649>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84650>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84651>>>>>>>
84651>>>>>>>        Move False to Err
84652>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84653>>>>>>>
84653>>>>>>>        Function_Return (Err = False)
84654>>>>>>>    End_Function
84655>>>>>>>    
84655>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
84655>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
84655>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84657>>>>>>>        Boolean bOK                                                            
84657>>>>>>>        String sStatement
84657>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84658>>>>>>>        Function_Return bOK
84659>>>>>>>    End_Function
84660>>>>>>>    
84660>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84660>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84660>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84660>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
84662>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84662>>>>>>>        Integer iRetval iDbType
84662>>>>>>>        Boolean bExists bOK
84662>>>>>>>
84662>>>>>>>        Get psDriverID to sDriverID
84663>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84664>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84665>>>>>>>        If (bExists = False) Begin
84667>>>>>>>            Function_Return False
84668>>>>>>>        End
84668>>>>>>>>
84668>>>>>>>
84668>>>>>>>        Get psDataPathFirstPart to sPath
84669>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84670>>>>>>>
84670>>>>>>>        Get piDbType to iDbType
84671>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84672>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84673>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84674>>>>>>>
84674>>>>>>>        Move False to Err
84675>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84676>>>>>>>
84676>>>>>>>        // We also need to remove the cache-file since the table has been changed
84676>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84677>>>>>>>
84677>>>>>>>        Function_Return (Err = False)
84678>>>>>>>    End_Function
84679>>>>>>>
84679>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84679>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84681>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84681>>>>>>>        Integer iRetval iDbType
84681>>>>>>>        Boolean bOK
84681>>>>>>>
84681>>>>>>>        Get psDriverID to sDriverID
84682>>>>>>>        Get psDataPathFirstPart to sPath
84683>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84684>>>>>>>
84684>>>>>>>        Get piDbType to iDbType
84685>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84686>>>>>>>        Get psSchema to sSchema
84687>>>>>>>        If (sSchema = "") Begin
84689>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84690>>>>>>>        End
84690>>>>>>>>
84690>>>>>>>        Move (Uppercase(sTableName)) to sVal
84691>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84693>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84694>>>>>>>        End
84694>>>>>>>>
84694>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84695>>>>>>>
84695>>>>>>>        Move False to Err
84696>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84697>>>>>>>
84697>>>>>>>        // We also need to remove the cache-file since the table has been changed
84697>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84698>>>>>>>
84698>>>>>>>        Function_Return (Err = False)
84699>>>>>>>    End_Function
84700>>>>>>>
84700>>>>>>>    // *** Sql View Messages ***
84700>>>>>>>
84700>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
84700>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
84702>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
84702>>>>>>>        Integer iRetval
84702>>>>>>>        Boolean bOK
84702>>>>>>>
84702>>>>>>>        Get psDriverID to sDriverID
84703>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
84704>>>>>>>
84704>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84705>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84706>>>>>>>        Set psSQLStatementString to sSQLString
84707>>>>>>>
84707>>>>>>>        // As we don't check if the view exist or not, it might happen
84707>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84707>>>>>>>        Move False to Err
84708>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84709>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84710>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84711>>>>>>>        Move 0 to LastErr
84712>>>>>>>
84712>>>>>>>        // We also need to remove the cache-file since the table has been changed
84712>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
84713>>>>>>>
84713>>>>>>>        Function_Return (Err = False)
84714>>>>>>>    End_Function
84715>>>>>>>
84715>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84717>>>>>>>        Boolean bOK
84717>>>>>>>        Integer iDbType
84717>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84717>>>>>>>
84717>>>>>>>        Get psDriverID to sDriverID
84718>>>>>>>        Get piDbType   to iDbType
84719>>>>>>>
84719>>>>>>>        Case Begin
84719>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84721>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84722>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84723>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84724>>>>>>>            Break
84725>>>>>>>
84725>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84728>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84729>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84730>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84731>>>>>>>            Break
84732>>>>>>>
84732>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84735>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84736>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84737>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84738>>>>>>>            Break
84739>>>>>>>
84739>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84742>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84743>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84744>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84745>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84746>>>>>>>            Break
84747>>>>>>>
84747>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84750>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84751>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84752>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84753>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84754>>>>>>>            Break
84755>>>>>>>        Case End
84755>>>>>>>
84755>>>>>>>        Move False to Err
84756>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84757>>>>>>>        Move (Err = False) to bOK
84758>>>>>>>
84758>>>>>>>        Function_Return bOK
84759>>>>>>>    End_Function
84760>>>>>>>
84760>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84760>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84762>>>>>>>        Function_Return False
84763>>>>>>>    End_Function
84764>>>>>>>
84764>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84764>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84766>>>>>>>        Integer iLength iDecimals
84766>>>>>>>        String sColumnValue
84766>>>>>>>        String sTableName sDriverID
84766>>>>>>>        Boolean bOK bInitializeValue
84766>>>>>>>
84766>>>>>>>        Get psDriverID to sDriverID
84767>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84768>>>>>>>        If (bOK = False) Begin
84770>>>>>>>            Function_Return False
84771>>>>>>>        End
84771>>>>>>>>
84771>>>>>>>
84771>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84772>>>>>>>        If (sTableName = "") Begin
84774>>>>>>>            Function_Return False
84775>>>>>>>        End
84775>>>>>>>>
84775>>>>>>>
84775>>>>>>>        If (num_arguments > 3) Begin
84777>>>>>>>            Move iLen     to iLength
84778>>>>>>>            Move iDec     to iDecimals
84779>>>>>>>            Move bInitVal to bInitializeValue
84780>>>>>>>            Move sColVal  to sColumnValue
84781>>>>>>>        End
84781>>>>>>>>
84781>>>>>>>
84781>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84782>>>>>>>
84782>>>>>>>        Function_Return (bOK = True)
84783>>>>>>>    End_Function
84784>>>>>>>
84784>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84784>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84786>>>>>>>        Integer iDbType iLength iDecimals iDriver
84786>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84786>>>>>>>        String sDriverID sNotNull
84786>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84786>>>>>>>        Handle hTable
84786>>>>>>>
84786>>>>>>>        Get psDriverID to sDriverID
84787>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84788>>>>>>>        If (bOK = False) Begin
84790>>>>>>>            Function_Return True
84791>>>>>>>        End
84791>>>>>>>>
84791>>>>>>>
84791>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84792>>>>>>>        If (hTable = 0) Begin
84794>>>>>>>            Get NextFreeFilelistSlot to hTable
84795>>>>>>>        End
84795>>>>>>>>
84795>>>>>>>
84795>>>>>>>        Get piDbType to iDbType
84796>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84796>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84797>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84799>>>>>>>            Function_Return True
84800>>>>>>>        End
84800>>>>>>>>
84800>>>>>>>
84800>>>>>>>        Get DriverIndex sDriverID to iDriver
84801>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84804>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84807>>>>>>>
84807>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84808>>>>>>>        If (num_arguments > 3) Begin
84810>>>>>>>            Move iLen     to iLength
84811>>>>>>>            Move iDec     to iDecimals
84812>>>>>>>            Move bInitVal to bInitializeValue
84813>>>>>>>            Move sColVal  to sColumnValue
84814>>>>>>>        End
84814>>>>>>>>
84814>>>>>>>
84814>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84815>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84816>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84817>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84818>>>>>>>
84818>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84819>>>>>>>        If (bFixed = False) Begin
84821>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84822>>>>>>>        End
84822>>>>>>>>
84822>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84823>>>>>>>
84823>>>>>>>        Move False to Err
84824>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84825>>>>>>>
84825>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84827>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84828>>>>>>>        End
84828>>>>>>>>
84828>>>>>>>
84828>>>>>>>        If (Err = False) Begin
84830>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84831>>>>>>>        End
84831>>>>>>>>
84831>>>>>>>
84831>>>>>>>        Move (not(Err)) to bRetval
84832>>>>>>>
84832>>>>>>>        // We also need to remove the cache-file since the table has been changed
84832>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84833>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84836>>>>>>>
84836>>>>>>>        Function_Return bRetval
84837>>>>>>>    End_Function
84838>>>>>>>
84838>>>>>>>    // To update all current rows for a table column with a common value.
84838>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84840>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84840>>>>>>>        Boolean bRetval bSQLDriver
84840>>>>>>>        Integer iCurrErr iDbType
84840>>>>>>>
84840>>>>>>>        Move False to bRetval
84841>>>>>>>        Get piDbType to iDbType
84842>>>>>>>        Get psDriverID to sDriverID
84843>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84844>>>>>>>        If (bSQLDriver = False) Begin
84846>>>>>>>            Function_Return bRetval
84847>>>>>>>        End
84847>>>>>>>>
84847>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84848>>>>>>>
84848>>>>>>>        Move Err to iCurrErr
84849>>>>>>>        Move False to Err
84850>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84851>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84852>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84853>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84853>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
84855>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84856>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84857>>>>>>>        End
84857>>>>>>>>
84857>>>>>>>        Else Begin
84858>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84859>>>>>>>        End
84859>>>>>>>>
84859>>>>>>>
84859>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84860>>>>>>>        Move (Err = False) to bRetval
84861>>>>>>>        Move iCurrErr to Err
84862>>>>>>>
84862>>>>>>>        Function_Return bRetval
84863>>>>>>>    End_Function
84864>>>>>>>
84864>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84864>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84864>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84866>>>>>>>        String sDriverID sTableName
84866>>>>>>>        Boolean bOK
84866>>>>>>>
84866>>>>>>>        Get psDriverID to sDriverID
84867>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84868>>>>>>>        If (bOK = False) Begin
84870>>>>>>>            Function_Return False
84871>>>>>>>        End
84871>>>>>>>>
84871>>>>>>>
84871>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84872>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84873>>>>>>>
84873>>>>>>>        Function_Return (Err = False)
84874>>>>>>>    End_Function
84875>>>>>>>
84875>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84875>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84875>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84875>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84877>>>>>>>        Integer iDbType iLength iDecimals
84877>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84877>>>>>>>        Boolean bExists bOK bFixed
84877>>>>>>>        Handle hTable
84877>>>>>>>
84877>>>>>>>        Get psDriverID to sDriverID
84878>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84879>>>>>>>        If (bOK = False) Begin
84881>>>>>>>            Function_Return False
84882>>>>>>>        End
84882>>>>>>>>
84882>>>>>>>
84882>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84883>>>>>>>        If (hTable = 0) Begin
84885>>>>>>>            Get NextFreeFilelistSlot to hTable
84886>>>>>>>        End
84886>>>>>>>>
84886>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84887>>>>>>>        If (bExists = False) Begin
84889>>>>>>>            Function_Return False
84890>>>>>>>        End
84890>>>>>>>>
84890>>>>>>>
84890>>>>>>>        If (num_arguments > 3) Begin
84892>>>>>>>            Move iLen to iLength
84893>>>>>>>        End
84893>>>>>>>>
84893>>>>>>>        If (num_arguments > 4) Begin
84895>>>>>>>            Move iDec to iDecimals
84896>>>>>>>        End
84896>>>>>>>>
84896>>>>>>>
84896>>>>>>>        Get piDbType to iDbType
84897>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84898>>>>>>>
84898>>>>>>>        Move False to Err
84899>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84900>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84901>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84902>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84903>>>>>>>
84903>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84904>>>>>>>        If (bFixed = False) Begin
84906>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84907>>>>>>>        End
84907>>>>>>>>
84907>>>>>>>
84907>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84908>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84909>>>>>>>
84909>>>>>>>        // We also need to remove the cache-file since the table has been changed
84909>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84910>>>>>>>
84910>>>>>>>        Function_Return (Err = False)
84911>>>>>>>    End_Function
84912>>>>>>>
84912>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84914>>>>>>>        Boolean bOK bErr bIsSQLDriver
84914>>>>>>>        String sDriverID
84914>>>>>>>        Integer iDataType
84914>>>>>>>
84914>>>>>>>        Get psDriverID to sDriverID
84915>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84916>>>>>>>        If (bIsSQLDriver = False) Begin
84918>>>>>>>            Function_Return False
84919>>>>>>>        End
84919>>>>>>>>
84919>>>>>>>
84919>>>>>>>        Move Err to bErr
84920>>>>>>>        Move False to bErr
84921>>>>>>>
84921>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84921>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84921>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84922>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84925>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84927>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
84928>>>>>>>        End
84928>>>>>>>>
84928>>>>>>>
84928>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84931>>>>>>>        Move (not(Err)) to bOK
84932>>>>>>>        Move bErr to Err
84933>>>>>>>
84933>>>>>>>        Function_Return bOK
84934>>>>>>>    End_Function
84935>>>>>>>
84935>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84937>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84937>>>>>>>        String sDriverID
84937>>>>>>>
84937>>>>>>>        Get psDriverID to sDriverID
84938>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84939>>>>>>>        If (bIsSQLDriver = False) Begin
84941>>>>>>>            Function_Return False
84942>>>>>>>        End
84942>>>>>>>>
84942>>>>>>>
84942>>>>>>>        Move Err to bErr
84943>>>>>>>        Move False to bErr
84944>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84947>>>>>>>        If (bNullable = bCurrentState) Begin
84949>>>>>>>            Function_Return True
84950>>>>>>>        End
84950>>>>>>>>
84950>>>>>>>
84950>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84953>>>>>>>        If (bOpen = False) Begin
84955>>>>>>>            Get AutoConnectionIDLogin to bOK
84956>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84957>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84958>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84959>>>>>>>            Open hTable
84961>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84962>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84963>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84964>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84967>>>>>>>        End
84967>>>>>>>>
84967>>>>>>>        If (bOpen = True) Begin
84969>>>>>>>            Structure_Start hTable sDriverID
84970>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84973>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84974>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84976>>>>>>>            Set Action_Text of ghoStatusPanel to ""
84977>>>>>>>        End
84977>>>>>>>>
84977>>>>>>>
84977>>>>>>>        Move (not(Err)) to bOK
84978>>>>>>>        Move bErr to Err
84979>>>>>>>
84979>>>>>>>        Function_Return bOK
84980>>>>>>>    End_Function
84981>>>>>>>
84981>>>>>>>    // Drop column by its table handle
84981>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84983>>>>>>>        String sDriverID sTableName
84983>>>>>>>        Boolean bOK
84983>>>>>>>
84983>>>>>>>        Get psDriverID to sDriverID
84984>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84985>>>>>>>        If (bOK = False) Begin
84987>>>>>>>            Function_Return False
84988>>>>>>>        End
84988>>>>>>>>
84988>>>>>>>
84988>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84989>>>>>>>        If (sTableName = "") Begin
84991>>>>>>>            Function_Return False
84992>>>>>>>        End
84992>>>>>>>>
84992>>>>>>>
84992>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84993>>>>>>>
84993>>>>>>>        Function_Return (bOK = True)
84994>>>>>>>    End_Function
84995>>>>>>>
84995>>>>>>>    // Drop column by its table name as a string.
84995>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84997>>>>>>>        Integer iDbType iDriver
84997>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
84997>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84997>>>>>>>        Handle hTable
84997>>>>>>>
84997>>>>>>>        Get psDriverID to sDriverID
84998>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84999>>>>>>>        If (bOK = False) Begin
85001>>>>>>>            Function_Return False
85002>>>>>>>        End
85002>>>>>>>>
85002>>>>>>>
85002>>>>>>>        Get DriverIndex sDriverID to iDriver
85003>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85006>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85009>>>>>>>
85009>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85010>>>>>>>        If (hTable <> 0) Begin
85012>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85013>>>>>>>            If (bExists = False) Begin
85015>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85018>>>>>>>                Function_Return False
85019>>>>>>>            End
85019>>>>>>>>
85019>>>>>>>        End
85019>>>>>>>>
85019>>>>>>>
85019>>>>>>>        Get piDbType to iDbType
85020>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85022>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85023>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85024>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85027>>>>>>>            Function_Return bOK
85028>>>>>>>        End
85028>>>>>>>>
85028>>>>>>>
85028>>>>>>>        Move False to Err
85029>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85030>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85031>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85032>>>>>>>
85032>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85033>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85034>>>>>>>        Move (not(Err)) to bRetval
85035>>>>>>>
85035>>>>>>>        // We also need to remove the cache-file since the table has been changed
85035>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85036>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85039>>>>>>>
85039>>>>>>>        Function_Return bRetval
85040>>>>>>>    End_Function
85041>>>>>>>
85041>>>>>>>    // Rename a field/column by table handle (filelist number)
85041>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85043>>>>>>>        String sDriverID sTableName
85043>>>>>>>        Boolean bOK
85043>>>>>>>
85043>>>>>>>        Get psDriverID to sDriverID
85044>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85045>>>>>>>        If (bOK = False) Begin
85047>>>>>>>            Function_Return False
85048>>>>>>>        End
85048>>>>>>>>
85048>>>>>>>
85048>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85049>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85050>>>>>>>
85050>>>>>>>        Function_Return (Err = False)
85051>>>>>>>    End_Function
85052>>>>>>>
85052>>>>>>>    // Rename a field/column by table name.
85052>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85054>>>>>>>        Integer iDbType iDataType
85054>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85054>>>>>>>        Boolean bOK bRetval
85054>>>>>>>        Handle hTable
85054>>>>>>>
85054>>>>>>>        Move sTableName to sOrgTableName
85055>>>>>>>        Get psDriverID to sDriverID
85056>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85057>>>>>>>        If (bOK = False) Begin
85059>>>>>>>            Function_Return False
85060>>>>>>>        End
85060>>>>>>>>
85060>>>>>>>
85060>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85061>>>>>>>        If (sVal = "") Begin
85063>>>>>>>            Function_Return False
85064>>>>>>>        End
85064>>>>>>>>
85064>>>>>>>
85064>>>>>>>        Get piDbType to iDbType
85065>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85066>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85067>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85068>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85069>>>>>>>
85069>>>>>>>        Case Begin
85069>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85071>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85072>>>>>>>                Case Break
85073>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85073>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85076>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85077>>>>>>>                Case Break
85078>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85078>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85081>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85082>>>>>>>                Case Break
85083>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85083>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85086>>>>>>>                Move sOrgTableName to sTableName
85087>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85088>>>>>>>                Case Break
85089>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85092>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85092>>>>>>>                Move sOrgTableName to sTableName
85093>>>>>>>                Get psDatabase to sDatabase
85094>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85095>>>>>>>                If (hTable = 0) Begin
85097>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85098>>>>>>>                    If (bOK = False) Begin
85100>>>>>>>                        Function_Return False
85101>>>>>>>                    End
85101>>>>>>>>
85101>>>>>>>                    Get NextFreeFilelistSlot to hTable
85102>>>>>>>                End
85102>>>>>>>>
85102>>>>>>>                Else Begin
85103>>>>>>>                    Open hTable
85105>>>>>>>                End
85105>>>>>>>>
85105>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85106>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85107>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85108>>>>>>>                Case Break
85109>>>>>>>            Case Else
85109>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85110>>>>>>>        Case End
85110>>>>>>>
85110>>>>>>>        Move False to Err
85111>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85112>>>>>>>        Move (Err = False) to bRetval
85113>>>>>>>        // We also need to remove the cache-file since the table has been changed
85113>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85114>>>>>>>
85114>>>>>>>        Function_Return bRetval
85115>>>>>>>    End_Function
85116>>>>>>>
85116>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85118>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85118>>>>>>>        Integer iNumCols iCount iDataType
85118>>>>>>>        String sValue
85118>>>>>>>
85118>>>>>>>        Get phoSQLManager to hoSQLHandler
85119>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85120>>>>>>>        If (hSQLConnect <> 0) Begin
85122>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85123>>>>>>>            If (hStmt <> 0) Begin
85125>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85126>>>>>>>
85126>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85127>>>>>>>                For iCount from 1 to iNumCols
85133>>>>>>>>
85133>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85134>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85136>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85137>>>>>>>                        Move iNumCols to iCount // We're out of here
85138>>>>>>>                    End
85138>>>>>>>>
85138>>>>>>>                Loop
85139>>>>>>>>
85139>>>>>>>
85139>>>>>>>                Send SQLClose of hStmt
85140>>>>>>>            End
85140>>>>>>>>
85140>>>>>>>            Send SQLDisconnect of hSQLConnect
85141>>>>>>>        End
85141>>>>>>>>
85141>>>>>>>
85141>>>>>>>        Function_Return iDataType
85142>>>>>>>    End_Function
85143>>>>>>>
85143>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85143>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85145>>>>>>>        Function_Return False
85146>>>>>>>    End_Function
85147>>>>>>>
85147>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85149>>>>>>>        String sMessage // sConnectionString
85149>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85149>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85149>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85152>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85152>>>>>>>        TimeSpan tsQuery tsFetch
85152>>>>>>>        tSqlErrorArray aSqlErrorArray
85152>>>>>>>        tSqlErrorArray aSqlErrorArray
85152>>>>>>>        Boolean bOK bShowProgress
85152>>>>>>>        tSQLConnection SQLConnection
85152>>>>>>>        tSQLConnection SQLConnection
85152>>>>>>>
85152>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85153>>>>>>>        If (bOK = False) Begin
85155>>>>>>>            Procedure_Return
85156>>>>>>>        End
85156>>>>>>>>
85156>>>>>>>
85156>>>>>>>        If (num_arguments > 2) Begin
85158>>>>>>>            Move bShowProgr to bShowProgress
85159>>>>>>>        End
85159>>>>>>>>
85159>>>>>>>
85159>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85160>>>>>>>        Get phoSQLManager to hoSqlHandler
85161>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85162>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85163>>>>>>>
85163>>>>>>>        If (hoSQLConnect <> 0) Begin
85165>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85166>>>>>>>            If (hoStmt <> 0) Begin
85168>>>>>>>                // record starting date/time stamp
85168>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85169>>>>>>>                // turn on error handling if enabled
85169>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85171>>>>>>>                    Set pbSqlError to False
85172>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85173>>>>>>>                    Move Error_Object_Id to hoError
85174>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85176>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85177>>>>>>>                    End
85177>>>>>>>>
85177>>>>>>>                    Else Begin
85178>>>>>>>                        Move Self to Error_Object_Id
85179>>>>>>>                    End
85179>>>>>>>>
85179>>>>>>>                End
85179>>>>>>>>
85179>>>>>>>
85179>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85179>>>>>>>                Set psSQLStatementString to sStmt
85180>>>>>>>                Send Cursor_Wait of Cursor_Control
85181>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85182>>>>>>>                Send Cursor_Ready of Cursor_Control
85183>>>>>>>
85183>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85185>>>>>>>                    Move hoError to Error_Object_Id
85186>>>>>>>                End
85186>>>>>>>>
85186>>>>>>>
85186>>>>>>>                Move 0 to iMsgs
85187>>>>>>>                Move Err to iErr
85188>>>>>>>                Move LastErr to iLastErr
85189>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85190>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85191>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85192>>>>>>>                Send _SqlColumnInfo hoStmt
85193>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85194>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85195>>>>>>>                Repeat
85195>>>>>>>>
85195>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85196>>>>>>>                    If (iFetchResult <> 0) Begin
85198>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85199>>>>>>>                    End
85199>>>>>>>>
85199>>>>>>>                Until (iFetchResult = 0)
85201>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85202>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85203>>>>>>>                Move iErr to Err
85204>>>>>>>                Move iLastErr to LastErr
85205>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85206>>>>>>>
85206>>>>>>>                Set piRows    to iRows
85207>>>>>>>                Set piRowType to iRowType
85208>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85209>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85210>>>>>>>
85210>>>>>>>                If (iMsgs <> 0) Begin
85212>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85214>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85215>>>>>>>                    End
85215>>>>>>>>
85215>>>>>>>                    For i from 1 to iMsgs
85221>>>>>>>>
85221>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85222>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85223>>>>>>>                        If (bShowProgress = True) Begin
85225>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85227>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85228>>>>>>>                            End
85228>>>>>>>>
85228>>>>>>>                            Else Begin
85229>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85231>>>>>>>                            End
85231>>>>>>>>
85231>>>>>>>                        End
85231>>>>>>>>
85231>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85232>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85233>>>>>>>                    Loop
85234>>>>>>>>
85234>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85236>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85237>>>>>>>                    End
85237>>>>>>>>
85237>>>>>>>                    Set paQueryMessages to sMsg
85238>>>>>>>                End
85238>>>>>>>>
85238>>>>>>>                Else Begin
85239>>>>>>>                    If (bShowProgress = True) Begin
85241>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85242>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85244>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85245>>>>>>>                            Decrement iMsgs
85246>>>>>>>                            For i from 0 to iMsgs
85252>>>>>>>>
85252>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85255>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85258>>>>>>>                            Loop
85259>>>>>>>>
85259>>>>>>>                        End
85259>>>>>>>>
85259>>>>>>>                    End
85259>>>>>>>>
85259>>>>>>>                End
85259>>>>>>>>
85259>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85260>>>>>>>            End
85260>>>>>>>>
85260>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85261>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85262>>>>>>>            Set ptsQueryExec to tsQuery
85263>>>>>>>            Set ptsFetchResults to tsFetch
85264>>>>>>>            Send SqlClose of hoStmt
85265>>>>>>>        End
85265>>>>>>>>
85265>>>>>>>
85265>>>>>>>        Send SqlDisconnect of hoSQLConnect
85266>>>>>>>    End_Procedure
85267>>>>>>>
85267>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85267>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85267>>>>>>>    // Returns False if no error occured.
85267>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85269>>>>>>>        Boolean bOK bShowProgress
85269>>>>>>>        tSQLScriptArray SQLScriptArray
85269>>>>>>>        tSQLScriptArray SQLScriptArray
85269>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85269>>>>>>>        TimeSpan tsTotalTime
85269>>>>>>>
85269>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85270>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85271>>>>>>>        If (SQLScriptArray.bError = True) Begin
85273>>>>>>>            Function_Return False
85274>>>>>>>        End
85274>>>>>>>>
85274>>>>>>>
85274>>>>>>>        If (num_arguments > 3) Begin
85276>>>>>>>            Move bShowProgr to bShowProgress
85277>>>>>>>        End
85277>>>>>>>>
85277>>>>>>>
85277>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85278>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85279>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85280>>>>>>>
85280>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85281>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85282>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85283>>>>>>>
85283>>>>>>>        Function_Return bOK
85284>>>>>>>    End_Function
85285>>>>>>>
85285>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85285>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85287>>>>>>>        Function_Return False
85288>>>>>>>    End_Function
85289>>>>>>>
85289>>>>>>>    // Does three things with auxilirary files;
85289>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85289>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85289>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85289>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85291>>>>>>>        String sDataPath sDDSrcPath sDriverID
85291>>>>>>>        Boolean bOK bExists
85291>>>>>>>        Integer iCount iCh iPos
85291>>>>>>>
85291>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85291>>>>>>>        If (sTableName contains ".") Begin
85293>>>>>>>            Move (Pos(".", sTableName)) to iPos
85294>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85295>>>>>>>        End
85295>>>>>>>>
85295>>>>>>>
85295>>>>>>>        Get psDriverID to sDriverID
85296>>>>>>>        Get psDataPathFirstPart to sDataPath
85297>>>>>>>        Get vFolderExists sDataPath to bOK
85298>>>>>>>        If (bOK = False) Begin
85300>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85301>>>>>>>>
85301>>>>>>>            Function_Return False
85302>>>>>>>        End
85302>>>>>>>>
85302>>>>>>>
85302>>>>>>>        // First delete the cache file:
85302>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85303>>>>>>>
85303>>>>>>>        Get Seq_New_Channel to iCh
85304>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85306>>>>>>>            Function_Return False
85307>>>>>>>        End
85307>>>>>>>>
85307>>>>>>>
85307>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85308>>>>>>>        If (bExists = False) Begin
85310>>>>>>>            Function_Return False
85311>>>>>>>        End
85311>>>>>>>>
85311>>>>>>>
85311>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85312>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85312>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85313>>>>>>>
85313>>>>>>>        // If in development environment; output new .fd file:
85313>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85314>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85315>>>>>>>        If (iCount > 1) Begin
85317>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85318>>>>>>>        End
85318>>>>>>>>
85318>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85319>>>>>>>        If (bExists = True) Begin
85321>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85322>>>>>>>            Move False to Err
85323>>>>>>>            Get AutoConnectionIDLogin to bOK
85324>>>>>>>            If (hTable <> 0) Begin
85326>>>>>>>                Open hTable
85328>>>>>>>            End
85328>>>>>>>>
85328>>>>>>>            Else Begin
85329>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85330>>>>>>>            End
85330>>>>>>>>
85330>>>>>>>
85330>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85333>>>>>>>            If (bOK = True) Begin
85335>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85337>>>>>>>            End
85337>>>>>>>>
85337>>>>>>>            If (Err = True) Begin
85339>>>>>>>                Move False to bOK
85340>>>>>>>            End
85340>>>>>>>>
85340>>>>>>>        End
85340>>>>>>>>
85340>>>>>>>
85340>>>>>>>        Function_Return (bOK = True)
85341>>>>>>>    End_Function
85342>>>>>>>
85342>>>>>>>    // Message for changing .int files to use connection ID's
85342>>>>>>>    //
85342>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85342>>>>>>>    // OR changes an existing connection id to a new id.
85342>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85342>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85342>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85344>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85344>>>>>>>        String[] sFilesData
85345>>>>>>>        Boolean bOK bCancel
85345>>>>>>>        Integer iSize iCount
85345>>>>>>>
85345>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85346>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85347>>>>>>>        If (iSize = 0) Begin
85349>>>>>>>            If (ghoStatusPanel <> 0) Begin
85351>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85353>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85354>>>>>>>                End
85354>>>>>>>>
85354>>>>>>>            End
85354>>>>>>>>
85354>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85355>>>>>>>            Procedure_Return
85356>>>>>>>        End
85356>>>>>>>>
85356>>>>>>>
85356>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85357>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85358>>>>>>>        Decrement iSize
85359>>>>>>>        For iCount from 0 to iSize
85365>>>>>>>>
85365>>>>>>>            Move sFilesData[iCount] to sFileName
85366>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85366>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85367>>>>>>>            If (ghoStatusPanel <> 0) Begin
85369>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85371>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85372>>>>>>>                    If (bCancel = True) Begin
85374>>>>>>>                        Send Deactivate of ghoStatusPanel
85375>>>>>>>                        Procedure_Return
85376>>>>>>>                    End
85376>>>>>>>>
85376>>>>>>>                End
85376>>>>>>>>
85376>>>>>>>            End
85376>>>>>>>>
85376>>>>>>>        Loop
85377>>>>>>>>
85377>>>>>>>
85377>>>>>>>        Get psDriverID to sDriverID
85378>>>>>>>
85378>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85378>>>>>>>        Move "" to sFileName
85379>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85381>>>>>>>            Move "MSSQLDrv.int" to sFileName
85382>>>>>>>        End
85382>>>>>>>>
85382>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85384>>>>>>>            Move "DB2_Drv.int" to sFileName
85385>>>>>>>        End
85385>>>>>>>>
85385>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85387>>>>>>>            Move "ODBC_Drv.int" to sFileName
85388>>>>>>>        End
85388>>>>>>>>
85388>>>>>>>        If (sFileName <> "") Begin
85390>>>>>>>            Move "" to sDriverFile
85391>>>>>>>            Get_File_Path sFileName to sDriverFile
85392>>>>>>>            If (sDriverFile <> "") Begin
85394>>>>>>>                Get psConnectionString to sConnectionString
85395>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85396>>>>>>>            End
85396>>>>>>>>
85396>>>>>>>        End
85396>>>>>>>>
85396>>>>>>>    End_Procedure
85397>>>>>>>
85397>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85397>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85399>>>>>>>        String[] sDatabaseArray
85400>>>>>>>        String sVal sServer sDriverID
85400>>>>>>>        Integer iCount iSize iPos
85400>>>>>>>        Boolean bExists
85400>>>>>>>        tSQLConnection SQLConnection
85400>>>>>>>        tSQLConnection SQLConnection
85400>>>>>>>
85400>>>>>>>        Move False to bExists
85401>>>>>>>        Get psDriverID to sDriverID
85402>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85402>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85404>>>>>>>            Function_Return bExists
85405>>>>>>>        End
85405>>>>>>>>
85405>>>>>>>
85405>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85406>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85408>>>>>>>            Function_Return False
85409>>>>>>>        End
85409>>>>>>>>
85409>>>>>>>
85409>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85410>>>>>>>        Move SQLConnection.sServer to sServer
85411>>>>>>>
85411>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85411>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85413>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85414>>>>>>>        End
85414>>>>>>>>
85414>>>>>>>        Else If (sServer contains "/") Begin
85417>>>>>>>            Move (Pos("/", sServer)) to iPos
85418>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85419>>>>>>>        End
85419>>>>>>>>
85419>>>>>>>
85419>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85420>>>>>>>        Decrement iSize
85421>>>>>>>        For iCount from 0 to iSize
85427>>>>>>>>
85427>>>>>>>            Move sDatabaseArray[iCount] to sVal
85428>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85430>>>>>>>                Move True to bExists
85431>>>>>>>                If (bExists = True) Begin
85433>>>>>>>                    Move iSize to iCount // We're done.
85434>>>>>>>                End
85434>>>>>>>>
85434>>>>>>>            End
85434>>>>>>>>
85434>>>>>>>        Loop
85435>>>>>>>>
85435>>>>>>>
85435>>>>>>>        Function_Return bExists
85436>>>>>>>    End_Function
85437>>>>>>>
85437>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85437>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85439>>>>>>>        String sDatabase sSchema sTableName sVal
85439>>>>>>>        Boolean bExists
85439>>>>>>>        String[] sTablesArray
85440>>>>>>>        Integer iSize iCount
85440>>>>>>>
85440>>>>>>>        Move False to bExists
85441>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85442>>>>>>>        Get psDatabase to sDatabase
85443>>>>>>>        Get psSchema   to sSchema
85444>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85445>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85446>>>>>>>        Decrement iSize
85447>>>>>>>        For iCount from 0 to iSize
85453>>>>>>>>
85453>>>>>>>            Move sTablesArray[iCount] to sVal
85454>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85456>>>>>>>                Move True to bExists
85457>>>>>>>                Move iSize to iCount // We're done!
85458>>>>>>>            End
85458>>>>>>>>
85458>>>>>>>        Loop
85459>>>>>>>>
85459>>>>>>>
85459>>>>>>>        Function_Return bExists
85460>>>>>>>    End_Function
85461>>>>>>>
85461>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85463>>>>>>>        String sVal sTableSpelledCorrectly
85463>>>>>>>        Boolean bExists
85463>>>>>>>        String[] sTablesArray
85464>>>>>>>        Integer iSize iCount
85464>>>>>>>
85464>>>>>>>        Move False to bExists
85465>>>>>>>        Move sTableName to sTableSpelledCorrectly
85466>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85467>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85468>>>>>>>        Decrement iSize
85469>>>>>>>        For iCount from 0 to iSize
85475>>>>>>>>
85475>>>>>>>            Move sTablesArray[iCount] to sVal
85476>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85478>>>>>>>                Move sVal to sTableSpelledCorrectly
85479>>>>>>>                Move iSize to iCount // We're done!
85480>>>>>>>            End
85480>>>>>>>>
85480>>>>>>>        Loop
85481>>>>>>>>
85481>>>>>>>
85481>>>>>>>        Function_Return sTableSpelledCorrectly
85482>>>>>>>    End_Function
85483>>>>>>>
85483>>>>>>>    // ToDo: This index name function needs to be finished...
85483>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85485>>>>>>>        String sSchema sTableName sDriverID
85485>>>>>>>        Boolean bExists
85485>>>>>>>
85485>>>>>>>        Get psDriverID to sDriverID
85486>>>>>>>        Get psSchema to sSchema
85487>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85488>>>>>>>
85488>>>>>>>        Function_Return bExists
85489>>>>>>>    End_Function
85490>>>>>>>
85490>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85490>>>>>>>    // Returns True if it does
85490>>>>>>>    // Sample:
85490>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85490>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85492>>>>>>>        Integer iNumColumns iColumn
85492>>>>>>>        String sColumn sDriverID
85492>>>>>>>        String[] sColumnsArray
85493>>>>>>>        Boolean bExists bOK
85493>>>>>>>
85493>>>>>>>        Move False to bExists
85494>>>>>>>        Get AutoConnectionIDLogin to bOK
85495>>>>>>>        Get psDriverID to sDriverID
85496>>>>>>>
85496>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85497>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85498>>>>>>>        Decrement iNumColumns
85499>>>>>>>        For iColumn from 0 to iNumColumns
85505>>>>>>>>
85505>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85506>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85508>>>>>>>                Move True to bExists
85509>>>>>>>                Move iNumColumns to iColumn // We're out of here
85510>>>>>>>            End
85510>>>>>>>>
85510>>>>>>>        Loop
85511>>>>>>>>
85511>>>>>>>
85511>>>>>>>        Function_Return bExists
85512>>>>>>>    End_Function
85513>>>>>>>
85513>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85515>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85515>>>>>>>        Boolean bOpened bOK
85515>>>>>>>        String sColumnName sNativeTypeName
85515>>>>>>>
85515>>>>>>>        Get AutoConnectionIDLogin to bOK
85516>>>>>>>        Get OpenTableExclusive hTable to bOK
85517>>>>>>>        If (bOK = False) Begin
85519>>>>>>>            Function_Return False
85520>>>>>>>        End
85520>>>>>>>>
85520>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85523>>>>>>>        If (bOpened = False) Begin
85525>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85526>>>>>>>>
85526>>>>>>>            Function_Return False
85527>>>>>>>        End
85527>>>>>>>>
85527>>>>>>>
85527>>>>>>>        Move False to Err
85528>>>>>>>
85528>>>>>>>        Structure_Start hTable
85529>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85532>>>>>>>
85532>>>>>>>            For iColumn from 1 to iNumColumns
85538>>>>>>>>
85538>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85541>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85544>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85547>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85550>>>>>>>
85550>>>>>>>                Case Begin
85550>>>>>>>                    Case (iDFType = DF_DATE)
85552>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85554>>>>>>>                            // Convert datetime to date
85554>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85557>>>>>>>                        End
85557>>>>>>>>
85557>>>>>>>                        Case Break
85558>>>>>>>                    Case (iDFType = DF_DATETIME)
85561>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85563>>>>>>>                            // Convert datetime to datetime2
85563>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85566>>>>>>>                        End
85566>>>>>>>>
85566>>>>>>>                        Case Break
85567>>>>>>>                    Case (iDFType = DF_ASCII)
85570>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85572>>>>>>>                            // Convert char to varchar
85572>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85575>>>>>>>                        End
85575>>>>>>>>
85575>>>>>>>                        Case Break
85576>>>>>>>                    Case (iDFType = DF_TEXT)
85579>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85581>>>>>>>                            // Convert text to varchar(max)
85581>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85584>>>>>>>                        End
85584>>>>>>>>
85584>>>>>>>                        Case Break
85585>>>>>>>                    Case (iDFType = DF_BINARY)
85588>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85590>>>>>>>                            // Convert image to varbinary(max)
85590>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85593>>>>>>>                        End
85593>>>>>>>>
85593>>>>>>>                        Case Break
85594>>>>>>>                Case End
85594>>>>>>>            Loop
85595>>>>>>>>
85595>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85596>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85598>>>>>>>
85598>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85599>>>>>>>        Function_Return (Err = False)
85600>>>>>>>    End_Function
85601>>>>>>>
85601>>>>>>>
85601>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85601>>>>>>>    // the DbUpdateVersion database revision in.
85601>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85601>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85601>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85603>>>>>>>        Boolean bOK bOpened
85603>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85603>>>>>>>
85603>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85606>>>>>>>        Get _TableNameOnly sTableName to sTableName
85607>>>>>>>        If (sTableName = "") Begin
85609>>>>>>>            Function_Return False
85610>>>>>>>        End
85610>>>>>>>>
85610>>>>>>>
85610>>>>>>>        // This just creates the table and a "dummy" column.
85610>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85611>>>>>>>        If (bOK = False) Begin
85613>>>>>>>            Function_Return False
85614>>>>>>>        End
85614>>>>>>>>
85614>>>>>>>
85614>>>>>>>        Close hTable
85615>>>>>>>        Move False to Err
85616>>>>>>>
85616>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85617>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85618>>>>>>>        Move "Decimal" to sDataType
85619>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85620>>>>>>>
85620>>>>>>>        // Adds the "sColumnName" passed to the function
85620>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85621>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85622>>>>>>>
85622>>>>>>>        // Now we can delete the dummy column:
85622>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85623>>>>>>>
85623>>>>>>>        // Finally, we attach to the newly created table.
85623>>>>>>>        If (Err = False) Begin
85625>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85626>>>>>>>        End
85626>>>>>>>>
85626>>>>>>>        Open hTable
85628>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85631>>>>>>>
85631>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85632>>>>>>>    End_Function
85633>>>>>>>
85633>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85633>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85633>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85633>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85633>>>>>>>    // column types.
85633>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85635>>>>>>>        Handle hDatabase
85635>>>>>>>        Integer iDriver iServers iCount
85635>>>>>>>        String sValue
85635>>>>>>>
85635>>>>>>>        If (sServer = "") Begin
85637>>>>>>>            Function_Return 0
85638>>>>>>>        End
85638>>>>>>>>
85638>>>>>>>
85638>>>>>>>        Get DriverIndex sDriverID to iDriver
85639>>>>>>>        If (iDriver = 0) Begin
85641>>>>>>>            Function_Return 0
85642>>>>>>>        End
85642>>>>>>>>
85642>>>>>>>
85642>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85645>>>>>>>        For iCount from 1 to iServers
85651>>>>>>>>
85651>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85654>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85656>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85659>>>>>>>            End
85659>>>>>>>>
85659>>>>>>>        Loop
85660>>>>>>>>
85660>>>>>>>
85660>>>>>>>        Function_Return hDatabase
85661>>>>>>>    End_Function
85662>>>>>>>
85662>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85662>>>>>>>//        String sRootName
85662>>>>>>>//        Boolean bOK
85662>>>>>>>//
85662>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85662>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85662>>>>>>>//
85662>>>>>>>//        Function_Return bOK
85662>>>>>>>//    End_Function
85662>>>>>>>
85662>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85662>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85662>>>>>>>//        Integer iDbType
85662>>>>>>>//        Boolean bOK
85662>>>>>>>//
85662>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85662>>>>>>>//        If (bOK = True) Begin
85662>>>>>>>//            Function_Return False
85662>>>>>>>//        End
85662>>>>>>>//
85662>>>>>>>//        Get psDriverID to sDriverID
85662>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85662>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85662>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85662>>>>>>>//
85662>>>>>>>//        Get psDriverID to sDriverID
85662>>>>>>>//        Get piDbType   to iDbType
85662>>>>>>>//        Get psSchema   to sSchema
85662>>>>>>>//        If (sSchema = "") Begin
85662>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85662>>>>>>>//        End
85662>>>>>>>//
85662>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85662>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85662>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85662>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85662>>>>>>>//            End
85662>>>>>>>//            Else Begin
85662>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85662>>>>>>>//            End
85662>>>>>>>//        End
85662>>>>>>>//
85662>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85662>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85662>>>>>>>//
85662>>>>>>>//        Function_Return True
85662>>>>>>>//    End_Function
85662>>>>>>>
85662>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85662>>>>>>>    // from the passed filelist.
85662>>>>>>>    // Returns the number of tables affected.
85662>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85664>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85664>>>>>>>        Integer iRetval
85664>>>>>>>        Handle hTable
85664>>>>>>>
85664>>>>>>>        // We first save the current filelist as the passed filelist name
85664>>>>>>>        // may come from another workspace, to restore it when we're ready.
85664>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85667>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85670>>>>>>>        Move 0 to hTable
85671>>>>>>>        Move 0 to iRetval
85672>>>>>>>
85672>>>>>>>        Repeat
85672>>>>>>>>
85672>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85675>>>>>>>            If (hTable <> 0) Begin
85677>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85680>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85683>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85686>>>>>>>                Move (Uppercase(sRootName)) to sVal
85687>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85689>>>>>>>                    // Prefixes:
85689>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85690>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85691>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85692>>>>>>>                    // Suffixes:
85692>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85693>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85694>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85695>>>>>>>
85695>>>>>>>                    // Change Filelist entry:
85695>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85698>>>>>>>
85698>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85699>>>>>>>                    If (sVal contains "dbo.") Begin
85701>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85702>>>>>>>
85702>>>>>>>                        // Change Filelist entry:
85702>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85705>>>>>>>                    End
85705>>>>>>>>
85705>>>>>>>                    Increment iRetval
85706>>>>>>>                End
85706>>>>>>>>
85706>>>>>>>            End
85706>>>>>>>>
85706>>>>>>>        Until (hTable = 0)
85708>>>>>>>
85708>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85711>>>>>>>
85711>>>>>>>        Function_Return iRetval
85712>>>>>>>    End_Function
85713>>>>>>>
85713>>>>>>>    // To open all Sql based tables in Filelist.cfg
85713>>>>>>>    Procedure SqlUtilOpenAllTables
85715>>>>>>>        Handle hTable
85715>>>>>>>        String sRoot sDriverID
85715>>>>>>>        Boolean bOK
85715>>>>>>>
85715>>>>>>>        Move 0 to hTable
85716>>>>>>>        Move "" to sDriverID
85717>>>>>>>        Get AutoConnectionIDLogin to bOK
85718>>>>>>>
85718>>>>>>>        Repeat
85718>>>>>>>>
85718>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85721>>>>>>>            If (hTable > 0) Begin
85723>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85726>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85728>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85731>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85733>>>>>>>                        Open hTable
85735>>>>>>>                    End
85735>>>>>>>>
85735>>>>>>>                End
85735>>>>>>>>
85735>>>>>>>            End
85735>>>>>>>>
85735>>>>>>>
85735>>>>>>>        Until (hTable = 0)
85737>>>>>>>    End_Procedure
85738>>>>>>>
85738>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85738>>>>>>>//        String sRetval sDriverID
85738>>>>>>>//        String sTableName
85738>>>>>>>//        Integer iDbType iIndex
85738>>>>>>>//        Boolean bOK
85738>>>>>>>//
85738>>>>>>>//        Get psDriverID to sDriverID
85738>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85738>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85738>>>>>>>//            Function_Return ""
85738>>>>>>>//        End
85738>>>>>>>//
85738>>>>>>>//        Move False to Err
85738>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85738>>>>>>>//        Get piDbType to iDbType
85738>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85738>>>>>>>//        If (iIndex = -1) Begin
85738>>>>>>>//            Function_Return ""
85738>>>>>>>//        End
85738>>>>>>>//
85738>>>>>>>//        Function_Return sRetval
85738>>>>>>>//    End_Function
85738>>>>>>>
85738>>>>>>>    // Checks if the passed Table;
85738>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
85738>>>>>>>    // 2) It has an .int file.
85738>>>>>>>    // If both is True it should already be connected to SQL
85738>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85740>>>>>>>        Boolean bExists bRootName
85740>>>>>>>        String sRootName sDataPath
85740>>>>>>>
85740>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85743>>>>>>>        Move (sRootName contains sDriverID) to bRootName
85744>>>>>>>
85744>>>>>>>        Get psDataPathFirstPart to sDataPath
85745>>>>>>>        Get vFolderExists sDataPath to bExists
85746>>>>>>>        If (bExists = False) Begin
85748>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85748>>>>>>>            Function_Return False
85749>>>>>>>        End
85749>>>>>>>>
85749>>>>>>>
85749>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85750>>>>>>>        Get _TableNameOnly sRootName to sRootName
85751>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85752>>>>>>>
85752>>>>>>>        Function_Return (bRootName = True and bExists = True)
85753>>>>>>>    End_Function
85754>>>>>>>
85754>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85756>>>>>>>        Boolean bViewTableType bOpen bOK
85756>>>>>>>        Integer iTableCount iNumTables
85756>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85756>>>>>>>        Handle hoCliHandler
85756>>>>>>>        tSQLConnection SQLConnection
85756>>>>>>>        tSQLConnection SQLConnection
85756>>>>>>>
85756>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85759>>>>>>>        If (bOpen = False) Begin
85761>>>>>>>            Get AutoConnectionIDLogin to bOK
85762>>>>>>>            Open hTable
85764>>>>>>>        End
85764>>>>>>>>
85764>>>>>>>
85764>>>>>>>        Get pSQLConnection to SQLConnection
85765>>>>>>>        Get phoCLIHandler to hoCliHandler
85766>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
85767>>>>>>>
85767>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85770>>>>>>>        Get _TableNameOnly sTableName to sTableName
85771>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85774>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85775>>>>>>>
85775>>>>>>>        For iTableCount from 1 to iNumTables
85781>>>>>>>>
85781>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85782>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85783>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85785>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
85786>>>>>>>                Move iNumTables to iTableCount // We're done.
85787>>>>>>>            End
85787>>>>>>>>
85787>>>>>>>        Loop
85788>>>>>>>>
85788>>>>>>>
85788>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
85789>>>>>>>        If (bOpen = False) Begin
85791>>>>>>>            Close hTable
85792>>>>>>>        End
85792>>>>>>>>
85792>>>>>>>
85792>>>>>>>        Function_Return bViewTableType
85793>>>>>>>    End_Function
85794>>>>>>>
85794>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85794>>>>>>>    //
85794>>>>>>>    // SQL utility function that returns a database type (string) constant
85794>>>>>>>    // corresponding to the passed iDbType.
85794>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85796>>>>>>>        String sRetval
85796>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85797>>>>>>>        Function_Return sRetval
85798>>>>>>>    End_Function
85799>>>>>>>
85799>>>>>>>    // SQL utility function that returns a database type constant (integer)
85799>>>>>>>    // corresponding to the passed sDbType string constant.
85799>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85801>>>>>>>        Integer iRetval
85801>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85802>>>>>>>        Function_Return iRetval
85803>>>>>>>    End_Function
85804>>>>>>>
85804>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85804>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85804>>>>>>>    // the SQL Connection program's grid.
85804>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85806>>>>>>>        String sRetval
85806>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85807>>>>>>>        Function_Return sRetval
85808>>>>>>>    End_Function
85809>>>>>>>
85809>>>>>>>    // Pass a driver name as a string and the function will return
85809>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85809>>>>>>>    // quite work and always returns "MS SQL Server"
85809>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85811>>>>>>>        Integer iRetval
85811>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85812>>>>>>>        Function_Return iRetval
85813>>>>>>>    End_Function
85814>>>>>>>
85814>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85814>>>>>>>    // that "fits" in the max allowed length for table names.
85814>>>>>>>    // Max number of characters allowed for table names;
85814>>>>>>>    // IBM DB2      = 128
85814>>>>>>>    // MS-SQL       = 128
85814>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85814>>>>>>>    // MySQL        = 64
85814>>>>>>>    // PostgreSQL   = 64
85814>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85816>>>>>>>        String sGUIDName
85816>>>>>>>        Integer iDbType iLength
85816>>>>>>>
85816>>>>>>>        Get piDbType to iDbType
85817>>>>>>>        Move (RandomHexUUID()) to sGUIDName
85818>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85819>>>>>>>        Move (Length(sGUIDName)) to iLength
85820>>>>>>>
85820>>>>>>>        Case Begin
85820>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85822>>>>>>>            If (iLength > 128) Begin
85824>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85825>>>>>>>            End
85825>>>>>>>>
85825>>>>>>>            Case Break
85826>>>>>>>
85826>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85829>>>>>>>            If (iLength > 128) Begin
85831>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85832>>>>>>>            End
85832>>>>>>>>
85832>>>>>>>            Case Break
85833>>>>>>>
85833>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85836>>>>>>>            If (iLength > 128) Begin
85838>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85839>>>>>>>            End
85839>>>>>>>>
85839>>>>>>>            Case Break
85840>>>>>>>
85840>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85843>>>>>>>            If (iLength > 64) Begin
85845>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85846>>>>>>>            End
85846>>>>>>>>
85846>>>>>>>            Case Break
85847>>>>>>>
85847>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85850>>>>>>>            If (iLength > 64) Begin
85852>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85853>>>>>>>            End
85853>>>>>>>>
85853>>>>>>>        Case End
85853>>>>>>>
85853>>>>>>>        Function_Return sGUIDName
85854>>>>>>>    End_Function
85855>>>>>>>
85855>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85855>>>>>>>    // Pass the memory resource file reference and the filename to be created,
85855>>>>>>>    // including full path.
85855>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85857>>>>>>>        String sText
85857>>>>>>>        Integer iCh iSize iArgSize
85857>>>>>>>
85857>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85858>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85859>>>>>>>        Get_Channel_Size iCh to iSize
85860>>>>>>>        Read_Block channel iCh sText iSize
85862>>>>>>>        Send Seq_Close_Channel iCh
85863>>>>>>>
85863>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
85864>>>>>>>            Write channel iCh sText
85866>>>>>>>        Send Seq_Close_Channel iCh
85867>>>>>>>
85867>>>>>>>        // Wait for file to be written to disk.
85867>>>>>>>        Sleep 2
85868>>>>>>>    End_Procedure
85869>>>>>>>
85869>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85871>>>>>>>        String sNotNull sRetval sDefaultValue
85871>>>>>>>        Boolean bOK
85871>>>>>>>
85871>>>>>>>        Get IsSQLDriver sDriverID to bOK
85872>>>>>>>        If (bOK = False) Begin
85874>>>>>>>            Function_Return ""
85875>>>>>>>        End
85875>>>>>>>>
85875>>>>>>>
85875>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85876>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85877>>>>>>>
85877>>>>>>>        Case Begin
85877>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85879>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85880>>>>>>>                Case Break
85881>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85884>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85885>>>>>>>                Case Break
85886>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85889>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85890>>>>>>>                Case Break
85891>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85894>>>>>>>                Move (String(sNotNull))                                     to sRetval
85895>>>>>>>                Case Break
85896>>>>>>>
85896>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85896>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85896>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85899>>>>>>>                Move  ""                                                    to sRetval
85900>>>>>>>                Case Break
85901>>>>>>>
85901>>>>>>>            Case Else
85901>>>>>>>                Move  ""                                                    to sRetval
85902>>>>>>>        Case End
85902>>>>>>>
85902>>>>>>>        Function_Return sRetval
85903>>>>>>>    End_Function
85904>>>>>>>
85904>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85904>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85906>>>>>>>        Function_Return False
85907>>>>>>>    End_Function
85908>>>>>>>
85908>>>>>>>    // Enumerate SQL Servers.
85908>>>>>>>    // Pass a driver id. Returns a string array.
85908>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85908>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85908>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85910>>>>>>>        String[] sReturnArray
85911>>>>>>>        Handle hoSQLHandler
85911>>>>>>>        String sServer
85911>>>>>>>        Integer iCount iNumItems iDataSourceType
85911>>>>>>>
85911>>>>>>>        If (num_arguments > 1) Begin
85913>>>>>>>            Move iDatSrcType to iDataSourceType
85914>>>>>>>        End
85914>>>>>>>>
85914>>>>>>>
85914>>>>>>>        Case Begin
85914>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85916>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
85917>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
85918>>>>>>>                For iCount from 0 to (iNumItems - 1)
85924>>>>>>>>
85924>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
85925>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85926>>>>>>>                Loop
85927>>>>>>>>
85927>>>>>>>                Case Break
85928>>>>>>>
85928>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85931>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
85932>>>>>>>                Send SeedDataSources of hoSQLHandler
85933>>>>>>>                Move 0 to iCount
85934>>>>>>>                Repeat
85934>>>>>>>>
85934>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85935>>>>>>>                    If (sServer <> "") Begin
85937>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
85938>>>>>>>                        Move sServer to sReturnArray[iCount]
85939>>>>>>>                    End
85939>>>>>>>>
85939>>>>>>>                    Increment iCount
85940>>>>>>>                Until (sServer = "")
85942>>>>>>>                Case Break
85943>>>>>>>
85943>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85946>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
85947>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85948>>>>>>>                Move 0 to iCount
85949>>>>>>>                Repeat
85949>>>>>>>>
85949>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85950>>>>>>>                    If (sServer <> "") Begin
85952>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
85953>>>>>>>                        Move sServer to sReturnArray[iCount]
85954>>>>>>>                    End
85954>>>>>>>>
85954>>>>>>>                    Increment iCount
85955>>>>>>>                Until (sServer = "")
85957>>>>>>>                Case Break
85958>>>>>>>
85958>>>>>>>            Case Else
85958>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85959>>>>>>>>
85959>>>>>>>        Case End
85959>>>>>>>
85959>>>>>>>        Function_Return sReturnArray
85960>>>>>>>    End_Function
85961>>>>>>>
85961>>>>>>>    // Returns all databases as a string array for the passed driver id.
85961>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85963>>>>>>>        String[] sReturnArray
85964>>>>>>>        String sServer sVal
85964>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85964>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85965>>>>>>>        tSQLConnection SQLConnection
85965>>>>>>>        tSQLConnection SQLConnection
85965>>>>>>>        Boolean bOK
85965>>>>>>>        Integer iCount iSize
85965>>>>>>>
85965>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85966>>>>>>>        If (bOK = False) Begin
85968>>>>>>>            Function_Return sReturnArray
85969>>>>>>>        End
85969>>>>>>>>
85969>>>>>>>
85969>>>>>>>        Case Begin
85969>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85971>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85972>>>>>>>                Case Break
85973>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85976>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85977>>>>>>>                Case Break
85978>>>>>>>
85978>>>>>>>            // This is needed to be able to check if a database exists or not.
85978>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85981>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
85982>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
85984>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
85986>>>>>>>                        // If a FILEDSN: (can only be one database name)
85986>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
85987>>>>>>>                    End
85987>>>>>>>>
85987>>>>>>>                    Else Begin
85988>>>>>>>                        // Else the DSN's were read from the registry.
85988>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85989>>>>>>>                        Move SQLConnection.sServer to sServer
85990>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
85991>>>>>>>                        Decrement iSize
85992>>>>>>>                        for iCount from 0 to iSize
85998>>>>>>>>
85998>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
85999>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86001>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86002>>>>>>>                                Move iSize to iCount // We're done.
86003>>>>>>>                            End
86003>>>>>>>>
86003>>>>>>>                        Loop
86004>>>>>>>>
86004>>>>>>>                    End
86004>>>>>>>>
86004>>>>>>>                End
86004>>>>>>>>
86004>>>>>>>                Case Break
86005>>>>>>>
86005>>>>>>>            Case Else
86005>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86005>>>>>>>        Case End
86005>>>>>>>
86005>>>>>>>        Function_Return sReturnArray
86006>>>>>>>    End_Function
86007>>>>>>>
86007>>>>>>>    
86007>>>>>>>    // *** Database API Functions: ***
86007>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86007>>>>>>>    // make changes/updates to the database.
86007>>>>>>>
86007>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86007>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86009>>>>>>>        Function_Return False
86010>>>>>>>    End_Function
86011>>>>>>>
86011>>>>>>>    // This might not do what you think - Here's what it does:
86011>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86011>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86011>>>>>>>    // to the SQL table.
86011>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86011>>>>>>>    // already exists in SQL.
86011>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86011>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86011>>>>>>>    // restructuring an existing table.
86011>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86013>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86013>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86013>>>>>>>        Handle hToTable
86013>>>>>>>
86013>>>>>>>        Move True to bUseConnectionID
86014>>>>>>>        If (num_arguments > 1) Begin
86016>>>>>>>            Move bUseConnID to bUseConnectionID
86017>>>>>>>        End
86017>>>>>>>>
86017>>>>>>>
86017>>>>>>>        Get psDriverID to sDriverID
86018>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86018>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86019>>>>>>>        If (bExists = False) Begin
86021>>>>>>>            Function_Return False
86022>>>>>>>        End
86022>>>>>>>>
86022>>>>>>>
86022>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86023>>>>>>>
86023>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86024>>>>>>>        If (bOK = False) Begin
86026>>>>>>>            Function_Return False
86027>>>>>>>        End
86027>>>>>>>>
86027>>>>>>>
86027>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86027>>>>>>>        // we do nothing
86027>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86028>>>>>>>        If (bExists = True) Begin
86030>>>>>>>            Function_Return False
86031>>>>>>>        End
86031>>>>>>>>
86031>>>>>>>
86031>>>>>>>        Get psConnectionID     to sConnectionID
86032>>>>>>>        Get psConnectionString to sConnectionString
86033>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86035>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86036>>>>>>>>
86036>>>>>>>            Function_Return False
86037>>>>>>>        End
86037>>>>>>>>
86037>>>>>>>
86037>>>>>>>        Set Private.phCurrentTable to hTable
86038>>>>>>>        Get psSchema to sSchema
86039>>>>>>>        If (sSchema = "") Begin
86041>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86042>>>>>>>        End
86042>>>>>>>>
86042>>>>>>>
86042>>>>>>>        // If we should use a connection id we need to check it exists;
86042>>>>>>>        // else we create it before attempting creating the table
86042>>>>>>>        If (bUseConnectionID = True) Begin
86044>>>>>>>            Get AutoConnectionIDLogin to bOK
86045>>>>>>>            If (bOk = False) Begin
86047>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86048>>>>>>>>
86048>>>>>>>                Function_Return False
86049>>>>>>>            End
86049>>>>>>>>
86049>>>>>>>        End
86049>>>>>>>>
86049>>>>>>>
86049>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86052>>>>>>>        Get _TableNameOnly sRootName to sRootName
86053>>>>>>>        If (sRootName = "") Begin
86055>>>>>>>            Function_Return False
86056>>>>>>>        End
86056>>>>>>>>
86056>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86057>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86060>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86063>>>>>>>
86063>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86063>>>>>>>        //
86063>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86063>>>>>>>        // because then the table should not be visible to users.
86063>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86063>>>>>>>//        If (iPos <> 1) Begin
86063>>>>>>>//            If (sDisplayName contains ".") Begin
86063>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86063>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86063>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86063>>>>>>>//            End
86063>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86063>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86063>>>>>>>//            End
86063>>>>>>>//        End
86063>>>>>>>
86063>>>>>>>        If (bIsAlias = False) Begin
86065>>>>>>>            Get OpenTableExclusive hTable to bOpened
86066>>>>>>>            If (bOpened = False) Begin
86068>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86069>>>>>>>>
86069>>>>>>>                Function_Return False
86070>>>>>>>            End
86070>>>>>>>>
86070>>>>>>>        End
86070>>>>>>>>
86070>>>>>>>
86070>>>>>>>        If (ghoProgressBar <> 0) Begin
86072>>>>>>>            Send DoAdvance of ghoProgressBar
86073>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86074>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86075>>>>>>>        End
86075>>>>>>>>
86075>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86075>>>>>>>        Move hTable to hToTable
86076>>>>>>>        Move False to Err
86077>>>>>>>
86077>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86077>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86077>>>>>>>        // a proper and updated .int file.
86077>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86080>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86081>>>>>>>
86081>>>>>>>        If (bIsAlias = False) Begin
86083>>>>>>>            Structure_Start hToTable sDriverID
86084>>>>>>>                Set Private.phCurrentTable to hTable
86085>>>>>>>                If (bUseConnectionID = True) Begin
86087>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86090>>>>>>>                End
86090>>>>>>>>
86090>>>>>>>                Else Begin
86091>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86094>>>>>>>                End
86094>>>>>>>>
86094>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86097>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86097>>>>>>>                Move False to Err
86098>>>>>>>                Move 0 to LastErr
86099>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86100>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86102>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86103>>>>>>>        End
86103>>>>>>>>
86103>>>>>>>
86103>>>>>>>        Move (not(Err)) to bOK
86104>>>>>>>        If (bOK = True) Begin
86106>>>>>>>            // The attributes set above will always trigger an error
86106>>>>>>>            // We also adjust the Filelist entries
86106>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86109>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86112>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86115>>>>>>>
86115>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86115>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86116>>>>>>>        End
86116>>>>>>>>
86116>>>>>>>
86116>>>>>>>        Function_Return (bOK = True)
86117>>>>>>>    End_Function
86118>>>>>>>
86118>>>>>>>    // Sample usage:
86118>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86118>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86118>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86120>>>>>>>        Boolean bOK bIsSQLTable
86120>>>>>>>
86120>>>>>>>        Get AutoConnectionIDLogin to bOK
86121>>>>>>>        Move False to Err
86122>>>>>>>        Get OpenTableExclusive hTable to bOK
86123>>>>>>>        If (bOK = False) Begin
86125>>>>>>>            Function_Return False
86126>>>>>>>        End
86126>>>>>>>>
86126>>>>>>>
86126>>>>>>>        // ToDo: Add to all table change functions!
86126>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86127>>>>>>>            If (bIsSQLTable = True) Begin
86129>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86132>>>>>>>            End
86132>>>>>>>>
86132>>>>>>>
86132>>>>>>>        Set Private.phCurrentTable to hTable
86133>>>>>>>        Structure_Start hTable
86134>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86137>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86138>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86140>>>>>>>
86140>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86141>>>>>>>        Function_Return (Err = False)
86142>>>>>>>    End_Function
86143>>>>>>>
86143>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86145>>>>>>>        Boolean bOK
86145>>>>>>>        
86145>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86146>>>>>>>        If (bOK = True) Begin
86148>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86149>>>>>>>        End
86149>>>>>>>>
86149>>>>>>>        
86149>>>>>>>        Function_Return (bOK = True)
86150>>>>>>>    End_Function
86151>>>>>>>    
86151>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86151>>>>>>>    // or to change the filelist slot names.
86151>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86153>>>>>>>        String sFileListName
86153>>>>>>>        
86153>>>>>>>        Move False to Err
86154>>>>>>>
86154>>>>>>>        If (ghoProgressBar <> 0) Begin
86156>>>>>>>            Send DoAdvance of ghoProgressBar
86157>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86158>>>>>>>        End
86158>>>>>>>>
86158>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86158>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86160>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86163>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86166>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86169>>>>>>>            Function_Return (Err = False) // And we're done.
86170>>>>>>>        End
86170>>>>>>>>
86170>>>>>>>
86170>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86172>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86172>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86173>>>>>>>        End
86173>>>>>>>>
86173>>>>>>>//        Else Begin
86173>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86173>>>>>>>//        End
86173>>>>>>>//
86173>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86173>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86173>>>>>>>
86173>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86176>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86179>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86182>>>>>>>        
86182>>>>>>>        Function_Return (Err = False)
86183>>>>>>>    End_Function
86184>>>>>>>
86184>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86186>>>>>>>        Boolean bOK
86186>>>>>>>
86186>>>>>>>        Get AutoConnectionIDLogin to bOK
86187>>>>>>>        Move False to Err
86188>>>>>>>        Get OpenTableExclusive hTable to bOK
86189>>>>>>>        If (bOK = False) Begin
86191>>>>>>>            Function_Return False
86192>>>>>>>        End
86192>>>>>>>>
86192>>>>>>>
86192>>>>>>>        Set Private.phCurrentTable to hTable
86193>>>>>>>        Structure_Start hTable
86194>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86197>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86198>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86200>>>>>>>
86200>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86201>>>>>>>        Function_Return (Err = False)
86202>>>>>>>    End_Function
86203>>>>>>>
86203>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86205>>>>>>>        Boolean bOK bIsSQLTable
86205>>>>>>>
86205>>>>>>>        Move False to Err
86206>>>>>>>        Get AutoConnectionIDLogin to bOK
86207>>>>>>>        Open hToTable
86209>>>>>>>        Get OpenTableExclusive hTable to bOK
86210>>>>>>>        If (bOK = False) Begin
86212>>>>>>>            Function_Return False
86213>>>>>>>        End
86213>>>>>>>>
86213>>>>>>>
86213>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86214>>>>>>>            If (bIsSQLTable = True) Begin
86216>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86219>>>>>>>            End
86219>>>>>>>>
86219>>>>>>>
86219>>>>>>>        Set Private.phCurrentTable to hTable
86220>>>>>>>        Structure_Start hTable
86221>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86224>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86227>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86228>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86230>>>>>>>
86230>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86231>>>>>>>        Function_Return (Err = False)
86232>>>>>>>    End_Function
86233>>>>>>>
86233>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86235>>>>>>>        Integer[] aTableConvertExceptions
86236>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86237>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86238>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86239>>>>>>>    End_Procedure
86240>>>>>>>
86240>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86242>>>>>>>        Integer[] aTableDateCorrectionExceptions
86243>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86244>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86245>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86246>>>>>>>    End_Procedure
86247>>>>>>>
86247>>>>>>>    Procedure ApiTableConvertALLToSql
86249>>>>>>>        Integer[] iTablesArray
86250>>>>>>>        Integer iSize iCount
86250>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86250>>>>>>>        String sDriverID
86250>>>>>>>
86250>>>>>>>        Get psDriverID to sDriverID
86251>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86252>>>>>>>        Get pbToANSI          to bToANSI
86253>>>>>>>        Get pbRecnum          to bRecnum
86254>>>>>>>        Get pbCopyData        to bCopyData
86255>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86257>>>>>>>            Get pbContinueOnError to bContinueOnError
86258>>>>>>>        End
86258>>>>>>>>
86258>>>>>>>
86258>>>>>>>        Get _AllTablesToConvert to iTablesArray
86259>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86260>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86261>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86262>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86263>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86264>>>>>>>
86264>>>>>>>        Decrement iSize
86265>>>>>>>        For iCount from 0 to iSize
86271>>>>>>>>
86271>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86272>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86273>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86273>>>>>>>            // if there was an error converting one table...
86273>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86273>>>>>>>        Loop
86274>>>>>>>>
86274>>>>>>>
86274>>>>>>>    End_Procedure
86275>>>>>>>
86275>>>>>>>    Procedure ApiTableAttachALLToSql
86277>>>>>>>        Integer[] iTablesArray
86278>>>>>>>        Integer iSize iCount
86278>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86278>>>>>>>        String sDriverID
86278>>>>>>>
86278>>>>>>>        Get psDriverID to sDriverID
86279>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86280>>>>>>>        Get pbToANSI          to bToANSI
86281>>>>>>>        Get pbRecnum          to bRecnum
86282>>>>>>>        Get pbCopyData        to bCopyData
86283>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86285>>>>>>>            Get pbContinueOnError to bContinueOnError
86286>>>>>>>        End
86286>>>>>>>>
86286>>>>>>>
86286>>>>>>>        Get _AllTablesToConvert to iTablesArray
86287>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86288>>>>>>>        Decrement iSize
86289>>>>>>>        For iCount from 0 to iSize
86295>>>>>>>>
86295>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86296>>>>>>>        Loop
86297>>>>>>>>
86297>>>>>>>
86297>>>>>>>    End_Procedure
86298>>>>>>>
86298>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86300>>>>>>>        Handle hToTable hoLogFile
86300>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86300>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86300>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86300>>>>>>>        tSQLConnection SQLConnection
86300>>>>>>>        tSQLConnection SQLConnection
86300>>>>>>>
86300>>>>>>>        Get _UtilTableExists hTable to bExists
86301>>>>>>>        If (bExists = False) Begin
86303>>>>>>>            Set Private.phCurrentTable to hTable
86304>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86305>>>>>>>>
86305>>>>>>>            Function_Return False
86306>>>>>>>        End
86306>>>>>>>>
86306>>>>>>>
86306>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86307>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86307>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86307>>>>>>>        If (bIsAlias = True) Begin
86309>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86312>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86314>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86317>>>>>>>                Get psConnectionID to sConnectionID
86318>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86319>>>>>>>            End
86319>>>>>>>>
86319>>>>>>>            Function_Return True
86320>>>>>>>        End
86320>>>>>>>>
86320>>>>>>>
86320>>>>>>>        Set Private.phCurrentTable to hTable
86321>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86324>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86327>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86330>>>>>>>
86330>>>>>>>        If (ghoProgressBar <> 0) Begin
86332>>>>>>>            Send DoAdvance of ghoProgressBar
86333>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86334>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86335>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86336>>>>>>>        End
86336>>>>>>>>
86336>>>>>>>
86336>>>>>>>        // Marco Kuipers suggestion;
86336>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86336>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86336>>>>>>>        // SQL table.
86336>>>>>>>        Get _UtilTableIsSql hTable to bOK
86337>>>>>>>        If (bOK = False) Begin
86339>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86340>>>>>>>            If (bExists = True) Begin
86342>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86342>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86342>>>>>>>                Get phoLogFile to hoLogFile
86343>>>>>>>                If (hoLogFile <> 0) Begin          
86345>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86346>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86346>>>>>>>                    Send LogError sWarning False
86347>>>>>>>                End
86347>>>>>>>>
86347>>>>>>>                Else Begin
86348>>>>>>>                    Error DFERR_PROGRAM sWarning
86349>>>>>>>>
86349>>>>>>>                End                                                       
86349>>>>>>>>
86349>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86350>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86351>>>>>>>            End
86351>>>>>>>>
86351>>>>>>>        End
86351>>>>>>>>
86351>>>>>>>
86351>>>>>>>        // Does the rootname contain a driver?
86351>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86353>>>>>>>            // Does the table already exist as an SQL table?
86353>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86354>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86354>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86354>>>>>>>            If (bExists = False) Begin
86356>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86357>>>>>>>            End
86357>>>>>>>>
86357>>>>>>>            If (bExists = True) Begin
86359>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86360>>>>>>>                Function_Return False
86361>>>>>>>            End
86361>>>>>>>>
86361>>>>>>>        End
86361>>>>>>>>
86361>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86362>>>>>>>
86362>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86363>>>>>>>        If (bUseConnectionID = True) Begin
86365>>>>>>>            Move False to bUseConnectionID
86366>>>>>>>        End
86366>>>>>>>>
86366>>>>>>>
86366>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86367>>>>>>>        Move SQLConnection.sSchema           to sSchema
86368>>>>>>>        If (sSchema = "") Begin
86370>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86371>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86372>>>>>>>        End
86372>>>>>>>>
86372>>>>>>>
86372>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86373>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86374>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86375>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86377>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86378>>>>>>>>
86378>>>>>>>            Function_Return False
86379>>>>>>>        End
86379>>>>>>>>
86379>>>>>>>
86379>>>>>>>        Get AutoConnectionIDLogin to bOK
86380>>>>>>>        Open hTable
86382>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86385>>>>>>>        If (bOpened = False) Begin
86387>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86388>>>>>>>>
86388>>>>>>>            Function_Return False
86389>>>>>>>        End
86389>>>>>>>>
86389>>>>>>>
86389>>>>>>>        If (ghoProgressBar <> 0) Begin
86391>>>>>>>            Send DoAdvance of ghoProgressBar
86392>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86393>>>>>>>        End
86393>>>>>>>>
86393>>>>>>>
86393>>>>>>>        Move 0 to hToTable
86394>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86395>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86396>>>>>>>
86396>>>>>>>        Case Begin
86396>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86398>>>>>>>                Case Break
86399>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86402>>>>>>>                Case Break
86403>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86406>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86407>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86408>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86409>>>>>>>                Case Break
86410>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86413>>>>>>>                Case Break
86414>>>>>>>            Case Else
86414>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86415>>>>>>>>
86415>>>>>>>                Case Break
86416>>>>>>>        Case End
86416>>>>>>>
86416>>>>>>>        Move False to Err
86417>>>>>>>
86417>>>>>>>        Structure_Start hToTable sDriverID
86418>>>>>>>            Structure_Copy hTable to hToTable
86419>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86422>>>>>>>
86422>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86424>>>>>>>                If (bUseConnectionID = True) Begin
86426>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86429>>>>>>>                End
86429>>>>>>>>
86429>>>>>>>                Else Begin
86430>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86433>>>>>>>                End
86433>>>>>>>>
86433>>>>>>>
86433>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86436>>>>>>>
86436>>>>>>>                If (sSchema <> "") Begin
86438>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86441>>>>>>>                End
86441>>>>>>>>
86441>>>>>>>
86441>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86443>>>>>>>                    If (sLongTableSpace <> "") Begin
86445>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86448>>>>>>>                    End
86448>>>>>>>>
86448>>>>>>>                    If (sBaseTableSpace <> "") Begin
86450>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86453>>>>>>>                    End
86453>>>>>>>>
86453>>>>>>>                    If (sIndexTableSpace <> "") Begin
86455>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86458>>>>>>>                    End
86458>>>>>>>>
86458>>>>>>>                End
86458>>>>>>>>
86458>>>>>>>            End
86458>>>>>>>>
86458>>>>>>>
86458>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86459>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86461>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86462>>>>>>>
86462>>>>>>>        Move (not(Err)) to bOK
86463>>>>>>>
86463>>>>>>>        If (bOK = True and bCopyData = True) Begin
86465>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86466>>>>>>>
86466>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86468>>>>>>>                Get pbContinueOnError to bContinueOnError
86469>>>>>>>            End
86469>>>>>>>>
86469>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86469>>>>>>>            // rename it by adding a GUID to the end of the table name
86469>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86469>>>>>>>            // different rules how long a table name can be.
86469>>>>>>>            // The new table will probably contain data but something went
86469>>>>>>>            // wrong while converting the data from embedded to SQL.
86469>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86471>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86472>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86473>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86474>>>>>>>>
86474>>>>>>>            End
86474>>>>>>>>
86474>>>>>>>        End
86474>>>>>>>>
86474>>>>>>>
86474>>>>>>>        // This must be after copying data...
86474>>>>>>>        If (Err = False) Begin
86476>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86479>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86479>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86479>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86479>>>>>>>            //                // The max length for the display_name is 31 characters...
86479>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86479>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86479>>>>>>>            //                End
86479>>>>>>>            //            End
86479>>>>>>>        End
86479>>>>>>>>
86479>>>>>>>
86479>>>>>>>        Close hTable
86480>>>>>>>        Move (not(Err)) to bOK
86481>>>>>>>        Function_Return bOK
86482>>>>>>>    End_Function
86483>>>>>>>
86483>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86483>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86483>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86483>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86485>>>>>>>        Boolean bOpened bOK
86485>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86485>>>>>>>        String sErrorFile sEmpty sPath
86485>>>>>>>
86485>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86488>>>>>>>        Get AutoConnectionIDLogin to bOK
86489>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86491>>>>>>>            Send IncreaseSortBufferSize
86492>>>>>>>//            Send SetAllIndexesToBatch hToTable
86492>>>>>>>        End
86492>>>>>>>>
86492>>>>>>>
86492>>>>>>>        Move False to Err
86493>>>>>>>        Open sPhysicalName as hToTable
86495>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86498>>>>>>>        If (bOpened = False) Begin
86500>>>>>>>            Function_Return False
86501>>>>>>>        End
86501>>>>>>>>
86501>>>>>>>
86501>>>>>>>        If (ghoStatusPanel <> 0) Begin
86503>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86504>>>>>>>            Set piMinimum of ghoProgressBar to 0
86505>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86506>>>>>>>        End
86506>>>>>>>>
86506>>>>>>>
86506>>>>>>>        Move "" to sEmpty
86507>>>>>>>        Move False to Err
86508>>>>>>>        Move True to bOK
86509>>>>>>>        Set Private.phCurrentTable to hToTable
86510>>>>>>>
86510>>>>>>>        // No need to get the record identifier
86510>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86513>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86516>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86518>>>>>>>            // Remove all indices to speed up copying of data:
86518>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86523>>>>>>>            If (iRetval <> 0) Begin       
86525>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86526>>>>>>>>
86526>>>>>>>                Close hToTable
86527>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86530>>>>>>>                Function_Return False
86531>>>>>>>            End
86531>>>>>>>>
86531>>>>>>>        End
86531>>>>>>>>
86531>>>>>>>
86531>>>>>>>        Move (sRootName + ".err") to sErrorFile
86532>>>>>>>        Move 0 to iIndex
86533>>>>>>>        Move False to Err
86534>>>>>>>
86534>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86536>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86539>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86544>>>>>>>            If (iRetval <> 0) Begin
86546>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86547>>>>>>>>
86547>>>>>>>                Close hToTable
86548>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86551>>>>>>>                Function_Return False
86552>>>>>>>            End
86552>>>>>>>>
86552>>>>>>>        End
86552>>>>>>>>
86552>>>>>>>        Else Begin
86553>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86556>>>>>>>        End
86556>>>>>>>>
86556>>>>>>>
86556>>>>>>>        If (Err = False) Begin
86558>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86559>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86560>>>>>>>        End
86560>>>>>>>>
86560>>>>>>>
86560>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86562>>>>>>>            // Recreate indices:
86562>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86567>>>>>>>            If (iRetval <> 0) Begin
86569>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86570>>>>>>>>
86570>>>>>>>                Close hToTable
86571>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86574>>>>>>>                Function_Return False
86575>>>>>>>            End
86575>>>>>>>>
86575>>>>>>>        End
86575>>>>>>>>
86575>>>>>>>
86575>>>>>>>        Close hToTable
86576>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86579>>>>>>>
86579>>>>>>>        If (bOK = True) Begin
86581>>>>>>>            Move (not(Err)) to bOK
86582>>>>>>>        End
86582>>>>>>>>
86582>>>>>>>
86582>>>>>>>        If (ghoStatusPanel <> 0) Begin
86584>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86585>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86586>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86587>>>>>>>        End
86587>>>>>>>>
86587>>>>>>>
86587>>>>>>>        Function_Return (bOK = True)
86588>>>>>>>    End_Function
86589>>>>>>>
86589>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86589>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86589>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86591>>>>>>>        Handle hFile
86591>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86591>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86591>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86591>>>>>>>        tSQLConnection SQLConnection
86591>>>>>>>        tSQLConnection SQLConnection
86591>>>>>>>        tAPIColumn[] aColumns
86591>>>>>>>        tAPIColumn[] aColumns
86592>>>>>>>        tColumnType ColumnType
86592>>>>>>>        tColumnType ColumnType
86592>>>>>>>
86592>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86592>>>>>>>        Get _UtilTableExists hTable to bOk
86593>>>>>>>        If (bOk = True) Begin
86595>>>>>>>            Function_Return False
86596>>>>>>>        End
86596>>>>>>>>
86596>>>>>>>
86596>>>>>>>        Set Private.phCurrentTable to hTable
86597>>>>>>>        Move sLogicalName to sTableName
86598>>>>>>>        If (ghoProgressBar <> 0) Begin
86600>>>>>>>            Send DoAdvance of ghoProgressBar
86601>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86602>>>>>>>        End
86602>>>>>>>>
86602>>>>>>>
86602>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86603>>>>>>>        Get psDriverID to sDriverID
86604>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86605>>>>>>>        Get piDbType to iDbType
86606>>>>>>>
86606>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86606>>>>>>>        Move False to bDeleteDummy
86607>>>>>>>        If (Num_Arguments = 8) Begin
86609>>>>>>>            Move aColumnIn to aColumns
86610>>>>>>>        End
86610>>>>>>>>
86610>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86612>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86613>>>>>>>            Move ColumnType.iSQLType to iDataType
86614>>>>>>>            If (bRecnum = False) Begin
86616>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86617>>>>>>>            End
86617>>>>>>>>
86617>>>>>>>            Else Begin
86618>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86619>>>>>>>            End
86619>>>>>>>>
86619>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86620>>>>>>>            Move True to bDeleteDummy
86621>>>>>>>        End
86621>>>>>>>>
86621>>>>>>>
86621>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86621>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86621>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86621>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86621>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86623>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86624>>>>>>>            Decrement iSize
86625>>>>>>>            for iCount from 0 to iSize
86631>>>>>>>>
86631>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86633>>>>>>>                    Move False to bRecnum
86634>>>>>>>                    Move iSize to iCount
86635>>>>>>>                End
86635>>>>>>>>
86635>>>>>>>            Loop
86636>>>>>>>>
86636>>>>>>>        End
86636>>>>>>>>
86636>>>>>>>
86636>>>>>>>        // If this is a SQL based driver we also check if the table exists
86636>>>>>>>        // in the SQL back end; in case we do nothing.
86636>>>>>>>        If (bSqlDriver = True) Begin
86638>>>>>>>            // Get all connection properties
86638>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86639>>>>>>>            Move SQLConnection.sSchema to sSchema
86640>>>>>>>            If (sSchema = "") Begin
86642>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86643>>>>>>>            End
86643>>>>>>>>
86643>>>>>>>
86643>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86644>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86644>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86644>>>>>>>            If (bExists = False) Begin
86646>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86647>>>>>>>            End
86647>>>>>>>>
86647>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86647>>>>>>>            // we will just add it to Filelist.cfg
86647>>>>>>>            If (bExists = True) Begin
86649>>>>>>>                If (bExistsInFilelist = False) Begin
86651>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86653>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86654>>>>>>>                    End
86654>>>>>>>>
86654>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86657>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86660>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86663>>>>>>>                    Move False to bSysFile
86664>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86665>>>>>>>                End
86665>>>>>>>>
86665>>>>>>>                Function_Return False
86666>>>>>>>            End
86666>>>>>>>>
86666>>>>>>>        End
86666>>>>>>>>
86666>>>>>>>
86666>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86667>>>>>>>        If (num_arguments > 6) Begin
86669>>>>>>>            If (bANSI = False) Begin
86671>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86672>>>>>>>            End
86672>>>>>>>>
86672>>>>>>>        End
86672>>>>>>>>
86672>>>>>>>
86672>>>>>>>        Move False to Err
86673>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86675>>>>>>>            Move sRootName to sPhysicalFile
86676>>>>>>>        End
86676>>>>>>>>
86676>>>>>>>
86676>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86678>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86679>>>>>>>
86679>>>>>>>            // If DAW driver and we should use a connection id we need to
86679>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86679>>>>>>>            If (bUseConnectionID = True) Begin
86681>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86682>>>>>>>                If (bExists = False) Begin
86684>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86685>>>>>>>                    If (bOk = False) Begin
86687>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86688>>>>>>>>
86688>>>>>>>                        Function_Return False
86689>>>>>>>                    End
86689>>>>>>>>
86689>>>>>>>                End
86689>>>>>>>>
86689>>>>>>>            End
86689>>>>>>>>
86689>>>>>>>
86689>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86691>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86692>>>>>>>            End
86692>>>>>>>>
86692>>>>>>>            Else Begin
86693>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86694>>>>>>>            End
86694>>>>>>>>
86694>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86695>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86695>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86695>>>>>>>//            End
86695>>>>>>>        End
86695>>>>>>>>
86695>>>>>>>        Move False to Err
86696>>>>>>>        Move 0 to hFile
86697>>>>>>>
86697>>>>>>>        Structure_Start hFile sDriverID
86698>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86700>>>>>>>                If (bUseConnectionID = True) Begin
86702>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86705>>>>>>>                End
86705>>>>>>>>
86705>>>>>>>                Else Begin
86706>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86709>>>>>>>                End
86709>>>>>>>>
86709>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86712>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86715>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86718>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86721>>>>>>>
86721>>>>>>>                If (sSchema <> "") Begin
86723>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86726>>>>>>>                End
86726>>>>>>>>
86726>>>>>>>
86726>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86728>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86730>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86733>>>>>>>                    End
86733>>>>>>>>
86733>>>>>>>                End
86733>>>>>>>>
86733>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86735>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86737>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86740>>>>>>>                    End
86740>>>>>>>>
86740>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86742>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86745>>>>>>>                    End
86745>>>>>>>>
86745>>>>>>>                End
86745>>>>>>>>
86745>>>>>>>            End
86745>>>>>>>>
86745>>>>>>>
86745>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86748>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86749>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86750>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86752>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86753>>>>>>>
86753>>>>>>>        Move (not(Err)) to bOK
86754>>>>>>>        If (bOk = True) Begin
86756>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86758>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86759>>>>>>>            End
86759>>>>>>>>
86759>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86762>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86765>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86768>>>>>>>
86768>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86768>>>>>>>            If (bDeleteDummy) Begin
86770>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86771>>>>>>>            End
86771>>>>>>>>
86771>>>>>>>        End
86771>>>>>>>>
86771>>>>>>>
86771>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86772>>>>>>>        Close hTable
86773>>>>>>>        Function_Return (bOK = True)
86774>>>>>>>    End_Function
86775>>>>>>>
86775>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86777>>>>>>>        Move False to Err
86778>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86781>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86784>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86787>>>>>>>
86787>>>>>>>        Function_Return (Err = False)
86788>>>>>>>    End_Function
86789>>>>>>>
86789>>>>>>>    // ToDo: Needs to be revised
86789>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86791>>>>>>>        Handle hTable
86791>>>>>>>        String sDEFName sDataPath
86791>>>>>>>        Boolean bExists
86791>>>>>>>
86791>>>>>>>        // Do nothing if MSSQL Driver.
86791>>>>>>>//        Get IsMSSQLDriver to bExists
86791>>>>>>>//        If (bExists = True) Begin
86791>>>>>>>//            Procedure_Return
86791>>>>>>>//        End
86791>>>>>>>
86791>>>>>>>        Get psDataPathFirstPart to sDataPath
86792>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86793>>>>>>>        If (bExists = True) Begin
86795>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86795>>>>>>>            // still be missing from the filelist and needs to be added.
86795>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86796>>>>>>>            If (bExists = True) Begin
86798>>>>>>>                Procedure_Return
86799>>>>>>>            End
86799>>>>>>>>
86799>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86799>>>>>>>            Else Begin
86800>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86803>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86806>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86809>>>>>>>                Procedure_Return
86810>>>>>>>            End
86810>>>>>>>>
86810>>>>>>>        End
86810>>>>>>>>
86810>>>>>>>
86810>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86811>>>>>>>        Move 0 to hTable
86812>>>>>>>        Move False to Err
86813>>>>>>>
86813>>>>>>>        Structure_Start hTable DATAFLEX_ID
86814>>>>>>>            Load_Def sDEFName Onto hTable
86815>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86818>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86819>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86821>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86822>>>>>>>
86822>>>>>>>        Move iFilelistSlot to hTable
86823>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86826>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86829>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86832>>>>>>>
86832>>>>>>>    End_Procedure
86833>>>>>>>
86833>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86835>>>>>>>        Boolean bTmp bErr bOK
86835>>>>>>>        String sTableName sDisplayName sFileName
86835>>>>>>>
86835>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86835>>>>>>>        Move Err to bTmp
86836>>>>>>>        Move False to Err
86837>>>>>>>
86837>>>>>>>        Get AutoConnectionIDLogin to bOK
86838>>>>>>>        // First get the info for the current filelist slot:
86838>>>>>>>        Open iFromFileSlot
86840>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86843>>>>>>>        If (bOK = True) Begin
86845>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86848>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86851>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86854>>>>>>>
86854>>>>>>>            //...then move it.
86854>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86857>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86860>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86863>>>>>>>
86863>>>>>>>            //...and finally remove the old filelist values.
86863>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86866>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86869>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86872>>>>>>>        End
86872>>>>>>>>
86872>>>>>>>        Close iFromFileSlot
86873>>>>>>>
86873>>>>>>>        Move Err to bErr
86874>>>>>>>        Move bTmp to Err
86875>>>>>>>        Function_Return (bErr = False)
86876>>>>>>>    End_Function
86877>>>>>>>
86877>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86879>>>>>>>        Handle hTable
86879>>>>>>>        Boolean bOK
86879>>>>>>>        String sDriverID
86879>>>>>>>
86879>>>>>>>        Get _UtilTableExists hTableFrom to bOK
86880>>>>>>>        If (bOK = False) Begin
86882>>>>>>>            Set Private.phCurrentTable to hTableFrom
86883>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86884>>>>>>>>
86884>>>>>>>            Function_Return False
86885>>>>>>>        End
86885>>>>>>>>
86885>>>>>>>
86885>>>>>>>        Get _UtilTableExists hTableTo to bOK
86886>>>>>>>        If (bOK = False) Begin
86888>>>>>>>            Set Private.phCurrentTable to hTableTo
86889>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86890>>>>>>>>
86890>>>>>>>            Function_Return False
86891>>>>>>>        End
86891>>>>>>>>
86891>>>>>>>
86891>>>>>>>        Get AutoConnectionIDLogin to bOK
86892>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86893>>>>>>>        If (bOK = False) Begin
86895>>>>>>>            Function_Return False
86896>>>>>>>        End
86896>>>>>>>>
86896>>>>>>>
86896>>>>>>>        Move False to Err
86897>>>>>>>        Open hTableTo
86899>>>>>>>
86899>>>>>>>        Move hTableFrom to hTable
86900>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86903>>>>>>>        Set Private.phCurrentTable to hTable
86904>>>>>>>
86904>>>>>>>        Structure_Start hTable sDriverID
86905>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86908>>>>>>>            If (iColumnTo <> 0) Begin
86910>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86913>>>>>>>            End
86913>>>>>>>>
86913>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86914>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86916>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86917>>>>>>>
86917>>>>>>>        If (hTableTo > 0) Begin
86919>>>>>>>            Close hTableTo
86920>>>>>>>        End
86920>>>>>>>>
86920>>>>>>>
86920>>>>>>>        Function_Return (Err = False)
86921>>>>>>>    End_Function
86922>>>>>>>
86922>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86922>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
86924>>>>>>>        String sTableName sDriverID
86924>>>>>>>        Boolean bOk
86924>>>>>>>        String sDataPath
86924>>>>>>>
86924>>>>>>>        Get AutoConnectionIDLogin to bOK
86925>>>>>>>        Move False to Err
86926>>>>>>>        Get psDriverID to sDriverID
86927>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86928>>>>>>>        If (sTableName = "") Begin
86930>>>>>>>            Function_Return False
86931>>>>>>>        End
86931>>>>>>>>
86931>>>>>>>
86931>>>>>>>        Set Private.phCurrentTable to hTable
86932>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86933>>>>>>>        Delete_db sTableName
86934>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86935>>>>>>>
86935>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86937>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86937>>>>>>>            Get psDataPathFirstPart to sDataPath
86938>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86939>>>>>>>        End
86939>>>>>>>>
86939>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86939>>>>>>>        If (hTable <> 0) Begin
86941>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86944>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86947>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86950>>>>>>>        End
86950>>>>>>>>
86950>>>>>>>
86950>>>>>>>        Close hTable
86951>>>>>>>        Function_Return (hTable <> 0)
86952>>>>>>>    End_Function
86953>>>>>>>
86953>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86955>>>>>>>        Handle hTable
86955>>>>>>>        Boolean bOK
86955>>>>>>>
86955>>>>>>>        Get AutoConnectionIDLogin to bOK
86956>>>>>>>        Move False to Err
86957>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
86959>>>>>>>        Move hTableFrom to hTable
86960>>>>>>>
86960>>>>>>>        Structure_Start hTable
86961>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86964>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86965>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86967>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86968>>>>>>>
86968>>>>>>>        Close hTableFrom
86969>>>>>>>        Function_Return (Err = False)
86970>>>>>>>    End_Function
86971>>>>>>>
86971>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86973>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86973>>>>>>>        Boolean bOK bExists bOpened
86973>>>>>>>        tAPITableNameInfo APITableNameInfo
86973>>>>>>>        tAPITableNameInfo APITableNameInfo
86973>>>>>>>
86973>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86976>>>>>>>        If (bOpened = False) Begin
86978>>>>>>>            Get OpenTableExclusive hTable to bOpened
86979>>>>>>>            If (bOpened = False) Begin
86981>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86982>>>>>>>                Function_Return False
86983>>>>>>>            End
86983>>>>>>>>
86983>>>>>>>        End
86983>>>>>>>>
86983>>>>>>>
86983>>>>>>>        Set Private.phCurrentTable to hTable
86984>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
86985>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
86986>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86987>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86988>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86989>>>>>>>        If (bExists = True) Begin
86991>>>>>>>            Function_Return True
86992>>>>>>>        End
86992>>>>>>>>
86992>>>>>>>
86992>>>>>>>        Set Private.phCurrentTable to hTable
86993>>>>>>>        Move False to Err
86994>>>>>>>        Get psDataPathFirstPart to sDataPath
86995>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86998>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87001>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87004>>>>>>>
87004>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87007>>>>>>>        Close hTable
87008>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87010>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87011>>>>>>>            If (bExists = True) Begin
87013>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87015>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87018>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87018>>>>>>>                    // might report "File in use..." and the deletion will fail.
87018>>>>>>>                    Sleep 2
87019>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87020>>>>>>>                End
87020>>>>>>>>
87020>>>>>>>            End
87020>>>>>>>>
87020>>>>>>>        End
87020>>>>>>>>
87020>>>>>>>
87020>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87022>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87024>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87025>>>>>>>            End
87025>>>>>>>>
87025>>>>>>>
87025>>>>>>>            // Change the table name in the .int file to the new table new:
87025>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87026>>>>>>>            If (bOK = False) Begin
87028>>>>>>>                Function_Return False
87029>>>>>>>            End
87029>>>>>>>>
87029>>>>>>>
87029>>>>>>>            // Change table name at the SQL side:
87029>>>>>>>            Get psSchema to sSchema
87030>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87031>>>>>>>
87031>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87032>>>>>>>            // Remove cache file and Rename the physical file names:
87032>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87033>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87034>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87035>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87036>>>>>>>
87036>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87036>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87036>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87036>>>>>>>//            End
87036>>>>>>>        End
87036>>>>>>>>
87036>>>>>>>
87036>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87039>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87042>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87045>>>>>>>
87045>>>>>>>        Function_Return (Err = False)
87046>>>>>>>    End_Function
87047>>>>>>>
87047>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87049>>>>>>>        Move False to Err
87050>>>>>>>        Set Private.phCurrentTable to hTable
87051>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87054>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87057>>>>>>>
87057>>>>>>>        Function_Return (Err = False)
87058>>>>>>>    End_Function
87059>>>>>>>
87059>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
87059>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87061>>>>>>>        Handle hTable
87061>>>>>>>        String sTableName
87061>>>>>>>        String sDriverIDFrom sDriverIDTo
87061>>>>>>>        Integer iDbType
87061>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto
87061>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87061>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87061>>>>>>>        tSQLConnection SQLConnection
87061>>>>>>>        tSQLConnection SQLConnection
87061>>>>>>>        tAPITable      APITableFrom APITableTo
87061>>>>>>>        tAPITable      APITableFrom APITableTo
87061>>>>>>>        tColumnType    ColumnType
87061>>>>>>>        tColumnType    ColumnType
87061>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87061>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87062>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87062>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87063>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87063>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87064>>>>>>>
87064>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87064>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87066>>>>>>>            Function_Return False
87067>>>>>>>        End
87067>>>>>>>>
87067>>>>>>>
87067>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87068>>>>>>>        Get piDbType                            to iDbType
87069>>>>>>>        Get pbRecnum                            to bRecnum
87070>>>>>>>        Get pbToANSI                            to bToANSI
87071>>>>>>>        Get pbCopyData                          to bCopyData
87072>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87073>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87074>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87075>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87076>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87077>>>>>>>
87077>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87078>>>>>>>        Set Private.phCurrentTable              to hTable
87079>>>>>>>        Get _UtilTableExists  hTable             to bTableExists
87080>>>>>>>
87080>>>>>>>        If (ghoProgressBar <> 0) Begin
87082>>>>>>>            Send DoAdvance of ghoProgressBar
87083>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87084>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87085>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87086>>>>>>>        End
87086>>>>>>>>
87086>>>>>>>
87086>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87087>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87088>>>>>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
87089>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87090>>>>>>>        Move True                               to APITableFrom.bFromTable
87091>>>>>>>        Move hTable                             to APITableFrom.hTable
87092>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87093>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87094>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87095>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87096>>>>>>>
87096>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87098>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87099>>>>>>>            If (bOk = True) Begin
87101>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
87102>>>>>>>                Function_Return bOk
87103>>>>>>>            End 
87103>>>>>>>>
87103>>>>>>>        End
87103>>>>>>>>
87103>>>>>>>
87103>>>>>>>        If (bTableExists = True) Begin
87105>>>>>>>            If (bIsSQLTableTo = True) Begin
87107>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87108>>>>>>>            End
87108>>>>>>>>
87108>>>>>>>
87108>>>>>>>            Get OpenTableExclusive hTable to bOpened
87109>>>>>>>            If (bOpened = False) Begin
87111>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87112>>>>>>>                Function_Return False
87113>>>>>>>            End
87113>>>>>>>>
87113>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87114>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87115>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87116>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87117>>>>>>>        End
87117>>>>>>>>
87117>>>>>>>
87117>>>>>>>        Move False to Err
87118>>>>>>>        Case Begin
87118>>>>>>>            // Alias table:
87118>>>>>>>            Case (bIsAliasFrom = True)
87120>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87121>>>>>>>                Case Break
87122>>>>>>>
87122>>>>>>>            // New Table:
87122>>>>>>>            Case (bTableExists = False)
87125>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87126>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87126>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87128>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87129>>>>>>>                End                                                                 
87129>>>>>>>>
87129>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87130>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87131>>>>>>>                Case Break
87132>>>>>>>
87132>>>>>>>            // Update table:
87132>>>>>>>            Case (bTableExists = True)
87135>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87136>>>>>>>                If (bIsSame = True) Begin
87138>>>>>>>                    Case Break
87139>>>>>>>                End
87139>>>>>>>>
87139>>>>>>>                If (bFilelistError = True) Begin
87141>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87142>>>>>>>                    If (bOk = False) Begin
87144>>>>>>>                        Case Break
87145>>>>>>>                    End
87145>>>>>>>>
87145>>>>>>>                End
87145>>>>>>>>
87145>>>>>>>
87145>>>>>>>                If (ghoProgressBar <> 0) Begin
87147>>>>>>>                    Send DoAdvance of ghoProgressBar
87148>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87149>>>>>>>                End
87149>>>>>>>>
87149>>>>>>>
87149>>>>>>>                // Columns:
87149>>>>>>>                Move True to bOk
87150>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87151>>>>>>>                If (bIsSame = False) Begin
87153>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87154>>>>>>>                End
87154>>>>>>>>
87154>>>>>>>                If (bOk = False) Begin
87156>>>>>>>                    Case Break
87157>>>>>>>                End
87157>>>>>>>>
87157>>>>>>>
87157>>>>>>>                // Indexes:
87157>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87158>>>>>>>                If (bIsSame = False) Begin
87160>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87161>>>>>>>                End
87161>>>>>>>>
87161>>>>>>>
87161>>>>>>>                // Relations:
87161>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87162>>>>>>>                If (bIsSame = False) Begin
87164>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87165>>>>>>>                    If (bOk = False) Begin
87167>>>>>>>                        Case Break
87168>>>>>>>                    End
87168>>>>>>>>
87168>>>>>>>                End
87168>>>>>>>>
87168>>>>>>>
87168>>>>>>>                Case Break
87169>>>>>>>
87169>>>>>>>            Case Else
87169>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87170>>>>>>>>
87170>>>>>>>                Move False to bOk
87171>>>>>>>        Case End
87171>>>>>>>        
87171>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87171>>>>>>>        // or convert an embedded table to SQL
87171>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87173>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87174>>>>>>>            If (bOk = False) Begin
87176>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87177>>>>>>>            End
87177>>>>>>>>
87177>>>>>>>        End
87177>>>>>>>>
87177>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87180>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
87181>>>>>>>        End
87181>>>>>>>>
87181>>>>>>>        
87181>>>>>>>        // Filelist Names:
87181>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87182>>>>>>>        Close hTable
87183>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87184>>>>>>>
87184>>>>>>>        Function_Return (bOK = True)
87185>>>>>>>    End_Function
87186>>>>>>>
87186>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87186>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87188>>>>>>>        Function_Return False
87189>>>>>>>    End_Function
87190>>>>>>>
87190>>>>>>>    // Adds a column name to the passed table number.
87190>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87192>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87192>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87192>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87192>>>>>>>
87192>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87193>>>>>>>        If (bExists = True) Begin
87195>>>>>>>            Function_Return False
87196>>>>>>>        End
87196>>>>>>>>
87196>>>>>>>
87196>>>>>>>        Move False to Err
87197>>>>>>>        If (num_arguments > 4) Begin
87199>>>>>>>            Move iPrec to iPrecision
87200>>>>>>>        End
87200>>>>>>>>
87200>>>>>>>        If (num_arguments > 6) Begin
87202>>>>>>>            Move bInitVal to bInitializeValue
87203>>>>>>>            Move sColVal  to sColumnValue
87204>>>>>>>        End
87204>>>>>>>>
87204>>>>>>>        If (iType < -1490) Begin
87206>>>>>>>            Move (iType + 1500) to iType
87207>>>>>>>        End
87207>>>>>>>>
87207>>>>>>>
87207>>>>>>>        Move hTable to iFile
87208>>>>>>>        Get psDriverID to sDriverID
87209>>>>>>>        Get AutoConnectionIDLogin to bOK
87210>>>>>>>        Move False to Err
87211>>>>>>>        Move LastErr to iLastErr
87212>>>>>>>        Get OpenTableExclusive iFile to bOK
87213>>>>>>>        Set Private.phCurrentTable to hTable
87214>>>>>>>
87214>>>>>>>        Structure_Start iFile sDriverID
87215>>>>>>>            Move 0 to iColumn
87216>>>>>>>            Set Private.piCurrentField to iColumn
87217>>>>>>>            Create_Field hTable At iColumn
87218>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87221>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87224>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87227>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87230>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87231>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87233>>>>>>>
87233>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87234>>>>>>>
87234>>>>>>>        // If in development environment; create .fd file:
87234>>>>>>>        Open hTable
87236>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87237>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87238>>>>>>>        If (iCount > 1) Begin
87240>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87241>>>>>>>        End
87241>>>>>>>>
87241>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87242>>>>>>>        If (bExists = True) Begin
87244>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87245>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87248>>>>>>>            Get _TableNameOnly sTableName to sTableName
87249>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87251>>>>>>>        End
87251>>>>>>>>
87251>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87253>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87254>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87255>>>>>>>            If (iCount > 1) Begin
87257>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87258>>>>>>>            End
87258>>>>>>>>
87258>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87259>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87259>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87259>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87259>>>>>>>        End
87259>>>>>>>>
87259>>>>>>>        // Check for a default value
87259>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87261>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87262>>>>>>>        End
87262>>>>>>>>
87262>>>>>>>        Close hTable
87263>>>>>>>
87263>>>>>>>        Function_Return (Err = False)
87264>>>>>>>    End_Function
87265>>>>>>>
87265>>>>>>>    // Adds a column name to the passed table number.
87265>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87267>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87267>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87267>>>>>>>        String sDdSrcPath sTableName
87267>>>>>>>
87267>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87268>>>>>>>        Move False to Err
87269>>>>>>>        If (bExists = True) Begin
87271>>>>>>>            Function_Return False
87272>>>>>>>        End
87272>>>>>>>>
87272>>>>>>>        If (num_arguments > 4) Begin
87274>>>>>>>            Move iPrec to iPrecision
87275>>>>>>>        End
87275>>>>>>>>
87275>>>>>>>        If (iType < -1490) Begin
87277>>>>>>>            Move (iType + 1500) to iType
87278>>>>>>>        End
87278>>>>>>>>
87278>>>>>>>
87278>>>>>>>        Get AutoConnectionIDLogin to bOK
87279>>>>>>>        Move False to Err
87280>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87281>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87281>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87281>>>>>>>        Get piDbType to iDbType
87282>>>>>>>        If (bIsSQLTypeTo = False) Begin
87284>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87285>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87287>>>>>>>                Move DF_DATE to iType
87288>>>>>>>            End
87288>>>>>>>>
87288>>>>>>>        End
87288>>>>>>>>
87288>>>>>>>
87288>>>>>>>        // Structure_start will change the value of hTable...
87288>>>>>>>        Move hTable to iFile
87289>>>>>>>        Get OpenTableExclusive iFile to bOK
87290>>>>>>>        If (bOK = False) Begin
87292>>>>>>>            Function_Return False
87293>>>>>>>        End
87293>>>>>>>>
87293>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87296>>>>>>>
87296>>>>>>>        // If the passed column number is higher than the current number of fields
87296>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87296>>>>>>>        // a new field to the end:
87296>>>>>>>        If (iColumn > iNumberOfFields) Begin
87298>>>>>>>            Move 0 to iColumn
87299>>>>>>>        End
87299>>>>>>>>
87299>>>>>>>
87299>>>>>>>        Set Private.phCurrentTable to hTable
87300>>>>>>>        Set Private.piCurrentField to iColumn
87301>>>>>>>
87301>>>>>>>        Structure_Start iFile
87302>>>>>>>            Create_Field iFile At iColumn
87303>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87306>>>>>>>            If (bIsSQLTypeTo = False) Begin
87308>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87311>>>>>>>            End
87311>>>>>>>>
87311>>>>>>>            Else Begin
87312>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87315>>>>>>>            End
87315>>>>>>>>
87315>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87316>>>>>>>            If (bIsDateType = False) Begin
87318>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87321>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87324>>>>>>>            End
87324>>>>>>>>
87324>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87325>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87327>>>>>>>
87327>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87328>>>>>>>        // If in development environment; create .fd file:
87328>>>>>>>        Open hTable
87330>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87331>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87332>>>>>>>        If (iCount > 1) Begin
87334>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87335>>>>>>>        End
87335>>>>>>>>
87335>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87336>>>>>>>        If (bExists = True) Begin
87338>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87339>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87342>>>>>>>            Get _TableNameOnly sTableName to sTableName
87343>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87345>>>>>>>        End
87345>>>>>>>>
87345>>>>>>>
87345>>>>>>>        // Check for a default value
87345>>>>>>>        Close hTable
87346>>>>>>>
87346>>>>>>>        Function_Return (Err = False)
87347>>>>>>>    End_Function
87348>>>>>>>
87348>>>>>>>    // To update all records for a table column with a fixed value.
87348>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87350>>>>>>>        Integer iRecs iCurrErr iField iRecord
87350>>>>>>>        Boolean bRetval bOpen
87350>>>>>>>
87350>>>>>>>        Move 0 to iRecs
87351>>>>>>>        Move False to bRetval
87352>>>>>>>        Move Err to iCurrErr
87353>>>>>>>        Move False to Err
87354>>>>>>>
87354>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87357>>>>>>>        If (bOpen = False) Begin
87359>>>>>>>            Open hTable
87361>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87364>>>>>>>            If (bOpen = False) Begin
87366>>>>>>>                Function_Return bRetval
87367>>>>>>>            End
87367>>>>>>>>
87367>>>>>>>        End
87367>>>>>>>>
87367>>>>>>>
87367>>>>>>>        Field_Map hTable sFieldName to iField
87369>>>>>>>        If (iField <> 0) Begin
87371>>>>>>>            Set Private.phCurrentTable to hTable
87372>>>>>>>            Set Private.piCurrentField to iField
87373>>>>>>>            Clear hTable
87374>>>>>>>            Repeat
87374>>>>>>>>
87374>>>>>>>                Vfind hTable 0 GT
87376>>>>>>>                If (Found) Begin
87378>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87380>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87383>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87384>>>>>>>                    End
87384>>>>>>>>
87384>>>>>>>                    Reread hTable
87388>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87391>>>>>>>                        SaveRecord hTable
87392>>>>>>>                    Unlock
87393>>>>>>>>
87393>>>>>>>                End
87393>>>>>>>>
87393>>>>>>>           Until (not(Found))
87395>>>>>>>        End
87395>>>>>>>>
87395>>>>>>>
87395>>>>>>>        Move (Err = False) to bRetval
87396>>>>>>>        Move iCurrErr to Err
87397>>>>>>>
87397>>>>>>>        Function_Return bRetval
87398>>>>>>>    End_Function
87399>>>>>>>
87399>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87399>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87401>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87401>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87401>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87401>>>>>>>
87401>>>>>>>        Get psDriverID to sDriverID
87402>>>>>>>        Get piDbType to iDbType
87403>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87404>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87405>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87406>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87407>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87409>>>>>>>            Move True to bIsSqlTable
87410>>>>>>>        End
87410>>>>>>>>
87410>>>>>>>        Move False to bIsOpen
87411>>>>>>>        If (hTable > 0) Begin
87413>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87416>>>>>>>        End
87416>>>>>>>>
87416>>>>>>>        If (bIsOpen = True) Begin
87418>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87421>>>>>>>        End
87421>>>>>>>>
87421>>>>>>>        Else Begin
87422>>>>>>>            Get pbRecnum to bRecnumTable
87423>>>>>>>        End
87423>>>>>>>>
87423>>>>>>>
87423>>>>>>>        Move False to Err
87424>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87425>>>>>>>        Decrement iSize
87426>>>>>>>        for iCount from 0 to iSize
87432>>>>>>>>
87432>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87433>>>>>>>            If (hTable > 0) Begin
87435>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87436>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87437>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87440>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87441>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87442>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87443>>>>>>>            End
87443>>>>>>>>
87443>>>>>>>            Else Begin
87444>>>>>>>                Move False to bFieldExists
87445>>>>>>>            End
87445>>>>>>>>
87445>>>>>>>
87445>>>>>>>            If (bFieldExists = False) Begin
87447>>>>>>>                Move 0 to iColumn
87448>>>>>>>                Create_Field hTable At iColumn
87449>>>>>>>            End
87449>>>>>>>>
87449>>>>>>>            Else Begin
87450>>>>>>>                Move iCount to iColumn
87451>>>>>>>            End
87451>>>>>>>>
87451>>>>>>>
87451>>>>>>>            Set Private.piCurrentField to iColumn
87452>>>>>>>
87452>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87453>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87456>>>>>>>
87456>>>>>>>            Move aColumns[iCount].iType to iType
87457>>>>>>>            Move (not(iType < -1490)) to bNativeType
87458>>>>>>>            If (iType < -1490) Begin
87460>>>>>>>                Move (iType + 1500) to iType
87461>>>>>>>            End
87461>>>>>>>>
87461>>>>>>>
87461>>>>>>>            If (bIsSqlTable = True) Begin
87463>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87465>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87466>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87469>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87472>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87475>>>>>>>
87475>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87476>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87478>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87479>>>>>>>                    End
87479>>>>>>>>
87479>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87482>>>>>>>
87482>>>>>>>                End
87482>>>>>>>>
87482>>>>>>>                Else Begin
87483>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87486>>>>>>>                End
87486>>>>>>>>
87486>>>>>>>            End
87486>>>>>>>>
87486>>>>>>>            Else Begin
87487>>>>>>>                If (bCreating = False) Begin
87489>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87490>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87492>>>>>>>                        Move DF_DATE to iType
87493>>>>>>>                    End
87493>>>>>>>>
87493>>>>>>>                End
87493>>>>>>>>
87493>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87496>>>>>>>            End
87496>>>>>>>>
87496>>>>>>>
87496>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87497>>>>>>>            If (bIsDateType = False) Begin
87499>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87502>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87505>>>>>>>            End
87505>>>>>>>>
87505>>>>>>>
87505>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87507>>>>>>>                Move 0 to iIndex
87508>>>>>>>                Create_Index hTable at iIndex
87509>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87512>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87515>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87518>>>>>>>
87518>>>>>>>                // If we have an identity table - we must create a primary_key table.
87518>>>>>>>                If (bIsSqlTable = True) Begin
87520>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87523>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87526>>>>>>>                End
87526>>>>>>>>
87526>>>>>>>            End
87526>>>>>>>>
87526>>>>>>>        Loop
87527>>>>>>>>
87527>>>>>>>
87527>>>>>>>        Function_Return (Err = False)
87528>>>>>>>    End_Function
87529>>>>>>>
87529>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87529>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87531>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87531>>>>>>>        Boolean bOK bIsSqlTable
87531>>>>>>>        String sFieldNameTo
87531>>>>>>>
87531>>>>>>>        If (num_arguments > 4) Begin
87533>>>>>>>            Move iPrec to iPrecFrom
87534>>>>>>>        End
87534>>>>>>>>
87534>>>>>>>        If (iTypeFrom < -1490) Begin
87536>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87537>>>>>>>        End
87537>>>>>>>>
87537>>>>>>>
87537>>>>>>>        Get AutoConnectionIDLogin to bOK
87538>>>>>>>        Move False to Err
87539>>>>>>>        Get OpenTableExclusive hTable to bOK
87540>>>>>>>        If (bOK = False) Begin
87542>>>>>>>            Function_Return False
87543>>>>>>>        End
87543>>>>>>>>
87543>>>>>>>
87543>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87544>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87545>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87547>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87548>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87549>>>>>>>        If (Err = True) Begin
87551>>>>>>>            Function_Return False
87552>>>>>>>        End
87552>>>>>>>>
87552>>>>>>>
87552>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87555>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87556>>>>>>>        If (bIsSqlTable = False) Begin
87558>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87561>>>>>>>        End
87561>>>>>>>>
87561>>>>>>>        Else Begin
87562>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87565>>>>>>>        End
87565>>>>>>>>
87565>>>>>>>        // Let the driver decide the other values;
87565>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87568>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87571>>>>>>>
87571>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87573>>>>>>>            Function_Return False
87574>>>>>>>        End
87574>>>>>>>>
87574>>>>>>>
87574>>>>>>>        Set Private.phCurrentTable to hTable
87575>>>>>>>        Set Private.piCurrentField to iColumn
87576>>>>>>>
87576>>>>>>>        Structure_Start hTable
87577>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87580>>>>>>>//            If (bIsSqlTable = False) Begin
87580>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87583>>>>>>>//            End
87583>>>>>>>//            Else Begin
87583>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87583>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87583>>>>>>>//            End
87583>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87586>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87589>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87590>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87592>>>>>>>
87592>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87593>>>>>>>        Function_Return (Err = False)
87594>>>>>>>    End_Function
87595>>>>>>>
87595>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87595>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87597>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87597>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87597>>>>>>>        String sFieldNameTo sDriverIDTo
87597>>>>>>>        tColumnType ColumnType
87597>>>>>>>        tColumnType ColumnType
87597>>>>>>>
87597>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87598>>>>>>>        Get piDbType to iDbType
87599>>>>>>>        If (num_arguments > 4) Begin
87601>>>>>>>            Move iPrec to iPrecFrom
87602>>>>>>>            Move iOpt  to iOptionFrom
87603>>>>>>>        End
87603>>>>>>>>
87603>>>>>>>        If (iTypeFrom < -1490) Begin
87605>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87606>>>>>>>        End
87606>>>>>>>>
87606>>>>>>>
87606>>>>>>>        Get AutoConnectionIDLogin to bOK
87607>>>>>>>        Move False to Err
87608>>>>>>>        Close hTable
87609>>>>>>>        Get OpenTableExclusive hTable to bOK
87610>>>>>>>        If (bOK = False) Begin
87612>>>>>>>            Function_Return False
87613>>>>>>>        End
87613>>>>>>>>
87613>>>>>>>
87613>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87616>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87619>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87620>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87622>>>>>>>            Move DF_DATE to iDataFlexType
87623>>>>>>>        End
87623>>>>>>>>
87623>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87626>>>>>>>
87626>>>>>>>        If (bIsSQLTableTo = True) Begin
87628>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87631>>>>>>>        End
87631>>>>>>>>
87631>>>>>>>        Else Begin
87632>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87635>>>>>>>        End
87635>>>>>>>>
87635>>>>>>>
87635>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87638>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87641>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87644>>>>>>>
87644>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87644>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87644>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87646>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87647>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87649>>>>>>>                Move DF_DATE to iTypeTo  
87650>>>>>>>            End
87650>>>>>>>>
87650>>>>>>>        End
87650>>>>>>>>
87650>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87653>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87654>>>>>>>        End
87654>>>>>>>>
87654>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87655>>>>>>>
87655>>>>>>>        If (bCompareDate_DateTime = False) Begin
87657>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87658>>>>>>>            If (bSkip = True) Begin
87660>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87662>>>>>>>                    Function_Return True
87663>>>>>>>                End
87663>>>>>>>>
87663>>>>>>>            End
87663>>>>>>>>
87663>>>>>>>        End
87663>>>>>>>>
87663>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87666>>>>>>>            Function_Return True
87667>>>>>>>        End
87667>>>>>>>>
87667>>>>>>>
87667>>>>>>>        Set Private.phCurrentTable to hTable
87668>>>>>>>        Set Private.piCurrentField to iColumn
87669>>>>>>>
87669>>>>>>>        Structure_Start hTable
87670>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87672>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87675>>>>>>>            End
87675>>>>>>>>
87675>>>>>>>
87675>>>>>>>            If (bIsSameDataType = False) Begin
87677>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87680>>>>>>>                If (bIsSQLTableTo = True) Begin
87682>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87685>>>>>>>                End
87685>>>>>>>>
87685>>>>>>>            End
87685>>>>>>>>
87685>>>>>>>
87685>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87687>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87690>>>>>>>            End
87690>>>>>>>>
87690>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87692>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87695>>>>>>>            End
87695>>>>>>>>
87695>>>>>>>
87695>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87697>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87697>>>>>>>                If (bRecnumTable = True) Begin
87699>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87702>>>>>>>                End
87702>>>>>>>>
87702>>>>>>>
87702>>>>>>>                // We might need to create an index here.
87702>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87702>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87702>>>>>>>                // index update checking logic.
87702>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87705>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87707>>>>>>>                    Create_Index hTable At iIndex
87708>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87711>>>>>>>                End
87711>>>>>>>>
87711>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87714>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87717>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87720>>>>>>>                If (bIsSQLTableTo = True) Begin
87722>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87725>>>>>>>                End
87725>>>>>>>>
87725>>>>>>>            End
87725>>>>>>>>
87725>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87726>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87728>>>>>>>
87728>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87729>>>>>>>        Function_Return (Err = False)
87730>>>>>>>    End_Function
87731>>>>>>>
87731>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87733>>>>>>>        Boolean bOK
87733>>>>>>>
87733>>>>>>>        Get AutoConnectionIDLogin to bOK
87734>>>>>>>        Move False to Err
87735>>>>>>>        Get OpenTableExclusive hTable to bOK
87736>>>>>>>        If (bOK = False) Begin
87738>>>>>>>            Function_Return False
87739>>>>>>>        End
87739>>>>>>>>
87739>>>>>>>
87739>>>>>>>        Structure_Start hTable
87740>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87743>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87744>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87746>>>>>>>
87746>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87747>>>>>>>        Function_Return (Err = False)
87748>>>>>>>    End_Function
87749>>>>>>>
87749>>>>>>>    // To move an existing field to another position in a table.
87749>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87751>>>>>>>        String sColumn sDriverID
87751>>>>>>>        Integer iType
87751>>>>>>>        Boolean bOK bIsDate
87751>>>>>>>
87751>>>>>>>        Close hTable
87752>>>>>>>        Get AutoConnectionIDLogin to bOK
87753>>>>>>>        Get OpenTableExclusive hTable to bOK
87754>>>>>>>        If (bOK = False) Begin
87756>>>>>>>            Function_Return False
87757>>>>>>>        End
87757>>>>>>>>
87757>>>>>>>
87757>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87760>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87762>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87763>>>>>>>>
87763>>>>>>>            Function_Return False
87764>>>>>>>        End
87764>>>>>>>>
87764>>>>>>>
87764>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87767>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87770>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87771>>>>>>>
87771>>>>>>>        Set Private.phCurrentTable to hTable
87772>>>>>>>        Set Private.piCurrentField to iOld
87773>>>>>>>
87773>>>>>>>//        If (bIsDate = False) Begin
87773>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87773>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87773>>>>>>>//        End
87773>>>>>>>//        Else Begin
87773>>>>>>>//            Move 6 to iLength
87773>>>>>>>//            Move 0 to iPrecision
87773>>>>>>>//        End
87773>>>>>>>
87773>>>>>>>        Move False to Err
87774>>>>>>>
87774>>>>>>>        Structure_Start hTable
87775>>>>>>>            Delete_Field hTable iOld
87776>>>>>>>            Create_Field hTable At iNew
87777>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87780>>>>>>>
87780>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87783>>>>>>>            If (bIsSQLType = False) Begin
87785>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87788>>>>>>>            End
87788>>>>>>>>
87788>>>>>>>            Else Begin
87789>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87792>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87792>>>>>>>            End
87792>>>>>>>>
87792>>>>>>>
87792>>>>>>>            If (bIsDate = False) Begin
87794>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87797>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87800>>>>>>>            End
87800>>>>>>>>
87800>>>>>>>
87800>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87801>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87803>>>>>>>
87803>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87804>>>>>>>        Function_Return (Err = False)
87805>>>>>>>    End_Function
87806>>>>>>>
87806>>>>>>>    // Deletes a column name for the passed table number (and column number).
87806>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87808>>>>>>>        Integer iColumn
87808>>>>>>>        Boolean bOK
87808>>>>>>>
87808>>>>>>>        Get AutoConnectionIDLogin to bOK
87809>>>>>>>        Move False to Err
87810>>>>>>>        Close hTable
87811>>>>>>>        Get OpenTableExclusive hTable to bOK
87812>>>>>>>        If (bOK = False) Begin
87814>>>>>>>            Function_Return False
87815>>>>>>>        End
87815>>>>>>>>
87815>>>>>>>
87815>>>>>>>        If (not(Err)) Begin
87817>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87818>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87819>>>>>>>            Field_Map hTable sFieldName to iColumn
87821>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87822>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87823>>>>>>>            If (iColumn = 0) Begin
87825>>>>>>>                Move 0 to LastErr
87826>>>>>>>                Function_Return False
87827>>>>>>>            End
87827>>>>>>>>
87827>>>>>>>            Move False to Err
87828>>>>>>>
87828>>>>>>>            Set Private.phCurrentTable to hTable
87829>>>>>>>            Set Private.piCurrentField to iColumn
87830>>>>>>>
87830>>>>>>>            Structure_Start hTable
87831>>>>>>>                Delete_Field hTable iColumn
87832>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87833>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87835>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87836>>>>>>>        End
87836>>>>>>>>
87836>>>>>>>        Else Begin
87837>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87838>>>>>>>>
87838>>>>>>>        End
87838>>>>>>>>
87838>>>>>>>
87838>>>>>>>        Function_Return (Err = False)
87839>>>>>>>    End_Function
87840>>>>>>>
87840>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87840>>>>>>>    // Returns True if no errors occured.
87840>>>>>>>    // Sample usage:
87840>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87840>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87842>>>>>>>        Integer iField
87842>>>>>>>        Boolean bOK bExists bIsOpen
87842>>>>>>>
87842>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87843>>>>>>>        If (bExists = True) Begin
87845>>>>>>>            Function_Return False
87846>>>>>>>        End
87846>>>>>>>>
87846>>>>>>>
87846>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87846>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87846>>>>>>>        Close hTable
87847>>>>>>>        Open hTable
87849>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87852>>>>>>>        If (bIsOpen = False) Begin
87854>>>>>>>            Function_Return False
87855>>>>>>>        End
87855>>>>>>>>
87855>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87856>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87857>>>>>>>        Field_Map hTable sOldFieldName to iField
87859>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87860>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87861>>>>>>>
87861>>>>>>>        Get AutoConnectionIDLogin to bOK
87862>>>>>>>        Get OpenTableExclusive hTable to bOK
87863>>>>>>>        If (bOK = False) Begin
87865>>>>>>>            Function_Return False
87866>>>>>>>        End
87866>>>>>>>>
87866>>>>>>>
87866>>>>>>>        Move False to Err
87867>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87868>>>>>>>        Set Private.phCurrentTable to hTable
87869>>>>>>>        Set Private.piCurrentField to iField
87870>>>>>>>
87870>>>>>>>        If (iField > 0) Begin
87872>>>>>>>            Structure_Start hTable
87873>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87876>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87877>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87879>>>>>>>        End
87879>>>>>>>>
87879>>>>>>>        Else Begin
87880>>>>>>>            Move 0 to LastErr
87881>>>>>>>            Move False to Err
87882>>>>>>>        End
87882>>>>>>>>
87882>>>>>>>
87882>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87883>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87884>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87885>>>>>>>
87885>>>>>>>        Function_Return (Err = False)
87886>>>>>>>    End_Function
87887>>>>>>>
87887>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87889>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87889>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87890>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87890>>>>>>>        Boolean bRenameField
87890>>>>>>>
87890>>>>>>>        Open hTable
87892>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87893>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87894>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87895>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87898>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87899>>>>>>>        Decrement iSize
87900>>>>>>>        for iCount from 0 to iSize
87906>>>>>>>>
87906>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87908>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87909>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87910>>>>>>>
87910>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87912>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87914>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87915>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87916>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87918>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87919>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87920>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87921>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87922>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87923>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87924>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87925>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87926>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87927>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87928>>>>>>>                        Increment iItem
87929>>>>>>>                    End
87929>>>>>>>>
87929>>>>>>>                End
87929>>>>>>>>
87929>>>>>>>            End
87929>>>>>>>>
87929>>>>>>>        Loop
87930>>>>>>>>
87930>>>>>>>
87930>>>>>>>        Move False to Err
87931>>>>>>>        Move 0 to LastErr
87932>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87933>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87934>>>>>>>        Function_Return aAPIColumnsToInsert
87935>>>>>>>    End_Function
87936>>>>>>>
87936>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87938>>>>>>>        Integer iSize iCount
87938>>>>>>>        Boolean bOK
87938>>>>>>>        tAPIColumn[] aColumnsTo
87938>>>>>>>        tAPIColumn[] aColumnsTo
87939>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87939>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87940>>>>>>>
87940>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87941>>>>>>>        If (iSize = 0) Begin
87943>>>>>>>            Function_Return True
87944>>>>>>>        End
87944>>>>>>>>
87944>>>>>>>
87944>>>>>>>        Move False to Err
87945>>>>>>>        Decrement iSize
87946>>>>>>>        for iCount from 0 to iSize
87952>>>>>>>>
87952>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87953>>>>>>>        Loop
87954>>>>>>>>
87954>>>>>>>
87954>>>>>>>        Function_Return bOK
87955>>>>>>>    End_Function
87956>>>>>>>
87956>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
87956>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87958>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87958>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87959>>>>>>>        Integer iSize iCount iItem iShouldMove
87959>>>>>>>
87959>>>>>>>        Move 0 to iItem
87960>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87961>>>>>>>        Decrement iSize
87962>>>>>>>        for iCount from 0 to iSize
87968>>>>>>>>
87968>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87970>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87971>>>>>>>                If (iShouldMove <> -1) Begin
87973>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87974>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87975>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87976>>>>>>>                    Increment iItem
87977>>>>>>>                End
87977>>>>>>>>
87977>>>>>>>            End
87977>>>>>>>>
87977>>>>>>>        Loop
87978>>>>>>>>
87978>>>>>>>
87978>>>>>>>        Move False to Err
87979>>>>>>>        Move 0 to LastErr
87980>>>>>>>        Function_Return aAPIColumnsToMove
87981>>>>>>>    End_Function
87982>>>>>>>
87982>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87984>>>>>>>        Integer iSize iCount
87984>>>>>>>        Boolean bOK
87984>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87984>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87985>>>>>>>
87985>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87986>>>>>>>        If (iSize = 0) Begin
87988>>>>>>>            Function_Return True
87989>>>>>>>        End
87989>>>>>>>>
87989>>>>>>>
87989>>>>>>>        Move False to Err
87990>>>>>>>        Decrement iSize
87991>>>>>>>        for iCount from 0 to iSize
87997>>>>>>>>
87997>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87998>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87999>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88001>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88002>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
88003>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88004>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88005>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
88007>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88008>>>>>>>                    Decrement iSize
88009>>>>>>>                    Move 0 to iCount
88010>>>>>>>                End
88010>>>>>>>>
88010>>>>>>>            End
88010>>>>>>>>
88010>>>>>>>        Loop
88011>>>>>>>>
88011>>>>>>>
88011>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88012>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
88013>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88015>>>>>>>            Move 0 to LastErr
88016>>>>>>>        End
88016>>>>>>>>
88016>>>>>>>        Function_Return bOK
88017>>>>>>>    End_Function
88018>>>>>>>
88018>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88018>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88018>>>>>>>    // - The "FROM" field name is <> "TO" field name
88018>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88018>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88018>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88020>>>>>>>        Boolean bShouldRename
88020>>>>>>>        String sFieldNameFrom sFieldNameTo
88020>>>>>>>
88020>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88021>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88022>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88024>>>>>>>            Function_Return False
88025>>>>>>>        End
88025>>>>>>>>
88025>>>>>>>
88025>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88026>>>>>>>//        If (bShouldRename = False) Begin
88026>>>>>>>//            Function_Return False
88026>>>>>>>//        End
88026>>>>>>>//
88026>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88026>>>>>>>//            Function_Return True
88026>>>>>>>//        End
88026>>>>>>>
88026>>>>>>>        Function_Return bShouldRename
88027>>>>>>>    End_Function
88028>>>>>>>
88028>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88028>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88028>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88030>>>>>>>        Integer iCount iSize iRetval
88030>>>>>>>        String sFieldNameFrom
88030>>>>>>>
88030>>>>>>>        Move -1 to iRetval
88031>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88033>>>>>>>            Function_Return iRetval
88034>>>>>>>        End
88034>>>>>>>>
88034>>>>>>>
88034>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88035>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88036>>>>>>>        Decrement iSize
88037>>>>>>>        for iCount from 0 to iSize
88043>>>>>>>>
88043>>>>>>>            // We're only interested in fields other than the passed field/column number:
88043>>>>>>>            If (iCount <> iColumn) Begin
88045>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88047>>>>>>>                    Move (iCount + 1) to iRetval
88048>>>>>>>                End
88048>>>>>>>>
88048>>>>>>>            End
88048>>>>>>>>
88048>>>>>>>        Loop
88049>>>>>>>>
88049>>>>>>>
88049>>>>>>>        Move 0 to LastErr
88050>>>>>>>        Function_Return iRetval
88051>>>>>>>    End_Function
88052>>>>>>>
88052>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88054>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88054>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88055>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88055>>>>>>>        Boolean bRenameField
88055>>>>>>>
88055>>>>>>>        Open hTable
88057>>>>>>>        Move 0 to iItem
88058>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88059>>>>>>>        Decrement iSize
88060>>>>>>>        for iCount from 0 to iSize
88066>>>>>>>>
88066>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88068>>>>>>>                // Check if the field exists in another position (other field number)
88068>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88069>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88070>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88072>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88073>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88074>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88075>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88076>>>>>>>                    Increment iItem
88077>>>>>>>                End
88077>>>>>>>>
88077>>>>>>>            End
88077>>>>>>>>
88077>>>>>>>        Loop
88078>>>>>>>>
88078>>>>>>>
88078>>>>>>>        Move False to Err
88079>>>>>>>        Move 0 to LastErr
88080>>>>>>>        Function_Return aAPIColumnsToRename
88081>>>>>>>    End_Function
88082>>>>>>>
88082>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88084>>>>>>>        Integer iSize iCount
88084>>>>>>>        Boolean bOK
88084>>>>>>>        tAPIColumn[] aColumnsTo
88084>>>>>>>        tAPIColumn[] aColumnsTo
88085>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88085>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88086>>>>>>>
88086>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88087>>>>>>>        If (iSize = 0) Begin
88089>>>>>>>            Function_Return True
88090>>>>>>>        End
88090>>>>>>>>
88090>>>>>>>
88090>>>>>>>        Move False to Err
88091>>>>>>>        Decrement iSize
88092>>>>>>>        For iCount from 0 to iSize
88098>>>>>>>>
88098>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88099>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88100>>>>>>>        Loop
88101>>>>>>>>
88101>>>>>>>
88101>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88102>>>>>>>        Function_Return bOK
88103>>>>>>>    End_Function
88104>>>>>>>
88104>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88106>>>>>>>        Boolean bDateType
88106>>>>>>>
88106>>>>>>>        If (bIsSQLTableTo = True) Begin
88108>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88109>>>>>>>        End
88109>>>>>>>>
88109>>>>>>>        Else Begin
88110>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88111>>>>>>>        End
88111>>>>>>>>
88111>>>>>>>
88111>>>>>>>        Function_Return bDateType
88112>>>>>>>    End_Function
88113>>>>>>>
88113>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88115>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88115>>>>>>>        Integer iCount2 iColumn2
88115>>>>>>>        Handle hFile
88115>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88115>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88115>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88115>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88115>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88120>>>>>>>        tColumnType ColumnType
88120>>>>>>>        tColumnType ColumnType
88120>>>>>>>
88120>>>>>>>        Move False to Err
88121>>>>>>>        Close hTable
88122>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88123>>>>>>>        If (bIsOpen = False) Begin
88125>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88126>>>>>>>>
88126>>>>>>>            Function_Return False
88127>>>>>>>        End 
88127>>>>>>>>
88127>>>>>>>        
88127>>>>>>>        Get piDbType to iDbType
88128>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88131>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88132>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88133>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88136>>>>>>>
88136>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88137>>>>>>>
88137>>>>>>>        // Before we start to change the table we need to do three things;
88137>>>>>>>        // 1) Insert any new fields
88137>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88138>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88140>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88141>>>>>>>            If (bOK = False) Begin
88143>>>>>>>                Function_Return False
88144>>>>>>>            End
88144>>>>>>>>
88144>>>>>>>            // Update info with changes made.
88144>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88145>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88146>>>>>>>        End
88146>>>>>>>>
88146>>>>>>>
88146>>>>>>>        // 2) Move fields with same names
88146>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88147>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88149>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88150>>>>>>>            If (bOK = False) Begin
88152>>>>>>>                Function_Return False
88153>>>>>>>            End
88153>>>>>>>>
88153>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88154>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88155>>>>>>>        End
88155>>>>>>>>
88155>>>>>>>        
88155>>>>>>>        // 3) Rename fields
88155>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88156>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88158>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88159>>>>>>>            If (bOK = False) Begin
88161>>>>>>>                Function_Return False
88162>>>>>>>            End
88162>>>>>>>>
88162>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88163>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88164>>>>>>>        End
88164>>>>>>>>
88164>>>>>>>
88164>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88164>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88164>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88164>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88164>>>>>>>//            If (bOK = False) Begin
88164>>>>>>>//                Function_Return False
88164>>>>>>>//            End
88164>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88164>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88164>>>>>>>//        End
88164>>>>>>>
88164>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88164>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88166>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88167>>>>>>>            If (bIsSame = True) Begin
88169>>>>>>>                Function_Return True
88170>>>>>>>            End
88170>>>>>>>>
88170>>>>>>>        End
88170>>>>>>>>
88170>>>>>>>
88170>>>>>>>        // We can now continue to make standard field changes:
88170>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88171>>>>>>>        Set Private.phCurrentTable to hTable
88172>>>>>>>        Move hTable to hFile
88173>>>>>>>        Structure_Start hFile sDriverIDTo
88174>>>>>>>
88174>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88175>>>>>>>            Decrement iColumns
88176>>>>>>>            for iCount from 0 to iColumns
88182>>>>>>>>
88182>>>>>>>                Send DoAdvance of ghoProgressBar
88183>>>>>>>
88183>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88184>>>>>>>                Set Private.piCurrentField                  to iColumn
88185>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88186>>>>>>>                If (bIsSame = False) Begin
88188>>>>>>>
88188>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88189>>>>>>>                    If (bFieldExistsFrom = True) Begin
88191>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88192>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88193>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88194>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88195>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88196>>>>>>>
88196>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88197>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88198>>>>>>>                        If (iTypeFrom < -1490) Begin
88200>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88201>>>>>>>                        End
88201>>>>>>>>
88201>>>>>>>
88201>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88201>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88201>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88203>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88204>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88206>>>>>>>                                Move DF_DATE to iTypeFrom
88207>>>>>>>                            End
88207>>>>>>>>
88207>>>>>>>                        End
88207>>>>>>>>
88207>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88210>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88211>>>>>>>                        End
88211>>>>>>>>
88211>>>>>>>
88211>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88212>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88213>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88214>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88215>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88216>>>>>>>
88216>>>>>>>                        Move False to bSkipTypeChange
88217>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88219>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88220>>>>>>>                        End
88220>>>>>>>>
88220>>>>>>>
88220>>>>>>>                        If (bFieldExistsTo = False) Begin
88222>>>>>>>                            Move 0 to iColumn
88223>>>>>>>                            Create_Field hFile At iColumn
88224>>>>>>>                            Set Private.piCurrentField to iColumn
88225>>>>>>>                        End
88225>>>>>>>>
88225>>>>>>>
88225>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88227>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88230>>>>>>>                        End
88230>>>>>>>>
88230>>>>>>>
88230>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88232>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88235>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88236>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88238>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88239>>>>>>>                            End
88239>>>>>>>>
88239>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88242>>>>>>>                        End
88242>>>>>>>>
88242>>>>>>>
88242>>>>>>>                        If (bSkipTypeChange = False) Begin
88244>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88246>>>>>>>                                If (bIsSQLTableTo = True) Begin
88248>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88251>>>>>>>                                End
88251>>>>>>>>
88251>>>>>>>                                Else Begin                                                   
88252>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88254>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88255>>>>>>>                                    End
88255>>>>>>>>
88255>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88258>>>>>>>                                End
88258>>>>>>>>
88258>>>>>>>                            End
88258>>>>>>>>
88258>>>>>>>                        End
88258>>>>>>>>
88258>>>>>>>
88258>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88259>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88259>>>>>>>                        If (bIsDateType = False) Begin
88261>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88263>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88266>>>>>>>                            End
88266>>>>>>>>
88266>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88268>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88271>>>>>>>                            End
88271>>>>>>>>
88271>>>>>>>                        End
88271>>>>>>>>
88271>>>>>>>
88271>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88273>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88273>>>>>>>                            If (bRecnumTable = True) Begin
88275>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88278>>>>>>>                            End
88278>>>>>>>>
88278>>>>>>>
88278>>>>>>>                            // We might need to create an index here.
88278>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88278>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88278>>>>>>>                            // index update checking logic.
88278>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88281>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88283>>>>>>>                                Create_Index hFile at iIndex
88284>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88287>>>>>>>                            End
88287>>>>>>>>
88287>>>>>>>
88287>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88290>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88293>>>>>>>                                // Note: The order here is crucial!
88293>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88296>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88299>>>>>>>                        End
88299>>>>>>>>
88299>>>>>>>                    End
88299>>>>>>>>
88299>>>>>>>                    Else Begin
88300>>>>>>>                        Delete_Field hFile iColumn
88301>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88302>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88303>>>>>>>                        Decrement iCount2
88304>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88304>>>>>>>                        // starting with the array number we just deleted the field for.
88304>>>>>>>                        for iColumn2 from iCount to iCount2
88310>>>>>>>>
88310>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88311>>>>>>>                        Loop
88312>>>>>>>>
88312>>>>>>>                        Decrement iCount
88313>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88314>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88315>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88317>>>>>>>                            Move iColumns to iCount 
88318>>>>>>>                        End
88318>>>>>>>>
88318>>>>>>>                    End
88318>>>>>>>>
88318>>>>>>>                End
88318>>>>>>>>
88318>>>>>>>            Loop
88319>>>>>>>>
88319>>>>>>>
88319>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88320>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88322>>>>>>>
88322>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88323>>>>>>>        Function_Return (Err = False)
88324>>>>>>>    End_Function
88325>>>>>>>
88325>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88325>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88327>>>>>>>        Function_Return False
88328>>>>>>>    End_Function
88329>>>>>>>
88329>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88329>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88329>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88329>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88331>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88331>>>>>>>        String sDriverID
88331>>>>>>>        Boolean bOK bExists bIsSQLTable
88331>>>>>>>
88331>>>>>>>        Get AutoConnectionIDLogin to bOK
88332>>>>>>>        Get OpenTableExclusive hTable to bOK
88333>>>>>>>        If (bOK = False) Begin
88335>>>>>>>            Function_Return False
88336>>>>>>>        End
88336>>>>>>>>
88336>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88339>>>>>>>
88339>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88340>>>>>>>            If (bIsSQLTable = True) Begin
88342>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88345>>>>>>>            End
88345>>>>>>>>
88345>>>>>>>
88345>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88348>>>>>>>        Move (iIndexSegments > 0) to bExists
88349>>>>>>>        If (bExists = True) Begin
88351>>>>>>>            Function_Return True
88352>>>>>>>        End
88352>>>>>>>>
88352>>>>>>>
88352>>>>>>>        Move -1 to iSegment1
88353>>>>>>>        Move -1 to iSegment2
88354>>>>>>>        Move -1 to iSegment3
88355>>>>>>>        Move -1 to iSegment4
88356>>>>>>>        Move -1 to iSegment5
88357>>>>>>>        Move -1 to iSegment6
88358>>>>>>>        Move -1 to iSegment7
88359>>>>>>>        Move -1 to iSegment8
88360>>>>>>>        Move -1 to iSegment9
88361>>>>>>>        Move -1 to iSegment10
88362>>>>>>>
88362>>>>>>>        If (num_arguments > 3) Begin
88364>>>>>>>            Move iSgmnt1 to iSegment1
88365>>>>>>>        End
88365>>>>>>>>
88365>>>>>>>        If (num_arguments > 4) Begin
88367>>>>>>>            Move iSgmnt2 to iSegment2
88368>>>>>>>        End
88368>>>>>>>>
88368>>>>>>>        If (num_arguments > 5) Begin
88370>>>>>>>            Move iSgmnt3 to iSegment3
88371>>>>>>>        End
88371>>>>>>>>
88371>>>>>>>        If (num_arguments > 6) Begin
88373>>>>>>>            Move iSgmnt4 to iSegment4
88374>>>>>>>        End
88374>>>>>>>>
88374>>>>>>>        If (num_arguments > 7) Begin
88376>>>>>>>            Move iSgmnt5 to iSegment5
88377>>>>>>>        End
88377>>>>>>>>
88377>>>>>>>        If (num_arguments > 8) Begin
88379>>>>>>>            Move iSgmnt6 to iSegment6
88380>>>>>>>        End
88380>>>>>>>>
88380>>>>>>>        If (num_arguments > 9) Begin
88382>>>>>>>            Move iSgmnt7 to iSegment7
88383>>>>>>>        End
88383>>>>>>>>
88383>>>>>>>        If (num_arguments > 10) Begin
88385>>>>>>>            Move iSgmnt8 to iSegment8
88386>>>>>>>        End
88386>>>>>>>>
88386>>>>>>>        If (num_arguments > 11) Begin
88388>>>>>>>            Move iSgmnt9 to iSegment9
88389>>>>>>>        End
88389>>>>>>>>
88389>>>>>>>        If (num_arguments > 12) Begin
88391>>>>>>>            Move iSgmnt10 to iSegment10
88392>>>>>>>        End
88392>>>>>>>>
88392>>>>>>>
88392>>>>>>>        Move False to Err
88393>>>>>>>        Move hTable to iTableNo
88394>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88395>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88396>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88397>>>>>>>
88397>>>>>>>        // We start by deleting the index, if it exists.
88397>>>>>>>        If (bExists = True) Begin
88399>>>>>>>            Structure_Start hTable sDriverID
88400>>>>>>>                Delete_Index iTableNo iIndex
88401>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88402>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88404>>>>>>>        End
88404>>>>>>>>
88404>>>>>>>
88404>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88405>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88406>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88407>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88408>>>>>>>        Move False to Err
88409>>>>>>>        Move 0 to LastErr
88410>>>>>>>
88410>>>>>>>        // Need to re-open if index deleted.
88410>>>>>>>        Move iTableNo to hTable
88411>>>>>>>        Get OpenTableExclusive hTable to bOK
88412>>>>>>>        If (bOK = False) Begin
88414>>>>>>>            Function_Return False
88415>>>>>>>        End
88415>>>>>>>>
88415>>>>>>>
88415>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88416>>>>>>>        Structure_Start hTable sDriverID
88417>>>>>>>            Create_Index hTable At iIndex
88418>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88421>>>>>>>
88421>>>>>>>            If (iSgmnt1 <> -1) Begin
88423>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88426>>>>>>>            End
88426>>>>>>>>
88426>>>>>>>            If (iSegment2 <> -1) Begin
88428>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88431>>>>>>>            End
88431>>>>>>>>
88431>>>>>>>            If (iSegment3 <> -1) Begin
88433>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88436>>>>>>>            End
88436>>>>>>>>
88436>>>>>>>            If (iSegment4 <> -1) Begin
88438>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88441>>>>>>>            End
88441>>>>>>>>
88441>>>>>>>            If (iSegment5 <> -1) Begin
88443>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88446>>>>>>>            End
88446>>>>>>>>
88446>>>>>>>            If (iSegment6 <> -1) Begin
88448>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88451>>>>>>>            End
88451>>>>>>>>
88451>>>>>>>            If (iSegment7 <> -1) Begin
88453>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88456>>>>>>>            End
88456>>>>>>>>
88456>>>>>>>            If (iSegment8 <> -1) Begin
88458>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88461>>>>>>>            End
88461>>>>>>>>
88461>>>>>>>            If (iSegment9 <> -1) Begin
88463>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88466>>>>>>>            End
88466>>>>>>>>
88466>>>>>>>            If (iSegment10 <> -1) Begin
88468>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88471>>>>>>>            End
88471>>>>>>>>
88471>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88472>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88474>>>>>>>
88474>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88475>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88476>>>>>>>
88476>>>>>>>        Function_Return (Err = False)
88477>>>>>>>    End_Function
88478>>>>>>>
88478>>>>>>>    // Example:
88478>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88478>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88478>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88480>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88480>>>>>>>        String sDriverID
88480>>>>>>>        Boolean bOK bIsSQLTable
88480>>>>>>>
88480>>>>>>>        Get AutoConnectionIDLogin to bOK
88481>>>>>>>
88481>>>>>>>        Move False to Err
88482>>>>>>>        Move hTable to iTableNo
88483>>>>>>>        Get OpenTableExclusive hTable to bOK
88484>>>>>>>        If (bOK = False) Begin
88486>>>>>>>            Function_Return False
88487>>>>>>>        End
88487>>>>>>>>
88487>>>>>>>
88487>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88490>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88491>>>>>>>            If (bIsSQLTable = True) Begin
88493>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88496>>>>>>>            End
88496>>>>>>>>
88496>>>>>>>
88496>>>>>>>        // We start by deleting the index
88496>>>>>>>        Structure_Start hTable sDriverID
88497>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88498>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88499>>>>>>>            Delete_Index iTableNo iIndex
88500>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88501>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88502>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88504>>>>>>>
88504>>>>>>>        Move False to Err
88505>>>>>>>        Move iTableNo to hTable
88506>>>>>>>        Get OpenTableExclusive hTable to bOK
88507>>>>>>>        If (bOK = False) Begin
88509>>>>>>>            Function_Return False
88510>>>>>>>        End
88510>>>>>>>>
88510>>>>>>>
88510>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88511>>>>>>>        Structure_Start hTable sDriverID
88512>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88513>>>>>>>
88513>>>>>>>            Create_Index hTable at iIndex
88514>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88517>>>>>>>
88517>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88523>>>>>>>>
88523>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88526>>>>>>>            Loop
88527>>>>>>>>
88527>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88529>>>>>>>
88529>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88530>>>>>>>
88530>>>>>>>        Function_Return (Err = False)
88531>>>>>>>    End_Function
88532>>>>>>>
88532>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88534>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88534>>>>>>>        String sDriverID sSQLIndexName
88534>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88534>>>>>>>
88534>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88535>>>>>>>        If (iSegmentsFrom = 0) Begin
88537>>>>>>>            Function_Return False
88538>>>>>>>        End
88538>>>>>>>>
88538>>>>>>>
88538>>>>>>>        Get AutoConnectionIDLogin to bOK
88539>>>>>>>        Move False to Err
88540>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88541>>>>>>>        If (bIsOpen = False) Begin
88543>>>>>>>            Function_Return False
88544>>>>>>>        End
88544>>>>>>>>
88544>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88547>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88548>>>>>>>            If (bIsSQLTable = True) Begin
88550>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88553>>>>>>>            End
88553>>>>>>>>
88553>>>>>>>
88553>>>>>>>        Move 0     to iSegmentsTo
88554>>>>>>>        Move 0     to iSQLIndexType
88555>>>>>>>        Move ""    to sSQLIndexName
88556>>>>>>>        Move False to bIsSQLTemporaryIndex
88557>>>>>>>        Move False to bIsSQLPrimaryKey
88558>>>>>>>        Move False to bIsSQLClustered
88559>>>>>>>
88559>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88560>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88563>>>>>>>        Move (iSegmentsTo > 0) to bExists
88564>>>>>>>        If (bExists = True) Begin
88566>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88568>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88571>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88574>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88575>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88578>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88581>>>>>>>            End
88581>>>>>>>>
88581>>>>>>>        End
88581>>>>>>>>
88581>>>>>>>
88581>>>>>>>        Move hTable to iTableNo
88582>>>>>>>        Move False to Err
88583>>>>>>>        Move 0 to LastErr
88584>>>>>>>
88584>>>>>>>        Structure_Start hTable sDriverID
88585>>>>>>>            If (bExists = True) Begin
88587>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88588>>>>>>>            End
88588>>>>>>>>
88588>>>>>>>
88588>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88589>>>>>>>
88589>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88591>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88594>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88597>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88600>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88603>>>>>>>                End
88603>>>>>>>>
88603>>>>>>>
88603>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88606>>>>>>>
88606>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88612>>>>>>>>
88612>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88613>>>>>>>                If (iFieldFrom <> -1 ) Begin
88615>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88618>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88621>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88624>>>>>>>                End
88624>>>>>>>>
88624>>>>>>>            Loop
88625>>>>>>>>
88625>>>>>>>
88625>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88626>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88628>>>>>>>
88628>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88629>>>>>>>
88629>>>>>>>        Function_Return (Err = False)
88630>>>>>>>    End_Function
88631>>>>>>>
88631>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88631>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88631>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88633>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88633>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88633>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
88633>>>>>>>
88633>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88634>>>>>>>        
88634>>>>>>>        If (bIsSQLDriver = False) Begin
88636>>>>>>>            Function_Return False
88637>>>>>>>        End
88637>>>>>>>>
88637>>>>>>>
88637>>>>>>>        Move False to Err
88638>>>>>>>        Move hTable to iTableNo
88639>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88642>>>>>>>        for iCount from 0 to iLastIndex
88648>>>>>>>>
88648>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88651>>>>>>>            Move (iSegments > 0) to bExists
88652>>>>>>>            If (bExists = True) Begin
88654>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88657>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88659>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88660>>>>>>>                    Structure_Start iTableNo sDriverID
88661>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88664>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88666>>>>>>>                    Open hTable
88668>>>>>>>                End
88668>>>>>>>>
88668>>>>>>>            End
88668>>>>>>>>
88668>>>>>>>        Loop
88669>>>>>>>>
88669>>>>>>>
88669>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88672>>>>>>>        If (bIsOpen = False) Begin
88674>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88675>>>>>>>        End
88675>>>>>>>>
88675>>>>>>>        If (bIsOpen = False) Begin
88677>>>>>>>            Function_Return False
88678>>>>>>>        End
88678>>>>>>>>
88678>>>>>>>
88678>>>>>>>        Function_Return (Err = False)
88679>>>>>>>    End_Function
88680>>>>>>>
88680>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88680>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88680>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88682>>>>>>>        Integer iSize iCount
88682>>>>>>>        Integer iRetVal
88682>>>>>>>
88682>>>>>>>        Move 0 to iRetVal
88683>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88686>>>>>>>        If (iRetVal = 0) Begin
88688>>>>>>>            Function_Return 0
88689>>>>>>>        End
88689>>>>>>>>
88689>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88690>>>>>>>        Decrement iSize
88691>>>>>>>        for iCount from 0 to iSize
88697>>>>>>>>
88697>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88699>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88701>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88702>>>>>>>                End
88702>>>>>>>>
88702>>>>>>>            End
88702>>>>>>>>
88702>>>>>>>        Loop
88703>>>>>>>>
88703>>>>>>>
88703>>>>>>>        Function_Return iRetVal
88704>>>>>>>    End_Function
88705>>>>>>>
88705>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88707>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88707>>>>>>>        Boolean bIsSQLTable
88707>>>>>>>        
88707>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88708>>>>>>>            If (bIsSQLTable = True) Begin
88710>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88713>>>>>>>            End
88713>>>>>>>>
88713>>>>>>>
88713>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88716>>>>>>>        If (iSegment = iNumSegments) Begin
88718>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88718>>>>>>>        End
88718>>>>>>>>
88718>>>>>>>
88718>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88721>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88727>>>>>>>>
88727>>>>>>>                //*** Move index segment attributes
88727>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88730>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88733>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88736>>>>>>>
88736>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88739>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88742>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88745>>>>>>>            Loop
88746>>>>>>>>
88746>>>>>>>
88746>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88749>>>>>>>        End
88749>>>>>>>>
88749>>>>>>>
88749>>>>>>>        Function_Return (Err = False)
88750>>>>>>>    End_Function
88751>>>>>>>
88751>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88753>>>>>>>        Integer iCount iSize iIndex
88753>>>>>>>        String sDriverID
88753>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88753>>>>>>>
88753>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88754>>>>>>>        If (iSize = 0) Begin
88756>>>>>>>            Function_Return True
88757>>>>>>>        End
88757>>>>>>>>
88757>>>>>>>
88757>>>>>>>        Get AutoConnectionIDLogin to bOK
88758>>>>>>>        Move False to Err
88759>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88762>>>>>>>        If (bIsOpen = False) Begin
88764>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88765>>>>>>>            If (bIsOpen = False) Begin
88767>>>>>>>                Function_Return False
88768>>>>>>>            End
88768>>>>>>>>
88768>>>>>>>        End
88768>>>>>>>>
88768>>>>>>>
88768>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88771>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88772>>>>>>>            If (bIsSQLTable = True) Begin
88774>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88777>>>>>>>            End
88777>>>>>>>>
88777>>>>>>>
88777>>>>>>>        Move False to Err
88778>>>>>>>        Move 0 to LastErr
88779>>>>>>>        Decrement iSize
88780>>>>>>>
88780>>>>>>>        Structure_Start hTable sDriverID
88781>>>>>>>            for iCount from 0 to iSize
88787>>>>>>>>
88787>>>>>>>//                Move False to bIsSQLPrimaryKey
88787>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88787>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88787>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88787>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88787>>>>>>>//                #ENDIF
88787>>>>>>>                // We can't delete if this is a primary key index:
88787>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88787>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88788>>>>>>>                    Delete_Index hTable iIndex
88789>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88789>>>>>>>//                End
88789>>>>>>>            Loop
88790>>>>>>>>
88790>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88791>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88793>>>>>>>//        Move False to Err
88793>>>>>>>        Move 0 to LastErr
88794>>>>>>>
88794>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88795>>>>>>>        Function_Return (Err = False)
88796>>>>>>>    End_Function
88797>>>>>>>
88797>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88799>>>>>>>        Boolean bOK
88799>>>>>>>
88799>>>>>>>        Get AutoConnectionIDLogin to bOK
88800>>>>>>>        Move False to Err
88801>>>>>>>        Get OpenTableExclusive hTable to bOK
88802>>>>>>>        If (bOK = False) Begin
88804>>>>>>>            Function_Return False
88805>>>>>>>        End
88805>>>>>>>>
88805>>>>>>>        Structure_Start hTable
88806>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88809>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88810>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88812>>>>>>>
88812>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88813>>>>>>>        Function_Return (Err = False)
88814>>>>>>>    End_Function
88815>>>>>>>
88815>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88817>>>>>>>        Integer iCase
88817>>>>>>>        Boolean bOK
88817>>>>>>>
88817>>>>>>>        If (bUppercase = True) Begin
88819>>>>>>>            Move DF_CASE_IGNORED to iCase
88820>>>>>>>        End
88820>>>>>>>>
88820>>>>>>>        Else Begin
88821>>>>>>>            Move DF_CASE_USED to iCase
88822>>>>>>>        End
88822>>>>>>>>
88822>>>>>>>
88822>>>>>>>        Get AutoConnectionIDLogin to bOK
88823>>>>>>>        Move False to Err
88824>>>>>>>        Get OpenTableExclusive hTable to bOK
88825>>>>>>>        If (bOK = False) Begin
88827>>>>>>>            Function_Return False
88828>>>>>>>        End
88828>>>>>>>>
88828>>>>>>>        Structure_Start hTable
88829>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88832>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88833>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88835>>>>>>>
88835>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88836>>>>>>>        Function_Return (Err = False)
88837>>>>>>>    End_Function
88838>>>>>>>
88838>>>>>>>    // To delete an index
88838>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88840>>>>>>>        Integer iTableNo iNumSegments
88840>>>>>>>        String sDriverID
88840>>>>>>>        Boolean bOK bIsSQLTable
88840>>>>>>>
88840>>>>>>>        Get AutoConnectionIDLogin to bOK
88841>>>>>>>        Move False to Err
88842>>>>>>>        Move hTable to iTableNo
88843>>>>>>>        Get OpenTableExclusive hTable to bOK
88844>>>>>>>        If (bOK = False) Begin
88846>>>>>>>            Function_Return False
88847>>>>>>>        End
88847>>>>>>>>
88847>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88850>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88851>>>>>>>            If (bIsSQLTable = True) Begin
88853>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88856>>>>>>>            End
88856>>>>>>>>
88856>>>>>>>
88856>>>>>>>        // Check to see if the index exists or not...
88856>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88859>>>>>>>        If (iNumSegments = 0) Begin
88861>>>>>>>            Function_Return True // Then nothing to do.
88862>>>>>>>        End
88862>>>>>>>>
88862>>>>>>>
88862>>>>>>>        Structure_Start hTable sDriverID
88863>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88864>>>>>>>            Delete_Index iTableNo iIndex
88865>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88866>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88867>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88869>>>>>>>
88869>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88870>>>>>>>        Function_Return (Err = False)
88871>>>>>>>    End_Function
88872>>>>>>>
88872>>>>>>>    // Delete an Index Segment
88872>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88874>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88874>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88874>>>>>>>        Integer iIndexType
88874>>>>>>>        String sDriverID
88874>>>>>>>
88874>>>>>>>        Get AutoConnectionIDLogin to bOK
88875>>>>>>>        Move False to Err
88876>>>>>>>
88876>>>>>>>        Get OpenTableExclusive hTable to bOK
88877>>>>>>>        If (bOK = False) Begin
88879>>>>>>>            Function_Return False
88880>>>>>>>        End
88880>>>>>>>>
88880>>>>>>>
88880>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88881>>>>>>>            If (bIsSQLTable = True) Begin
88883>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88886>>>>>>>            End
88886>>>>>>>>
88886>>>>>>>
88886>>>>>>>        // Check to see if the index exists or not...
88886>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88889>>>>>>>        If (iNumSegments = 0) Begin
88891>>>>>>>            Function_Return False
88892>>>>>>>        End
88892>>>>>>>>
88892>>>>>>>
88892>>>>>>>        Move False to bIndexTemporary
88893>>>>>>>        Get psDriverID to sDriverID
88894>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88895>>>>>>>        If (bSQLDriver) Begin
88897>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88900>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88903>>>>>>>                Move True to bIndexTemporary
88904>>>>>>>        End
88904>>>>>>>>
88904>>>>>>>
88904>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88904>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88906>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88909>>>>>>>            If (iSegment = iNumSegments) Begin
88911>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88914>>>>>>>            End
88914>>>>>>>>
88914>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88917>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88923>>>>>>>>
88923>>>>>>>                    //*** Move index segment attributes
88923>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88926>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88929>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88932>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88935>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88938>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88941>>>>>>>                Loop
88942>>>>>>>>
88942>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88945>>>>>>>            End
88945>>>>>>>>
88945>>>>>>>        End
88945>>>>>>>>
88945>>>>>>>
88945>>>>>>>        Else Begin
88946>>>>>>>           Structure_Start hTable
88947>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88950>>>>>>>               If (iSegment = iNumSegments) Begin
88952>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88955>>>>>>>               End
88955>>>>>>>>
88955>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88958>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88964>>>>>>>>
88964>>>>>>>                       //*** Move index segment attributes
88964>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88967>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88970>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88973>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88976>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88979>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88982>>>>>>>                   Loop
88983>>>>>>>>
88983>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88986>>>>>>>               End
88986>>>>>>>>
88986>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88987>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88989>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88990>>>>>>>        End
88990>>>>>>>>
88990>>>>>>>
88990>>>>>>>        Function_Return (Err = False)
88991>>>>>>>    End_Function
88992>>>>>>>
88992>>>>>>>    // Add/Insert an Index Segment
88992>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88994>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88994>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88994>>>>>>>        Integer iIndexType
88994>>>>>>>        String sDriverId
88994>>>>>>>
88994>>>>>>>        Get AutoConnectionIDLogin to bOK
88995>>>>>>>        Move False to Err
88996>>>>>>>
88996>>>>>>>        Get OpenTableExclusive hTable to bOK
88997>>>>>>>        If (bOK = False) Begin
88999>>>>>>>            Function_Return False
89000>>>>>>>        End
89000>>>>>>>>
89000>>>>>>>
89000>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89001>>>>>>>            If (bIsSQLTable = True) Begin
89003>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89006>>>>>>>            End
89006>>>>>>>>
89006>>>>>>>
89006>>>>>>>        Move False to bIndexTemporary
89007>>>>>>>        // Check to see if the index exists or not...
89007>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89010>>>>>>>        If (iNumSegments = 0) Begin
89012>>>>>>>            Function_Return False
89013>>>>>>>        End
89013>>>>>>>>
89013>>>>>>>
89013>>>>>>>        Get psDriverID to sDriverID
89014>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89015>>>>>>>        If (bSQLDriver) Begin
89017>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89020>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89023>>>>>>>                Move True to bIndexTemporary
89024>>>>>>>        End
89024>>>>>>>>
89024>>>>>>>
89024>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89024>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89026>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89029>>>>>>>
89029>>>>>>>           If (iSegment > iNumSegments) Begin
89031>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89034>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89035>>>>>>>           End
89035>>>>>>>>
89035>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89038>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89041>>>>>>>               Move iNumSegments to iCurSegment
89042>>>>>>>
89042>>>>>>>               While (iCurSegment > iSegment)
89046>>>>>>>                   //*** Move index segment attributes
89046>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89049>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89052>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89055>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89058>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89061>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89064>>>>>>>                   Decrement iCurSegment
89065>>>>>>>               Loop
89066>>>>>>>>
89066>>>>>>>
89066>>>>>>>               //*** Now set new segment attributes
89066>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89069>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89072>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89075>>>>>>>           End
89075>>>>>>>>
89075>>>>>>>        End
89075>>>>>>>>
89075>>>>>>>
89075>>>>>>>        Else Begin
89076>>>>>>>        Structure_Start hTable
89077>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89080>>>>>>>
89080>>>>>>>            If (iSegment > iNumSegments) Begin
89082>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89085>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89086>>>>>>>            End
89086>>>>>>>>
89086>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89089>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89092>>>>>>>                Move iNumSegments to iCurSegment
89093>>>>>>>
89093>>>>>>>                While (iCurSegment > iSegment)
89097>>>>>>>                    //*** Move index segment attributes
89097>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89100>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89103>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89106>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89109>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89112>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89115>>>>>>>                    Decrement iCurSegment
89116>>>>>>>                Loop
89117>>>>>>>>
89117>>>>>>>
89117>>>>>>>                //*** Now set new segment attributes
89117>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89120>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89123>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89126>>>>>>>            End
89126>>>>>>>>
89126>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89127>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89129>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89130>>>>>>>        End
89130>>>>>>>>
89130>>>>>>>
89130>>>>>>>        Function_Return (Err = False)
89131>>>>>>>    End_Function
89132>>>>>>>
89132>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89132>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89134>>>>>>>        Function_Return False
89135>>>>>>>    End_Function  
89136>>>>>>>    
89136>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89136>>>>>>>    // for an SQL conversion.
89136>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89138>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89138>>>>>>>        
89138>>>>>>>        Move True to bConvertTo30FormatbOK
89139>>>>>>>        Move True to bRepairAndReindexOK
89140>>>>>>>        Move True to bFixBogusDatesOK
89141>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89142>>>>>>>        
89142>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89144>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89145>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89146>>>>>>>        End                                                                                
89146>>>>>>>>
89146>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89148>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89149>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89150>>>>>>>        End
89150>>>>>>>>
89150>>>>>>>        If (bConvertTo30Format = True) Begin
89152>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89153>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89154>>>>>>>        End                                                 
89154>>>>>>>>
89154>>>>>>>        If (bRepairAndReindex = True) Begin
89156>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89157>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89158>>>>>>>        End  
89158>>>>>>>>
89158>>>>>>>        If (bFixBogusDates = True) Begin
89160>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89161>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89162>>>>>>>        End                                    
89162>>>>>>>>
89162>>>>>>>        
89162>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89163>>>>>>>    End_Function
89164>>>>>>>
89164>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89166>>>>>>>        Boolean bOK bFlexErrs bTemp
89166>>>>>>>        Handle hTable
89166>>>>>>>        String sTableName
89166>>>>>>>        Integer iCount iSize
89166>>>>>>>        
89166>>>>>>>        Move True to bOK
89167>>>>>>>        Move 0 to hTable    
89168>>>>>>>
89168>>>>>>>        Get UtilFilelistNoOfTables to iSize
89169>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89170>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89171>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89172>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89173>>>>>>>
89173>>>>>>>        Repeat
89173>>>>>>>>
89173>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89174>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89175>>>>>>>            Increment iCount
89176>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89179>>>>>>>            If (hTable > 0) Begin
89181>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89184>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89185>>>>>>>                If (bFlexErrs = False) Begin
89187>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89188>>>>>>>                    If (bTemp = False) Begin
89190>>>>>>>                        Move False to bOK
89191>>>>>>>                    End
89191>>>>>>>>
89191>>>>>>>                End
89191>>>>>>>>
89191>>>>>>>            End
89191>>>>>>>>
89191>>>>>>>        Until (hTable = 0)
89193>>>>>>>        
89193>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89194>>>>>>>        Function_Return bOK
89195>>>>>>>    End_Function
89196>>>>>>>    
89196>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89196>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89196>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89196>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89198>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89198>>>>>>>        String sRevision
89198>>>>>>>        
89198>>>>>>>        Get AutoConnectionIDLogin to bOK
89199>>>>>>>        If (bOK = False) Begin
89201>>>>>>>            Function_Return True
89202>>>>>>>        End
89202>>>>>>>>
89202>>>>>>>        Get OpenTableExclusive hTable to bOK
89203>>>>>>>        If (bOK = False) Begin
89205>>>>>>>            Function_Return True
89206>>>>>>>        End
89206>>>>>>>>
89206>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89207>>>>>>>        If (bIsEmbedded = False) Begin
89209>>>>>>>            Function_Return True
89210>>>>>>>        End                             
89210>>>>>>>>
89210>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89211>>>>>>>        If (bIsAlias = True) Begin
89213>>>>>>>            Function_Return True
89214>>>>>>>        End                     
89214>>>>>>>>
89214>>>>>>>        
89214>>>>>>>        Move False to Err
89215>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89218>>>>>>>        If (sRevision contains "2.3") Begin
89220>>>>>>>            Move False to Err
89221>>>>>>>            Set Private.phCurrentTable to hTable
89222>>>>>>>            Structure_Start hTable    
89223>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89226>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89227>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89229>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89230>>>>>>>        End
89230>>>>>>>>
89230>>>>>>>        
89230>>>>>>>        Function_Return (Err = False)
89231>>>>>>>    End_Function
89232>>>>>>>
89232>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89234>>>>>>>        Boolean bIgnore bExists bOK bResponse
89234>>>>>>>        Handle hTable   
89234>>>>>>>        String sTableName
89234>>>>>>>        
89234>>>>>>>        Move False to Err 
89235>>>>>>>        Move True to bOK
89236>>>>>>>        Move 0 to hTable
89237>>>>>>>        Repeat
89237>>>>>>>>
89237>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89240>>>>>>>            If (hTable > 0) Begin
89242>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89245>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89246>>>>>>>                If (bIgnore = False) Begin
89248>>>>>>>                    Get _UtilTableExists hTable to bExists
89249>>>>>>>                    If (bExists = False) Begin
89251>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89252>>>>>>>                        If (bResponse = False) Begin
89254>>>>>>>                            Move False to bOK
89255>>>>>>>                        End
89255>>>>>>>>
89255>>>>>>>                        
89255>>>>>>>                    End
89255>>>>>>>>
89255>>>>>>>                End
89255>>>>>>>>
89255>>>>>>>            End
89255>>>>>>>>
89255>>>>>>>        Until (hTable = 0)                     
89257>>>>>>>        
89257>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89258>>>>>>>        Function_Return bOK
89259>>>>>>>    End_Function
89260>>>>>>>    
89260>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89260>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89260>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89260>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89260>>>>>>>    //
89260>>>>>>>    // The root of the problem is the following:
89260>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89260>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89260>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89260>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89260>>>>>>>    // an SQL error will be thrown;
89260>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89260>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89262>>>>>>>        Boolean bOK bIsAlias bIsSQL
89262>>>>>>>        Integer iCount iSize iDateSize
89262>>>>>>>        Handle hTable
89262>>>>>>>        String sLogicalName
89262>>>>>>>        Integer[] aTablesToCheck aDateFields
89264>>>>>>>
89264>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89265>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89266>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89267>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89268>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89269>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89270>>>>>>>
89270>>>>>>>        Move True to bOK
89271>>>>>>>        Decrement iSize
89272>>>>>>>        for iCount from 0 to iSize
89278>>>>>>>>
89278>>>>>>>            Move aTablesToCheck[iCount] to hTable
89279>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89280>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89281>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89282>>>>>>>
89282>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89285>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89286>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89287>>>>>>>
89287>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89289>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89290>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89291>>>>>>>                If (iDateSize > 0) Begin
89293>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89294>>>>>>>                    Close hTable
89295>>>>>>>                End
89295>>>>>>>>
89295>>>>>>>            End
89295>>>>>>>>
89295>>>>>>>        Loop
89296>>>>>>>>
89296>>>>>>>
89296>>>>>>>        Close DF_ALL
89297>>>>>>>        Function_Return bOK
89298>>>>>>>    End_Function
89299>>>>>>>
89299>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89299>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89301>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89303>>>>>>>        Integer iSize iCount iType
89303>>>>>>>        Boolean bOpen bOK
89303>>>>>>>        
89303>>>>>>>        Get _UtilTableExists hTable to bOK
89304>>>>>>>        If (bOK = False) Begin
89306>>>>>>>            Set Private.phCurrentTable to hTable
89307>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89308>>>>>>>>
89308>>>>>>>            Function_Return aDateFieldsEmpty
89309>>>>>>>        End
89309>>>>>>>>
89309>>>>>>>        Set Private.phCurrentTable to hTable
89310>>>>>>>        Set Private.piCurrentField to 0
89311>>>>>>>
89311>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89311>>>>>>>        Open hTable
89313>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89316>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89316>>>>>>>        If (bOpen = False) Begin
89318>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
89318>>>>>>>            Function_Return aDateFieldsEmpty
89319>>>>>>>        End
89319>>>>>>>>
89319>>>>>>>
89319>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89322>>>>>>>        For iCount from 1 to iSize
89328>>>>>>>>
89328>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89331>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89333>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89334>>>>>>>            End
89334>>>>>>>>
89334>>>>>>>        Loop
89335>>>>>>>>
89335>>>>>>>
89335>>>>>>>        Function_Return aDateFields
89336>>>>>>>    End_Function
89337>>>>>>>
89337>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89337>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89337>>>>>>>    // and the record is saved
89337>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89337>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89337>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89339>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89339>>>>>>>        String sDriverID sDateMin
89339>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89339>>>>>>>        Date dDate dDateMin
89339>>>>>>>        Integer[] iaChangeField
89340>>>>>>>
89340>>>>>>>        Get _UtilTableExists hTable to bOK
89341>>>>>>>        // I believe we should just skip files not found and not report an error.
89341>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89341>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89341>>>>>>>        // Especially considering that this call is probably done at the very
89341>>>>>>>        // beginning of a DUF update.
89341>>>>>>>        If (bOK = False) Begin
89343>>>>>>>//            Set Private.phCurrentTable to hTable
89343>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89343>>>>>>>//            Function_Return False
89343>>>>>>>            Function_Return True
89344>>>>>>>        End
89344>>>>>>>>
89344>>>>>>>
89344>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89344>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89344>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89347>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89350>>>>>>>
89350>>>>>>>//        Send SetAllIndexesToBatch hTable True
89350>>>>>>>        Open hTable
89352>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89355>>>>>>>        If (bOpened = False) Begin
89357>>>>>>>            Function_Return False
89358>>>>>>>        End
89358>>>>>>>>
89358>>>>>>>        
89358>>>>>>>        Set Private.phCurrentTable to hTable
89359>>>>>>>        Move 0 to iRecord
89360>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89361>>>>>>>        Decrement iSize
89362>>>>>>>
89362>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89365>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89366>>>>>>>        If (iDriverIndex <> 0) Begin
89368>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89371>>>>>>>            If (sDateMin = "") Begin
89373>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89374>>>>>>>            End
89374>>>>>>>>
89374>>>>>>>            Else Begin
89375>>>>>>>                If (IsDate(sDateMin)) Begin
89377>>>>>>>                    Move sDateMin to dDateMin
89378>>>>>>>                End
89378>>>>>>>>
89378>>>>>>>                Else Begin
89379>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89380>>>>>>>                End
89380>>>>>>>>
89380>>>>>>>            End
89380>>>>>>>>
89380>>>>>>>        End
89380>>>>>>>>
89380>>>>>>>        Else Begin
89381>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89382>>>>>>>        End
89382>>>>>>>>
89382>>>>>>>
89382>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89385>>>>>>>        Set piPosition   of ghoProgressBar to 0
89386>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89387>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89388>>>>>>>        Move False to Err
89389>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89390>>>>>>>
89390>>>>>>>        Clear hTable
89391>>>>>>>        Repeat
89391>>>>>>>>
89391>>>>>>>            Vfind hTable 0 GT
89393>>>>>>>            Move Found to bFound
89394>>>>>>>            If (bFound = True) Begin
89396>>>>>>>                Move False to bSaveChanges
89397>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89398>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89399>>>>>>>                Decrement iSize
89400>>>>>>>                For iCount from 0 to iSize
89406>>>>>>>>
89406>>>>>>>                    Move aDateFields[iCount] to iField
89407>>>>>>>                    Get_Field_Value hTable iField to dDate
89410>>>>>>>                    If (bFixZeroDates = True) Begin
89412>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89413>>>>>>>                    End
89413>>>>>>>>
89413>>>>>>>                    Else Begin
89414>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89415>>>>>>>                    End
89415>>>>>>>>
89415>>>>>>>                    If (bChange = True) Begin
89417>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89418>>>>>>>                    End
89418>>>>>>>>
89418>>>>>>>                Loop
89419>>>>>>>>
89419>>>>>>>
89419>>>>>>>                // Only change Date fields that needs to be changed.
89419>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89421>>>>>>>                    Reread hTable
89425>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89426>>>>>>>                        Decrement iSize
89427>>>>>>>                        For iCount from 0 to iSize
89433>>>>>>>>
89433>>>>>>>                            Move iaChangeField[iCount] to iField
89434>>>>>>>                            Set Private.piCurrentField to iField
89435>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89438>>>>>>>                        Loop
89439>>>>>>>>
89439>>>>>>>                        Move False to Err
89440>>>>>>>                        SaveRecord hTable
89441>>>>>>>                    Unlock
89442>>>>>>>>
89442>>>>>>>                End
89442>>>>>>>>
89442>>>>>>>
89442>>>>>>>                Increment iRecord
89443>>>>>>>                // Increment the StatusPanel counter and check the
89443>>>>>>>                // cancel status every 100 records rather than every
89443>>>>>>>                // record, it's way faster.
89443>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89445>>>>>>>                    Send DoAdvance of ghoProgressBar
89446>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89447>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89448>>>>>>>                End
89448>>>>>>>>
89448>>>>>>>            End
89448>>>>>>>>
89448>>>>>>>        Until (bFound = False)
89450>>>>>>>
89450>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89453>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89455>>>>>>>            Send SetAllIndexesToBatch hTable False
89456>>>>>>>        End
89456>>>>>>>>
89456>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89457>>>>>>>
89457>>>>>>>        Function_Return (Err = False)
89458>>>>>>>    End_Function
89459>>>>>>>
89459>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89459>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89459>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89461>>>>>>>        Boolean bIsSame
89461>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89461>>>>>>>
89461>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89462>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89463>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89464>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89465>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89466>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89467>>>>>>>
89467>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89469>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89470>>>>>>>        End
89470>>>>>>>>
89470>>>>>>>        Else Begin
89471>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89472>>>>>>>        End
89472>>>>>>>>
89472>>>>>>>        If (bIsSame = False) Begin
89474>>>>>>>            Function_Return False
89475>>>>>>>        End
89475>>>>>>>>
89475>>>>>>>
89475>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89476>>>>>>>        If (bIsSame = False) Begin
89478>>>>>>>            Function_Return False
89479>>>>>>>        End
89479>>>>>>>>
89479>>>>>>>
89479>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89480>>>>>>>        If (bIsSame = False) Begin
89482>>>>>>>            Function_Return False
89483>>>>>>>        End
89483>>>>>>>>
89483>>>>>>>
89483>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89484>>>>>>>        If (bIsSame = False) Begin
89486>>>>>>>            Function_Return False
89487>>>>>>>        End
89487>>>>>>>>
89487>>>>>>>
89487>>>>>>>        Function_Return bIsSame
89488>>>>>>>    End_Function
89489>>>>>>>
89489>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89491>>>>>>>        Handle hTableFrom hTableTo
89491>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89491>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89491>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89491>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89491>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89492>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89492>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89493>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89493>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89494>>>>>>>
89494>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89495>>>>>>>        If (bIsSame = True) Begin
89497>>>>>>>            Function_Return True
89498>>>>>>>        End
89498>>>>>>>>
89498>>>>>>>
89498>>>>>>>        Move False to bFilelistError
89499>>>>>>>        Move True to bIsSame
89500>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89501>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89502>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89503>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89504>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89505>>>>>>>
89505>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89506>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89507>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89508>>>>>>>
89508>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89508>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89508>>>>>>>        If (bCodeGenerateMode = True) Begin
89510>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89510>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89512>>>>>>>                Function_Return False
89513>>>>>>>            End
89513>>>>>>>>
89513>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89514>>>>>>>            If (bIsSame = False) Begin
89516>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89517>>>>>>>                Move True to bFilelistError
89518>>>>>>>                Function_Return False
89519>>>>>>>            End
89519>>>>>>>>
89519>>>>>>>        End
89519>>>>>>>>
89519>>>>>>>
89519>>>>>>>        If (bCodeGenerateMode = False) Begin
89521>>>>>>>            // Then we want to create this table
89521>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89523>>>>>>>                Function_Return False
89524>>>>>>>            End
89524>>>>>>>>
89524>>>>>>>
89524>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89525>>>>>>>            If (bIsSame = False) Begin
89527>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89528>>>>>>>>
89528>>>>>>>                Move True to bFilelistError
89529>>>>>>>                Function_Return False
89530>>>>>>>            End
89530>>>>>>>>
89530>>>>>>>        End
89530>>>>>>>>
89530>>>>>>>
89530>>>>>>>        // Check columns:
89530>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89531>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89532>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89533>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89534>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89535>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89536>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89537>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89538>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89539>>>>>>>        If (bIsSame = False) Begin
89541>>>>>>>            Function_Return False
89542>>>>>>>        End
89542>>>>>>>>
89542>>>>>>>
89542>>>>>>>        // ...then check indexes:
89542>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89543>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89544>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89545>>>>>>>        If (bIsSame = False) Begin
89547>>>>>>>            Function_Return False
89548>>>>>>>        End
89548>>>>>>>>
89548>>>>>>>
89548>>>>>>>        // ...and finally relationships:
89548>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89549>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89550>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89551>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89552>>>>>>>
89552>>>>>>>        Function_Return (bIsSame = True)
89553>>>>>>>    End_Function
89554>>>>>>>
89554>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89554>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89556>>>>>>>        Handle hTable
89556>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89556>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89556>>>>>>>
89556>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89558>>>>>>>            Move True to bFilelistError
89559>>>>>>>            Function_Return False
89560>>>>>>>        End
89560>>>>>>>>
89560>>>>>>>
89560>>>>>>>        Move APITableCompare.hTable to hTable
89561>>>>>>>        Move True  to bIsSame
89562>>>>>>>        Move False to bFilelistError
89563>>>>>>>
89563>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89565>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89566>>>>>>>        End
89566>>>>>>>>
89566>>>>>>>        Else Begin
89567>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89568>>>>>>>        End
89568>>>>>>>>
89568>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89569>>>>>>>
89569>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89570>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89571>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89572>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89573>>>>>>>
89573>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89573>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89573>>>>>>>        If (bCodeGenerateMode = True) Begin
89575>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89575>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89577>>>>>>>                Function_Return False
89578>>>>>>>            End
89578>>>>>>>>
89578>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89579>>>>>>>            If (bIsSame = False) Begin
89581>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89582>>>>>>>                Move True to bFilelistError
89583>>>>>>>                Function_Return False
89584>>>>>>>            End
89584>>>>>>>>
89584>>>>>>>        End
89584>>>>>>>>
89584>>>>>>>
89584>>>>>>>        If (bCodeGenerateMode = False) Begin
89586>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89588>>>>>>>                // Then we might want to create this table
89588>>>>>>>                Function_Return False
89589>>>>>>>            End
89589>>>>>>>>
89589>>>>>>>
89589>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89590>>>>>>>            If (bIsSame = False) Begin
89592>>>>>>>                Function_Return False
89593>>>>>>>            End
89593>>>>>>>>
89593>>>>>>>
89593>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89594>>>>>>>            If (bIsSame = False) Begin
89596>>>>>>>                Function_Return False
89597>>>>>>>            End
89597>>>>>>>>
89597>>>>>>>
89597>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89598>>>>>>>            If (bIsSame = False) Begin
89600>>>>>>>                Function_Return False
89601>>>>>>>            End
89601>>>>>>>>
89601>>>>>>>
89601>>>>>>>            // Check table names et al.
89601>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89602>>>>>>>            If (bIsSame = False) Begin
89604>>>>>>>                Function_Return False
89605>>>>>>>            End
89605>>>>>>>>
89605>>>>>>>        End
89605>>>>>>>>
89605>>>>>>>
89605>>>>>>>        // Check Columns:
89605>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89606>>>>>>>        If (bIsSame = False) Begin
89608>>>>>>>            Function_Return False
89609>>>>>>>        End
89609>>>>>>>>
89609>>>>>>>
89609>>>>>>>        // ...then check Indexes:
89609>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89610>>>>>>>        If (bIsSame = False) Begin
89612>>>>>>>            Function_Return False
89613>>>>>>>        End
89613>>>>>>>>
89613>>>>>>>
89613>>>>>>>        // ...and finally Relationships:
89613>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89614>>>>>>>
89614>>>>>>>        Function_Return (bIsSame = True)
89615>>>>>>>    End_Function
89616>>>>>>>
89616>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89616>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89616>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89616>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89616>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89618>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89618>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89618>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89618>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89620>>>>>>>        tAPIColumn[]    aApiColumns
89620>>>>>>>        tAPIColumn[]    aApiColumns
89621>>>>>>>        tAPIIndex[]     aApiIndexes
89621>>>>>>>        tAPIIndex[]     aApiIndexes
89622>>>>>>>        tAPIRelation[]  aApiRelations
89622>>>>>>>        tAPIRelation[]  aApiRelations
89623>>>>>>>        Handle hTable
89623>>>>>>>        Integer iCount
89623>>>>>>>        Boolean bUserCancel bOK
89623>>>>>>>        String sLogicalName sMessageText
89623>>>>>>>
89623>>>>>>>        Get AutoConnectionIDLogin to bOK
89624>>>>>>>        Move 0 to hTable
89625>>>>>>>        If (bFromTables = True) Begin
89627>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89628>>>>>>>            If (bCompareUtil = True) Begin
89630>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89631>>>>>>>            End
89631>>>>>>>>
89631>>>>>>>        End
89631>>>>>>>>
89631>>>>>>>        Else Begin
89632>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89633>>>>>>>            If (bCompareUtil = True) Begin
89635>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89636>>>>>>>            End
89636>>>>>>>>
89636>>>>>>>        End
89636>>>>>>>>
89636>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89637>>>>>>>
89637>>>>>>>        Get UtilFilelistNoOfTables to iCount
89638>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89639>>>>>>>        Move 0 to iCount
89640>>>>>>>
89640>>>>>>>        Repeat
89640>>>>>>>>
89640>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89643>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89645>>>>>>>
89645>>>>>>>                Open hTable
89647>>>>>>>                // ToDo: Needs to be revised
89647>>>>>>>                // For some reason tables may be reported as "unopened", while in
89647>>>>>>>                // fact the open was successful (!)
89647>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89647>>>>>>>//                If (bIsOpen = False) Begin
89647>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89647>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89647>>>>>>>//                    Function_Return aApiTablesEmpty
89647>>>>>>>//                End
89647>>>>>>>
89647>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89650>>>>>>>                Set piPosition of ghoProgressBar to iCount
89651>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89652>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89653>>>>>>>
89653>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89654>>>>>>>//                Close hTable DF_PERMANENT
89654>>>>>>>                Increment iCount
89655>>>>>>>            End
89655>>>>>>>>
89655>>>>>>>
89655>>>>>>>            If (bStatusPanel = True) Begin
89657>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89658>>>>>>>                If (bUserCancel = True) Begin
89660>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89661>>>>>>>                    Function_Return aApiTablesEmpty
89662>>>>>>>                End
89662>>>>>>>>
89662>>>>>>>            End
89662>>>>>>>>
89662>>>>>>>
89662>>>>>>>        Until (hTable = 0)
89664>>>>>>>
89664>>>>>>>        Function_Return aApiTables
89665>>>>>>>    End_Function
89666>>>>>>>
89666>>>>>>>    // Returns a 'single' table APITable struct.
89666>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89668>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89668>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89668>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89668>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89668>>>>>>>        tAPIColumn[]     aApiColumns
89668>>>>>>>        tAPIColumn[]     aApiColumns
89669>>>>>>>        tAPIIndex[]      aApiIndexes
89669>>>>>>>        tAPIIndex[]      aApiIndexes
89670>>>>>>>        tAPIRelation[]   aApiRelations
89670>>>>>>>        tAPIRelation[]   aApiRelations
89671>>>>>>>        Boolean bIsOpen
89671>>>>>>>
89671>>>>>>>        Open hTable
89673>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89676>>>>>>>        If (bIsOpen = False) Begin
89678>>>>>>>            Move True to ApiTableEmpty.bError
89679>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89680>>>>>>>            Function_Return ApiTableEmpty
89681>>>>>>>        End
89681>>>>>>>>
89681>>>>>>>
89681>>>>>>>        // Fill Table Name Info
89681>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89682>>>>>>>
89682>>>>>>>        // Fill columns
89682>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89683>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89685>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89687>>>>>>>                Move True to ApiTableEmpty.bError
89688>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89689>>>>>>>                Function_Return ApiTableEmpty
89690>>>>>>>            End
89690>>>>>>>>
89690>>>>>>>        End
89690>>>>>>>>
89690>>>>>>>
89690>>>>>>>        // Fill indexes
89690>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89691>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89693>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89695>>>>>>>                Move True to ApiTableEmpty.bError
89696>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89697>>>>>>>                Function_Return ApiTableEmpty
89698>>>>>>>            End
89698>>>>>>>>
89698>>>>>>>        End
89698>>>>>>>>
89698>>>>>>>
89698>>>>>>>        // Fill relationships
89698>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89699>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89701>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89703>>>>>>>                Move True to ApiTableEmpty.bError
89704>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89705>>>>>>>                Function_Return ApiTableEmpty
89706>>>>>>>            End
89706>>>>>>>>
89706>>>>>>>        End
89706>>>>>>>>
89706>>>>>>>
89706>>>>>>>        Move hTable             to ApiTable.hTable
89707>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89708>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89709>>>>>>>
89709>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89710>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89711>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89712>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89713>>>>>>>
89713>>>>>>>        Function_Return ApiTable
89714>>>>>>>    End_Function
89715>>>>>>>
89715>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89717>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89717>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89717>>>>>>>        Boolean bIsOpen
89717>>>>>>>
89717>>>>>>>        Open hTable
89719>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89722>>>>>>>        If (bIsOpen = False) Begin
89724>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89725>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89726>>>>>>>            Function_Return APITableNameInfoEmpty
89727>>>>>>>        End
89727>>>>>>>>
89727>>>>>>>
89727>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89728>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89731>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89734>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89737>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89740>>>>>>>
89740>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89741>>>>>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89742>>>>>>>
89742>>>>>>>        Function_Return APITableNameInfo
89743>>>>>>>    End_Function
89744>>>>>>>
89744>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89746>>>>>>>        Integer iSize iCount iItem
89746>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89746>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89746>>>>>>>
89746>>>>>>>        Move -1 to iItem
89747>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89748>>>>>>>        Decrement iSize
89749>>>>>>>        for iCount from 0 to iSize
89755>>>>>>>>
89755>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89756>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89758>>>>>>>                Move iCount to iItem
89759>>>>>>>                Move iSize  to iCount // We're done.
89760>>>>>>>            End
89760>>>>>>>>
89760>>>>>>>        Loop
89761>>>>>>>>
89761>>>>>>>
89761>>>>>>>        Function_Return iItem
89762>>>>>>>    End_Function
89763>>>>>>>
89763>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89765>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89768>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89771>>>>>>>
89771>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89774>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89777>>>>>>>
89777>>>>>>>        Function_Return (EQ)
89778>>>>>>>    End_Function
89779>>>>>>>
89779>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89781>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89781>>>>>>>        Handle hTable
89781>>>>>>>        tAPITable[] aAPITableFromAndTo
89781>>>>>>>        tAPITable[] aAPITableFromAndTo
89782>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89782>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89782>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89782>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89782>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89782>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89783>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89783>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89784>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89784>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89785>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89785>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89786>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89786>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89786>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89786>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89789>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89789>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89792>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89792>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89795>>>>>>>
89795>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89796>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89797>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89799>>>>>>>            Function_Return aAPITableCompare
89800>>>>>>>        End
89800>>>>>>>>
89800>>>>>>>
89800>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89801>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89802>>>>>>>
89802>>>>>>>        Move 0 to iItem
89803>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89804>>>>>>>        Decrement iSize
89805>>>>>>>        for iCount from 0 to iSize
89811>>>>>>>>
89811>>>>>>>
89811>>>>>>>            Move iCount to iItemFrom
89812>>>>>>>            Move iCount to iItemTo
89813>>>>>>>            Move APITableEmpty to APITableFrom
89814>>>>>>>            Move APITableEmpty to APITableTo
89815>>>>>>>
89815>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89817>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89818>>>>>>>            End
89818>>>>>>>>
89818>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89820>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89821>>>>>>>            End
89821>>>>>>>>
89821>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89823>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89824>>>>>>>                Move (iCount + 1) to iItemTo
89825>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89826>>>>>>>            End
89826>>>>>>>>
89826>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89828>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89829>>>>>>>                If (iItemTo <> -1) Begin
89831>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89832>>>>>>>                End
89832>>>>>>>>
89832>>>>>>>                Else Begin
89833>>>>>>>                    Move APITableEmpty to APITableTo
89834>>>>>>>                End
89834>>>>>>>>
89834>>>>>>>            End
89834>>>>>>>>
89834>>>>>>>
89834>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89835>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89836>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89837>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89838>>>>>>>
89838>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89839>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89840>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89841>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89842>>>>>>>
89842>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89843>>>>>>>
89843>>>>>>>            If (hTable > 0) Begin
89845>>>>>>>
89845>>>>>>>                // Table info:
89845>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89846>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89847>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89848>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89849>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89850>>>>>>>
89850>>>>>>>                // Column info:
89850>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89851>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89852>>>>>>>
89852>>>>>>>                // Index info:
89852>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89853>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89854>>>>>>>
89854>>>>>>>                // Relation info:
89854>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89855>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89856>>>>>>>
89856>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89857>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89858>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89859>>>>>>>                If (iItemTo > iItemFrom) Begin
89861>>>>>>>                    Increment iCount
89862>>>>>>>                End
89862>>>>>>>>
89862>>>>>>>                Increment iItem
89863>>>>>>>            End
89863>>>>>>>>
89863>>>>>>>
89863>>>>>>>        Loop
89864>>>>>>>>
89864>>>>>>>
89864>>>>>>>        Function_Return aAPITableCompare
89865>>>>>>>    End_Function
89866>>>>>>>
89866>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89868>>>>>>>        Integer iSize iCount iItem
89868>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89868>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89868>>>>>>>
89868>>>>>>>        Move -1 to iItem
89869>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89870>>>>>>>        Decrement iSize
89871>>>>>>>        For iCount from 0 to iSize
89877>>>>>>>>
89877>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89878>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89880>>>>>>>                Move iCount to iItem
89881>>>>>>>                Move iSize  to iCount // We're done.
89882>>>>>>>            End
89882>>>>>>>>
89882>>>>>>>        Loop
89883>>>>>>>>
89883>>>>>>>
89883>>>>>>>        Function_Return iItem
89884>>>>>>>    End_Function
89885>>>>>>>
89885>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89887>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89887>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89887>>>>>>>
89887>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89889>>>>>>>            Function_Return APITableNameInfoCompare
89890>>>>>>>        End
89890>>>>>>>>
89890>>>>>>>
89890>>>>>>>        // FROM database info:
89890>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89892>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89893>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89894>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89895>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89896>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89897>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89898>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89899>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89900>>>>>>>        End
89900>>>>>>>>
89900>>>>>>>
89900>>>>>>>        // TO database info:
89900>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89902>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89903>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89904>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89905>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89906>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89907>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89908>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89909>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89910>>>>>>>        End
89910>>>>>>>>
89910>>>>>>>
89910>>>>>>>        Function_Return APITableNameInfoCompare
89911>>>>>>>    End_Function
89912>>>>>>>
89912>>>>>>>    // Note:
89912>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89912>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89912>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89912>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89912>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89912>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
89914>>>>>>>        String sTableName
89914>>>>>>>        Boolean bOpen bExists bOK
89914>>>>>>>
89914>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
89915>>>>>>>        If (bExists = False) Begin
89917>>>>>>>            Function_Return ""
89918>>>>>>>        End
89918>>>>>>>>
89918>>>>>>>
89918>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89919>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89922>>>>>>>        If (bOpen = False) Begin
89924>>>>>>>            Get AutoConnectionIDLogin to bOK
89925>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89926>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89927>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89928>>>>>>>            Open hTable
89930>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89931>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89932>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89933>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89936>>>>>>>        End
89936>>>>>>>>
89936>>>>>>>        If (bOpen = True) Begin
89938>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89939>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89942>>>>>>>            // If blank it is an embedded table:
89942>>>>>>>            If (sTableName = "") Begin
89944>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89947>>>>>>>                Move 0 to LastErr
89948>>>>>>>                Move False to Err
89949>>>>>>>            End
89949>>>>>>>>
89949>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89950>>>>>>>        End
89950>>>>>>>>
89950>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89951>>>>>>>        Move 0 to LastErr
89952>>>>>>>
89952>>>>>>>        Function_Return sTableName
89953>>>>>>>    End_Function
89954>>>>>>>
89954>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89954>>>>>>>    // Returns 0 if unsuccessful.
89954>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89954>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89956>>>>>>>        String sValue sPrefixTableName sDriverID
89956>>>>>>>        Handle hTable hRetval
89956>>>>>>>
89956>>>>>>>        Get psDriverID to sDriverID
89957>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89959>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89960>>>>>>>        End
89960>>>>>>>>
89960>>>>>>>        Move 0 to hTable
89961>>>>>>>        Move 0 to hRetval
89962>>>>>>>        Repeat
89962>>>>>>>>
89962>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89965>>>>>>>            If (hTable <> 0) Begin
89967>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89970>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89972>>>>>>>                    Move hTable to hRetval
89973>>>>>>>                    Move 0 to hTable
89974>>>>>>>                End
89974>>>>>>>>
89974>>>>>>>            End
89974>>>>>>>>
89974>>>>>>>        Until (hTable = 0)
89976>>>>>>>
89976>>>>>>>        Function_Return hRetval
89977>>>>>>>    End_Function
89978>>>>>>>
89978>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89978>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89978>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89980>>>>>>>        Boolean bOK bExists
89980>>>>>>>        String sDataPath sBackupFolder
89980>>>>>>>
89980>>>>>>>        Close DF_ALL DF_PERMANENT
89981>>>>>>>        Send DoAdvance of ghoProgressBar
89982>>>>>>>
89982>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89983>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89984>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89985>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89986>>>>>>>
89986>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89987>>>>>>>        If (bExists = False) Begin
89989>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89990>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89991>>>>>>>            If (bExists = False) Begin
89993>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89994>>>>>>>>
89994>>>>>>>                Function_Return False
89995>>>>>>>            End
89995>>>>>>>>
89995>>>>>>>        End
89995>>>>>>>>
89995>>>>>>>
89995>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89996>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89997>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89998>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89999>>>>>>>        // We need to wait for Windows before we can copy files back
89999>>>>>>>        Sleep 2  
90000>>>>>>>        
90000>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90000>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90001>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90002>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90003>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90004>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90005>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90006>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90006>>>>>>>        
90006>>>>>>>
90006>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90007>>>>>>>        Function_Return True
90008>>>>>>>    End_Function
90009>>>>>>>    
90009>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90011>>>>>>>        Boolean bOK bRetval
90011>>>>>>>        Handle hTable
90011>>>>>>>        Integer iSize iCount
90011>>>>>>>        
90011>>>>>>>        Move True to bOK
90012>>>>>>>        Get UtilFilelistNoOfTables to iSize
90013>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90014>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90015>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90016>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90017>>>>>>>
90017>>>>>>>        Repeat
90017>>>>>>>>
90017>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90018>>>>>>>            Increment iCount
90019>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90022>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90024>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90025>>>>>>>                If (bRetval = False) Begin
90027>>>>>>>                    Move False to bOK
90028>>>>>>>                End
90028>>>>>>>>
90028>>>>>>>            End
90028>>>>>>>>
90028>>>>>>>        Until (hTable = 0)
90030>>>>>>>                
90030>>>>>>>        Function_Return bOK
90031>>>>>>>    End_Function           
90032>>>>>>>    
90032>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90032>>>>>>>    // After the header has been repaired - also makes a re-index.  
90032>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90032>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90034>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90034>>>>>>>        Integer iRetval
90034>>>>>>>        String sRootName sFileName sDataPath
90034>>>>>>>        
90034>>>>>>>        Move False to Err
90035>>>>>>>        Move 0 to LastErr 
90036>>>>>>>        Move True to bOK
90037>>>>>>>        
90037>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90038>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90040>>>>>>>            Function_Return True
90041>>>>>>>        End
90041>>>>>>>>
90041>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90042>>>>>>>        If (bIsAlias = True) Begin
90044>>>>>>>            Function_Return True
90045>>>>>>>        End
90045>>>>>>>>
90045>>>>>>>        
90045>>>>>>>        // Check for bad file and remove if exists
90045>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90048>>>>>>>        Set private.phCurrentTable to hTable  
90049>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90050>>>>>>>        
90050>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90050>>>>>>>        // with a "4077 - File in use" error.
90050>>>>>>>        Close DF_ALL DF_PERMANENT    
90051>>>>>>>        Open hTable
90053>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90056>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90057>>>>>>>        If (bIsOpen = False) Begin
90059>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90060>>>>>>>>
90060>>>>>>>            Function_Return False        
90061>>>>>>>        End
90061>>>>>>>>
90061>>>>>>>
90061>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90062>>>>>>>        If (bBadExists = True) Begin
90064>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90065>>>>>>>            Get vDeleteFile sFileName to iRetval
90066>>>>>>>        End
90066>>>>>>>>
90066>>>>>>>        
90066>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90067>>>>>>>        
90067>>>>>>>        Move False to Err
90068>>>>>>>        // **** Repair and reindex the table. ****
90068>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90069>>>>>>>
90069>>>>>>>        // Check for bad file: if it exists, something went wrong
90069>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90070>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90071>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90072>>>>>>>        If (bBadExists = True) Begin
90074>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90075>>>>>>>>
90075>>>>>>>            Move False to bOK
90076>>>>>>>        End
90076>>>>>>>>
90076>>>>>>>        Close hTable
90077>>>>>>>
90077>>>>>>>        Function_Return bOK
90078>>>>>>>    End_Function
90079>>>>>>>
90079>>>>>>>    // Repair and reindex the named DataFlex data-table.
90079>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90079>>>>>>>    // so use with care (make sure you only pass embedded table names).
90079>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90081>>>>>>>        String sMode
90081>>>>>>>        Integer iVoid
90081>>>>>>>
90081>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90082>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90083>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90084>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90089>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90090>>>>>>>        Function_Return (iVoid = 0)
90091>>>>>>>    End_Function
90092>>>>>>>
90092>>>>>>>    // Returns _two_ arrays.
90092>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90092>>>>>>>    // Also returns all files that are Alias files in a second array.
90092>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90092>>>>>>>    //            the DoSetAllMasterAndAlias message.
90092>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90094>>>>>>>        Integer[] iaFileIsAlias
90095>>>>>>>        Integer hTable iFileAlias iSize
90095>>>>>>>        Boolean bOpen
90095>>>>>>>
90095>>>>>>>        Move 0 to hTable
90096>>>>>>>        Repeat
90096>>>>>>>>
90096>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90099>>>>>>>            If (hTable <> 0) Begin
90101>>>>>>>                Open hTable
90103>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90106>>>>>>>                If (bOpen = True) Begin
90108>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90111>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90113>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90114>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90115>>>>>>>                    End
90115>>>>>>>>
90115>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90118>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90119>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90120>>>>>>>                    End
90120>>>>>>>>
90120>>>>>>>                End
90120>>>>>>>>
90120>>>>>>>            End
90120>>>>>>>>
90120>>>>>>>        Until (hTable = 0)
90122>>>>>>>
90122>>>>>>>        Function_Return iaFileIsAlias
90123>>>>>>>    End_Function  
90124>>>>>>>    
90124>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90124>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90126>>>>>>>        String sMode
90126>>>>>>>        Integer iRepairNeeded bIsOpen
90126>>>>>>>
90126>>>>>>>        Move "0" to sMode
90127>>>>>>>        Set private.phCurrentTable to hTable 
90128>>>>>>>        Close hTable
90129>>>>>>>        Open hTable
90131>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90134>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90139>>>>>>>
90139>>>>>>>        Function_Return iRepairNeeded
90140>>>>>>>    End_Function
90141>>>>>>>
90141>>>>>>>    // Helper function
90141>>>>>>>    // Takes two params:
90141>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90141>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90141>>>>>>>    // Returns:
90141>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90141>>>>>>>    //  DF_FILE_IS_MASTER if master
90141>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90141>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90143>>>>>>>        Integer i iSize
90143>>>>>>>
90143>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90144>>>>>>>        Decrement iSize
90145>>>>>>>        for i from 0 to iSize
90151>>>>>>>>
90151>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90153>>>>>>>                Function_Return DF_FILE_IS_MASTER
90154>>>>>>>            End
90154>>>>>>>>
90154>>>>>>>        Loop
90155>>>>>>>>
90155>>>>>>>
90155>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90156>>>>>>>        Decrement iSize
90157>>>>>>>        for i from 0 to iSize
90163>>>>>>>>
90163>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90165>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90166>>>>>>>            End
90166>>>>>>>>
90166>>>>>>>        Loop
90167>>>>>>>>
90167>>>>>>>
90167>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90168>>>>>>>    End_Function
90169>>>>>>>
90169>>>>>>>    // Determine the available indexes of a table.
90169>>>>>>>    //
90169>>>>>>>    // Arguments:
90169>>>>>>>    //   Handle hTable - The number of the table
90169>>>>>>>    //
90169>>>>>>>    // Returns:
90169>>>>>>>    //   String - A string to be used with the sort command
90169>>>>>>>    //   to re-index all indexes of a table.
90169>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90171>>>>>>>        String  sSortString
90171>>>>>>>        Integer iLastIndex iNumSegments iCount
90171>>>>>>>
90171>>>>>>>        Move "" to sSortString
90172>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90175>>>>>>>
90175>>>>>>>        for iCount from 1 to iLastIndex
90181>>>>>>>>
90181>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90184>>>>>>>            If iNumSegments Begin
90186>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90189>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90190>>>>>>>            End
90190>>>>>>>>
90190>>>>>>>        Loop
90191>>>>>>>>
90191>>>>>>>
90191>>>>>>>        Function_Return sSortString
90192>>>>>>>    End_Function
90193>>>>>>>
90193>>>>>>>    
90193>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90193>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90195>>>>>>>        Function_Return False
90196>>>>>>>    End_Function
90197>>>>>>>
90197>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90197>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90199>>>>>>>        Boolean bIsSame
90199>>>>>>>        Integer iCount iColumns iColumn
90199>>>>>>>
90199>>>>>>>        Move True to bIsSame
90200>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90201>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90202>>>>>>>        Decrement iColumns
90203>>>>>>>
90203>>>>>>>        for iCount from 0 to iColumns
90209>>>>>>>>
90209>>>>>>>            Set piPosition of ghoProgressBar to iCount
90210>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90211>>>>>>>            If (bIsSame = False) Begin
90213>>>>>>>                Function_Return False
90214>>>>>>>            End
90214>>>>>>>>
90214>>>>>>>        Loop
90215>>>>>>>>
90215>>>>>>>
90215>>>>>>>        Function_Return (bIsSame = True)
90216>>>>>>>    End_Function
90217>>>>>>>
90217>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90217>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90219>>>>>>>        Integer iFromType iToType iDbType
90219>>>>>>>        tColumnType ColumnType
90219>>>>>>>        tColumnType ColumnType
90219>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90219>>>>>>>
90219>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90221>>>>>>>            Function_Return False
90222>>>>>>>        End
90222>>>>>>>>
90222>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90224>>>>>>>            Function_Return False
90225>>>>>>>        End
90225>>>>>>>>
90225>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90227>>>>>>>            Function_Return False
90228>>>>>>>        End                                                                
90228>>>>>>>>
90228>>>>>>>
90228>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90230>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90232>>>>>>>                Function_Return False
90233>>>>>>>            End
90233>>>>>>>>
90233>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90235>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90237>>>>>>>                    End
90237>>>>>>>>
90237>>>>>>>                Else Begin
90238>>>>>>>                    Function_Return False
90239>>>>>>>                End
90239>>>>>>>>
90239>>>>>>>            End
90239>>>>>>>>
90239>>>>>>>        End
90239>>>>>>>>
90239>>>>>>>
90239>>>>>>>        Get piDbType                       to iDbType
90240>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90241>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90242>>>>>>>
90242>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90242>>>>>>>        // data types between Embedded and SQL.
90242>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90244>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90245>>>>>>>        End
90245>>>>>>>>
90245>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90247>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90248>>>>>>>        End
90248>>>>>>>>
90248>>>>>>>
90248>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90249>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90250>>>>>>>
90250>>>>>>>        // Make Date and DateTime comparison?
90250>>>>>>>        If (bCompareDate_DataTime = True) Begin
90252>>>>>>>            If (iFromType <> iToType) Begin
90254>>>>>>>                Function_Return False
90255>>>>>>>            End
90255>>>>>>>>
90255>>>>>>>        End
90255>>>>>>>>
90255>>>>>>>
90255>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90255>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90257>>>>>>>            If (iFromType <> iToType) Begin
90259>>>>>>>                Function_Return False
90260>>>>>>>            End
90260>>>>>>>>
90260>>>>>>>        End
90260>>>>>>>>
90260>>>>>>>
90260>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90260>>>>>>>        If (bIsDateTypeFrom = False) Begin
90262>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90264>>>>>>>                Function_Return False
90265>>>>>>>            End
90265>>>>>>>>
90265>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90267>>>>>>>                Function_Return False
90268>>>>>>>            End
90268>>>>>>>>
90268>>>>>>>        End
90268>>>>>>>>
90268>>>>>>>
90268>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90270>>>>>>>            Function_Return False
90271>>>>>>>        End
90271>>>>>>>>
90271>>>>>>>
90271>>>>>>>        Function_Return True
90272>>>>>>>    End_Function
90273>>>>>>>
90273>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90275>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90275>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90275>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90275>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90277>>>>>>>        String sDriverID sRootName sLogicalName
90277>>>>>>>
90277>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90278>>>>>>>        Get piDbType to iDbType
90279>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90282>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90285>>>>>>>
90285>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90288>>>>>>>        If (bIsOpen = False) Begin
90290>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90291>>>>>>>            Open hTable
90293>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90294>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90297>>>>>>>            If (bIsOpen = False) Begin
90299>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90300>>>>>>>                Move True to APIColumnsEmpty[0].bError
90301>>>>>>>                Function_Return APIColumnsEmpty
90302>>>>>>>            End
90302>>>>>>>>
90302>>>>>>>        End
90302>>>>>>>>
90302>>>>>>>
90302>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90305>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90306>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90307>>>>>>>
90307>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90308>>>>>>>        If (bIsSqlTable = True) Begin
90310>>>>>>>            Get _UtilTableExists hTable to bExists
90311>>>>>>>            If (bExists = False) Begin
90313>>>>>>>                Move True to APIColumnsEmpty[0].bError
90314>>>>>>>                Function_Return APIColumnsEmpty
90315>>>>>>>            End
90315>>>>>>>>
90315>>>>>>>        End
90315>>>>>>>>
90315>>>>>>>
90315>>>>>>>        Move 0 to iCount
90316>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90319>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90320>>>>>>>
90320>>>>>>>        for iColumn from 1 to iNumColumns
90326>>>>>>>>
90326>>>>>>>            Move 0 to iOptions
90327>>>>>>>            Move False to bIdentityKey
90328>>>>>>>            Move False to Err
90329>>>>>>>            Move 0     to LastErr
90330>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90331>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90332>>>>>>>            If (bDawSqlDriver = True) Begin
90334>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90335>>>>>>>                If (bIsSqlTable = True) Begin
90337>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90340>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90341>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90344>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90347>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90350>>>>>>>                End
90350>>>>>>>>
90350>>>>>>>                Else Begin
90351>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90354>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90355>>>>>>>                End
90355>>>>>>>>
90355>>>>>>>
90355>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90355>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90358>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90359>>>>>>>                If (bExists = False) Begin
90361>>>>>>>                    Move 0 to APIColumns[iCount].iType
90362>>>>>>>                End
90362>>>>>>>>
90362>>>>>>>                If (bExists = True) Begin
90364>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90367>>>>>>>                End
90367>>>>>>>>
90367>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90368>>>>>>>                If (bIdentityKey = True) Begin
90370>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90371>>>>>>>                End
90371>>>>>>>>
90371>>>>>>>            End
90371>>>>>>>>
90371>>>>>>>            Else Begin
90372>>>>>>>                Move False to Err
90373>>>>>>>                Move 0     to LastErr
90374>>>>>>>                If (bIsSqlTable = True) Begin
90376>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90379>>>>>>>                End
90379>>>>>>>>
90379>>>>>>>                Else Begin
90380>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90383>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90384>>>>>>>                End
90384>>>>>>>>
90384>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90384>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90385>>>>>>>                If (bExists = False) Begin
90387>>>>>>>                    Move 0 to APIColumns[iCount].iType
90388>>>>>>>                End
90388>>>>>>>>
90388>>>>>>>            End
90388>>>>>>>>
90388>>>>>>>
90388>>>>>>>            If (bExists = True) Begin
90390>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90391>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90394>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90394>>>>>>>//                If (bIsSqlTable = True) Begin
90394>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90394>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90394>>>>>>>//                End
90394>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90397>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90400>>>>>>>
90400>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90400>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90400>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90402>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90405>>>>>>>                    If (iType = DF_OVERLAP) Begin
90407>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90408>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90409>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90410>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90411>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90412>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90413>>>>>>>                        Decrement iCount
90414>>>>>>>                    End
90414>>>>>>>>
90414>>>>>>>                End
90414>>>>>>>>
90414>>>>>>>            End
90414>>>>>>>>
90414>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90415>>>>>>>            If (bUserCancel = True) Begin
90417>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90418>>>>>>>                Function_Return APIColumnsEmpty
90419>>>>>>>            End
90419>>>>>>>>
90419>>>>>>>            Increment iCount
90420>>>>>>>        Loop
90421>>>>>>>>
90421>>>>>>>
90421>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90422>>>>>>>        Function_Return APIColumns
90423>>>>>>>    End_Function
90424>>>>>>>
90424>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90424>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90424>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90424>>>>>>>    // have "holes" in the series of index numbers.
90424>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90426>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90426>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90427>>>>>>>        tAPIColumnCompare   APIColumnCompare
90427>>>>>>>        tAPIColumnCompare   APIColumnCompare
90427>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90427>>>>>>>
90427>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90428>>>>>>>        Decrement iSizeFrom
90429>>>>>>>        for iCount from 0 to iSizeFrom
90435>>>>>>>>
90435>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90436>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90437>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90438>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90439>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90440>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90441>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90442>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90443>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90444>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90445>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90446>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90447>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90448>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90449>>>>>>>        Loop
90450>>>>>>>>
90450>>>>>>>
90450>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90451>>>>>>>        Decrement iSizeTo
90452>>>>>>>        for iCount from 0 to iSizeTo
90458>>>>>>>>
90458>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90459>>>>>>>            // Search if the field number already exists in the array; else add it.
90459>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90460>>>>>>>            If (iItem = -1) Begin
90462>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90463>>>>>>>            End
90463>>>>>>>>
90463>>>>>>>
90463>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90464>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90465>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90466>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90467>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90468>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90469>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90470>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90471>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90472>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90473>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90474>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90475>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90476>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90477>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90478>>>>>>>        Loop
90479>>>>>>>>
90479>>>>>>>
90479>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90480>>>>>>>
90480>>>>>>>        Function_Return aAPIColumnCompare
90481>>>>>>>    End_Function
90482>>>>>>>
90482>>>>>>>    // Checks if a field name exists in a table definition
90482>>>>>>>    // Returns True if it does
90482>>>>>>>    // Sample:
90482>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90482>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90484>>>>>>>        Integer iNumColumns iColumn
90484>>>>>>>        String sColumn
90484>>>>>>>        Boolean bExists bOK bOpen
90484>>>>>>>
90484>>>>>>>        Get AutoConnectionIDLogin to bOK
90485>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90486>>>>>>>        Open hTable
90488>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90489>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90492>>>>>>>        If (bOpen = False) Begin
90494>>>>>>>            Function_Return False
90495>>>>>>>        End
90495>>>>>>>>
90495>>>>>>>
90495>>>>>>>        Move False to bExists
90496>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90499>>>>>>>        for iColumn from 1 to iNumColumns
90505>>>>>>>>
90505>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90508>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90510>>>>>>>                Move iNumColumns to iColumn
90511>>>>>>>                Move True to bExists
90512>>>>>>>            End
90512>>>>>>>>
90512>>>>>>>        Loop
90513>>>>>>>>
90513>>>>>>>        Close hTable
90514>>>>>>>
90514>>>>>>>        Function_Return bExists
90515>>>>>>>    End_Function
90516>>>>>>>
90516>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90516>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90518>>>>>>>        Integer iNumColumns iColumn iRetval
90518>>>>>>>        String sColumn
90518>>>>>>>        Boolean bOK bOpen
90518>>>>>>>
90518>>>>>>>        Get AutoConnectionIDLogin to bOK
90519>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90520>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90521>>>>>>>        Open hTable
90523>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90524>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90527>>>>>>>        If (bOpen = False) Begin
90529>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90530>>>>>>>            Function_Return False
90531>>>>>>>        End
90531>>>>>>>>
90531>>>>>>>
90531>>>>>>>        Move 0 to iColumn
90532>>>>>>>        Move 0 to iRetval
90533>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90536>>>>>>>        for iColumn from 1 to iNumColumns
90542>>>>>>>>
90542>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90545>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90547>>>>>>>                Move iColumn to iRetval
90548>>>>>>>                Move iNumColumns to iColumn
90549>>>>>>>            End
90549>>>>>>>>
90549>>>>>>>        Loop
90550>>>>>>>>
90550>>>>>>>        Close hTable
90551>>>>>>>
90551>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90552>>>>>>>        Function_Return iRetval
90553>>>>>>>    End_Function
90554>>>>>>>
90554>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90554>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90554>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90556>>>>>>>        tColumnType RetvalType
90556>>>>>>>        tColumnType RetvalType
90556>>>>>>>
90556>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90557>>>>>>>        Function_Return RetvalType.iSQLType
90558>>>>>>>    End_Function
90559>>>>>>>
90559>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90559>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90559>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90561>>>>>>>        tColumnType RetvalType
90561>>>>>>>        tColumnType RetvalType
90561>>>>>>>
90561>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90562>>>>>>>        Function_Return RetvalType.sSQLType
90563>>>>>>>    End_Function
90564>>>>>>>
90564>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90566>>>>>>>        tColumnType RetvalType
90566>>>>>>>        tColumnType RetvalType
90566>>>>>>>
90566>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90567>>>>>>>        Function_Return RetvalType.sPrecision
90568>>>>>>>    End_Function
90569>>>>>>>
90569>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90571>>>>>>>        tColumnType RetvalType
90571>>>>>>>        tColumnType RetvalType
90571>>>>>>>
90571>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90572>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90572>>>>>>>        // if the column type length is _not_ fixed.
90572>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90573>>>>>>>    End_Function
90574>>>>>>>
90574>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90576>>>>>>>        tColumnType RetvalType
90576>>>>>>>        tColumnType RetvalType
90576>>>>>>>        String sValue
90576>>>>>>>        Integer iRetval iPos
90576>>>>>>>
90576>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90577>>>>>>>        Move RetvalType.sPrecision to sValue
90578>>>>>>>        Move (Pos(".", sValue)) to iPos
90579>>>>>>>        If (iPos <> 0) Begin
90581>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90582>>>>>>>        End
90582>>>>>>>>
90582>>>>>>>        Else Begin
90583>>>>>>>            Move sValue to iRetval
90584>>>>>>>        End
90584>>>>>>>>
90584>>>>>>>        Function_Return iRetval
90585>>>>>>>    End_Function
90586>>>>>>>
90586>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90588>>>>>>>        tColumnType RetvalType
90588>>>>>>>        tColumnType RetvalType
90588>>>>>>>        String sValue
90588>>>>>>>        Integer iRetval iPos
90588>>>>>>>
90588>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90589>>>>>>>        Move RetvalType.sPrecision to sValue
90590>>>>>>>        Move (Pos(".", sValue)) to iPos
90591>>>>>>>        If (iPos = 0) Begin
90593>>>>>>>            Function_Return 0
90594>>>>>>>        End
90594>>>>>>>>
90594>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90595>>>>>>>
90595>>>>>>>        Function_Return iRetval
90596>>>>>>>    End_Function
90597>>>>>>>
90597>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90597>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90599>>>>>>>        Function_Return False
90600>>>>>>>    End_Function
90601>>>>>>>
90601>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90601>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90603>>>>>>>        Boolean bIsSame
90603>>>>>>>        Integer iCount iSize
90603>>>>>>>
90603>>>>>>>        Move True to bIsSame
90604>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90605>>>>>>>        Decrement iSize
90606>>>>>>>        For iCount from 0 to iSize
90612>>>>>>>>
90612>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90613>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90614>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90615>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90616>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90617>>>>>>>            If (bIsSame = False) Begin
90619>>>>>>>                Function_Return False
90620>>>>>>>            End
90620>>>>>>>>
90620>>>>>>>        Loop
90621>>>>>>>>
90621>>>>>>>
90621>>>>>>>        Function_Return bIsSame
90622>>>>>>>    End_Function
90623>>>>>>>
90623>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90623>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90625>>>>>>>        Boolean bIsSame
90625>>>>>>>        Integer iSegment
90625>>>>>>>
90625>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90626>>>>>>>        If (bIsSame = False) Begin
90628>>>>>>>            Function_Return False
90629>>>>>>>        End
90629>>>>>>>>
90629>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90630>>>>>>>        If (bIsSame = False) Begin
90632>>>>>>>            Function_Return False
90633>>>>>>>        End
90633>>>>>>>>
90633>>>>>>>
90633>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90635>>>>>>>            // * We should probably not compare SQL index names?
90635>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90635>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90635>>>>>>>            //     Function_Return False
90635>>>>>>>            // End
90635>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90636>>>>>>>            If (bIsSame = False) Begin
90638>>>>>>>                Function_Return False
90639>>>>>>>            End
90639>>>>>>>>
90639>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90640>>>>>>>            If (bIsSame = False) Begin
90642>>>>>>>                Function_Return False
90643>>>>>>>            End
90643>>>>>>>>
90643>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90644>>>>>>>            If (bIsSame = False) Begin
90646>>>>>>>                Function_Return False
90647>>>>>>>            End
90647>>>>>>>>
90647>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90648>>>>>>>            If (bIsSame = False) Begin
90650>>>>>>>                Function_Return False
90651>>>>>>>            End
90651>>>>>>>>
90651>>>>>>>        End
90651>>>>>>>>
90651>>>>>>>
90651>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90652>>>>>>>        Move (iSegment = -1) to bIsSame
90653>>>>>>>
90653>>>>>>>        Function_Return (bIsSame = True)
90654>>>>>>>    End_Function
90655>>>>>>>
90655>>>>>>>    // Compares each segment for the passed index.
90655>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90655>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90657>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90657>>>>>>>        Boolean bIsSame
90657>>>>>>>
90657>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90658>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90659>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90660>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90661>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90662>>>>>>>
90662>>>>>>>        Decrement iNumSegments
90663>>>>>>>        for iSegment from 0 to iNumSegments
90669>>>>>>>>
90669>>>>>>>            Move False to bIsSame
90670>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90672>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90673>>>>>>>            End
90673>>>>>>>>
90673>>>>>>>            If (bIsSame = False) Begin
90675>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90676>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90677>>>>>>>                Function_Return iSegment
90678>>>>>>>            End
90678>>>>>>>>
90678>>>>>>>        Loop
90679>>>>>>>>
90679>>>>>>>
90679>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90680>>>>>>>        Function_Return -1 // This means bIsSame = True
90681>>>>>>>    End_Function
90682>>>>>>>
90682>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90684>>>>>>>        Boolean bIsSame
90684>>>>>>>
90684>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90685>>>>>>>        If (bIsSame = False) Begin
90687>>>>>>>            Function_Return False
90688>>>>>>>        End
90688>>>>>>>>
90688>>>>>>>        If (bCompareIndexUppercase = True) Begin
90690>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90691>>>>>>>            If (bIsSame = False) Begin
90693>>>>>>>                Function_Return False
90694>>>>>>>            End
90694>>>>>>>>
90694>>>>>>>        End
90694>>>>>>>>
90694>>>>>>>        If (bCompareIndexAscending = True) Begin
90696>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90697>>>>>>>            If (bIsSame = False) Begin
90699>>>>>>>                Function_Return False
90700>>>>>>>            End
90700>>>>>>>>
90700>>>>>>>        End
90700>>>>>>>>
90700>>>>>>>
90700>>>>>>>        Function_Return True
90701>>>>>>>    End_Function
90702>>>>>>>
90702>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90704>>>>>>>        Boolean bIsSame bOK
90704>>>>>>>        Integer iSize iSizeTo iCount
90704>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90704>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90705>>>>>>>
90705>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90706>>>>>>>        If (iSize = 0) Begin
90708>>>>>>>            Function_Return True
90709>>>>>>>        End
90709>>>>>>>>
90709>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90710>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90711>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90712>>>>>>>
90712>>>>>>>        for iCount from 0 to (iSize - 1)
90718>>>>>>>>
90718>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90719>>>>>>>            If (bIsSame = False) Begin
90721>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90722>>>>>>>            End
90722>>>>>>>>
90722>>>>>>>        Loop
90723>>>>>>>>
90723>>>>>>>
90723>>>>>>>        // We probably should delete other indexes if they exists.
90723>>>>>>>        for iCount from (iSize +1) to iSizeTo
90729>>>>>>>>
90729>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90730>>>>>>>        Loop
90731>>>>>>>>
90731>>>>>>>
90731>>>>>>>        Function_Return bOK
90732>>>>>>>    End_Function
90733>>>>>>>
90733>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90735>>>>>>>        tAPIIndex[] APIIndexes
90735>>>>>>>        tAPIIndex[] APIIndexes
90736>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90736>>>>>>>        String sDriverID
90736>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90736>>>>>>>
90736>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90737>>>>>>>        Get psDriverID to sDriverID
90738>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90739>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90740>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90743>>>>>>>        If (bIsOpen = False) Begin
90745>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90746>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90747>>>>>>>            Open hTable
90749>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90750>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90751>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90754>>>>>>>            If (bIsOpen = False) Begin
90756>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90757>>>>>>>                Move True to APIIndexes[0].bError
90758>>>>>>>                Function_Return APIIndexes
90759>>>>>>>            End
90759>>>>>>>>
90759>>>>>>>        End
90759>>>>>>>>
90759>>>>>>>
90759>>>>>>>        Move 0 to iCount
90760>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90763>>>>>>>        for iIndex from 1 to iIndexes
90769>>>>>>>>
90769>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90769>>>>>>>            // numbers doesn't not need to be consequitive:
90769>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90772>>>>>>>            If (iNumSegments > 0) Begin
90774>>>>>>>
90774>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90775>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90778>>>>>>>                If (bIsSQLTable = True) Begin
90780>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90783>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90786>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90789>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90792>>>>>>>                End
90792>>>>>>>>
90792>>>>>>>
90792>>>>>>>                Move 0 to iSegmentCount
90793>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90796>>>>>>>                For iSegment from 1 to iNumSegments
90802>>>>>>>>
90802>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90805>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90806>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90809>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90812>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90815>>>>>>>                    Increment iSegmentCount
90816>>>>>>>                Loop
90817>>>>>>>>
90817>>>>>>>                Increment iCount
90818>>>>>>>            End
90818>>>>>>>>
90818>>>>>>>        Loop
90819>>>>>>>>
90819>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90820>>>>>>>
90820>>>>>>>        Function_Return APIIndexes
90821>>>>>>>    End_Function
90822>>>>>>>
90822>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90822>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90822>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90822>>>>>>>    // have "holes" in the series of index numbers.
90822>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90824>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90824>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90825>>>>>>>        tAPIIndexCompare   APIIndexCompare
90825>>>>>>>        tAPIIndexCompare   APIIndexCompare
90825>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90825>>>>>>>
90825>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90826>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90827>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90829>>>>>>>            Function_Return aAPIIndexCompare
90830>>>>>>>        End
90830>>>>>>>>
90830>>>>>>>
90830>>>>>>>        Decrement iSizeFrom
90831>>>>>>>        for iCount from 0 to iSizeFrom
90837>>>>>>>>
90837>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90838>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90839>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90840>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90841>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90842>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90843>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90844>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90845>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90846>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90847>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90848>>>>>>>        Loop
90849>>>>>>>>
90849>>>>>>>
90849>>>>>>>        Decrement iSizeTo
90850>>>>>>>        for iCount from 0 to iSizeTo
90856>>>>>>>>
90856>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90857>>>>>>>            // Search if the Index number already exists in the array; else add it.
90857>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90858>>>>>>>            If (iItem = -1) Begin
90860>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90861>>>>>>>            End
90861>>>>>>>>
90861>>>>>>>
90861>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90862>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90863>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90864>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90865>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90866>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90867>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90868>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90869>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90870>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90871>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90872>>>>>>>        Loop
90873>>>>>>>>
90873>>>>>>>
90873>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90874>>>>>>>
90874>>>>>>>        Function_Return aAPIIndexCompare
90875>>>>>>>    End_Function
90876>>>>>>>
90876>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90876>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90878>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90878>>>>>>>        String sDriverID
90878>>>>>>>
90878>>>>>>>        Get psDriverID to sDriverID
90879>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90880>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90881>>>>>>>        If (bIsSqlTable = True) Begin
90883>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90884>>>>>>>        End
90884>>>>>>>>
90884>>>>>>>
90884>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90885>>>>>>>        If (bIsSame = False) Begin
90887>>>>>>>            Function_Return False
90888>>>>>>>        End
90888>>>>>>>>
90888>>>>>>>
90888>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90890>>>>>>>            // Don't think we should do this. Or should we?
90890>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90890>>>>>>>
90890>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90891>>>>>>>            If (bIsSame = False) Begin
90893>>>>>>>                Function_Return False
90894>>>>>>>            End
90894>>>>>>>>
90894>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90895>>>>>>>            If (bIsSame = False) Begin
90897>>>>>>>                Function_Return False
90898>>>>>>>            End
90898>>>>>>>>
90898>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90899>>>>>>>            If (bIsSame = False) Begin
90901>>>>>>>                Function_Return False
90902>>>>>>>            End
90902>>>>>>>>
90902>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90903>>>>>>>            If (bIsSame = False) Begin
90905>>>>>>>                Function_Return False
90906>>>>>>>            End
90906>>>>>>>>
90906>>>>>>>        End
90906>>>>>>>>
90906>>>>>>>
90906>>>>>>>        Function_Return bIsSame
90907>>>>>>>    End_Function
90908>>>>>>>
90908>>>>>>>    // DF_INDEX_SQL_TYPE values
90908>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90908>>>>>>>    // returns a string with the name.
90908>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90910>>>>>>>        String sRetval
90910>>>>>>>            Case Begin
90910>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
90912>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
90913>>>>>>>                    Case Break
90914>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
90917>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
90918>>>>>>>                    Case Break
90919>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
90922>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
90923>>>>>>>                    Case Break
90924>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
90927>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
90928>>>>>>>                    Case Break
90929>>>>>>>                Case Else
90929>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
90930>>>>>>>            Case End
90930>>>>>>>        Function_Return sRetval
90931>>>>>>>    End_Function
90932>>>>>>>
90932>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90932>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90934>>>>>>>        Function_Return False
90935>>>>>>>    End_Function
90936>>>>>>>
90936>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90936>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90938>>>>>>>        Boolean bIsSame
90938>>>>>>>        Integer iSize iCount
90938>>>>>>>
90938>>>>>>>        Move True to bIsSame
90939>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90940>>>>>>>        Decrement iSize
90941>>>>>>>        For iCount from 0 to iSize
90947>>>>>>>>
90947>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90948>>>>>>>            If (bIsSame = False) Begin
90950>>>>>>>                Function_Return False
90951>>>>>>>            End
90951>>>>>>>>
90951>>>>>>>        Loop
90952>>>>>>>>
90952>>>>>>>
90952>>>>>>>        Function_Return bIsSame
90953>>>>>>>    End_Function
90954>>>>>>>
90954>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90954>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90956>>>>>>>        Boolean bIsSame
90956>>>>>>>
90956>>>>>>>        Move True to bIsSame
90957>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90959>>>>>>>            Function_Return False
90960>>>>>>>        End
90960>>>>>>>>
90960>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90962>>>>>>>            Function_Return False
90963>>>>>>>        End
90963>>>>>>>>
90963>>>>>>>
90963>>>>>>>        // We could also compare field names, but I don't think that is necessary...
90963>>>>>>>
90963>>>>>>>        Function_Return bIsSame
90964>>>>>>>    End_Function
90965>>>>>>>
90965>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90965>>>>>>>    // already exists.
90965>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90967>>>>>>>        Boolean bOK
90967>>>>>>>        Integer iSizeTo iSize iCount iColumn
90967>>>>>>>        String sDriverID
90967>>>>>>>
90967>>>>>>>        Move True to bOK
90968>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90969>>>>>>>        If (iSizeTo > 0) Begin
90971>>>>>>>            Get AutoConnectionIDLogin to bOK
90972>>>>>>>            Move False to Err
90973>>>>>>>            Open hTable Mode DF_EXCLUSIVE
90975>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90978>>>>>>>            Decrement iSizeTo
90979>>>>>>>
90979>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90979>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90979>>>>>>>            Structure_Start hTable sDriverID
90980>>>>>>>                for iCount from 0 to iSizeTo
90986>>>>>>>>
90986>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90987>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90990>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90993>>>>>>>                Loop
90994>>>>>>>>
90994>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90995>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90997>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90998>>>>>>>        End
90998>>>>>>>>
90998>>>>>>>
90998>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90999>>>>>>>        Decrement iSize
91000>>>>>>>        for iCount from 0 to iSize
91006>>>>>>>>
91006>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91007>>>>>>>        Loop
91008>>>>>>>>
91008>>>>>>>
91008>>>>>>>        Function_Return bOK
91009>>>>>>>    End_Function
91010>>>>>>>
91010>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91012>>>>>>>        tAPIRelation[] APIRelations
91012>>>>>>>        tAPIRelation[] APIRelations
91013>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91013>>>>>>>        Handle hParent
91013>>>>>>>        Boolean bIsOpen
91013>>>>>>>
91013>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91014>>>>>>>        Move 0 to iCount
91015>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91018>>>>>>>        If (bIsOpen = False) Begin
91020>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91021>>>>>>>            Open hTable
91023>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91024>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91027>>>>>>>            If (bIsOpen = False) Begin
91029>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91030>>>>>>>                Move True to APIRelations[0].bError
91031>>>>>>>                Function_Return APIRelations
91032>>>>>>>            End
91032>>>>>>>>
91032>>>>>>>        End
91032>>>>>>>>
91032>>>>>>>
91032>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91035>>>>>>>        For iColumn from 1 to iNumColumns
91041>>>>>>>>
91041>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91044>>>>>>>            If (hParent <> 0) Begin
91046>>>>>>>                Open hParent
91048>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91049>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91052>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91053>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91056>>>>>>>
91056>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91057>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91060>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91063>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91064>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91067>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91068>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91069>>>>>>>                Move False                                              to APIRelations[iCount].bError
91070>>>>>>>                Close hParent
91071>>>>>>>                Increment iCount
91072>>>>>>>            End
91072>>>>>>>>
91072>>>>>>>        Loop
91073>>>>>>>>
91073>>>>>>>
91073>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91074>>>>>>>        Function_Return APIRelations
91075>>>>>>>    End_Function
91076>>>>>>>
91076>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91076>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91076>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91078>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91078>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91079>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91079>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91080>>>>>>>        tAPIRelationCompare   APIRelationCompare
91080>>>>>>>        tAPIRelationCompare   APIRelationCompare
91080>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91080>>>>>>>
91080>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91081>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91082>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91084>>>>>>>            Function_Return aAPIRelationCompare
91085>>>>>>>        End
91085>>>>>>>>
91085>>>>>>>
91085>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91086>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91087>>>>>>>
91087>>>>>>>        Decrement iSizeFrom
91088>>>>>>>        for iCount from 0 to iSizeFrom
91094>>>>>>>>
91094>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91095>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91096>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91097>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91098>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91099>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91100>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91101>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91102>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91103>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91104>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91105>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91106>>>>>>>        Loop
91107>>>>>>>>
91107>>>>>>>
91107>>>>>>>        Decrement iSizeTo
91108>>>>>>>        for iCount from 0 to iSizeTo
91114>>>>>>>>
91114>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91115>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91116>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91117>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91118>>>>>>>
91118>>>>>>>            // Search if the relation already exists in the array; else add it.
91118>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91119>>>>>>>            If (iItem = -1) Begin
91121>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91122>>>>>>>            End
91122>>>>>>>>
91122>>>>>>>
91122>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91123>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91124>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91125>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91126>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91127>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91128>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91129>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91130>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91131>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91132>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91133>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91134>>>>>>>        Loop
91135>>>>>>>>
91135>>>>>>>
91135>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91136>>>>>>>
91136>>>>>>>        Function_Return aAPIRelationCompare
91137>>>>>>>    End_Function
91138>>>>>>>
91138>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91138>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91140>>>>>>>        Function_Return False
91141>>>>>>>    End_Function
91142>>>>>>>
91142>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91142>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91142>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91142>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91144>>>>>>>        Boolean bFound
91144>>>>>>>
91144>>>>>>>        Move False to Err
91145>>>>>>>        Open CodeMast
91147>>>>>>>        Open CodeType
91149>>>>>>>
91149>>>>>>>        If (bCodeType = True) Begin
91151>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91152>>>>>>>            Clear CodeType
91153>>>>>>>            Move sTypeValue to CODETYPE.Type
91154>>>>>>>            Find eq CODETYPE by 1
91155>>>>>>>>
91155>>>>>>>            Move Found to bFound
91156>>>>>>>            If (bFound = True) Begin
91158>>>>>>>                Reread CodeType
91162>>>>>>>            End
91162>>>>>>>>
91162>>>>>>>            Else Begin
91163>>>>>>>                Clear CodeType
91164>>>>>>>            End
91164>>>>>>>>
91164>>>>>>>
91164>>>>>>>            Move sTypeValue to CODETYPE.Type
91165>>>>>>>            Move sValue2    to CODETYPE.Description
91166>>>>>>>            Move sValue3    to CODETYPE.Comment
91167>>>>>>>            SaveRecord CODETYPE
91168>>>>>>>
91168>>>>>>>            If (bFound = True) Begin
91170>>>>>>>                Unlock
91171>>>>>>>>
91171>>>>>>>            End
91171>>>>>>>>
91171>>>>>>>        End
91171>>>>>>>>
91171>>>>>>>
91171>>>>>>>        If (bCodeType = False) Begin
91173>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91174>>>>>>>            Clear CODEMAST
91175>>>>>>>            Move sTypeValue to CODEMAST.Type
91176>>>>>>>            Move sValue2    to CODEMAST.Code
91177>>>>>>>            Find eq CODEMAST by 1
91178>>>>>>>>
91178>>>>>>>            Move Found to bFound
91179>>>>>>>            If (bFound = True) Begin
91181>>>>>>>                Reread CODEMAST
91185>>>>>>>            End
91185>>>>>>>>
91185>>>>>>>            Else Begin
91186>>>>>>>                Clear CODEMAST
91187>>>>>>>            End
91187>>>>>>>>
91187>>>>>>>
91187>>>>>>>            Move sTypeValue to CODEMAST.Type
91188>>>>>>>            Move sValue2    to CODEMAST.Code
91189>>>>>>>            Move sValue3    to CODEMAST.Description
91190>>>>>>>            SaveRecord CODEMAST
91191>>>>>>>
91191>>>>>>>            If (bFound = True) Begin
91193>>>>>>>                Unlock
91194>>>>>>>>
91194>>>>>>>            End
91194>>>>>>>>
91194>>>>>>>        End
91194>>>>>>>>
91194>>>>>>>
91194>>>>>>>        Close CodeMast
91195>>>>>>>        Close CodeType
91196>>>>>>>
91196>>>>>>>        Function_Return (Err = False)
91197>>>>>>>    End_Function
91198>>>>>>>
91198>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91198>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91198>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91200>>>>>>>        Boolean bFound
91200>>>>>>>
91200>>>>>>>        Move False to Err
91201>>>>>>>        Open CodeMast
91203>>>>>>>        Open CodeType
91205>>>>>>>
91205>>>>>>>        Clear CodeType
91206>>>>>>>        Move sFromValue to CODETYPE.Type
91207>>>>>>>        Find eq CODETYPE.Type
91208>>>>>>>>
91208>>>>>>>        If (Found = True) Begin
91210>>>>>>>            Reread CODETYPE
91214>>>>>>>                Move sToValue to CODETYPE.Type
91215>>>>>>>                SaveRecord CODETYPE
91216>>>>>>>            Unlock
91217>>>>>>>>
91217>>>>>>>        End
91217>>>>>>>>
91217>>>>>>>
91217>>>>>>>        Clear CODEMAST
91218>>>>>>>        Find gt CODEMAST by Recnum
91219>>>>>>>>
91219>>>>>>>        While (Found = True)
91223>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91224>>>>>>>            If (bFound = True) Begin
91226>>>>>>>                Reread CODEMAST
91230>>>>>>>                    Move sToValue to CODEMAST.Type
91231>>>>>>>                    SaveRecord CODEMAST
91232>>>>>>>                Unlock
91233>>>>>>>>
91233>>>>>>>            End
91233>>>>>>>>
91233>>>>>>>            Find gt CODEMAST by Recnum
91234>>>>>>>>
91234>>>>>>>        Loop
91235>>>>>>>>
91235>>>>>>>
91235>>>>>>>        Close CodeMast
91236>>>>>>>        Close CodeType
91237>>>>>>>
91237>>>>>>>        Function_Return (Err = False)
91238>>>>>>>    End_Function
91239>>>>>>>
91239>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91239>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91241>>>>>>>        Boolean bFound
91241>>>>>>>
91241>>>>>>>        Move False to Err
91242>>>>>>>        Open CodeMast
91244>>>>>>>
91244>>>>>>>        Clear CODEMAST
91245>>>>>>>        Move sTypeValue to CODEMAST.Type
91246>>>>>>>        Move sValue2    to CODEMAST.Code
91247>>>>>>>        Find eq CODEMAST.Code
91248>>>>>>>>
91248>>>>>>>        Move Found to bFound
91249>>>>>>>        If (bFound = True) Begin
91251>>>>>>>            Delete CODEMAST
91252>>>>>>>        End
91252>>>>>>>>
91252>>>>>>>
91252>>>>>>>        Close CodeMast
91253>>>>>>>
91253>>>>>>>        Function_Return (Err = False)
91254>>>>>>>    End_Function
91255>>>>>>>
91255>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91257>>>>>>>        Boolean bRecnum bToAnsi
91257>>>>>>>        Integer iCh
91257>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91257>>>>>>>
91257>>>>>>>        If (Trim(sDataPath) = "") Begin
91259>>>>>>>            Function_Return False
91260>>>>>>>        End
91260>>>>>>>>
91260>>>>>>>
91260>>>>>>>        Move False to Err
91261>>>>>>>        Get psDriverID     to sDriverID
91262>>>>>>>        Get psConnectionID to sConnectionID
91263>>>>>>>        Get psSchema       to sSchemaName
91264>>>>>>>        Get True           to bRecnum
91265>>>>>>>        Get pbToANSI       to bToAnsi
91266>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91267>>>>>>>        If (bToAnsi = False) Begin
91269>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91270>>>>>>>        End
91270>>>>>>>>
91270>>>>>>>
91270>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91271>>>>>>>        Move "CodeMast.int"         to sFileName
91272>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91273>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91276>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91279>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91282>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91285>>>>>>>            Writeln channel iCh ("")
91288>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91291>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91294>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91297>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91300>>>>>>>            Writeln channel iCh ("")
91303>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91306>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91309>>>>>>>            Writeln channel iCh ("")
91312>>>>>>>        Send Seq_Close_Channel iCh
91313>>>>>>>
91313>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91314>>>>>>>        Move "CodeType.int"         to sFileName
91315>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91316>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91319>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91322>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91325>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91328>>>>>>>            Writeln channel iCh ("")
91331>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91334>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91337>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91340>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91343>>>>>>>            Writeln channel iCh ("")
91346>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91349>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91352>>>>>>>            Writeln channel iCh ("")
91355>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91358>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91361>>>>>>>            Writeln channel iCh ("")
91364>>>>>>>        Send Seq_Close_Channel iCh
91365>>>>>>>
91365>>>>>>>        Function_Return (Err = False)
91366>>>>>>>    End_Function
91367>>>>>>>
91367>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91367>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91369>>>>>>>        Function_Return False
91370>>>>>>>    End_Function
91371>>>>>>>
91371>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91371>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91371>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91373>>>>>>>        Boolean bOK bExists
91373>>>>>>>        String sDataPath sBackupFolder
91373>>>>>>>
91373>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91374>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91375>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91376>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91377>>>>>>>
91377>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91378>>>>>>>        If (bExists = False) Begin
91380>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91381>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91382>>>>>>>            If (bExists = False) Begin
91384>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91385>>>>>>>>
91385>>>>>>>                Function_Return False
91386>>>>>>>            End
91386>>>>>>>>
91386>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91387>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91388>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91389>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91390>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91391>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91392>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91393>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91394>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91395>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91396>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91397>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91398>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91399>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91400>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91401>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91402>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91403>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91404>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91405>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91406>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91407>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91408>>>>>>>        End
91408>>>>>>>>
91408>>>>>>>
91408>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91409>>>>>>>        Function_Return True
91410>>>>>>>    End_Function
91411>>>>>>>    
91411>>>>>>>    // Check if the file exists in the Data folder,
91411>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91411>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91413>>>>>>>        String sPath
91413>>>>>>>        Boolean bExists
91413>>>>>>>
91413>>>>>>>        Get psDataPathFirstPart to sPath
91414>>>>>>>        Move (sPath + sFileName) to sFileName
91415>>>>>>>        Get vFilePathExists sFileName to bExists
91416>>>>>>>
91416>>>>>>>        If (bExists = False) Begin
91418>>>>>>>            // Read from memory & create file on disk.
91418>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91419>>>>>>>            Get vFilePathExists sFileName to bExists
91420>>>>>>>        End
91420>>>>>>>>
91420>>>>>>>        Function_Return bExists
91421>>>>>>>    End_Function
91422>>>>>>>
91422>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91424>>>>>>>        tColumnType RetvalType
91424>>>>>>>        tColumnType RetvalType
91424>>>>>>>        Integer iRetval
91424>>>>>>>
91424>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91425>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91426>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91428>>>>>>>            If (iLength <= 255) Begin
91430>>>>>>>                Move DF_ASCII to iRetval
91431>>>>>>>            End
91431>>>>>>>>
91431>>>>>>>        End
91431>>>>>>>>
91431>>>>>>>        Function_Return iRetval
91432>>>>>>>    End_Function
91433>>>>>>>
91433>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91435>>>>>>>        String sRetval
91435>>>>>>>
91435>>>>>>>        Case Begin
91435>>>>>>>            Case (iDataType = DF_ASCII)
91437>>>>>>>                Move "DF_ASCII" to sRetval
91438>>>>>>>                Case Break
91439>>>>>>>            Case (iDataType = DF_BCD)
91442>>>>>>>                Move "DF_BCD" to sRetval
91443>>>>>>>                Case Break
91444>>>>>>>            Case (iDataType = DF_BINARY)
91447>>>>>>>                Move "DF_BINARY" to sRetval
91448>>>>>>>                Case Break
91449>>>>>>>            Case (iDataType = DF_DATE)
91452>>>>>>>                Move "DF_DATE" to sRetval
91453>>>>>>>                Case Break
91454>>>>>>>            Case (iDataType = DF_DATETIME)
91457>>>>>>>                Move "DF_DATETIME" to sRetval
91458>>>>>>>                Case Break
91459>>>>>>>            Case (iDataType = DF_TEXT)
91462>>>>>>>                Move "DF_TEXT" to sRetval
91463>>>>>>>                Case Break
91464>>>>>>>            Case Else
91464>>>>>>>                Move "" to sRetval
91465>>>>>>>        Case End
91465>>>>>>>
91465>>>>>>>        Function_Return sRetval
91466>>>>>>>    End_Function
91467>>>>>>>
91467>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91467>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91469>>>>>>>        String sRetval sServer
91469>>>>>>>        tColumnType RetvalType
91469>>>>>>>        tColumnType RetvalType
91469>>>>>>>        Integer iDriver iDataFlexType
91469>>>>>>>        Handle hDatabase
91469>>>>>>>
91469>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91470>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91471>>>>>>>        Get DriverIndex sDriverID to iDriver
91472>>>>>>>        Get psServer to sServer
91473>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91474>>>>>>>        If (hDatabase = 0) Begin
91476>>>>>>>            Function_Return ""
91477>>>>>>>        End
91477>>>>>>>>
91477>>>>>>>
91477>>>>>>>        Case Begin
91477>>>>>>>            Case (iDataFlexType = DF_ASCII)
91479>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91482>>>>>>>                Case Break
91483>>>>>>>            Case (iDataFlexType = DF_BCD)
91486>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91489>>>>>>>                Case Break
91490>>>>>>>            Case (iDataFlexType = DF_BINARY)
91493>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91496>>>>>>>                Case Break
91497>>>>>>>            Case (iDataFlexType = DF_DATE)
91500>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91503>>>>>>>                Case Break
91504>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91507>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91510>>>>>>>                Case Break
91511>>>>>>>            Case (iDataFlexType = DF_TEXT)
91514>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91517>>>>>>>                Case Break
91518>>>>>>>            Case Else
91518>>>>>>>                Move "" to sRetval
91519>>>>>>>        Case End
91519>>>>>>>
91519>>>>>>>        Function_Return sRetval
91520>>>>>>>    End_Function
91521>>>>>>>
91521>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91523>>>>>>>        String sDriverID sServer
91523>>>>>>>        tColumnType RetvalType
91523>>>>>>>        tColumnType RetvalType
91523>>>>>>>        Integer iDbType iDriver
91523>>>>>>>        Handle hDatabase
91523>>>>>>>
91523>>>>>>>        Get psDriverID to sDriverID
91524>>>>>>>        Get piDbType   to iDbType
91525>>>>>>>        Get DriverIndex sDriverID to iDriver
91526>>>>>>>        Get psServer to sServer
91527>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91528>>>>>>>        If (hDatabase = 0) Begin
91530>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91531>>>>>>>>
91531>>>>>>>            Procedure_Return
91532>>>>>>>        End
91532>>>>>>>>
91532>>>>>>>
91532>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91535>>>>>>>
91535>>>>>>>    End_Procedure
91536>>>>>>>
91536>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91538>>>>>>>        String sDriverID sServer
91538>>>>>>>        tColumnType RetvalType
91538>>>>>>>        tColumnType RetvalType
91538>>>>>>>        Integer iDbType iDriver
91538>>>>>>>        Handle hDatabase
91538>>>>>>>
91538>>>>>>>        Get psDriverID to sDriverID
91539>>>>>>>        Get piDbType   to iDbType
91540>>>>>>>        Get DriverIndex sDriverID to iDriver
91541>>>>>>>        Get psServer to sServer
91542>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91543>>>>>>>        If (hDatabase = 0) Begin
91545>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91546>>>>>>>>
91546>>>>>>>            Procedure_Return
91547>>>>>>>        End
91547>>>>>>>>
91547>>>>>>>
91547>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91550>>>>>>>
91550>>>>>>>    End_Procedure
91551>>>>>>>
91551>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91551>>>>>>>    // are mapped to the standard DataFlex data types.
91551>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91551>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91553>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91553>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91555>>>>>>>        String sDataType
91555>>>>>>>        Integer iDataType iDriverID iCount
91555>>>>>>>        Boolean bSQLDriver
91555>>>>>>>
91555>>>>>>>        Move 0 to iCount
91556>>>>>>>        Get DriverIndex sDriverID to iDriverID
91557>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91558>>>>>>>        If (bSQLDriver = False) Begin
91560>>>>>>>            Function_Return EmptyArray
91561>>>>>>>        End
91561>>>>>>>>
91561>>>>>>>
91561>>>>>>>        // DF_ASCII
91561>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91563>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91566>>>>>>>        End
91566>>>>>>>>
91566>>>>>>>        Else Begin
91567>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91570>>>>>>>        End
91570>>>>>>>>
91570>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91571>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91572>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91573>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91574>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91575>>>>>>>        Increment iCount
91576>>>>>>>
91576>>>>>>>        // DF_BINARY
91576>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91578>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91581>>>>>>>        End
91581>>>>>>>>
91581>>>>>>>        Else Begin
91582>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91585>>>>>>>        End
91585>>>>>>>>
91585>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91586>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91587>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91588>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91589>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91590>>>>>>>        Increment iCount
91591>>>>>>>
91591>>>>>>>        // DF_DATE
91591>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91593>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91596>>>>>>>        End
91596>>>>>>>>
91596>>>>>>>        Else Begin
91597>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91600>>>>>>>        End
91600>>>>>>>>
91600>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91601>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91602>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91603>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91604>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91605>>>>>>>        Increment iCount
91606>>>>>>>
91606>>>>>>>        // DF_DATETIME
91606>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91608>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91611>>>>>>>        End
91611>>>>>>>>
91611>>>>>>>        Else Begin
91612>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91615>>>>>>>        End
91615>>>>>>>>
91615>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91616>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91617>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91618>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91619>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91620>>>>>>>        Increment iCount
91621>>>>>>>
91621>>>>>>>        // DF_NUMERIC
91621>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91621>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91621>>>>>>>        // we make them here all "Numeric"...
91621>>>>>>>        Case Begin
91621>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91623>>>>>>>                Move SQL_NUMERIC to iDataType
91624>>>>>>>                Move "numeric"   to sDataType
91625>>>>>>>                Case Break
91626>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91629>>>>>>>                Move SQL_NUMERIC to iDataType
91630>>>>>>>                Move "NUMERIC"   to sDataType
91631>>>>>>>                Case Break
91632>>>>>>>            Case Else
91632>>>>>>>                Move DF_BCD      to iDataType
91633>>>>>>>                Move "Numeric"   to sDataType
91634>>>>>>>        Case End
91634>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91635>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91636>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91637>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91638>>>>>>>        Increment iCount
91639>>>>>>>
91639>>>>>>>        // DF_TEXT
91639>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91641>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91644>>>>>>>        End
91644>>>>>>>>
91644>>>>>>>        Else Begin
91645>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91648>>>>>>>        End
91648>>>>>>>>
91648>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91649>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91650>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91651>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91652>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91653>>>>>>>
91653>>>>>>>        Function_Return ColumnTypeArray
91654>>>>>>>    End_Function
91655>>>>>>>
91655>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91657>>>>>>>        tColumnType[] ColumnTypeArray
91657>>>>>>>        tColumnType[] ColumnTypeArray
91658>>>>>>>        tColumnType   ColumnType
91658>>>>>>>        tColumnType   ColumnType
91658>>>>>>>        Integer iCount iSize
91658>>>>>>>
91658>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91659>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91660>>>>>>>        Decrement iSize
91661>>>>>>>
91661>>>>>>>        for iCount from 0 to iSize
91667>>>>>>>>
91667>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91669>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91670>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91671>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91672>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91673>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91674>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91675>>>>>>>                Move iSize to iCount
91676>>>>>>>            End
91676>>>>>>>>
91676>>>>>>>        Loop
91677>>>>>>>>
91677>>>>>>>
91677>>>>>>>        Function_Return ColumnType
91678>>>>>>>    End_Function
91679>>>>>>>
91679>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91679>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91679>>>>>>>    // but the Logical name is different.
91679>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91679>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91681>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91681>>>>>>>        Handle hInTable hMasterTable 
91681>>>>>>>        Boolean bIsAlias
91681>>>>>>>        
91681>>>>>>>        Move hTable to hInTable
91682>>>>>>>        Move False to bIsAlias
91683>>>>>>>        Move 0 to hMasterTable
91684>>>>>>>        
91684>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91687>>>>>>>        // Remove any prefix with a driver name.
91687>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91688>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91691>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91692>>>>>>>        
91692>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91692>>>>>>>        // so we can safely return a "False".
91692>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91694>>>>>>>            Function_Return False
91695>>>>>>>        End
91695>>>>>>>>
91695>>>>>>>        
91695>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91695>>>>>>>        // as the passed hTable root name.
91695>>>>>>>        // A master table always has the same root and logical name.
91695>>>>>>>        Move 0 to hTable
91696>>>>>>>        Repeat
91696>>>>>>>>
91696>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91699>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
91701>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91704>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91705>>>>>>>                // If we found another table with the same root and logical name
91705>>>>>>>                // we have found a master table.
91705>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91707>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91710>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91711>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91713>>>>>>>                        Move hTable to hMasterTable   
91714>>>>>>>                        Move 0 to hTable // To end the loop.
91715>>>>>>>                    End
91715>>>>>>>>
91715>>>>>>>                End
91715>>>>>>>>
91715>>>>>>>            End
91715>>>>>>>>
91715>>>>>>>        Until (hTable = 0)
91717>>>>>>>        
91717>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91719>>>>>>>            Move True to bIsAlias
91720>>>>>>>        End
91720>>>>>>>>
91720>>>>>>>        
91720>>>>>>>        Function_Return bIsAlias
91721>>>>>>>    End_Function
91722>>>>>>>
91722>>>>>>>    // To Open a table with any driver.
91722>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91722>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91722>>>>>>>    //
91722>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91722>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
91722>>>>>>>    // returns a True if successful (table could be opened).
91722>>>>>>>    //
91722>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91722>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91722>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91722>>>>>>>    // set properly we can open the table.
91722>>>>>>>    //
91722>>>>>>>    // DAW Driver Syntax:
91722>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91722>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91722>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91722>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91722>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91722>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91722>>>>>>>    //
91722>>>>>>>    // DAW Driver Sample:
91722>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91722>>>>>>>    //
91722>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91724>>>>>>>        String sTableNameOrg
91724>>>>>>>        Boolean bOpen bOK
91724>>>>>>>        tSQLConnection SQLConnection
91724>>>>>>>        tSQLConnection SQLConnection
91724>>>>>>>        
91724>>>>>>>        Move False to bOpen
91725>>>>>>>        Move sTableName to sTableNameOrg
91726>>>>>>>        If (hTable > 0) Begin
91728>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
91729>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91730>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91731>>>>>>>            Send Ignore_Error of Error_Object_Id 10
91732>>>>>>>            Open hTable Mode iMode
91734>>>>>>>            Send Trap_Error of Error_Object_Id 20529
91735>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91736>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91737>>>>>>>            Send Trap_Error of Error_Object_Id 10
91738>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91741>>>>>>>            If (bOpen = True) Begin
91743>>>>>>>                Function_Return True
91744>>>>>>>            End
91744>>>>>>>>
91744>>>>>>>        End
91744>>>>>>>>
91744>>>>>>>
91744>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91745>>>>>>>        If (hTable > 0) Begin
91747>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91750>>>>>>>        End
91750>>>>>>>>
91750>>>>>>>
91750>>>>>>>        Function_Return bOpen
91751>>>>>>>    End_Function
91752>>>>>>>
91752>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91754>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91754>>>>>>>        Boolean bOpen bOK
91754>>>>>>>        tSQLConnection SQLConnection
91754>>>>>>>        tSQLConnection SQLConnection
91754>>>>>>>
91754>>>>>>>        If (hTable < 1) Begin
91756>>>>>>>            Function_Return False
91757>>>>>>>        End
91757>>>>>>>>
91757>>>>>>>
91757>>>>>>>        Move sTableName to sTableNameOrg
91758>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91759>>>>>>>        Move SQLConnection.sDriverID to sDriverID
91760>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91761>>>>>>>        Move SQLConnection.sSchema to sSchema
91762>>>>>>>        If (sSchema = "") Begin
91764>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91765>>>>>>>        End
91765>>>>>>>>
91765>>>>>>>
91765>>>>>>>        // We need to remove the ".int" part of the table name because
91765>>>>>>>        // the table name after the "#" in the connection syntax below wants the
91765>>>>>>>        // "bare" table name without any extension.
91765>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91767>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
91769>>>>>>>                Get ParseFileExtension sTableName to sExt
91770>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91771>>>>>>>            End
91771>>>>>>>>
91771>>>>>>>            Else Begin
91772>>>>>>>                Move sTableName to sTableNameShort
91773>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
91774>>>>>>>            End
91774>>>>>>>>
91774>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91775>>>>>>>            Move sConnection to sTableName
91776>>>>>>>        End
91776>>>>>>>>
91776>>>>>>>
91776>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91777>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91778>>>>>>>        If (hTable = 0) Begin
91780>>>>>>>            Get NextFreeFilelistSlot to hTable
91781>>>>>>>        End
91781>>>>>>>>
91781>>>>>>>
91781>>>>>>>        Case Begin
91781>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91783>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91783>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91785>>>>>>>                    Close hTable
91786>>>>>>>                    Open sTableName as hTable
91788>>>>>>>                End
91788>>>>>>>>
91788>>>>>>>                Else Begin
91789>>>>>>>                    Get OpenTableExclusive hTable to bOK
91790>>>>>>>                    If (bOK = False) Begin
91792>>>>>>>                        Function_Return False
91793>>>>>>>                    End
91793>>>>>>>>
91793>>>>>>>                End
91793>>>>>>>>
91793>>>>>>>                Case Break
91794>>>>>>>
91794>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91797>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91797>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91799>>>>>>>                    Close hTable
91800>>>>>>>                    Open sTableName as hTable
91802>>>>>>>                End
91802>>>>>>>>
91802>>>>>>>                Else Begin
91803>>>>>>>                    Get OpenTableExclusive hTable to bOK
91804>>>>>>>                    If (bOK = False) Begin
91806>>>>>>>                        Function_Return False
91807>>>>>>>                    End
91807>>>>>>>>
91807>>>>>>>                End
91807>>>>>>>>
91807>>>>>>>                Case Break
91808>>>>>>>
91808>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91811>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91811>>>>>>>                If (iMode = DF_SHARE) Begin
91813>>>>>>>                    Close hTable
91814>>>>>>>                    Open sTableName as hTable
91816>>>>>>>                End
91816>>>>>>>>
91816>>>>>>>                Else Begin
91817>>>>>>>                    Get OpenTableExclusive hTable to bOK
91818>>>>>>>                    If (bOK = False) Begin
91820>>>>>>>                        Function_Return False
91821>>>>>>>                    End
91821>>>>>>>>
91821>>>>>>>                End
91821>>>>>>>>
91821>>>>>>>                Case Break
91822>>>>>>>
91822>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91825>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91827>>>>>>>                    Close hTable
91828>>>>>>>                    Open sTableName as hTable
91830>>>>>>>                End
91830>>>>>>>>
91830>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91833>>>>>>>                    Get OpenTableExclusive hTable to bOK
91834>>>>>>>                    If (bOK = False) Begin
91836>>>>>>>                        Function_Return False
91837>>>>>>>                    End
91837>>>>>>>>
91837>>>>>>>                End
91837>>>>>>>>
91837>>>>>>>                Else Begin
91838>>>>>>>                    Open hTable
91840>>>>>>>                End
91840>>>>>>>>
91840>>>>>>>                Case Break
91841>>>>>>>
91841>>>>>>>            Case Else
91841>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91842>>>>>>>>
91842>>>>>>>        Case End
91842>>>>>>>
91842>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91843>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91844>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91846>>>>>>>            Move False to Found
91847>>>>>>>        End
91847>>>>>>>>
91847>>>>>>>        // If open failed, the Err is set to true,
91847>>>>>>>        // but we don't want that because it could end our loop.
91847>>>>>>>        Move False to Err
91848>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91851>>>>>>>
91851>>>>>>>        Function_Return bOpen
91852>>>>>>>    End_Function
91853>>>>>>>
91853>>>>>>>    // Pass a table's logical name
91853>>>>>>>    // Returns True if the table exists in filelist.cfg.
91853>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91855>>>>>>>        Handle hTable
91855>>>>>>>        Boolean bFound
91855>>>>>>>        String sCompareTable
91855>>>>>>>
91855>>>>>>>        Move False to bFound
91856>>>>>>>        Move 0 to hTable
91857>>>>>>>        Repeat
91857>>>>>>>>
91857>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91860>>>>>>>            If (hTable > 0) Begin
91862>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91865>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91867>>>>>>>                    Move True to bFound
91868>>>>>>>                End
91868>>>>>>>>
91868>>>>>>>            End
91868>>>>>>>>
91868>>>>>>>            If (bFound = True) ;                Break
91871>>>>>>>        Until (hTable = 0)
91873>>>>>>>
91873>>>>>>>        Function_Return (bFound = True)
91874>>>>>>>    End_Function
91875>>>>>>>
91875>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91875>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91877>>>>>>>        Boolean bOK bExists
91877>>>>>>>        String sDriverID
91877>>>>>>>
91877>>>>>>>        Get _UtilTableExists hTable to bExists
91878>>>>>>>        If (bExists = False) Begin
91880>>>>>>>            Function_Return DATAFLEX_ID
91881>>>>>>>        End
91881>>>>>>>>
91881>>>>>>>        Get OpenTableExclusive hTable to bOK
91882>>>>>>>        If (bOK = False) Begin
91884>>>>>>>            Function_Return DATAFLEX_ID
91885>>>>>>>        End
91885>>>>>>>>
91885>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91888>>>>>>>        Function_Return sDriverID
91889>>>>>>>    End_Function
91890>>>>>>>
91890>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
91890>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
91892>>>>>>>        Handle hTable
91892>>>>>>>        Integer iRetval
91892>>>>>>>
91892>>>>>>>        Move 0 to hTable
91893>>>>>>>        Move 0 to iRetval
91894>>>>>>>
91894>>>>>>>        Repeat
91894>>>>>>>>
91894>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91897>>>>>>>            If (hTable > 0) Begin
91899>>>>>>>                Increment iRetval
91900>>>>>>>            End
91900>>>>>>>>
91900>>>>>>>        Until (hTable = 0)
91902>>>>>>>
91902>>>>>>>        Function_Return iRetval
91903>>>>>>>    End_Function
91904>>>>>>>
91904>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91904>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91906>>>>>>>        Handle hTable
91906>>>>>>>        String sRoot sDriverID
91906>>>>>>>        Boolean bIsSQLTable
91906>>>>>>>        Integer iPos
91906>>>>>>>
91906>>>>>>>        Move 0 to hTable
91907>>>>>>>        Move "" to sDriverID
91908>>>>>>>        Move False to bIsSQLTable
91909>>>>>>>
91909>>>>>>>        Repeat
91909>>>>>>>>
91909>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91912>>>>>>>            If (hTable > 0) Begin
91914>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91917>>>>>>>                If (sRoot contains ":") Begin
91919>>>>>>>                    Move (Pos(":", sRoot)) to iPos
91920>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91921>>>>>>>                End
91921>>>>>>>>
91921>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91922>>>>>>>            End
91922>>>>>>>>
91922>>>>>>>
91922>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
91924>>>>>>>
91924>>>>>>>        Function_Return sDriverID
91925>>>>>>>    End_Function
91926>>>>>>>
91926>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91928>>>>>>>        String sRootName
91928>>>>>>>        Boolean bIsSQL
91928>>>>>>>        Handle hTable
91928>>>>>>>
91928>>>>>>>        Move False to bIsSQL
91929>>>>>>>        Move 0 to hTable
91930>>>>>>>        Repeat
91930>>>>>>>>
91930>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91933>>>>>>>            If (hTable > 0) Begin
91935>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91938>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
91939>>>>>>>                If (bIsSQL = True) Begin
91941>>>>>>>                    Move 0 to hTable
91942>>>>>>>                End
91942>>>>>>>>
91942>>>>>>>            End
91942>>>>>>>>
91942>>>>>>>        Until (hTable = 0)
91944>>>>>>>
91944>>>>>>>        Function_Return (bIsSQL = False)
91945>>>>>>>    End_Function
91946>>>>>>>
91946>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91946>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
91948>>>>>>>        Function_Return False
91949>>>>>>>    End_Function
91950>>>>>>>
91950>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91952>>>>>>>        String  sRetval
91952>>>>>>>        String[] sOverlapFieldsArray
91953>>>>>>>        Integer iType iColumn iColumns
91953>>>>>>>        Boolean bOpen bOverlap
91953>>>>>>>
91953>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91956>>>>>>>        If (bOpen = False) Begin
91958>>>>>>>            Open hTable
91960>>>>>>>        End
91960>>>>>>>>
91960>>>>>>>
91960>>>>>>>        Move "" to sRetval
91961>>>>>>>
91961>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91964>>>>>>>
91964>>>>>>>        for iColumn from 0 to iColumns
91970>>>>>>>>
91970>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91973>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91975>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91978>>>>>>>                If (bOverlap) Begin
91980>>>>>>>                    If (sRetval <> "") Begin
91982>>>>>>>                        Append sRetval ","
91983>>>>>>>                    End
91983>>>>>>>>
91983>>>>>>>                    Append sRetval iColumn
91984>>>>>>>                End
91984>>>>>>>>
91984>>>>>>>            End
91984>>>>>>>>
91984>>>>>>>        Loop
91985>>>>>>>>
91985>>>>>>>
91985>>>>>>>        If (bOpen = False) Begin
91987>>>>>>>            Close hTable
91988>>>>>>>        End
91988>>>>>>>>
91988>>>>>>>
91988>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91989>>>>>>>
91989>>>>>>>        Function_Return sOverlapFieldsArray
91990>>>>>>>    End_Function
91991>>>>>>>
91991>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
91993>>>>>>>        Handle hoRegistry hoODBCDriverNames
91993>>>>>>>        Boolean bExists bKeyOpened
91993>>>>>>>        String sKey
91993>>>>>>>        String[] sDrivers
91994>>>>>>>        Integer iDriverNames iDriverName
91994>>>>>>>
91994>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91995>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91996>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
91997>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91998>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
91999>>>>>>>        If (bExists) Begin
92001>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92002>>>>>>>            If (bKeyOpened) Begin
92004>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92005>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92006>>>>>>>                If (iDriverNames > 0) Begin
92008>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92009>>>>>>>                    Decrement iDriverNames
92010>>>>>>>                    for iDriverName from 0 to iDriverNames
92016>>>>>>>>
92016>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92017>>>>>>>                    Loop
92018>>>>>>>>
92018>>>>>>>                End
92018>>>>>>>>
92018>>>>>>>                Send CloseKey of hoRegistry
92019>>>>>>>            End
92019>>>>>>>>
92019>>>>>>>        End
92019>>>>>>>>
92019>>>>>>>        Send Destroy of hoRegistry
92020>>>>>>>
92020>>>>>>>        Function_Return sDrivers
92021>>>>>>>    End_Function
92022>>>>>>>
92022>>>>>>>    Procedure IncreaseSortBufferSize
92024>>>>>>>        String sNull
92024>>>>>>>        Integer iSortBufferSize
92024>>>>>>>        Boolean bBufferSet
92024>>>>>>>
92024>>>>>>>        Move "" to sNull
92025>>>>>>>        Move (1024 * 128) to iSortBufferSize
92026>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92031>>>>>>>
92031>>>>>>>    End_Procedure
92032>>>>>>>
92032>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92034>>>>>>>        Integer iLastIndex iIndex iNumSegments
92034>>>>>>>        Boolean bOK
92034>>>>>>>        String sDriverID
92034>>>>>>>
92034>>>>>>>        If (hTable > 0) Begin
92036>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92037>>>>>>>            Close hTable
92038>>>>>>>            Get OpenTableExclusive hTable to bOK
92039>>>>>>>            If (bOK = False) Begin
92041>>>>>>>                Procedure_Return
92042>>>>>>>            End
92042>>>>>>>>
92042>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92045>>>>>>>            Structure_Start hTable sDriverID
92046>>>>>>>                for iIndex from 1 to iLastIndex
92052>>>>>>>>
92052>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92055>>>>>>>                    If (iNumSegments > 0) Begin
92057>>>>>>>                        If (bSetToBatch = True) Begin
92059>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92062>>>>>>>                        End
92062>>>>>>>>
92062>>>>>>>                        Else Begin
92063>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92066>>>>>>>                        End
92066>>>>>>>>
92066>>>>>>>                    End
92066>>>>>>>>
92066>>>>>>>                Loop
92067>>>>>>>>
92067>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92069>>>>>>>        End
92069>>>>>>>>
92069>>>>>>>    End_Procedure
92070>>>>>>>
92070>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92072>>>>>>>        Handle hTable
92072>>>>>>>
92072>>>>>>>        Move 0 to hTable
92073>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92076>>>>>>>
92076>>>>>>>        Function_Return hTable
92077>>>>>>>    End_Function
92078>>>>>>>
92078>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92078>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92080>>>>>>>        Integer iCh
92080>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92081>>>>>>>            Write channel iCh sStmt
92083>>>>>>>        Send Seq_Close_Channel iCh
92084>>>>>>>    End_Procedure
92085>>>>>>>
92085>>>>>>>    // Returns the integer number for the passed Driver ID that is
92085>>>>>>>    // needed by some database API calls.
92085>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92087>>>>>>>        String  sCurrentDriver
92087>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92087>>>>>>>
92087>>>>>>>        Move 0 to iDriver
92088>>>>>>>
92088>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92091>>>>>>>        for iCount from 1 to iNumberOfDrivers
92097>>>>>>>>
92097>>>>>>>
92097>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92100>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92102>>>>>>>                Move iCount to iDriver
92103>>>>>>>            End
92103>>>>>>>>
92103>>>>>>>        Loop
92104>>>>>>>>
92104>>>>>>>
92104>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92104>>>>>>>        If (iDriver = 0) Begin
92106>>>>>>>            Move False to Err
92107>>>>>>>            Load_Driver sDriverID
92108>>>>>>>            If (Err = False) Begin
92110>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92113>>>>>>>            End
92113>>>>>>>>
92113>>>>>>>        End
92113>>>>>>>>
92113>>>>>>>
92113>>>>>>>        Function_Return iDriver
92114>>>>>>>    End_Function
92115>>>>>>>
92115>>>>>>>
92115>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92117>>>>>>>        String  sSqlServerClientVersionName
92117>>>>>>>        
92117>>>>>>>        Case Begin
92117>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92119>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92120>>>>>>>                Case Break
92121>>>>>>>
92121>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92124>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92125>>>>>>>                Case Break
92126>>>>>>>                
92126>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92129>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92130>>>>>>>                Case Break
92131>>>>>>>            
92131>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92134>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92135>>>>>>>                Case Break
92136>>>>>>>            
92136>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92139>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92140>>>>>>>                Case Break
92141>>>>>>>            
92141>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92144>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92145>>>>>>>                Case Break
92146>>>>>>>            
92146>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92149>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92150>>>>>>>                Case Break
92151>>>>>>>            
92151>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92154>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92155>>>>>>>                Case Break
92156>>>>>>>            
92156>>>>>>>            Case Else
92156>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92157>>>>>>>        Case End
92157>>>>>>>        
92157>>>>>>>        Function_Return sSqlServerClientVersionName
92158>>>>>>>    End_Function
92159>>>>>>>
92159>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92161>>>>>>>        String  sSqlServerClientDriverName
92161>>>>>>>        
92161>>>>>>>        Case Begin
92161>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92163>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92164>>>>>>>                Case Break
92165>>>>>>>
92165>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92168>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92169>>>>>>>                Case Break
92170>>>>>>>                
92170>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92173>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92174>>>>>>>                Case Break
92175>>>>>>>            
92175>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92178>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92179>>>>>>>                Case Break
92180>>>>>>>            
92180>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92183>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92184>>>>>>>                Case Break
92185>>>>>>>            
92185>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92188>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92189>>>>>>>                Case Break
92190>>>>>>>            
92190>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92193>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92194>>>>>>>                Case Break
92195>>>>>>>            
92195>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92198>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92199>>>>>>>                Case Break
92200>>>>>>>            
92200>>>>>>>            Case Else
92200>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92201>>>>>>>        Case End
92201>>>>>>>        
92201>>>>>>>        Function_Return sSqlServerClientDriverName
92202>>>>>>>    End_Function
92203>>>>>>>    
92203>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92205>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92205>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92205>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92205>>>>>>>        Boolean bOK
92205>>>>>>>        
92205>>>>>>>        Move "" to sRetval
92206>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92207>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92208>>>>>>>        Load_Driver MSSQLDRV_ID
92209>>>>>>>
92209>>>>>>>        // Loop through all loaded drivers.
92209>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92212>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92218>>>>>>>>
92218>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92221>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92223>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92224>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92227>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92228>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92229>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92230>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92231>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92233>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92234>>>>>>>                End                                
92234>>>>>>>>
92234>>>>>>>                Else Begin
92235>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92236>>>>>>>                End
92236>>>>>>>>
92236>>>>>>>            End
92236>>>>>>>>
92236>>>>>>>        Loop
92237>>>>>>>>
92237>>>>>>>        Send Destroy of hoCLIHandler  
92238>>>>>>>        Send Destroy of hoMSSQLHandler  
92239>>>>>>>        If (bShowErrorDialog = True) Begin
92241>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92242>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92244>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92245>>>>>>>                If (bExitProgram = True) Begin
92247>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92248>>>>>>>                End
92248>>>>>>>>
92248>>>>>>>                Send Stop_Box sRetval  
92249>>>>>>>                If (bExitProgram = True) Begin
92251>>>>>>>                    Send Exit_Application
92252>>>>>>>                End
92252>>>>>>>>
92252>>>>>>>            End
92252>>>>>>>>
92252>>>>>>>        End
92252>>>>>>>>
92252>>>>>>>        
92252>>>>>>>        Function_Return sRetval
92253>>>>>>>    End_Function  
92254>>>>>>>    
92254>>>>>>>    // Returns True if first "." separated string is greater than the second.
92254>>>>>>>    // It checks from left to right, one part of the string at a time.
92254>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92254>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92256>>>>>>>        String[] asVersion asSQLVersion          
92258>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92258>>>>>>>        
92258>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92259>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92260>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92261>>>>>>>        // Make sure the two arrays are of the same size:
92261>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92263>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92264>>>>>>>        End
92264>>>>>>>>
92264>>>>>>>        Decrement iSize
92265>>>>>>>        for iCount from 0 to iSize
92271>>>>>>>>
92271>>>>>>>            Move asVersion[iCount]    to iVersion
92272>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92273>>>>>>>            CompilerWarnings Off
92273>>>>>>>            If (iVersion > iSQLVersion) Break
92276>>>>>>>            CompilerWarnings On
92276>>>>>>>        Loop
92277>>>>>>>>
92277>>>>>>>        
92277>>>>>>>        Function_Return (iVersion > iSQLVersion)
92278>>>>>>>    End_Function
92279>>>>>>>
92279>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92279>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92279>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92279>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92281>>>>>>>        Integer iMode iErrorObject
92281>>>>>>>        Boolean bOpened
92281>>>>>>>        String sTableName 
92281>>>>>>>        Handle hoCurrentErrorHandler
92281>>>>>>>
92281>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92282>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92282>>>>>>>        // so we generate an error here:
92282>>>>>>>        If (IsDebuggerPresent()) Begin
92284>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92285>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92286>>>>>>>            If (iErrorObject <> 0) Begin
92288>>>>>>>                Move iErrorObject to Error_Object_Id
92289>>>>>>>            End
92289>>>>>>>>
92289>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92290>>>>>>>>
92290>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92291>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92292>>>>>>>            Function_Return False
92293>>>>>>>        End
92293>>>>>>>>
92293>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92296>>>>>>>        If (bOpened) Begin
92298>>>>>>>//            If (IsDebuggerPresent()) Begin
92298>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92298>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92298>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
92298>>>>>>>//                    Function_Return True
92298>>>>>>>//                End
92298>>>>>>>//            End
92298>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92301>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92303>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92304>>>>>>>                Function_Return True
92305>>>>>>>            End
92305>>>>>>>>
92305>>>>>>>            Close hTable
92306>>>>>>>        End
92306>>>>>>>>
92306>>>>>>>        Else Begin
92307>>>>>>>            Open hTable
92309>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92312>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92314>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92317>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92319>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92320>>>>>>>                    Function_Return True
92321>>>>>>>                End
92321>>>>>>>>
92321>>>>>>>            End
92321>>>>>>>>
92321>>>>>>>
92321>>>>>>>        End
92321>>>>>>>>
92321>>>>>>>
92321>>>>>>>        Close hTable
92322>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92324>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92327>>>>>>>
92327>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92328>>>>>>>        Function_Return bOpened
92329>>>>>>>    End_Function
92330>>>>>>>
92330>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92332>>>>>>>        String sConnectionID sConnectionString sDriverID
92332>>>>>>>        Boolean bExists bOK bSQLDriver
92332>>>>>>>        Handle hoCLI hoDriver
92332>>>>>>>        Integer iRetval
92332>>>>>>>        tSQLConnection SQLConnection
92332>>>>>>>        tSQLConnection SQLConnection
92332>>>>>>>
92332>>>>>>>        Get psDriverID to sDriverID
92333>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92334>>>>>>>        If (bSQLDriver = False) Begin
92336>>>>>>>            Function_Return True
92337>>>>>>>        End
92337>>>>>>>>
92337>>>>>>>
92337>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92338>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92339>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92340>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92341>>>>>>>
92341>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92342>>>>>>>        If (bExists = False) Begin
92344>>>>>>>            // We always start by deleting the current connection - if any - because the
92344>>>>>>>            // login details my have changed.
92344>>>>>>>            Get phoCLIHandler to hoCLI
92345>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92346>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92347>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92348>>>>>>>            If (bOk = False) Begin
92350>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92351>>>>>>>>
92351>>>>>>>                Function_Return False
92352>>>>>>>            End
92352>>>>>>>>
92352>>>>>>>            Move bOK to bExists
92353>>>>>>>        End
92353>>>>>>>>
92353>>>>>>>
92353>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92354>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92355>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92356>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92357>>>>>>>        Send Destroy of hoDriver
92358>>>>>>>
92358>>>>>>>        Function_Return (bExists = True)
92359>>>>>>>    End_Function
92360>>>>>>>
92360>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92360>>>>>>>    // Returns: False if nobody else is running
92360>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92360>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92360>>>>>>>    //      tables are not locked as DataFlex tables are.
92360>>>>>>>    Function IsDatabaseInUse Returns Boolean
92362>>>>>>>        Handle  hTable
92362>>>>>>>        String  sRootName
92362>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92362>>>>>>>        Integer iCount iTables
92362>>>>>>>
92362>>>>>>>        Move 0 to iTables
92363>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92364>>>>>>>        Get AutoConnectionIDLogin to bOK
92365>>>>>>>        Get UtilFilelistNoOfTables to iTables
92366>>>>>>>        Set piPosition   of ghoProgressBar to 0
92367>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92368>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92369>>>>>>>        Close DF_ALL
92370>>>>>>>        Move 0 to hTable
92371>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92374>>>>>>>        Move False to bErr
92375>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92376>>>>>>>
92376>>>>>>>        Repeat
92376>>>>>>>>
92376>>>>>>>            Set piPosition of ghoProgressBar to iCount
92377>>>>>>>            Increment iCount
92378>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92381>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92382>>>>>>>
92382>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92382>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92383>>>>>>>            Move False to bOpen
92384>>>>>>>            Get _UtilTableExists hTable to bExists
92385>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92385>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92387>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92388>>>>>>>                Open hTable
92390>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92393>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92394>>>>>>>                If (bOpen = True) Begin
92396>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92396>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92397>>>>>>>                    If (bAlias = False) Begin
92399>>>>>>>                        Close hTable
92400>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92401>>>>>>>                        If (bOpen = False) Begin
92403>>>>>>>                            Move True to bErr
92404>>>>>>>                        End
92404>>>>>>>>
92404>>>>>>>                    End
92404>>>>>>>>
92404>>>>>>>                End
92404>>>>>>>>
92404>>>>>>>                Close hTable
92405>>>>>>>            End
92405>>>>>>>>
92405>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92408>>>>>>>            If (bErr = True ) ;                Break
92411>>>>>>>        Until (not(hTable))
92413>>>>>>>
92413>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92414>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92415>>>>>>>        Move False to Err
92416>>>>>>>
92416>>>>>>>        Function_Return bErr
92417>>>>>>>    End_Function
92418>>>>>>>
92418>>>>>>>End_Class
92419>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92419>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92419>>>>>>>//
92419>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92419>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92419>>>>>>>// conjunction with constraint-clauses.
92419>>>>>>>//
92419>>>>>>>// SYNTAX:
92419>>>>>>>//
92419>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92419>>>>>>>//    <Constraints...>
92419>>>>>>>//    {DO}
92419>>>>>>>//      <loop body>
92419>>>>>>>//  End_For_All
92419>>>>>>>//
92419>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92419>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92419>>>>>>>//
92419>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92419>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92419>>>>>>>//   End_For_All
92419>>>>>>>//
92419>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92419>>>>>>>//
92419>>>>>>>//   For_All Customer BY Index.1
92419>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92419>>>>>>>//     DO
92419>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92419>>>>>>>//   End_For_All
92419>>>>>>>//
92419>>>>>>>// Constraint clauses are:
92419>>>>>>>//
92419>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92419>>>>>>>//   CONSTRAIN <File> AS <Expression>
92419>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92419>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92419>>>>>>>//
92419>>>>>>>// For example, to list all customers with a bad status whose names start
92419>>>>>>>// with "A" and which have not made a payment in thirty days:
92419>>>>>>>//
92419>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92419>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92419>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92419>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92419>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92419>>>>>>>//      DO
92419>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92419>>>>>>>//    End_For_All
92419>>>>>>>//
92419>>>>>>>
92419>>>>>>>
92419>>>>>>>//This command starts the loop process body when constraints are used;
92419>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92419>>>>>>>//command line, and not on a line by itself
92419>>>>>>>//
92419>>>>>>>
92419>>>>>>>//Ends a For_All loop
92419>>>>>>>//
92419>>>>>>>
92419>>>>>>>
92419>>>>>
92419>>>>>
92419>>>>>Class cDbUpdateVersion is a cObject
92420>>>>>
92420>>>>>    Procedure Construct_Object    
92422>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92422>>>>>        String[] aSQLQueryMessages
92423>>>>>        
92423>>>>>        Forward Send Construct_Object
92425>>>>>
92425>>>>>        // cDbUpdateHandler object event.
92425>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92427>>>>>        If (bOnCreateExecuted = False) Begin    
92429>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92431>>>>>            If (bUseCustomDbVersion = False) Begin
92433>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92435>>>>>            End
92435>>>>>>
92435>>>>>            Delegate Send CheckIntFilesIntegrity
92437>>>>>            Delegate Send OnCreate
92439>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92441>>>>>        End
92441>>>>>>
92441>>>>>
92441>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92441>>>>>        // event was triggered, thus an actual change of the database was made.
92441>>>>>        Property Boolean pbVersionUpdate False
92442>>>>>
92442>>>>>        // This property must be manually set within each cDbUpdateVersion object
92442>>>>>        // by the programmer, to a consecutive number.
92442>>>>>        Property Number pnVersionNumber
92443>>>>>
92443>>>>>        Property Boolean pbUseConnectionID True
92444>>>>>        Property Boolean private.pbToANSI   True
92445>>>>>        Property Boolean private.pbRecnum   True
92446>>>>>        Property Boolean private.pbCopyData True
92447>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92448>>>>>        Property Boolean private.pbCompareDate_DateTime False
92449>>>>>        Property Boolean private.pbCompareIndexAscending False
92450>>>>>        Property Boolean private.pbCompareIndexUppercase False
92451>>>>>        Property String private.psSchema
92452>>>>>        Property String private.psBaseTableSpace
92453>>>>>        Property String private.psLongTableSpace
92454>>>>>        Property String private.psIndexTableSpace
92455>>>>>
92455>>>>>        // Driver default value settings:
92455>>>>>        Property String private.psDriverDefaultValueASCII    ""
92456>>>>>        Property String private.psDriverDefaultValueBinary   ""
92457>>>>>        Property String private.psDriverDefaultValueDate     ""
92458>>>>>        Property String private.psDriverDefaultValueDateTime ""
92459>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92460>>>>>        Property String private.psDriverDefaultValueText     ""
92461>>>>>
92461>>>>>        // Driver "nullability" settings:
92461>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92462>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92463>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92464>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92465>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92466>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92467>>>>>
92467>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92467>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92467>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92467>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92467>>>>>        // We reset it here for each cDbUpdateVersion object
92467>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92469>>>>>    End_Procedure
92470>>>>>
92470>>>>>    // *** Main hook event message ***
92470>>>>>    // Place your database update logic here!
92470>>>>>    Procedure OnUpdate
92472>>>>>    End_Procedure
92473>>>>>
92473>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92473>>>>>    // imported to the cDbUpdateHandler container class which should be a
92473>>>>>    // parent object to this object. To have the Studio's Property Panel
92473>>>>>    // "behave" aka show these properties we need to duplicate them in this
92473>>>>>    // class and "relay" them to the parent object.
92473>>>>>    Procedure Set pbToANSI Boolean bState
92475>>>>>        Set private.pbToANSI  to bState
92476>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92477>>>>>        Delegate Set pbToANSI to bState
92479>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92480>>>>>    End_Procedure
92481>>>>>
92481>>>>>    Function pbToANSI Returns Boolean
92483>>>>>        Function_Return (private.pbToAnsi(Self))
92484>>>>>    End_Function
92485>>>>>
92485>>>>>    Procedure Set pbRecnum Boolean bState
92487>>>>>        Set private.pbRecnum  to bState
92488>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92489>>>>>        Delegate Set pbRecnum to bState
92491>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92492>>>>>    End_Procedure
92493>>>>>
92493>>>>>    Function pbRecnum Returns Boolean
92495>>>>>        Function_Return (private.pbRecnum(Self))
92496>>>>>    End_Function
92497>>>>>
92497>>>>>    Procedure Set pbCopyData Boolean bState
92499>>>>>        Set private.pbCopyData  to bState
92500>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92501>>>>>        Delegate Set pbCopyData to bState
92503>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92504>>>>>    End_Procedure
92505>>>>>
92505>>>>>    Function pbCopyData Returns Boolean
92507>>>>>        Function_Return (private.pbCopyData(Self))
92508>>>>>    End_Function
92509>>>>>
92509>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92509>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92511>>>>>        Set private.pbApiTableUpdateAuto  to bState
92512>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92513>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92514>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92515>>>>>    End_Procedure
92516>>>>>
92516>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92518>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92519>>>>>    End_Function
92520>>>>>
92520>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92522>>>>>        Set private.pbCompareDate_DateTime  to bState
92523>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92524>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92525>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92526>>>>>    End_Procedure
92527>>>>>
92527>>>>>    Function pbCompareDate_DateTime Returns Boolean
92529>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92530>>>>>    End_Function
92531>>>>>
92531>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92533>>>>>        Set private.pbCompareIndexAscending  to bState
92534>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92535>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92536>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92537>>>>>    End_Procedure
92538>>>>>
92538>>>>>    Function pbCompareIndexAscending Returns Boolean
92540>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92541>>>>>    End_Function
92542>>>>>
92542>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92544>>>>>        Set private.pbCompareIndexUppercase  to bState
92545>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92546>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92547>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92548>>>>>    End_Procedure
92549>>>>>
92549>>>>>    Function pbCompareIndexUppercase Returns Boolean
92551>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92552>>>>>    End_Function
92553>>>>>
92553>>>>>    Procedure Set psSchema String sValue
92555>>>>>        Set private.psSchema  to sValue
92556>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92557>>>>>        Delegate Set psSchema to sValue
92559>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92560>>>>>    End_Procedure
92561>>>>>
92561>>>>>    // First retrieve the private value that might have been set in the object.
92561>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92561>>>>>    // it might have been specified in the SQLConnections.ini file.
92561>>>>>    Function psSchema Returns String
92563>>>>>        String sValue
92563>>>>>        Get private.psSchema to sValue
92564>>>>>        If (sValue = "") Begin
92566>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92567>>>>>        End
92567>>>>>>
92567>>>>>        Function_Return sValue
92568>>>>>    End_Function
92569>>>>>
92569>>>>>    Procedure Set psBaseTableSpace String sValue
92571>>>>>        Set private.psBaseTableSpace  to sValue
92572>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92573>>>>>        Delegate Set psBaseTableSpace to sValue
92575>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92576>>>>>    End_Procedure
92577>>>>>
92577>>>>>    // First retrieve the private value that might have been set in the object.
92577>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92577>>>>>    // it might have been specified in the SQLConnections.ini file.
92577>>>>>    Function psBaseTableSpace Returns String
92579>>>>>        String sValue
92579>>>>>        Get private.psBaseTableSpace to sValue
92580>>>>>        If (sValue = "") Begin
92582>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92583>>>>>        End
92583>>>>>>
92583>>>>>        Function_Return sValue
92584>>>>>    End_Function
92585>>>>>
92585>>>>>    Procedure Set psLongTableSpace String sValue
92587>>>>>        Set private.psLongTableSpace  to sValue
92588>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92589>>>>>        Delegate Set psLongTableSpace to sValue
92591>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92592>>>>>    End_Procedure
92593>>>>>
92593>>>>>    // First retrieve the private value that might have been set in the object.
92593>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92593>>>>>    // it might have been specified in the SQLConnections.ini file.
92593>>>>>    Function psLongTableSpace Returns String
92595>>>>>        String sValue
92595>>>>>        Get private.psLongTableSpace to sValue
92596>>>>>        If (sValue = "") Begin
92598>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
92599>>>>>        End
92599>>>>>>
92599>>>>>        Function_Return sValue
92600>>>>>    End_Function
92601>>>>>
92601>>>>>    Procedure Set psIndexTableSpace String sValue
92603>>>>>        Set private.psIndexTableSpace  to sValue
92604>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92605>>>>>        Delegate Set psIndexTableSpace to sValue
92607>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92608>>>>>    End_Procedure
92609>>>>>
92609>>>>>    // First retrieve the private value that might have been set in the object.
92609>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92609>>>>>    // it might have been specified in the SQLConnections.ini file.
92609>>>>>    Function psIndexTableSpace Returns String
92611>>>>>        String sValue
92611>>>>>        Get private.psIndexTableSpace to sValue
92612>>>>>        If (sValue = "") Begin
92614>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
92615>>>>>        End
92615>>>>>>
92615>>>>>        Function_Return sValue
92616>>>>>    End_Function
92617>>>>>
92617>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92619>>>>>        Set private.psDriverDefaultValueASCII  to sValue
92620>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92621>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
92623>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92624>>>>>    End_Procedure
92625>>>>>
92625>>>>>    // First retrieve the private value that might have been set in the object.
92625>>>>>    // If blank; get it from the parent object
92625>>>>>    Function psDriverDefaultValueASCII Returns String
92627>>>>>        String sValue
92627>>>>>        Get private.psDriverDefaultValueASCII to sValue
92628>>>>>        If (sValue = "") Begin
92630>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
92632>>>>>        End
92632>>>>>>
92632>>>>>        Function_Return sValue
92633>>>>>    End_Function
92634>>>>>
92634>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92636>>>>>        Set private.psDriverDefaultValueBinary  to sValue
92637>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92638>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
92640>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92641>>>>>    End_Procedure
92642>>>>>
92642>>>>>    // First retrieve the private value that might have been set in the object.
92642>>>>>    // If blank; get it from the parent object
92642>>>>>    Function psDriverDefaultValueBinary Returns String
92644>>>>>        String sValue
92644>>>>>        Get private.psDriverDefaultValueBinary to sValue
92645>>>>>        If (sValue = "") Begin
92647>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
92649>>>>>        End
92649>>>>>>
92649>>>>>        Function_Return sValue
92650>>>>>    End_Function
92651>>>>>
92651>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92653>>>>>        Set private.psDriverDefaultValueDate  to sValue
92654>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92655>>>>>        Delegate Set psDriverDefaultValueDate to sValue
92657>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92658>>>>>    End_Procedure
92659>>>>>
92659>>>>>    // First retrieve the private value that might have been set in the object.
92659>>>>>    // If blank; get it from the parent object
92659>>>>>    Function psDriverDefaultValueDate Returns String
92661>>>>>        String sValue
92661>>>>>        Get private.psDriverDefaultValueDate to sValue
92662>>>>>        If (sValue = "") Begin
92664>>>>>            Delegate Get psDriverDefaultValueDate to sValue
92666>>>>>        End
92666>>>>>>
92666>>>>>        Function_Return sValue
92667>>>>>    End_Function
92668>>>>>
92668>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92670>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
92671>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92672>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
92674>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92675>>>>>    End_Procedure
92676>>>>>
92676>>>>>    // First retrieve the private value that might have been set in the object.
92676>>>>>    // If blank; get it from the parent object
92676>>>>>    Function psDriverDefaultValueDateTime Returns String
92678>>>>>        String sValue
92678>>>>>        Get private.psDriverDefaultValueDateTime to sValue
92679>>>>>        If (sValue = "") Begin
92681>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
92683>>>>>        End
92683>>>>>>
92683>>>>>        Function_Return sValue
92684>>>>>    End_Function
92685>>>>>
92685>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92687>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
92688>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92689>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
92691>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92692>>>>>    End_Procedure
92693>>>>>
92693>>>>>    // First retrieve the private value that might have been set in the object.
92693>>>>>    // If blank; get it from the parent object
92693>>>>>    Function psDriverDefaultValueNumeric Returns String
92695>>>>>        String sValue
92695>>>>>        Get private.psDriverDefaultValueNumeric to sValue
92696>>>>>        If (sValue = "") Begin
92698>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
92700>>>>>        End
92700>>>>>>
92700>>>>>        Function_Return sValue
92701>>>>>    End_Function
92702>>>>>
92702>>>>>    Procedure Set psDriverDefaultValueText String sValue
92704>>>>>        Set private.psDriverDefaultValueText  to sValue
92705>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92706>>>>>        Delegate Set psDriverDefaultValueText to sValue
92708>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92709>>>>>    End_Procedure
92710>>>>>
92710>>>>>    // First retrieve the private value that might have been set in the object.
92710>>>>>    // If blank; get it from the parent object
92710>>>>>    Function psDriverDefaultValueText Returns String
92712>>>>>        String sValue
92712>>>>>        Get private.psDriverDefaultValueText to sValue
92713>>>>>        If (sValue = "") Begin
92715>>>>>            Delegate Get psDriverDefaultValueText to sValue
92717>>>>>        End
92717>>>>>>
92717>>>>>        Function_Return sValue
92718>>>>>    End_Function
92719>>>>>
92719>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92721>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
92722>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92723>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
92725>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92726>>>>>    End_Procedure
92727>>>>>
92727>>>>>    // First retrieve the private value that might have been set in the object.
92727>>>>>    // If blank; get it from the parent object
92727>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92729>>>>>        Boolean bState
92729>>>>>        Get private.pbDriverDefaultNullableASCII to bState
92730>>>>>        If (bState = False) Begin
92732>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
92734>>>>>        End
92734>>>>>>
92734>>>>>        Function_Return bState
92735>>>>>    End_Function
92736>>>>>
92736>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92738>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
92739>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92740>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
92742>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92743>>>>>    End_Procedure
92744>>>>>
92744>>>>>    // First retrieve the private value that might have been set in the object.
92744>>>>>    // If blank; get it from the parent object
92744>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92746>>>>>        Boolean bState
92746>>>>>        Get private.pbDriverDefaultNullableBinary to bState
92747>>>>>        If (bState = False) Begin
92749>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
92751>>>>>        End
92751>>>>>>
92751>>>>>        Function_Return bState
92752>>>>>    End_Function
92753>>>>>
92753>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92755>>>>>        Set private.pbDriverDefaultNullableDate  to bState
92756>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92757>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
92759>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92760>>>>>    End_Procedure
92761>>>>>
92761>>>>>    // First retrieve the private value that might have been set in the object.
92761>>>>>    // If blank; get it from the parent object
92761>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92763>>>>>        Boolean bState
92763>>>>>        Get private.pbDriverDefaultNullableDate to bState
92764>>>>>        If (bState = False) Begin
92766>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
92768>>>>>        End
92768>>>>>>
92768>>>>>        Function_Return bState
92769>>>>>    End_Function
92770>>>>>
92770>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92772>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
92773>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92774>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
92776>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92777>>>>>    End_Procedure
92778>>>>>
92778>>>>>    // First retrieve the private value that might have been set in the object.
92778>>>>>    // If blank; get it from the parent object
92778>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92780>>>>>        Boolean bState
92780>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
92781>>>>>        If (bState = False) Begin
92783>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
92785>>>>>        End
92785>>>>>>
92785>>>>>        Function_Return bState
92786>>>>>    End_Function
92787>>>>>
92787>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92789>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
92790>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92791>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
92793>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92794>>>>>    End_Procedure
92795>>>>>
92795>>>>>    // First retrieve the private value that might have been set in the object.
92795>>>>>    // If blank; get it from the parent object
92795>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92797>>>>>        Boolean bState
92797>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
92798>>>>>        If (bState = False) Begin
92800>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
92802>>>>>        End
92802>>>>>>
92802>>>>>        Function_Return bState
92803>>>>>    End_Function
92804>>>>>
92804>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92806>>>>>        Set private.pbDriverDefaultNullableText  to bState
92807>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92808>>>>>        Delegate Set pbDriverDefaultNullableText to bState
92810>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92811>>>>>    End_Procedure
92812>>>>>
92812>>>>>    // First retrieve the private value that might have been set in the object.
92812>>>>>    // If blank; get it from the parent object
92812>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92814>>>>>        Boolean bState
92814>>>>>        Get private.pbDriverDefaultNullableText to bState
92815>>>>>        If (bState = False) Begin
92817>>>>>            Delegate Get pbDriverDefaultNullableText to bState
92819>>>>>        End
92819>>>>>>
92819>>>>>        Function_Return bState
92820>>>>>    End_Function
92821>>>>>
92821>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
92823>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
92823>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
92823>>>>>
92823>>>>>        Get psDriverID to sDriverID
92824>>>>>        Get psSchema to sSchema
92825>>>>>
92825>>>>>        Get psBaseTableSpace to sBaseTableSpace
92826>>>>>        If (sBaseTableSpace <> "") Begin
92828>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92829>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
92831>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92832>>>>>        End
92832>>>>>>
92832>>>>>
92832>>>>>        Get psLongTableSpace to sLongTableSpace
92833>>>>>        If (sLongTableSpace <> "") Begin
92835>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92836>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
92838>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92839>>>>>        End
92839>>>>>>
92839>>>>>
92839>>>>>        Get psIndexTableSpace to sIndexTableSpace
92840>>>>>        If (sIndexTableSpace <> "") Begin
92842>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92843>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
92845>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92846>>>>>        End
92846>>>>>>
92846>>>>>
92846>>>>>        Get pbUseConnectionID to bUseConnectionID
92847>>>>>        Get pbToANSI          to bToANSI
92848>>>>>        Get pbRecnum          to bRecnum
92849>>>>>        Get pbCopyData        to bCopyData
92850>>>>>
92850>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
92851>>>>>
92851>>>>>        Function_Return bOK
92852>>>>>    End_Function
92853>>>>>
92853>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
92853>>>>>//        Boolean bOK bExists
92853>>>>>//        String sDataPath sBackupFolder
92853>>>>>//        
92853>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
92853>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
92853>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92853>>>>>//        Get vFolderFormat sDataPath to sDataPath
92853>>>>>//        
92853>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92853>>>>>//        If (bExists = False) Begin
92853>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92853>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92853>>>>>//            If (bExists = False) Begin
92853>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
92853>>>>>//                Function_Return False
92853>>>>>//            End                                                                                                                                            
92853>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
92853>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
92853>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
92853>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
92853>>>>>//        End
92853>>>>>//        
92853>>>>>//        Set Message_Text of ghoStatusPanel to ""
92853>>>>>//        Function_Return bOK
92853>>>>>//    End_Function
92853>>>>>//
92853>>>>>    // This is automatically called after the OnUpdate
92853>>>>>    // event has been executed. It will automatically update the
92853>>>>>    // version database field/column with the "pnVersionNumber"
92853>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
92853>>>>>    Procedure UpdateVersionColumnValue
92855>>>>>        Number nVersion nCurrentValue
92855>>>>>        Integer hTable iColumn
92855>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
92855>>>>>
92855>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
92855>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
92855>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92857>>>>>        Get pbVersionUpdate to bVersionUpdate
92858>>>>>
92858>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
92860>>>>>            Get pnVersionNumber to nVersion
92861>>>>>            Delegate Get piDbVersionFileNumber  to hTable
92863>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
92865>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
92865>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
92865>>>>>            Close DF_ALL DF_PERMANENT
92866>>>>>
92866>>>>>            Open hTable
92868>>>>>
92868>>>>>            // It is then the developer responsibility to take care of finding
92868>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
92868>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92870>>>>>            If (bUseCustomDbVersion = True) Begin
92872>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
92874>>>>>            End
92874>>>>>>
92874>>>>>
92874>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92877>>>>>            If (nCurrentValue < nVersion) Begin
92879>>>>>                Lock
92880>>>>>>
92880>>>>>                    If (bUseCustomDbVersion = False) Begin
92882>>>>>                        Vfind hTable Recnum GE                            
92884>>>>>                    End
92884>>>>>>
92884>>>>>                    Set_Field_Value hTable iColumn to nVersion
92887>>>>>                    SaveRecord hTable
92888>>>>>                Unlock
92889>>>>>>
92889>>>>>            End
92889>>>>>>
92889>>>>>            Close hTable
92890>>>>>        End
92890>>>>>>
92890>>>>>    End_Procedure
92891>>>>>
92891>>>>>// Property of the container object (cDbUpdateHandler)
92891>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
92891>>>>>
92891>>>>>    Procedure End_Construct_Object
92893>>>>>        Forward Send End_Construct_Object
92895>>>>>        Send ProcessUpdate True
92896>>>>>    End_Procedure
92897>>>>>    
92897>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
92899>>>>>        Number nVersion nCurrentValue
92899>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
92899>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
92899>>>>>        String sObjectName
92899>>>>>        tDbVersionInfo[] dbVersionInfoArray
92899>>>>>        tDbVersionInfo[] dbVersionInfoArray
92900>>>>>
92900>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
92902>>>>>
92902>>>>>        // If the programmer forgot to set the version number we do not allow for the application
92902>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
92902>>>>>        // one database update is depended on an earlier update and that earlier version
92902>>>>>        // update was never executed it could lead to disastrous results.
92902>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
92902>>>>>        Get pnVersionNumber to nVersion
92903>>>>>        If (nVersion = 0) Begin
92905>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
92906>>>>>            Move (Name(Self)) to sObjectName
92907>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
92908>>>>>>
92908>>>>>            Send Exit_Application
92909>>>>>        End
92909>>>>>>
92909>>>>>
92909>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
92909>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
92909>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
92911>>>>>        If (bOnPreUpdateExecuted = False) Begin
92913>>>>>            Delegate Send OnPreUpdate
92915>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
92917>>>>>        End
92917>>>>>>
92917>>>>>        
92917>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
92919>>>>>        
92919>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92921>>>>>        If (bUseCustomDbVersion = False) Begin
92923>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
92923>>>>>        End
92923>>>>>>
92923>>>>>        Else Begin
92924>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
92925>>>>>            If (bTableExists = False) Begin
92927>>>>>                Delegate Send OnCreateCustomDbVersionTable
92929>>>>>            End
92929>>>>>>
92929>>>>>        End
92929>>>>>>
92929>>>>>        
92929>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
92929>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
92929>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
92931>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
92933>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
92934>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
92935>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
92936>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
92938>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
92940>>>>>        End
92940>>>>>>
92940>>>>>
92940>>>>>        Delegate Get piDbVersionFileNumber  to hTable
92942>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
92944>>>>>
92944>>>>>        Open hTable
92946>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92949>>>>>        If (bOpened = False) Begin
92951>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
92952>>>>>            Send Exit_Application
92953>>>>>        End
92953>>>>>>
92953>>>>>        
92953>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
92953>>>>>        // in case we take care of it here.
92953>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
92956>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
92958>>>>>            Vfind hTable 0 GT
92960>>>>>        End
92960>>>>>>
92960>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
92963>>>>>        If (bSystemTable = True) Begin
92965>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92968>>>>>        End
92968>>>>>>
92968>>>>>        Else Begin
92969>>>>>            If (bUseCustomDbVersion = True) Begin
92971>>>>>                Send OnFindVersionRecord
92972>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
92975>>>>>            End
92975>>>>>>
92975>>>>>        End
92975>>>>>>
92975>>>>>
92975>>>>>        Close hTable
92976>>>>>
92976>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
92976>>>>>        // If not set we do nothing.
92976>>>>>        If (nCurrentValue < nVersion) Begin
92978>>>>>
92978>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
92978>>>>>            // execution of database update code. So if true _and_ one error
92978>>>>>            // has already occured; we're out of here.
92978>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
92980>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92982>>>>>            If (bStopOnFirstError = True) Begin
92984>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
92986>>>>>                    Procedure_Return
92987>>>>>                End
92987>>>>>>
92987>>>>>            End
92987>>>>>>
92987>>>>>
92987>>>>>            // This is send to the parent container object (cDbUpdateHandler)
92987>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
92989>>>>>
92989>>>>>            // If the parent property pbContinueOnError = False, an update
92989>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
92989>>>>>            Delegate Get pbContinueOnError to bContinueOnError
92991>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
92993>>>>>                Procedure_Return
92994>>>>>            End
92994>>>>>>
92994>>>>>
92994>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
92996>>>>>
92996>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
92997>>>>>
92997>>>>>            // *** Programmer's main hook event for database update functions:
92997>>>>>            Send OnUpdate
92998>>>>>
92998>>>>>            Set pbVersionUpdate to True
92999>>>>>            Send UpdateVersionColumnValue
93000>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93002>>>>>        End
93002>>>>>>
93002>>>>>
93002>>>>>    End_Procedure
93003>>>>>
93003>>>>>End_Class
93004>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93004>>>>>//****************************************************************************
93004>>>>>// $Module type: Class
93004>>>>>// $Module name: cDbUpdateUserCount.pkg
93004>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93004>>>>>//
93004>>>>>//               Collected from DAW's newsgroups.
93004>>>>>//
93004>>>>>// Description : It uses the windows API to lock bytes in a file.
93004>>>>>//               If the application or PC craches it will release the lock
93004>>>>>//               automatically.
93004>>>>>//
93004>>>>>// Note 1      : It will count the number of running app's, so if a
93004>>>>>//               user starts the app twice on one machine it will count as two users.
93004>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93004>>>>>//               However, to not conflict with any other usage of this class it was
93004>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93004>>>>>//               and cDbUpdateVersion classes)
93004>>>>>//
93004>>>>>// $Rev History:
93004>>>>>//    2008-10-17  Module header created (Militaty data format)
93004>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93004>>>>>//                for easy translation to other languages.
93004>>>>>//                Added the tUserCount struct for easier passing of parameters.
93004>>>>>//                Added the ApplicationPath message.
93004>>>>>//****************************************************************************
93004>>>>>Use LanguageText.pkg
93004>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93004>>>>>>>Use GlobalFunctionsProcedures.pkg
93004>>>>>>>// Sample:
93004>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93004>>>>>>>
93004>>>>>>>
93004>>>>>>>// Symbols used by UserCounting
93004>>>>>>>    Define GENERIC_READ         for |CI$80000000
93004>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93004>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93004>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93004>>>>>>>    Define CREATE_NEW           for 1
93004>>>>>>>    Define CREATE_ALWAYS        for 2
93004>>>>>>>    Define OPEN_EXISTING        for 3
93004>>>>>>>    Define OPEN_ALWAYS          for 4
93004>>>>>>>    Define TRUNCATE_EXISTING    for 5
93004>>>>>>>    Define FILE_BEGIN           for 0
93004>>>>>>>    Define FILE_CURRENT         for 1
93004>>>>>>>    Define FILE_END             for 2
93004>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93004>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93004>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93004>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93004>>>>>>>    Define _MAX_PATH  for 260
93004>>>>>>>    Define _MAX_DRIVE for 3
93004>>>>>>>    Define _MAX_DIR   for 256
93004>>>>>>>    Define _MAX_FNAME for 256
93004>>>>>>>    Define _MAX_EXT   for 256
93004>>>>>>>
93004>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93005>>>>>>>
93005>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93006>>>>>>>
93006>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93007>>>>>>>
93007>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93008>>>>>>>
93008>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93009>>>>>>>
93009>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93010>>>>>>>
93010>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93011>>>>>>>
93011>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93012>>>>>>>// Sample:
93012>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93012>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93014>>>>>>>    Boolean bReturn
93014>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93015>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93016>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93017>>>>>>>    Function_Return bReturn
93018>>>>>>>End_Function
93019>>>>>Use vWin32fh.pkg
93019>>>>>Use seq_chnl.pkg
93019>>>>>
93019>>>>>// User interface constant strings:
93019>>>>>    Define CS_UserCountError            for "User count error:"
93019>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93019>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93019>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93019>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>
93019>>>>>    Struct tUserCount
93019>>>>>        Integer iUserCount
93019>>>>>        Integer iError
93019>>>>>        String  sErrorTxt
93019>>>>>    End_Struct
93019>>>>>
93019>>>>>    Define CI_UserCountMaxUsers for 9999
93019>>>>>
93019>>>>>Class cDbUpdateUserCount is a cObject
93020>>>>>    Procedure Construct_Object
93022>>>>>        Forward Send Construct_Object
93024>>>>>
93024>>>>>        Property String  psLockFileName
93025>>>>>        Property Integer piMaxUsers
93026>>>>>        Property Boolean pbCheckDataFlexUserCount True
93027>>>>>
93027>>>>>        Property Handle  phUserCountFile
93028>>>>>        Property Integer pdwLockPosition
93029>>>>>    End_Procedure
93030>>>>>
93030>>>>>    Function IsProgramRunning Returns Boolean
93032>>>>>        tUserCount UserCount
93032>>>>>        tUserCount UserCount
93032>>>>>
93032>>>>>        Get CheckUserCount to UserCount
93033>>>>>
93033>>>>>        Function_Return (UserCount.iUserCount > 1)
93034>>>>>    End_Function
93035>>>>>
93035>>>>>    // Returns the full path of the Application (no trailing "\")
93035>>>>>    Function ApplicationPath Returns String
93037>>>>>        String sApplicationFileName sPath
93037>>>>>        Integer iNumChars iRetval
93037>>>>>
93037>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93038>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93039>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93040>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93041>>>>>        Move (CString(sApplicationFileName)) to sPath
93042>>>>>
93042>>>>>        Function_Return sPath
93043>>>>>    End_Function
93044>>>>>
93044>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93046>>>>>        Handle  hFile
93046>>>>>        Pointer pFileName
93046>>>>>        String sPath sFile
93046>>>>>        Integer iCh
93046>>>>>
93046>>>>>        Move (Addressof(sFileName)) to pFileName
93047>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93048>>>>>
93048>>>>>        // If lock file doesn't exist, create it.
93048>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93050>>>>>            Get ApplicationPath to sPath
93051>>>>>            Get vFolderFormat sPath to sPath
93052>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93053>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93054>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93056>>>>>                Function_Return 0
93057>>>>>            End
93057>>>>>>
93057>>>>>            Direct_Output channel iCh sFile
93059>>>>>                Write channel iCh ""
93061>>>>>            Send Seq_Close_Channel iCh
93062>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93063>>>>>        End
93063>>>>>>
93063>>>>>
93063>>>>>        Function_Return hFile
93064>>>>>    End_Function
93065>>>>>
93065>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93067>>>>>        Integer iReturnValue 
93067>>>>>        Boolean bOK
93067>>>>>
93067>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93068>>>>>        If (iReturnValue = 0) Begin
93070>>>>>            Move False to bOK
93071>>>>>        End
93071>>>>>>
93071>>>>>        Else Begin
93072>>>>>            Move True to bOK
93073>>>>>        End
93073>>>>>>
93073>>>>>        Function_Return bOK
93074>>>>>    End_Function
93075>>>>>
93075>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93077>>>>>        Integer iReturnValue
93077>>>>>        Boolean bOK
93077>>>>>
93077>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93078>>>>>        If (iReturnValue = 0) Begin
93080>>>>>            Move False to bOK
93081>>>>>        End
93081>>>>>>
93081>>>>>        Else Begin
93082>>>>>            Move True to bOK
93083>>>>>        End           
93083>>>>>>
93083>>>>>        Function_Return bOK
93084>>>>>    End_Function
93085>>>>>
93085>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93087>>>>>        dWord dwCurrPos
93087>>>>>
93087>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93088>>>>>        Function_Return dwCurrPos
93089>>>>>    End_Function
93090>>>>>
93090>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93092>>>>>        DWord dwCurrPos
93092>>>>>
93092>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93093>>>>>        Function_Return dwCurrPos
93094>>>>>    End_Function
93095>>>>>
93095>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93097>>>>>        Integer iReturnValue                               
93097>>>>>        Boolean bOK
93097>>>>>        String  sBuffer
93097>>>>>        Pointer pBuffer
93097>>>>>        String  sSize
93097>>>>>        Pointer pSize
93097>>>>>
93097>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93098>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93099>>>>>
93099>>>>>        Move (Repeat((Character(0)),4)) to sSize
93100>>>>>        Move (AddressOf(sSize)) to pSize
93101>>>>>
93101>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93102>>>>>        If (iReturnValue = 0) Begin
93104>>>>>            Move False to bOK
93105>>>>>        End
93105>>>>>>
93105>>>>>        Else Begin
93106>>>>>            Move True to bOK
93107>>>>>        End                 
93107>>>>>>
93107>>>>>        Function_Return bOK
93108>>>>>    End_Function
93109>>>>>
93109>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93111>>>>>        Integer iReturnValue
93111>>>>>
93111>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93112>>>>>        Function_Return iReturnValue
93113>>>>>    End_Function
93114>>>>>
93114>>>>>    Procedure DoCheckUserCount
93116>>>>>        tUserCount UserCount
93116>>>>>        tUserCount UserCount
93116>>>>>
93116>>>>>        Get CheckUserCount to UserCount
93117>>>>>        // If all is fine, we're done.
93117>>>>>        If (UserCount.iError = 0) Begin
93119>>>>>            Procedure_Return
93120>>>>>        End
93120>>>>>>
93120>>>>>
93120>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93121>>>>>
93121>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93123>>>>>            Abort
93124>>>>>>
93124>>>>>        End
93124>>>>>>
93124>>>>>    End_Procedure
93125>>>>>
93125>>>>>    Function CheckUserCount Returns tUserCount
93127>>>>>        Handle  hFile
93127>>>>>        String  sPath sFile
93127>>>>>        Integer iResult
93127>>>>>        DWord   dwFilePos
93127>>>>>        Integer bLocked
93127>>>>>        Integer iMaxUsers
93127>>>>>        Integer iCurUser
93127>>>>>        tUserCount UserCount
93127>>>>>        tUserCount UserCount
93127>>>>>
93127>>>>>        Move 0 to UserCount.iError
93128>>>>>
93128>>>>>        Get phUserCountFile to hFile
93129>>>>>        If (not(hFile)) Begin
93131>>>>>            Get ApplicationPath to sPath
93132>>>>>            Get vFolderFormat sPath to sPath
93133>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93134>>>>>            Get OpenUserCountFile sFile to hFile
93135>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93137>>>>>                Move 1 to UserCount.iUserCount
93138>>>>>                Move 1 to UserCount.iError
93139>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93140>>>>>                Function_Return UserCount
93141>>>>>            End
93141>>>>>>
93141>>>>>            Else Begin
93142>>>>>                Move False to bLocked
93143>>>>>                Set phUserCountFile to hFile
93144>>>>>                Get piMaxUsers to iMaxUsers
93145>>>>>
93145>>>>>                // Set Filepointer to beginning of the file
93145>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93146>>>>>                If (dwFilePos = -1) Begin
93148>>>>>                    Move 1 to UserCount.iUserCount
93149>>>>>                    Move 2 to UserCount.iError
93150>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93151>>>>>                    Function_Return UserCount
93152>>>>>                End
93152>>>>>>
93152>>>>>                For iCurUser from 1 to iMaxUsers
93158>>>>>>
93158>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93159>>>>>                    If (not(iResult)) Begin  // byte is locked
93161>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93162>>>>>                        If (dwFilePos = -1) Begin
93164>>>>>                            Move 1 to UserCount.iUserCount
93165>>>>>                            Move 3 to UserCount.iError
93166>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93167>>>>>                            Function_Return UserCount
93168>>>>>                        End
93168>>>>>>
93168>>>>>                    End
93168>>>>>>
93168>>>>>                    Else Begin  // byte is not locked
93169>>>>>                        Set pdwLockPosition to dwFilePos
93170>>>>>                        Move True to bLocked
93171>>>>>                        Move iMaxUsers to iCurUser
93172>>>>>                    End
93172>>>>>>
93172>>>>>                Loop
93173>>>>>>
93173>>>>>                If (not(bLocked)) Begin
93175>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93176>>>>>                    Move 4 to UserCount.iError
93177>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93178>>>>>                    Function_Return UserCount
93179>>>>>                End
93179>>>>>>
93179>>>>>            End
93179>>>>>>
93179>>>>>        End
93179>>>>>>
93179>>>>>
93179>>>>>        Function_Return UserCount
93180>>>>>    End_Function
93181>>>>>
93181>>>>>
93181>>>>>    Procedure DoReleaseUserCount
93183>>>>>        Integer iResult
93183>>>>>        Handle  hFile
93183>>>>>        DWord   dwLockPos
93183>>>>>
93183>>>>>        Get phUserCountFile to hFile
93184>>>>>        Get pdwLockPosition to dwLockPos
93185>>>>>        If (hFile) Begin
93187>>>>>            If (dwLockPos) Begin
93189>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93190>>>>>            End
93190>>>>>>
93190>>>>>            Get CloseUserCountFile hFile to iResult
93191>>>>>        End
93191>>>>>>
93191>>>>>    End_Procedure
93192>>>>>
93192>>>>>    Function CurrentNumberOfUsers Returns Integer
93194>>>>>        Handle  hFile
93194>>>>>        Integer iMaxUsers
93194>>>>>        DWord   dwFilePos
93194>>>>>        Integer iCurUser
93194>>>>>        Integer iResult
93194>>>>>        Integer iNumberOfLocks
93194>>>>>        String  sPath sFile
93194>>>>>
93194>>>>>        Move 0 to iNumberOfLocks
93195>>>>>
93195>>>>>        Get ApplicationPath to sPath
93196>>>>>        Get vFolderFormat sPath to sPath
93197>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93198>>>>>        Get OpenUserCountFile sFile to hFile
93199>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93201>>>>>            Send UserError CS_UnableToInitUserCountSys
93202>>>>>            Abort
93203>>>>>>
93203>>>>>        End
93203>>>>>>
93203>>>>>
93203>>>>>        If (hFile > 0) Begin
93205>>>>>            Get piMaxUsers To iMaxUsers
93206>>>>>
93206>>>>>            // Set Filepointer to beginning of the file
93206>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93207>>>>>            If (dwFilePos = -1) Begin
93209>>>>>                Send UserError CS_UnableResetUserCountSys
93210>>>>>                Abort
93211>>>>>>
93211>>>>>            End
93211>>>>>>
93211>>>>>            For iCurUser from 1 to iMaxUsers
93217>>>>>>
93217>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93218>>>>>                If (Not(iResult)) Begin  // byte is locked
93220>>>>>                    Increment iNumberOfLocks
93221>>>>>                End
93221>>>>>>
93221>>>>>                Else Begin  // byte is not locked
93222>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93223>>>>>                End
93223>>>>>>
93223>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93224>>>>>                If (dwFilePos = -1) Begin
93226>>>>>                    Send UserError CS_ErrorAdvancingPointer
93227>>>>>                    Abort
93228>>>>>>
93228>>>>>                End
93228>>>>>>
93228>>>>>            Loop
93229>>>>>>
93229>>>>>        End
93229>>>>>>
93229>>>>>        Get CloseUserCountFile hFile to iResult
93230>>>>>        Function_Return iNumberOfLocks
93231>>>>>    End_Function
93232>>>>>
93232>>>>>End_Class
93233>>>Use cDbUpdateFunctionLibrary.pkg
93233>>>
93233>>>//{ DataBindable=True }
93233>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
93233>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
93234>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary
93234>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
93234>>>
93234>>>    Procedure Construct_Object
93236>>>        tUserCount UserCount
93236>>>        tUserCount UserCount
93236>>>        Integer iUserCount
93236>>>        Handle ho                     
93236>>>
93236>>>        Forward Send Construct_Object
93238>>>        Move Self to ghoDbUpdateHandler  
93239>>>        
93239>>>        // Latin1_General_CI_AS = General Insensitive collation
93239>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93239>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93239>>>        // Good read about which collation to select:
93239>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93239>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93240>>>
93240>>>        // Struct array that will contain pnVersionNumbers & object id's of
93240>>>        // all child cDbVersion objects.
93240>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93241>>>
93241>>>        Property Integer Error_Processing_State False  // internal usage
93242>>>        
93242>>>        Property Boolean Private.pbDbVersionCheckDone False
93243>>>
93243>>>        Property Boolean pbUseCustomDbVersion False  
93244>>>        
93244>>>        // If this property = True _and_ no DbVersion table exists 
93244>>>        // when the framework is started, a DbVersion table will be created automatically.
93244>>>        Property Boolean pbAutoCreateDbVersionTable True
93245>>>
93245>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93245>>>        // the Filelist.cfg slot number indicated by this property will be used
93245>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93245>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93245>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93245>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93245>>>        Property Integer Private.piDbVersionFileNumber -1
93246>>>        Property Integer Private.piDbVersionFieldNumber 1
93247>>>
93247>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93247>>>        // that creates all library properties
93247>>>        Send CreateDbUpdateLibraryProperties
93248>>>
93248>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93249>>>
93249>>>        // Error handling:
93249>>>        Property Boolean Private.pbOnCreateExecuted False
93250>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93251>>>        Property Boolean Private.pbProcessingError False
93252>>>        Property Boolean pbDbUpdateErrorHasOccured False
93253>>>        // Don't touch. It is being used by the cDbUpdateVersion
93253>>>        // subclass to tell if that particular update went OK or not.
93253>>>        Property Boolean Private.pbUpdateVersionObjectError False
93254>>>        Property String[] paSQLQueryMessages
93255>>>
93255>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93256>>>        Move Self to Error_Object_Id
93257>>>        // Error handling:
93257>>>        // Temporarily redirect all errors to this object so we can silently
93257>>>        // log all errors that might appear while updating the database.
93257>>>        // We temporarily redirect all errors to this object so we can
93257>>>        // log and write errors to the log file. It will be reset after
93257>>>        // the database updates have been finished.
93257>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93258>>>
93258>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93259>>>
93259>>>        // Error Reporting Related
93259>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93259>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93260>>>
93260>>>        // If the pbContinueOnError = False, an update
93260>>>        // of another cDbUpdateVersion object will _not_ be
93260>>>        // performed if an error occured in a previous
93260>>>        // cDbUpdateVersion object.
93260>>>        Property Boolean pbContinueOnError False
93261>>>        // Stops execution in other cDbUpdateVersion objecs,
93261>>>        // if errors occurred in one cDbUpdateVersion object.
93261>>>        Property Boolean pbStopOnFirstError False
93262>>>        // If True errors that occured while updating the database
93262>>>        // will be shown in the default app for .txt files when done.
93262>>>        // Note: The log file will _always_ be created in the Data folder.
93262>>>        Property Boolean pbShowErrorLogPostRun True
93263>>>
93263>>>        // Be _very_ careful to set this property to true!
93263>>>        // If = True, no question will be asked if the update
93263>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93263>>>        // the error log won't be shown. The logfile itself will still be created though.
93263>>>        // You have to know what you're doing!
93263>>>        Property Boolean pbSilentMode False
93264>>>        
93264>>>        Property Boolean pbEnableCancelButton False
93265>>>
93265>>>        // Don't touch! Very private. The value is used by the error log to write for which
93265>>>        // cDbUpdateVersion object an error occured.
93265>>>        Property Number pnCurrentVersionUpdate 0
93266>>>
93266>>>        // The user counting logic is used to safe-guard agains anybody else is
93266>>>        // using the application when a database update is to be performed.
93266>>>        // (Garters & suspenders!)
93266>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93267>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93268>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93269>>>
93269>>>        // This lock file is used to guard against somebody else tries to start the
93269>>>        // application while updates are in progress.
93269>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93270>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93271>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93272>>>                                                                                      // Only the current user allowed.
93272>>>        // Properties for the table & column of a system file field/column where
93272>>>        // the database version update number gets saved.
93272>>>        Property Integer Private.Data_File  0
93273>>>        Property Integer Private.Data_Field 0
93274>>>
93274>>>        // Property that is used to indicate that we have already
93274>>>        // started the database update.
93274>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93275>>>
93275>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93275>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93275>>>        // change of the database has been made.
93275>>>        Property Boolean Private.pbDatabaseWasUpdated False
93276>>>
93276>>>        // We need to trigger the user counting system so that a bit in the
93276>>>        // user counting file is locked. This is to guard that not more than one user
93276>>>        // is currently runnning the program.
93276>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93277>>>
93277>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93278>>>        If (iUserCount > 0) Begin
93280>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93281>>>            Send Exit_Application
93282>>>        End
93282>>>>
93282>>>
93282>>>        Set pbHandleQueryErrors to False
93283>>>            
93283>>>        Property Handle phoSQLConnectionHandler 0
93284>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93284>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93284>>>        // etc information.
93284>>>        If (ghoSQLConnectionHandler = 0) Begin
93286>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93287>>>            Set phoSQLConnectionHandler to ho
93288>>>        End             
93288>>>>
93288>>>        
93288>>>        Property Boolean pbCheckIntFiles False   
93289>>>        Property Handle  phIntFilesTable 2048
93290>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93291>>>        
93291>>>        Set Icon to "Default.ico"
93292>>>    End_Procedure
93293>>>
93293>>>    Procedure End_Construct_Object
93295>>>        Boolean bCheckIntFiles
93295>>>        
93295>>>        Forward Send End_Construct_Object
93297>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93299>>>            Send OnCreate
93300>>>            Set Private.pbOnCreateExecuted to True
93301>>>        End
93301>>>>
93301>>>        Send Cleanup
93302>>>    End_Procedure
93303>>>    
93303>>>    // Programmers hook event.
93303>>>    Procedure OnCreate
93305>>>    End_Procedure        
93306>>>                                 
93306>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93306>>>    //                                                
93306>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
93306>>>    // cDbUpdateHandler object.
93306>>>    //
93306>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93306>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93306>>>    //
93306>>>    // If not done previously the phIntFilesTable will be created and filled with data
93306>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93306>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93306>>>    // of Filelist.cfg is made for backup purposes.
93306>>>    //
93306>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93306>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93306>>>    Procedure CheckIntFilesIntegrity
93308>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
93308>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
93308>>>        String sFileListZipFile sParam sProgram sFile 
93308>>>        Integer iDataPaths iCount
93308>>>        Handle hTable hIntFilesTable                    
93308>>>        UChar[] asFileListArray 
93309>>>        String[] asSavedIntFile
93310>>>        tDUFIntFile[] DUFIntFiles
93310>>>        tDUFIntFile[] DUFIntFiles
93311>>>        
93311>>>        Get pbCheckIntFiles to bCheckIntFiles
93312>>>        If (bCheckIntFiles = False) Begin
93314>>>            Procedure_Return
93315>>>        End
93315>>>>
93315>>>        
93315>>>        Move True to bResult        
93316>>>        
93316>>>        // Note: Include_Resource is a compiler directive!
93316>>>        // It will embedd the Filelist.cfg from the developers machine
93316>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
93316>>>        // need to change the next code line.         
93316>>>        //
93316>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93316>>>        // when we get here and then the compiler can't embedd it!        
93316>>>        // ToDo: Change compiler directives in Project properties (?)
93316>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93316>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93316>>>        
93316>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93317>>>        Get vFilePathExists sFileListName to bExists 
93318>>>        If (bExists = True) Begin
93320>>>            Get ParseFolderName sFileListName to sDataPath    
93321>>>            Get vFolderFormat sDataPath to sDataPath                              
93322>>>            Get ParseFileName sFileListName to sFile
93323>>>            // We need to create a backup copy of Filelist.cfg.
93323>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
93324>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
93325>>>            If (bOK = False) Begin
93327>>>                Move False to bResult
93328>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
93329>>>>
93329>>>            End
93329>>>>
93329>>>        End
93329>>>>
93329>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
93329>>>        Else Begin
93330>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
93331>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
93331>>>            If (bOK = False) Begin   
93333>>>                Move False to bResult
93334>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
93335>>>>
93335>>>            End
93335>>>>
93335>>>        End
93335>>>>
93335>>>        
93335>>>        Get phIntFilesTable to hIntFilesTable
93336>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
93339>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
93340>>>        // This will automatically create the phIntFilesTable if not exists.
93340>>>        // It is used to save data from the current set of .int files.
93340>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
93342>>>            Send AutoCreateIntFilesTable
93343>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93344>>>            If (bIntFilesTablesCheckDone = False) Begin
93346>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
93347>>>                Send Exit_Application of ghoApplication
93348>>>            End
93348>>>>
93348>>>        End                                                       
93348>>>>
93348>>>        
93348>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
93348>>>        // ToDo: Or should this always be attempted? Else the 
93348>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93349>>>        Move (IsDebuggerPresent()) to bDevelop
93350>>>        If (bDevelop = False) Begin
93352>>>            Get vFolderExists sDDSrcPath to bDevelop
93353>>>        End
93353>>>>
93353>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93354>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93355>>>        For iCount from 1 to iDataPaths
93361>>>>
93361>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93362>>>            Get vFolderFormat sDataPath to sDataPath 
93363>>>            Get vFolderExists sDataPath to bExists
93364>>>            If (bExists = True) Begin                  
93366>>>                Move 0 to hTable
93367>>>                Repeat
93367>>>>
93367>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93370>>>                    If (hTable <> 0) Begin
93372>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93375>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93376>>>                        If (bIsSQL = True) Begin     
93378>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93379>>>                            Move (sIntFileName + ".int")    to sIntFileName
93380>>>                            Get IsIntFileSaved sIntFileName to bSaved  
93381>>>                            Move True to bOK            
93382>>>                            
93382>>>                            // Save .int file to database if not done previously.
93382>>>                            // We only attempt to read .int files on a development machine.
93382>>>                            If (bDevelop = True) Begin
93384>>>                                If (bSaved = False) Begin
93386>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93387>>>                                    If (bOK = False) Begin
93389>>>                                        Move False to bResult    
93390>>>                                    End
93390>>>>
93390>>>                                End         
93390>>>>
93390>>>                                If (bOK = True) Begin
93392>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93393>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
93395>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93396>>>                                        If (bOK = False) Begin
93398>>>                                            Move False to bResult
93399>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93400>>>>
93400>>>                                        End
93400>>>>
93400>>>                                    End
93400>>>>
93400>>>                                End
93400>>>>
93400>>>                            End
93400>>>>
93400>>>                            
93400>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
93401>>>                            If (bExists = False) Begin                           
93403>>>                                // If the .int file is missing on disk; create it from database.
93403>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
93404>>>                                If (bOK = False) Begin         
93406>>>                                    Move False to bResult
93407>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
93408>>>>
93408>>>                                End
93408>>>>
93408>>>                            End
93408>>>>
93408>>>                        End
93408>>>>
93408>>>                    End
93408>>>>
93408>>>                Until (hTable = 0)
93410>>>            End
93410>>>>
93410>>>        Loop       
93411>>>>
93411>>>        
93411>>>        // If an error occured we need to exit the application.
93411>>>        If (bResult = False) Begin  
93413>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
93414>>>            Send Exit_Application
93415>>>        End
93415>>>>
93415>>>        
93415>>>    End_Procedure               
93416>>>
93416>>>    // To update currently saved IntFile data to the database.
93416>>>    // Because it is much easier, we first delete all current records and
93416>>>    // then saves the changed .int file to the database.
93416>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93418>>>        Boolean bOK
93418>>>        
93418>>>        Move False to bOK
93419>>>
93419>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93420>>>        If (bOK = True) Begin
93422>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93423>>>        End
93423>>>>
93423>>>        
93423>>>        Function_Return bOK
93424>>>    End_Function
93425>>>    
93425>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93427>>>        Handle hTable
93427>>>        Boolean bOK
93427>>>        Integer iColumn iIndex   
93427>>>        String sFileName
93427>>>        
93427>>>        Move False to bOK
93428>>>        Get phIntFilesTable to hTable
93429>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93430>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93431>>>
93431>>>        Open hTable
93433>>>        Set_Field_Value hTable iColumn to sIntFileName
93436>>>        Vfind hTable iIndex GE
93438>>>        Get_Field_Value hTable iColumn to sFileName
93441>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93443>>>            Move True to bOK    
93444>>>        End
93444>>>>
93444>>>        Close hTable
93445>>>        
93445>>>        Function_Return bOK       
93446>>>    End_Function   
93447>>>    
93447>>>    // Checks that the passed .int file is the same as what is saved in the database.
93447>>>    // If not same, the return string array will contain the read .int file,
93447>>>    // else the returned array will be empty.
93447>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93449>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93453>>>        Boolean bIsSame
93453>>>        
93453>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
93454>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
93455>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93456>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93457>>>        
93457>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93458>>>        If (bIsSame = False) Begin
93460>>>            Move asIntFileOrg to asReturnIntFile    
93461>>>        End
93461>>>>
93461>>>        
93461>>>        Function_Return asReturnIntFile    
93462>>>    End_Function                                   
93463>>>    
93463>>>    // Takes a string array as parameter and returns a new
93463>>>    // string array without any empty rows and all rows trimmed.
93463>>>    // This is e.g. used by the HasIntFileChanged message to compare
93463>>>    // two .int file arrays. 
93463>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93465>>>        Integer iSize iCount iRow
93465>>>        String sVal        
93465>>>        String[] asRetValArray
93466>>>        
93466>>>        Move (SizeOfArray(asIntFile)) to iSize
93467>>>        If (iSize = 0) Begin
93469>>>            Function_Return asRetValArray
93470>>>        End                          
93470>>>>
93470>>>        Decrement iSize         
93471>>>        Move 0 to iRow
93472>>>        
93472>>>        For iCount from 0  to iSize
93478>>>>
93478>>>            Move asIntFile[iCount] to sVal
93479>>>            Move (Trim(sVal)) to sVal
93480>>>            If (sVal <> "") Begin
93482>>>                Move sVal to asRetValArray[iRow]
93483>>>                Increment iRow        
93484>>>            End
93484>>>>
93484>>>        Loop
93485>>>>
93485>>>        
93485>>>        Function_Return asRetValArray
93486>>>    End_Function
93487>>>    
93487>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93489>>>        Handle hTable
93489>>>        Boolean bOK bErr
93489>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93489>>>        Number iID
93489>>>        String sFileName
93489>>>        String[] asIntFile
93490>>>        
93490>>>        Move Err to bErr
93491>>>        Move False to Err
93492>>>        Move False to bOK
93493>>>        Get phIntFilesTable to hTable  
93494>>>        Move 1              to iIDCol
93495>>>        Move 2              to iFileCol
93496>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93497>>>        Move 1              to iIDIdx   // Main ID index.
93498>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93499>>>
93499>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93500>>>        Move (SizeOfArray(asIntFile)) to iSize
93501>>>        If (iSize = 0) Begin
93503>>>            Function_Return False
93504>>>        End
93504>>>>
93504>>>        Decrement iSize
93505>>>        Open hTable  
93507>>>                  
93507>>>        // Find the last used ID no:
93507>>>        Fill_Field hTable iIDCol with DF_HIGH
93509>>>        Vfind hTable iIDIdx LE
93511>>>        Get_Field_Value hTable iIDCol to iID 
93514>>>        // This only happens the very first time we save a record.
93514>>>        If (iID = 999999999999) Begin
93516>>>            Move 0 to iID
93517>>>        End
93517>>>>
93517>>>        Increment iID        
93518>>>        
93518>>>        Lock
93519>>>>
93519>>>            For iCount from 0 to iSize
93525>>>>
93525>>>                Clear hTable
93526>>>                Set_Field_Value hTable iIDCol   to iID     
93529>>>                Set_Field_Value hTable iFileCol to sIntFileName
93532>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
93535>>>                SaveRecord hTable
93536>>>                Increment iID
93537>>>            Loop
93538>>>>
93538>>>        Unlock
93539>>>>
93539>>>        Close hTable
93540>>>        
93540>>>        Move (not(Err)) to bOK
93541>>>        Move bErr to Err
93542>>>        
93542>>>        Function_Return bOK
93543>>>    End_Function
93544>>>    
93544>>>    // Deletes all records for the passed sIntFileName value,
93544>>>    // from the phIntFilesTable.
93544>>>    // Returns True if no errors occured.
93544>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
93546>>>        Handle hTable
93546>>>        Boolean bOK bErr bFound
93546>>>        Integer iFileCol iIndex
93546>>>        String sVal
93546>>>        String[] asIntFile
93547>>>        
93547>>>        Move Err to bErr
93548>>>        Move False to Err
93549>>>        Move False to bOK
93550>>>        Move 2              to iFileCol
93551>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93552>>>        Get phIntFilesTable to hTable  
93553>>>        Open hTable  
93555>>>                  
93555>>>        // Find the first record
93555>>>        Set_Field_Value hTable iFileCol to sIntFileName
93558>>>        Vfind hTable iIndex GE
93560>>>        Get_Field_Value hTable iFileCol to sVal
93563>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93564>>>        While (bFound = True)
93568>>>            Delete hTable
93569>>>            Vfind hTable iIndex GT
93571>>>            Get_Field_Value hTable iFileCol to sVal
93574>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93575>>>        Loop
93576>>>>
93576>>>        Unlock
93577>>>>
93577>>>        Close hTable
93578>>>        
93578>>>        Move (not(Err)) to bOK
93579>>>        Move bErr to Err
93580>>>        
93580>>>        Function_Return bOK
93581>>>    End_Function
93582>>>
93582>>>    // Returns all saved phIntFilesTable records for the passed 
93582>>>    // sIntFileName value as a string array.
93582>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
93584>>>        Handle hTable
93584>>>        Boolean bOK bErr bFound
93584>>>        Integer iFileCol iTextCol iIndex
93584>>>        String sVal sFileName
93584>>>        String[] asIntFile asEmptyArray
93586>>>        
93586>>>        Move Err to bErr
93587>>>        Move False to Err
93588>>>        Move False to bOK
93589>>>        Move 2              to iFileCol
93590>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93591>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93592>>>        Get phIntFilesTable to hTable  
93593>>>        Open hTable  
93595>>>
93595>>>        // Find the first record
93595>>>        Set_Field_Value hTable iFileCol to sIntFileName
93598>>>        Vfind hTable iIndex GE
93600>>>        Get_Field_Value hTable iFileCol to sFileName
93603>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93604>>>        While (bFound = True)
93608>>>            Get_Field_Value hTable iFileCol to sFileName
93611>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93612>>>            If (bFound = True) Begin
93614>>>                Get_Field_Value hTable iTextCol to sVal
93617>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
93618>>>            End
93618>>>>
93618>>>            Vfind hTable iIndex GT
93620>>>        Loop
93621>>>>
93621>>>        
93621>>>        Close hTable
93622>>>        Move (not(Err)) to bOK
93623>>>        If (bOK = False) Begin
93625>>>            Move asEmptyArray to asIntFile
93626>>>        End
93626>>>>
93626>>>        Move bErr to Err               
93627>>>        
93627>>>        Function_Return asIntFile
93628>>>    End_Function
93629>>>
93629>>>    // Reads the passed sIntFileName from disk and returns its value
93629>>>    // as a string array.
93629>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
93631>>>        String[] asIntFile       
93632>>>        String sFileName sLine
93632>>>        Integer iCh iSize iCount
93632>>>        
93632>>>        Get vFolderFormat sPath to sPath
93633>>>        If (not(sIntFileName contains ".")) Begin
93635>>>            Move (sIntFileName + ".int") to sIntFileName
93636>>>        End
93636>>>>
93636>>>        Move (sPath + sIntFileName) to sFileName
93637>>>        Get Seq_Open_input_Channel sFileName to iCh
93638>>>        If (iCh < 0) Begin
93640>>>            Function_Return asIntFile
93641>>>        End                                 
93641>>>>
93641>>>        
93641>>>        Repeat
93641>>>>
93641>>>            Readln channel iCh sLine
93643>>>            If (SeqEof = False) Begin
93645>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
93646>>>            End
93646>>>>
93646>>>        Until (SeqEof = True)
93648>>>        Send Seq_Close_Channel iCh    
93649>>>        
93649>>>        Function_Return asIntFile
93650>>>    End_Function
93651>>>    
93651>>>    // Reads the Filelist.cfg from memeory as a resource.
93651>>>    // The Filelist.cfg has been compiled into the program.
93651>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
93653>>>        Integer iCh iCount
93653>>>        Number nByteCount
93653>>>        String[] asFileListArray sEmptyArray
93655>>>        String sLine
93655>>>        UChar[] uCharData
93656>>>        
93656>>>        Move False to Err
93657>>>        Get Seq_New_Channel to iCh
93658>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93660>>>            Error DFERR_PROGRAM 'No channel available...'
93661>>>>
93661>>>            Function_Return sEmptyArray
93662>>>        End
93662>>>>
93662>>>
93662>>>        // First decide the size of the script
93662>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
93664>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
93666>>>        Close_Input channel iCh
93668>>>        Send Seq_Release_Channel iCh
93669>>>
93669>>>        Function_Return uCharData
93670>>>    End_Function    
93671>>>    
93671>>>    // Writes a copy of the workspace Filelist.cfg to disk.
93671>>>    // It does so by reading from a memory resource, as the file has
93671>>>    // been compiled into the program.
93671>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
93673>>>        Boolean bOK bErr
93673>>>        Integer iSize iCh
93673>>>        
93673>>>        Move Err to bErr
93674>>>        Move False to Err
93675>>>        Move False to bOK
93676>>>        Move (SizeOfArray(asFileListArray)) to iSize
93677>>>        If (iSize = 0) Begin
93679>>>            Function_Return False
93680>>>        End
93680>>>>
93680>>>
93680>>>        Get Seq_New_Channel to iCh
93681>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93683>>>            Error DFERR_PROGRAM 'No channel available...'
93684>>>>
93684>>>            Function_Return False
93685>>>        End                      
93685>>>>
93685>>>        
93685>>>        Direct_Output channel iCh sFileListName
93687>>>        Writeln channel iCh asFileListArray
93690>>>                
93690>>>        Close_Input channel iCh
93692>>>        Send Seq_Release_Channel iCh
93693>>>        Move (not(Err)) to bOK
93694>>>        Move bErr to Err
93695>>>        
93695>>>        Function_Return bOK
93696>>>    End_Function
93697>>>
93697>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
93697>>>    // It first deletes the .cch file (if any).
93697>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
93699>>>        Boolean bOK bFound bExists bErr
93699>>>        Integer iCh iSize iCount
93699>>>        String sFileName sCCHFileName sVal
93699>>>        String[] asIntFile
93700>>>        
93700>>>        Move Err to bErr   
93701>>>        Move False to Err
93702>>>        Move False to bOK
93703>>>
93703>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
93704>>>        Move (SizeOfArray(asIntFile)) to iSize
93705>>>        If (iSize = 0) Begin
93707>>>            Function_Return False        
93708>>>        End                      
93708>>>>
93708>>>        Decrement iSize
93709>>>        
93709>>>        Get Seq_New_Channel to iCh
93710>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93712>>>            Function_Return False
93713>>>        End   
93713>>>>
93713>>>        
93713>>>        // Before we start to actually create the new .int file, make sure we delete
93713>>>        // the .cch file first.                                     
93713>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
93714>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
93715>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
93716>>>        If (bExists = True) Begin
93718>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
93719>>>            If (bOK = False) Begin
93721>>>                Function_Return False
93722>>>            End
93722>>>>
93722>>>        End
93722>>>>
93722>>>        
93722>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
93724>>>        For iCount from 0 to iSize
93730>>>>
93730>>>            Writeln channel iCh asIntFile[iCount]
93733>>>        Loop
93734>>>>
93734>>>        
93734>>>        Close_Input channel iCh
93736>>>        Send Seq_Release_Channel iCh
93737>>>        Move (not(Err)) to bOK
93738>>>        Move bErr to Err
93739>>>        
93739>>>        Function_Return bOK
93740>>>    End_Function   
93741>>>              
93741>>>    // Automatically writes .int files to disk that is missing.
93741>>>    // We only need to make this test this once, but because the message is called
93741>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
93741>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
93741>>>    Procedure AutoCreateIntFilesTable 
93743>>>        Integer hTable 
93743>>>        Boolean bIntFilesTablesCheckDone bTableExists
93743>>>        String sInfoTxt 
93743>>>        
93743>>>        Get phIntFilesTable to hTable  
93744>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93745>>>        If (bIntFilesTablesCheckDone = True) Begin
93747>>>            Procedure_Return
93748>>>        End
93748>>>>
93748>>>
93748>>>        If (hTable < 1) Begin
93750>>>            Set Private.pbIntFilesTablesCheckDone to False
93751>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93752>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
93753>>>>
93753>>>            Procedure_Return
93754>>>        End
93754>>>>
93754>>>
93754>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
93755>>>        If (bTableExists = True) Begin
93757>>>            Set Private.pbIntFilesTablesCheckDone to True
93758>>>            Procedure_Return
93759>>>        End
93759>>>>
93759>>>
93759>>>        Send CreateIntFilesTable hTable
93760>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93761>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93762>>>    End_Function
93763>>>                
93763>>>    Procedure CreateIntFilesTable Handle hTable
93765>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
93765>>>        Boolean bTableExists bOK bUseConnectionID bExists
93765>>>        tAPIColumn[] APIColumn
93765>>>        tAPIColumn[] APIColumn
93766>>>
93766>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93767>>>        If (bTableExists = True) Begin
93769>>>            Procedure_Return
93770>>>        End
93770>>>>
93770>>>
93770>>>        Move False to Err
93771>>>        Get psDriverID to sDriverID
93772>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93773>>>
93773>>>        Move CS_IntFilesTableRootName to sTableName
93774>>>
93774>>>        Move 1                  to APIColumn[0].iFieldNumber
93775>>>        Move "ID"               to APIColumn[0].sFieldName
93776>>>        Move DF_BCD             to APIColumn[0].iType
93777>>>        Move False              to APIColumn[0].bIsSQLType
93778>>>        Move 12                 to APIColumn[0].iLength
93779>>>        Move 0                  to APIColumn[0].iPrecision
93780>>>
93780>>>        Move 2                  to APIColumn[1].iFieldNumber
93781>>>        Move "IntFileName"      to APIColumn[1].sFieldName
93782>>>        Move DF_ASCII           to APIColumn[1].iType
93783>>>        Move False              to APIColumn[1].bIsSQLType
93784>>>        Move 50                 to APIColumn[1].iLength
93785>>>        Move 0                  to APIColumn[1].iPrecision
93786>>>
93786>>>        Move 3                  to APIColumn[2].iFieldNumber
93787>>>        Move "IntLineText"      to APIColumn[2].sFieldName
93788>>>        Move DF_ASCII           to APIColumn[2].iType
93789>>>        Move False              to APIColumn[2].bIsSQLType
93790>>>        Move 100                to APIColumn[2].iLength
93791>>>        Move 0                  to APIColumn[2].iPrecision
93792>>>
93792>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93793>>>        
93793>>>        If (bOK = True and Err = False) Begin
93795>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93796>>>        End
93796>>>>
93796>>>        Else Begin
93797>>>            Set Private.pbIntFilesTablesCheckDone to False
93798>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93799>>>            Error DFERR_PROGRAM sInfoTxt
93800>>>>
93800>>>            Procedure_Return
93801>>>        End
93801>>>>
93801>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93802>>>        
93802>>>        Open hTable
93804>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
93805>>>        If (bOK = True) Begin
93807>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
93808>>>        End
93808>>>>
93808>>>        If (bOK = False) Begin
93810>>>            Set Private.pbIntFilesTablesCheckDone to False
93811>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93812>>>            Error DFERR_PROGRAM sInfoTxt
93813>>>>
93813>>>            Procedure_Return
93814>>>        End                    
93814>>>>
93814>>>        
93814>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
93814>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93815>>>        Get vFolderFormat sDataPath to sDataPath
93816>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
93817>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
93818>>>        If (bExists = True) Begin
93820>>>            Move CS_IntFilesTableRootName to sTableName
93821>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
93822>>>            If (bExists = True) Begin
93824>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
93825>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
93826>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
93827>>>            End
93827>>>>
93827>>>        End
93827>>>>
93827>>>        
93827>>>        Set Private.pbIntFilesTablesCheckDone to True
93828>>>    End_Procedure
93829>>>
93829>>>    Procedure CheckAutoCreateDbVersionTable
93831>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
93831>>>        Integer iDbVersionFileNumber
93831>>>
93831>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
93832>>>        If (bDbVersionCheckDone = True) Begin
93834>>>            Procedure_Return
93835>>>        End
93835>>>>
93835>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
93836>>>        If (bUseCustomDbVersion = True) Begin
93838>>>            Procedure_Return
93839>>>        End
93839>>>>
93839>>>
93839>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
93840>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
93842>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93843>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
93844>>>>
93844>>>            Send Exit_Application
93845>>>        End
93845>>>>
93845>>>
93845>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
93846>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93847>>>        If (bTableExists = True) Begin
93849>>>            Set Private.pbDbVersionCheckDone to True
93850>>>            Procedure_Return
93851>>>        End
93851>>>>
93851>>>
93851>>>        Send CreateDbVersionTable iDbVersionFileNumber
93852>>>
93852>>>        // We only need to these DbVersion checks once, but because this message is called
93852>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
93852>>>        // we use a property to only run these tests once.
93852>>>        Set Private.pbDbVersionCheckDone to True
93853>>>    End_Procedure
93854>>>
93854>>>    Procedure CreateDbVersionTable Handle hTable
93856>>>        String sTableName sColumnName sInfoTxt sDriverID 
93856>>>        Boolean bTableExists bOK bUseConnectionID
93856>>>        tAPIColumn[] APIColumn
93856>>>        tAPIColumn[] APIColumn
93857>>>
93857>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93858>>>        If (bTableExists = True) Begin
93860>>>            Procedure_Return
93861>>>        End
93861>>>>
93861>>>
93861>>>        Get psDriverID to sDriverID
93862>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93863>>>
93863>>>        Move "DbVersion"        to sTableName
93864>>>        Move 1                  to APIColumn[0].iFieldNumber
93865>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
93866>>>        Move DF_BCD             to APIColumn[0].iType
93867>>>        Move False              to APIColumn[0].bIsSQLType
93868>>>        Move 4                  to APIColumn[0].iLength
93869>>>        Move 2                  to APIColumn[0].iPrecision
93870>>>
93870>>>        Move False to Err                                
93871>>>        
93871>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
93871>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
93871>>>        Set psDriverID to DATAFLEX_ID
93872>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93873>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93874>>>        Set psDriverID to sDriverID
93875>>>        
93875>>>        If (bOK = True and Err = False) Begin
93877>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
93877>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93878>>>        End
93878>>>>
93878>>>        Else Begin
93879>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
93880>>>        End
93880>>>>
93880>>>
93880>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93881>>>    End_Procedure
93882>>>
93882>>>    Procedure Set pbVerboseState Boolean bVerboseState
93884>>>        Handle ho
93884>>>        Get phoLogFile to ho
93885>>>        Set pbVerboseState of ho to bVerboseState
93886>>>    End_Procedure
93887>>>
93887>>>    Function pbVerboseState Returns Boolean
93889>>>        Boolean bVerboseState
93889>>>        Handle ho
93889>>>        Get phoLogFile to ho
93890>>>        Get pbVerboseState of ho to bVerboseState
93891>>>        Function_Return bVerboseState
93892>>>    End_Function
93893>>>
93893>>>    // Callback functionality used when e.g. calling driver functions directly.
93893>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
93893>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
93895>>>        Integer iPerc
93895>>>        Number nReady nTotal nVersion
93895>>>        Boolean bVerboseState
93895>>>        Handle hoLogFile
93895>>>
93895>>>        Get pbVerboseState to bVerboseState
93896>>>        Get pnCurrentVersionUpdate to nVersion
93897>>>        Get phoLogFile     to hoLogFile
93898>>>        Send DoAdvance of ghoProgressBar
93899>>>
93899>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
93901>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93902>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93903>>>        End
93903>>>>
93903>>>        If (sCallback_Text contains "Creating index") Begin
93905>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
93906>>>        End
93906>>>>
93906>>>
93906>>>        Case Begin
93906>>>            Case (iCallback_Type = DF_Message_Text)
93908>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93909>>>                Set Action_Text  of ghoStatusPanel to ""
93910>>>                If (bVerboseState = True) Begin
93912>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93913>>>                End
93913>>>>
93913>>>                Case Break
93914>>>            Case (iCallback_Type = DF_Message_Heading_1)
93917>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93918>>>                If (bVerboseState = True) Begin
93920>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93921>>>                End
93921>>>>
93921>>>                Case Break
93922>>>            Case (iCallback_Type = DF_Message_Heading_2)
93925>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93926>>>                Set Action_Text  of ghoStatusPanel to ""
93927>>>                If (bVerboseState = True) Begin
93929>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93930>>>                End
93930>>>>
93930>>>                Case Break
93931>>>            Case (iCallback_Type = DF_Message_Heading_3)
93934>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93935>>>                Set Action_Text  of ghoStatusPanel to ""
93936>>>                If (bVerboseState = True) Begin
93938>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93939>>>                End
93939>>>>
93939>>>                Case Break
93940>>>            Case (iCallback_Type = DF_Message_Heading_4)
93943>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93944>>>                Set Action_Text  of ghoStatusPanel to ""
93945>>>                If (bVerboseState = True) Begin
93947>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93948>>>                End
93948>>>>
93948>>>                Case Break
93949>>>            Case (iCallback_Type = DF_Message_Heading_5)
93952>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93953>>>                Set Action_Text  of ghoStatusPanel to ""
93954>>>                If (bVerboseState = True) Begin
93956>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93957>>>                End
93957>>>>
93957>>>                Case Break
93958>>>            Case (iCallback_Type = DF_Message_Warning)
93961>>>                If (bVerboseState = True) Begin
93963>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93964>>>                End
93964>>>>
93964>>>                Case Break
93965>>>            Case (iCallback_Type = DF_Message_Progress_Title)
93968>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93969>>>                Set Action_Text  of ghoStatusPanel to ""
93970>>>                If (bVerboseState = True) Begin
93972>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93973>>>                End
93973>>>>
93973>>>                Case Break
93974>>>            Case (iCallback_Type = DF_Message_Progress_Value)
93977>>>                //*** Interpret numbers
93977>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
93978>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
93979>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
93980>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
93981>>>                Set piPosition of ghoProgressBar to iPerc
93982>>>                Case Break
93983>>>            Case Else
93983>>>                Set Message_Text to ""
93984>>>                Set Action_Text  to ""
93985>>>        Case End
93985>>>
93985>>>        Send ProcessEvents of ghoStatusPanel
93986>>>        Function_Return False
93987>>>    End_Function
93988>>>
93988>>>    // This was made to be a procedure/function pair so we
93988>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
93988>>>
93988>>>    Procedure Set piDbType Integer iDbType
93990>>>        If (ghoSQLConnectionHandler = 0) Begin
93992>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93993>>>>
93993>>>            Procedure_Return
93994>>>        End
93994>>>>
93994>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
93995>>>    End_Procedure
93996>>>
93996>>>    Function piDbType Returns Integer
93998>>>        Integer iDbType
93998>>>        If (ghoSQLConnectionHandler = 0) Begin
94000>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94001>>>>
94001>>>            Function_Return ""
94002>>>        End
94002>>>>
94002>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94003>>>        Function_Return iDbType
94004>>>    End_Function
94005>>>
94005>>>    Procedure Set psDriverID String sDriverID
94007>>>        If (ghoSQLConnectionHandler = 0) Begin
94009>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94010>>>>
94010>>>            Procedure_Return
94011>>>        End
94011>>>>
94011>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94012>>>    End_Procedure
94013>>>
94013>>>    Function psDriverID Returns String
94015>>>        String sValue
94015>>>        If (ghoSQLConnectionHandler = 0) Begin
94017>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94018>>>>
94018>>>            Function_Return ""
94019>>>        End
94019>>>>
94019>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94020>>>        Function_Return sValue
94021>>>    End_Function
94022>>>
94022>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94024>>>        If (ghoSQLConnectionHandler = 0) Begin
94026>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94027>>>>
94027>>>            Procedure_Return
94028>>>        End
94028>>>>
94028>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94029>>>    End_Procedure
94030>>>
94030>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94032>>>        Integer iRetval
94032>>>        If (ghoSQLConnectionHandler = 0) Begin
94034>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94035>>>>
94035>>>            Function_Return 2
94036>>>        End
94036>>>>
94036>>>
94036>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94037>>>        Function_Return iRetval
94038>>>    End_Function
94039>>>
94039>>>    Procedure Set psConnectionID String sValue
94041>>>        If (ghoSQLConnectionHandler = 0) Begin
94043>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94044>>>>
94044>>>            Procedure_Return
94045>>>        End
94045>>>>
94045>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94046>>>    End_Procedure
94047>>>
94047>>>    Function psConnectionID Returns String
94049>>>        String sValue
94049>>>        If (ghoSQLConnectionHandler = 0) Begin
94051>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94052>>>>
94052>>>            Function_Return ""
94053>>>        End
94053>>>>
94053>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94054>>>
94054>>>        Function_Return sValue
94055>>>    End_Function
94056>>>
94056>>>    // These "properties" are settings of the cCLIHandler class, but are being
94056>>>    // relayed to the ghoSQLConnectionHandler object
94056>>>    // simply by changing one of its parameters.
94056>>>    Procedure Set psServer String sValue
94058>>>        If (ghoSQLConnectionHandler = 0) Begin
94060>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94061>>>>
94061>>>            Procedure_Return
94062>>>        End
94062>>>>
94062>>>        Set psServer of ghoSQLConnectionHandler to sValue
94063>>>    End_Procedure
94064>>>
94064>>>    Function psServer Returns String
94066>>>        String sValue
94066>>>        If (ghoSQLConnectionHandler = 0) Begin
94068>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94069>>>>
94069>>>            Function_Return ""
94070>>>        End
94070>>>>
94070>>>        Get psServer of ghoSQLConnectionHandler to sValue
94071>>>
94071>>>        Function_Return sValue
94072>>>    End_Function
94073>>>
94073>>>    Procedure Set psDatabase String sValue
94075>>>        If (ghoSQLConnectionHandler = 0) Begin
94077>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94078>>>>
94078>>>            Procedure_Return
94079>>>        End
94079>>>>
94079>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94080>>>    End_Procedure
94081>>>
94081>>>    Function psDatabase Returns String
94083>>>        String sValue
94083>>>        If (ghoSQLConnectionHandler = 0) Begin
94085>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94086>>>>
94086>>>            Function_Return ""
94087>>>        End
94087>>>>
94087>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94088>>>
94088>>>        Function_Return sValue
94089>>>    End_Function
94090>>>
94090>>>    Procedure Set psUserID String sValue
94092>>>        If (ghoSQLConnectionHandler = 0) Begin
94094>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94095>>>>
94095>>>            Procedure_Return
94096>>>        End
94096>>>>
94096>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94097>>>    End_Procedure
94098>>>
94098>>>    Function psUserID Returns String
94100>>>        String sValue
94100>>>        If (ghoSQLConnectionHandler = 0) Begin
94102>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94103>>>>
94103>>>            Function_Return ""
94104>>>        End
94104>>>>
94104>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94105>>>
94105>>>        Function_Return sValue
94106>>>    End_Function
94107>>>
94107>>>    Procedure Set psPassword String sValue
94109>>>        If (ghoSQLConnectionHandler = 0) Begin
94111>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94112>>>>
94112>>>            Procedure_Return
94113>>>        End
94113>>>>
94113>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94114>>>    End_Procedure
94115>>>
94115>>>    Function psPassword Returns String
94117>>>        String sValue
94117>>>        If (ghoSQLConnectionHandler = 0) Begin
94119>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94120>>>>
94120>>>            Function_Return ""
94121>>>        End
94121>>>>
94121>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94122>>>
94122>>>        Function_Return sValue
94123>>>    End_Function
94124>>>
94124>>>    Procedure Set pbTrusted Boolean bValue
94126>>>        If (ghoSQLConnectionHandler = 0) Begin
94128>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94129>>>>
94129>>>            Procedure_Return
94130>>>        End
94130>>>>
94130>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94131>>>    End_Procedure
94132>>>
94132>>>    Function pbTrusted Returns Boolean
94134>>>        Boolean bValue
94134>>>        If (ghoSQLConnectionHandler = 0) Begin
94136>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94137>>>>
94137>>>            Function_Return False
94138>>>        End
94138>>>>
94138>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94139>>>
94139>>>        Function_Return bValue
94140>>>    End_Function
94141>>>
94141>>>    Procedure Set psConnectionString String sValue
94143>>>        If (ghoSQLConnectionHandler = 0) Begin
94145>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94146>>>>
94146>>>            Procedure_Return
94147>>>        End
94147>>>>
94147>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94148>>>    End_Procedure
94149>>>
94149>>>    Function psConnectionString Returns String
94151>>>        String sValue
94151>>>        If (ghoSQLConnectionHandler = 0) Begin
94153>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94154>>>>
94154>>>            Function_Return ""
94155>>>        End
94155>>>>
94155>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94156>>>
94156>>>        Function_Return sValue
94157>>>    End_Function
94158>>>
94158>>>    Function piConnectionOptions Returns Integer
94160>>>        Integer iValue
94160>>>        If (ghoSQLConnectionHandler = 0) Begin
94162>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94163>>>>
94163>>>            Function_Return 0
94164>>>        End
94164>>>>
94164>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94165>>>
94165>>>        Function_Return iValue
94166>>>    End_Function
94167>>>
94167>>>
94167>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94169>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94170>>>    End_Procedure
94171>>>
94171>>>    Function pbCheckDataFlexUserCount Returns Boolean
94173>>>        Boolean bState
94173>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94174>>>        Function_Return bState
94175>>>    End_Function
94176>>>
94176>>>    Procedure Set psLogTextFile String sValue
94178>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94179>>>    End_Procedure
94180>>>
94180>>>    Function psLogTextFile Returns String
94182>>>        String sValue
94182>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94183>>>        Function_Return sValue
94184>>>    End_Function
94185>>>
94185>>>    Procedure Set psEditorProgram String sValue
94187>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94188>>>    End_Procedure
94189>>>
94189>>>    Function psEditorProgram Returns String
94191>>>        String sValue
94191>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94192>>>        Function_Return sValue
94193>>>    End_Function
94194>>>
94194>>>    Procedure Set pbUseDataTableLog Boolean bState
94196>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94197>>>    End_Procedure
94198>>>
94198>>>    Function pbUseDataTableLog Returns Boolean
94200>>>        Boolean bState
94200>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94201>>>        Function_Return bState
94202>>>    End_Function
94203>>>
94203>>>    Procedure Set pbQuickWrite Boolean bState
94205>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94206>>>    End_Procedure
94207>>>
94207>>>    Function pbQuickWrite Returns Boolean
94209>>>        Boolean bState
94209>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94210>>>        Function_Return bState
94211>>>    End_Function
94212>>>
94212>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94214>>>        Boolean bUpdateVersionObjectError bVerboseState
94214>>>        Integer iSize iCount
94214>>>        Number nVersion
94214>>>        String[] aSQLQueryMessages
94215>>>
94215>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94216>>>        Set Private.pbDatabaseWasUpdated to bState
94217>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94217>>>        // to the log that it was OK.
94217>>>        If (bUpdateVersionObjectError = False) Begin
94219>>>            Get pnCurrentVersionUpdate to nVersion
94220>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94221>>>        End
94221>>>>
94221>>>
94221>>>        Get pbVerboseState to bVerboseState
94222>>>        If (bVerboseState = True) Begin
94224>>>            Get paSQLQueryMessages to aSQLQueryMessages
94225>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94226>>>            Decrement iSize
94227>>>            For iCount from 0 to iSize
94233>>>>
94233>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94234>>>            Loop
94235>>>>
94235>>>        End
94235>>>>
94235>>>
94235>>>    End_Procedure 
94236>>>    
94236>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94238>>>        Set Private.piDbVersionFileNumber to iFileNumber
94239>>>    End_Procedure                                         
94240>>>    
94240>>>    Function piDbVersionFileNumber Returns Integer
94242>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94243>>>    End_Function
94244>>>
94244>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94246>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94247>>>    End_Procedure                                         
94248>>>    
94248>>>    Function piDbVersionFieldNumber Returns Integer
94250>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94251>>>    End_Function
94252>>>
94252>>>    Function pbDatabaseWasUpdated Returns Boolean
94254>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94255>>>    End_Function
94256>>>    
94256>>>    //
94256>>>    Procedure ReinitializeFramework  
94258>>>        tDbVersionInfo[] aDbVersionInfoArray
94258>>>        tDbVersionInfo[] aDbVersionInfoArray
94259>>>        Handle hoDbVersionObject
94259>>>        Integer iSize iCount
94259>>>        
94259>>>        Set Private.pbDatabaseUpdateStarted to False
94260>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94261>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94262>>>        Decrement iSize
94263>>>        
94263>>>        For iCount from 0 to iSize
94269>>>>
94269>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94270>>>            Send ProcessUpdate                  of hoDbVersionObject False
94271>>>        Loop
94272>>>>
94272>>>        Send Cleanup
94273>>>    End_Procedure
94274>>>    
94274>>>    // This event is triggered by the cDbUpdateVersion child class when
94274>>>    // a database change is to be started, and is considered private.
94274>>>    // It is only executed once for the first cDbUpateVersion object!
94274>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94276>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94276>>>        Integer iRetval iDataFlexUsers iUserCount
94276>>>        Handle hoUserCountSystem
94276>>>        tUserCount UserCount
94276>>>        tUserCount UserCount
94276>>>        DateTime dtUpdateStarted
94276>>>        tSQLConnection SQLConnection
94276>>>        tSQLConnection SQLConnection
94276>>>
94276>>>        // *Important:* If we already started the update; we do no further checking.
94276>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94277>>>        If (bDatabaseUpdateStarted = True) Begin
94279>>>            Procedure_Return
94280>>>        End
94280>>>>
94280>>>
94280>>>        // If not silent mode; Ask user if OK to start database update.
94280>>>        If (pbSilentMode(Self) = False) Begin
94282>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94283>>>            If (iRetval <> MBR_Yes) Begin
94285>>>                Send Exit_Application
94286>>>            End
94286>>>>
94286>>>        End
94286>>>>
94286>>>        
94286>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94287>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94288>>>        Send Start_StatusPanel      of ghoStatusPanel
94289>>>
94289>>>        // This will save the status of all open tables including Master/Alias settings,
94289>>>        // so we can restore them later;
94289>>>        Send SaveOpenTables
94290>>>
94290>>>        Move 0 to iDataFlexUsers
94291>>>        // Make various tests to check that the database is not in use.
94291>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94292>>>        // We also use our own user counting mechanism to guard against the
94292>>>        // database isn't opened already as we need exclusive access to the tables.:
94292>>>        Get phoUserCountSystem to hoUserCountSystem
94293>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94294>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94295>>>
94295>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94296>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94296>>>        If (bCheckDataFlexUserCount = True) Begin
94298>>>            Get_Current_User_Count to iDataFlexUsers
94299>>>            // For some reason DataFlex - in some cases - might think that 2 users
94299>>>            // are in use while debugging from the Studio.
94299>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94301>>>                Decrement iDataFlexUsers
94302>>>            End
94302>>>>
94302>>>        End 
94302>>>>
94302>>>        Else Begin
94303>>>            Move 1 to iDataFlexUsers 
94304>>>            Move 1 to iUserCount
94305>>>            Move False to bInUse
94306>>>        End
94306>>>>
94306>>>
94306>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94308>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94309>>>            If (iRetval <> MBR_Yes) Begin
94311>>>                Send Exit_Application
94312>>>            End
94312>>>>
94312>>>        End
94312>>>>
94312>>>
94312>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94314>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94315>>>            Send Exit_Application
94316>>>        End
94316>>>>
94316>>>
94316>>>        // This will put a look on the DbUpdateLock.ucf file.
94316>>>        // It is released when the update process is finished
94316>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94317>>>
94317>>>        Move (CurrentDateTime()) to dtUpdateStarted
94318>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94319>>>        Set Private.pbDatabaseUpdateStarted to True
94320>>>
94320>>>        // We need to close all tables before starting to make changes.
94320>>>        Close DF_ALL DF_PERMANENT
94321>>>
94321>>>        // If these properties has not exclicitly been set in the object, set them
94321>>>        // to settings from the SQLConnections.ini file;
94321>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94322>>>        If (psSchema(Self) = "") Begin
94324>>>            Set psSchema            to SQLConnection.sSchema
94325>>>        End
94325>>>>
94325>>>        If (psBaseTableSpace(Self) = "") Begin
94327>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94328>>>        End
94328>>>>
94328>>>        If (psLongTableSpace(Self) = "") Begin
94330>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94331>>>        End
94331>>>>
94331>>>        If (psIndexTableSpace(Self) = "") Begin
94333>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94334>>>        End
94334>>>>
94334>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94336>>>            Procedure_Return
94337>>>        End
94337>>>>
94337>>>
94337>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94338>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94340>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94341>>>            Send Stop_StatusPanel of ghoStatusPanel
94342>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94342>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94343>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94343>>>            Send Exit_Application
94344>>>        End
94344>>>>
94344>>>    End_Procedure
94345>>>
94345>>>    // *** Hook message for pre-processing ***
94345>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94345>>>    // Aka, when another table than the standard "DbVersion" is used.
94345>>>    Procedure OnCreateCustomDbVersionTable
94347>>>    End_Procedure
94348>>>    
94348>>>    // *** Hook message for pre-processing ***
94348>>>    // The programmer can use this event for putting code that
94348>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94348>>>    // child objects are executed.
94348>>>    Procedure OnPreUpdate
94350>>>    End_Procedure
94351>>>
94351>>>    // *** Hook message for post-processing ***
94351>>>    // The programmer should use this event for putting code that
94351>>>    // needs to be executed _after_ all database updates have finished.
94351>>>    Procedure OnPostUpdate
94353>>>    End_Procedure
94354>>>
94354>>>    // *** Hook message for custom DbVersion record find ***
94354>>>    // The programmer can use this event for putting code that
94354>>>    // needs to be executed to find a *custom* DbVersion table record.
94354>>>    // By default the DbVersion table is used but this can be
94354>>>    // customized by adding this line to the code;
94354>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94354>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94354>>>    //       to save the current database version to. Only if you use your own
94354>>>    //       table _and_ it is not a system table (contains only one record).
94354>>>    Procedure OnFindVersionRecord
94356>>>        // Open MyTable
94356>>>        // Move xx to MyTable.Field1
94356>>>        // Move yy to MyTable.Field2
94356>>>        // Find le MyTable by Index.x
94356>>>    End_Procedure
94357>>>
94357>>>    // Hook event for writing header error text (pre-update) to
94357>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94357>>>    // Don't forget to Open the table first (!) as all
94357>>>    // tables have been closed at this stage.
94357>>>    // The start date & time is passed.
94357>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94359>>>    End_Procedure
94360>>>
94360>>>    // Hook event to log errors to a database table.
94360>>>    // Only called if the pbUseDataTableLog = True.
94360>>>    // Don't forget to Open the table first (!) as all
94360>>>    // tables have been closed at this stage.
94360>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94360>>>    // will contain just one row, as it is called for each error
94360>>>    // that occurred. Else it is called once at the end after all updates
94360>>>    // have run and contains all errors.
94360>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94362>>>    End_Procedure
94363>>>
94363>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94363>>>    Procedure Cleanup
94365>>>        Boolean bDatabaseWasUpdated bError
94365>>>
94365>>>        Send CheckAutoCreateDbVersionTable
94366>>>        Send RestoreOpenTables
94367>>>
94367>>>        // The function library have two purposes; one is to use it in the
94367>>>        // Database Update Framework, but it can also be used on its own.
94367>>>        // If that is the case it has its own error handling system, which
94367>>>        // we temporarily disbled when running updates because we have
94367>>>        // error handling/logging here too... We now restore its setting.
94367>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94369>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94370>>>        End
94370>>>>
94370>>>        Set pbHandleQueryErrors to True
94371>>>
94371>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94372>>>        Get pbDbUpdateErrorHasOccured to bError
94373>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94375>>>
94375>>>            // We should always create the log as it also contains info about
94375>>>            // the update being successful.
94375>>>            Send WriteErrorLog of (phoLogFile(Self))
94376>>>
94376>>>            // This is a programmer's hook message:
94376>>>            Send OnPostUpdate
94377>>>
94377>>>            Send Stop_StatusPanel of ghoStatusPanel
94378>>>
94378>>>            If (pbSilentMode(Self) = False) Begin
94380>>>                If (bError = True) Begin
94382>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94384>>>                        Send ShowErrorLog of (phoLogFile(Self))
94385>>>                    End
94385>>>>
94385>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94386>>>                    Send Exit_Application
94387>>>                End
94387>>>>
94387>>>                Else Begin
94388>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94390>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94391>>>                    End
94391>>>>
94391>>>                    Else Begin
94392>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94393>>>                    End
94393>>>>
94393>>>
94393>>>                End
94393>>>>
94393>>>            End
94393>>>>
94393>>>        End
94393>>>>
94393>>>
94393>>>        // Restore the standard error handler:
94393>>>        Get piOrgErrorHandlerID to Error_Object_Id
94394>>>    End_Procedure
94395>>>
94395>>>    // We do this _before_ we close the database to make changes, and save
94395>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94395>>>    // we reopen the database.
94395>>>    Procedure SaveOpenTables
94397>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94397>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94398>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94399>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94400>>>    End_Procedure
94401>>>
94401>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94401>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94401>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94403>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94403>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94404>>>        Integer hTable iMasterAliasType iSize
94404>>>        Boolean bOpen
94404>>>
94404>>>        Move 0 to hTable
94405>>>        Repeat
94405>>>>
94405>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94408>>>            If (hTable <> 0) Begin
94410>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94413>>>                If (bOpen = True) Begin
94415>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94418>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94419>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94420>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94421>>>                End
94421>>>>
94421>>>            End
94421>>>>
94421>>>        Until (hTable = 0)
94423>>>
94423>>>        Function_Return aDbUpdateHandlerMasterAlias
94424>>>    End_Function
94425>>>
94425>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94425>>>    // Takes one parameter:
94425>>>    //   A struct array with all master & alias
94425>>>    Procedure RestoreOpenTables
94427>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94427>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94428>>>        Integer hTable iFileAlias iSize iCount
94428>>>        Boolean bOpen
94428>>>        String sRootName
94428>>>
94428>>>        Move 0 to hTable
94429>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94430>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94431>>>        Decrement iSize
94432>>>        For iCount from 0 to iSize
94438>>>>
94438>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94439>>>            // We also need to check that the table hasn't been removed...
94439>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94442>>>            If (hTable <> 0 and sRootName <> "") Begin
94444>>>                Open hTable
94446>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94449>>>                If (bOpen = True) Begin
94451>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94452>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94454>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94457>>>                    End
94457>>>>
94457>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94460>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94463>>>                    End
94463>>>>
94463>>>                End
94463>>>>
94463>>>            End
94463>>>>
94463>>>        Loop
94464>>>>
94464>>>    End_Procedure
94465>>>
94465>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94465>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94465>>>    Procedure CheckForDuplicates Number nVersion
94467>>>        tDbVersionInfo[] DbVersionInfoArray
94467>>>        tDbVersionInfo[] DbVersionInfoArray
94468>>>        Integer iCount iSize iHits iDuplicateIndex
94468>>>        Number nCompare
94468>>>        Handle hObject1 hObject2
94468>>>        String sObjectName1 sObjectName2
94468>>>        Boolean bObjectOrderError
94468>>>
94468>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94469>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94470>>>        Decrement iSize
94471>>>        Move 0 to iHits
94472>>>        Move 0 to nCompare
94473>>>        Move False to bObjectOrderError
94474>>>        For iCount from 0 to iSize
94480>>>>
94480>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94482>>>                Increment iHits
94483>>>                If (iHits > 1) Begin
94485>>>                    Move iCount to iDuplicateIndex
94486>>>                    If (nCompare <> 0) Begin
94488>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94489>>>                    End
94489>>>>
94489>>>                End
94489>>>>
94489>>>            End
94489>>>>
94489>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94490>>>        Loop
94491>>>>
94491>>>        If (iHits > 1) Begin
94493>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94494>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94495>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94496>>>            Move (Name(hObject1)) to sObjectName1
94497>>>            Move (Name(hObject2)) to sObjectName2
94498>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94499>>>>
94499>>>            Send Exit_Application
94500>>>        End
94500>>>>
94500>>>        Else If (bObjectOrderError = True) Begin
94503>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94504>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94505>>>>
94505>>>            Send Exit_Application
94506>>>        End
94506>>>>
94506>>>    End_Procedure
94507>>>
94507>>>    // We take care of all errors in the Error_Report below and
94507>>>    // collect them all to an array property. So just ignore any
94507>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94507>>>    // in some other package.
94507>>>    Procedure Ignore_Error Integer iError
94509>>>    End_Procedure
94510>>>
94510>>>    Procedure Trap_Error Integer iError
94512>>>    End_Procedure
94513>>>
94513>>>    // Build complete error description from Flexerrs and user error message.
94513>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94515>>>        String Full_Error_Text
94515>>>        
94515>>>        Move (Trim(ErrMsg)) to ErrMsg
94516>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94517>>>        
94517>>>        If (ErrMsg <> "") Begin
94519>>>            
94519>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94521>>>                // Make sure last character of error text is a separating symbol.
94521>>>                // if not, add a "." So we have format of "error-text. error-detail"
94521>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
94524>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
94525>>>            End
94525>>>>
94525>>>            Else ;                Move ErrMsg to Full_Error_Text
94527>>>            
94527>>>        End
94527>>>>
94527>>>        
94527>>>        Function_Return Full_Error_Text
94528>>>    End_Function
94529>>>
94529>>>    // While we update the database we collect all errors in
94529>>>    // the struct array paDbUpdateErrorArray.
94529>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94531>>>        Number nVersion
94531>>>        Handle hoLogFile 
94531>>>//        String sErrExtraText
94531>>>        
94531>>>        If (Private.pbProcessingError(Self)) Begin
94533>>>            Procedure_Return
94534>>>        End
94534>>>>
94534>>>
94534>>>        // The UtilTableNameFromHandleToString function does a:
94534>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
94534>>>        // and it generates an error if the table is of the embedded type.
94534>>>        // As we don't want to trigger an error in that very specific case,
94534>>>        // we just ignore it here.
94534>>>        //
94534>>>        // If no report mode, just set the err indicator to true.
94534>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
94536>>>            Move False to Err
94537>>>            Procedure_Return
94538>>>        End
94538>>>>
94538>>>
94538>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
94540>>>            Procedure_Return
94541>>>        End
94541>>>>
94541>>>
94541>>>        Set Private.pbProcessingError to True
94542>>>        Set Private.pbUpdateVersionObjectError to True
94543>>>
94543>>>        Set pbDbUpdateErrorHasOccured to True
94544>>>        Get pnCurrentVersionUpdate to nVersion
94545>>>        Get phoLogFile to hoLogFile
94546>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
94547>>>
94547>>>        Set Private.pbProcessingError to False
94548>>>    End_Procedure
94549>>>
94549>>>End_Class
94550>
94550>Object oHtmlHelp is a cHtmlHelp
94552>    Set pbAlwaysOnTop to False
94553>
94553>    // Overriden class message to also handle internet HTML Help links;
94553>    // which in which case we should not try to find the path to the help file.
94553>    Function GetHelpFile Returns String
94556>        String sHelpFile
94556>
94556>        Get psHelpFile of ghoApplication to sHelpFile
94557>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
94559>            Get_File_Path sHelpFile to sHelpFile
94560>        End
94560>        Function_Return sHelpFile
94561>    End_Function
94562>
94562>End_Object
94563>
94563>Object oApplication is a cApplication
94565>    Set peHelpType to htHtmlHelp
94566>
94566>    // Note: These help file settings gets changed by the Help toolbar button(s).
94566>    Set psHelpFile to "Developer5.chm"
94567>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
94567>
94567>    Set pbPreserveEnvironment to True
94568>    Set psProduct to "Database Update Framework Lab"
94569>    Set psCompany to "RDC Tools International" 
94570>
94570>    Property String psCompileDateAndTime
94572>    // This is used by the About object to display the compile date & time:
94572>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
94572>
94572>    Object oConnection is a cConnection
94574>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
94574>>>Use cLoginEncryption.pkg
94574>>>
94574>>>Object oLoginEncryption is a cLoginEncryption
94576>>>
94576>>>    // this must be created in your appsrc directory and must contain an encryption
94576>>>    // key that is set to psEncryptPassword. It will look something like this
94576>>>    //
94576>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
94576>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
94576>>>>// Studio generated login encryption key
94576>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
94577>>>>
94577>>>    
94577>>>    // use this to register this object to your cConnection Object. This object
94577>>>    // must be created after the cConnection object
94577>>>    Move Self to ghoLoginEncryption
94578>>>End_Object
94579>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
94579>>>
94579>>>Use Windows.pkg
94579>>>Use cConnection.pkg
94579>>>Use dfLine.pkg
94579>>>
94579>>>Object oDatabaseLoginDialog is a ModalPanel
94581>>>    Set Label to "Database Login"
94582>>>    Set Location to 2 2
94583>>>    Set Size to 110 211
94584>>>    
94584>>>    Property String psId
94586>>>    Property Boolean pbOk False
94588>>>    Property Boolean pbChanged False
94590>>>    Property Boolean pbAllowRemember True
94592>>>    
94592>>>    // this registers this object with the cConnection object.
94592>>>    Move Self to ghoLoginConnectDialog
94593>>>    
94593>>>    Object oUserIDForm is a Form
94595>>>        Set Label to "User Name"
94596>>>        Set Size to 12 85
94597>>>        Set Location to 34 79
94598>>>        Set Label_Col_Offset to 64
94599>>>        Set peAnchors to anTopLeftRight
94600>>>    End_Object
94601>>>    
94601>>>    Object oPwdForm is a Form
94603>>>        Set Size to 12 85
94604>>>        Set Location to 49 79
94605>>>        Set Label_Col_Offset to 64
94606>>>        Set Password_State to True
94607>>>        Set peAnchors to anTopLeftRight
94608>>>        Set Label to "Password"
94609>>>    End_Object
94610>>>    
94610>>>    Object oTrustedConnection is a CheckBox
94612>>>        Set Size to 10 50
94613>>>        Set Location to 65 79
94614>>>        Set Label to "Trusted Connection"
94615>>>    End_Object
94616>>>    
94616>>>    Object oRemember is a CheckBox
94618>>>        Set Size to 10 50
94619>>>        Set Location to 79 14
94620>>>        Set Label to "Remember and don't ask again"
94621>>>        Set Checked_State to True
94622>>>    End_Object
94623>>>    
94623>>>    Object oLogin_btn is a Button
94625>>>        Set Label to "&Login"
94626>>>        Set Location to 92 102
94627>>>        Set peAnchors to anBottomRight
94628>>>        Set Default_State to True
94629>>>        
94629>>>        Procedure OnClick
94632>>>            Boolean bTrust
94632>>>            String sUser sPwd sConn sErr sId
94632>>>            Integer iError
94632>>>            Get psId to sId
94633>>>            Get Value of oUserIDForm to sUser
94634>>>            Get Value of oPwdForm to sPwd
94635>>>            Get Checked_State of oTrustedConnection to bTrust
94636>>>            
94636>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
94637>>>            If (iError=0) Begin
94639>>>                Set pbOk to True
94640>>>                Set pbChanged to True
94641>>>                Send Close_Panel
94642>>>            End
94642>>>>
94642>>>            Else Begin
94643>>>                Get psErrorText of ghoConnection to sErr
94644>>>                Send UserError sErr "Login Error"
94645>>>            End
94645>>>>
94645>>>        End_Procedure
94646>>>    End_Object
94647>>>    
94647>>>    Object oCancel_btn is a Button
94649>>>        Set Label to "&Cancel"
94650>>>        Set Location to 92 157
94651>>>        Set peAnchors to anBottomRight
94652>>>        
94652>>>        Procedure OnClick
94655>>>            Send Close_Panel
94656>>>        End_Procedure
94657>>>    End_Object
94658>>>    
94658>>>    Object oConnectionIdInfo is a TextBox
94660>>>        Set Size to 10 50
94661>>>        Set Location to 4 14
94662>>>        Set Label to 'Connection Id='
94663>>>    End_Object
94664>>>    
94664>>>    Object oConnectionServerInfo is a TextBox
94666>>>        Set Size to 10 50
94667>>>        Set Location to 16 14
94668>>>        Set Label to 'Server'
94669>>>    End_Object
94670>>>    
94670>>>    Object oLineControl1 is a LineControl
94672>>>        Set Size to 2 202
94673>>>        Set Location to 29 5
94674>>>    End_Object
94675>>>    
94675>>>    Function LoginConnectIdDialog String sId Returns Boolean
94678>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
94678>>>        String sUser sPwd sDescription
94678>>>        tConnection Connect
94678>>>        tConnection Connect
94678>>>        
94678>>>        Get pbAllowRemember to bAllowRemember
94679>>>        
94679>>>        
94679>>>        If not bAllowRemember Begin
94681>>>            Set Enabled_State of oRemember to bRemember
94682>>>            Set Visible_State of oRemember to bRemember
94683>>>        End
94683>>>>
94683>>>        
94683>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
94684>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
94685>>>        Set Value of oConnectionServerInfo to Connect.sString
94686>>>        
94686>>>        Set psId to sId
94687>>>        Set pbOk to False
94688>>>        Set pbChanged to False
94689>>>        Set Value of oUserIDForm to Connect.sUID
94690>>>        Set Value of oPwdForm to ""
94691>>>        
94691>>>        Send Popup
94692>>>        
94692>>>        Get pbOk to bOk
94693>>>        Get pbChanged to bChanged
94694>>>        If (bChanged and bOk) Begin
94696>>>            If bAllowRemember Begin
94698>>>                Get Checked_State of oRemember to bRemember
94699>>>                If bRemember Begin
94701>>>                    Get Checked_State of oTrustedConnection to bTrusted
94702>>>                    If not (bTrusted) Begin
94704>>>                        Get Value of oUserIDForm to sUser
94705>>>                        Get Value of oPwdForm to sPwd
94706>>>                    End
94706>>>>
94706>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
94707>>>                End
94707>>>>
94707>>>            End
94707>>>>
94707>>>        End
94707>>>>
94707>>>        Function_Return bOk
94708>>>    End_Function
94709>>>    
94709>>>    
94709>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
94710>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
94711>>>End_Object
94712>>>
94712>    End_Object
94713>
94713>    Procedure End_Construct_Object
94716>        String sCompileTime  
94716>        Integer iPos
94716>        
94716>        Forward Send End_Construct_Object
94718>        Direct_Input "resource: res_CompileHeader"
94719>        Readln sCompileTime
94720>        Move (Pos('"', sCompileTime)) to iPos
94721>        If (iPos <> 0) Begin
94723>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
94724>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
94725>            Set psCompileDateAndTime to sCompileTime
94726>        End
94726>        Close_Input
94727>    End_Procedure
94728>
94728>End_Object   
94729>
94729>Object oDbUpdateHandler is a cDbUpdateHandler 
94731>    Set piDbVersionFieldNumber to 1
94732>    Set piDbVersionFileNumber to 1
94733>    
94733>End_Object
94734>
94734>Object oCJSkinFramework is a cCJSkinFramework
94736>    Set pbLoadPreference to True
94737>End_Object
94738>
94738>Object oToolTipController is a cToolTipController
94740>    Set piDurationPopup to 10000
94741>    Set piMaxWidth to 500
94742>    Move Self to ghoToolTipController
94743>End_Object
94744>
94744>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
94744>>>Use cCJStandardMenuItemClasses.pkg
94744>>>
94744>>>Object oEditContextMenu is a cCJContextMenu
94746>>>    
94746>>>    Move Self to Default_Form_Floating_Menu_ID
94747>>>    
94747>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94749>>>    End_Object
94750>>>    
94750>>>    Object oCutMenuItem is a cCJCutMenuItem
94752>>>        Set pbControlBeginGroup to True
94753>>>    End_Object
94754>>>    
94754>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94756>>>    End_Object
94757>>>
94757>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94759>>>    End_Object
94760>>>
94760>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94762>>>    End_Object
94763>>>
94763>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94765>>>        Set pbControlBeginGroup to True
94766>>>    End_Object
94767>>>
94767>>>End_Object
94768>>>
94768>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
94768>>>Use Windows.pkg
94768>>>Use cCJStandardMenuItemClasses.pkg
94768>>>Use cCJDeoMenuItemClasses.pkg
94768>>>
94768>>>
94768>>>Object oDEOEditContextMenu17 is a cCJContextMenu
94770>>>    
94770>>>    Move Self to Default_dbFloating_Menu_ID
94771>>>    
94771>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94773>>>    End_Object
94774>>>    
94774>>>    Object oCutMenuItem is a cCJCutMenuItem
94776>>>        Set pbControlBeginGroup to True
94777>>>    End_Object
94778>>>    
94778>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94780>>>    End_Object
94781>>>
94781>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94783>>>    End_Object
94784>>>
94784>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94786>>>    End_Object
94787>>>
94787>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94789>>>        Set pbControlBeginGroup to True
94790>>>    End_Object
94791>>>
94791>>>    Object oPromptMenuItem is a cCJPromptMenuItem
94793>>>        Set pbControlBeginGroup to True
94794>>>    End_Object
94795>>>
94795>>>    Object oFindNextMenu is a cCJFindNextMenuItem
94797>>>        Set pbControlBeginGroup to True
94798>>>    End_Object
94799>>>
94799>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
94801>>>    End_Object
94802>>>
94802>>>    Object oClearMenuItem is a cCJClearMenuItem
94804>>>        Set pbControlBeginGroup to True
94805>>>    End_Object
94806>>>
94806>>>    Object oClearAllMenu is a cCJClearAllMenuItem
94808>>>    End_Object
94809>>>
94809>>>    Object oSaveMenu is a cCJSaveMenuItem
94811>>>    End_Object
94812>>>    
94812>>>    Object oDeleteMenu is a cCJDeleteMenuItem
94814>>>    End_Object
94815>>>
94815>>>    Object oRememberitem is a cCJRememberFieldMenuItem
94817>>>        Set pbControlBeginGroup to True
94818>>>    End_Object
94819>>>
94819>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
94821>>>    End_Object
94822>>>
94822>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
94824>>>    End_Object
94825>>>
94825>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
94827>>>    End_Object
94828>>>
94828>>>End_Object
94829>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
94829>>>Use cCJCommandBarSystem.pkg
94829>>>Use Wingdi.pkg
94829>>>Use LanguageText.pkg
94829>>>
94829>>>// User interface constant strings:
94829>>>Define CS_NoSkinShort For "-None"
94829>>>Define CS_NoSkinLong  For "Do not use a skin"
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>
94829>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
94830>>>
94830>>>    Procedure Construct_Object
94832>>>        Forward Send Construct_Object
94834>>>
94834>>>        Set peControlType to xtpControlComboBox
94835>>>
94835>>>        Property tSkinInformation[] pSkins
94836>>>
94836>>>    End_Procedure
94837>>>
94837>>>    Procedure End_Construct_Object
94839>>>        Forward Send End_Construct_Object
94841>>>    End_Procedure
94842>>>
94842>>>    // Custom array sort for the tSkinInformation struct array.
94842>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
94842>>>    // Why?
94842>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
94842>>>    // create a custom sort algorithm.
94842>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
94842>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
94842>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
94842>>>    // randomly ordered. This custom sort method will take care of that.
94842>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
94844>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94846>>>            Function_Return (GT)
94847>>>        End
94847>>>>
94847>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94849>>>            Function_Return (LT)
94850>>>        End
94850>>>>
94850>>>        Function_Return (EQ)
94851>>>    End_Function
94852>>>
94852>>>    Procedure OnCreateControl Handle hoObj
94854>>>        Forward Send OnCreateControl hoObj
94856>>>
94856>>>        Send LoadSkins
94857>>>        Send FillComboList hoObj
94858>>>    End_Procedure
94859>>>
94859>>>    // Load all skins. We will only look for skins in expected
94859>>>    // directory which is the Programs folder.
94859>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
94859>>>    // This is not the case with the 'standard' VDF behaviour.
94859>>>    Procedure LoadSkins
94861>>>        Integer iCount iItems iSize
94861>>>        Boolean bFound
94861>>>        String sFile sIni sSkin
94861>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
94861>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
94863>>>        tSkinInformation NoneRow
94863>>>        tSkinInformation NoneRow
94863>>>
94863>>>        If (ghoSkinFramework > 0) Begin
94865>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
94866>>>
94866>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
94867>>>            Move CS_NoSkinShort to NoneRow.sName
94868>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
94869>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
94870>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
94871>>>
94871>>>            // Get the currently loaded skin.
94871>>>            Get psSkinFile of ghoSkinFramework to sFile
94872>>>            Get psSkinIni  of ghoSkinFramework to sIni
94873>>>
94873>>>            // Remove all Extra Large and Large skins from the array.
94873>>>            Move (SizeOfArray(SkinsArray)) to iItems
94874>>>            Decrement iItems
94875>>>            For iCount From 0 to iItems
94881>>>>
94881>>>                Move SkinsArray[iCount].sSkinIni to sSkin
94882>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
94883>>>                If (bFound = False) Begin
94885>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
94886>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
94887>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
94888>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
94889>>>                End
94889>>>>
94889>>>            Loop
94890>>>>
94890>>>            Set pSkins to SkinsArrayNoLarge
94891>>>        End
94891>>>>
94891>>>    End_Procedure
94892>>>
94892>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
94892>>>    Procedure FillComboList Handle hoCombo
94894>>>        Integer iCount iItems iCurrent iTxtEntentSize
94894>>>        String  sFile sIni sCurrSkin
94894>>>        String  sSkin sSkinText
94894>>>        tSkinInformation[] SkinsArray
94894>>>        tSkinInformation[] SkinsArray
94895>>>        Integer iSize
94895>>>
94895>>>        If (ghoSkinFramework < 1) Begin
94897>>>            Procedure_Return
94898>>>        End
94898>>>>
94898>>>
94898>>>        // Get the currently loaded skin.
94898>>>        Get psSkinFile of ghoSkinFramework to sFile
94899>>>        Get psSkinIni  of ghoSkinFramework to sIni
94900>>>        Get pSkins to SkinsArray
94901>>>        Move (SizeOfArray(SkinsArray)) to iItems
94902>>>        Decrement iItems
94903>>>        Send ComClear of hoCombo
94904>>>
94904>>>        For iCount From 0 to iItems
94910>>>>
94910>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
94911>>>            Move (Replace(".ini", sSkin, "")) to sSkin
94912>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
94913>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
94914>>>            Get Text_Extent sSkinText to iSize
94915>>>            If (iSize > iTxtEntentSize) Begin
94917>>>                Move iSize to iTxtEntentSize
94918>>>            End
94918>>>>
94918>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
94919>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
94921>>>                Move iCount to iCurrent
94922>>>            End
94922>>>>
94922>>>        Loop
94923>>>>
94923>>>
94923>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
94924>>>        Set ComDropDownWidth of hoCombo  to iSize
94925>>>        Set ComWidth         of hoCombo  to (iSize + 100)
94926>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
94927>>>    End_Procedure
94928>>>
94928>>>    // Event for when an item is selected from the comboform
94928>>>    Procedure OnExecute Variant vCommandBarControl
94930>>>        Handle  hoCombo
94930>>>        Integer iSelection
94930>>>        String  sSkinFile sSkinIni
94930>>>        tSkinInformation[] SkinsArray
94930>>>        tSkinInformation[] SkinsArray
94931>>>
94931>>>        // Create and bind proxy control
94931>>>        Get CreateProxyControl vCommandBarControl to hoCombo
94932>>>        // Get the current selection
94932>>>        Get ComListIndex of hoCombo to iSelection
94933>>>        Decrement iSelection
94934>>>        Get pSkins to SkinsArray
94935>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
94936>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
94937>>>
94937>>>        Send DoChangeSkin sSkinFile sSkinIni
94938>>>
94938>>>        // Dispose of the proxy control
94938>>>        Send Destroy of hoCombo
94939>>>    End_Procedure
94940>>>
94940>>>    // Send this message to change the current skin.
94940>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
94942>>>        Handle hoClient
94942>>>
94942>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
94943>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
94944>>>        Send ApplySkin of ghoSkinFramework
94945>>>
94945>>>        // Note: The following line is essential for the resizing logic
94945>>>        // to function properly when changing a skin and a view is maximized.
94945>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
94946>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
94947>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
94948>>>    End_Procedure
94949>>>
94949>>>    // Returns: DPI setting as an integer.
94949>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
94949>>>    //                      iDPI=120 is "Medium setting" 125%
94949>>>    //                      iDPI= 144 is "Large setting" 150%
94949>>>    Function GetCurrentDPI Returns Integer
94951>>>        Handle hDC
94951>>>        Integer iPixelsX
94951>>>        Move (GetDC(0)) to hDC
94952>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
94953>>>        Move (ReleaseDC(0, hDC)) to hDC
94954>>>        Function_Return iPixelsX
94955>>>    End_Function
94956>>>
94956>>>End_Class
94957>
94957>Object oMain is a Panel
94959>    Set Label to "Test Program - The Database Update Framework"
94960>    Set Location to 2 2
94961>    Set Size to 309 493
94962>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
94963>    Set Icon to "TestTools.ico"
94964>
94964>    Property Handle phoViewMenu 0
94966>    Property Handle phoReportMenu 0
94968>
94968>    Object oCommandBarSystem is a cCJCommandBarSystem
94970>        Set pbTimerUpdate to True
94971>            Set pbAutoResizeIcons to True
94972>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
94973>            Set peVisualTheme to xtpThemeOffice2013Publisher
94974>            Set pbLargeIcons to True
94975>
94975>        Procedure OnCreateCommandBars
94978>            Handle hoOptions
94978>            Forward Send OnCreateCommandBars
94980>                Get OptionsObject to hoOptions
94981>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
94982>        End_Procedure
94983>
94983>
94983>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
94986>        Set ComShowIcons of hoTabPaintManager to True
94987>
94987>        // This will truncate the middle part of long items
94987>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
94988>    End_Procedure
94989>
94989>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
94989>        // the previous tab workspace view.
94989>        Object oPreviousTabAction is a cCJAction
94991>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
94992>            Procedure OnExecute Variant vCommandBarControl
94995>                Handle hoCommandBars hoClientArea
94995>                Forward Send OnExecute vCommandBarControl
94997>                Get CommandBarSystemObject to hoCommandBars
94998>                Get ClientAreaObject of hoCommandBars to hoClientArea
94999>                If hoClientArea Begin
95001>                    Send Switch_Next_View of hoClientArea
95002>                End
95002>            End_Procedure
95003>        End_Object
95004>
95004>        Object oToolBar is a cCJToolbar
95006>            Set psTitle to "Edit Toolbar"
95007>            Set pbGripper to False
95008>            Set peStretched to stStretch
95009>
95009>            Object oCutToolbarItem is a cCJCutMenuItem  
95011>                Set psImage to "ActionCut1.ico"
95012>            End_Object
95013>
95013>            Object oCopyToolbarItem is a cCJCopyMenuItem
95015>                Set psImage to "ActionCopy1.ico"
95016>            End_Object
95017>
95017>            Object oPasteToolbarItem is a cCJPasteMenuItem
95019>                Set psImage to "ActionPaste1.ico"
95020>            End_Object
95021>
95021>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95023>                Set psImage to "ActionDelete1.ico"
95024>                Set pbControlBeginGroup to True
95025>            End_Object
95026>
95026>            Object oTheme_tb is a cCJMenuItem
95028>                Set peControlType to xtpControlLabel
95029>                Set psCaption to "Theme:"
95030>                Set pbControlBeginGroup to True
95031>            End_Object
95032>
95032>            Object oThemeItem is a cCJMenuItem
95034>                Set peControlType to xtpControlComboBox
95035>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95036>
95036>                Procedure OnCreateControl Handle hoObj
95039>                    Integer iItem eTheme
95039>                    Set ComWidth of hoObj to 250
95040>                    Send FillComboList hoObj
95041>                    Get peVisualTheme to eTheme
95042>                    Get FindDataItem hoObj eTheme to iItem
95043>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95044>                End_Procedure
95045>
95045>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95048>                    Integer iCount i eTheme
95048>                    Get ComListCount of hoCombo to iCount
95049>                    For i from 1 to iCount
95055>                        Get ComItemData of hoCombo i to eTheme
95056>                        If (eTheme=eVal) Begin
95058>                            Send SetTheTheme eTheme
95059>                            Function_Return i
95060>                        End
95060>                    Loop
95061>                    Function_Return 0
95062>                End_Function
95063>
95063>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95066>                    Integer iCount
95066>                    Get ComListCount of hoCombo to iCount
95067>                    Increment iCount
95068>                    Send ComAddItem  of hoCombo sText iCount
95069>                    Set ComItemData  of hoCombo iCount to  eTheme
95070>                End_Procedure
95071>
95071>                Procedure FillComboList Handle hoCombo
95074>                    Send ComClear     of hoCombo
95075>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95076>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95077>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95078>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95079>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95080>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95081>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95082>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95083>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95084>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95085>    
95085>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95086>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95087>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95088>    
95088>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95089>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95090>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95091>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95092>    
95092>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95093>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95094>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95095>    
95095>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95096>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95097>    
95097>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95098>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95099>    
95099>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95100>    
95100>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95101>    
95101>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95102>                End_Procedure
95103>
95103>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95106>                    Handle hMessage hoCombo
95106>                    Integer iIndex
95106>                    // create and bind  proxy control
95106>                    Get CreateProxyControl vCommandBarControl to hoCombo
95107>                    // get the current selection
95107>                    Get ComListIndex of hoCombo to iIndex
95108>                    // note the index selections are 1 based
95108>                    If (iIndex > 0) Begin
95110>                        // get the ItemData for the selected item and send that message
95110>                        Get ComItemData of hoCombo iIndex to hMessage
95111>                        Function_Return hMessage
95112>                    End
95112>                    // dispose of the proxy control
95112>                    Send Destroy of hoCombo
95113>                    Function_Return 0
95114>                End_Function
95115>
95115>                Procedure OnExecute Variant vCommandBarControl
95118>                    Integer eTheme
95118>                    Integer iColor
95118>                    Get CurrentTheme vCommandBarControl to eTheme
95119>                    Set peVisualTheme of ghoCommandBars to eTheme
95120>                    Send ComRecalcLayout of ghoCommandBars
95121>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95122>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95124>                End_Procedure
95125>
95125>                Procedure SetTheTheme Integer eTheme
95128>                    Integer iColor
95128>                    Set peVisualTheme of ghoCommandBars to eTheme
95129>                    Send ComRecalcLayout of ghoCommandBars
95130>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95131>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95133>                End_Procedure
95134>
95134>                Function ConvertSystemColor Integer iColor Returns Integer
95137>                    Integer iSysColor
95137>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95139>                        Move clNone to iColor
95140>                    End
95140>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95143>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95144>                        Move (GetSysColor(iSysColor)) to iColor
95145>                    End
95145>                    Function_Return iColor
95146>                End_Function
95147>
95147>            End_Object
95148>
95148>            Object oAbout_MenuItem is a cCJMenuItem
95150>                Set psCaption to "About"
95151>                Set psToolTip to "About Info"
95152>                Set psDescription to "About the program"
95153>                Set psImage to "ActionAbout1.ico"
95154>                Set pbControlBeginGroup to True
95155>                Procedure OnExecute Variant vCommandBarControl
95158>                    Forward Send OnExecute vCommandBarControl
95160>                    Send Activate_About of (Client_Id(ghoCommandBars))
95161>                End_Procedure
95162>            End_Object
95163>
95163>            Object oHelpMenuItem is a cCJHelpMenuItem
95165>                Set peControlType to xtpControlSplitButtonPopup
95166>                Set psImage to "ActionHelp1.ico"
95167>
95167>                Procedure OnExecute Variant vCommandBarControl
95170>                    Forward Send OnExecute vCommandBarControl
95172>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95173>                    Send ShowProgramHelp
95174>                End_Procedure
95175>
95175>                Object oHelpMenuItemLocal is a cCJMenuItem
95177>                    Set psCaption to "Local HTML Help"
95178>                    Set psImage to "ActionHelp1.ico"
95179>                    Procedure OnExecute Variant vCommandBarControl
95182>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95183>                        Send ShowProgramHelp
95184>                    End_Procedure
95185>                End_Object
95186>
95186>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95188>                    Set psCaption to "Internet Online HTML Help"
95189>                    Set psImage to "ActionHelp1.ico"
95190>                    Procedure OnExecute Variant vCommandBarControl
95193>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95194>                    End_Procedure
95195>
95195>                End_Object
95196>            End_Object
95197>
95197>            Object oExitMenuItem is a cCJExitMenuItem
95199>                Set psImage to "ActionExit1.ico"
95200>                Set psToolTip to "Exit application"
95201>                Set psDescription to "Exit the program (Alt+F4)"
95202>                Set pbControlBeginGroup to True
95203>            End_Object
95204>        End_Object
95205>
95205>//        Object oSpacerBar is a cCJToolbar
95205>//            Set pbDockNextTo to False
95205>//            Set pbShowExpandButton to False
95205>//            Set pbGripper to False
95205>//            Set peStretched to stStretch
95205>//            Set pbCustomizable to False
95205>//            Set pbCloseable to False
95205>//            Set pbEnableDocking to False
95205>//            Set pbHideWrap to True
95205>//
95205>//            Object oFiller is a cCJMenuItem
95205>//            End_Object
95205>//
95205>//        End_Object
95205>
95205>        Object oStatusBar is a cCJStatusBar
95207>
95207>            Object oStatusPane1 is a cCJStatusBarPane
95209>                Set piID to sbpIDIdlePane
95210>                Set pbStyleStretch to True
95211>            End_Object
95212>            Object oStatusPane2 is a cCJStatusBarPane
95214>                Set phoViewPane to Self
95215>                Set pbStyleStretch to True
95216>            End_Object
95217>
95217>        End_Object
95218>
95218>    End_Object
95219>
95219>    Object oClientArea is a ClientArea
95221>
95221>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95221>
95221>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95221>>>//************************************************************************
95221>>>// Confidential Trade Secret.
95221>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95221>>>// as an unpublished work.  All rights reserved.
95221>>>// DataFlex is a registered trademark of Data Access Corporation.
95221>>>//
95221>>>//************************************************************************
95221>>>//************************************************************************
95221>>>//
95221>>>// $File name  : StdAbout.pkg
95221>>>// $File title : Standard about object package for VDF
95221>>>// Notice      :
95221>>>// $Author(s)  : John Tuohy
95221>>>//
95221>>>// $Rev History
95221>>>//
95221>>>// JT 06/27/97   File created
95221>>>//************************************************************************
95221>>>
95221>>>// This provides a quick and simple way to create an about package for a program.
95221>>>// You need to create a message inside you client area called Activate_About.
95221>>>// Within this message you should send the message DoAbout passing needed
95221>>>// string information.
95221>>>//
95221>>>//       Procedure Activate_About
95221>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95221>>>//       End_Procedure
95221>>>//    where: sTitle =     Name of application. If none provided, uses caption
95221>>>//                        bar title
95221>>>//           sVersion   = Version Line. If none provided, will be blank
95221>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95221>>>//           sAuthor    = Author name, blank if none provided
95221>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95221>>>//                        is used.
95221>>>// It is expected that you will place this in your own object package. For
95221>>>// example an order about package may look like this:
95221>>>//
95221>>>//   // OrderAbout.pkg
95221>>>//   Use StdAbout.pkg
95221>>>//   Procedure Activate_About
95221>>>//      String sTitle sCopyright sVersion sAuthor
95221>>>//      Move "My Order Entry System" to sTitle
95221>>>//      Move "Version 2.1" to sVersion
95221>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95221>>>//      Move "John Smith"  to sAuthor
95221>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95221>>>//   end_procedure
95221>>>//   // end of file.
95221>>>
95221>>>Use DfAbout.pkg
95221>>>
95221>>>// *************************************************************************
95221>>>//  Public message. This is the default message. It is expected that you will
95221>>>//   create your own message to override this
95221>>>// *************************************************************************
95221>>>
95221>>>Procedure Activate_About
95224>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95225>>>End_Procedure
95226>>>
95226>>>// *************************************************************************
95226>>>//  Public message. It is expected that you will send this message (most
95226>>>//  likely from Activate_About. This creates an about object, activates it
95226>>>//  and destroys it when done. It is not exepected that you will augment this.
95226>>>// *************************************************************************
95226>>>// Sample usage:
95226>>>//   The first two params will automatically be filled from the application settings if not provided.
95226>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95226>>>
95226>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95229>>>    Integer hoObj hoMain iArgs
95229>>>    String sValue
95229>>>
95229>>>    // Create object
95229>>>    Object About is an AboutDialog
95231>>>    // Uncomment these two lines if you would like to have a resizable About object.
95231>>>    //            Set Border_Style to Border_Thick
95231>>>    //            Set peAnchors to anAll
95231>>>
95231>>>    // Add checking for the number of arguments passed to avoid runtime errors
95231>>>    // if one of them is not passed. This makes the interface
95231>>>    // more flexible.
95231>>>        Move num_arguments to iArgs
95232>>>
95232>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95232>>>        If (iArgs > 0 and sTitle = "") Begin
95234>>>            Get Main_Window of Desktop to hoMain
95235>>>            If hoMain Begin
95237>>>                Get Label of hoMain to sValue
95238>>>            End
95238>>>>
95238>>>        End
95238>>>>
95238>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95241>>>            Move sTitle to sValue
95242>>>        End
95242>>>>
95242>>>        Else If (iArgs = 0) Begin
95245>>>            Get Main_Window of Desktop to hoMain
95246>>>            If hoMain Begin
95248>>>                Get Label of hoMain to sValue
95249>>>            End
95249>>>>
95249>>>        End
95249>>>>
95249>>>
95249>>>        If (sValue <> "") Begin
95251>>>            Send Add_LineLn sValue
95252>>>        End
95252>>>>
95252>>>        Move "" to sValue
95253>>>
95253>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95253>>>        // For this to work the Project Properties Version must have been set in the Studio.
95253>>>        If (iArgs < 2) Begin
95255>>>            Move "" to sValue
95256>>>        End
95256>>>>
95256>>>        Else Begin
95257>>>            Move sVersion to sValue
95258>>>        End
95258>>>>
95258>>>        Set Version to sValue
95259>>>
95259>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95261>>>            Send Add_LineLn sCopyRight
95262>>>        End
95262>>>>
95262>>>
95262>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95262>>>        // else we do.
95262>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95264>>>            Send Add_Line sAuthor
95265>>>        End
95265>>>>
95265>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95268>>>            Send Add_LineLn sAuthor
95269>>>        End
95269>>>>
95269>>>
95269>>>        // Square bitmaps of 80x80 works best
95269>>>        If (iArgs > 4 and sBitmap <> "") Begin
95271>>>            Set Logo to sBitMap
95272>>>        End
95272>>>>
95272>>>
95272>>>        // Here starts handling of the five optional params:
95272>>>        If (iArgs = 6 and sParam6  <> "") Begin
95274>>>            Send Add_Line sParam6
95275>>>        End
95275>>>>
95275>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95278>>>            Send Add_LineLn sParam6
95279>>>        End
95279>>>>
95279>>>
95279>>>        If (iArgs = 7 and sParam7  <> "") Begin
95281>>>            Send Add_Line sParam7
95282>>>        End
95282>>>>
95282>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95285>>>            Send Add_LineLn sParam7
95286>>>        End
95286>>>>
95286>>>
95286>>>        If (iArgs = 8 and sParam8  <> "") Begin
95288>>>            Send Add_Line sParam8
95289>>>        End
95289>>>>
95289>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95292>>>            Send Add_LineLn sParam8
95293>>>        End
95293>>>>
95293>>>
95293>>>        If (iArgs = 9 and sParam9  <> "") Begin
95295>>>            Send Add_Line sParam9
95296>>>        End
95296>>>>
95296>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95299>>>            Send Add_LineLn sParam9
95300>>>        End
95300>>>>
95300>>>
95300>>>        If (iArgs = 10 and sParam10 <> "") Begin
95302>>>            Send Add_Line sParam10
95303>>>        End
95303>>>>
95303>>>
95303>>>        Move Self to hoObj
95304>>>    End_Object
95305>>>
95305>>>    Send Popup   of hoObj // Popup the about object
95306>>>    Send Destroy of hoObj // When done, it will be destroyed
95307>>>End_Procedure
95308>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95308>>>Use Windows.pkg
95308>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95308>>>>>Use Windows.pkg
95308>>>>>Use cCJGrid.pkg
95308>>>>>Use umPromptRelational.pkg
95308>>>>>
95308>>>>>Class cCJGridPromptList is a cCJGrid
95309>>>>>    
95309>>>>>    Procedure Construct_Object
95311>>>>>        Forward Send Construct_Object
95313>>>>>        
95313>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95314>>>>>        Property Boolean Private_pbAutoOrdering True
95315>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95316>>>>>        Property Integer peUpdateMode umPromptValue
95317>>>>>        Property Integer piUpdateColumn 0
95318>>>>>        Property Integer piInitialColumn -1
95319>>>>>        Property String  psSeedValue ''
95320>>>>>        Property Handle phmPromptUpdateCallback 0
95321>>>>>        Property Integer phoInvokingObject
95322>>>>>        
95322>>>>>        Property Boolean pbStoredAutoSeed
95323>>>>>        Property Boolean pbStoredAutoOrdering
95324>>>>>        Property Boolean pbStoredAutoSearch
95325>>>>>        Property Integer peStoredUpdateMode
95326>>>>>        Property Integer piStoredUpdateColumn
95327>>>>>        Property Integer piStoredInitialColumn
95328>>>>>        Property Handle  phmStoredPromptUpdateCallback
95329>>>>>        Property Boolean pbStoredSelectionEnable
95330>>>>>        Property Boolean pbStoredMultipleSelection
95331>>>>>        
95331>>>>>        // internally set by list
95331>>>>>        // these must be set upon closing the list and can be used for manual list updates
95331>>>>>        Property Boolean pbCanceled
95332>>>>>        Property Integer[] pSelectedRows
95333>>>>>        
95333>>>>>        Property Boolean pbNeedsNewOrdering
95334>>>>>        Property Boolean pbRequestSearch
95335>>>>>        Property tGridKeyPair[] pSearchKeys
95336>>>>>        
95336>>>>>        // these properties makes a prompt list a prompt list
95336>>>>>        // and should not be changed.
95336>>>>>        Set pbEditOnKeyNavigation to False
95337>>>>>        Set pbEditOnClick to False
95338>>>>>        Set pbReadOnly to True
95339>>>>>        Set pbFocusSubItems to True
95340>>>>>        
95340>>>>>        // these could maybe be changed
95340>>>>>        Set pbShadeSortColumn to True
95341>>>>>        Set pbHeaderReorders to True
95342>>>>>        Set pbHeaderTogglesDirection to True
95343>>>>>        Set pbHeaderSelectsColumn to True
95344>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95345>>>>>        Set piFocusCellBackColor to clNone
95346>>>>>        Set piFocusCellForeColor to clNone
95347>>>>>        Set piFocusCellRectangleColor to clBlack
95348>>>>>        Set pbUseFocusCellRectangle to False
95349>>>>>        Set pbSelectionEnable to True
95350>>>>>        
95350>>>>>        On_Key kEnter Send Ok
95351>>>>>        On_Key kCancel Send Cancel
95352>>>>>        
95352>>>>>    End_Procedure
95353>>>>>    
95353>>>>>    // reorder list automatically on column change
95353>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95353>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95355>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95356>>>>>        Set pbFocusSubItems to bAutoOrder
95357>>>>>    End_Procedure
95358>>>>>    
95358>>>>>    Function pbAutoOrdering Returns Boolean
95360>>>>>        Boolean bAutoOrder
95360>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95361>>>>>        Function_Return bAutoOrder
95362>>>>>    End_Function
95363>>>>>    
95363>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95363>>>>>    Procedure OnIdle
95365>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95365>>>>>        Handle hoCol
95365>>>>>        Integer iKy1 iKy2 iCol
95365>>>>>        
95365>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95366>>>>>        If bNeedsReorder Begin
95368>>>>>            Get SelectedColumn to iCol
95369>>>>>            If (iCol<>-1) Begin
95371>>>>>                
95371>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95372>>>>>                Set pbHeaderTogglesDirection to False
95373>>>>>                Send HeaderReorder iCol
95374>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95375>>>>>                
95375>>>>>                Set pbNeedsNewOrdering to False
95376>>>>>            End
95376>>>>>>
95376>>>>>        End
95376>>>>>>
95376>>>>>        
95376>>>>>        Get pbRequestSearch to bSearch
95377>>>>>        If bSearch Begin
95379>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95380>>>>>        End
95380>>>>>>
95380>>>>>        
95380>>>>>        Forward Send OnIdle
95382>>>>>    End_Procedure
95383>>>>>    
95383>>>>>    Procedure OnStoreDefaults
95385>>>>>        Integer iVal
95385>>>>>        Boolean bVal
95385>>>>>        
95385>>>>>        Get pbAutoSeed to bVal
95386>>>>>        Set pbStoredAutoSeed to bVal
95387>>>>>        
95387>>>>>        Get pbAutoOrdering to bVal
95388>>>>>        Set pbStoredAutoOrdering to bVal
95389>>>>>        
95389>>>>>        Get pbAutoSearch to bVal
95390>>>>>        Set pbStoredAutoSearch to bVal
95391>>>>>        
95391>>>>>        Get peUpdateMode to iVal
95392>>>>>        Set peStoredUpdateMode to iVal
95393>>>>>        
95393>>>>>        Get piUpdateColumn to iVal
95394>>>>>        Set piStoredUpdateColumn to iVal
95395>>>>>        
95395>>>>>        Get piInitialColumn to iVal
95396>>>>>        Set piStoredInitialColumn to iVal
95397>>>>>        
95397>>>>>        Get phmPromptUpdateCallback to iVal
95398>>>>>        Set phmStoredPromptUpdateCallback to iVal
95399>>>>>        
95399>>>>>        Get pbSelectionEnable to bVal
95400>>>>>        Set pbStoredSelectionEnable to bVal
95401>>>>>        
95401>>>>>        Get pbMultipleSelection to bVal
95402>>>>>        Set pbStoredMultipleSelection to bVal
95403>>>>>        
95403>>>>>    End_Procedure
95404>>>>>    
95404>>>>>    Procedure OnRestoreDefaults
95406>>>>>        Integer iVal
95406>>>>>        Boolean bVal
95406>>>>>        
95406>>>>>        Get pbStoredAutoSeed to bVal
95407>>>>>        Set pbAutoSeed to bVal
95408>>>>>        
95408>>>>>        Get pbStoredAutoOrdering to bVal
95409>>>>>        Set pbAutoOrdering to bVal
95410>>>>>        
95410>>>>>        Get pbStoredAutoSearch to bVal
95411>>>>>        Set pbAutoSearch to bVal
95412>>>>>        
95412>>>>>        Get peStoredUpdateMode to iVal
95413>>>>>        Set peUpdateMode to iVal
95414>>>>>        
95414>>>>>        Get piStoredUpdateColumn to iVal
95415>>>>>        Set piUpdateColumn to iVal
95416>>>>>        
95416>>>>>        Get piStoredInitialColumn to iVal
95417>>>>>        Set piInitialColumn to iVal
95418>>>>>        
95418>>>>>        Get phmStoredPromptUpdateCallback to iVal
95419>>>>>        Set phmPromptUpdateCallback to iVal
95420>>>>>        
95420>>>>>        Get pbStoredSelectionEnable to bVal
95421>>>>>        Set pbSelectionEnable to bVal
95422>>>>>        
95422>>>>>        Get pbStoredMultipleSelection to bVal
95423>>>>>        Set pbMultipleSelection to bVal
95424>>>>>        
95424>>>>>    End_Procedure
95425>>>>>    
95425>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95425>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95425>>>>>    // Suitable for augmentation
95425>>>>>    Procedure OnSeedData
95427>>>>>        Integer iUpdateColumn iSortColumn
95427>>>>>        Boolean bSeed bAuto
95427>>>>>        String sValue
95427>>>>>        Handle hoCol
95427>>>>>        
95427>>>>>        Get piUpdateColumn to iUpdateColumn
95428>>>>>        Get psSeedValue to sValue
95429>>>>>        Get pbAutoSeed to bSeed
95430>>>>>        Get piSortColumn to iSortColumn
95431>>>>>        Get pbAutoOrdering to bAuto
95432>>>>>        // if not yet sorted and this is auto ordering we will
95432>>>>>        // sort the data for the search column. We do this to make the
95432>>>>>        // column search GE logic work properly.
95432>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95434>>>>>            Get ColumnObject iUpdateColumn to hoCol
95435>>>>>            Send SortGridByColumn hoCol False
95436>>>>>        End
95436>>>>>>
95436>>>>>        
95436>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95438>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95439>>>>>        End
95439>>>>>>
95439>>>>>        Else Begin
95440>>>>>            Send MovetoFirstRow
95441>>>>>        End
95441>>>>>>
95441>>>>>        
95441>>>>>    End_Procedure
95442>>>>>    
95442>>>>>    Procedure OnMoveValueOutByValue
95444>>>>>        String sValue
95444>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95444>>>>>        Integer iRow iCol
95444>>>>>        Integer[] SelRowsIndexes
95445>>>>>        
95445>>>>>        Get phoInvokingObject to hoInvokingObject
95446>>>>>        Get pSelectedRows to SelRowsIndexes
95447>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95449>>>>>            Get piUpdateColumn to iCol
95450>>>>>            Get ColumnObject iCol to hoCol
95451>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95452>>>>>            Set Value of hoInvokingObject to sValue
95453>>>>>            Set Item_Changed_State of hoInvokingObject to True
95454>>>>>        End
95454>>>>>>
95454>>>>>    End_Procedure
95455>>>>>    
95455>>>>>    Procedure OnMoveValueOutByCustom
95457>>>>>    End_Procedure
95458>>>>>    
95458>>>>>    // augment to popup a search window when allowed
95458>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95460>>>>>        Boolean bSubFocus bAutoSearch bChar
95460>>>>>        Integer iVal
95460>>>>>        
95460>>>>>        Get pbFocusSubItems to bSubFocus
95461>>>>>        Get pbAutoSearch to bAutoSearch
95462>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95464>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95466>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95468>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95469>>>>>                Move (iVal<>0) to bChar
95470>>>>>            End
95470>>>>>>
95470>>>>>            If bChar Begin
95472>>>>>                // this can get called multiple times before a search dialog pops up
95472>>>>>                Send AddToSearchKeys llKeyCode llShift
95473>>>>>            End
95473>>>>>>
95473>>>>>        End
95473>>>>>>
95473>>>>>    End_Procedure
95474>>>>>    
95474>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95476>>>>>        Boolean bAutoSearch
95476>>>>>        Integer iKeyCode iShiftCode
95476>>>>>        Get pbAutoSearch to bAutoSearch
95477>>>>>        If bAutoSearch Begin
95479>>>>>            // this can get called multiple times before a search dialog pops up
95479>>>>>            Get piLastKey to iKeyCode
95480>>>>>            Get piLastKey2 to iShiftCode
95481>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95482>>>>>        End
95482>>>>>>
95482>>>>>        Move True to llCancel
95483>>>>>    End_Procedure
95484>>>>>    
95484>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95486>>>>>        Send ClearSearchRequest // kill any deferred search popup
95487>>>>>        Forward Send OnComRowDblClick llRow llItem
95489>>>>>    End_Procedure
95490>>>>>    
95490>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95492>>>>>        Send Ok
95493>>>>>    End_Procedure
95494>>>>>    
95494>>>>>    
95494>>>>>    // we don't want a menu for prompt lists
95494>>>>>    Function CreateContextMenu Returns Handle
95496>>>>>        Function_Return 0
95497>>>>>    End_Function
95498>>>>>    
95498>>>>>    // if we use auto-ordering, change the order when the column changes
95498>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95500>>>>>        Boolean bAutoOrder
95500>>>>>        Forward Send ColumnChanged iOld iNew
95502>>>>>        Get pbAutoOrdering to bAutoOrder
95503>>>>>        If bAutoOrder Begin
95505>>>>>            // will be reordered in idle event
95505>>>>>            Set pbNeedsNewOrdering to True
95506>>>>>        End
95506>>>>>>
95506>>>>>    End_Procedure
95507>>>>>    
95507>>>>>    
95507>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95509>>>>>        Integer eMode
95509>>>>>        Integer[] SelRowsIndexes
95510>>>>>        Set pbCanceled to True // assume cancel unless changed
95511>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95512>>>>>        Get peUpdateMode to eMode
95513>>>>>        If (eMode<>umPromptNonInvoking) Begin
95515>>>>>            Send OnStoreDefaults
95516>>>>>        End
95516>>>>>>
95516>>>>>        Send InitializePromptList
95517>>>>>        Forward Send Add_Focus hoParent
95519>>>>>        Send LoadData
95520>>>>>        Set psSeedValue to ""
95521>>>>>    End_Procedure
95522>>>>>    
95522>>>>>    // called before the list is activated.
95522>>>>>    Procedure InitializePromptList
95524>>>>>        Integer hoInvokingObject
95524>>>>>        Boolean bAutoColumn bAutoSeed
95524>>>>>        Integer i iOldMode eUpdateMode
95524>>>>>        String sValue
95524>>>>>        
95524>>>>>        Get peUpdateMode to eUpdateMode
95525>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95527>>>>>            Get Focus of Desktop to hoInvokingObject
95528>>>>>            If (hoInvokingObject<=Desktop) Begin
95530>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95531>>>>>>
95531>>>>>                Procedure_Return
95532>>>>>            End
95532>>>>>>
95532>>>>>            
95532>>>>>            Set phoInvokingObject to hoInvokingObject
95533>>>>>            
95533>>>>>            Send Prompt_Callback to hoInvokingObject Self
95534>>>>>            Get peUpdateMode to eUpdateMode
95535>>>>>        End
95535>>>>>>
95535>>>>>        
95535>>>>>        Send ClearSearchRequest // clear the search keys
95536>>>>>        Set pbNeedsNewOrdering to False
95537>>>>>        
95537>>>>>        Get pbAutoSeed to bAutoSeed
95538>>>>>        
95538>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
95540>>>>>            Get Value of hoInvokingObject to sValue
95541>>>>>            Set psSeedValue to sValue
95542>>>>>        End
95542>>>>>>
95542>>>>>        
95542>>>>>    End_Procedure
95543>>>>>    
95543>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
95543>>>>>    Procedure LoadData
95545>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
95545>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
95545>>>>>        Integer eUpdateMode
95545>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
95545>>>>>        
95545>>>>>        Get phoDataSource to hoDataSource
95546>>>>>        Get peUpdateMode to eUpdateMode
95547>>>>>        Get phoInvokingObject to hoInvokingObject
95548>>>>>        Get pbAutoSeed to bAutoSeed
95549>>>>>        Get piInitialColumn to iInitialColumn
95550>>>>>        Get piUpdateColumn to iUpdateColumn
95551>>>>>        Get RowCount of hoDataSource to iRows
95552>>>>>        
95552>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
95552>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
95552>>>>>        If (iInitialColumn=-1) Begin
95554>>>>>            Move iUpdateColumn to iInitialColumn
95555>>>>>        End
95555>>>>>>
95555>>>>>        If (iInitialColumn>=0) Begin
95557>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
95558>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
95559>>>>>        End
95559>>>>>>
95559>>>>>        Send OnSeedData // find a good starting place for the row
95560>>>>>        Get pbFocusSubItems to bSubFocus
95561>>>>>        If bSubFocus Begin
95563>>>>>            // if column focus, which is normal, go to initialcolumn
95563>>>>>            If hoInitialColumn Begin
95565>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
95566>>>>>            End
95566>>>>>>
95566>>>>>            Else Begin
95567>>>>>                Send MoveToFirstEnterableColumn
95568>>>>>            End
95568>>>>>>
95568>>>>>        End
95568>>>>>>
95568>>>>>        
95568>>>>>    End_Procedure
95569>>>>>    
95569>>>>>    // This is only called in a successful close
95569>>>>>    Procedure ClosePromptList
95571>>>>>        Handle hoDataSource hoInvokingObject
95571>>>>>        Handle hmCallBack
95571>>>>>        Integer iRow eUpdateMode
95571>>>>>        Integer[] SelRowsIndexes
95572>>>>>        
95572>>>>>        Get phoDataSource to hoDataSource
95573>>>>>        Get phoInvokingObject to hoInvokingObject
95574>>>>>        
95574>>>>>        If (pbMultipleSelection(Self)) Begin
95576>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
95577>>>>>        End
95577>>>>>>
95577>>>>>        Else Begin
95578>>>>>            Get SelectedRow of hoDataSource to iRow
95579>>>>>            If (iRow<>-1) Begin
95581>>>>>                Move iRow to SelRowsIndexes[0]
95582>>>>>            End
95582>>>>>>
95582>>>>>        End
95582>>>>>>
95582>>>>>        
95582>>>>>        Set pbCanceled to False
95583>>>>>        Set pSelectedRows to SelRowsIndexes
95584>>>>>        
95584>>>>>        Get peUpdateMode to eUpdateMode
95585>>>>>        // if non-invoking there is by definition, no move value out
95585>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95587>>>>>            
95587>>>>>            If (eUpdateMode=umPromptValue) Begin
95589>>>>>                Send OnMoveValueOutByValue
95590>>>>>            End
95590>>>>>>
95590>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
95593>>>>>                Send OnMoveValueOutByCustom
95594>>>>>            End
95594>>>>>>
95594>>>>>            Get phmPromptUpdateCallback to hmCallBack
95595>>>>>            If hmCallBack Begin
95597>>>>>                Send hmCallBack of hoInvokingObject Self
95598>>>>>            End
95598>>>>>>
95598>>>>>        End
95598>>>>>>
95598>>>>>        
95598>>>>>        Send Close_Panel
95599>>>>>    End_Procedure
95600>>>>>    
95600>>>>>    // augment to send OnRestoreDefaults.
95600>>>>>    Procedure Release_Focus
95602>>>>>        Integer eUpdateMode
95602>>>>>        Get peUpdateMode to eUpdateMode
95603>>>>>        Forward Send Release_Focus
95605>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95607>>>>>            Send OnRestoreDefaults
95608>>>>>        End
95608>>>>>>
95608>>>>>    End_Procedure
95609>>>>>    
95609>>>>>    Function SelectedRowIds Returns RowID[]
95611>>>>>        RowID[] SelectedRowids
95612>>>>>        Integer[] SelectedRows
95613>>>>>        Integer i iRows
95613>>>>>        Handle hoDataSource
95613>>>>>        Get phoDataSource to hoDataSource
95614>>>>>        Get pSelectedRows to SelectedRows
95615>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95616>>>>>        For i from 0 to (iRows-1)
95622>>>>>>
95622>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
95623>>>>>        Loop
95624>>>>>>
95624>>>>>        Function_Return SelectedRowids
95625>>>>>    End_Function
95626>>>>>    
95626>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
95628>>>>>        String[] SelectedValues
95629>>>>>        Integer[] SelectedRows
95630>>>>>        Integer i iRows
95630>>>>>        Handle hoCol
95630>>>>>        Get ColumnObject iCol to hoCol
95631>>>>>        Get pSelectedRows to SelectedRows
95632>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95633>>>>>        For i from 0 to (iRows-1)
95639>>>>>>
95639>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
95640>>>>>        Loop
95641>>>>>>
95641>>>>>        Function_Return SelectedValues
95642>>>>>    End_Function
95643>>>>>    
95643>>>>>    Procedure Ok Returns Integer
95645>>>>>        Send ClosePromptList
95646>>>>>    End_Procedure
95647>>>>>    
95647>>>>>    Procedure Cancel Returns Integer
95649>>>>>        Send Close_Panel
95650>>>>>    End_Procedure
95651>>>>>    
95651>>>>>    Procedure Search
95653>>>>>        Send Activate // give focus back to list so focus things are correct
95654>>>>>        Send Request_Search 0 0
95655>>>>>    End_Procedure
95656>>>>>    
95656>>>>>    // do a search using the current keys in the search key buffer for the sort column.
95656>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
95656>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
95656>>>>>    Procedure Request_SearchEx
95658>>>>>        tGridKeyPair[] Keys
95658>>>>>        tGridKeyPair[] Keys
95659>>>>>        Integer iCol
95659>>>>>        Handle hoCol hoSearchDialog
95659>>>>>        Boolean bOk
95659>>>>>        String sValue
95659>>>>>        
95659>>>>>        Get piSortColumn to iCol
95660>>>>>        If (iCol<>-1) Begin
95662>>>>>            Get ColumnObject iCol to hoCol
95663>>>>>            Get pSearchKeys to Keys
95664>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
95665>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
95666>>>>>            If bOk Begin
95668>>>>>                Send RequestFindColumnValue iCol sValue True 0
95669>>>>>            End
95669>>>>>>
95669>>>>>            Send Destroy of hoSearchDialog
95670>>>>>        End
95670>>>>>>
95670>>>>>        Send ClearSearchRequest // clear the search keys
95671>>>>>    End_Procedure
95672>>>>>    
95672>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
95672>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
95674>>>>>        tGridKeyPair[] Keys
95674>>>>>        tGridKeyPair[] Keys
95675>>>>>        tGridKeyPair KeyPair
95675>>>>>        tGridKeyPair KeyPair
95675>>>>>        Set pbRequestSearch to True
95676>>>>>        Move iKeyCode to KeyPair.KeyCode
95677>>>>>        Move iShiftCode to KeyPair.ShiftCode
95678>>>>>        Get pSearchKeys to Keys
95679>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
95680>>>>>        Set pSearchKeys to Keys
95681>>>>>    End_Procedure
95682>>>>>    
95682>>>>>    Procedure ClearSearchRequest
95684>>>>>        tGridKeyPair[] SearchKeys
95684>>>>>        tGridKeyPair[] SearchKeys
95685>>>>>        Set pSearchKeys to SearchKeys
95686>>>>>        Set pbRequestSearch to False
95687>>>>>    End_Procedure
95688>>>>>    
95688>>>>>End_Class
95689>>>>>
95689>>>Use cDbUpdateFunctionLibrary.pkg
95689>>>Use MSSqldrv.pkg
95689>>>Use db2_drv.pkg
95689>>>Use odbc_drv.pkg
95689>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
95689>>>>>//****************************************************************************
95689>>>>>// $Module type: Class
95689>>>>>// $Module name: cRDCModalPanel
95689>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
95689>>>>>// Created     : 2014-03-17 @ 12:33
95689>>>>>//
95689>>>>>// Description :
95689>>>>>//
95689>>>>>// $Rev History:
95689>>>>>//    2014-03-17  Module header created
95689>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95689>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95689>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95689>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95689>>>>>// in the help folder for more details.
95689>>>>>//
95689>>>>>//****************************************************************************
95689>>>>>Use Windows.pkg
95689>>>>>Use cCJCommandBarSystem.pkg   
95689>>>>>Use cCJSkinFramework.pkg
95689>>>>>
95689>>>>>Class cRDCModalPanel is a ModalPanel
95690>>>>>
95690>>>>>    Procedure Construct_Object
95692>>>>>        Forward Send Construct_Object
95694>>>>>
95694>>>>>        Set Maximize_Icon to True
95695>>>>>        Set Minimize_Icon to False
95696>>>>>        Set Border_Style to Border_Thick
95697>>>>>        Set Locate_Mode to Center_On_Parent
95698>>>>>
95698>>>>>        Property String Private_Icon
95699>>>>>        Property Handle phoDialogCommandbar
95700>>>>>    End_Procedure
95701>>>>>
95701>>>>>    Procedure Set Icon String sIcon
95703>>>>>        Forward Set Icon to sIcon
95705>>>>>        Set Private_Icon to sIcon
95706>>>>>    End_Procedure
95707>>>>>
95707>>>>>    Function Icon Returns String
95709>>>>>        String sIcon
95709>>>>>        Get Private_Icon to sIcon
95710>>>>>        Function_Return sIcon
95711>>>>>    End_Function
95712>>>>>
95712>>>>>    Procedure Page Integer iPageObject
95714>>>>>        String sIcon
95714>>>>>        Integer hWnd
95714>>>>>        
95714>>>>>        Forward Send Page iPageObject
95716>>>>>        Get Private_Icon to sIcon
95717>>>>>        If (sIcon <> "") Begin
95719>>>>>            Set Icon to sIcon
95720>>>>>        End
95720>>>>>>
95720>>>>>
95720>>>>>        Get Window_Handle to hWnd
95721>>>>>
95721>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
95723>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
95724>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
95725>>>>>        End
95725>>>>>>
95725>>>>>    End_Procedure
95726>>>>>
95726>>>>>    // Put a status bar at the bottom of the panel, which makes
95726>>>>>    // status_help work and puts a gripper in the lower right corner.
95726>>>>>    Procedure End_Construct_Object
95728>>>>>        Integer iStyle iSize iOffset
95728>>>>>
95728>>>>>        Forward Send End_Construct_Object
95730>>>>>
95730>>>>>        Get Border_Style to iStyle
95731>>>>>        Move 8 to iOffset
95732>>>>>        If (iStyle = Border_Thick) Begin
95734>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
95736>>>>>                Object oStatusBar is a cCJStatusBar
95738>>>>>                    Set phoDialogCommandbar to Self
95739>>>>>                    Object oStatusIdle is a cCJStatusBarPane
95741>>>>>                        Set piId to sbpIDIdlePane
95742>>>>>                        Set pbStyleStretch to True
95743>>>>>                    End_Object
95744>>>>>                End_Object
95745>>>>>            End_Object
95746>>>>>            Get Size to iSize
95747>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
95748>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
95749>>>>>        End
95749>>>>>>
95749>>>>>
95749>>>>>    End_Procedure
95750>>>>>
95750>>>>>    Procedure Popup
95752>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
95753>>>>>        Forward Send Popup
95755>>>>>    End_Procedure
95756>>>>>
95756>>>>>End_Class
95757>>>
95757>>>Object oDatabaseSelection_sl is a cRDCModalPanel
95759>>>    Set Label to "SQL Database Selection"
95760>>>    Set Size to 119 183
95761>>>    Set piMinSize to 89 170
95762>>>    Set Location to 2 2
95763>>>    Set Border_Style to Border_Thick
95764>>>    Set Icon to "DatabaseLookup1.ico"
95765>>>
95765>>>    Property String[] psTheData
95767>>>
95767>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
95769>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
95771>>>        End_Object
95772>>>    End
95772>>>>
95772>>>
95772>>>    Object oSelList is a cCJGridPromptList
95774>>>        Set Size to 89 167
95775>>>        Set Location to 6 6
95776>>>        Set peAnchors to anAll
95777>>>        Set pbAllowColumnRemove to False
95778>>>        Set pbUseAlternateRowBackgroundColor to True
95779>>>        Set pbGrayIfDisable to False
95780>>>        Set pbHeaderReorders to False
95781>>>        Set pbHeaderSelectsColumn to False
95782>>>        Set pbHeaderTogglesDirection to False
95783>>>        Set pbShadeSortColumn to False
95784>>>        Set piFocusCellBackColor to clDkGray
95785>>>
95785>>>        Object oName is a cCJGridColumn
95787>>>            Set piWidth to 334
95788>>>            Set psCaption to "Database Name"
95789>>>        End_Object
95790>>>
95790>>>        Procedure Activating
95793>>>            tDataSourceRow[] MyData
95793>>>            tDataSourceRow[] MyData
95794>>>            Handle hoDataSource
95794>>>            String[] sTheData
95795>>>            Integer iCount iSize
95795>>>
95795>>>            Send Cursor_Wait of Cursor_Control
95796>>>            Forward Send Activating
95798>>>
95798>>>            Get psTheData to sTheData
95799>>>            Move (SizeOfArray(sTheData)) to iSize
95800>>>            Decrement iSize
95801>>>            For iCount from 0 to iSize
95807>>>>
95807>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
95808>>>            Loop
95809>>>>
95809>>>
95809>>>            Get phoDataSource to hoDataSource
95810>>>            Send InitializeData of hoDataSource MyData
95811>>>            Send Cursor_Ready of Cursor_Control
95812>>>        End_Procedure
95813>>>
95813>>>    End_Object
95814>>>
95814>>>    Object oOK_Btn is a Button
95816>>>        Set Size to 14 50
95817>>>        Set Label    to "&OK"
95818>>>        Set Location to 98 68
95819>>>        Set peAnchors To anBottomRight
95820>>>
95820>>>        Procedure OnClick
95823>>>            Send Ok of oSelList
95824>>>        End_Procedure
95825>>>
95825>>>    End_Object
95826>>>
95826>>>    Object oCancel_Btn is a Button
95828>>>        Set Size to 14 50
95829>>>        Set Label    to "&Cancel"
95830>>>        Set Location to 98 123
95831>>>        Set peAnchors to anBottomRight
95832>>>
95832>>>        Procedure OnClick
95835>>>            Send Close_Panel
95836>>>        End_Procedure
95837>>>
95837>>>    End_Object
95838>>>
95838>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95839>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95840>>>End_Object
95841>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
95841>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
95841>>>Use Windows.pkg
95841>>>Use vWin32fh.pkg
95841>>>
95841>>>Object oSQLDatabaseBackup_dg is a ModalPanel
95843>>>    Set Size to 104 298
95844>>>    Set Label to "SQL Database Backup"
95845>>>    Set piMinSize to 89 211
95846>>>    Set Location to 2 4
95847>>>    Set Border_Style To Border_Thick
95848>>>
95848>>>    Property Boolean pbOK False
95850>>>    Property String  psDatabase
95852>>>    Property String  psPath
95854>>>    Property String  psBackupName
95856>>>
95856>>>    Object oDatabase_fm is a Form
95858>>>        Set Size to 13 204
95859>>>        Set Location to 14 71
95860>>>        Set Label_Justification_Mode to JMode_Right
95861>>>        Set Label_Col_Offset to 2
95862>>>        Set Label to "Database Name"
95863>>>        Set Enabled_State to False
95864>>>        Set peAnchors to anTopLeftRight
95865>>>
95865>>>        Procedure Page Integer iPageObject
95868>>>            String sValue
95868>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
95869>>>            Set Value to sValue
95870>>>            Set psDatabase to sValue
95871>>>            Forward Send Page iPageObject
95873>>>        End_Procedure
95874>>>
95874>>>    End_Object
95875>>>
95875>>>    Object oBackupName_fm is a Form
95877>>>        Set Size to 13 204
95878>>>        Set Location to 29 71
95879>>>        Set Label_Justification_Mode to JMode_Right
95880>>>        Set Label_Col_Offset to 2
95881>>>        Set Label to "Backup Name"
95882>>>        Set peAnchors to anTopLeftRight
95883>>>
95883>>>        Procedure Page Integer iPageObject
95886>>>            String sValue
95886>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
95887>>>            Set Value to sValue
95888>>>            Forward Send Page iPageObject
95890>>>        End_Procedure
95891>>>
95891>>>        Procedure OnChange
95894>>>            String sValue
95894>>>            Get Value to sValue
95895>>>            Set psBackupName to sValue
95896>>>        End_Procedure
95897>>>
95897>>>    End_Object
95898>>>
95898>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
95900>>>        Set Size to 10 50
95901>>>        Set Location to 50 71
95902>>>        Set Label to "Use Default SQL Backup Folder"
95903>>>        Set Checked_State to True
95904>>>
95904>>>        Procedure OnChange
95907>>>            Boolean bChecked
95907>>>            Get Checked_State to bChecked
95908>>>            Set Enabled_State of oPath_fm to (bChecked = False)
95909>>>        End_Procedure
95910>>>
95910>>>    End_Object
95911>>>
95911>>>    Object oPath_fm is a Form
95913>>>        Set Size to 13 204
95914>>>        Set Location to 62 71
95915>>>        Set Label_Justification_Mode to JMode_Right
95916>>>        Set Label_Col_Offset to 2
95917>>>        Set Label to "Path"
95918>>>        Set Prompt_Button_Mode to PB_PromptOn
95919>>>        Set peAnchors to anTopLeftRight
95920>>>        Set Enabled_State to False
95921>>>
95921>>>        Procedure Page Integer iPageObject
95924>>>            String sValue
95924>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
95925>>>            Get vFolderFormat sValue to sValue
95926>>>            Move (sValue + "Backup") to sValue
95927>>>            Set Value to sValue
95928>>>            Forward Send Page iPageObject
95930>>>        End_Procedure
95931>>>
95931>>>        Procedure Prompt
95934>>>            String sPath sFileMask sRetval
95934>>>
95934>>>            Get Value to sPath
95935>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
95936>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
95937>>>            If (sRetval <> "") Begin
95939>>>                Get ParseFolderName sRetval to sPath
95940>>>                If (Right(sPath, 1) ="\") Begin
95942>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
95943>>>                End
95943>>>>
95943>>>                Set Value to sPath
95944>>>            End
95944>>>>
95944>>>        End_Procedure
95945>>>
95945>>>        Procedure OnChange
95948>>>            String sValue
95948>>>            Get Value to sValue
95949>>>            Set psPath to sValue
95950>>>        End_Procedure
95951>>>
95951>>>    End_Object
95952>>>
95952>>>    Object oOK_Btn is a Button
95954>>>        Set Label    to "&OK"
95955>>>        Set Location to 81 169
95956>>>        Set peAnchors to anBottomRight
95957>>>
95957>>>        Procedure OnClick
95960>>>            Set pbOK to True
95961>>>            Send Close_Panel
95962>>>        End_Procedure
95963>>>
95963>>>    End_Object
95964>>>
95964>>>    Object oCancel_Btn is a Button
95966>>>        Set Label    to "&Cancel"
95967>>>        Set Location to 81 224
95968>>>        Set peAnchors to anBottomRight
95969>>>
95969>>>        Procedure OnClick
95972>>>            Set pbOK to False
95973>>>            Send Close_Panel
95974>>>        End_Procedure
95975>>>
95975>>>    End_Object
95976>>>
95976>>>    Object oButton1 is a Button
95978>>>        Set Size to 14 96
95979>>>        Set Location to 80 32
95980>>>        Set Label to "Enum table types"
95981>>>
95981>>>        Procedure OnClick
95984>>>            String sDriverID
95984>>>            tSQLConnection SQLConnection
95984>>>            tSQLConnection SQLConnection
95984>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
95985>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
95986>>>        End_Procedure
95987>>>
95987>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
95990>>>            Handle hoCLIHandler
95990>>>            Integer iNumTables iTableCount
95990>>>
95990>>>            Get Create U_cCLIHandler to hoCLIhandler
95991>>>            If (hoCLIHandler > 0) Begin
95993>>>                Set psDriverID of hoCLIHandler to sDriver
95994>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
95995>>>                For iTableCount from 1 to iNumTables
96001>>>>
96001>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96003>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96005>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96007>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96009>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96009>>>//                    For iColumnCount from 1 to iNumColumns
96009>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96009>>>//                    Loop
96009>>>                    Showln
96010>>>                Loop
96011>>>>
96011>>>                Send Destroy of hoCLIHandler
96012>>>            End
96012>>>>
96012>>>        End_Procedure
96013>>>
96013>>>    End_Object
96014>>>
96014>>>    Procedure Page Integer iPageObject
96017>>>        Set Icon to "DbBackup1.ico"
96018>>>        Forward Send Page iPageObject
96020>>>    End_Procedure
96021>>>
96021>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96022>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96023>>>
96023>>>End_Object
96024>>>
96024>>>// *** General purpose access method for this dialog ***
96024>>>Function MakeSQLDatabaseBackup Returns Boolean
96027>>>    Handle ho
96027>>>    Boolean bOK bDefault
96027>>>    String sDatabase sPath sBackupName
96027>>>
96027>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96028>>>    Set pbOK of ho to False
96029>>>    Send Popup of ho
96030>>>
96030>>>    Get pbOk of ho to bOK
96031>>>    If (bOK = True) Begin
96033>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96034>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96035>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96036>>>        If (bDefault = False) Begin
96038>>>            Get Value of (oPath_fm(ho)) to sPath
96039>>>        End
96039>>>>
96039>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96040>>>    End
96040>>>>
96040>>>
96040>>>    Function_Return bOK
96041>>>End_Function
96042>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96042>>>Use Windows.pkg
96042>>>Use DFClient.pkg
96042>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96042>>>>>// Provides support for db aware scrolling containers.
96042>>>>>// Scrolling containers is provided by creating two objects,
96042>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96042>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96042>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96042>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96042>>>>>
96042>>>>>Use DFClient.pkg
96042>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96042>>>>>>>// Mixin classes for scrolling container support:
96042>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96042>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96042>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96042>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96042>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96042>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96042>>>>>>>
96042>>>>>>>Use Windows.pkg
96042>>>>>>>Use Winuser.pkg
96042>>>>>>>Use tWinStructs.pkg
96042>>>>>>>
96042>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96042>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96042>>>>>>>// support for the scrolling client area mixin object.
96042>>>>>>>
96042>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96043>>>>>>>    
96043>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96045>>>>>>>        
96045>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96046>>>>>>>        Set Border_Style to Border_None
96047>>>>>>>        
96047>>>>>>>        Property Boolean pbAutoScroll True
96048>>>>>>>        Property Boolean pbAutoScrollFocus True
96049>>>>>>>        Property Integer piAutoScrollMarginX 5
96050>>>>>>>        Property Integer piAutoScrollMarginY 5
96051>>>>>>>        Property Integer piAutoScrollMinX 0
96052>>>>>>>        Property Integer piAutoScrollMinY 0
96053>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96054>>>>>>>        
96054>>>>>>>        
96054>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96055>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96056>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96057>>>>>>>        // keeps track of scrolling
96057>>>>>>>        Property Integer piCurrentVertScrolled 0
96058>>>>>>>        Property Integer piCurrentHorzScrolled 0
96059>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96060>>>>>>>        Delegate Set phoScrollingClientArea to Self
96062>>>>>>>        
96062>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96062>>>>>>>        Property Boolean pbTabWorkspaceView False
96063>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96063>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96064>>>>>>>    End_Procedure
96065>>>>>>>    
96065>>>>>>>    // low level event sent from windows.
96065>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96067>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96067>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96068>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96069>>>>>>>        If (wParam<0) Begin
96071>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96072>>>>>>>        End
96072>>>>>>>>
96072>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96073>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96074>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96074>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96075>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96076>>>>>>>        // If we have enough Clicks send OnMouseWheel
96076>>>>>>>        If (iClicks<>0) Begin
96078>>>>>>>            Send OnMouseWheel iClicks iKeys
96079>>>>>>>        End
96079>>>>>>>>
96079>>>>>>>        // tell windows that we've handled the event.
96079>>>>>>>        Set Windows_Override_State to True
96080>>>>>>>    End_Procedure
96081>>>>>>>    
96081>>>>>>>    
96081>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96081>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96083>>>>>>>        Integer iLineScrollUnit
96083>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96084>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96085>>>>>>>    End_Procedure
96086>>>>>>>    
96086>>>>>>>    // should be sent by WM_VSCROLL
96086>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96088>>>>>>>        Boolean bOk
96088>>>>>>>        tWinScrollInfo ScrollInfo
96088>>>>>>>        tWinScrollInfo ScrollInfo
96088>>>>>>>        Integer iLineScrollUnit
96088>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96089>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96090>>>>>>>        If bOk Begin
96092>>>>>>>            
96092>>>>>>>            Case Begin
96092>>>>>>>                Case (iType=SB_PAGEDOWN)
96094>>>>>>>                    Send VScroll ScrollInfo.nPage
96095>>>>>>>                    Case Break
96096>>>>>>>                
96096>>>>>>>                Case (iType=SB_PAGEUP)
96099>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96100>>>>>>>                    Case Break
96101>>>>>>>                
96101>>>>>>>                Case (iType=SB_LINEDOWN)
96104>>>>>>>                    Send VScroll iLineScrollUnit
96105>>>>>>>                    Case Break
96106>>>>>>>                
96106>>>>>>>                Case (iType=SB_LINEUP)
96109>>>>>>>                    Send VScroll (-iLineScrollUnit)
96110>>>>>>>                    Case Break
96111>>>>>>>                
96111>>>>>>>                Case (iType=SB_BOTTOM)
96114>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96115>>>>>>>                    Case Break
96116>>>>>>>                
96116>>>>>>>                Case (iType=SB_Top)
96119>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96120>>>>>>>                    Case Break
96121>>>>>>>                
96121>>>>>>>                Case (iType=SB_THUMBPOSITION)
96124>>>>>>>                    Case Break
96125>>>>>>>                
96125>>>>>>>                Case (iType=SB_THUMBTRACK)
96128>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96129>>>>>>>                    Case Break
96130>>>>>>>            Case End
96130>>>>>>>        End
96130>>>>>>>>
96130>>>>>>>    End_Procedure
96131>>>>>>>    
96131>>>>>>>    // should be sent by WM_HSCROLL
96131>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96133>>>>>>>        Boolean bOk
96133>>>>>>>        tWinScrollInfo ScrollInfo
96133>>>>>>>        tWinScrollInfo ScrollInfo
96133>>>>>>>        Integer iLineScrollUnit
96133>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96134>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96135>>>>>>>        If bOk Begin
96137>>>>>>>            
96137>>>>>>>            Case Begin
96137>>>>>>>                Case (iType=SB_PAGEDOWN)
96139>>>>>>>                    Send hScroll ScrollInfo.nPage
96140>>>>>>>                    Case Break
96141>>>>>>>                
96141>>>>>>>                Case (iType=SB_PAGEUP)
96144>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96145>>>>>>>                    Case Break
96146>>>>>>>                
96146>>>>>>>                Case (iType=SB_LINEDOWN)
96149>>>>>>>                    Send hScroll iLineScrollUnit
96150>>>>>>>                    Case Break
96151>>>>>>>                
96151>>>>>>>                Case (iType=SB_LINEUP)
96154>>>>>>>                    Send hScroll (-iLineScrollUnit)
96155>>>>>>>                    Case Break
96156>>>>>>>                
96156>>>>>>>                Case (iType=SB_BOTTOM)
96159>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96160>>>>>>>                    Case Break
96161>>>>>>>                
96161>>>>>>>                Case (iType=SB_Top)
96164>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96165>>>>>>>                    Case Break
96166>>>>>>>                
96166>>>>>>>                Case (iType=SB_THUMBPOSITION)
96169>>>>>>>                    Case Break
96170>>>>>>>                
96170>>>>>>>                Case (iType=SB_THUMBTRACK)
96173>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96174>>>>>>>                    Case Break
96175>>>>>>>            Case End
96175>>>>>>>        End
96175>>>>>>>>
96175>>>>>>>    End_Procedure
96176>>>>>>>    
96176>>>>>>>    
96176>>>>>>>    // this calls SetScrollInfo with proper info
96176>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96178>>>>>>>        tWinScrollInfo ScrollInfo
96178>>>>>>>        tWinScrollInfo ScrollInfo
96178>>>>>>>        Integer iVoid
96178>>>>>>>        Handle hWnd
96178>>>>>>>        Boolean bShow
96178>>>>>>>        
96178>>>>>>>        Delegate Get Window_Handle to hWnd
96180>>>>>>>        If (hWnd <> 0) Begin
96182>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96183>>>>>>>            
96183>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96184>>>>>>>            Get pbShowDisabledScrollBar to bShow
96185>>>>>>>            If bShow Begin
96187>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96188>>>>>>>            End
96188>>>>>>>>
96188>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96189>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96190>>>>>>>            Move iPageSize to ScrollInfo.nPage
96191>>>>>>>            Move 0 to ScrollInfo.nPos
96192>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96193>>>>>>>            
96193>>>>>>>        End
96193>>>>>>>>
96193>>>>>>>    End_Procedure
96194>>>>>>>    
96194>>>>>>>    // this wraps GetScrollInfo
96194>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96196>>>>>>>        Boolean bOk
96196>>>>>>>        Handle hWnd
96196>>>>>>>        
96196>>>>>>>        Delegate Get Window_Handle to hWnd
96198>>>>>>>        If (hWnd <> 0) Begin
96200>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96201>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96202>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96203>>>>>>>        End
96203>>>>>>>>
96203>>>>>>>        Function_Return bOk
96204>>>>>>>    End_Function
96205>>>>>>>    
96205>>>>>>>    // this wraps SetScrollPos
96205>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96207>>>>>>>        Integer iVoid
96207>>>>>>>        Handle hWnd
96207>>>>>>>        
96207>>>>>>>        Delegate Get Window_Handle to hWnd
96209>>>>>>>        If (hWnd <> 0) Begin
96211>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96212>>>>>>>        End
96212>>>>>>>>
96212>>>>>>>    End_Procedure
96213>>>>>>>    
96213>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96213>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96213>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96215>>>>>>>        Send ScrollClientArea
96216>>>>>>>    End_Procedure
96217>>>>>>>    
96217>>>>>>>    // augment to handle the scrolling area initialization.
96217>>>>>>>    Procedure Add_Focus Handle hoParent
96219>>>>>>>        Forward Send Add_Focus hoParent
96221>>>>>>>        // at this the scrolling container and client area should both be paged.
96221>>>>>>>        // child objects ae also paged with initial anchors applied
96221>>>>>>>        Send CalculateAutoScrollMinimums
96222>>>>>>>    End_Procedure
96223>>>>>>>    
96223>>>>>>>    Procedure Page Integer iPage
96225>>>>>>>        Forward Send Page iPage
96227>>>>>>>        If iPage Begin
96229>>>>>>>            // at this the scrolling container and client area should both be paged
96229>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96229>>>>>>>            // the child items are paged (else they may get anchored oddly)
96229>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96229>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96229>>>>>>>            // before they were really needed. This should be more accurate
96229>>>>>>>            Send SetScrollBarInfo True 0 0 0
96230>>>>>>>            Send SetScrollBarInfo False 0 0 0
96231>>>>>>>        End
96231>>>>>>>>
96231>>>>>>>    End_Procedure
96232>>>>>>>    
96232>>>>>>>    // determine scrolling minimums and set the client area as required.
96232>>>>>>>    
96232>>>>>>>    Procedure CalculateAutoScrollMinimums
96234>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96234>>>>>>>        Integer iAutoMinX iAutoMinY
96234>>>>>>>        Boolean bAutoScroll
96234>>>>>>>        Handle hoNext hoFirst
96234>>>>>>>        
96234>>>>>>>        Get pbAutoScroll to bAutoScroll
96235>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96236>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96237>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96238>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96239>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96240>>>>>>>        Set piMinimumHeight to iAutoMinY
96241>>>>>>>        Set piMinimumWidth to iAutoMinX
96242>>>>>>>        
96242>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96244>>>>>>>            
96244>>>>>>>            Get Next_Level to hoFirst
96245>>>>>>>            Move hoFirst to hoNext
96246>>>>>>>            If (hoFirst) Begin
96248>>>>>>>                Repeat
96248>>>>>>>>
96248>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96249>>>>>>>                    Get GuiLocation of hoNext to iLoc
96250>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96251>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96252>>>>>>>                    Get Next_Focus of hoNext to hoNext
96253>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96255>>>>>>>                
96255>>>>>>>                If (iAutoMinY=0) Begin
96257>>>>>>>                    Get piAutoScrollMarginY to iMargin
96258>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96259>>>>>>>                End
96259>>>>>>>>
96259>>>>>>>                
96259>>>>>>>                If (iAutoMinX=0) Begin
96261>>>>>>>                    Get piAutoScrollMarginX to iMargin
96262>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96263>>>>>>>                    
96263>>>>>>>                End
96263>>>>>>>>
96263>>>>>>>            End
96263>>>>>>>>
96263>>>>>>>        End
96263>>>>>>>>
96263>>>>>>>        
96263>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96263>>>>>>>        Broadcast Set pbAnchorCreated to False
96265>>>>>>>        Send ScrollClientArea
96266>>>>>>>        // after the scroll set up, reinitialize all anchors.
96266>>>>>>>        Broadcast Send DoCreateAnchors
96268>>>>>>>    End_Procedure
96269>>>>>>>    
96269>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96269>>>>>>>    // work of scrolling.
96269>>>>>>>    
96269>>>>>>>    Procedure ScrollClientArea
96271>>>>>>>        Integer iSiz
96271>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96271>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96271>>>>>>>        Integer iSzY iSzX iLocX iLocY
96271>>>>>>>        
96271>>>>>>>        Delegate Get GuiClientSize to iSiz
96273>>>>>>>        Move (Hi(iSiz)) to iHeight
96274>>>>>>>        Move (Low(iSiz)) to iWidth
96275>>>>>>>        
96275>>>>>>>        // Vertical scrolling
96275>>>>>>>        
96275>>>>>>>        Get piMinimumHeight to iOrig
96276>>>>>>>        Get piMinimumWidth to iWOrig
96277>>>>>>>        
96277>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96279>>>>>>>            
96279>>>>>>>            If (iOrig<>0) Begin
96281>>>>>>>                Get piCurrentVertScrolled to iHCur
96282>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96282>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96284>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96285>>>>>>>                    Set piCurrentVertScrolled to iHCur
96286>>>>>>>                End
96286>>>>>>>>
96286>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96288>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96289>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96290>>>>>>>                End
96290>>>>>>>>
96290>>>>>>>                Else Begin
96291>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96292>>>>>>>                End
96292>>>>>>>>
96292>>>>>>>            End
96292>>>>>>>>
96292>>>>>>>            
96292>>>>>>>            // Horiz scrolling
96292>>>>>>>            
96292>>>>>>>            Get piCurrentHorzScrolled to iWCur
96293>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96293>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96295>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96296>>>>>>>                Set piCurrentHorzScrolled to iWCur
96297>>>>>>>            End
96297>>>>>>>>
96297>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96299>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96300>>>>>>>                Send SetScrollBarPosInfo False iWCur
96301>>>>>>>            End
96301>>>>>>>>
96301>>>>>>>            Else Begin
96302>>>>>>>                Send SetScrollBarInfo False 0 0 0
96303>>>>>>>            End
96303>>>>>>>>
96303>>>>>>>        End
96303>>>>>>>>
96303>>>>>>>        
96303>>>>>>>        // this could change depending on scrollbars appearing or not
96303>>>>>>>        Delegate Get GuiClientSize to iSiz
96305>>>>>>>        
96305>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96305>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96305>>>>>>>        // This is required to make anchors work sensibly
96305>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96306>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96307>>>>>>>        Move (-iHCur) to iLocY
96308>>>>>>>        Move (-iWCur) to iLocX
96309>>>>>>>        
96309>>>>>>>        // Allow chance to make modifications
96309>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96310>>>>>>>        
96310>>>>>>>        Set GuiSize to iSzY iSzX
96311>>>>>>>        // if we've scrolled, we need to reposition the container
96311>>>>>>>        Set GuiLocation to iLocY iLocX
96312>>>>>>>    End_Procedure
96313>>>>>>>    
96313>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96313>>>>>>>    // this way, it does not interfere with anchors.
96313>>>>>>>    
96313>>>>>>>    Procedure VScroll Integer iDelta
96315>>>>>>>        Integer iHeight iCur iOrig iSiz
96315>>>>>>>        Delegate Get GuiClientSize to iSiz
96317>>>>>>>        Move (hi(iSiz)) to iHeight
96318>>>>>>>        Get piCurrentVertScrolled to iCur
96319>>>>>>>        Get piMinimumHeight to iOrig
96320>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96322>>>>>>>            Procedure_Return
96323>>>>>>>        End
96323>>>>>>>>
96323>>>>>>>        // make sure delta is within range
96323>>>>>>>        If (iDelta+iCur<0) Begin
96325>>>>>>>            Move (-iCur) to iDelta
96326>>>>>>>        End
96326>>>>>>>>
96326>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96329>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96330>>>>>>>        End
96330>>>>>>>>
96330>>>>>>>        If (iDelta=0) ;            Procedure_Return
96333>>>>>>>        
96333>>>>>>>        Move (iCur + iDelta) to iCur
96334>>>>>>>        Set piCurrentVertScrolled to iCur
96335>>>>>>>        Send SetScrollBarPosInfo True iCur
96336>>>>>>>        Get GuiLocation to iSiz
96337>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96338>>>>>>>        Send ScrollClientArea
96339>>>>>>>    End_Procedure
96340>>>>>>>    
96340>>>>>>>    
96340>>>>>>>    Procedure HScroll Integer iDelta
96342>>>>>>>        Integer iHeight iCur iOrig iSiz
96342>>>>>>>        Delegate Get GuiClientSize to iSiz
96344>>>>>>>        Move (low(iSiz)) to iHeight
96345>>>>>>>        Get piCurrentHorzScrolled to iCur
96346>>>>>>>        Get piMinimumWidth to iOrig
96347>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96349>>>>>>>            Procedure_Return
96350>>>>>>>        End
96350>>>>>>>>
96350>>>>>>>        If (iDelta+iCur<0) Begin
96352>>>>>>>            Move (-iCur) to iDelta
96353>>>>>>>        End
96353>>>>>>>>
96353>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96356>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96357>>>>>>>        End
96357>>>>>>>>
96357>>>>>>>        If (iDelta=0) ;            Procedure_Return
96360>>>>>>>        
96360>>>>>>>        Move (iCur + iDelta) to iCur
96361>>>>>>>        Set piCurrentHorzScrolled to iCur
96362>>>>>>>        Send SetScrollBarPosInfo False iCur
96363>>>>>>>        Get GuiLocation to iSiz
96364>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96365>>>>>>>        Send ScrollClientArea
96366>>>>>>>    End_Procedure
96367>>>>>>>    
96367>>>>>>>    // make sure client is a 0,0
96367>>>>>>>    Procedure ScrollHome
96369>>>>>>>        Send SetVScrollbox SB_TOP 0
96370>>>>>>>        Send SetHScrollbox SB_TOP 0
96371>>>>>>>    End_Procedure
96372>>>>>>>    
96372>>>>>>>    // get relative GUI location of this object to the parent one passed.
96372>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96374>>>>>>>        Integer ivoid
96374>>>>>>>        tWinRect Rect0 Rect1
96374>>>>>>>        tWinRect Rect0 Rect1
96374>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96375>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96376>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96377>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96378>>>>>>>    End_Procedure
96379>>>>>>>    
96379>>>>>>>    // This scrolls this object into visual range.
96379>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96381>>>>>>>        Handle hoScrollingContainer
96381>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96381>>>>>>>        Integer iViewHeight iViewWidth
96381>>>>>>>        Integer iRelLocHeight iRelLocWidth
96381>>>>>>>        Integer iSize iControlHeight iControlWidth
96381>>>>>>>        Integer iScroll
96381>>>>>>>        Integer iMarginX iMarginY
96381>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96381>>>>>>>        
96381>>>>>>>        Get piAutoScrollMarginX to iMarginX
96382>>>>>>>        Get piAutoScrollMarginY to iMarginY
96383>>>>>>>        
96383>>>>>>>        // the scrolling container
96383>>>>>>>        Move Self to hoScrollingContainer
96384>>>>>>>        // the amount the SC is currently scrolled
96384>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96385>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96386>>>>>>>        
96386>>>>>>>        // size of view's client area (this is the viewport area)
96386>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96387>>>>>>>        Move (hi(iSize)) to iViewHeight
96388>>>>>>>        Move (low(iSize)) to iViewWidth
96389>>>>>>>        
96389>>>>>>>        // get this object's location relative to the scrolling container
96389>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96390>>>>>>>        
96390>>>>>>>        // we expect that the client size is the window size but just in case
96390>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96391>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96392>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96393>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96394>>>>>>>        
96394>>>>>>>        // the outer size of the control object
96394>>>>>>>        Get GUIWindowSize of hoControl to iSize
96395>>>>>>>        Move (hi(iSize)) to iControlHeight
96396>>>>>>>        Move (low(iSize)) to iControlWidth
96397>>>>>>>        
96397>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96397>>>>>>>        
96397>>>>>>>        // Vertical Scroll
96397>>>>>>>        
96397>>>>>>>        // Vertical Scroll down
96397>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96397>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96399>>>>>>>            
96399>>>>>>>            // set scroll amount so that the bottom of the control is visible
96399>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96400>>>>>>>            
96400>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96400>>>>>>>            // top of the object appears at the bottom
96400>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96402>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96403>>>>>>>            End
96403>>>>>>>>
96403>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96403>>>>>>>            If (iScroll>0) Begin
96405>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96406>>>>>>>            End
96406>>>>>>>>
96406>>>>>>>        End
96406>>>>>>>>
96406>>>>>>>        // else vertical scroll up
96406>>>>>>>        // We scroll if the top of the object is not visible.
96406>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96409>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96409>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96410>>>>>>>            If (iScroll<0) Begin
96412>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96413>>>>>>>            End
96413>>>>>>>>
96413>>>>>>>        End
96413>>>>>>>>
96413>>>>>>>        
96413>>>>>>>        // Horizonal Scroll
96413>>>>>>>        
96413>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96413>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96415>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96416>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96418>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96419>>>>>>>            End
96419>>>>>>>>
96419>>>>>>>            If (iScroll>0) Begin
96421>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96422>>>>>>>            End
96422>>>>>>>>
96422>>>>>>>        End
96422>>>>>>>>
96422>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96424>>>>>>>            // if this can fit by moving all the way to left, do so.
96424>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96426>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96427>>>>>>>            End
96427>>>>>>>>
96427>>>>>>>            Else Begin
96428>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96429>>>>>>>            End
96429>>>>>>>>
96429>>>>>>>            If (iScroll<0) Begin
96431>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96432>>>>>>>            End
96432>>>>>>>>
96432>>>>>>>        End
96432>>>>>>>>
96432>>>>>>>        
96432>>>>>>>        
96432>>>>>>>    End_Procedure
96433>>>>>>>    
96433>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96433>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96435>>>>>>>        Boolean bScrollOnFocus
96435>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96436>>>>>>>        If bScrollOnFocus Begin
96438>>>>>>>            Send ScrollObjectInRange hoControl
96439>>>>>>>        End
96439>>>>>>>>
96439>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96441>>>>>>>    End_Procedure
96442>>>>>>>    
96442>>>>>>>    
96442>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96444>>>>>>>        Boolean bCenter
96444>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96445>>>>>>>        Function_Return bCenter
96446>>>>>>>    End_Function
96447>>>>>>>    
96447>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96449>>>>>>>        Boolean bTabWorkspaceView
96449>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96450>>>>>>>        If bTabWorkspaceView Begin
96452>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96453>>>>>>>        End
96453>>>>>>>>
96453>>>>>>>    End_Procedure
96454>>>>>>>    
96454>>>>>>>    Function ParentView Returns Handle
96456>>>>>>>        Function_Return (Parent(Parent(Self)))
96457>>>>>>>    End_Function
96458>>>>>>>    
96458>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96460>>>>>>>        Integer iSize iMax iDiff
96460>>>>>>>        Handle hoView
96460>>>>>>>        Boolean bCenter bModal
96460>>>>>>>        Get ParentView to hoView
96461>>>>>>>        Get Block_Mouse_State of hoView to bModal
96462>>>>>>>        If not bModal Begin
96464>>>>>>>            Get CenterTabWorkspaceView to bCenter
96465>>>>>>>            Get GuiSize of hoView to iSize
96466>>>>>>>            Get piMaxSize of hoView to iMax
96467>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
96468>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
96470>>>>>>>                If bCenter Begin
96472>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
96473>>>>>>>                End
96473>>>>>>>>
96473>>>>>>>                Move (Low(iMax)) to iWidth
96474>>>>>>>            End
96474>>>>>>>>
96474>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
96476>>>>>>>                If bCenter Begin
96478>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
96479>>>>>>>                    Move (iLocy min 25) to  iLocY
96480>>>>>>>                End
96480>>>>>>>>
96480>>>>>>>                Move (Hi(imax)) to iHeight
96481>>>>>>>            End
96481>>>>>>>>
96481>>>>>>>        End
96481>>>>>>>>
96481>>>>>>>    End_Procedure
96482>>>>>>>    
96482>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
96482>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
96482>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
96482>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
96482>>>>>>>    // This should almost always yield the right answer.
96482>>>>>>>    // This is called by the scrolling container's end_constructor
96482>>>>>>>    Procedure AutoSetTabWorkspaceView
96484>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
96484>>>>>>>        Handle hoParent
96484>>>>>>>        Integer iSize
96484>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
96485>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
96487>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
96488>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
96488>>>>>>>            // change this after the commandbar is paged.
96488>>>>>>>            If (bTabView) Begin
96490>>>>>>>                Get ParentView to hoParent
96491>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
96492>>>>>>>                If (bIsView) Begin
96494>>>>>>>                    // set this as a tab workspace view
96494>>>>>>>                    Set pbTabWorkspaceView to True
96495>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
96495>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
96495>>>>>>>                    Set pbAutoScroll to True
96496>>>>>>>                    
96496>>>>>>>                End
96496>>>>>>>>
96496>>>>>>>            End
96496>>>>>>>>
96496>>>>>>>        End
96496>>>>>>>>
96496>>>>>>>    End_Procedure
96497>>>>>>>    
96497>>>>>>>End_Class
96498>>>>>>>
96498>>>>>>>// Container scrolling class support. Nothing in here is public
96498>>>>>>>Class cScrollingContainerMixin is a Mixin
96499>>>>>>>    
96499>>>>>>>    Procedure Define_cScrollingContainerMixin
96501>>>>>>>        Forward Set Border_Style to Border_None
96503>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
96504>>>>>>>        Forward Set peAnchors to anAll
96506>>>>>>>        
96506>>>>>>>        // forcing scrollbars right away seems to make painting better
96506>>>>>>>        Set Window_Style WS_HSCROLL to True
96507>>>>>>>        Set Window_Style WS_VSCROLL to True
96508>>>>>>>        
96508>>>>>>>        Property Handle phoScrollingClientArea 0
96509>>>>>>>    End_Procedure
96510>>>>>>>    
96510>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
96510>>>>>>>    Procedure Set peAnchors Integer eAnchors
96512>>>>>>>    End_Procedure
96513>>>>>>>    
96513>>>>>>>    // if a border style is set, it will not work. We won't let that happen
96513>>>>>>>    Procedure Set Border_Style Integer eStyle
96515>>>>>>>    End_Procedure
96516>>>>>>>    
96516>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
96516>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96518>>>>>>>        Handle hoClient
96518>>>>>>>        Get phoScrollingClientArea to hoClient
96519>>>>>>>        If hoClient Begin
96521>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
96522>>>>>>>        End
96522>>>>>>>>
96522>>>>>>>    End_Procedure
96523>>>>>>>    
96523>>>>>>>    // should be sent by WM_VSCROLL
96523>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96525>>>>>>>        Handle hoClient
96525>>>>>>>        Get phoScrollingClientArea to hoClient
96526>>>>>>>        If hoClient Begin
96528>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
96529>>>>>>>        End
96529>>>>>>>>
96529>>>>>>>    End_Procedure
96530>>>>>>>    
96530>>>>>>>    // should be sent by WM_HSCROLL
96530>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96532>>>>>>>        Handle hoClient
96532>>>>>>>        Get phoScrollingClientArea to hoClient
96533>>>>>>>        If hoClient Begin
96535>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
96536>>>>>>>        End
96536>>>>>>>>
96536>>>>>>>    End_Procedure
96537>>>>>>>    
96537>>>>>>>    // augmented to adjust its size to the size of the parent client area.
96537>>>>>>>    // After this is set, anchors will handle any further resizing.
96537>>>>>>>    Procedure Page Integer iState
96539>>>>>>>        Integer iSiz iHeight iWidth
96539>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
96539>>>>>>>        Boolean bGroup
96539>>>>>>>        Handle hoClient
96539>>>>>>>        If (iState =1) Begin
96541>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
96543>>>>>>>            // We have special code to support groups because they
96543>>>>>>>            // draw a border inside of the client rectangle
96543>>>>>>>            If bGroup Begin
96545>>>>>>>                Get Physical_FontSize to iFontSize
96546>>>>>>>                Move (Hi(iFontSize)) to iTop
96547>>>>>>>                Move 2 to iLeft
96548>>>>>>>                Move 2 to iRight
96549>>>>>>>                Move 2 to iBottom
96550>>>>>>>            End
96550>>>>>>>>
96550>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
96550>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
96550>>>>>>>            // makes anchors work properly with unpaged tab-pages
96550>>>>>>>            Delegate Get GetContainerClientSize to iSiz
96552>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
96553>>>>>>>            Set GuiLocation to iTop iLeft
96554>>>>>>>            Send Adjust_Logicals
96555>>>>>>>        End
96555>>>>>>>>
96555>>>>>>>        Forward Send Page iState
96557>>>>>>>    End_Procedure
96558>>>>>>>    
96558>>>>>>>    Procedure End_Construct_Object
96560>>>>>>>        Handle hoClient
96560>>>>>>>        Forward Send End_Construct_Object
96562>>>>>>>        Get phoScrollingClientArea to hoClient
96563>>>>>>>        If (hoClient) Begin
96565>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
96566>>>>>>>        End
96566>>>>>>>>
96566>>>>>>>    End_Procedure
96567>>>>>>>    
96567>>>>>>>End_Class
96568>>>>>
96568>>>>>Class cDbScrollingClientArea is a dbContainer3d
96569>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
96570>>>>>    Procedure Construct_Object
96572>>>>>        Forward Send Construct_Object
96574>>>>>        Send Define_cScrollingClientAreaMixin
96575>>>>>    End_Procedure
96576>>>>>End_Class
96577>>>>>
96577>>>>>
96577>>>>>
96577>>>>>Class cDbScrollingContainer is a dbContainer3d
96578>>>>>    Import_Class_Protocol cScrollingContainerMixin
96579>>>>>    Procedure Construct_Object
96581>>>>>        Forward Send Construct_Object
96583>>>>>        Send Define_cScrollingContainerMixin
96584>>>>>    End_Procedure
96585>>>>>End_Class
96586>>>Use cDbUpdateFunctionLibrary.pkg
96586>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
96586>>>>>//****************************************************************************
96586>>>>>// $Module type: Package
96586>>>>>// $Module name: cRDCButtonDPI.pkg
96586>>>>>//
96586>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96586>>>>>// Copyright (c) 2013 RDC Tools International
96586>>>>>// E-mail      : support@rdctools.com
96586>>>>>// Web-site    : http://www.rdctools.com
96586>>>>>//
96586>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96586>>>>>//
96586>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96586>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96586>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96586>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96586>>>>>// in the help folder for more details.
96586>>>>>//
96586>>>>>//****************************************************************************
96586>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
96586>>>>>>>//****************************************************************************
96586>>>>>>>// $Module type: Package
96586>>>>>>>// $Module name: cRDCButton.pkg
96586>>>>>>>//
96586>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96586>>>>>>>// Copyright (c) 2013 RDC Tools International
96586>>>>>>>// E-mail      : support@rdctools.com
96586>>>>>>>// Web-site    : http://www.rdctools.com
96586>>>>>>>//
96586>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96586>>>>>>>//
96586>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96586>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96586>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96586>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96586>>>>>>>// in the help folder for more details.
96586>>>>>>>//
96586>>>>>>>//****************************************************************************
96586>>>>>>>Use Windows.pkg
96586>>>>>>>Use Enclient.pkg
96586>>>>>>>Use errornum.inc
96586>>>>>>>
96586>>>>>>>Class cButtonIdleHandler is a cIdleHandler
96587>>>>>>>    Procedure Construct_Object
96589>>>>>>>        Forward Send Construct_Object
96591>>>>>>>
96591>>>>>>>    End_Procedure
96592>>>>>>>
96592>>>>>>>    Procedure OnIdle
96594>>>>>>>        Delegate Send DoUpdate
96596>>>>>>>    End_Procedure
96597>>>>>>>
96597>>>>>>>End_Class
96598>>>>>>>
96598>>>>>>>Class cRDCButton is a Button
96599>>>>>>>
96599>>>>>>>    Procedure Construct_Object
96601>>>>>>>        Forward Send Construct_Object
96603>>>>>>>
96603>>>>>>>        Property Boolean pbAutoEnable True
96604>>>>>>>
96604>>>>>>>        Property Boolean pbEnabled True
96605>>>>>>>
96605>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
96606>>>>>>>
96606>>>>>>>        On_Key kCancel Send CancelIfPopupObject
96607>>>>>>>    End_Procedure
96608>>>>>>>
96608>>>>>>>    Procedure CancelIfPopupObject
96610>>>>>>>        Boolean bIsInPopupObject
96610>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
96612>>>>>>>        If (bIsInPopupObject = True) Begin
96614>>>>>>>            Send Close_Panel
96615>>>>>>>        End
96615>>>>>>>>
96615>>>>>>>    End_Procedure
96616>>>>>>>
96616>>>>>>>    Procedure End_Construct_Object
96618>>>>>>>        String sTooltip sStatus_Help
96618>>>>>>>
96618>>>>>>>        Forward Send End_Construct_Object
96620>>>>>>>
96620>>>>>>>        Get psToolTip   to sTooltip
96621>>>>>>>        Get Status_Help to sStatus_Help
96622>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96624>>>>>>>            Set psToolTip to sStatus_Help
96625>>>>>>>        End
96625>>>>>>>>
96625>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
96627>>>>>>>            Set Status_Help to sToolTip
96628>>>>>>>        End
96628>>>>>>>>
96628>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96629>>>>>>>    End_Procedure
96630>>>>>>>
96630>>>>>>>    Procedure DoUpdate
96632>>>>>>>        If (pbAutoEnable(Self) = False) Begin
96634>>>>>>>            Procedure_Return
96635>>>>>>>        End
96635>>>>>>>>
96635>>>>>>>        Set Enabled_State to (IsEnabled(Self))
96636>>>>>>>    End_Procedure
96637>>>>>>>
96637>>>>>>>    Function IsEnabled Returns Boolean
96639>>>>>>>        Boolean bEnabled
96639>>>>>>>        Get pbEnabled to bEnabled
96640>>>>>>>        Function_Return bEnabled
96641>>>>>>>    End_Function
96642>>>>>>>
96642>>>>>>>    // Enable the idle handler timer when the button is activated
96642>>>>>>>    Procedure Activating
96644>>>>>>>        Forward Send Activating
96646>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96647>>>>>>>    End_Procedure
96648>>>>>>>
96648>>>>>>>    // Disable the idle handler when the button is deactivated
96648>>>>>>>    Procedure Deactivating
96650>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96651>>>>>>>        Forward Send Deactivating
96653>>>>>>>    End_Procedure
96654>>>>>>>
96654>>>>>>>End_Class
96655>>>>>
96655>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
96655>>>>>Class cRDCButtonDPI is a cRDCButton
96656>>>>>    Procedure Construct_Object
96658>>>>>        Integer iIconSize
96658>>>>>        Forward Send Construct_Object
96660>>>>>        Set piImageMarginLeft to 10
96661>>>>>    End_Procedure
96662>>>>>
96662>>>>>    // Returns: DPI setting as an integer.
96662>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
96662>>>>>    //                      iDPI=120 is "Medium setting" 125%
96662>>>>>    //                      iDPI= 144 is "Large setting" 150%
96662>>>>>    Function GetCurrentDPI Returns Integer
96664>>>>>        Handle hDC
96664>>>>>        Integer iPixelsX
96664>>>>>        Move (GetDC(0)) to hDC
96665>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
96666>>>>>        Move (ReleaseDC(0, hDC)) to hDC
96667>>>>>        Function_Return iPixelsX
96668>>>>>    End_Function
96669>>>>>
96669>>>>>    Function GetCorrectIconSize Returns Integer
96671>>>>>        Integer iPixelsX iIndex iSize
96671>>>>>        Integer[] iaSizes
96672>>>>>
96672>>>>>        Move 16 to iaSizes[0]
96673>>>>>        Move 24 to iaSizes[1]
96674>>>>>        Move 32 to iaSizes[2]
96675>>>>>        Move 48 to iaSizes[3]
96676>>>>>        Move 64 to iaSizes[4]
96677>>>>>
96677>>>>>        Get piImageSize to iSize  // the "100%" size
96678>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
96679>>>>>        Move (0 max iIndex) to iIndex
96680>>>>>        Get GetCurrentDPI to iPixelsX
96681>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
96681>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
96681>>>>>        // will increment iIndex as many times as we need here.
96681>>>>>        Case Begin
96681>>>>>            Case (iPixelsX > 144)
96683>>>>>                Increment iIndex
96684>>>>>            Case (iPixelsX = 144)
96687>>>>>                Increment iIndex
96688>>>>>            Case (iPixelsX = 120)
96691>>>>>                Increment iIndex
96692>>>>>        Case End
96692>>>>>        Move (iIndex min 4) to iIndex
96693>>>>>        Function_Return iaSizes[iIndex]
96694>>>>>    End_Function
96695>>>>>
96695>>>>>    Procedure Set psToolTip String sToolTip
96697>>>>>        String sStatusHelp
96697>>>>>
96697>>>>>        Get Status_Help to sStatusHelp
96698>>>>>        If (sStatusHelp = "") Begin
96700>>>>>            Set Status_Help to sToolTip
96701>>>>>        End
96701>>>>>>
96701>>>>>
96701>>>>>        Forward Set psToolTip to sToolTip
96703>>>>>    End_Procedure
96704>>>>>
96704>>>>>End_Class
96705>>>Use DatabaseSelection.dg
96705>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
96705>>>>>Use Windows.pkg
96705>>>>>Use cCJGridPromptList.pkg
96705>>>>>Use MSSqldrv.pkg
96705>>>>>Use db2_drv.pkg
96705>>>>>Use odbc_drv.pkg    
96705>>>>>Use cRDCModalPanel.pkg
96705>>>>>Use cDbUpdateFunctionLibrary.pkg
96705>>>>>
96705>>>>>Object oServerSelection_sl is a cRDCModalPanel
96707>>>>>    Set Size to 105 225
96708>>>>>    Set Label to "Database Server/DSN Selection"
96709>>>>>    Set piMinSize to 89 211
96710>>>>>    Set Location to 2 2
96711>>>>>    Set Icon to "ServerLookup1.ico"
96712>>>>>
96712>>>>>    Property String[] psTheData
96714>>>>>
96714>>>>>    Object oSelList is a cCJGridPromptList
96716>>>>>        Set Size to 72 215
96717>>>>>        Set Location to 6 6
96718>>>>>        Set peAnchors to anAll
96719>>>>>        Set pbAllowColumnRemove to False
96720>>>>>        Set pbUseAlternateRowBackgroundColor to True
96721>>>>>        Set pbGrayIfDisable to False
96722>>>>>        Set pbHeaderReorders to False
96723>>>>>        Set pbHeaderSelectsColumn to False
96724>>>>>        Set pbHeaderTogglesDirection to False
96725>>>>>        Set pbShadeSortColumn to False
96726>>>>>        Set piFocusCellBackColor to clDkGray
96727>>>>>
96727>>>>>        Object oName is a cCJGridColumn
96729>>>>>            Set piWidth to 358
96730>>>>>            Set psCaption to "Name"
96731>>>>>        End_Object
96732>>>>>
96732>>>>>        Procedure Activating
96735>>>>>            tDataSourceRow[] MyData
96735>>>>>            tDataSourceRow[] MyData
96736>>>>>            Handle hoDataSource
96736>>>>>            String[] sTheData
96737>>>>>            Integer iCount iSize
96737>>>>>
96737>>>>>            Send Cursor_Wait of Cursor_Control
96738>>>>>            Get psTheData to sTheData
96739>>>>>            Move (SizeOfArray(sTheData)) to iSize
96740>>>>>            Decrement iSize
96741>>>>>            For iCount from 0 to iSize
96747>>>>>>
96747>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96748>>>>>            Loop
96749>>>>>>
96749>>>>>
96749>>>>>            Forward Send Activating
96751>>>>>
96751>>>>>            Get phoDataSource to hoDataSource
96752>>>>>            Send InitializeData of hoDataSource MyData
96753>>>>>            Send Cursor_Ready of Cursor_Control
96754>>>>>        End_Procedure
96755>>>>>
96755>>>>>    End_Object
96756>>>>>
96756>>>>>    Object oOK_Btn is a Button
96758>>>>>        Set Size to 14 50
96759>>>>>        Set Label    to "&OK"
96760>>>>>        Set Location to 85 116
96761>>>>>        Set peAnchors To anBottomRight
96762>>>>>
96762>>>>>        Procedure OnClick
96765>>>>>            Send Ok of oSelList
96766>>>>>        End_Procedure
96767>>>>>
96767>>>>>    End_Object
96768>>>>>
96768>>>>>    Object oCancel_Btn is a Button
96770>>>>>        Set Size to 14 50
96771>>>>>        Set Label    to "&Cancel"
96772>>>>>        Set Location to 85 171
96773>>>>>        Set peAnchors to anBottomRight
96774>>>>>
96774>>>>>        Procedure OnClick
96777>>>>>            Send Close_Panel
96778>>>>>        End_Procedure
96779>>>>>
96779>>>>>    End_Object
96780>>>>>
96780>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96781>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96782>>>>>End_Object
96783>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
96783>>>>>Use Windows.pkg
96783>>>>>Use cCJGridPromptList.pkg
96783>>>>>Use cDbUpdateFunctionLibrary.pkg
96783>>>>>Use MSSqldrv.pkg
96783>>>>>Use db2_drv.pkg
96783>>>>>Use odbc_drv.pkg
96783>>>>>Use cCJGridColumn.pkg
96783>>>>>
96783>>>>>Object oSQLConnections is a ModalPanel
96785>>>>>    Set Label to "SQL Connections"
96786>>>>>    Set Size to 121 397
96787>>>>>    Set piMinSize to 89 185
96788>>>>>    Set Location to 2 2
96789>>>>>    Set Border_Style to Border_Thick
96790>>>>>
96790>>>>>    Property tSQLConnection[] psTheData
96792>>>>>
96792>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
96792>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96792>>>>>//        End_Object
96792>>>>>//    End
96792>>>>>
96792>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
96794>>>>>        Set Size to 90 377
96795>>>>>        Set Location to 6 6
96796>>>>>        Set peAnchors to anAll
96797>>>>>        Set pbAllowColumnRemove to False
96798>>>>>        Set pbUseAlternateRowBackgroundColor to True
96799>>>>>        Set pbGrayIfDisable to False
96800>>>>>        Set pbHeaderReorders to False
96801>>>>>        Set pbHeaderSelectsColumn to False
96802>>>>>        Set pbHeaderTogglesDirection to False
96803>>>>>        Set pbShadeSortColumn to False
96804>>>>>        Set piFocusCellBackColor to clDkGray  
96805>>>>>        Set pbRestoreLayout to True
96806>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
96807>>>>>
96807>>>>>        Object oID_Col is a cCJGridColumn
96809>>>>>            Set piWidth to 132
96810>>>>>            Set psCaption to "ID"
96811>>>>>        End_Object
96812>>>>>
96812>>>>>        Object oDbType_Col is a cCJGridColumn
96814>>>>>            Set piWidth to 182
96815>>>>>            Set psCaption to "Database Type"
96816>>>>>        End_Object
96817>>>>>
96817>>>>>        Object oServer_Col is a cCJGridColumn
96819>>>>>            Set piWidth to 296
96820>>>>>            Set psCaption to "Server/DSN"
96821>>>>>        End_Object
96822>>>>>
96822>>>>>        Object oDatabase_Col is a cCJGridColumn
96824>>>>>            Set piWidth to 211
96825>>>>>            Set psCaption to "Database"
96826>>>>>        End_Object
96827>>>>>
96827>>>>>        Object oDriverID_Col is a cCJGridColumn
96829>>>>>            Set piWidth to 121
96830>>>>>            Set psCaption to "Driver ID"
96831>>>>>        End_Object
96832>>>>>
96832>>>>>        Procedure Activating
96835>>>>>            tDataSourceRow[] MyData
96835>>>>>            tDataSourceRow[] MyData
96836>>>>>            Handle hoDataSource
96836>>>>>            Integer iCount iSize iPos
96836>>>>>            String sDriverID sConnectionID sValue
96836>>>>>            tSQLConnection[] sTheData
96836>>>>>            tSQLConnection[] sTheData
96837>>>>>
96837>>>>>            Send Cursor_Wait of Cursor_Control
96838>>>>>            Forward Send Activating
96840>>>>>
96840>>>>>            Get psTheData to sTheData
96841>>>>>            Move (SizeOfArray(sTheData)) to iSize
96842>>>>>            Decrement iSize
96843>>>>>            For iCount from 0 to iSize
96849>>>>>>
96849>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
96850>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
96851>>>>>                Move sValue                         to MyData[iCount].sValue[1]
96852>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
96853>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
96854>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
96855>>>>>            Loop
96856>>>>>>
96856>>>>>
96856>>>>>            Get phoDataSource to hoDataSource
96857>>>>>            Send InitializeData of hoDataSource MyData
96858>>>>>            Send Cursor_Ready of Cursor_Control
96859>>>>>        End_Procedure
96860>>>>>
96860>>>>>    End_Object
96861>>>>>
96861>>>>>    Object oOK_Btn is a Button
96863>>>>>        Set Label    to "&OK"
96864>>>>>        Set Location to 101 280
96865>>>>>        Set peAnchors to anBottomRight
96866>>>>>
96866>>>>>        Procedure OnClick
96869>>>>>            Send Ok of oSelListSQLConnections
96870>>>>>        End_Procedure
96871>>>>>
96871>>>>>    End_Object
96872>>>>>
96872>>>>>    Object oCancel_Btn is a Button
96874>>>>>        Set Label    to "&Cancel"
96875>>>>>        Set Location to 101 335
96876>>>>>        Set peAnchors to anBottomRight
96877>>>>>
96877>>>>>        Procedure OnClick
96880>>>>>            Send Close_Panel
96881>>>>>        End_Procedure
96882>>>>>
96882>>>>>    End_Object
96883>>>>>
96883>>>>>    Procedure Page Integer iPageObject
96886>>>>>        Set Icon to "SQLConnections1.ico"
96887>>>>>        Forward Send Page iPageObject
96889>>>>>    End_Procedure
96890>>>>>
96890>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96891>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96892>>>>>End_Object
96893>>>
96893>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
96903>>>>
96903>>>Object oSQLConnections_vw is a dbView
96905>>>    Set Border_Style to Border_Thick
96906>>>    Set Size to 251 427
96907>>>    Set Location to 2 2
96908>>>    Set Label to "SQL Connections"
96909>>>    Set pbAutoActivate to True
96910>>>    Set Icon to "SQLConnections1.ico"
96911>>>
96911>>>    Object oScrollingContainer1 is a cDbScrollingContainer
96913>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
96915>>>
96915>>>            Object oCurrentSettings_grp is a Group
96917>>>                Set Size to 232 402
96918>>>                Set Location to 6 12
96919>>>                Set Label to "Current Connection Settings"
96920>>>                Set peAnchors to anAll
96921>>>
96921>>>                Object oConnectionID_fm is a Form
96923>>>                    Set Size to 12 100
96924>>>                    Set Location to 12 68
96925>>>                    Set Label to "Connection ID"
96926>>>                    Set Label_Col_Offset to 2
96927>>>                    Set Label_Justification_Mode to JMode_Right
96928>>>                    Set Prompt_Button_Mode to PB_PromptOn
96929>>>                    Set Prompt_Object to (oSQLConnections(Self))
96930>>>
96930>>>                    Procedure Prompt
96933>>>                        String[] sTheData
96934>>>                        String sCurrentVal sNewVal
96934>>>                        Handle hoIniFile ho
96934>>>                        Integer iSize iCount
96934>>>                        tSQLConnection[] SQLConnectionArray
96934>>>                        tSQLConnection[] SQLConnectionArray
96935>>>
96935>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
96936>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
96937>>>                        Get Value to sCurrentVal
96938>>>                        Get Prompt_Object to ho
96939>>>                        Set psTheData of ho to SQLConnectionArray
96940>>>
96940>>>                        Forward Send Prompt
96942>>>                        Get Value to sNewVal
96943>>>                        If (sCurrentVal <> sNewVal) Begin
96945>>>                            Send Cursor_Wait of Cursor_Control
96946>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
96947>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
96949>>>                            Send Cursor_Ready of Cursor_Control
96950>>>                            Send KeyAction of oTestLogin_btn
96951>>>                        End
96951>>>>
96951>>>                    End_Procedure   
96952>>>                    
96952>>>                    Procedure PromptUpdate Handle hoPrompt
96955>>>                        String[] sSelectedNames                    
96956>>>                
96956>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
96957>>>                        If (SizeOfArray(sSelectedNames)) Begin
96959>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
96960>>>                            Delegate Send Page True // Broadcast sends refresh
96962>>>                        End
96962>>>>
96962>>>                    End_Procedure   
96963>>>
96963>>>                    Procedure Prompt_Callback Handle hoPrompt
96966>>>                        String sServer
96966>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
96967>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
96968>>>                        Get Value of oServer_fm to sServer
96969>>>                        Set psSeedValue of hoPrompt to sServer
96970>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
96971>>>                    End_Procedure
96972>>>
96972>>>                    Procedure Refresh
96975>>>                        String sValue
96975>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
96976>>>                        Set Value to sValue
96977>>>                    End_Procedure
96978>>>
96978>>>                End_Object
96979>>>
96979>>>                Object oDriverID_cf is a ComboForm
96981>>>                    Set Size to 12 91
96982>>>                    Set Location to 12 222
96983>>>                    Set Label_Col_Offset to 2
96984>>>                    Set Label_Justification_Mode to JMode_Right
96985>>>                    Set Label to "Driver ID"
96986>>>                    Set Entry_State to False
96987>>>                    Set Enabled_State to False
96988>>>
96988>>>                    Procedure Combo_Fill_List
96991>>>                        Send Combo_Add_Item MSSQLDRV_ID
96992>>>                        Send Combo_Add_Item DB2_DRV_ID
96993>>>                        Send Combo_Add_Item ODBC_DRV_ID
96994>>>                    End_Procedure
96995>>>
96995>>>                    Procedure OnChange
96998>>>                        String sValue sOrgValue
96998>>>                        Boolean bEnabled bChecked
96998>>>
96998>>>                        Get Value to sValue
96999>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97000>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97002>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97003>>>                        End
97003>>>>
97003>>>                        Move (sValue <> "None") to bEnabled
97004>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97006>>>                        Set Enabled_State to False
97007>>>                        Set Enabled_State of oConnectionString_fm to False
97008>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97009>>>
97009>>>                        Get Checked_State of oTrusted_cb  to bChecked
97010>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97011>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97012>>>                    End_Procedure
97013>>>
97013>>>                    Procedure Refresh
97016>>>                        String sValue
97016>>>
97016>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97017>>>                        Set Value to sValue
97018>>>                    End_Procedure
97019>>>
97019>>>                End_Object
97020>>>
97020>>>                Object oServer_fm is a Form
97022>>>                    Set Size to 12 100
97023>>>                    Set Location to 26 68
97024>>>                    Set Label to "Server"
97025>>>                    Set Label_Col_Offset to 2
97026>>>                    Set Label_Justification_Mode to JMode_Right
97027>>>                    Set Prompt_Button_Mode to PB_PromptOn
97028>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97029>>>
97029>>>                    Procedure Refresh
97032>>>                        String sValue
97032>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97033>>>                        Set Value to sValue
97034>>>                    End_Procedure
97035>>>
97035>>>                    Procedure Prompt
97038>>>                        String[] sTheData
97039>>>                        String sDriverID
97039>>>                        Handle ho
97039>>>
97039>>>                        Send Cursor_Wait of Cursor_Control
97040>>>                        Get Prompt_Object to ho
97041>>>                        Get Value of oDriverID_cf to sDriverID
97042>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97043>>>                        Set psTheData of ho to sTheData
97044>>>                        Send Cursor_Ready of Cursor_Control
97045>>>
97045>>>                        Forward Send Prompt
97047>>>                    End_Procedure
97048>>>
97048>>>                End_Object
97049>>>
97049>>>                Object oDatabase_fm is a Form
97051>>>                    Set Size to 12 91
97052>>>                    Set Location to 26 222
97053>>>                    Set Label to "Database"
97054>>>                    Set Label_Col_Offset to 2
97055>>>                    Set Label_Justification_Mode to JMode_Right
97056>>>                    Set Prompt_Button_Mode to PB_PromptOn
97057>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97058>>>                    Set peAnchors to anNone
97059>>>                    Set Entry_State to False
97060>>>
97060>>>                    Procedure Refresh
97063>>>                        String sDatabase
97063>>>
97063>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97064>>>                        Set Value to sDatabase
97065>>>                    End_Procedure
97066>>>
97066>>>                    Procedure Prompt
97069>>>                        String[] sTheData
97070>>>                        Handle ho
97070>>>                        String sDriverID
97070>>>
97070>>>                        Get Value of oDriverID_cf to sDriverID
97071>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97072>>>
97072>>>                        Get Prompt_Object to ho
97073>>>                        Set psTheData of ho to sTheData
97074>>>
97074>>>                        Forward Send Prompt
97076>>>                    End_Procedure
97077>>>
97077>>>                    Procedure OnChange
97080>>>                        String sValue sOrgValue
97080>>>                        Get Value to sValue
97081>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97082>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97084>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97085>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97086>>>                            Set Value of oConnectionString_fm to sValue
97087>>>                        End
97087>>>>
97087>>>                    End_Procedure
97088>>>
97088>>>                End_Object
97089>>>
97089>>>                Object oTrusted_cb is a CheckBox
97091>>>                    Set Size to 10 50
97092>>>                    Set Location to 45 68
97093>>>                    Set Label to "Use Trusted Connection"
97094>>>
97094>>>                    Procedure Refresh
97097>>>                        Boolean bValue
97097>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97098>>>                        Set Checked_State to bValue
97099>>>                    End_Procedure
97100>>>
97100>>>                    Procedure OnChange
97103>>>                        Boolean bChecked
97103>>>
97103>>>                        Get Checked_State to bChecked
97104>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97105>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97106>>>                    End_Procedure
97107>>>
97107>>>                End_Object
97108>>>
97108>>>                Object oUserID_fm is a Form
97110>>>                    Set Size to 12 100
97111>>>                    Set Location to 57 68
97112>>>                    Set Label to "UserID"
97113>>>                    Set Label_Col_Offset to 2
97114>>>                    Set Label_Justification_Mode to JMode_Right
97115>>>
97115>>>                    Procedure Refresh
97118>>>                        String sValue
97118>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97119>>>                        Set Value to sValue
97120>>>                    End_Procedure
97121>>>
97121>>>                End_Object
97122>>>
97122>>>                Object oPassword_fm is a Form
97124>>>                    Set Size to 12 91
97125>>>                    Set Location to 57 222
97126>>>                    Set Label to "Password"
97127>>>                    Set Label_Col_Offset to 2
97128>>>                    Set Label_Justification_Mode to JMode_Right
97129>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97129>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97130>>>                    Set Password_State to True
97131>>>
97131>>>                    Procedure Refresh
97134>>>                        String sValue
97134>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97135>>>                        Set Value to sValue
97136>>>                    End_Procedure
97137>>>
97137>>>                End_Object
97138>>>
97138>>>                Object oViewPassword_btn is a cRDCButtonDPI
97140>>>                    Set Size to 12 19
97141>>>                    Set Location to 57 317
97142>>>                    Set psToolTip to "Toggle password"
97143>>>                    Set psImage to "ViewPassword1.ico"
97144>>>                    Set piImageMarginLeft to 0
97145>>>
97145>>>                    Procedure OnClick
97148>>>                        Boolean bState
97148>>>                        Get Password_State of oPassword_fm to bState
97149>>>                        Send Page_Object   of oPassword_fm False
97150>>>                        Set Password_State of oPassword_fm to (not(bState))
97151>>>                        Send Page_Object   of oPassword_fm True
97152>>>                    End_Procedure
97153>>>
97153>>>                End_Object
97154>>>
97154>>>                Object oTestLogin_btn is a cRDCButtonDPI
97156>>>                    Set Size to 12 56
97157>>>                    Set Location to 57 340
97158>>>                    Set Label to "Test Login"
97159>>>                    Set peAnchors to anNone
97160>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97161>>>                    Set FontWeight to fw_Bold
97162>>>                    Set psImage to "ActionLogin1.ico"
97163>>>                    Set piImageMarginLeft to 0
97164>>>
97164>>>                    Procedure OnClick
97167>>>                        tSQLConnection SQLConnection
97167>>>                        tSQLConnection SQLConnection
97167>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97167>>>                        Boolean bTrusted bLoginSuccessful
97167>>>                        Integer iDriverID
97167>>>                        Handle hoDriver
97167>>>
97167>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97168>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97169>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97170>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97171>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97172>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97173>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97174>>>
97174>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97175>>>
97175>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97176>>>                        If (iDriverID = 0) Begin
97178>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97179>>>                            Procedure_Return
97180>>>                        End
97180>>>>
97180>>>
97180>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97183>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97184>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97185>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97186>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97187>>>                        Send Destroy   of hoDriver
97188>>>
97188>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97189>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97191>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97192>>>                            Set Value of oConnectionString_fm to sConnectionString
97193>>>                            Send Info_Box "Login Successful!"
97194>>>                        End
97194>>>>
97194>>>                        Else Begin
97195>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97196>>>                        End
97196>>>>
97196>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97198>>>                        Move 0 to LastErr
97199>>>                    End_Procedure
97200>>>
97200>>>                End_Object
97201>>>
97201>>>                Object oConnectionString_fm is a Form
97203>>>                    Set Size to 12 328
97204>>>                    Set Location to 82 68
97205>>>                    Set Label to "Connection String"    
97206>>>                    Set Label_Col_Offset to 2
97207>>>                    Set Label_Justification_Mode to JMode_Right
97208>>>                    Set peAnchors to anTopLeftRight
97209>>>                    Set Enabled_State to False
97210>>>
97210>>>                    Procedure Refresh
97213>>>                        String sValue
97213>>>                        tSQLConnection SQLConnection
97213>>>                        tSQLConnection SQLConnection
97213>>>
97213>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97214>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97215>>>                        Set Value to sValue
97216>>>                    End_Procedure
97217>>>
97217>>>                End_Object
97218>>>
97218>>>                Object oInfo_tb is a TextBox
97220>>>                    Set Auto_Size_State to False
97221>>>                    Set Size to 18 303
97222>>>                    Set Location to 106 8
97223>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97224>>>                    Set Justification_Mode to JMode_Left
97225>>>                    Set FontItalics to True
97226>>>                End_Object
97227>>>
97227>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97229>>>                    Set Size to 21 83
97230>>>                    Set Location to 106 315
97231>>>                    Set Label to "SQL Connections"
97232>>>                    Set peAnchors to anNone
97233>>>                    Set psImage to "SQLConnections1.ico"
97234>>>
97234>>>                    Procedure OnClick 
97237>>>                        Runprogram Background "DUFSQLConnections.exe"
97238>>>                    End_Procedure
97239>>>
97239>>>                End_Object
97240>>>
97240>>>                Object oGetCollation_btn is a Button
97242>>>                    Set Size to 27 91
97243>>>                    Set Location to 154 38
97244>>>                    Set Label to 'Get Database Collation'
97245>>>                
97245>>>                    Procedure OnClick
97248>>>                        String sCollation sDatabase
97248>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97249>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97250>>>                        Set Value of oGetCollation_fm to sCollation
97251>>>                    End_Procedure
97252>>>                
97252>>>                End_Object
97253>>>
97253>>>                Object oGetCollation_fm is a Form
97255>>>                    Set Size to 12 148
97256>>>                    Set Location to 162 143
97257>>>                    Set Label to "Current SQL Collation Name"
97258>>>                    Set Label_Col_Offset to 0
97259>>>                    Set Label_Row_Offset to 1
97260>>>                    Set Label_Justification_Mode to JMode_Top
97261>>>                End_Object
97262>>>        
97262>>>                Object oSetCollation_btn is a Button
97264>>>                    Set Size to 27 91
97265>>>                    Set Location to 188 38
97266>>>                    Set Label to "Set Database Collation"
97267>>>                
97267>>>                    Procedure OnClick
97270>>>                        String sCollation sDatabase sErrorText
97270>>>                        Boolean bOK
97270>>>                        Integer iRetval  
97270>>>                        tSqlErrorArray aSqlErrorArray
97270>>>                        tSqlErrorArray aSqlErrorArray
97270>>>                        
97270>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97271>>>                        Get Value of oSetCollation_fm to sCollation
97272>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97273>>>                        If (iRetval <> MBR_Yes) Begin
97275>>>                            Procedure_Return
97276>>>                        End
97276>>>>
97276>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97277>>>                        If (bOK = True) Begin
97279>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97280>>>                        End
97280>>>>
97280>>>                        Else Begin                   
97281>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97282>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97283>>>                            Move (sErrorText + "\n")                  to sErrorText
97284>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97285>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97286>>>                        End
97286>>>>
97286>>>
97286>>>                    End_Procedure
97287>>>                
97287>>>                End_Object
97288>>>
97288>>>                Object oSetCollation_fm is a Form
97290>>>                    Set Size to 12 148
97291>>>                    Set Location to 197 143
97292>>>                    Set Label to "New SQL Collation Name"
97293>>>                    Set Label_Col_Offset to 0
97294>>>                    Set Label_Row_Offset to 1
97295>>>                    Set Label_Justification_Mode to JMode_Top
97296>>>                End_Object
97297>>>
97297>>>                Procedure Page Integer iPageObject
97300>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97302>>>                    Forward Send Page iPageObject
97304>>>                End_Procedure
97305>>>
97305>>>            End_Object
97306>>>
97306>>>        End_Object
97307>>>        
97307>>>    End_Object
97308>>>
97308>>>End_Object
97309>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97309>>>Use Windows.pkg
97309>>>Use DFClient.pkg
97309>>>Use Dfspnfrm.pkg
97309>>>Use cDbScrollingContainer.pkg
97309>>>Use cRDCButtonDPI.pkg
97309>>>Use cDbUpdateFunctionLibrary.pkg
97309>>>Use SQLDatabaseBackup.dg
97309>>>
97309>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97319>>>>
97319>>>Object oSQLFunctions_vw is a dbView
97321>>>    Set Border_Style to Border_Thick
97322>>>    Set Size to 260 426
97323>>>    Set Location to -4 2
97324>>>    Set Label to "Functions"
97325>>>    Set pbAutoActivate to True
97326>>>    Set Icon to "Sql1.ico"
97327>>>
97327>>>    Procedure OnSetFocus
97330>>>        String sValue
97330>>>        tSQLConnection SQLConnection
97330>>>        tSQLConnection SQLConnection
97330>>>
97330>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97331>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97332>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97333>>>        Set Value of oSQLConnectionString_fm to sValue
97334>>>    End_Procedure
97335>>>
97335>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97337>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97339>>>
97339>>>            Object oSQLFunctionTests_grp is a Group
97341>>>                Set Size to 243 402
97342>>>                Set Location to 7 12
97343>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97344>>>                Set peAnchors to anAll
97345>>>
97345>>>                Object oSQLConnectionString_fm is a Form
97347>>>                    Set Size to 12 375
97348>>>                    Set Location to 23 14
97349>>>                    Set Label to "Current Connection String Settings:"
97350>>>                    Set Label_Col_Offset to 0
97351>>>                    Set Label_Justification_Mode to JMode_Top
97352>>>                    Set peAnchors to anTopLeftRight
97353>>>                    Set Enabled_State to False
97354>>>                    Set Label_Row_Offset to 1
97355>>>                End_Object
97356>>>
97356>>>                Object oSQLDatabase_fm is a Form
97358>>>                    Set Size to 12 86
97359>>>                    Set Location to 50 14
97360>>>                    Set Label to "Database:"
97361>>>                    Set Label_Col_Offset to 0
97362>>>                    Set Label_Justification_Mode to JMode_Top
97363>>>                    Set Label_Row_Offset to 1
97364>>>                    Set FontWeight to fw_Bold
97365>>>                    Set Enabled_State to False
97366>>>                End_Object
97367>>>
97367>>>                Object oDriverID2_cf is a ComboForm
97369>>>                    Set Size to 12 91
97370>>>                    Set Location to 50 121
97371>>>                    Set Label_Col_Offset to 0
97372>>>                    Set Label_Justification_Mode to JMode_Top
97373>>>                    Set Label to "Driver ID:"
97374>>>                    Set Entry_State to False
97375>>>                    Set Enabled_State to False
97376>>>                    Set Label_Row_Offset to 1
97377>>>
97377>>>                    Procedure Combo_Fill_List
97380>>>                        Send Combo_Add_Item MSSQLDRV_ID
97381>>>                        Send Combo_Add_Item DB2_DRV_ID
97382>>>                        Send Combo_Add_Item ODBC_DRV_ID
97383>>>                    End_Procedure
97384>>>
97384>>>                    Procedure Refresh
97387>>>                        String sValue
97387>>>
97387>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97388>>>                        Set Value to sValue
97389>>>                    End_Procedure
97390>>>
97390>>>                End_Object
97391>>>
97391>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97393>>>                    Set Size to 12 109
97394>>>                    Set Location to 50 220
97395>>>                    Set Label to "Backup MS-SQL Database"
97396>>>                    Set psImage to "DbBackup1.ico"
97397>>>
97397>>>                    Procedure OnClick
97400>>>                        Boolean bOK
97400>>>
97400>>>                        // SQLDatabaseBackup dialog:
97400>>>                        Get MakeSQLDatabaseBackup to bOK
97401>>>
97401>>>                        If (bOK = True) Begin
97403>>>                            Send Info_Box "The backup of the database was successful!"
97404>>>                        End
97404>>>>
97404>>>                        Else Begin
97405>>>                            Send Info_Box "The database was not backup up"
97406>>>                        End
97406>>>>
97406>>>                    End_Procedure
97407>>>
97407>>>                End_Object
97408>>>
97408>>>                Object oDatabaseInfo_tb is a TextBox
97410>>>                    Set Auto_Size_State to False
97411>>>                    Set Size to 25 96
97412>>>                    Set Location to 64 14
97413>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97414>>>                    Set Justification_Mode to JMode_Left
97415>>>                End_Object
97416>>>
97416>>>                Object oSQLInfo_tb is a TextBox
97418>>>                    Set Auto_Size_State to False
97419>>>                    Set Size to 37 270
97420>>>                    Set Location to 76 118
97421>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97422>>>                    Set Justification_Mode to JMode_Left
97423>>>                End_Object
97424>>>
97424>>>                Object oSQLTableName_cf is a ComboForm
97426>>>                    Set Size to 12 96
97427>>>                    Set Location to 106 14
97428>>>                    Set Label_Col_Offset to 0
97429>>>                    Set Label_Justification_Mode to JMode_Top
97430>>>                    Set Label to "Select Table:"
97431>>>                    Set Label_Row_Offset to 1
97432>>>                    Set Entry_State to False
97433>>>
97433>>>                    Procedure OnDropDown
97436>>>                        Send DoCombo_Fill_List
97437>>>                    End_Procedure
97438>>>
97438>>>                    Procedure OnCloseUp
97441>>>                        Send Delete_Data of oSQLColumnName_cf
97442>>>                    End_Procedure
97443>>>
97443>>>                    Procedure DoCombo_Fill_List
97446>>>                        String[] sTablesArray
97447>>>                        String sDriverID
97447>>>                        Integer iCount iSize
97447>>>
97447>>>                        Send Delete_Data
97448>>>                        Get Value of oDriverID2_cf to sDriverID
97449>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97450>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97451>>>                        Decrement iSize
97452>>>                        For iCount from 0 to iSize
97458>>>>
97458>>>                            Send Combo_Add_Item sTablesArray[iCount]
97459>>>                        Loop
97460>>>>
97460>>>                    End_Procedure
97461>>>
97461>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97461>>>                    // Augmented Value function.
97461>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97461>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97461>>>                    Function Value Integer iItem Returns String
97464>>>                        String sValue
97464>>>                        Get WinCombo_Current_Item to iItem
97465>>>                        Get WinCombo_Value iItem  to sValue
97466>>>                        Function_Return sValue
97467>>>                    End_Function
97468>>>
97468>>>                End_Object
97469>>>
97469>>>                Object oSQLColumnName_cf is a ComboForm
97471>>>                    Set Size to 12 96
97472>>>                    Set Location to 134 14
97473>>>                    Set Label_Col_Offset to 0
97474>>>                    Set Label_Justification_Mode to JMode_Top
97475>>>                    Set Label to "Select Column:"
97476>>>                    Set Label_Row_Offset to 1
97477>>>                    Set Entry_State to False
97478>>>
97478>>>                    Procedure DoCombo_Fill_List
97481>>>                        String[] sColumnsArray
97482>>>                        String sTableName sDriverID
97482>>>                        Integer iCount iSize
97482>>>
97482>>>                        Send Delete_Data
97483>>>                        Get Value of oDriverID2_cf    to sDriverID
97484>>>                        Get Value of oSQLTableName_cf to sTableName
97485>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
97486>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
97487>>>                        Decrement iSize
97488>>>                        For iCount from 0 to iSize
97494>>>>
97494>>>                            Send Combo_Add_Item sColumnsArray[iCount]
97495>>>                        Loop
97496>>>>
97496>>>                        If (iSize > 1) Begin
97498>>>                            Set Current_Item to 1
97499>>>                        End
97499>>>>
97499>>>                    End_Procedure
97500>>>
97500>>>                    Procedure OnDropDown
97503>>>                        Send DoCombo_Fill_List
97504>>>                    End_Procedure
97505>>>                End_Object
97506>>>
97506>>>                Object oSQLRenameColumnTo_fm is a Form
97508>>>                    Set Size to 12 96
97509>>>                    Set Location to 134 116
97510>>>                    Set Label_Col_Offset to 0
97511>>>                    Set Label_Justification_Mode to JMode_Top
97512>>>                    Set Label to "Rename Column To:"
97513>>>                    Set Label_Row_Offset to 1
97514>>>                    Set Value to "NewColumnName"
97515>>>                End_Object
97516>>>
97516>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
97518>>>                    Set Size to 12 69
97519>>>                    Set Location to 134 220
97520>>>                    Set Label to "Rename Column"
97521>>>                    Set psToolTip to "Test of SQLColumnRename function"
97522>>>                    Set MultiLineState to True
97523>>>
97523>>>                    Procedure OnClick
97526>>>                        Boolean bOk
97526>>>                        Handle hTable
97526>>>                        String sTableName sColumnName sNewColumnName sDriverID
97526>>>
97526>>>                        Get Value of oSQLTableName_cf to sTableName
97527>>>                        If (sTableName = "") Begin
97529>>>                            Send Info_Box "You need to select a table first..."
97530>>>                            Procedure_Return
97531>>>                        End
97531>>>>
97531>>>                        Get Value of oSQLColumnName_cf to sColumnName
97532>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
97534>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
97535>>>                            Procedure_Return
97536>>>                        End
97536>>>>
97536>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
97537>>>                        If (Trim(sNewColumnName) = "") Begin
97539>>>                            Send Info_Box "You need to enter a column name to rename to..."
97540>>>                            Procedure_Return
97541>>>                        End
97541>>>>
97541>>>
97541>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97542>>>                        If (hTable = 0) Begin
97544>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
97545>>>                            Procedure_Return
97546>>>                        End
97546>>>>
97546>>>
97546>>>                        Get Value of oDriverID2_cf to sDriverID
97547>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97548>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
97549>>>                        If (bOk = True) Begin
97551>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
97551>>>                            Send Delete_Data of oSQLColumnName_cf
97552>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
97553>>>                        End
97553>>>>
97553>>>                        Else Begin
97554>>>                            Send Info_Box "Nope, that didn't work..."
97555>>>                        End
97555>>>>
97555>>>
97555>>>                    End_Procedure
97556>>>
97556>>>                End_Object
97557>>>
97557>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
97559>>>                    Set Size to 12 91
97560>>>                    Set Location to 134 297
97561>>>                    Set Label to "Drop Column"
97562>>>                    Set psToolTip to "Test of SQLColumnRemove function"
97563>>>                    Set psImage to "DeleteColumn1.ico"
97564>>>
97564>>>                    Procedure OnClick
97567>>>                        Boolean bOk
97567>>>                        String sTableName sColumnName sDriverID
97567>>>                        Integer iRetval
97567>>>
97567>>>                        Get Value of oDriverID2_cf              to sDriverID
97568>>>                        Get Value of oSQLTableName_cf           to sTableName
97569>>>                        Get Value of oSQLColumnName_cf          to sColumnName
97570>>>
97570>>>                        If (sTableName = "" or sColumnName = "") Begin
97572>>>                            Send Info_Box "You first need to select a table and a column."
97573>>>                            Procedure_Return
97574>>>                        End
97574>>>>
97574>>>
97574>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
97575>>>                        If (iRetval <> MBR_Yes) Begin
97577>>>                            Procedure_Return
97578>>>                        End
97578>>>>
97578>>>
97578>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
97579>>>
97579>>>                        If (bOk = True) Begin
97581>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
97581>>>                            Send Delete_Data of oSQLColumnName_cf
97582>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
97583>>>                        End
97583>>>>
97583>>>                        Else Begin
97584>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
97585>>>                            Procedure_Return
97586>>>                        End
97586>>>>
97586>>>
97586>>>                    End_Procedure
97587>>>
97587>>>                End_Object
97588>>>
97588>>>                Object oSQLAddColumnName_fm is a Form
97590>>>                    Set Size to 12 96
97591>>>                    Set Location to 177 14
97592>>>                    Set Label_Col_Offset to 0
97593>>>                    Set Label_Justification_Mode to JMode_Top
97594>>>                    Set Label to "Column Name:"
97595>>>                    Set Label_Row_Offset to 1
97596>>>                    Set Value to "NewColumn"
97597>>>                End_Object
97598>>>
97598>>>                Object oSQLColumnType_cf is a ComboForm
97600>>>                    Set Size to 12 96
97601>>>                    Set Location to 177 116
97602>>>                    Set Label_Col_Offset to 0
97603>>>                    Set Label_Justification_Mode to JMode_Top
97604>>>                    Set Label_Row_Offset to 1
97605>>>                    Set Label to "Type:"
97606>>>                    Set Entry_State to False
97607>>>
97607>>>                    Procedure Combo_Fill_List
97610>>>                        tColumnType[] ColumnTypeArray
97610>>>                        tColumnType[] ColumnTypeArray
97611>>>                        Integer iSize iCount iDbType
97611>>>                        String sDriverID
97611>>>
97611>>>                        Send Delete_Data
97612>>>                        Get Value of oDriverID2_cf to sDriverID
97613>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
97614>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
97615>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
97616>>>                        Decrement iSize
97617>>>                        For iCount from 0 to iSize
97623>>>>
97623>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
97624>>>                        Loop
97625>>>>
97625>>>                        If (iSize > 0) Begin
97627>>>                            Set Value to ColumnTypeArray[0].sSQLType
97628>>>                        End
97628>>>>
97628>>>                    End_Procedure
97629>>>
97629>>>                    Procedure OnChange
97632>>>                        Integer iType iSize iDec
97632>>>                        tSQLConnection SQLConnection
97632>>>                        tSQLConnection SQLConnection
97632>>>                        Boolean bFixed
97632>>>
97632>>>                        Get SelectedType to iType
97633>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97634>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
97635>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
97636>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
97637>>>
97637>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
97638>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
97639>>>                        Set Value         of oSQLLength_sf   to iSize
97640>>>                        If (iDec = 0) Begin
97642>>>                            Set Value     of oSQLDecimals_sf to ""
97643>>>                        End
97643>>>>
97643>>>                        Else Begin
97644>>>                            Set Value     of oSQLDecimals_sf to iDec
97645>>>                        End
97645>>>>
97645>>>                        If (bFixed = False) Begin
97647>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
97648>>>                        End
97648>>>>
97648>>>                    End_Procedure
97649>>>
97649>>>                    Function SelectedType Returns Integer
97652>>>                        String sValue sDriverID
97652>>>                        Integer iType iDbType
97652>>>
97652>>>                        Get Value to sValue
97653>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
97654>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
97655>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
97656>>>
97656>>>                        Function_Return iType
97657>>>                    End_Function
97658>>>
97658>>>                End_Object
97659>>>
97659>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
97661>>>                    Set Size to 12 69
97662>>>                    Set Location to 177 220
97663>>>                    Set Label to "Add Column"
97664>>>                    Set psToolTip to "Test of SQLColumnAdd function"
97665>>>                    Set psImage to "AddColumn1.ico"
97666>>>
97666>>>                    Procedure OnClick
97669>>>                        Boolean bOk bInitialize
97669>>>                        Handle hTable
97669>>>                        String sTableName sColumnName sType sColumnValue sDriverID
97669>>>                        Integer iType iLength iDecimals
97669>>>
97669>>>                        Get Value of oDriverID2_cf              to sDriverID
97670>>>                        Get Value of oSQLTableName_cf           to sTableName
97671>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
97672>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
97673>>>                        Get Value         of oSQLColumnType_cf  to sType
97674>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
97675>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
97676>>>                        Get Value         of oSQLLength_sf      to iLength
97677>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
97678>>>
97678>>>                        If (sTableName <> "") Begin
97680>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97681>>>                            If (hTable = 0) Begin
97683>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97684>>>                            End
97684>>>>
97684>>>                        End
97684>>>>
97684>>>                        If (hTable = 0) Begin
97686>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
97687>>>                            Procedure_Return
97688>>>                        End
97688>>>>
97688>>>                        If (sColumnName = "") Begin
97690>>>                            Send Info_Box "You need to enter a column name"
97691>>>                            Procedure_Return
97692>>>                        End
97692>>>>
97692>>>
97692>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
97693>>>
97693>>>                        If (bOk = True) Begin
97695>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
97696>>>                        End
97696>>>>
97696>>>                        Else Begin
97697>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
97698>>>                            Procedure_Return
97699>>>                        End
97699>>>>
97699>>>
97699>>>                    End_Procedure
97700>>>
97700>>>                End_Object
97701>>>
97701>>>//                Object oTest_btn is a cRDCButtonDPI
97701>>>//                    Set Size to 13 92
97701>>>//                    Set Location to 177 298
97701>>>//                    Set Label to "Test SQL script button"
97701>>>//
97701>>>//                    Procedure OnClick
97701>>>//                        Boolean bOK
97701>>>//                        String sTableName sColumnName
97701>>>//
97701>>>//                        Get Value of oSQLTableName_cf      to sTableName
97701>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
97701>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
97701>>>//
97701>>>//                    End_Procedure
97701>>>//
97701>>>//                End_Object
97701>>>
97701>>>                Object oSQLLength_sf is a SpinForm
97703>>>                    Set Label to "Length:"
97704>>>                    Set Size to 12 40
97705>>>                    Set Location to 202 16
97706>>>                    Set Label_Col_Offset to 0
97707>>>                    Set Label_Justification_Mode to JMode_Top
97708>>>                    Set Label_Row_Offset to 1
97709>>>                    Set Value to "10"
97710>>>                    Set Maximum_Position to 500
97711>>>                    Set Minimum_Position to 1
97712>>>                End_Object
97713>>>
97713>>>                Object oSQLDecimals_sf is a SpinForm
97715>>>                    Set Label to "Decimals:"
97716>>>                    Set Size to 12 33
97717>>>                    Set Location to 202 60
97718>>>                    Set Label_Col_Offset to 0
97719>>>                    Set Label_Justification_Mode to JMode_Top
97720>>>                    Set Label_Row_Offset to 1
97721>>>                    Set Value to "0"
97722>>>                    Set Maximum_Position to 16
97723>>>                    Set Minimum_Position to 1
97724>>>                End_Object
97725>>>
97725>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
97727>>>                    Set Size to 12 85
97728>>>                    Set Location to 202 116
97729>>>                    Set Label to "Initialize Column Value"
97730>>>
97730>>>                    Procedure OnChange
97733>>>                        Boolean bChecked
97733>>>
97733>>>                        Get Checked_State to bChecked
97734>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
97735>>>                    End_Procedure
97736>>>
97736>>>                End_Object
97737>>>
97737>>>                Object oSQLColumnValue_fm is a Form
97739>>>                    Set Size to 12 96
97740>>>                    Set Location to 218 116
97741>>>                    Set Label_Col_Offset to 2
97742>>>                    Set Label_Justification_Mode to JMode_Right
97743>>>                    Set Label to "Column Value"
97744>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
97745>>>                    Set Enabled_State to False
97746>>>                End_Object
97747>>>
97747>>>                Object oEnumRelations_btn is a cRDCButtonDPI
97749>>>                    Set Size to 12 91
97750>>>                    Set Location to 116 297
97751>>>                    Set Label to "Test Enum SQL Relations"
97752>>>
97752>>>                    Procedure OnClick
97755>>>                        tSQLRelation[] SQLRelationArray
97755>>>                        tSQLRelation[] SQLRelationArray
97756>>>                        String sTableName sDriverID
97756>>>                        Integer iSize iCount
97756>>>
97756>>>                        Get Value of oDriverID2_cf to sDriverID
97757>>>                        Get Value of oSQLTableName_cf to sTableName
97758>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
97759>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
97760>>>                        Decrement iSize
97761>>>                        For iCount from 0 to iSize
97767>>>>
97767>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
97776>>>                        Loop
97777>>>>
97777>>>                        If (iSize < 1) Begin
97779>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
97780>>>                        End
97780>>>>
97780>>>
97780>>>                    End_Procedure
97781>>>
97781>>>                End_Object
97782>>>
97782>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
97784>>>                    Set Size to 12 101
97785>>>                    Set Location to 177 297
97786>>>                    Set Label to "Enumerate Logged In Users"
97787>>>
97787>>>                    Procedure OnClick
97790>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97790>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97791>>>                        String sDriverID sDatabase
97791>>>                        Integer iSize iCount
97791>>>
97791>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97792>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
97793>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
97794>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
97795>>>                        Decrement iSize
97796>>>
97796>>>                        Showln "SQL User Name" " and Program:"
97799>>>                        For iCount from 0 to iSize
97805>>>>
97805>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
97809>>>                        Loop
97810>>>>
97810>>>                    End_Procedure
97811>>>
97811>>>                End_Object
97812>>>
97812>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
97814>>>                    Set Size to 12 101
97815>>>                    Set Location to 193 297
97816>>>                    Set Label to "Is Table or View?"
97817>>>
97817>>>                    Procedure OnClick
97820>>>                        String sDriverID sTableName
97820>>>                        Handle hTable
97820>>>                        Boolean bViewTableType
97820>>>
97820>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97821>>>                        Get Value of oSQLTableName_cf to sTableName
97822>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97823>>>                        If (hTable = 0) Begin
97825>>>                            Procedure_Return
97826>>>                        End
97826>>>>
97826>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
97827>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
97828>>>                    End_Procedure
97829>>>
97829>>>                End_Object
97830>>>
97830>>>            End_Object
97831>>>
97831>>>        End_Object
97832>>>
97832>>>    End_Object
97833>>>
97833>>>End_Object
97834>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
97834>>>Use Windows.pkg
97834>>>Use DFClient.pkg
97834>>>Use Dfspnfrm.pkg
97834>>>Use Dfline.pkg
97834>>>Use cDbScrollingContainer.pkg
97834>>>Use cRDCButtonDPI.pkg
97834>>>Use cDbUpdateFunctionLibrary.pkg
97834>>>
97834>>>Define CI_Table1_FileNo for 401
97834>>>Define CI_View1_FileNo  for 402
97834>>>
97834>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
97844>>>>
97844>>>Object oAPIFunctions_vw is a dbView
97846>>>    Set Border_Style to Border_Thick
97847>>>    Set Size to 237 424
97848>>>    Set Location to 17 2
97849>>>    Set Label to "API Functions"
97850>>>    Set pbAutoActivate to True
97851>>>    Set Icon to "APIFunctions1.ico"
97852>>>
97852>>>    Property String psTableName ""
97854>>>
97854>>>    Procedure OnSetFocus
97857>>>        String sValue
97857>>>        tSQLConnection SQLConnection
97857>>>        tSQLConnection SQLConnection
97857>>>
97857>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97858>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
97859>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97860>>>        Set Value of oApiConnectionString_fm to sValue
97861>>>    End_Procedure
97862>>>
97862>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97864>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97866>>>
97866>>>            Object oApiFunctions_grp is a Group
97868>>>                Set Size to 222 402
97869>>>                Set Location to 6 12
97870>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
97871>>>                Set peAnchors to anAll
97872>>>
97872>>>                Object oApiConnectionString_fm is a Form
97874>>>                    Set Size to 12 368
97875>>>                    Set Location to 23 14
97876>>>                    Set Label to "Current Connection String Settings:"
97877>>>                    Set Label_Col_Offset to 0
97878>>>                    Set Label_Justification_Mode to JMode_Top
97879>>>                    Set peAnchors to anTopLeftRight
97880>>>                    Set Enabled_State to False
97881>>>                    Set Label_Row_Offset to 1
97882>>>                End_Object
97883>>>
97883>>>                Object oApiDatabase_fm is a Form
97885>>>                    Set Size to 12 86
97886>>>                    Set Location to 50 14
97887>>>                    Set Label to "Database:"
97888>>>                    Set Label_Col_Offset to 0
97889>>>                    Set Label_Justification_Mode to JMode_Top
97890>>>                    Set Label_Row_Offset to 1
97891>>>                    Set Enabled_State to False
97892>>>                    Set FontWeight to fw_Bold
97893>>>//                    Set Label_FontWeight to fw_Bold
97893>>>
97893>>>                    Procedure Page Integer iPageObject
97896>>>                        String sValue
97896>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
97897>>>                        Set Value to sValue
97898>>>
97898>>>                        Forward Send Page iPageObject
97900>>>                    End_Procedure
97901>>>
97901>>>                End_Object
97902>>>
97902>>>                Object oDriverID3_cf is a ComboForm
97904>>>                    Set Size to 12 91
97905>>>                    Set Location to 51 121
97906>>>                    Set Label_Col_Offset to 0
97907>>>                    Set Label_Justification_Mode to JMode_Top
97908>>>                    Set Label to "Driver ID:"
97909>>>                    Set Entry_State to False
97910>>>                    Set Enabled_State to False
97911>>>                    Set Label_Row_Offset to 1
97912>>>                    Set Enabled_State to False
97913>>>
97913>>>                    Procedure Combo_Fill_List
97916>>>                        Send Combo_Add_Item MSSQLDRV_ID
97917>>>                        Send Combo_Add_Item DB2_DRV_ID
97918>>>                        Send Combo_Add_Item ODBC_DRV_ID
97919>>>                    End_Procedure
97920>>>
97920>>>                    Procedure Refresh
97923>>>                        String sValue
97923>>>
97923>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97924>>>                        Set Value to sValue
97925>>>                    End_Procedure
97926>>>
97926>>>                End_Object
97927>>>
97927>>>                Object oDatabaseInfo_tb is a TextBox
97929>>>                    Set Auto_Size_State to False
97930>>>                    Set Size to 25 96
97931>>>                    Set Location to 64 14
97932>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97933>>>                    Set Justification_Mode to JMode_Left
97934>>>                End_Object
97935>>>
97935>>>                Object oApiTableName_fm is a Form
97937>>>                    Set Size to 12 77
97938>>>                    Set Location to 114 14
97939>>>                    Set Label_Col_Offset to 0
97940>>>                    Set Label_Justification_Mode to JMode_Top
97941>>>                    Set Label to "Table Name:"
97942>>>                    Set Label_Row_Offset to 1
97943>>>                    Set Value to "NewTable"
97944>>>                    Procedure OnChange
97947>>>                        String sValue
97947>>>                        Get Value to sValue
97948>>>                        Set psTableName to sValue
97949>>>                    End_Procedure
97950>>>                    Send OnChange
97951>>>                End_Object
97952>>>
97952>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
97954>>>                    Set Size to 12 69
97955>>>                    Set Location to 114 271
97956>>>                    Set Label to "Add Table"
97957>>>                    Set psImage to "ActionAddTable1.ico"
97958>>>
97958>>>                    Procedure OnClick
97961>>>                        Boolean bOk
97961>>>                        Handle hTable
97961>>>                        String sTableName sDriverID
97961>>>
97961>>>                        Get Value of oDriverID3_cf to sDriverID
97962>>>                        Get Value of oApiTableName_fm to sTableName
97963>>>                        Move (Trim(sTableName)) to sTableName
97964>>>                        If (sTableName = "") Begin
97966>>>                            Send Info_Box "You first need to enter a table name."
97967>>>                            Procedure_Return
97968>>>                        End
97968>>>>
97968>>>
97968>>>                        Send Cursor_Wait of Cursor_Control
97969>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97970>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97971>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
97972>>>                        If (bOk = True) Begin
97974>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
97975>>>                        End
97975>>>>
97975>>>                        Else Begin
97976>>>                            Send Cursor_Ready of Cursor_Control
97977>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
97978>>>                            Procedure_Return
97979>>>                        End
97979>>>>
97979>>>
97979>>>                    End_Procedure
97980>>>
97980>>>                End_Object
97981>>>
97981>>>                Object oApiAddColumn_fm is a Form
97983>>>                    Set Size to 12 77
97984>>>                    Set Location to 141 14
97985>>>                    Set Label_Col_Offset to 0
97986>>>                    Set Label_Justification_Mode to JMode_Top
97987>>>                    Set Label to "Column Name:"
97988>>>                    Set Label_Row_Offset to 1
97989>>>                    Set Value to "NewColumn"
97990>>>                End_Object
97991>>>
97991>>>                Object oApiColumnType_cf is a ComboForm
97993>>>                    Set Size to 12 85
97994>>>                    Set Location to 141 96
97995>>>                    Set Label_Col_Offset to 0
97996>>>                    Set Label_Justification_Mode to JMode_Top
97997>>>                    Set Label_Row_Offset to 1
97998>>>                    Set Label to "Type:"
97999>>>                    Set Entry_State to False
98000>>>
98000>>>                    Procedure Combo_Fill_List
98003>>>                        tColumnType[] ColumnTypeArray
98003>>>                        tColumnType[] ColumnTypeArray
98004>>>                        Integer iSize iCount
98004>>>
98004>>>                        Send Delete_Data
98005>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98006>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98007>>>                        Decrement iSize
98008>>>                        For iCount from 0 to iSize
98014>>>>
98014>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98015>>>                        Loop
98016>>>>
98016>>>                        Set Value to ColumnTypeArray[0].sSQLType
98017>>>                    End_Procedure
98018>>>
98018>>>                    Procedure OnChange
98021>>>                        Integer iType iSize iDec
98021>>>                        tSQLConnection SQLConnection
98021>>>                        tSQLConnection SQLConnection
98021>>>                        Boolean bFixed
98021>>>
98021>>>                        Get SelectedType to iType
98022>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98023>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98024>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98025>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98026>>>
98026>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98027>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98028>>>                        Set Value         of oApiLength_sf   to iSize
98029>>>                        If (iDec = 0) Begin
98031>>>                            Set Value     of oApiDecimals_sf to ""
98032>>>                        End
98032>>>>
98032>>>                        Else Begin
98033>>>                            Set Value     of oApiDecimals_sf to iDec
98034>>>                        End
98034>>>>
98034>>>                        If (bFixed = False) Begin
98036>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98037>>>                        End
98037>>>>
98037>>>                    End_Procedure
98038>>>
98038>>>                    Function SelectedType Returns Integer
98041>>>                        String sValue
98041>>>                        Integer iType
98041>>>
98041>>>                        Get Value to sValue
98042>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98043>>>
98043>>>                        Function_Return iType
98044>>>                    End_Function
98045>>>
98045>>>                End_Object
98046>>>
98046>>>                Object oApiLength_sf is a SpinForm
98048>>>                    Set Label to "Length:"
98049>>>                    Set Size to 12 35
98050>>>                    Set Location to 141 186
98051>>>                    Set Label_Col_Offset to 0
98052>>>                    Set Label_Justification_Mode to JMode_Top
98053>>>                    Set Label_Row_Offset to 1
98054>>>                    Set Value to "10"
98055>>>                    Set Maximum_Position to 500
98056>>>                    Set Minimum_Position to 1
98057>>>                End_Object
98058>>>
98058>>>                Object oApiDecimals_sf is a SpinForm
98060>>>                    Set Label to "Decimals:"
98061>>>                    Set Size to 12 33
98062>>>                    Set Location to 141 225
98063>>>                    Set Label_Col_Offset to 0
98064>>>                    Set Label_Justification_Mode to JMode_Top
98065>>>                    Set Label_Row_Offset to 1
98066>>>                    Set Value to "0"
98067>>>                    Set Maximum_Position to 16
98068>>>                    Set Minimum_Position to 1
98069>>>                End_Object
98070>>>
98070>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98072>>>                    Set Size to 12 69
98073>>>                    Set Location to 141 271
98074>>>                    Set Label to "Add Column"
98075>>>                    Set psToolTip to "ApiColumnAdd function"
98076>>>                    Set psImage to "ActionAddColumn1.ico"
98077>>>
98077>>>                    Procedure OnClick
98080>>>                        Boolean bOk
98080>>>                        Handle hTable
98080>>>                        String sTableName sColumnName sType sDriverID
98080>>>                        Integer iType iLength iDecimals
98080>>>
98080>>>                        Get Value of oDriverID3_cf            to sDriverID
98081>>>                        Get Value of oApiTableName_fm         to sTableName
98082>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98083>>>                        Get SelectedType of oApiColumnType_cf to iType
98084>>>                        Get Value        of oApiLength_sf     to iLength
98085>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98086>>>
98086>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98087>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98088>>>                        If (hTable = 0) Begin
98090>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98091>>>                            Procedure_Return
98092>>>                        End
98092>>>>
98092>>>                        If (sColumnName = "") Begin
98094>>>                            Send Info_Box "You need to enter a column name"
98095>>>                            Procedure_Return
98096>>>                        End
98096>>>>
98096>>>
98096>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98097>>>                        If (bOk = True) Begin
98099>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98100>>>                        End
98100>>>>
98100>>>                        Else Begin
98101>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98102>>>                            Procedure_Return
98103>>>                        End
98103>>>>
98103>>>
98103>>>                    End_Procedure
98104>>>
98104>>>                End_Object
98105>>>
98105>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98107>>>                    Set Size to 26 77
98108>>>                    Set Location to 184 14
98109>>>                    Set Label to "Create 'New' Table with Three Columns"
98110>>>                    Set MultiLineState to True
98111>>>                    Set psImage to "ActionAddTable1.ico"
98112>>>
98112>>>                    Procedure OnClick
98115>>>                        Boolean bOk
98115>>>                        Handle hTable
98115>>>                        String sTableName sDriverID
98115>>>
98115>>>                        Get Value of oDriverID3_cf to sDriverID
98116>>>                        Get Value of oApiTableName_fm to sTableName
98117>>>                        Move (Trim(sTableName)) to sTableName
98118>>>                        If (sTableName = "") Begin
98120>>>                            Send Info_Box "You first need to enter a table name."
98121>>>                            Procedure_Return
98122>>>                        End
98122>>>>
98122>>>
98122>>>                        Send Cursor_Wait of Cursor_Control
98123>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98124>>>
98124>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98125>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98126>>>                        If (bOk = True) Begin
98128>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98129>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98130>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98131>>>                        End
98131>>>>
98131>>>                        Send Cursor_Ready of Cursor_Control
98132>>>
98132>>>                        If (bOk = True) Begin
98134>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98135>>>                        End
98135>>>>
98135>>>                        Else Begin
98136>>>                            Send Cursor_Ready of Cursor_Control
98137>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98138>>>                            Procedure_Return
98139>>>                        End
98139>>>>
98139>>>
98139>>>                    End_Procedure
98140>>>
98140>>>                End_Object
98141>>>
98141>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98143>>>                    Set Size to 26 77
98144>>>                    Set Location to 184 96
98145>>>                    Set Label to "Remove 'New' Table"
98146>>>                    Set psImage to "ActionDeleteTable1.ico"
98147>>>                    Set MultiLineState to True
98148>>>
98148>>>                    Procedure OnClick
98151>>>                        Boolean bOk
98151>>>                        Integer iRetval
98151>>>                        Handle hTable
98151>>>                        String sTableName sDriverID
98151>>>
98151>>>                        Get Value of oDriverID3_cf to sDriverID
98152>>>                        Get Value of oApiTableName_fm to sTableName
98153>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98154>>>                        If (iRetval = MBR_Yes) Begin
98156>>>                            Send Cursor_Wait of Cursor_Control
98157>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98158>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98159>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98160>>>                            Send Cursor_Ready of Cursor_Control
98161>>>                            If (bOk = True) Begin
98163>>>                                Send Info_Box "Table removed"
98164>>>                            End
98164>>>>
98164>>>                            Else Begin
98165>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98166>>>                            End
98166>>>>
98166>>>                        End
98166>>>>
98166>>>                    End_Procedure
98167>>>
98167>>>                End_Object
98168>>>
98168>>>                Object oLineControl1 is a LineControl
98170>>>                    Set Size to 2 387
98171>>>                    Set Location to 96 6
98172>>>                    Set peAnchors to anTopLeftRight
98173>>>                End_Object
98174>>>
98174>>>                Object oLineControl2 is a LineControl
98176>>>                    Set Size to 3 248
98177>>>                    Set Location to 171 9
98178>>>                End_Object
98179>>>
98179>>>                Object oTestError_fm is a Form
98181>>>                    Set Size to 13 64
98182>>>                    Set Location to 186 180
98183>>>                    Set Form_Datatype to 0 
98184>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98185>>>                End_Object
98186>>>
98186>>>Register_Function FetchErrorDescription Integer iError Returns String
98186>>>                Object oFindErrorText_Btn is a Button
98188>>>                    Set Size to 13 70
98189>>>                    Set Location to 186 248
98190>>>                    Set Label to "Find Error Text"
98191>>>                
98191>>>                    Procedure OnClick
98194>>>                        String sRetval
98194>>>                        Integer iError 
98194>>>                        Handle hoLogFile
98194>>>                        
98194>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98195>>>                        Get Value of oTestError_fm to iError
98196>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98197>>>                        Set Value of oErrorText_fm to sRetval    
98198>>>                    End_Procedure
98199>>>                
98199>>>                End_Object
98200>>>
98200>>>                Object oErrorText_fm is a Form
98202>>>                    Set Size to 13 213
98203>>>                    Set Location to 202 180
98204>>>                End_Object
98205>>>
98205>>>            End_Object
98206>>>
98206>>>        End_Object
98207>>>
98207>>>    End_Object
98208>>>
98208>>>End_Object
98209>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98209>>>
98209>>>Use Windows.pkg
98209>>>Use DFClient.pkg
98209>>>Use Dfline.pkg
98209>>>Use cDbScrollingContainer.pkg
98209>>>Use cRDCButtonDPI.pkg
98209>>>Use cDbUpdateFunctionLibrary.pkg
98209>>>Use Dftreevw.pkg
98209>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98209>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98209>>>>>//
98209>>>>>// This program is free software; you can redistribute it and/or
98209>>>>>// modify it under the terms of the GNU General Public License
98209>>>>>// as published by the Free Software Foundation; version 2
98209>>>>>// of the License.
98209>>>>>
98209>>>>>// This program is distributed in the hope that it will be useful,
98209>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98209>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98209>>>>>// GNU General Public License for more details.
98209>>>>>
98209>>>>>// You should have received a copy of the GNU General Public License
98209>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98209>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98209>>>>>Use Windows.pkg
98209>>>>>
98209>>>>>Object oWorkingMessagePanel is a ToolPanel
98211>>>>>    Set Label    to "Working"
98212>>>>>    Set Size to 48 150
98213>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98214>>>>>    Set Popup_State to True
98215>>>>>
98215>>>>>    Object oWorkingMessage is a Textbox
98217>>>>>        Set Label to "Working message..."
98218>>>>>        Set Location to 15 5
98219>>>>>        Set Size to 27 123
98220>>>>>        Set Auto_Size_State to False
98221>>>>>        Set Justification_Mode to JMode_Center
98222>>>>>        Set FontWeight to fw_Bold
98223>>>>>    End_Object
98224>>>>>
98224>>>>>End_Object
98225>>>>>
98225>>>>>Procedure StartWorkingMessage Global String sText
98227>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98228>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98229>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98230>>>>>End_Procedure
98231>>>>>
98231>>>>>Procedure StopWorkingMessage Global
98233>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98234>>>>>End_Procedure
98235>>>Use DUFStatusPanel.pkg
98235>>>Use cCharTranslate.pkg
98235>>>
98235>>>Struct tFilelistDUF
98235>>>    Integer iFileNumber
98235>>>    String sLogicalName
98235>>>    String sRootName
98235>>>    String sDisplayName
98235>>>End_Struct
98235>>>
98235>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98245>>>>
98245>>>Object oUtilFunctions_vw is a dbView
98247>>>    Set Border_Style to Border_Thick
98248>>>    Set Size to 291 428
98249>>>    Set Location to 2 1
98250>>>    Set Label to "Utility Functions"
98251>>>    Set pbAutoActivate to True
98252>>>    Set Icon to "TestTools1.ico"
98253>>>    Set pbAcceptDropFiles to True
98254>>>
98254>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98256>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98258>>>
98258>>>            Object oSQL_grp is a Group
98260>>>                Set Size to 88 402
98261>>>                Set Location to 7 12
98262>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98263>>>                Set peAnchors to anTopLeftRight
98264>>>
98264>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98266>>>                    Set Size to 14 219
98267>>>                    Set Location to 13 13
98268>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98269>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98270>>>                    Set psImage to "ActionCreateDatabase1.ico"
98271>>>
98271>>>                    Procedure OnClick
98274>>>                        String sInfoText sDriverID
98274>>>                        Boolean bOK
98274>>>                        TimeSpan tsTotalQueryTime
98274>>>                        Integer iRetval
98274>>>
98274>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98274>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98274>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98274>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98275>>>                        If (iRetval <> MBR_Yes) Begin
98277>>>                            Procedure_Return
98278>>>                        End
98278>>>>
98278>>>
98278>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98279>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98281>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98282>>>                            Procedure_Return
98283>>>                        End
98283>>>>
98283>>>
98283>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98284>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98285>>>                        Send StopWorkingMessage
98286>>>
98286>>>                        If (bOK = True) Begin
98288>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98289>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98290>>>                        End
98290>>>>
98290>>>
98290>>>                        Else Begin
98291>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98292>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98293>>>                        End
98293>>>>
98293>>>
98293>>>                        Send Info_Box sInfoText
98294>>>                    End_Procedure
98295>>>
98295>>>                End_Object
98296>>>
98296>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98298>>>                    Set Size to 14 219
98299>>>                    Set Location to 33 13
98300>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98301>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98302>>>                    Set psImage to "ActionCreateDatabase1.ico"
98303>>>
98303>>>                    Procedure OnClick
98306>>>                        String sInfoText sDriverID
98306>>>                        Boolean bOK
98306>>>                        TimeSpan tsTotalQueryTime
98306>>>                        Integer iRetval
98306>>>
98306>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98306>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98306>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98306>>>
98306>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98307>>>                        If (iRetval <> MBR_Yes) Begin
98309>>>                            Procedure_Return
98310>>>                        End
98310>>>>
98310>>>
98310>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98311>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98313>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98314>>>                            Procedure_Return
98315>>>                        End
98315>>>>
98315>>>
98315>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98316>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98317>>>                        Send StopWorkingMessage
98318>>>
98318>>>                        If (bOK = True) Begin
98320>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98321>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98322>>>                        End
98322>>>>
98322>>>
98322>>>                        Else Begin
98323>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98324>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98325>>>                        End
98325>>>>
98325>>>
98325>>>                        Send Info_Box sInfoText
98326>>>                    End_Procedure
98327>>>
98327>>>                End_Object
98328>>>
98328>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98330>>>                    Set Size to 14 219
98331>>>                    Set Location to 53 13
98332>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98333>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98334>>>                    Set psImage to "ActionCreateDatabase1.ico"
98335>>>
98335>>>                    Procedure OnClick
98338>>>                        String sInfoText sDriverID
98338>>>                        Boolean bOK
98338>>>                        TimeSpan tsTotalQueryTime
98338>>>                        Integer iRetval
98338>>>
98338>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98338>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98338>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98338>>>
98338>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98339>>>                        If (iRetval <> MBR_Yes) Begin
98341>>>                            Procedure_Return
98342>>>                        End
98342>>>>
98342>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98343>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98345>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98346>>>                            Procedure_Return
98347>>>                        End
98347>>>>
98347>>>
98347>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98348>>>
98348>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98349>>>
98349>>>                        Send StopWorkingMessage
98350>>>                        If (bOK = True) Begin
98352>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98353>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98354>>>                        End
98354>>>>
98354>>>
98354>>>                        Else Begin
98355>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98356>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98357>>>                        End
98357>>>>
98357>>>
98357>>>                        Send Info_Box sInfoText
98358>>>                    End_Procedure
98359>>>
98359>>>                End_Object
98360>>>
98360>>>                Object oInfo_tb is a TextBox
98362>>>                    Set Auto_Size_State to False
98363>>>                    Set Size to 25 158
98364>>>                    Set Location to 53 238
98365>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98366>>>                    Set Justification_Mode to JMode_Left
98367>>>                    Set peAnchors to anTopLeftRight
98368>>>                End_Object
98369>>>
98369>>>        //  This will choke the computer so don't try it!
98369>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98369>>>        //            Set Size to 14 312
98369>>>        //            Set Location to 97 45
98369>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98369>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98369>>>        //
98369>>>        //            Procedure OnClick
98369>>>        //                String sInfoText
98369>>>        //                Boolean bOK
98369>>>        //                TimeSpan tsTotalQueryTime
98369>>>        //                Integer iRetval
98369>>>        //
98369>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98369>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98369>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98369>>>        //Procedure_Return
98369>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98369>>>        //                If (iRetval <> MBR_Yes) Begin
98369>>>        //                    Procedure_Return
98369>>>        //                End
98369>>>        //
98369>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98369>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98369>>>        //                Send StopWorkingMessage
98369>>>        //
98369>>>        //                If (bOK = True) Begin
98369>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98369>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98369>>>        //                End
98369>>>        //
98369>>>        //                Else Begin
98369>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98369>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98369>>>        //                End
98369>>>        //
98369>>>        //                Send Info_Box sInfoText
98369>>>        //            End_Procedure
98369>>>        //
98369>>>        //        End_Object
98369>>>
98369>>>            End_Object
98370>>>
98370>>>            Object oChangeIntFiles_grp is a Group
98372>>>                Set Size to 65 402
98373>>>                Set Location to 102 12
98374>>>                Set Label to "Change Old .int files to use Connection ID's"
98375>>>                Set peAnchors to anTopLeftRight
98376>>>
98376>>>                Object oSelectDataPath_fm is a Form
98378>>>                    Set Size to 12 300
98379>>>                    Set Location to 22 13
98380>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98381>>>                    Set Label_Col_Offset to 0
98382>>>                    Set Label_Row_Offset to 1
98383>>>                    Set Label_Justification_Mode to JMode_Top
98384>>>
98384>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98384>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98384>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98385>>>                    Set peAnchors to anTopLeftRight
98386>>>
98386>>>                    Procedure Prompt
98389>>>                        String sPath sFileMask sRetval
98389>>>
98389>>>                        Get psDataPathFirstPart to sPath
98390>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98391>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98392>>>                        If (sRetval <> "") Begin
98394>>>                            Get ParseFolderName sRetval to sPath
98395>>>                            If (Right(sPath, 1) ="\") Begin
98397>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98398>>>                            End
98398>>>>
98398>>>                            Set Value to sPath
98399>>>                        End
98399>>>>
98399>>>                    End_Procedure
98400>>>
98400>>>                    // Returns the first datapath found in the psDataPath property.
98400>>>                    // The returned path always ends with a "\"
98400>>>                    Function psDataPathFirstPart Returns String
98403>>>                        String sDataPath
98403>>>                        Integer iCount
98403>>>
98403>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98404>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98405>>>                        If (iCount > 1) Begin
98407>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98408>>>                        End
98408>>>>
98408>>>                        If (sDataPath <> "") Begin
98410>>>                            Get vFolderFormat sDataPath to sDataPath
98411>>>                        End
98411>>>>
98411>>>
98411>>>                        Function_Return sDataPath
98412>>>                    End_Function
98413>>>
98413>>>                End_Object
98414>>>
98414>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98416>>>                    Set Size to 13 73
98417>>>                    Set Location to 22 320
98418>>>                    Set Label to "Select Folder"
98419>>>                    Set psToolTip to "Please select an .int file from the data folder"
98420>>>                    Set peAnchors to anTopRight
98421>>>                    Set psImage to "ActionOpen1.ico"
98422>>>
98422>>>                    Procedure OnClick
98425>>>                        Send Prompt to oSelectDataPath_fm
98426>>>                    End_Procedure
98427>>>
98427>>>                End_Object
98428>>>
98428>>>                Object oConnectionID_fm is a Form
98430>>>                    Set Size to 13 111
98431>>>                    Set Location to 38 202
98432>>>                    Set Label_Col_Offset to 2
98433>>>                    Set Label_Justification_Mode to JMode_Right
98434>>>                    Set Label to "Change to DFConnID:"
98435>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98436>>>                    Set peAnchors to anTopRight
98437>>>                End_Object
98438>>>
98438>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98440>>>                    Set Size to 13 68
98441>>>                    Set Location to 38 320
98442>>>                    Set Label to "GO !"
98443>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98444>>>                    Set FontWeight to fw_Bold
98445>>>                    Set peAnchors to anTopRight
98446>>>
98446>>>                    Procedure OnClick
98449>>>                        String sDataPath sConnectionID
98449>>>                        Boolean bExists bActive
98449>>>                        Integer iRetval
98449>>>
98449>>>                        Get Value of oSelectDataPath_fm to sDataPath
98450>>>                        Get vFolderExists sDataPath to bExists
98451>>>                        If (bExists = False) Begin
98453>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98454>>>                            Procedure_Return
98455>>>                        End
98455>>>>
98455>>>                        Get Value of oConnectionID_fm to sConnectionID
98456>>>                        Move (Trim(sConnectionID)) to sConnectionID
98457>>>                        If (sConnectionID = "") Begin
98459>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98460>>>                            Procedure_Return
98461>>>                        End
98461>>>>
98461>>>
98461>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98462>>>                        If (iRetval <> MBR_Yes) Begin
98464>>>                            Procedure_Return
98465>>>                        End
98465>>>>
98465>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98466>>>                        If (iRetval <> MBR_Yes) Begin
98468>>>                            Procedure_Return
98469>>>                        End
98469>>>>
98469>>>
98469>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
98470>>>                        If (iRetval <> 0) Begin
98472>>>                            Send Info_Box "Could not delete .cch files!"
98473>>>                            Procedure_Return
98474>>>                        End
98474>>>>
98474>>>
98474>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
98475>>>                        Send Start_StatusPanel of ghoStatusPanel
98476>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
98477>>>
98477>>>                        Get Active_State of ghoStatusPanel to bActive
98478>>>                        If (bActive = False) Begin
98480>>>                            Send Info_Box "Process interupted..."
98481>>>                        End
98481>>>>
98481>>>                        Else Begin
98482>>>                            Send Stop_StatusPanel of ghoStatusPanel
98483>>>                            Send Info_Box "Ready! All .int files changed."
98484>>>                        End
98484>>>>
98484>>>                    End_Procedure
98485>>>
98485>>>                End_Object
98486>>>
98486>>>            End_Object
98487>>>
98487>>>            Object oRemoveFilelistDriverIDs_grp is a Group
98489>>>                Set Size to 59 402
98490>>>                Set Location to 171 12
98491>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
98492>>>                Set peAnchors to anTopLeftRight
98493>>>//                Set TextColor to clGreen
98493>>>//
98493>>>//                Procedure Page Integer iPage
98493>>>//                    Integer ia iz
98493>>>//                    Forward Send Page iPage
98493>>>//                    Move 0 to iz
98493>>>//                    Move (AddressOf(iz)) to ia
98493>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
98493>>>//                End_Procedure
98493>>>
98493>>>                Object oFilelistPath_fm is a Form
98495>>>                    Set Size to 13 299
98496>>>                    Set Location to 22 13
98497>>>                    Set Label to "Path and Filelist.cfg Name:"
98498>>>                    Set Label_Col_Offset to 0
98499>>>                    Set Label_Row_Offset to 1
98500>>>                    Set Label_Justification_Mode to JMode_Top
98501>>>
98501>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98501>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98501>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
98502>>>                    Set peAnchors to anTopLeftRight
98503>>>
98503>>>                    Procedure Prompt
98506>>>                        String sFileName sPath sFileMask sRetval
98506>>>
98506>>>                        Get Value to sFileName
98507>>>                        Get ParseFolderName sFileName to sPath
98508>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
98509>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
98510>>>                        If (sRetval <> "") Begin
98512>>>                            Set Value to sRetval
98513>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
98516>>>                        End
98516>>>>
98516>>>                    End_Procedure
98517>>>
98517>>>                    Procedure OnCreate
98520>>>                        String sFilelist
98520>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
98523>>>                        Set Value to sFilelist
98524>>>                    End_Procedure
98525>>>                    Send OnCreate
98526>>>
98526>>>                End_Object
98527>>>
98527>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
98529>>>                    Set Size to 13 73
98530>>>                    Set Location to 22 319
98531>>>                    Set Label to "Select Filelist.cfg"
98532>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
98533>>>                    Set peAnchors to anTopRight
98534>>>
98534>>>                    Procedure OnClick
98537>>>                        Send Prompt to oFilelistPath_fm
98538>>>                    End_Procedure
98539>>>
98539>>>                End_Object
98540>>>
98540>>>                Object oInfo_tb is a TextBox
98542>>>                    Set Size to 9 207
98543>>>                    Set Location to 40 138
98544>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
98545>>>                    Set peAnchors to anTopRight
98546>>>                End_Object
98547>>>
98547>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
98549>>>                    Set Size to 13 68
98550>>>                    Set Location to 38 319
98551>>>                    Set Label to "GO !"
98552>>>                    Set FontWeight to fw_Bold
98553>>>                    Set peAnchors to anTopRight
98554>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
98555>>>
98555>>>                    Procedure OnClick
98558>>>                        String sFileList
98558>>>                        Integer iRetval iCount
98558>>>                        Boolean bExits
98558>>>
98558>>>                        Get Value of oFilelistPath_fm to sFileList
98559>>>                        Get vFilePathExists sFileList to bExits
98560>>>                        If (bExits = False) Begin
98562>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
98563>>>                            Procedure_Return
98564>>>                        End
98564>>>>
98564>>>
98564>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
98565>>>                        If (iRetval <> MBR_Yes) Begin
98567>>>                            Procedure_Return
98568>>>                        End
98568>>>>
98568>>>                        Send Cursor_Wait of Cursor_Control
98569>>>
98569>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
98570>>>
98570>>>                        Send Cursor_Ready of Cursor_Control
98571>>>                        If (iCount <> 0) Begin
98573>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
98574>>>                        End
98574>>>>
98574>>>                        Else Begin
98575>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
98576>>>                        End
98576>>>>
98576>>>
98576>>>                    End_Procedure
98577>>>
98577>>>                End_Object
98578>>>
98578>>>            End_Object
98579>>>
98579>>>            Object oOutput_grp is a Group
98581>>>                Set Size to 47 402
98582>>>                Set Location to 234 12
98583>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
98584>>>                Set peAnchors to anTopLeftRight
98585>>>
98585>>>                Object oOutput_rg is a RadioGroup
98587>>>                    Set Location to 18 13
98588>>>                    Set Size to 25 288
98589>>>                    Set Label to "Filelist Output Order"
98590>>>
98590>>>                    Object oRadio1 is a Radio
98592>>>                        Set Label to "Filelist Number"
98593>>>                        Set Size to 10 61
98594>>>                        Set Location to 10 7
98595>>>                    End_Object
98596>>>
98596>>>                    Object oRadio2 is a Radio
98598>>>                        Set Label to "Logical Name"
98599>>>                        Set Size to 10 61
98600>>>                        Set Location to 10 77
98601>>>                    End_Object
98602>>>
98602>>>                    Object oRadio3 is a Radio
98604>>>                        Set Label to "Root Name"
98605>>>                        Set Size to 10 61
98606>>>                        Set Location to 10 147
98607>>>                    End_Object
98608>>>
98608>>>                    Object oRadio4 is a Radio
98610>>>                        Set Label to "Display Name"
98611>>>                        Set Size to 10 62
98612>>>                        Set Location to 10 213
98613>>>                    End_Object
98614>>>
98614>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
98617>>>                        Forward Send Notify_Select_State iToItem iFromItem
98619>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
98620>>>                    End_Procedure
98621>>>
98621>>>                End_Object
98622>>>                
98622>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
98624>>>                    Set Size to 13 78
98625>>>                    Set Location to 26 315
98626>>>                    Set Label to "Print to Filelist.txt"
98627>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
98628>>>                    Set psImage to "ActionDocument1.ico"
98629>>>
98629>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
98631>>>
98631>>>                    // Custom array sort function.
98631>>>                    // iSortOrder = 0 -> Filelist number order
98631>>>                    // iSortOrder = 1 -> Logical name order
98631>>>                    // iSortOrder = 2 -> Root name order
98631>>>                    // iSortOrder = 3 -> Display name order
98631>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
98634>>>                        Integer iSortOrder
98634>>>
98634>>>                        Get piSortOrder to iSortOrder
98635>>>
98635>>>                        Case Begin
98635>>>                            Case (iSortOrder = 0)
98637>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
98639>>>                                    Function_Return (GT)
98640>>>                                End
98640>>>>
98640>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
98642>>>                                    Function_Return (LT)
98643>>>                                End
98643>>>>
98643>>>                                Function_Return (EQ)
98644>>>                            Case (iSortOrder = 1)
98647>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
98649>>>                                    Function_Return (GT)
98650>>>                                End
98650>>>>
98650>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
98652>>>                                    Function_Return (LT)
98653>>>                                End
98653>>>>
98653>>>                                Function_Return (EQ)
98654>>>                            Case (iSortOrder = 2)
98657>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
98659>>>                                    Function_Return (GT)
98660>>>                                End
98660>>>>
98660>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
98662>>>                                    Function_Return (LT)
98663>>>                                End
98663>>>>
98663>>>                                Function_Return (EQ)
98664>>>                            Case (iSortOrder = 3)
98667>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
98669>>>                                    Function_Return (GT)
98670>>>                                End
98670>>>>
98670>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
98672>>>                                    Function_Return (LT)
98673>>>                                End
98673>>>>
98673>>>                                Function_Return (EQ)
98674>>>                        Case End
98674>>>
98674>>>                    End_Function
98675>>>
98675>>>                    Procedure OnClick
98678>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
98678>>>                        Integer iCh iCount iSize
98678>>>                        Handle hTable
98678>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98678>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98680>>>
98680>>>                        Get Value of oFilelistPath_fm to sFileList
98681>>>                        Move (Trim(sFileList)) to sFileList
98682>>>                        If (sFileList = "") Begin
98684>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
98685>>>                            Procedure_Return
98686>>>                        End
98686>>>>
98686>>>
98686>>>                        Get ParseFolderName sFileList to sPath
98687>>>                        Get vFolderFormat sPath to sPath
98688>>>                        Get ParseFileName sFileList to sOutputName
98689>>>                        Get ParseFileExtension sFileList to sExt
98690>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
98691>>>                        Move (sOutputName + "txt")           to sOutputName
98692>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
98693>>>                        If (iCh < 0) Begin
98695>>>                            Procedure_Return
98696>>>                        End
98696>>>>
98696>>>
98696>>>                        Move 0 to hTable
98697>>>                        Writeln channel iCh sFileList
98700>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
98703>>>                        Writeln channel iCh "==================================================================================================="
98706>>>                        Writeln channel iCh
98708>>>
98708>>>                        Move 0 to iCount
98709>>>                        Repeat
98709>>>>
98709>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98712>>>                            If (hTable > 0) Begin
98714>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
98715>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
98718>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
98721>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
98724>>>                                Increment iCount
98725>>>                            End
98725>>>>
98725>>>                        Until (hTable = 0)
98727>>>
98727>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
98728>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
98729>>>                        Decrement iSize
98730>>>
98730>>>                        For iCount from 0 to iSize
98736>>>>
98736>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
98737>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
98738>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
98739>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
98740>>>
98740>>>                            Get PadLeft (String(hTable))        09 to sTable
98741>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
98742>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
98743>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
98744>>>
98744>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
98750>>>                        Loop
98751>>>>
98751>>>
98751>>>                        Writeln channel iCh "==================================================================================================="
98754>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
98758>>>                        Close_Output
98759>>>
98759>>>                        Send vShellExecute "open" sOutputName "" sPath
98760>>>                    End_Procedure
98761>>>
98761>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
98764>>>                        String sChar
98764>>>
98764>>>                        If (Num_Arguments >= 3) Begin
98766>>>                            Move sOptChar to sChar
98767>>>                        End
98767>>>>
98767>>>                        Else Begin
98768>>>                            Move " " to sChar
98769>>>                        End
98769>>>>
98769>>>
98769>>>                        While (Length(sString) < iLength)
98773>>>                            Move (sChar + sString) to sString
98774>>>                        Loop
98775>>>>
98775>>>
98775>>>                        Function_Return sString
98776>>>                    End_Function
98777>>>
98777>>>                End_Object
98778>>>            End_Object
98779>>>
98779>>>        End_Object
98780>>>
98780>>>    End_Object
98781>>>
98781>>>    Procedure OnFileDropped String sFilename Boolean bLast
98784>>>        String sTest
98784>>>        Forward Send OnFileDropped sFilename bLast
98786>>>        If (bLast = True) Begin
98788>>>            Get ParseFileName sFilename to sTest
98789>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
98791>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
98792>>>                Procedure_Return
98793>>>            End
98793>>>>
98793>>>            Set Value of oFilelistPath_fm to sFilename
98794>>>        End
98794>>>>
98794>>>    End_Procedure
98795>>>
98795>>>End_Object
98796>
98796>        Procedure Activate_About
98799>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
98800>        End_Procedure
98801>
98801>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
98802>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
98803>        On_Key Key_Ctrl+Key_W             Send Close_Panel
98804>    End_Object
98805>
98805>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
98805>    // in the oHtmlHelp object, so we need to explitetly send the message
98805>    // to that object.
98805>    Procedure ShowProgramHelp
98808>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
98809>    End_Procedure
98810>
98810>    On_Key Key_F1 Send ShowProgramHelp
98811>End_Object
98812>
98812>// We do this to activate the first view:
98812>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
98812>Start_UI
98813>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52597
Total Resources: 9
Total Commands : 98812
Total Windows  : 0
Total Pages    : 0
Static Data    : 769517
Message area   : 636957
Total Blocks   : 75391
