Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 2147483646
1>
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>Use cCJCommandBarSystem.pkg
67884>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
67884>>>Use windows.pkg
67884>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
67884>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
67884>>>>>Use FlexCom20.pkg
67884>>>>>
67884>>>>>// Changes to Imported package
67884>>>>>//     OLEXTPxx to XTPxx
67884>>>>>//     OLExtpxx to xtpxx
67884>>>>>//     OLESkinFramework to SkinFramework
67884>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
67884>>>>>//     cCom classes to cCJ
67884>>>>>//     cCJAutomationObject back to cComAutomationObject
67884>>>>>//     cCJActiveXControl back to cComActiveXControl
67884>>>>>//     cCJSkinFramework to cCJComSkinFramework
67884>>>>>//     Use statements as noted below (classes moved to these files)
67884>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
67884>>>>>
67884>>>>>// These have been extracted from this class and moved into seperate packages
67884>>>>>// because other Codejock classes use these.
67884>>>>>Use cCJColorManager.pkg     // cCJColorManager
67884>>>>>
67884>>>>>Define SkinFrameworkApplyOptions for Integer
67884>>>>>    Define xtpSkinApplyMetrics for 1
67884>>>>>    Define xtpSkinApplyFrame for 2
67884>>>>>    Define xtpSkinApplyColors for 4
67884>>>>>    Define xtpSkinApplyMenus for 8
67884>>>>>
67884>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
67884>>>>>// Dispatch interface for SkinFramework Control
67884>>>>>Class cCJ_DSkinFramework is a Mixin
67885>>>>>
67885>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
67887>>>>>        SkinFrameworkApplyOptions retVal
67887>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
67888>>>>>        Function_Return retVal
67889>>>>>    End_Function
67890>>>>>
67890>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
67892>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
67893>>>>>    End_Procedure
67894>>>>>
67894>>>>>    Function ComAutoApplyNewWindows Returns Boolean
67896>>>>>        Boolean retVal
67896>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
67897>>>>>        Function_Return retVal
67898>>>>>    End_Function
67899>>>>>
67899>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
67901>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
67902>>>>>    End_Procedure
67903>>>>>
67903>>>>>    Function ComAutoApplyNewThreads Returns Boolean
67905>>>>>        Boolean retVal
67905>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
67906>>>>>        Function_Return retVal
67907>>>>>    End_Function
67908>>>>>
67908>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
67910>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
67911>>>>>    End_Procedure
67912>>>>>
67912>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
67914>>>>>        Handle hDispatchDriver
67914>>>>>        Boolean retVal
67914>>>>>        Get phDispatchDriver to hDispatchDriver
67915>>>>>        Send PrepareParams to hDispatchDriver 2
67916>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
67917>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
67918>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
67919>>>>>        Function_Return retVal
67920>>>>>    End_Function
67921>>>>>
67921>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
67923>>>>>        Handle hDispatchDriver
67923>>>>>        Get phDispatchDriver to hDispatchDriver
67924>>>>>        Send PrepareParams to hDispatchDriver 1
67925>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
67926>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
67927>>>>>    End_Procedure
67928>>>>>
67928>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
67930>>>>>        Handle hDispatchDriver
67930>>>>>        Get phDispatchDriver to hDispatchDriver
67931>>>>>        Send PrepareParams to hDispatchDriver 2
67932>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
67933>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
67934>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
67935>>>>>    End_Procedure
67936>>>>>
67936>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
67938>>>>>        Handle hDispatchDriver
67938>>>>>        Get phDispatchDriver to hDispatchDriver
67939>>>>>        Send PrepareParams to hDispatchDriver 1
67940>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
67941>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
67942>>>>>    End_Procedure
67943>>>>>
67943>>>>>    Procedure ComRemoveAllWindows
67945>>>>>        Handle hDispatchDriver
67945>>>>>        Get phDispatchDriver to hDispatchDriver
67946>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
67947>>>>>    End_Procedure
67948>>>>>
67948>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
67950>>>>>        Handle hDispatchDriver
67950>>>>>        Get phDispatchDriver to hDispatchDriver
67951>>>>>        Send PrepareParams to hDispatchDriver 2
67952>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
67953>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
67954>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
67955>>>>>    End_Procedure
67956>>>>>
67956>>>>>    Procedure ComRemoveWindowClass String llClassName
67958>>>>>        Handle hDispatchDriver
67958>>>>>        Get phDispatchDriver to hDispatchDriver
67959>>>>>        Send PrepareParams to hDispatchDriver 1
67960>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
67961>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
67962>>>>>    End_Procedure
67963>>>>>
67963>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
67965>>>>>        Handle hDispatchDriver
67965>>>>>        Variant retVal
67965>>>>>        Get phDispatchDriver to hDispatchDriver
67966>>>>>        Send PrepareParams to hDispatchDriver 2
67967>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
67968>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
67969>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
67970>>>>>        Function_Return retVal
67971>>>>>    End_Function
67972>>>>>
67972>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
67974>>>>>        Handle hDispatchDriver
67974>>>>>        Variant retVal
67974>>>>>        Get phDispatchDriver to hDispatchDriver
67975>>>>>        Send PrepareParams to hDispatchDriver 1
67976>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
67977>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
67978>>>>>        Function_Return retVal
67979>>>>>    End_Function
67980>>>>>
67980>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
67982>>>>>        Handle hDispatchDriver
67982>>>>>        OLE_COLOR retVal
67982>>>>>        Get phDispatchDriver to hDispatchDriver
67983>>>>>        Send PrepareParams to hDispatchDriver 1
67984>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
67985>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
67986>>>>>        Function_Return retVal
67987>>>>>    End_Function
67988>>>>>
67988>>>>>    Procedure ComExcludeModule String llModuleName
67990>>>>>        Handle hDispatchDriver
67990>>>>>        Get phDispatchDriver to hDispatchDriver
67991>>>>>        Send PrepareParams to hDispatchDriver 1
67992>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
67993>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
67994>>>>>    End_Procedure
67995>>>>>
67995>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
67997>>>>>        Handle hDispatchDriver
67997>>>>>        Variant retVal
67997>>>>>        Get phDispatchDriver to hDispatchDriver
67998>>>>>        Send PrepareParams to hDispatchDriver 2
67999>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
68000>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
68001>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
68002>>>>>        Function_Return retVal
68003>>>>>    End_Function
68004>>>>>
68004>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
68006>>>>>        Handle hDispatchDriver
68006>>>>>        Get phDispatchDriver to hDispatchDriver
68007>>>>>        Send PrepareParams to hDispatchDriver 2
68008>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68009>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
68010>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
68011>>>>>    End_Procedure
68012>>>>>
68012>>>>>    Procedure ComAboutBox
68014>>>>>        Handle hDispatchDriver
68014>>>>>        Get phDispatchDriver to hDispatchDriver
68015>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
68016>>>>>    End_Procedure
68017>>>>>End_Class
68018>>>>>
68018>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
68018>>>>>// Event interface for SkinFramework Control
68018>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
68019>>>>>
68019>>>>>    Procedure RegisterComEvents
68021>>>>>    End_Procedure
68022>>>>>End_Class
68023>>>>>
68023>>>>>// CoClass
68023>>>>>// ProgID: Codejock.SkinFramework.18.3.0
68023>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
68023>>>>>// SkinFramework Control
68023>>>>>Class cCJComSkinFramework is a cComActiveXControl
68024>>>>>    Import_Class_Protocol cCJ_DSkinFramework
68025>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
68026>>>>>
68026>>>>>    Procedure Construct_Object
68028>>>>>        Forward Send Construct_Object
68030>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
68031>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
68032>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
68033>>>>>        Set peAutoCreate to acAutoCreate
68034>>>>>    End_Procedure
68035>>>>>End_Class
68036>>>>>
68036>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
68036>>>>>// SkinFramework Global Settings
68036>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
68037>>>>>
68037>>>>>    Function ComLicense Returns String
68039>>>>>        String retVal
68039>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
68040>>>>>        Function_Return retVal
68041>>>>>    End_Function
68042>>>>>
68042>>>>>    Procedure Set ComLicense String value
68044>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
68045>>>>>    End_Procedure
68046>>>>>
68046>>>>>    Function ComTitle Returns String
68048>>>>>        String retVal
68048>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
68049>>>>>        Function_Return retVal
68050>>>>>    End_Function
68051>>>>>
68051>>>>>    Procedure Set ComTitle String value
68053>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
68054>>>>>    End_Procedure
68055>>>>>
68055>>>>>    Function ComVersion Returns String
68057>>>>>        Handle hDispatchDriver
68057>>>>>        String retVal
68057>>>>>        Get phDispatchDriver to hDispatchDriver
68058>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
68059>>>>>        Function_Return retVal
68060>>>>>    End_Function
68061>>>>>
68061>>>>>    Function ComUnicode Returns Boolean
68063>>>>>        Handle hDispatchDriver
68063>>>>>        Boolean retVal
68063>>>>>        Get phDispatchDriver to hDispatchDriver
68064>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
68065>>>>>        Function_Return retVal
68066>>>>>    End_Function
68067>>>>>
68067>>>>>    Function ComOcxPath Returns String
68069>>>>>        Handle hDispatchDriver
68069>>>>>        String retVal
68069>>>>>        Get phDispatchDriver to hDispatchDriver
68070>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
68071>>>>>        Function_Return retVal
68072>>>>>    End_Function
68073>>>>>End_Class
68074>>>>>
68074>>>>>// CoClass
68074>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
68074>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
68074>>>>>// SkinFramework Global Settings
68074>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
68075>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
68076>>>>>
68076>>>>>    Procedure Construct_Object
68078>>>>>        Forward Send Construct_Object
68080>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
68081>>>>>        Set peAutoCreate to acNoAutoCreate
68082>>>>>    End_Procedure
68083>>>>>End_Class
68084>>>>>
68084>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
68084>>>>>Class cCJSkinIniFile is a cComAutomationObject
68085>>>>>
68085>>>>>    Function ComColorScheme Returns String
68087>>>>>        String retVal
68087>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68088>>>>>        Function_Return retVal
68089>>>>>    End_Function
68090>>>>>
68090>>>>>    Procedure Set ComColorScheme String value
68092>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68093>>>>>    End_Procedure
68094>>>>>
68094>>>>>    Function ComFontSize Returns String
68096>>>>>        String retVal
68096>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68097>>>>>        Function_Return retVal
68098>>>>>    End_Function
68099>>>>>
68099>>>>>    Procedure Set ComFontSize String value
68101>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68102>>>>>    End_Procedure
68103>>>>>
68103>>>>>    Function ComIniFileName Returns String
68105>>>>>        String retVal
68105>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
68106>>>>>        Function_Return retVal
68107>>>>>    End_Function
68108>>>>>
68108>>>>>    Procedure Set ComIniFileName String value
68110>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
68111>>>>>    End_Procedure
68112>>>>>End_Class
68113>>>>>
68113>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
68113>>>>>Class cCJSkinDescription is a cComAutomationObject
68114>>>>>
68114>>>>>    Function ComName Returns String
68116>>>>>        String retVal
68116>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68117>>>>>        Function_Return retVal
68118>>>>>    End_Function
68119>>>>>
68119>>>>>    Procedure Set ComName String value
68121>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68122>>>>>    End_Procedure
68123>>>>>
68123>>>>>    Function ComPath Returns String
68125>>>>>        String retVal
68125>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68126>>>>>        Function_Return retVal
68127>>>>>    End_Function
68128>>>>>
68128>>>>>    Procedure Set ComPath String value
68130>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68131>>>>>    End_Procedure
68132>>>>>
68132>>>>>    Function ComCount Returns Integer
68134>>>>>        Handle hDispatchDriver
68134>>>>>        Integer retVal
68134>>>>>        Get phDispatchDriver to hDispatchDriver
68135>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68136>>>>>        Function_Return retVal
68137>>>>>    End_Function
68138>>>>>
68138>>>>>    Function ComIniFile Integer llIndex Returns Variant
68140>>>>>        Handle hDispatchDriver
68140>>>>>        Variant retVal
68140>>>>>        Get phDispatchDriver to hDispatchDriver
68141>>>>>        Send PrepareParams to hDispatchDriver 1
68142>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68143>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68144>>>>>        Function_Return retVal
68145>>>>>    End_Function
68146>>>>>
68146>>>>>    Function Com_NewEnum Returns Variant
68148>>>>>        Handle hDispatchDriver
68148>>>>>        Variant retVal
68148>>>>>        Get phDispatchDriver to hDispatchDriver
68149>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68150>>>>>        Function_Return retVal
68151>>>>>    End_Function
68152>>>>>End_Class
68153>>>>>
68153>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
68153>>>>>Class cCJSkinDescriptions is a cComAutomationObject
68154>>>>>
68154>>>>>    Function ComCount Returns Integer
68156>>>>>        Handle hDispatchDriver
68156>>>>>        Integer retVal
68156>>>>>        Get phDispatchDriver to hDispatchDriver
68157>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68158>>>>>        Function_Return retVal
68159>>>>>    End_Function
68160>>>>>
68160>>>>>    Function ComSkin Integer llIndex Returns Variant
68162>>>>>        Handle hDispatchDriver
68162>>>>>        Variant retVal
68162>>>>>        Get phDispatchDriver to hDispatchDriver
68163>>>>>        Send PrepareParams to hDispatchDriver 1
68164>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68165>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68166>>>>>        Function_Return retVal
68167>>>>>    End_Function
68168>>>>>
68168>>>>>    Function Com_NewEnum Returns Variant
68170>>>>>        Handle hDispatchDriver
68170>>>>>        Variant retVal
68170>>>>>        Get phDispatchDriver to hDispatchDriver
68171>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68172>>>>>        Function_Return retVal
68173>>>>>    End_Function
68174>>>>>End_Class
68175>>>>>
68175>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
68175>>>>>Class cCJSkinSchema is a cComAutomationObject
68176>>>>>
68176>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
68178>>>>>        Handle hDispatchDriver
68178>>>>>        OLE_COLOR retVal
68178>>>>>        Get phDispatchDriver to hDispatchDriver
68179>>>>>        Send PrepareParams to hDispatchDriver 1
68180>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68181>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
68182>>>>>        Function_Return retVal
68183>>>>>    End_Function
68184>>>>>End_Class
68185>>>Use cApplication.pkg
68185>>>
68185>>>Struct tSkinInformation
68185>>>    String sName     // description of the skin
68185>>>    String sSkinfile // file path. Can be relative or full
68185>>>    String sSkinIni  // section name
68185>>>End_Struct
68185>>>
68185>>>
68185>>>Class cCJSkinFramework is a cCJComSkinFramework
68186>>>    
68186>>>    Procedure Construct_Object
68188>>>        Forward Send Construct_Object
68190>>>        
68190>>>        Property String psSkinFile ""
68191>>>        Property String psSkinIni ""
68192>>>        Property Boolean pbLoadPreference False
68193>>>        
68193>>>        Set peAutoCreate to acAutoCreate
68194>>>        
68194>>>        Move Self to ghoSkinFramework
68195>>>    End_Procedure
68196>>>    
68196>>>    // return the default skin path, which is the programs directory.
68196>>>    // This requires an application object.
68196>>>    // If you want to different skin path, override this.
68196>>>    Function SkinPath Returns String
68198>>>        String sPath sPaths
68198>>>        Handle hoWorkspace
68198>>>        If ghoApplication Begin
68200>>>            Get phoWorkspace of ghoApplication to hoWorkspace
68201>>>            Get psProgramPath of hoWorkspace to sPaths
68202>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
68203>>>        End
68203>>>>
68203>>>        Else Begin
68204>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68205>>>>
68205>>>        End
68205>>>>
68205>>>        Function_Return sPath
68206>>>    End_Function
68207>>>    
68207>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
68207>>>    // returns itself. If it is not, it uses SkinPath to get the path.
68207>>>    Function SkinQFile Returns String
68209>>>        String sFile sPath sSep
68209>>>        Boolean bQualified
68209>>>        Get psSkinFile to sFile
68210>>>        If not (IsFileNameQualified(sFile)) Begin
68212>>>            Get SkinPath to sPath
68213>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68214>>>            Move (sPath - sSep - sFile) to sFile
68215>>>        End
68215>>>>
68215>>>        Function_Return sFile
68216>>>    End_Function
68217>>>    
68217>>>    // defines the default VDF window class mapping.
68217>>>    Procedure OnAddVDFWindowClasses
68219>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
68220>>>        Send ComAddWindowClass "DFentry"                 "Edit"
68221>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
68222>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
68223>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
68224>>>        Send ComAddWindowClass "DFformlist"              "Edit"
68225>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
68226>>>        Send ComAddWindowClass "DFbutton"                "Button"
68227>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
68228>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
68229>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
68230>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
68231>>>        Send ComAddWindowClass "DFedit"                  "edit"
68232>>>        Send ComAddWindowClass "DFlistedit"              "edit"
68233>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
68234>>>        Send ComAddWindowClass "DFgroup"                 "Button"
68235>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
68236>>>        // External class
68236>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
68237>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
68238>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
68239>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
68240>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
68241>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
68242>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
68243>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
68244>>>    End_Procedure
68245>>>    
68245>>>    // Used to support developer designed class mappings (e.g. COM controls)
68245>>>    Procedure OnAddCustomWindowClasses
68247>>>    End_Procedure
68248>>>    
68248>>>    // called when object is created during end_construct_object.
68248>>>    Procedure OnCreate
68250>>>        Integer iOpts
68250>>>        Boolean bUseWindowsFont
68250>>>        Forward Send OnCreate
68252>>>        
68252>>>        // if we are using the windows fonts we will disable the apply metrics which
68252>>>        // never really looked good anyway. This test only exists or legacy purposes
68252>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
68253>>>        If bUseWindowsFont Begin
68255>>>            Get ComApplyOptions to iOpts
68256>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
68257>>>        End
68257>>>>
68257>>>        
68257>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
68257>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
68257>>>        // and this was the suggested workaround.
68257>>>        Set ComAutoApplyNewThreads to False
68258>>>        
68258>>>        Send OnAddVDFWindowClasses
68259>>>        Send OnAddCustomWindowClasses
68260>>>        
68260>>>        // if preferences are used, it will set psSkinFile and psSkinIni
68260>>>        If (pbLoadPreference(Self)) Begin
68262>>>            Send LoadSkinPreference
68263>>>        End
68263>>>>
68263>>>        // if a skin file name exists, we apply the skin.
68263>>>        If (psSkinFile(Self)<>"") Begin
68265>>>            Send ApplySkin
68266>>>        End
68266>>>>
68266>>>    End_Procedure
68267>>>    
68267>>>    // called by framework as part of application exit.
68267>>>    Procedure Broadcast_Notify_Exit_Application
68269>>>        Send Notify_Exit_Application
68270>>>    End_Procedure
68271>>>    
68271>>>    Procedure Notify_Exit_Application
68273>>>        If (pbLoadPreference(Self)) Begin
68275>>>            Send SaveSkinPreference
68276>>>        End
68276>>>>
68276>>>    End_Procedure
68277>>>    
68277>>>    Procedure NotifyPreApplySkin
68279>>>        Broadcast Send OnPreApplySkin of Desktop True
68281>>>    End_Procedure
68282>>>    
68282>>>    Procedure NotifyPostApplySkin
68284>>>        Broadcast Send OnPostApplySkin of Desktop True
68286>>>    End_Procedure
68287>>>    
68287>>>    // returns an array of all skins in the path. If path is "", use the default path.
68287>>>    // If the default path is used, returns the file names as relative names, else use full path.
68287>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
68289>>>        tSkinInformation[] Skins
68289>>>        tSkinInformation[] Skins
68290>>>        String sSkinName sSkinFile sDefaultPath sSep
68290>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
68290>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
68290>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
68290>>>        Integer iPos iDfltLen
68290>>>        Boolean bUseRelativePath
68290>>>        
68290>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68291>>>        
68291>>>        Get SkinPath to sDefaultPath
68292>>>        If (sPath="") Begin
68294>>>            Move sDefaultPath to sPath
68295>>>        End
68295>>>>
68295>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
68296>>>        Move (Length(sDefaultPath)) to iDfltLen
68297>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
68298>>>        
68298>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
68299>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
68301>>>            
68301>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
68302>>>            Get Create U_cCJSkinDescription to hSkinDescription
68303>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
68304>>>            
68304>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
68305>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
68306>>>            
68306>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
68312>>>>
68312>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
68313>>>                Set pvComObject of hSkinDescription to vSkinDescription
68314>>>                
68314>>>                Get ComCount of hSkinDescription to iNumSkins
68315>>>                
68315>>>                For iSkinsCount from 0 to (iNumSkins-1)
68321>>>>
68321>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
68322>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
68323>>>                    
68323>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
68324>>>                    Get ComPath of hSkinDescription to sSkinFile
68325>>>                    If bUseRelativePath Begin
68327>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
68328>>>                        If iPos Begin
68330>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
68331>>>                            While (Left(sSkinFile,1)=sSep)
68335>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
68336>>>                            Loop
68337>>>>
68337>>>                        End
68337>>>>
68337>>>                    End
68337>>>>
68337>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
68338>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
68339>>>                    
68339>>>                    Increment iArrayItem
68340>>>                Loop
68341>>>>
68341>>>            Loop
68342>>>>
68342>>>            
68342>>>            Send Destroy of hSkinDescriptions
68343>>>            Send Destroy of hSkinDescription
68344>>>            Send Destroy of hSkinIniFile
68345>>>            
68345>>>        End
68345>>>>
68345>>>        Function_Return Skins
68346>>>    End_Function
68347>>>    
68347>>>    // Save the skin preference. This requires an application object.
68347>>>    // Only do this if the application object allows it.
68347>>>    // This is called during startup if pbLoadPreference is True
68347>>>    // Suitable for override
68347>>>    Procedure SaveSkinPreference
68349>>>        String sSkin sIni
68349>>>        If ghoApplication Begin
68351>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
68353>>>                Get psSkinFile to sSkin
68354>>>                Get psSkinIni to sIni
68355>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
68356>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
68357>>>            End
68357>>>>
68357>>>        End
68357>>>>
68357>>>        Else Begin
68358>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68359>>>>
68359>>>        End
68359>>>>
68359>>>    End_Procedure
68360>>>    
68360>>>    // Load the skin preference. This requires an application object.
68360>>>    // Only do this if the application object allows it.
68360>>>    // This is called during startup if pbLoadPreference is True
68360>>>    // Suitable for override
68360>>>    Procedure LoadSkinPreference
68362>>>        String sSkin sIni
68362>>>        Boolean bExists
68362>>>        If ghoApplication Begin
68364>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
68366>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
68367>>>                If bExists Begin
68369>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
68370>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
68371>>>                    Set psSkinFile to sSkin
68372>>>                    Set psSkinIni to sIni
68373>>>                End
68373>>>>
68373>>>            End
68373>>>>
68373>>>        End
68373>>>>
68373>>>        Else Begin
68374>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68375>>>>
68375>>>        End
68375>>>>
68375>>>    End_Procedure
68376>>>    
68376>>>    // Can be called to apply the current skin.
68376>>>    Procedure ApplySkin
68378>>>        Boolean bOk
68378>>>        String sSkin sIni
68378>>>        If (IsComObjectCreated(Self)) Begin
68380>>>            Get SkinQFile to sSkin
68381>>>            Get psSkinIni to sIni
68382>>>            
68382>>>            Send NotifyPreApplySkin
68383>>>            // when skins are used we don't want to use built in Visual Styles
68383>>>            Send EnableVisualStyles of Desktop (sSkin="")
68384>>>            Get ComLoadSkin sSkin sIni to bOK
68385>>>            If (sSkin<>"" and not(bOk)) Begin
68387>>>                // if not ok, no skin was appied. Enable visual styles
68387>>>                Send EnableVisualStyles of Desktop True
68388>>>            End
68388>>>>
68388>>>            Send NotifyPostApplySkin
68389>>>        End
68389>>>>
68389>>>    End_Procedure
68390>>>    
68390>>>    
68390>>>End_Class
68391>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
68391>>>//****************************************************************************
68391>>>// $Module type: Class
68391>>>// $Module name: cDbUpdateHandler
68391>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
68391>>>// Web-site    : http://www.rdctools.com
68391>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
68391>>>//
68391>>>// Purpose     : A framework for doing automated code based updates of a database from within
68391>>>//               a program, when it is started.
68391>>>//
68391>>>// Description : Place _one_ object of this class right after the cApplication object.
68391>>>//               Then inside this object place a series of cDbUpdateVersion objects
68391>>>//               as childs. One child object for each new database update.
68391>>>//
68391>>>//               - OnPreUpdate is a pre-processing event called
68391>>>//               before any database changes are started.
68391>>>//               - OnPostUpdate is a post-processing event called after all
68391>>>//               database changes have taken place.
68391>>>//
68391>>>// Note        : If tables have been opened prior to an object of this class
68391>>>//               (e.g. in the cApplication object), those tables will be closed.
68391>>>//               In that case you need to use the OnPostUpdate hook event to re-open
68391>>>//               tables after the last update has finished.
68391>>>//
68391>>>// Security    : Before an update is attempted; three things are checked to ensure the
68391>>>//               database is not in use. Aka nobody else is running the application.
68391>>>//               - All tables are tested for "Open in Exclusive_Mode"
68391>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
68391>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
68391>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
68391>>>//                 folder and a bit-lock is performed for each start of the application and this
68391>>>//                 user counter is checked before an update is attempted.
68391>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
68391>>>//                            against the database being "in use", there is no such guarantee! The
68391>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
68391>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
68391>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
68391>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
68391>>>//                 automatically be released after the update is completed.
68391>>>//
68391>>>//
68391>>>// Usage       :  Use cDbUpdateHandler.pkg
68391>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
68391>>>//                    // Declare the table that contains a "database version" field.
68391>>>//                    Declare_Datafile Sys
68391>>>//                    // Either one of these syntaxes is fine:
68391>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
68391>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
68391>>>//
68391>>>//                    // Don't forget to increase the pnVersionNumber property for each
68391>>>//                    // cDbUpdateVersion object!
68391>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
68391>>>//                    // with the value of pnVersionNumber after each update has been finished.
68391>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
68391>>>//                        Set pnVersionNumber to 1.1
68391>>>//                        Use VersionUpdate1_1.pkg
68391>>>//                    End_Object
68391>>>//
68391>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
68391>>>//                        Set pnVersionNumber to 1.2
68391>>>//                        Use VersionUpdate1_2.pkg
68391>>>//                    End_Object
68391>>>//
68391>>>//                End_Object
68391>>>//
68391>>>//
68391>>>// $Rev History:
68391>>>//    2016-09-27  Module header created
68391>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
68391>>>//                take place before any tables have been opened, or errors
68391>>>//                could occur if the client database is out of sync with the
68391>>>//                compiled program.
68391>>>//                Added user counting checks + lockout while database is being
68391>>>//                updated.
68391>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
68391>>>//                as it is more in line with the child class cDbUpdateVersion name.
68391>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
68391>>>//****************************************************************************
68391>>>Use VdfBase.pkg
68391>>>Use Dferror.pkg
68391>>>Use seq_chnl.pkg
68391>>>Use Datadict.pkg
68391>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
68391>>>>>// *** The Database Update Framework Include file for Languages ***
68391>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
68391>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
68391>>>>>//
68391>>>>>Use LanguageText.Pkg
68391>>>>>
68391>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
68391>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
68391>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
68391>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
68391>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
68391>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
68391>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
68391>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
68391>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
68391>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
68391>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
68391>>>>>    Define CS_DUF_CopyingData               for "Copying data"
68391>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
68391>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
68391>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
68391>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
68391>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
68391>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
68391>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
68391>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
68391>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
68391>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
68391>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
68391>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
68391>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
68391>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
68391>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
68391>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
68391>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
68391>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
68391>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
68391>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
68391>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
68391>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
68391>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
68391>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
68391>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>>>
68391>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
68391>>>>>// StatPnl.pkg - creates the standard status_panel object.
68391>>>>>//
68391>>>>>//
68391>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
68391>>>>>// invoke the standard status panel. The standard has always been that the package name
68391>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
68391>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
68391>>>>>// prior revisions has been replace with status panel that is part of the application.
68391>>>>>// This should work much better and faster than the old sentinel based solution.
68391>>>>>// While the way this operates has changed, the interface has not and therefore this should work
68391>>>>>// with most applications.
68391>>>>>//
68391>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
68391>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
68391>>>>>// a cleaner more robust interface.
68391>>>>>//
68391>>>>>//
68391>>>>>// Compatibility Note:
68391>>>>>//
68391>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
68391>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
68391>>>>>//
68391>>>>>// If for some reason you application will not work using this as a replacement for the old status
68391>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
68391>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
68391>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
68391>>>>>//
68391>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
68391>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
68391>>>>>//
68391>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
68391>>>>>// can still access the new object via the ghoStatusPanel handle.
68391>>>>>//
68391>>>>>//
68391>>>>>// Creating your own Status Panel objects
68391>>>>>//
68391>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
68391>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
68391>>>>>// with a different file and object name and direct your status panel request to the new object.
68391>>>>>//
68391>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
68391>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
68391>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
68391>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
68391>>>>>// e.g.
68391>>>>>//       Procedure UpdateStatusBar
68391>>>>>//           Send DoAdvance of oProgressBar
68391>>>>>//           Send ProcessEvents
68391>>>>>//       End_Procedure
68391>>>>>//
68391>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
68391>>>>>// messages this will be done for you.
68391>>>>>//
68391>>>>>// the standard Interface for status panels are:
68391>>>>>//
68391>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
68391>>>>>// Send Start_StatusPanel      - start the status panel
68391>>>>>// Send Stop_StatusPanel       - stop the status panel
68391>>>>>// Send Update_StatusPanel     - update the status panel's action area
68391>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
68391>>>>>//
68391>>>>>// Get/Set Caption_Text - updates the caption bar
68391>>>>>// Get/Set Title_Text   - updates the title area
68391>>>>>// Get/Set Message_Text - updates the Message area
68391>>>>>// Get/Set Action_Text  - updates the action area
68391>>>>>// Get/Set Button_Text  - updates the button area
68391>>>>>//
68391>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
68391>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
68391>>>>>//
68391>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
68391>>>>>Use cProcessStatusPanel.pkg
68391>>>>>Use cCJSkinFramework.pkg
68391>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProgressBar.pkg)
68391>>>>>>>Use Windows.pkg
68391>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWinControl.pkg)
68391>>>>>>>>>Use Windows.pkg
68391>>>>>>>>>
68391>>>>>>>>>// Key State Masks for Mouse Messages
68391>>>>>>>>>
68391>>>>>>>>>Define MK_LBUTTON  for |CI$0001
68391>>>>>>>>>Define MK_RBUTTON  for |CI$0002
68391>>>>>>>>>Define MK_SHIFT    for |CI$0004
68391>>>>>>>>>Define MK_CONTROL  for |CI$0008
68391>>>>>>>>>Define MK_MBUTTON  for |CI$0010
68391>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
68391>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
68391>>>>>>>>>
68391>>>>>>>>>Enum_List // Mouse Key Flags
68391>>>>>>>>>    Define mkLeft    for MK_LBUTTON
68391>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
68391>>>>>>>>>    Define mkRight   for MK_RBUTTON
68391>>>>>>>>>    Define mkX1      for MK_XBUTTON1
68391>>>>>>>>>    Define mkX2      for MK_XBUTTON2
68391>>>>>>>>>    Define mkShift   for MK_SHIFT
68391>>>>>>>>>    Define mkControl for MK_CONTROL
68391>>>>>>>>>End_Enum_List
68391>>>>>>>>>
68391>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
68391>>>>>>>>>    Define mbLeft
68391>>>>>>>>>    Define mbMiddle
68391>>>>>>>>>    Define mbRight
68391>>>>>>>>>    Define mbX1
68391>>>>>>>>>    Define mbX2
68391>>>>>>>>>End_Enum_List
68391>>>>>>>>>
68391>>>>>>>>>Class cWinControl is a DfBaseControl
68392>>>>>>>>>    Procedure Construct_Object
68394>>>>>>>>>        Forward Send Construct_Object
68396>>>>>>>>>        Property Integer private_pbEnabled True
68397>>>>>>>>>        Property Integer private_pbVisible True
68398>>>>>>>>>    End_Procedure
68399>>>>>>>>>    
68399>>>>>>>>>    Procedure End_Construct_Object
68401>>>>>>>>>        Forward Send End_Construct_Object
68403>>>>>>>>>        
68403>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
68404>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
68405>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
68406>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
68407>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
68408>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
68409>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
68410>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
68411>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
68412>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
68413>>>>>>>>>    End_Procedure
68414>>>>>>>>>    
68414>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
68416>>>>>>>>>        //Intentionally cancelled
68416>>>>>>>>>    End_Procedure
68417>>>>>>>>>    
68417>>>>>>>>>    Procedure Command Integer wParam Integer lParam
68419>>>>>>>>>        //Intentionally cancelled
68419>>>>>>>>>    End_Procedure
68420>>>>>>>>>    
68420>>>>>>>>>    Procedure DoRecreateWindow
68422>>>>>>>>>        // Recreates the window
68422>>>>>>>>>        If (Window_Handle(Self)) Begin
68424>>>>>>>>>            // attempt to do this without disturbing the focus tree.
68424>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
68425>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
68426>>>>>>>>>        End
68426>>>>>>>>>>
68426>>>>>>>>>    End_Procedure
68427>>>>>>>>>    
68427>>>>>>>>>    Procedure DoUpdateWindow
68429>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
68429>>>>>>>>>        Handle hWnd
68429>>>>>>>>>        
68429>>>>>>>>>        Get Window_Handle to hWnd
68430>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
68433>>>>>>>>>    End_Procedure
68434>>>>>>>>>    
68434>>>>>>>>>    Procedure Page Integer iState
68436>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
68437>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
68438>>>>>>>>>        Forward Send Page iState
68440>>>>>>>>>    End_Procedure
68441>>>>>>>>>    
68441>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
68443>>>>>>>>>        Integer x y eButton
68443>>>>>>>>>        
68443>>>>>>>>>        Move (Hi(lParam))  to y
68444>>>>>>>>>        Move (Low(lParam)) to x
68445>>>>>>>>>        
68445>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
68446>>>>>>>>>    End_Procedure
68447>>>>>>>>>    
68447>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
68449>>>>>>>>>        Integer x y eButton
68449>>>>>>>>>        
68449>>>>>>>>>        Move (Hi(lParam))  to y
68450>>>>>>>>>        Move (Low(lParam)) to x
68451>>>>>>>>>        
68451>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
68452>>>>>>>>>    End_Procedure
68453>>>>>>>>>    
68453>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
68455>>>>>>>>>        Integer x y eButton
68455>>>>>>>>>        
68455>>>>>>>>>        Move (Hi(lParam))  to y
68456>>>>>>>>>        Move (Low(lParam)) to x
68457>>>>>>>>>        
68457>>>>>>>>>        Send OnMouseUp mbRight x y wParam
68458>>>>>>>>>    End_Procedure
68459>>>>>>>>>    
68459>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
68461>>>>>>>>>        Integer x y eButton fKeys
68461>>>>>>>>>        
68461>>>>>>>>>        Move (Hi(lParam))  to y
68462>>>>>>>>>        Move (Low(lParam)) to x
68463>>>>>>>>>        
68463>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
68464>>>>>>>>>    End_Procedure
68465>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
68467>>>>>>>>>        Integer x y eButton
68467>>>>>>>>>        
68467>>>>>>>>>        Move (Hi(lParam))  to y
68468>>>>>>>>>        Move (Low(lParam)) to x
68469>>>>>>>>>        
68469>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
68470>>>>>>>>>    End_Procedure
68471>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
68473>>>>>>>>>        Integer x y eButton
68473>>>>>>>>>        
68473>>>>>>>>>        Move (Hi(lParam))  to y
68474>>>>>>>>>        Move (Low(lParam)) to x
68475>>>>>>>>>        
68475>>>>>>>>>        Send OnMouseDown mbRight x y wParam
68476>>>>>>>>>    End_Procedure
68477>>>>>>>>>    
68477>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
68479>>>>>>>>>        Integer x y eButton
68479>>>>>>>>>        
68479>>>>>>>>>        Move (Hi(lParam))  to y
68480>>>>>>>>>        Move (Low(lParam)) to x
68481>>>>>>>>>        
68481>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
68482>>>>>>>>>    End_Procedure
68483>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
68485>>>>>>>>>        Integer x y eButton
68485>>>>>>>>>        
68485>>>>>>>>>        Move (Hi(lParam))  to y
68486>>>>>>>>>        Move (Low(lParam)) to x
68487>>>>>>>>>        
68487>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
68488>>>>>>>>>    End_Procedure
68489>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
68491>>>>>>>>>        Integer x y eButton
68491>>>>>>>>>        
68491>>>>>>>>>        Move (Hi(lParam))  to y
68492>>>>>>>>>        Move (Low(lParam)) to x
68493>>>>>>>>>        
68493>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
68494>>>>>>>>>    End_Procedure
68495>>>>>>>>>    
68495>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
68497>>>>>>>>>        Integer x y eButton
68497>>>>>>>>>        
68497>>>>>>>>>        Move (Hi(lParam))  to y
68498>>>>>>>>>        Move (Low(lParam)) to x
68499>>>>>>>>>        
68499>>>>>>>>>        Send OnMouseMove x y wParam
68500>>>>>>>>>    End_Procedure
68501>>>>>>>>>    
68501>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
68503>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68503>>>>>>>>>        //String sButton
68503>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68503>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68503>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68503>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68503>>>>>>>>>        
68503>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68503>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68503>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68503>>>>>>>>>    End_Procedure
68504>>>>>>>>>    
68504>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
68506>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68506>>>>>>>>>        //String sButton
68506>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68506>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68506>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68506>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68506>>>>>>>>>        
68506>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68506>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68506>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68506>>>>>>>>>    End_Procedure
68507>>>>>>>>>    
68507>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
68509>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68509>>>>>>>>>        //String sButton
68509>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68509>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68509>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68509>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68509>>>>>>>>>        
68509>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68509>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68509>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68509>>>>>>>>>    End_Procedure
68510>>>>>>>>>    
68510>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
68512>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68512>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68512>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68512>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68512>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68512>>>>>>>>>        
68512>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68512>>>>>>>>>    End_Procedure
68513>>>>>>>>>    
68513>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
68515>>>>>>>>>        Handle hWnd
68515>>>>>>>>>        
68515>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
68517>>>>>>>>>            Set private_pbEnabled to bEnabled
68518>>>>>>>>>            Get Window_Handle to hWnd
68519>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
68522>>>>>>>>>        End
68522>>>>>>>>>>
68522>>>>>>>>>    End_Procedure
68523>>>>>>>>>    Function pbEnabled Returns Boolean
68525>>>>>>>>>        Function_Return (private_pbEnabled(Self))
68526>>>>>>>>>    End_Function
68527>>>>>>>>>    
68527>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
68529>>>>>>>>>        Handle  hWnd
68529>>>>>>>>>        Integer iVoid
68529>>>>>>>>>        
68529>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
68531>>>>>>>>>            Set private_pbVisible to bVisible
68532>>>>>>>>>            Get Window_Handle to hWnd
68533>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
68536>>>>>>>>>        End
68536>>>>>>>>>>
68536>>>>>>>>>    End_Procedure
68537>>>>>>>>>    Function pbVisible Returns Boolean
68539>>>>>>>>>        Function_Return (private_pbVisible(Self))
68540>>>>>>>>>    End_Function
68541>>>>>>>>>    
68541>>>>>>>>>End_Class
68542>>>>>>>Use CommCtrl.pkg
68542>>>>>>>
68542>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
68542>>>>>>>Class cProgressBar is a cWinControl
68543>>>>>>>    
68543>>>>>>>    Procedure Construct_Object
68545>>>>>>>        Forward Send Construct_Object
68547>>>>>>>        Property Integer private_piMinimum
68548>>>>>>>        Property Integer private_piMaximum   100
68549>>>>>>>        Property Integer private_piAdvanceBy 10
68550>>>>>>>        Property Integer private_piPosition
68551>>>>>>>        Property Integer private_pbVertical  False
68552>>>>>>>        Property Integer private_pbSmooth    False
68553>>>>>>>        Property Integer private_piBackColor clDefault
68554>>>>>>>        Property Integer private_piBarColor  clDefault
68555>>>>>>>        
68555>>>>>>>        Send Define_ToolTip_Support_Mixin
68556>>>>>>>        
68556>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
68557>>>>>>>        Set Focus_Mode to NonFocusable
68558>>>>>>>        Set Skip_State to True
68559>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
68560>>>>>>>    End_Procedure
68561>>>>>>>    
68561>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
68562>>>>>>>    
68562>>>>>>>    Procedure Set piMinimum Integer iMin
68564>>>>>>>        Integer iMax
68564>>>>>>>        
68564>>>>>>>        Set private_piMinimum to iMin
68565>>>>>>>        Get private_piMaximum to iMax
68566>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
68567>>>>>>>    End_Procedure
68568>>>>>>>    Function piMinimum Returns Integer
68570>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
68573>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
68575>>>>>>>    End_Function
68576>>>>>>>    
68576>>>>>>>    Procedure Set piMaximum Integer iMax
68578>>>>>>>        Integer iMin
68578>>>>>>>        
68578>>>>>>>        Set private_piMaximum to iMax
68579>>>>>>>        Get private_piMinimum to iMin
68580>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
68581>>>>>>>    End_Procedure
68582>>>>>>>    Function piMaximum Returns Integer
68584>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
68587>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
68589>>>>>>>    End_Function
68590>>>>>>>    
68590>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
68592>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
68593>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
68594>>>>>>>    End_Procedure
68595>>>>>>>    Function piAdvanceBy Returns Integer
68597>>>>>>>        Function_Return (private_piAdvanceBy(Self))
68598>>>>>>>    End_Function
68599>>>>>>>    
68599>>>>>>>    Procedure Set piPosition Integer iPos
68601>>>>>>>        Set private_piPosition to iPos
68602>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
68603>>>>>>>    End_Procedure
68604>>>>>>>    
68604>>>>>>>    Function piPosition Returns Integer
68606>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
68609>>>>>>>        Else;            Function_Return (private_piPosition(Self))
68611>>>>>>>    End_Function
68612>>>>>>>    
68612>>>>>>>    Procedure Set pbVertical Boolean bVertical
68614>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
68616>>>>>>>            Set private_pbVertical to bVertical
68617>>>>>>>            Send DoRecreateWindow
68618>>>>>>>        End
68618>>>>>>>>
68618>>>>>>>    End_Procedure
68619>>>>>>>    
68619>>>>>>>    Function pbVertical Returns Boolean
68621>>>>>>>        Function_Return (private_pbVertical(Self))
68622>>>>>>>    End_Function
68623>>>>>>>    
68623>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
68625>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
68627>>>>>>>            Set private_pbSmooth to bSmooth
68628>>>>>>>            Send DoRecreateWindow
68629>>>>>>>        End
68629>>>>>>>>
68629>>>>>>>    End_Procedure
68630>>>>>>>    Function pbSmooth Returns Boolean
68632>>>>>>>        Function_Return (private_pbSmooth(Self))
68633>>>>>>>    End_Function
68634>>>>>>>    
68634>>>>>>>    Procedure Set piBackColor Integer rgbColor
68636>>>>>>>        Set private_piBackColor to rgbColor
68637>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
68638>>>>>>>    End_Procedure
68639>>>>>>>    Function piBackColor Returns Integer
68641>>>>>>>        Function_Return (private_piBackColor(Self))
68642>>>>>>>    End_Function
68643>>>>>>>    
68643>>>>>>>    Procedure Set piBarColor Integer rgbColor
68645>>>>>>>        Set private_piBarColor to rgbColor
68646>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
68647>>>>>>>    End_Procedure
68648>>>>>>>    Function piBarColor Returns Integer
68650>>>>>>>        Function_Return (private_piBarColor(Self))
68651>>>>>>>    End_Function
68652>>>>>>>    
68652>>>>>>>    Procedure DoAdvance
68654>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
68655>>>>>>>    End_Procedure
68656>>>>>>>    
68656>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
68658>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
68659>>>>>>>    End_Procedure
68660>>>>>>>    
68660>>>>>>>    Procedure private_DoInitWindow
68662>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
68663>>>>>>>        Set piBackColor to (private_piBackColor(Self))
68664>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
68665>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
68666>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
68667>>>>>>>        Set piPosition  to (private_piPosition(Self))
68668>>>>>>>    End_Procedure
68669>>>>>>>    
68669>>>>>>>    Procedure Page_Object Integer iState
68671>>>>>>>        Handle hWnd
68671>>>>>>>        
68671>>>>>>>        Get Window_Handle to hWnd
68672>>>>>>>        If (hWnd=0 and iState) Begin
68674>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
68675>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
68676>>>>>>>            Forward Send Page_Object True
68678>>>>>>>        End
68678>>>>>>>>
68678>>>>>>>        Else ;            Forward Send Page_Object iState
68681>>>>>>>        
68681>>>>>>>        // Handle tooltip support....
68681>>>>>>>        If (iState = 0) Begin
68683>>>>>>>            Send RequestDeleteToolTip
68684>>>>>>>        End
68684>>>>>>>>
68684>>>>>>>        Else Begin
68685>>>>>>>            Send RequestAddToolTip
68686>>>>>>>        End
68686>>>>>>>>
68686>>>>>>>    End_Procedure
68687>>>>>>>    
68687>>>>>>>    Procedure Page Integer iState
68689>>>>>>>        Forward Send Page iState
68691>>>>>>>        If (iState =1);            Send private_DoInitWindow
68694>>>>>>>    End_Procedure
68695>>>>>>>    
68695>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
68695>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
68695>>>>>>>    // is implemented in a mixin class.
68695>>>>>>>    Procedure RequestAddToolTip
68697>>>>>>>        Send AddToolTip
68698>>>>>>>    End_Procedure
68699>>>>>>>    
68699>>>>>>>    
68699>>>>>>>    // Called by Page_Object. Handles tooltip removal.
68699>>>>>>>    Procedure RequestDeleteToolTip
68701>>>>>>>        Send DeleteToolTip
68702>>>>>>>    End_Procedure
68703>>>>>>>End_Class
68704>>>>>Use Windows.pkg
68704>>>>>Use DUFLanguageConstants.inc
68704>>>>>Use Statpnl.pkg
68704>>>>>
68704>>>>>
68704>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
68704>>>>>
68704>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
68704>>>>>
68704>>>>>Object Status_Panel is a cProcessStatusPanel
68706>>>>>    Set Size to 152 222
68707>>>>>    Set Border_Style to Border_Dialog
68708>>>>>    Set Icon to "Default.ico"
68709>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
68710>>>>>
68710>>>>>    Property Boolean Cancel_Button_Visible_State True
68712>>>>>
68712>>>>>    Procedure Activate
68715>>>>>        Integer iSizeBefore
68715>>>>>        Get GuiSize to iSizeBefore
68716>>>>>        Forward Send Activate
68718>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
68719>>>>>    End_Procedure
68720>>>>>
68720>>>>>    Procedure End_Construct_Object
68723>>>>>        Forward Send End_Construct_Object
68725>>>>>        Set Label of oTitleTxt      to ""
68726>>>>>        Set Label of oTableNameTxt  to ""
68727>>>>>        Set Label of oMessageTxt    to ""
68728>>>>>        Set Label of oActionTxt     to ""
68729>>>>>    End_Procedure
68730>>>>>
68730>>>>>    Object oTitleTxt is a TextBox
68732>>>>>        Set Location to 5 21
68733>>>>>        Set Size to 8 179
68734>>>>>        Set Auto_Size_State to False
68735>>>>>        Set Justification_Mode  to jMode_Center
68736>>>>>        Set Label to "This is the Title Text"
68737>>>>>    End_Object
68738>>>>>
68738>>>>>    Object oTableNameTxt is a TextBox
68740>>>>>        Set Size to 19 204
68741>>>>>        Set Location to 18 9
68742>>>>>        Set Auto_Size_State to False
68743>>>>>        Set Justification_Mode to JMode_Left
68744>>>>>        Set Label to "This is the TableName Text"
68745>>>>>    End_Object
68746>>>>>
68746>>>>>    Object oMessageTxt is a TextBox
68748>>>>>        Set Location to 39 9
68749>>>>>        Set Size to 19 204
68750>>>>>        Set Auto_Size_State to False
68751>>>>>        Set Justification_Mode to JMode_Left
68752>>>>>        Set Label to "This is the Message text"
68753>>>>>    End_Object
68754>>>>>
68754>>>>>    Object oActionTxt is a TextBox
68756>>>>>        Set Size to 16 204
68757>>>>>        Set Location to 60 9
68758>>>>>        Set Auto_Size_State to False
68759>>>>>        Set Justification_Mode to JMode_Left
68760>>>>>        Set Label to "This is the Action Text"
68761>>>>>    End_Object
68762>>>>>
68762>>>>>    Object oStopButton is a Button
68764>>>>>        Set Location to 123 82
68765>>>>>        Set Label to C_$Cancel
68766>>>>>
68766>>>>>        Procedure OnClick 
68769>>>>>            Integer iRetval
68769>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
68770>>>>>            If (iRetval = MBR_Yes) Begin
68772>>>>>                Send Exit_Application
68773>>>>>            End
68773>>>>>>
68773>>>>>        End_Procedure
68774>>>>>
68774>>>>>    End_Object
68775>>>>>
68775>>>>>    Object oPercentage_tb is a TextBox
68777>>>>>        Set Location to 74 196
68778>>>>>        Set Size to 10 25
68779>>>>>//        Set Label to "% Done"
68779>>>>>    End_Object
68780>>>>>
68780>>>>>    Object oCopyRight is a TextBox
68782>>>>>        Set Location to 140 21
68783>>>>>        Set Size to 9 197
68784>>>>>        Set FontPointHeight to 8
68785>>>>>        Set Auto_Size_State to False
68786>>>>>        Set Justification_Mode  to jMode_Center
68787>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
68788>>>>>    End_Object
68789>>>>>
68789>>>>>    Object oProgressBar is a cProgressBar
68791>>>>>        Set Size to 10 179
68792>>>>>        Set Location to 83 22
68793>>>>>        Set pbVisible to True // default
68794>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
68795>>>>>    End_Object
68796>>>>>
68796>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
68799>>>>>        Set pbVisible of ghoProgressBar to bVisible
68800>>>>>    End_Procedure
68801>>>>>
68801>>>>>    Function Progress_Bar_Visible_State Returns Boolean
68804>>>>>        Boolean bVisible
68804>>>>>        Get pbVisible of ghoProgressBar to bVisible
68805>>>>>        Function_Return (bVisible)
68806>>>>>    End_Function
68807>>>>>
68807>>>>>    Object oProgressBarOverall is a cProgressBar
68809>>>>>        Set Size to 10 179
68810>>>>>        Set Location to 107 22
68811>>>>>        Set pbVisible to True // default
68812>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
68813>>>>>    End_Object
68814>>>>>
68814>>>>>    Object oOverallProgress_tb is a TextBox
68816>>>>>        Set Size to 10 65
68817>>>>>        Set Location to 95 24
68818>>>>>        Set Label to "Overall Progress"
68819>>>>>    End_Object
68820>>>>>
68820>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
68823>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
68824>>>>>    End_Procedure
68825>>>>>
68825>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
68828>>>>>        Boolean bVisible
68828>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
68829>>>>>        Function_Return (bVisible)
68830>>>>>    End_Function
68831>>>>>
68831>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
68831>>>>>    // objects defined within this instance of the status panel.
68831>>>>>
68831>>>>>    // note: all of the messages that change text should be forwarded
68831>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
68831>>>>>
68831>>>>>    Procedure Set Message_Text String sText
68834>>>>>        Set Label of oMessageTxt to sText
68835>>>>>        Forward Set Message_Text to sText
68837>>>>>    End_Procedure
68838>>>>>
68838>>>>>    Function Message_Text Returns String
68841>>>>>        Function_Return (Label(oMessageTxt))
68842>>>>>    End_Function
68843>>>>>
68843>>>>>    Procedure Set Action_Text String sText
68846>>>>>        Set Label of oActionTxt to sText
68847>>>>>        Forward Set Action_Text to sText
68849>>>>>    End_Procedure
68850>>>>>
68850>>>>>    Function Action_Text Returns String
68853>>>>>        Function_Return (Label(oActionTxt))
68854>>>>>    End_Function
68855>>>>>
68855>>>>>    Procedure Set Button_Text String sText
68858>>>>>        Set Label of oStopButton to sText
68859>>>>>        Forward Set Button_Text to sText
68861>>>>>    End_Procedure
68862>>>>>
68862>>>>>    Function Button_Text Returns String
68865>>>>>        Function_Return (Label(oStopButton))
68866>>>>>    End_Function
68867>>>>>
68867>>>>>    Procedure Set Title_Text String sText
68870>>>>>        Set Label of oTitleTxt to sText
68871>>>>>        Forward Set Title_Text to sText
68873>>>>>    End_Procedure
68874>>>>>
68874>>>>>    Function Title_Text Returns String
68877>>>>>        Function_Return (Label(oTitleTxt))
68878>>>>>    End_Function
68879>>>>>
68879>>>>>    Procedure Set TableName_Text String sText
68882>>>>>        Set Label of oTableNameTxt to sText
68883>>>>>    End_Procedure
68884>>>>>
68884>>>>>    Function TableName_Text Returns String
68887>>>>>        Function_Return (Label(oTableNameTxt))
68888>>>>>    End_Function
68889>>>>>
68889>>>>>    Procedure Set License_Text String sText
68892>>>>>//        Set Label of oLicense_txt to sText
68892>>>>>    End_Procedure
68893>>>>>
68893>>>>>    // gets called when status panel is activated passing whether a button
68893>>>>>    // should appear
68893>>>>>    Procedure EnableCancelButton Boolean bEnable
68896>>>>>        Boolean bVisible
68896>>>>>        Get Cancel_Button_Visible_State to bVisible
68897>>>>>        If (bEnable = False) Begin
68899>>>>>            Set Visible_State of oStopButton to bVisible
68900>>>>>        End
68900>>>>>>
68900>>>>>        Set Enabled_State of oStopButton to bEnable
68901>>>>>    End_Procedure
68902>>>>>
68902>>>>>    Procedure Reset_StatusPanel
68905>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
68906>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
68907>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
68908>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
68909>>>>>    End_Procedure
68910>>>>>
68910>>>>>//    Object oProgressBar is a cProgressBar
68910>>>>>//        Move Self to ghoProgressBar
68910>>>>>//        Set Location to 1 25
68910>>>>>//        Set Size to 9 173
68910>>>>>//        Set piMinimum        to 0
68910>>>>>//        Set piMaximum        to 2000
68910>>>>>//        Set piAdvanceBy      to 100
68910>>>>>//        Set pbSmooth to True
68910>>>>>//
68910>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
68910>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
68910>>>>>//        // color will show correctly.
68910>>>>>//        Procedure Page Integer iPageObject
68910>>>>>//            Handle hWin
68910>>>>>//            Forward Send Page iPageObject
68910>>>>>//            If (ghoSkinFramework <> 0) Begin
68910>>>>>//                Get Window_Handle to hWin
68910>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
68910>>>>>//            End
68910>>>>>//        End_Procedure
68910>>>>>//    End_Object
68910>>>>>
68910>>>>>End_Object
68911>>>>>
68911>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
68911>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
68911>>>>>//
68911>>>>>Use VdfBase.pkg
68911>>>>>Use cApplication.pkg
68911>>>>>Use seq_chnl.pkg
68911>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
68911>>>>>>>// This code is part of VDF GUIdance
68911>>>>>>>// Visit us @ http://www.vdf-guidance.com
68911>>>>>>>// e-Mail us @ info@vdf-guidance.com
68911>>>>>>>// VDF GUIdance is a mutual project of
68911>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
68911>>>>>>>// Wil van Antwerpen  - Antwise Solutions
68911>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
68911>>>>>>>//
68911>>>>>>>//
68911>>>>>>>// *** Windows 32bit file handling wrapper class ***
68911>>>>>>>//
68911>>>>>>>
68911>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
68911>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
68911>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
68911>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
68911>>>>>>>//
68911>>>>>>>// The used naming-convention is:
68911>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
68911>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
68911>>>>>>>//
68911>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
68911>>>>>>>// of DataAccess in the future.
68911>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
68911>>>>>>>//
68911>>>>>>>// mm-dd-yyyy Author Description
68911>>>>>>>//
68911>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
68911>>>>>>>//                   vGetWindowsDirectory
68911>>>>>>>//
68911>>>>>>>//                   vGetTempFileName
68911>>>>>>>//                   vGetTempPath
68911>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
68911>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
68911>>>>>>>//                   error in your application anyways. Changed this for:
68911>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
68911>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
68911>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
68911>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
68911>>>>>>>//                   It is renamed too avoid this.
68911>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
68911>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
68911>>>>>>>//                   Removed the local keyword in the variable declarations
68911>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
68911>>>>>>>//                   created file-open dialog
68911>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
68911>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
68911>>>>>>>//                   This has now been taken care of.
68911>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
68911>>>>>>>//                   These declarations are now included from the vWin32fh header file.
68911>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
68911>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
68911>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
68911>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
68911>>>>>>>//                   One can however restore to the old way of handling by simply calling the
68911>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
68911>>>>>>>//                   filehandling operations
68911>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
68911>>>>>>>//                   as well as the StringFromRightOfChar function.
68911>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
68911>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
68911>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
68911>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
68911>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
68911>>>>>>>//                   extended characters are treated ok too.
68911>>>>>>>//                   Reported by Flemming from
68911>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
68911>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
68911>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
68911>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
68911>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
68911>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
68911>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
68911>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
68911>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
68911>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
68911>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
68911>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
68911>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
68911>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
68911>>>>>>>
68911>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
68911>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
68911>>>>>>>>>//***************************************************************************
68911>>>>>>>>>//*
68911>>>>>>>>>//* Class:        cvSaveAsDialog
68911>>>>>>>>>//* Package Name: cvFileDialogs.pkg
68911>>>>>>>>>//*
68911>>>>>>>>>//***************************************************************************
68911>>>>>>>>>
68911>>>>>>>>>Use File_dlg.pkg
68911>>>>>>>>>
68911>>>>>>>>>// *WvA: 13-01-1999 Created
68911>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
68911>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
68911>>>>>>>>>// file_name.
68911>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
68912>>>>>>>>>
68912>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
68914>>>>>>>>>        Forward Send Construct_Object iImage_Id
68916>>>>>>>>>        Set HideReadOnly_State to True
68917>>>>>>>>>    End_Procedure
68918>>>>>>>>>
68918>>>>>>>>>    Function SelectedFileName Returns String
68920>>>>>>>>>        String sFileName
68920>>>>>>>>>        Move "" to sFileName
68921>>>>>>>>>        If (Show_Dialog(Self)) Begin
68923>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
68924>>>>>>>>>        End
68924>>>>>>>>>>
68924>>>>>>>>>        Function_Return sFileName
68925>>>>>>>>>    End_Function
68926>>>>>>>>>End_Class
68927>>>>>>>>>
68927>>>>>>>>>// *WvA: 13-01-1999 Created
68927>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
68927>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
68927>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
68927>>>>>>>>>//                   file-open dialog
68927>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
68929>>>>>>>>>    String sSelectedFile
68929>>>>>>>>>    Integer hoOpenFileDialog
68929>>>>>>>>>
68929>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
68931>>>>>>>>>
68931>>>>>>>>>        Set Dialog_Caption    to sCaptionText
68932>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
68933>>>>>>>>>        Set Initial_Folder    to sInitialFolder
68934>>>>>>>>>
68934>>>>>>>>>        Move Self       to hoOpenFileDialog
68935>>>>>>>>>    End_Object
68936>>>>>>>>>
68936>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
68937>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
68938>>>>>>>>>    Function_Return sSelectedFile
68939>>>>>>>>>End_Function
68940>>>>>>>>>
68940>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
68941>>>>>>>>>
68941>>>>>>>>>    Procedure Construct_Object
68943>>>>>>>>>        Forward Send Construct_Object
68945>>>>>>>>>        Set HideReadOnly_State to True
68946>>>>>>>>>    End_Procedure
68947>>>>>>>>>
68947>>>>>>>>>    Function SelectedFileName Returns String
68949>>>>>>>>>        String sFileName
68949>>>>>>>>>        Move "" to sFileName
68950>>>>>>>>>        If (Show_Dialog(Self)) Begin
68952>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
68953>>>>>>>>>        End
68953>>>>>>>>>>
68953>>>>>>>>>        Function_Return sFileName
68954>>>>>>>>>    End_Function
68955>>>>>>>>>
68955>>>>>>>>>End_Class
68956>>>>>>>>>
68956>>>>>>>>>// Added optional default filename as suggested by Nils
68956>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
68958>>>>>>>>>    String sSelectedFile
68958>>>>>>>>>    Integer hoDialog
68958>>>>>>>>>
68958>>>>>>>>>    Move "" to sSelectedFile
68959>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
68960>>>>>>>>>    If (hoDialog) Begin
68962>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
68962>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
68963>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
68964>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
68965>>>>>>>>>        If (Num_Arguments = 4) Begin
68967>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
68968>>>>>>>>>        End
68968>>>>>>>>>>
68968>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
68969>>>>>>>>>        Send Destroy of hoDialog
68970>>>>>>>>>    End
68970>>>>>>>>>>
68970>>>>>>>>>    Function_Return sSelectedFile
68971>>>>>>>>>End_Function
68972>>>>>>>Use Seq_chnl.pkg
68972>>>>>>>
68972>>>>>>>Use windows.pkg
68972>>>>>>>Use Dll.pkg
68972>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
68972>>>>>>>>>//TH-Header
68972>>>>>>>>>//*****************************************************************************************
68972>>>>>>>>>// Copyright (c)  2004 KURANT Project
68972>>>>>>>>>// All rights reserved.
68972>>>>>>>>>//
68972>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
68972>>>>>>>>>// $ProjectName : Windows 32 bits file handling
68972>>>>>>>>>// $Authors     : Wil van Antwerpen
68972>>>>>>>>>// $Created     : 19.02.2004  19:25
68972>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
68972>>>>>>>>>//
68972>>>>>>>>>// Contents:
68972>>>>>>>>>//  This file contains the Windows API external function call definitions and
68972>>>>>>>>>//  constants as they are used in the vWin32fh package.
68972>>>>>>>>>//*****************************************************************************************
68972>>>>>>>>>//TH-RevisionStart
68972>>>>>>>>>//TH-RevisionEnd
68972>>>>>>>>>
68972>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
68972>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
68972>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
68972>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
68972>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
68972>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
68972>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
68972>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
68972>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
68972>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
68972>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
68972>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
68972>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
68972>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
68972>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
68972>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
68972>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
68972>>>>>>>>>
68972>>>>>>>>>
68972>>>>>>>>>Define vMax_Path     For |CI260
68972>>>>>>>>>Define vMinChar      For |CI$80
68972>>>>>>>>>Define vMaxChar      For |CI$7F
68972>>>>>>>>>Define vMinShort     For |CI$8000
68972>>>>>>>>>Define vMaxShort     For |CI$7FFF
68972>>>>>>>>>Define vMinLong      For |CI$80000000
68972>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
68972>>>>>>>>>Define vMaxByte      For |CI$FF
68972>>>>>>>>>Define vMaxWord      For |CI$FFFF
68972>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
68972>>>>>>>>>
68972>>>>>>>>>
68972>>>>>>>>>
68972>>>>>>>>>// For FindFirstFile
68972>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
68972>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
68972>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
68972>>>>>>>>>
68972>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
68972>>>>>>>>>// the API-call ShellExecute is used.
68972>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
68972>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
68972>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
68972>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
68972>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
68972>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
68972>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
68972>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
68972>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
68972>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
68972>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
68972>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
68972>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
68972>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
68972>>>>>>>>>
68972>>>>>>>>>
68972>>>>>>>>>// C-Structure
68972>>>>>>>>>//typedef struct _browseinfo {
68972>>>>>>>>>//    HWND hwndOwner;
68972>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
68972>>>>>>>>>//    LPSTR pszDisplayName;
68972>>>>>>>>>//    LPCSTR lpszTitle;
68972>>>>>>>>>//    UINT ulFlags;
68972>>>>>>>>>//    BFFCALLBACK lpfn;
68972>>>>>>>>>//    LPARAM lParam;
68972>>>>>>>>>//    int iImage;
68972>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
68972>>>>>>>>>
68972>>>>>>>>>//declare C structure struct_browseinfo
68972>>>>>>>>>//as documented in MSDN under Windows Shell API
68972>>>>>>>>>Struct tvBrowseInfo
68972>>>>>>>>>  Handle    hWndOwner
68972>>>>>>>>>  Pointer   pIDLRoot
68972>>>>>>>>>  Pointer   pszDisplayName
68972>>>>>>>>>  Pointer   lpszTitle
68972>>>>>>>>>  dWord     ulFlags
68972>>>>>>>>>  Pointer   lpfnCallback
68972>>>>>>>>>  dWord     lParam
68972>>>>>>>>>  DWord     iImage
68972>>>>>>>>>End_Struct // tvBrowseInfo
68972>>>>>>>>>
68972>>>>>>>>>// Browsing for directory.
68972>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
68972>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
68972>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
68972>>>>>>>>>                                            // The callback function can set the status text by
68972>>>>>>>>>                                            // sending messages to the dialog box.
68972>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
68972>>>>>>>>>
68972>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
68972>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
68972>>>>>>>>>
68972>>>>>>>>>// message from browser
68972>>>>>>>>>//Define BFFM_INITIALIZED        1
68972>>>>>>>>>//Define BFFM_SELCHANGED         2
68972>>>>>>>>>
68972>>>>>>>>>// messages to browser
68972>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
68972>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
68972>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
68972>>>>>>>>>
68972>>>>>>>>>
68972>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
68973>>>>>>>>>
68973>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
68974>>>>>>>>>
68974>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
68975>>>>>>>>>
68975>>>>>>>>>
68975>>>>>>>>>
68975>>>>>>>>>
68975>>>>>>>>>Struct tvSecurity_attributes
68975>>>>>>>>>  DWord   nLength
68975>>>>>>>>>  Pointer lpDescriptor
68975>>>>>>>>>  Integer bInheritHandle
68975>>>>>>>>>End_Struct // tvSecurity_attributes
68975>>>>>>>>>
68975>>>>>>>>>//nLength:
68975>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
68975>>>>>>>>>// SECURITY_ATTRIBUTES structure.
68975>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
68975>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
68975>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
68975>>>>>>>>>//
68975>>>>>>>>>//lpSecurityDescriptor:
68975>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
68975>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
68975>>>>>>>>>// descriptor of the calling process.
68975>>>>>>>>>//
68975>>>>>>>>>//bInheritHandle:
68975>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
68975>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
68975>>>>>>>>>
68975>>>>>>>>>
68975>>>>>>>>>// BOOL CreateDirectory(
68975>>>>>>>>>//    LPCTSTR lpPathName,
68975>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
68975>>>>>>>>>//   );
68975>>>>>>>>>//
68975>>>>>>>>>// lpPathName
68975>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
68975>>>>>>>>>//  to be created.
68975>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
68975>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
68975>>>>>>>>>// lpSecurityAttributes
68975>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
68975>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
68975>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
68975>>>>>>>>>// Returns:
68975>>>>>>>>>//  If the function succeeds, the return value is nonzero.
68975>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
68975>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
68976>>>>>>>>>
68976>>>>>>>>>
68976>>>>>>>>>// lpPathName
68976>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
68976>>>>>>>>>//  to be removed.
68976>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
68976>>>>>>>>>// Returns:
68976>>>>>>>>>//  If the function succeeds, the return value is nonzero.
68976>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
68976>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
68977>>>>>>>>>
68977>>>>>>>>>
68977>>>>>>>>>
68977>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
68977>>>>>>>>>// executable file or a document file.
68977>>>>>>>>>//
68977>>>>>>>>>// Operation can be one of the following:
68977>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
68977>>>>>>>>>//            The file can be an executable file or a document file.
68977>>>>>>>>>//            The file can be a folder to open.
68977>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
68977>>>>>>>>>//            The file should be a document file. If the file is an executable file,
68977>>>>>>>>>//            the function opens the file, as if "open" had been specified.
68977>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
68977>>>>>>>>>//
68977>>>>>>>>>// Return Values:
68977>>>>>>>>>//
68977>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
68977>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
68977>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
68977>>>>>>>>>//
68977>>>>>>>>>// The following table lists these error values:
68977>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
68977>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
68977>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
68977>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
68977>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
68977>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
68977>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
68977>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
68977>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
68977>>>>>>>>>// Public Const SE_ERR_FNF = 2
68977>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
68977>>>>>>>>>// Public Const SE_ERR_OOM = 8
68977>>>>>>>>>// Public Const SE_ERR_PNF = 3
68977>>>>>>>>>// Public Const SE_ERR_SHARE = 26
68977>>>>>>>>>
68977>>>>>>>>>
68977>>>>>>>>>
68977>>>>>>>>>// Code to open the program that is associated with the selected file.
68977>>>>>>>>>//
68977>>>>>>>>>// External function call used in Procedure DoStartDocument
68977>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
68978>>>>>>>>>
68978>>>>>>>>>
68978>>>>>>>>>
68978>>>>>>>>>
68978>>>>>>>>>Define vFO_MOVE                For |CI$0001
68978>>>>>>>>>Define vFO_COPY                For |CI$0002
68978>>>>>>>>>Define vFO_DELETE              For |CI$0003
68978>>>>>>>>>Define vFO_RENAME              For |CI$0004
68978>>>>>>>>>
68978>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
68978>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
68978>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
68978>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
68978>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
68978>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
68978>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
68978>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
68978>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
68978>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
68978>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
68978>>>>>>>>>
68978>>>>>>>>>Struct tvShFileOpStruct
68978>>>>>>>>>  Handle  hWnd
68978>>>>>>>>>  Integer wFunc
68978>>>>>>>>>  Pointer pFrom
68978>>>>>>>>>  Pointer pTo
68978>>>>>>>>>  Short   fFlags
68978>>>>>>>>>  Short   fAnyOperationsAborted
68978>>>>>>>>>  Pointer hNameMappings
68978>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
68978>>>>>>>>>End_Struct // tvShFileOpStruct
68978>>>>>>>>>
68978>>>>>>>>>// hwnd
68978>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
68978>>>>>>>>>
68978>>>>>>>>>// wFunc
68978>>>>>>>>>//   Operation to perform. This member can be one of the following values:
68978>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
68978>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
68978>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
68978>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
68978>>>>>>>>>
68978>>>>>>>>>// pFrom
68978>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
68978>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
68978>>>>>>>>>
68978>>>>>>>>>// pTo
68978>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
68978>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
68978>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
68978>>>>>>>>>//   double null-terminated.
68978>>>>>>>>>
68978>>>>>>>>>// fAnyOperationsAborted
68978>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
68978>>>>>>>>>//   were completed or FALSE otherwise.
68978>>>>>>>>>
68978>>>>>>>>>
68978>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
68978>>>>>>>>>// This can be a file or a folder.
68978>>>>>>>>>// With thanks to Andrew S Kaplan
68978>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
68979>>>>>>>>>
68979>>>>>>>>>
68979>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
68979>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
68980>>>>>>>>>
68980>>>>>>>>>
68980>>>>>>>>>
68980>>>>>>>>>// Courtesy Of Vincent Oorsprong
68980>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
68980>>>>>>>>>//   Pointer lpPathName ;
68980>>>>>>>>>//   Pointer lpPrefixString ;
68980>>>>>>>>>//   Integer uUnique ;
68980>>>>>>>>>//   Pointer lpTempFileName ;
68980>>>>>>>>>//   Returns Integer
68980>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
68980>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
68981>>>>>>>>>
68981>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
68982>>>>>>>>>
68982>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
68983>>>>>>>>>
68983>>>>>>>>>// from:
68983>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
68983>>>>>>>>>//
68983>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
68983>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
68983>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
68983>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
68983>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
68983>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
68983>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
68983>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
68983>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
68983>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
68983>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
68983>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
68983>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
68983>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
68983>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
68983>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
68983>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
68983>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
68983>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
68983>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
68983>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
68983>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
68983>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
68983>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
68983>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
68983>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
68983>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
68983>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
68983>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
68983>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
68983>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
68983>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
68983>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
68983>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
68983>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
68983>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
68983>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
68983>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
68983>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
68983>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
68983>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
68983>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
68983>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
68983>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
68983>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
68983>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
68983>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
68983>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
68983>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
68983>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
68983>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
68983>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
68983>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
68983>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
68983>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
68983>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
68983>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
68983>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
68983>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
68983>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
68983>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
68983>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
68983>>>>>>>>>
68983>>>>>>>>>
68983>>>>>>>>>//HRESULT SHGetFolderPath(
68983>>>>>>>>>//    HWND hwndOwner,
68983>>>>>>>>>//    int nFolder,
68983>>>>>>>>>//    HANDLE hToken,
68983>>>>>>>>>//    DWORD dwFlags,
68983>>>>>>>>>//    LPTSTR pszPath
68983>>>>>>>>>//);
68983>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
68983>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
68983>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
68983>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
68983>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
68983>>>>>>>>>//
68983>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
68984>>>>>>>>>
68984>>>>>>>>>
68984>>>>>>>>>
68984>>>>>>>>>Struct tvWin32FindData
68984>>>>>>>>> Dword            dwFileAttributes
68984>>>>>>>>> Dword            ftCreationLowDateTime
68984>>>>>>>>> Dword            ftCreationHighDateTime
68984>>>>>>>>> dword            ftLastAccessLowDateTime
68984>>>>>>>>> Dword            ftLastAccessHighDateTime
68984>>>>>>>>> Dword            ftLastWriteLowDateTime
68984>>>>>>>>> Dword            ftLastWriteHighDateTime
68984>>>>>>>>> Dword            nFileSizeHigh
68984>>>>>>>>> Dword            nFileSizeLow
68984>>>>>>>>> Dword            dwReserved0
68984>>>>>>>>> Dword            dwReserved1
68984>>>>>>>>> UChar[vMax_Path] cFileName
68984>>>>>>>>> UChar[14]        cAlternateFileName
68984>>>>>>>>>End_Struct
68984>>>>>>>>>
68984>>>>>>>>>// Courtesy Of Vincent Oorsprong
68984>>>>>>>>>// lpFileName      : address of name of file to search for
68984>>>>>>>>>// lpFindFileData  : address of returned information
68984>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
68985>>>>>>>>>
68985>>>>>>>>>// Courtesy Of Vincent Oorsprong
68985>>>>>>>>>// hFindFile       : handle of search
68985>>>>>>>>>// lpFindFileData  : address of structure for data on found file
68985>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
68986>>>>>>>>>
68986>>>>>>>>>//
68986>>>>>>>>>// Unicode equivalents
68986>>>>>>>>>//
68986>>>>>>>>>// lpFileName      : address of name of file to search for
68986>>>>>>>>>// lpFindFileData  : address of returned information
68986>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
68987>>>>>>>>>
68987>>>>>>>>>// hFindFile       : handle of search
68987>>>>>>>>>// lpFindFileData  : address of structure for data on found file
68987>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
68988>>>>>>>>>
68988>>>>>>>>>
68988>>>>>>>>>// Courtesy Of Vincent Oorsprong
68988>>>>>>>>>//  hFindFile      : file search handle
68988>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
68989>>>>>>>>>
68989>>>>>>>>>
68989>>>>>>>>>
68989>>>>>>>>>Struct tvFileTime
68989>>>>>>>>>  DWord dwLowDateTime
68989>>>>>>>>>  DWord dwHighDateTime
68989>>>>>>>>>End_Struct
68989>>>>>>>>>
68989>>>>>>>>>
68989>>>>>>>>>Struct tvSystemTime
68989>>>>>>>>>  UShort wYear
68989>>>>>>>>>  UShort wMonth
68989>>>>>>>>>  UShort wDayOfWeek
68989>>>>>>>>>  UShort wDay
68989>>>>>>>>>  UShort wHour
68989>>>>>>>>>  UShort wMinute
68989>>>>>>>>>  UShort wSecond
68989>>>>>>>>>  UShort wMilliSeconds
68989>>>>>>>>>End_Struct
68989>>>>>>>>>
68989>>>>>>>>>
68989>>>>>>>>>// Courtesy Of Vincent Oorsprong
68989>>>>>>>>>//  lpFileTime     : pointer to file time to convert
68989>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
68989>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
68990>>>>>>>>>
68990>>>>>>>>>// Courtesy Of Vincent Oorsprong
68990>>>>>>>>>// This function formats the time in a picture-string passed
68990>>>>>>>>>//
68990>>>>>>>>>// Picture      Meaning
68990>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
68990>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
68990>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
68990>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
68990>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
68990>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
68990>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
68990>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
68990>>>>>>>>>//    t         One character time marker string, such as A or P
68990>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
68990>>>>>>>>>//
68990>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
68990>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
68990>>>>>>>>>
68990>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
68991>>>>>>>>>
68991>>>>>>>>>
68991>>>>>>>>>// Courtesy Of Vincent Oorsprong
68991>>>>>>>>>// This function formats the date in a picture-string passed
68991>>>>>>>>>//
68991>>>>>>>>>// Picture      Meaning
68991>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
68991>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
68991>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
68991>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
68991>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
68991>>>>>>>>>//              value associated with the specified locale.
68991>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
68991>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
68991>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
68991>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
68991>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
68991>>>>>>>>>//              associated with the specified locale.
68991>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
68991>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
68991>>>>>>>>>//    yyyy      Year represented hy full four digits.
68991>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
68991>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
68991>>>>>>>>>//              does not have an associated era or period string.
68991>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
68991>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
68991>>>>>>>>>
68991>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
68992>>>>>>>>>
68992>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
68992>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
68992>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
68992>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
68992>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
68992>>>>>>>>>
68992>>>>>>>>>//  Date Flags for GetDateFormatW.
68992>>>>>>>>>//
68992>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
68992>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
68992>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
68992>>>>>>>>>
68992>>>>>>>>>
68992>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
68993>>>>>>>>>
68993>>>>>>>>>
68993>>>>>>>>>// **WvA: 20-02-2004
68993>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
68993>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
68993>>>>>>>>>// incorrectly into an unsigned integer.
68993>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
68993>>>>>>>>>// It does smell a bit fishy though
68993>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
68993>>>>>>>>>
68993>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
68993>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
68993>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
68993>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
68993>>>>>>>>>
68993>>>>>>>>>// Possible errors that can be returned by the shellformat function
68993>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
68993>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
68993>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
68993>>>>>>>>>
68993>>>>>>>>>
68993>>>>>>>>> // Courtesy Of Steve Walter,
68993>>>>>>>>> // USA Software, Inc
68993>>>>>>>>> // Format a disk
68993>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
68993>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
68994>>>>>>>>>
68994>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
68994>>>>>>>>>
68994>>>>>>>>>// SHCreateDirectoryEx
68994>>>>>>>>>
68994>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
68994>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
68994>>>>>>>>>//
68994>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
68994>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
68994>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
68994>>>>>>>>>//
68994>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
68994>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
68994>>>>>>>>>//        ERROR_CANCELLED.
68994>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
68994>>>>>>>>>
68994>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
68994>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
68994>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
68994>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
68994>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
68994>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
68994>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
68994>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
68994>>>>>>>>>
68994>>>>>>>>>//        int SHCreateDirectoryEx(
68994>>>>>>>>>//            HWND hwnd,
68994>>>>>>>>>//            LPCTSTR pszPath,
68994>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
68994>>>>>>>>>//        );
68994>>>>>>>>>
68994>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
68995>>>>>>>>>
68995>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
68996>>>>>>>
68996>>>>>>>
68996>>>>>>>//
68996>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
68996>>>>>>>// If sStopChar has no occurences in the string an empty string is
68996>>>>>>>// returned.
68996>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
68998>>>>>>>    String  sRetVal
68998>>>>>>>    String  sChar
68998>>>>>>>    Integer iLength
68998>>>>>>>    Integer iPos
68998>>>>>>>    Boolean bStopChar
68998>>>>>>>    Move "" to sRetval
68999>>>>>>>    Move (Length(sFrom)) to iLength
69000>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
69002>>>>>>>        Move iLength   to iPos
69003>>>>>>>        Move (False)   to bStopChar
69004>>>>>>>        While Not bStopChar
69008>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
69009>>>>>>>            Decrement iPos
69010>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
69012>>>>>>>                Move (True) to bStopChar
69013>>>>>>>            End
69013>>>>>>>>
69013>>>>>>>            Else Begin
69014>>>>>>>                Move (sChar+sRetVal) to sRetVal
69015>>>>>>>            End
69015>>>>>>>>
69015>>>>>>>        Loop
69016>>>>>>>>
69016>>>>>>>    End
69016>>>>>>>>
69016>>>>>>>    Function_Return sRetVal
69017>>>>>>>End_Function
69018>>>>>>>
69018>>>>>>>// Pre:  sFileName contains the complete path of the file.
69018>>>>>>>// Post: returns the complete path of the file.
69018>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
69018>>>>>>>Function ParseFolderName Global String sFileName Returns String
69020>>>>>>>    String sFile
69020>>>>>>>    String sFolderName
69020>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
69020>>>>>>>
69020>>>>>>>    Move "" to sFolderName
69021>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69022>>>>>>>    If sDirSep In sFileName Begin
69024>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
69025>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
69026>>>>>>>    End
69026>>>>>>>>
69026>>>>>>>    Else If ":" In sFileName Begin
69029>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
69030>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
69031>>>>>>>    End
69031>>>>>>>>
69031>>>>>>>    Function_Return sFolderName
69032>>>>>>>End_Function
69033>>>>>>>
69033>>>>>>>// Pre:  sFileName contains the complete path of the file.
69033>>>>>>>// post: The returned filename has it's path removed, but will have a extension
69033>>>>>>>Function ParseFileName Global String sFileName Returns String
69035>>>>>>>    String sFolderName
69035>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
69035>>>>>>>
69035>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69036>>>>>>>    Get ParseFolderName sFileName to sFolderName
69037>>>>>>>    If (sFolderName <> "") Begin
69039>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
69040>>>>>>>    End
69040>>>>>>>>
69040>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
69041>>>>>>>    Function_Return sFilename
69042>>>>>>>End_Function
69043>>>>>>>
69043>>>>>>>// Pre:  sFileName may contain the complete path of the file.
69043>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
69043>>>>>>>//       return "bak" as the extension and not "gif"
69043>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
69043>>>>>>>//       such as "html" or "java"
69043>>>>>>>Function ParseFileExtension Global String sFileName Returns String
69045>>>>>>>    String  sFileExtension
69045>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
69046>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
69047>>>>>>>    Function_Return sFileExtension
69048>>>>>>>End_Function
69049>>>>>>>
69049>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
69049>>>>>>>
69049>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
69051>>>>>>>    String sMessage
69051>>>>>>>    Case Begin
69051>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
69053>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
69054>>>>>>>            Case Break
69055>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
69058>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
69059>>>>>>>            Case Break
69060>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
69063>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
69064>>>>>>>            Case Break
69065>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
69068>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
69069>>>>>>>            Case Break
69070>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
69073>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
69074>>>>>>>            Case Break
69075>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
69078>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
69079>>>>>>>            Case Break
69080>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
69083>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
69084>>>>>>>            Case Break
69085>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
69088>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
69089>>>>>>>            Case Break
69090>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
69093>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
69094>>>>>>>            Case Break
69095>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
69098>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
69099>>>>>>>            Case Break
69100>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
69103>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
69104>>>>>>>            Case Break
69105>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
69108>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
69109>>>>>>>            Case Break
69110>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
69113>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
69114>>>>>>>            Case Break
69115>>>>>>>        Case Else
69115>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
69116>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
69117>>>>>>>            Case Break
69118>>>>>>>    Case End
69118>>>>>>>    Function_Return sMessage
69119>>>>>>>End_Function
69120>>>>>>>
69120>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
69122>>>>>>>    String sMessage
69122>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
69123>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
69124>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
69125>>>>>>>End_Procedure
69126>>>>>>>
69126>>>>>>>// Does the directory exist? - No = false, Yes = True
69126>>>>>>>// This also works with UNC path encoding and wildcards
69126>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
69128>>>>>>>    Boolean bFolderExists
69128>>>>>>>    Boolean bStop
69128>>>>>>>    String  sFolder sTmp
69128>>>>>>>    Integer iCh
69128>>>>>>>
69128>>>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
69128>>>>>>>    Move (ToAnsi(Trim(sFolderName))) to sFolderName
69129>>>>>>>    If (sFolderName = "") Begin
69131>>>>>>>        Function_Return False
69132>>>>>>>    End
69132>>>>>>>>
69132>>>>>>>
69132>>>>>>>    Move True  to bFolderExists
69133>>>>>>>    Move False to bStop
69134>>>>>>>    Move "dir:" to sFolder
69135>>>>>>>    Append sFolder sFolderName
69136>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
69137>>>>>>>    Direct_Input channel iCh sFolder
69139>>>>>>>    Repeat
69139>>>>>>>>
69139>>>>>>>        Readln channel iCh sTmp
69141>>>>>>>        Move (SeqEof) to bStop
69142>>>>>>>        If (Trim(sTmp)="") Begin
69144>>>>>>>            Move False to bFolderExists
69145>>>>>>>        End
69145>>>>>>>>
69145>>>>>>>        Else Begin
69146>>>>>>>            Move True to bFolderExists
69147>>>>>>>            Move True to bStop
69148>>>>>>>        End
69148>>>>>>>>
69148>>>>>>>    Until (bStop)
69150>>>>>>>    Close_Input channel iCh
69152>>>>>>>    Send Seq_Release_Channel iCh
69153>>>>>>>    Function_Return bFolderExists
69154>>>>>>>End_Function
69155>>>>>>>
69155>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
69155>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
69157>>>>>>>    String sFolder sTitle sPath
69157>>>>>>>    Pointer lpItemIdList
69157>>>>>>>    Integer iFolderSelected iRetval
69157>>>>>>>    tvBrowseInfo BrowseInfo
69157>>>>>>>    tvBrowseInfo BrowseInfo
69157>>>>>>>
69157>>>>>>>    Move "" to sPath
69158>>>>>>>    If (sDialogTitle<>"") Begin
69160>>>>>>>        Move sDialogTitle to sTitle
69161>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
69161>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
69161>>>>>>>        // These chars are correctly shown if no toansi is used.
69161>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
69161>>>>>>>        // selected it will always be valid.
69161>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
69162>>>>>>>    End
69162>>>>>>>>
69162>>>>>>>
69162>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
69163>>>>>>>
69163>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
69163>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
69163>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
69164>>>>>>>
69164>>>>>>>    // null 128 chars into var (make space)
69164>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69165>>>>>>>
69165>>>>>>>    // select folder
69165>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
69166>>>>>>>    // get selected folder name
69166>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
69167>>>>>>>
69167>>>>>>>    // release memory resources that are used by the ItemIdList
69167>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
69168>>>>>>>
69168>>>>>>>    If (iFolderSelected<>0) Begin
69170>>>>>>>        Move (CString(sFolder)) to sPath
69171>>>>>>>    End
69171>>>>>>>>
69171>>>>>>>    Function_Return  sPath
69172>>>>>>>End_Function
69173>>>>>>>
69173>>>>>>>// returns 0 if the folder is created.
69173>>>>>>>//         1 if the API-call returned an error.
69173>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
69175>>>>>>>    String  sFolder
69175>>>>>>>    Integer iRetval bFolderCreated
69175>>>>>>>    tvSecurity_attributes SA
69175>>>>>>>    tvSecurity_attributes SA
69175>>>>>>>
69175>>>>>>>    Move False to bFolderCreated
69176>>>>>>>
69176>>>>>>>    // null MAX_PATH chars into var (make space)
69176>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69177>>>>>>>
69177>>>>>>>    If (sNewFolder <> "") Begin
69179>>>>>>>
69179>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
69180>>>>>>>        Move  0  to SA.lpDescriptor
69181>>>>>>>        Move  1  to SA.bInheritHandle
69182>>>>>>>
69182>>>>>>>        //
69182>>>>>>>        Move (sNewFolder+"") to sFolder
69183>>>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
69184>>>>>>>    End
69184>>>>>>>>
69184>>>>>>>
69184>>>>>>>    If (bFolderCreated=false) Begin
69186>>>>>>>        Move 1 to iRetVal
69187>>>>>>>    End
69187>>>>>>>>
69187>>>>>>>    Function_Return iRetVal
69188>>>>>>>End_Function
69189>>>>>>>
69189>>>>>>>// **WvA: 03-02-2002 Function created.
69189>>>>>>>// With this function one can remove a directory.
69189>>>>>>>// returns 0 if the folder is removed.
69189>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
69189>>>>>>>//         2 if the folder did not exist
69189>>>>>>>//         3 if the sFolder parameter passed is equal to ""
69189>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
69191>>>>>>>    Boolean bRemoved
69191>>>>>>>    String  sPath
69191>>>>>>>    Integer iRetval
69191>>>>>>>
69191>>>>>>>    Move 0     to iRetVal
69192>>>>>>>    Move False to bRemoved
69193>>>>>>>    Move (Trim(sFolder)) to sFolder
69194>>>>>>>    If (sFolder="") Begin
69196>>>>>>>        Move 3 to iRetVal
69197>>>>>>>    End
69197>>>>>>>>
69197>>>>>>>    If (vFolderExists(sFolder)=False) Begin
69199>>>>>>>        Move 2 to iRetVal
69200>>>>>>>    End
69200>>>>>>>>
69200>>>>>>>    If (iRetVal=0) Begin
69202>>>>>>>    // null MAX_PATH chars into var (make space)
69202>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
69203>>>>>>>        //
69203>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
69204>>>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
69205>>>>>>>    End
69205>>>>>>>>
69205>>>>>>>
69205>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
69207>>>>>>>        Move 1 to iRetVal
69208>>>>>>>    End
69208>>>>>>>>
69208>>>>>>>    Function_Return iRetVal
69209>>>>>>>End_Function
69210>>>>>>>
69210>>>>>>>// This function informs the user that he entered a yet unknown folder and
69210>>>>>>>// asks if he/she wants to create the folder (Yes/No)
69210>>>>>>>// Choice: "Yes" - this creates the folder
69210>>>>>>>//                 if successful, the function returns false
69210>>>>>>>//                 else it will be true.
69210>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
69210>>>>>>>//                 For example: to stop a save
69210>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
69210>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
69210>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
69212>>>>>>>    Integer bIsNotValid
69212>>>>>>>    Integer iUsers_Choice
69212>>>>>>>    String  sMessage
69212>>>>>>>
69212>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
69214>>>>>>>        Move "The folder '" to sMessage
69215>>>>>>>        Append sMessage sFolderName
69216>>>>>>>        Append sMessage "' does not yet exist,\n"
69217>>>>>>>        Append sMessage "Do you want to create it now?"
69218>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
69219>>>>>>>        Case Begin
69219>>>>>>>            Case (iUsers_Choice = MBR_Yes)
69221>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
69222>>>>>>>                If bIsNotValid Begin
69224>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
69225>>>>>>>                    Append sMessage sFolderName "'.\n\n"
69227>>>>>>>                    Send Info_Box sMessage "Info"
69228>>>>>>>                End
69228>>>>>>>>
69228>>>>>>>                Case Break
69229>>>>>>>            Case (iUsers_Choice = MBR_No)
69232>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
69233>>>>>>>                Case Break
69234>>>>>>>        Case End
69234>>>>>>>    End
69234>>>>>>>>
69234>>>>>>>    Function_Return bIsNotValid
69235>>>>>>>End_Function
69236>>>>>>>
69236>>>>>>>// This will perform an operation on a file (e.g. open) with the application
69236>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
69236>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
69236>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
69238>>>>>>>    Handle  hInstance hWnd
69238>>>>>>>    // remove any leading/trailing spaces in the string
69238>>>>>>>    Move (Trim(sDocument)) to sDocument
69239>>>>>>>    Move (Trim(sPath))     to sPath
69240>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
69240>>>>>>>    Append sOperation   (Character(0))
69241>>>>>>>    Append sDocument    (Character(0))
69242>>>>>>>    Append sParameters  (Character(0))
69243>>>>>>>    Append sPath        (Character(0))
69244>>>>>>>
69244>>>>>>>    Get Window_Handle to hWnd
69245>>>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
69246>>>>>>>    If (hInstance <= 32) Begin
69248>>>>>>>        Send vDDE_Error_Handler hInstance
69249>>>>>>>    End
69249>>>>>>>>
69249>>>>>>>End_Procedure
69250>>>>>>>
69250>>>>>>>Class cShellFileOperations is a Array
69251>>>>>>>
69251>>>>>>>    Procedure Construct_Object
69253>>>>>>>        Forward Send Construct_Object
69255>>>>>>>        Property Integer piDeleteFlags        0
69256>>>>>>>        Property Integer piCopyFlags          0
69257>>>>>>>        Property Integer piMoveFlags          0
69258>>>>>>>        Property Integer piRenameFlags        0
69259>>>>>>>
69259>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
69260>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
69261>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
69262>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
69263>>>>>>>    End_Procedure
69264>>>>>>>
69264>>>>>>>    // This function uses the shell API to perform a file operation on the
69264>>>>>>>    // files supplied.
69264>>>>>>>    //
69264>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
69266>>>>>>>        Integer  iRetVal
69266>>>>>>>        Integer  iUserAbort
69266>>>>>>>        tvShFileOpStruct FOS
69266>>>>>>>        tvShFileOpStruct FOS
69266>>>>>>>
69266>>>>>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
69267>>>>>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
69268>>>>>>>        If (eOperation <> vFO_DELETE) Begin
69270>>>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
69271>>>>>>>        End
69271>>>>>>>>
69271>>>>>>>
69271>>>>>>>        Move eOperation           to FOS.wFunc
69272>>>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
69273>>>>>>>        Move iFlags               to FOS.fFlags
69274>>>>>>>
69274>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
69275>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
69276>>>>>>>        If (iUserAbort <> 0) Begin
69278>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
69279>>>>>>>        End
69279>>>>>>>>
69279>>>>>>>        Function_Return (iRetVal)
69280>>>>>>>    End_Function
69281>>>>>>>
69281>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
69283>>>>>>>        Integer  iRetVal
69283>>>>>>>        Integer  iFlags
69283>>>>>>>
69283>>>>>>>        Get piDeleteFlags to iFlags
69284>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
69285>>>>>>>        Function_Return iRetVal
69286>>>>>>>    End_Function
69287>>>>>>>
69287>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
69289>>>>>>>        Integer  iRetVal
69289>>>>>>>        Integer  iFlags
69289>>>>>>>
69289>>>>>>>        Get piCopyFlags to iFlags
69290>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
69291>>>>>>>        Function_Return iRetVal
69292>>>>>>>    End_Function
69293>>>>>>>
69293>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
69295>>>>>>>        Integer  iRetVal
69295>>>>>>>        Integer  iFlags
69295>>>>>>>
69295>>>>>>>        Get piMoveFlags to iFlags
69296>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
69297>>>>>>>        Function_Return iRetVal
69298>>>>>>>    End_Function
69299>>>>>>>
69299>>>>>>>    // Rename a file or folder
69299>>>>>>>    // Returns a nonzero value if the operation failed.
69299>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
69301>>>>>>>        Integer  iRetVal
69301>>>>>>>        Integer  iFlags
69301>>>>>>>
69301>>>>>>>        Get piRenameFlags to iFlags
69302>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
69303>>>>>>>        Function_Return iRetVal
69304>>>>>>>    End_Function
69305>>>>>>>
69305>>>>>>>    // Courtesy Of Steve Walter
69305>>>>>>>    // Requires Windows 2000 and up according to msdn but it was
69305>>>>>>>    //  in fact available before that as an unpublished API call
69305>>>>>>>    //  a little google search shows that this was already available
69305>>>>>>>    //  in windows 95 and NT
69305>>>>>>>    //
69305>>>>>>>    // The format is controlled by the dialog interface.
69305>>>>>>>    // That is, the user must click the OK button To actually Begin the format
69305>>>>>>>    // the format cannot be started programmatically.
69305>>>>>>>    // An alternative to this functionality would be to use a controlpanel
69305>>>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
69305>>>>>>>    //
69305>>>>>>>    // hWnd = The windows handle of the object from which the format Function
69305>>>>>>>    //        is called.
69305>>>>>>>    // To Get this,
69305>>>>>>>    //          use:  Get Window_Handle Of <object>
69305>>>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
69305>>>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
69305>>>>>>>    //
69305>>>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
69305>>>>>>>    //
69305>>>>>>>    // iOptions = Format options.
69305>>>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
69305>>>>>>>    //  SHFMT_OPT_FULL    = Full Format
69305>>>>>>>    //  SHFMT_OPT_SYSONLY = System only
69305>>>>>>>    //  3                 = Full format with system. (unsupported)
69305>>>>>>>    //
69305>>>>>>>    // Return Values:
69305>>>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
69305>>>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
69305>>>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
69305>>>>>>>    //
69305>>>>>>>    //
69305>>>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
69305>>>>>>>    //                seem to work, i must have made a silly mistake
69305>>>>>>>    //                somewhere.
69305>>>>>>>    //
69305>>>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
69307>>>>>>>        Handle   hWnd
69307>>>>>>>        Integer  iObj
69307>>>>>>>        DWord    dwReturnVal
69307>>>>>>>        Integer iDrive
69307>>>>>>>
69307>>>>>>>        Function_Return 1 // STOP HERE
69308>>>>>>>
69308>>>>>>>        Move (Trim(sDrive)) to sDrive
69309>>>>>>>        If ( sDrive <> '' ) Begin
69311>>>>>>>            If ( sDrive Contains ':' ) Begin
69313>>>>>>>                Move (Replace(':',sDrive,'')) to sDrive
69314>>>>>>>            End
69314>>>>>>>>
69314>>>>>>>            If (Not( 'AB' Contains sDrive )) Begin
69316>>>>>>>                Function_Return (SHFMT_NOFORMAT)
69317>>>>>>>            End
69317>>>>>>>>
69317>>>>>>>            If ( sDrive = 'A' ) Begin
69319>>>>>>>                Move 0 to iDrive
69320>>>>>>>            End
69320>>>>>>>>
69320>>>>>>>            Else If ( sDrive = 'B' ) Begin
69323>>>>>>>                Move 1 to iDrive
69324>>>>>>>            End
69324>>>>>>>>
69324>>>>>>>            // Window_Handle Of Desktop equals to 0
69324>>>>>>>
69324>>>>>>>            Get focus of desktop to iObj
69325>>>>>>>            If (iObj>desktop) Begin
69327>>>>>>>                Get Container_Handle of iObj to hWnd
69328>>>>>>>            End
69328>>>>>>>>
69328>>>>>>>            While (hWnd=0 And iObj<>Desktop)
69332>>>>>>>                Get Parent of iObj to iObj
69333>>>>>>>                Get Container_Handle of iObj to hWnd
69334>>>>>>>            Loop
69335>>>>>>>>
69335>>>>>>>
69335>>>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
69335>>>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
69336>>>>>>>        End
69336>>>>>>>>
69336>>>>>>>        Else Begin
69337>>>>>>>            Move (SHFMT_ERROR) to dwReturnVal
69338>>>>>>>        End
69338>>>>>>>>
69338>>>>>>>        Function_Return dwReturnVal
69339>>>>>>>    End_Function
69340>>>>>>>
69340>>>>>>>    //Example:
69340>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
69340>>>>>>>    //                                          mode.
69340>>>>>>>
69340>>>>>>>End_Class
69341>>>>>>>
69341>>>>>>>Object oShellFileOperations is a cShellFileOperations
69343>>>>>>>End_Object
69344>>>>>>>
69344>>>>>>>// Restore to the old way of working with the shell file operations.
69344>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
69344>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
69344>>>>>>>Procedure vWin32fhCompatibilityMode
69346>>>>>>>    Integer hoSFO
69346>>>>>>>    Integer iFlags
69346>>>>>>>
69346>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
69347>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
69348>>>>>>>
69348>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
69349>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
69350>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
69351>>>>>>>    Set piRenameFlags of hoSFO to iFlags
69352>>>>>>>End_Procedure
69353>>>>>>>
69353>>>>>>>// Delete a file or folder
69353>>>>>>>// Returns a nonzero value if the operation failed.
69353>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
69355>>>>>>>    Integer  iRetVal
69355>>>>>>>
69355>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
69356>>>>>>>    Function_Return iRetVal
69357>>>>>>>End_Function
69358>>>>>>>
69358>>>>>>>// Copy a file or folder
69358>>>>>>>// Returns a nonzero value if the operation failed.
69358>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
69360>>>>>>>    Integer  iRetVal
69360>>>>>>>
69360>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69361>>>>>>>    Function_Return iRetVal
69362>>>>>>>End_Function
69363>>>>>>>
69363>>>>>>>// Move a file or folder
69363>>>>>>>// Returns a nonzero value if the operation failed.
69363>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
69365>>>>>>>    Integer  iRetVal
69365>>>>>>>
69365>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69366>>>>>>>    Function_Return iRetVal
69367>>>>>>>End_Function
69368>>>>>>>
69368>>>>>>>// Rename a file or folder
69368>>>>>>>// Returns a nonzero value if the operation failed.
69368>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
69370>>>>>>>    Integer  iRetVal
69370>>>>>>>
69370>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69371>>>>>>>    Function_Return iRetVal
69372>>>>>>>End_Function
69373>>>>>>>
69373>>>>>>>Function vGetWindowsDirectory Returns String
69375>>>>>>>    String  sDirectory
69375>>>>>>>    Integer iVoid
69375>>>>>>>
69375>>>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
69376>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
69377>>>>>>>    Function_Return (CString(sDirectory))
69378>>>>>>>End_Function
69379>>>>>>>
69379>>>>>>>Function vGetTempPath Returns String
69381>>>>>>>    Integer iRetval
69381>>>>>>>    String  sTempPath
69381>>>>>>>
69381>>>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
69382>>>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
69383>>>>>>>    Function_Return (Cstring(sTempPath))
69384>>>>>>>End_Function
69385>>>>>>>
69385>>>>>>>// Courtesy of Marco Kuipers
69385>>>>>>>Function vMakeTempFile Returns String
69387>>>>>>>    Integer iRetval
69387>>>>>>>    String  sTempPath
69387>>>>>>>    String  sTempFileName
69387>>>>>>>    String  sPrefixString
69387>>>>>>>
69387>>>>>>>    Get vGetTempPath to sTempPath
69388>>>>>>>    If (sTempPath = "") Begin
69390>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
69391>>>>>>>        If (sTempPath<>"") Begin
69393>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
69394>>>>>>>        End
69394>>>>>>>>
69394>>>>>>>    End
69394>>>>>>>>
69394>>>>>>>
69394>>>>>>>    If (sTempPath = "") Begin
69396>>>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
69396>>>>>>>    // makes little sense. Leaving this in as it was old behavior.
69396>>>>>>>        Get_Current_Directory to sTempPath
69397>>>>>>>    End
69397>>>>>>>>
69397>>>>>>>
69397>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
69398>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
69400>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
69401>>>>>>>>
69401>>>>>>>    End
69401>>>>>>>>
69401>>>>>>>
69401>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
69402>>>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
69403>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
69404>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
69406>>>>>>>    //Get ShowLastError to iRetval
69406>>>>>>>        Move "" to sTempFileName
69407>>>>>>>    End
69407>>>>>>>>
69407>>>>>>>
69407>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
69408>>>>>>>End_Function
69409>>>>>>>
69409>>>>>>>// This function creates a uniquely named temporary file in folder sPath
69409>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
69409>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
69409>>>>>>>// does not take care of that.
69409>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
69411>>>>>>>    Integer iRetVal
69411>>>>>>>    String sTempFileName
69411>>>>>>>
69411>>>>>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
69412>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
69413>>>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
69414>>>>>>>
69414>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
69415>>>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
69416>>>>>>>    Function_Return sTempFileName
69417>>>>>>>End_Function
69418>>>>>>>
69418>>>>>>>//
69418>>>>>>>// Get a specific shell folder for example to get the desktop folder
69418>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
69418>>>>>>>//
69418>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
69420>>>>>>>    String  sFolder
69420>>>>>>>    Integer iVoid
69420>>>>>>>    Handle  hWnd
69420>>>>>>>
69420>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
69421>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69422>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
69423>>>>>>>    Function_Return (CString(sFolder))
69424>>>>>>>End_Function
69425>>>>>>>
69425>>>>>>>// Courtesy Of Vincent Oorsprong
69425>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
69427>>>>>>>    String  sFormattedTime sFormattedDate
69427>>>>>>>    String  sFileDateTime
69427>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
69427>>>>>>>    tvFileTime   FileTime
69427>>>>>>>    tvFileTime   FileTime
69427>>>>>>>    tvSystemTime SystemTime
69427>>>>>>>    tvSystemTime SystemTime
69427>>>>>>>
69427>>>>>>>    Move "" to sFileDateTime
69428>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
69429>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
69430>>>>>>>
69430>>>>>>>    Move 0 to SystemTime.wYear
69431>>>>>>>
69431>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
69432>>>>>>>    If (iSuccess = 1) Begin
69434>>>>>>>        Move (ZeroString(255))        to sFormattedTime
69435>>>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
69436>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
69437>>>>>>>        Move (ZeroString(255))        to sFormattedDate
69438>>>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
69439>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
69440>>>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
69441>>>>>>>    End
69441>>>>>>>>
69441>>>>>>>    Function_Return sFileDateTime
69442>>>>>>>End_Function
69443>>>>>>>
69443>>>>>>>// **WvA:
69443>>>>>>>// A windows replacement for the standard function FileExists.
69443>>>>>>>// This version will also return (true) for a file when it is open by an application.
69443>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
69443>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
69443>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
69443>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
69445>>>>>>>    String  sDirSep
69445>>>>>>>    Handle  hFindFile
69445>>>>>>>    Integer iVoid
69445>>>>>>>    tvWin32FindData FindData
69445>>>>>>>    tvWin32FindData FindData
69445>>>>>>>
69445>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
69446>>>>>>>    Move (ToAnsi(Trim(sFilePathMask))) to sFilePathMask
69447>>>>>>>    If (Length(sFilePathMask)>0) Begin
69449>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
69449>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69450>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
69454>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
69455>>>>>>>        Loop
69456>>>>>>>>
69456>>>>>>>
69456>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69457>>>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
69458>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
69459>>>>>>>    End
69459>>>>>>>>
69459>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
69460>>>>>>>End_Function
69461>>>>>>>
69461>>>>>>>//
69461>>>>>>>// WideChar version of the function, do not use, it's an experiment
69461>>>>>>>//
69461>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
69463>>>>>>>    Handle  hFindFile
69463>>>>>>>    Integer iVoid
69463>>>>>>>    tvWin32FindData FindData
69463>>>>>>>    tvWin32FindData FindData
69463>>>>>>>
69463>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
69464>>>>>>>
69464>>>>>>>    If (Length(sFilePathMask)>0) Begin
69466>>>>>>>
69466>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69467>>>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
69468>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
69469>>>>>>>    End
69469>>>>>>>>
69469>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
69470>>>>>>>End_Function
69471>>>>>>>
69471>>>>>>>// **WvA
69471>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
69471>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
69471>>>>>>>// The folder may contain a drive letter or UNC encoding.
69471>>>>>>>Function vFolderFormat Global String sFolderName Returns String
69473>>>>>>>    String sDirSep
69473>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
69474>>>>>>>    Move (Trim(sFolderName)) to sFolderName
69475>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
69477>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
69478>>>>>>>    End
69478>>>>>>>>
69478>>>>>>>    Function_Return sFolderName
69479>>>>>>>End_Function
69480>>>>>>>
69480>>>>>>>//
69480>>>>>>>// Returns the amount of files in the folder (if it exists)
69480>>>>>>>// Returns -1 if folder doesn't exist.
69480>>>>>>>// The files "." and ".." are not counted.
69480>>>>>>>//
69480>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
69482>>>>>>>    Boolean bFound
69482>>>>>>>    Handle  hFindFile
69482>>>>>>>    Integer iCount  iVoid
69482>>>>>>>    Integer iSuccess
69482>>>>>>>    String  sFileName
69482>>>>>>>    tvWin32FindData FindData
69482>>>>>>>    tvWin32FindData FindData
69482>>>>>>>
69482>>>>>>>    Move -1 to iCount
69483>>>>>>>    Get vFolderFormat sFolderName to sFolderName
69484>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
69485>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69486>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
69487>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
69488>>>>>>>    If (bFound) Begin
69490>>>>>>>        Move 0 to iCount
69491>>>>>>>    End
69491>>>>>>>>
69491>>>>>>>    While (bFound)
69495>>>>>>>        Increment iCount
69496>>>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
69497>>>>>>>        If (sFileName="." or sFileName="..") Begin
69499>>>>>>>            Decrement iCount
69500>>>>>>>        End
69500>>>>>>>>
69500>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
69501>>>>>>>        Move (iSuccess<>0) to bFound
69502>>>>>>>    Loop
69503>>>>>>>>
69503>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
69504>>>>>>>    Function_Return iCount
69505>>>>>>>End_Function
69506>>>>>>>
69506>>>>>>>//
69506>>>>>>>// Gets the parent path of the currently supplied path
69506>>>>>>>// Returns "" when we are at the root folder.
69506>>>>>>>//
69506>>>>>>>Function vParentPath Global String sPath Returns String
69508>>>>>>>    String sStrip sDirSep
69508>>>>>>>
69508>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69509>>>>>>>    Move (Trim(sPath)) to sPath
69510>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
69512>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
69513>>>>>>>    End
69513>>>>>>>>
69513>>>>>>>    If (Pos(sDirSep, sPath)) Begin
69515>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
69516>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
69517>>>>>>>    End
69517>>>>>>>>
69517>>>>>>>    Else Begin
69518>>>>>>>        Move "" to sPath
69519>>>>>>>    End
69519>>>>>>>>
69519>>>>>>>    Function_Return sPath
69520>>>>>>>End_Function
69521>>>>>>>
69521>>>>>>>// Create the folder, including intermediate directories.
69521>>>>>>>// Don't panic if the folder already exists.
69521>>>>>>>// Michael Mullan June 2009.
69521>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
69523>>>>>>>    String  sFolder
69523>>>>>>>    Integer iRetval iFolderCreated
69523>>>>>>>    tvSecurity_attributes SA
69523>>>>>>>    tvSecurity_attributes SA
69523>>>>>>>
69523>>>>>>>    Move 0 to iFolderCreated
69524>>>>>>>
69524>>>>>>>    // null MAX_PATH chars into var (make space)
69524>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69525>>>>>>>    If (sNewFolder <> "") Begin
69527>>>>>>>
69527>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
69528>>>>>>>        Move  0  to SA.lpDescriptor
69529>>>>>>>        Move  1  to SA.bInheritHandle
69530>>>>>>>
69530>>>>>>>        //
69530>>>>>>>        Move (sNewFolder+"") to sFolder
69531>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
69532>>>>>>>    End
69532>>>>>>>>
69532>>>>>>>
69532>>>>>>>    If (iFolderCreated <> 0) Begin
69534>>>>>>>        Move 1 to iRetVal
69535>>>>>>>        Case Begin
69535>>>>>>>            Case (iFolderCreated = 161)
69537>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
69538>>>>>>>>
69538>>>>>>>                Case Break
69539>>>>>>>            Case (iFolderCreated = 206)
69542>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
69543>>>>>>>>
69543>>>>>>>                Case Break
69544>>>>>>>            Case (iFolderCreated = 3)
69547>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
69548>>>>>>>>
69548>>>>>>>                Case Break
69549>>>>>>>            Case (iFolderCreated = 80)
69552>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
69553>>>>>>>                Case Break
69554>>>>>>>            Case (iFolderCreated = 183)
69557>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
69558>>>>>>>                Case Break
69559>>>>>>>            Case (iFolderCreated = 1223)
69562>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
69563>>>>>>>>
69563>>>>>>>                Case Break
69564>>>>>>>            Case Else
69564>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
69565>>>>>>>>
69565>>>>>>>        Case End
69565>>>>>>>    End
69565>>>>>>>>
69565>>>>>>>    Function_Return iRetVal
69566>>>>>>>End_Function
69567>>>>>>>
69567>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
69569>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
69569>>>>>>>    Integer iFileSize iVoid
69569>>>>>>>    Handle  hFindFile
69569>>>>>>>    tvWin32FindData FindData
69569>>>>>>>    tvWin32FindData FindData
69569>>>>>>>
69569>>>>>>>    Move (sFileName+"") to sFileName
69570>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69571>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
69572>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
69574>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
69575>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
69576>>>>>>>    End
69576>>>>>>>>
69576>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
69577>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
69578>>>>>>>
69578>>>>>>>    Function_Return iFileSize
69579>>>>>>>End_Function
69580>>>>>>>
69580>>>>>>>//
69580>>>>>>>// Based on code in Peter Crook's Browse folder workspace
69580>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
69580>>>>>>>//
69580>>>>>>>//=============================================================================
69580>>>>>>>// Verifies that a path is a valid directory.
69580>>>>>>>//
69580>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
69580>>>>>>>//
69580>>>>>>>// Parameters:
69580>>>>>>>//      sPath - Address of the path to verify.
69580>>>>>>>//=============================================================================
69580>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
69582>>>>>>>    Integer iResult
69582>>>>>>>    Boolean bRetVal
69582>>>>>>>
69582>>>>>>>    Move false to bRetVal
69583>>>>>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
69584>>>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
69585>>>>>>>    If (iResult<>0) Begin
69587>>>>>>>        Move True to bRetVal
69588>>>>>>>    End
69588>>>>>>>>
69588>>>>>>>
69588>>>>>>>    Function_Return bRetVal
69589>>>>>>>End_Function
69590>>>>>>>
69590>>>>>Use DUFLanguageConstants.inc
69590>>>>>
69590>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
69590>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
69590>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
69590>>>>>
69590>>>>>Struct tDUFIntFile
69590>>>>>    Integer iID
69590>>>>>    String sIntFileName
69590>>>>>    String sIntLineText
69590>>>>>End_Struct
69590>>>>>
69590>>>>>Struct tDbVersionInfo
69590>>>>>    Number nVersionNumber
69590>>>>>    Handle hObject
69590>>>>>End_Struct
69590>>>>>
69590>>>>>Struct tDbUpdateError
69590>>>>>    Number nUpdateVersion
69590>>>>>    Integer iError
69590>>>>>    String  sOrgErrorText
69590>>>>>    String  sErrorText
69590>>>>>    Integer iErrorLine
69590>>>>>    Boolean bError  
69590>>>>>    Handle  hTable 
69590>>>>>    String  sTableRootName
69590>>>>>    Integer iField
69590>>>>>    Boolean bShortFormat
69590>>>>>End_Struct
69590>>>>>
69590>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
69590>>>>>//  DF_FILE_IS_MASTER if master
69590>>>>>//  DF_FILE_IS_ALIAS if alias
69590>>>>>Struct tDbUpdateHandlerMasterAlias
69590>>>>>    Handle hTable
69590>>>>>    Integer iMode
69590>>>>>End_Struct
69590>>>>>
69590>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
69590>>>>>Enumeration_List
69590>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
69590>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
69590>>>>>End_Enumeration_List
69590>>>>>
69590>>>>>    Define DATAFLEX_ID for "DATAFLEX"
69590>>>>>
69590>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
69590>>>>>// communicate with the object from anywhere in a program.
69590>>>>>    Global_Variable Handle ghoDbUpdateHandler
69590>>>>>    Move 0 to ghoDbUpdateHandler
69591>>>>>
69591>>>>>// NOTE: If the DbVersion table should _not_ be used and you
69591>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
69591>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
69591>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
69591>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
69591>>>>>//    Declare_Datafile DbVersion
69591>>>>>//#ENDIF
69591>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
69591>>>>>//****************************************************************************
69591>>>>>// $Module type: Class
69591>>>>>// $Module name: cDbUpdateLogFile
69591>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69591>>>>>// Web-site    : http://www.rdctools.com
69591>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
69591>>>>>//
69591>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
69591>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
69591>>>>>//               that this class is to change; each developer can decide if the errors instead
69591>>>>>//               should be saved to a database table, or something entirely different.
69591>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
69591>>>>>//
69591>>>>>// $Rev History:
69591>>>>>//    2016-10-05  Module header created
69591>>>>>//****************************************************************************
69591>>>>>Use UI
69591>>>>>Use vWin32fh.pkg
69591>>>>>
69591>>>>>
69591>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
69591>>>>>
69591>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
69591>>>>>
69591>>>>>Class cDbUpdateLogFile is a cObject
69592>>>>>
69592>>>>>    Procedure Construct_Object
69594>>>>>        Forward Send Construct_Object
69596>>>>>
69596>>>>>        // Error handling:
69596>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
69597>>>>>        Property Integer piChannel -1
69598>>>>>
69598>>>>>        // This property is set by the cDbUpdateHandler object,
69598>>>>>        // when the update process starts.
69598>>>>>        Property DateTime pdtUpdateStart
69599>>>>>
69599>>>>>        // Gets set to False if the log contains data
69599>>>>>        Property Boolean pbEmptyLogFile True
69600>>>>>
69600>>>>>        // Gets set to True after the error log header text
69600>>>>>        // has been written.
69600>>>>>        Property Boolean pbHeaderWritten False
69601>>>>>
69601>>>>>        // If all activities should be logged- not just errors.
69601>>>>>        Property Boolean pbVerboseState False
69602>>>>>
69602>>>>>        // File name for the error log where all errors
69602>>>>>        // after a run is written to (appended).
69602>>>>>        // It is saved in the Data folder.
69602>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
69603>>>>>        // If this property is set to "" in object code, the
69603>>>>>        // "shell" command parameter will be used to let Windows decide
69603>>>>>        // with which program to open the logfile.
69603>>>>>        Property String psEditorProgram ""
69604>>>>>
69604>>>>>        Property Boolean pbUseDataTableLog False
69605>>>>>
69605>>>>>        // If true an error will be written to file immediately when
69605>>>>>        // it occurs. This can be handy if a large update generates a lots
69605>>>>>        // of errors and the application crasches before finished, thus
69605>>>>>        // the errors will not be written.
69605>>>>>        Property Boolean pbQuickWrite True
69606>>>>>    End_Procedure
69607>>>>>
69607>>>>>    Procedure End_Construct_Object
69609>>>>>        Forward Send End_Construct_Object
69611>>>>>
69611>>>>>    End_Procedure
69612>>>>>
69612>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
69614>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
69614>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
69616>>>>>        Boolean bShortFormat
69616>>>>>        Integer iSize
69616>>>>>        Handle hCurrentTable
69616>>>>>        Integer iCurrentField           
69616>>>>>        String sOrgErrorText sTableRootName
69616>>>>>        
69616>>>>>        Move False to bShortFormat
69617>>>>>        If (num_arguments > 5) Begin
69619>>>>>            Move bShortFormatIn to bShortFormat
69620>>>>>        End
69620>>>>>>
69620>>>>>        // Only do once.
69620>>>>>        If (pbHeaderWritten(Self) = False) Begin
69622>>>>>            Send WriteHeaderData
69623>>>>>            Set pbHeaderWritten to True
69624>>>>>        End
69624>>>>>>
69624>>>>>
69624>>>>>        Get Private.phCurrentTable to hCurrentTable  
69625>>>>>        Get Private.piCurrentField to iCurrentField  
69626>>>>>        If (iError > 0) Begin
69628>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
69631>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
69632>>>>>        End
69632>>>>>>
69632>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
69633>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
69634>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
69635>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
69636>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
69637>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
69638>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
69639>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
69640>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
69641>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
69642>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
69643>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
69644>>>>>
69644>>>>>        If (bError = False) Begin
69646>>>>>            Move False to DbUpdateErrorArray[iSize].bError
69647>>>>>        End
69647>>>>>>
69647>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
69648>>>>>
69648>>>>>        If (pbUseDataTableLog(Self) = True) Begin
69650>>>>>            If (pbQuickWrite(Self) = True) Begin
69652>>>>>                Send OnWriteRow_DataTable
69653>>>>>                // If we are writing error for error flush the
69653>>>>>                // error array when latest error has been written.
69653>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
69654>>>>>            End
69654>>>>>>
69654>>>>>            Procedure_Return
69655>>>>>        End
69655>>>>>>
69655>>>>>        Else Begin
69656>>>>>            If (pbQuickWrite(Self) = True) Begin
69658>>>>>                Send WriteErrorLog
69659>>>>>                // Flush the error log array
69659>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
69660>>>>>            End
69660>>>>>>
69660>>>>>        End
69660>>>>>>
69660>>>>>    End_Procedure   
69661>>>>>    
69661>>>>>    Function FetchErrorDescription Integer iError Returns String
69663>>>>>        String sErrorText         
69663>>>>>        Move "" to sErrorText
69664>>>>>        If (iError > 0) Begin
69666>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
69667>>>>>        End
69667>>>>>>
69667>>>>>        Function_Return sErrorText
69668>>>>>    End_Function
69669>>>>>
69669>>>>>    // Hook procedure for writing header text prior starting the update work to
69669>>>>>    // a database table. This does nothing by default.
69669>>>>>    // Don't forget to Open your "error log table" first (!) as all
69669>>>>>    // tables have been closed at this stage. Put anything
69669>>>>>    // you want to indicate that the update process is just started.
69669>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
69671>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
69673>>>>>    End_Procedure
69674>>>>>
69674>>>>>    Procedure OnWriteRow_DataTable
69676>>>>>        tDbUpdateError[] DbUpdateErrorArray
69676>>>>>        tDbUpdateError[] DbUpdateErrorArray
69677>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
69678>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
69680>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
69682>>>>>        End
69682>>>>>>
69682>>>>>    End_Procedure
69683>>>>>
69683>>>>>    Function psLogTextFileWithPath Returns String
69685>>>>>        String sPath sFileName sFullFileName
69685>>>>>        
69685>>>>>        Get psDataPathFirstPart to sPath
69686>>>>>        Get psLogTextFile to sFileName
69687>>>>>        Move (sPath + sFileName) to sFullFileName
69688>>>>>        Function_Return sFullFileName
69689>>>>>    End_Function                     
69690>>>>>    
69690>>>>>    Procedure WriteHeaderData
69692>>>>>        String sFileName
69692>>>>>        Integer iCh iSize
69692>>>>>        Boolean bQuickWrite
69692>>>>>        DateTime dtUpdateStart
69692>>>>>
69692>>>>>        Move (CurrentDateTime()) to dtUpdateStart
69693>>>>>        If (pbUseDataTableLog(Self) = True) Begin
69695>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
69696>>>>>            Procedure_Return
69697>>>>>        End
69697>>>>>>
69697>>>>>
69697>>>>>        Get piChannel to iCh
69698>>>>>        If (iCh < 0) Begin
69700>>>>>            Get Seq_New_Channel to iCh
69701>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
69703>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
69704>>>>>>
69704>>>>>                Procedure_Return
69705>>>>>            End
69705>>>>>>
69705>>>>>            Set piChannel to iCh
69706>>>>>        End
69706>>>>>>
69706>>>>>
69706>>>>>        Get psLogTextFileWithPath to sFileName
69707>>>>>        Get vWin32_APIFileSize sFileName to iSize
69708>>>>>        Get pbQuickWrite to bQuickWrite
69709>>>>>        
69709>>>>>        If (bQuickWrite = True) Begin
69711>>>>>            Append_Output channel iCh sFileName
69713>>>>>                If (bQuickWrite = True) Begin
69715>>>>>                    If (iSize = 0) Begin
69717>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
69720>>>>>                        Set pbEmptyLogFile to False
69721>>>>>                    End
69721>>>>>>
69721>>>>>                    Writeln channel iCh
69723>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
69726>>>>>                End
69726>>>>>>
69726>>>>>            Close_Output channel iCh
69728>>>>>        End
69728>>>>>>
69728>>>>>    End_Procedure
69729>>>>>
69729>>>>>    // Returns the first datapath found in the psDataPath property.
69729>>>>>    // The returned path always ends with a "\"
69729>>>>>    Function psDataPathFirstPart Returns String
69731>>>>>        String sDataPath
69731>>>>>        Integer iCount
69731>>>>>
69731>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
69732>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
69733>>>>>        If (iCount > 1) Begin
69735>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
69736>>>>>        End
69736>>>>>>
69736>>>>>        If (sDataPath <> "") Begin
69738>>>>>            Get vFolderFormat sDataPath to sDataPath
69739>>>>>        End
69739>>>>>>
69739>>>>>
69739>>>>>        Function_Return sDataPath
69740>>>>>    End_Function
69741>>>>>
69741>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
69741>>>>>    Procedure WriteErrorLog
69743>>>>>        tDbUpdateError[] aDbUpdateErrorArray
69743>>>>>        tDbUpdateError[] aDbUpdateErrorArray
69744>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
69744>>>>>        Integer iCount iSize iCh iError iErrorLine iField
69744>>>>>        Boolean bUseDataTable bQuickWrite
69744>>>>>        DateTime dtUpdateStart dtUpdateEnd
69744>>>>>        TimeSpan tsElapsed
69744>>>>>        Number nVersion                                  
69744>>>>>        Handle hTable
69744>>>>>
69744>>>>>        If (pbHeaderWritten(Self) = False) Begin
69746>>>>>            Send WriteHeaderData
69747>>>>>            Set pbHeaderWritten to True
69748>>>>>        End
69748>>>>>>
69748>>>>>
69748>>>>>        Get pbUseDataTableLog to bUseDataTable
69749>>>>>        If (bUseDataTable = True) Begin
69751>>>>>            Send OnWriteRow_DataTable
69752>>>>>            Procedure_Return
69753>>>>>        End
69753>>>>>>
69753>>>>>
69753>>>>>        Get piChannel to iCh
69754>>>>>        If (iCh < 0) Begin
69756>>>>>            Get Seq_New_Channel to iCh
69757>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
69759>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
69760>>>>>>
69760>>>>>                Procedure_Return
69761>>>>>            End
69761>>>>>>
69761>>>>>            Set piChannel to iCh
69762>>>>>        End
69762>>>>>>
69762>>>>>
69762>>>>>        Get psLogTextFileWithPath to sFileName
69763>>>>>
69763>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
69764>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
69765>>>>>        Decrement iSize
69766>>>>>
69766>>>>>        Get pdtUpdateStart to dtUpdateStart
69767>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
69769>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
69770>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
69771>>>>>        End
69771>>>>>>
69771>>>>>        Get pbQuickWrite to bQuickWrite
69772>>>>>
69772>>>>>        Append_Output channel iCh sFileName
69774>>>>>        If (bQuickWrite = True and iSize < 0) Begin
69776>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
69779>>>>>        End
69779>>>>>>
69779>>>>>        Else If (bQuickWrite = False) Begin
69782>>>>>            Writeln channel iCh
69784>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
69787>>>>>        End   
69787>>>>>>
69787>>>>>        If (iSize >= 0) Begin
69789>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
69791>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
69794>>>>>            End
69794>>>>>>
69794>>>>>        End
69794>>>>>>
69794>>>>>
69794>>>>>        For iCount from 0 to iSize  
69800>>>>>>
69800>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
69801>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
69802>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
69803>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
69804>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
69805>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
69806>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
69807>>>>>            
69807>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
69808>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
69810>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
69811>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
69812>>>>>            End
69812>>>>>>
69812>>>>>            Else Begin
69813>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
69814>>>>>                Move (sVersion + "   " + sErrorText) to sText
69815>>>>>            End
69815>>>>>>
69815>>>>>            Writeln channel iCh sText
69818>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
69820>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
69821>>>>>                Move (ToANSI(sOrgErrorText)) to sOrgErrorText
69822>>>>>                Writeln channel iCh sOrgErrorText
69825>>>>>            End
69825>>>>>>
69825>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
69827>>>>>                Writeln channel iCh
69829>>>>>            End
69829>>>>>>
69829>>>>>        Loop
69830>>>>>>
69830>>>>>        Close_Output channel iCh
69832>>>>>
69832>>>>>        Send Seq_Release_Channel iCh
69833>>>>>        Set piChannel to -1
69834>>>>>
69834>>>>>    End_Procedure
69835>>>>>
69835>>>>>    // The character to pad is optional. If nothing, spaces are used.
69835>>>>>    // Example:
69835>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
69835>>>>>    //  or:
69835>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
69835>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
69835>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
69837>>>>>        String sChar
69837>>>>>
69837>>>>>        If (Num_Arguments >= 3) Begin
69839>>>>>            Move sOptChar to sChar
69840>>>>>        End
69840>>>>>>
69840>>>>>        Else Begin
69841>>>>>            Move " " to sChar
69842>>>>>        End
69842>>>>>>
69842>>>>>
69842>>>>>        While (Length(sString) < iLength)
69846>>>>>            Move (sChar + sString) to sString
69847>>>>>        Loop
69848>>>>>>
69848>>>>>
69848>>>>>        Function_Return sString
69849>>>>>    End_Function
69850>>>>>
69850>>>>>    Procedure ShowErrorLog
69852>>>>>        String sPath sFileName sEditorProgram
69852>>>>>        Boolean bExists
69852>>>>>
69852>>>>>        Get psLogTextFileWithPath to sFileName
69853>>>>>        Get vFilePathExists sFileName to bExists
69854>>>>>        If (bExists = True) Begin
69856>>>>>            Get psEditorProgram to sEditorProgram
69857>>>>>            If (sEditorProgram <> "") Begin
69859>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
69860>>>>>            End
69860>>>>>>
69860>>>>>            Else Begin
69861>>>>>                Runprogram Shell Background sFileName
69862>>>>>            End
69862>>>>>>
69862>>>>>        End
69862>>>>>>
69862>>>>>        Else Begin
69863>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
69864>>>>>        End
69864>>>>>>
69864>>>>>    End_Procedure
69865>>>>>
69865>>>>>End_Class
69866>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
69866>>>>>//****************************************************************************
69866>>>>>// $Module type: Class
69866>>>>>// $Module name: cDbUpdateVersion
69866>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69866>>>>>// Web-site    : http://www.rdctools.com
69866>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
69866>>>>>//
69866>>>>>// Description : Child class to cDbUpdateHandler.
69866>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
69866>>>>>//               Set the pnVersionNumber to a version number.
69866>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
69866>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
69866>>>>>//               Place your code in the "OnUpdate" event that alters the database.
69866>>>>>//
69866>>>>>// $Rev History:
69866>>>>>//    2016-09-27  Module header created
69866>>>>>//****************************************************************************
69866>>>>>Use UI
69866>>>>>Use DUFLanguageConstants.inc
69866>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
69866>>>>>>>
69866>>>>>>>//****************************************************************************
69866>>>>>>>// $Module type: Class
69866>>>>>>>// $Module name: cDbUpdateFunctionLibrary
69866>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69866>>>>>>>// Web-site    : http://www.rdctools.com
69866>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
69866>>>>>>>//
69866>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
69866>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
69866>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
69866>>>>>>>//               with the help of Sql-scripts.
69866>>>>>>>//
69866>>>>>>>// $Rev History:
69866>>>>>>>//    2014-09-05  Module header created
69866>>>>>>>//
69866>>>>>>>//****************************************************************************
69866>>>>>>>Use cApplication.pkg
69866>>>>>>>Use seq_chnl.pkg
69866>>>>>>>Use GlobalFunctionsProcedures.pkg
69866>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
69866>>>>>>>Use Dfcursor.pkg
69866>>>>>>>Use DUFStatusPanel.pkg
69866>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
69866>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
69866>>>>>>>>>//
69866>>>>>>>>>// We need to create a mixin class for the library.
69866>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
69866>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
69866>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
69866>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
69866>>>>>>>>>//
69866>>>>>>>>>Use VdfBase.pkg
69866>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinUuid.pkg)
69866>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
69867>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
69868>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
69869>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
69870>>>>>>>>>>>
69870>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
69870>>>>>>>>>>>Function RandomHexUUID Global Returns String
69872>>>>>>>>>>>    Address pUUID pUUIDStr
69872>>>>>>>>>>>    Integer iRetval iOffset iChar
69872>>>>>>>>>>>    String sUUID sKey
69872>>>>>>>>>>>    
69872>>>>>>>>>>>    Move (Alloc(16)) to pUUID
69873>>>>>>>>>>>    
69873>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
69874>>>>>>>>>>>    
69874>>>>>>>>>>>    If (iRetval = 0) Begin
69876>>>>>>>>>>>        Move 0 to pUUIDStr
69877>>>>>>>>>>>        
69877>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
69878>>>>>>>>>>>        If (iRetval = 0) Begin
69880>>>>>>>>>>>            Move pUUIDStr to sUUID
69881>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
69882>>>>>>>>>>>            
69882>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
69883>>>>>>>>>>>        End
69883>>>>>>>>>>>>
69883>>>>>>>>>>>    End
69883>>>>>>>>>>>>
69883>>>>>>>>>>>    
69883>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
69884>>>>>>>>>>>    
69884>>>>>>>>>>>    Function_Return sUUID
69885>>>>>>>>>>>End_Function
69886>>>>>>>>>>>
69886>>>>>>>>>>>
69886>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
69886>>>>>>>>>>>Function SeqHexUUID Global Returns String
69888>>>>>>>>>>>    Address pUUID pUUIDStr
69888>>>>>>>>>>>    Integer iRetval iOffset iChar
69888>>>>>>>>>>>    String sUUID sKey
69888>>>>>>>>>>>    
69888>>>>>>>>>>>    Move (Alloc(16)) to pUUID
69889>>>>>>>>>>>    
69889>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
69890>>>>>>>>>>>    
69890>>>>>>>>>>>    If (iRetval = 0) Begin
69892>>>>>>>>>>>        Move 0 to pUUIDStr
69893>>>>>>>>>>>        
69893>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
69894>>>>>>>>>>>        If (iRetval = 0) Begin
69896>>>>>>>>>>>            Move pUUIDStr to sUUID
69897>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
69898>>>>>>>>>>>            
69898>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
69899>>>>>>>>>>>        End
69899>>>>>>>>>>>>
69899>>>>>>>>>>>    End
69899>>>>>>>>>>>>
69899>>>>>>>>>>>    
69899>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
69900>>>>>>>>>>>    
69900>>>>>>>>>>>    Function_Return sUUID
69901>>>>>>>>>>>End_Function
69902>>>>>>>>>Use cli.pkg
69902>>>>>>>>>Use sql.pkg
69902>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
69902>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
69902>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
69902>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69902>>>>>>>>>>>
69902>>>>>>>>>>>Use Cli.pkg
69902>>>>>>>>>>>Use SQL.pkg
69902>>>>>>>>>>>
69902>>>>>>>>>>>//   Driver Indentification
69902>>>>>>>>>>>
69902>>>>>>>>>>>//   Error number constants
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>// SQL Server spcific types.
69902>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69902>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69902>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69902>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69902>>>>>>>>>>>
69902>>>>>>>>>>>// SQL Server spcific types.
69902>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69902>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69902>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69902>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69902>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69902>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69902>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69902>>>>>>>>>>>//
69902>>>>>>>>>>>//     Setup a constraint for a file.
69902>>>>>>>>>>>
69902>>>>>>>>>>>
69902>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
69903>>>>>>>>>>>    
69903>>>>>>>>>>>    Procedure Construct_Object
69905>>>>>>>>>>>        Forward Send Construct_Object
69907>>>>>>>>>>>        
69907>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
69908>>>>>>>>>>>    End_Procedure
69909>>>>>>>>>>>    
69909>>>>>>>>>>>    
69909>>>>>>>>>>>    
69909>>>>>>>>>>>    //   Extract the list from the out connect string.
69909>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69911>>>>>>>>>>>        String  sItem
69911>>>>>>>>>>>        Integer iStart
69911>>>>>>>>>>>        Integer iEnd
69911>>>>>>>>>>>        
69911>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69914>>>>>>>>>>>        
69914>>>>>>>>>>>        Send Delete_Data to hoStore
69915>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69916>>>>>>>>>>>        While (iStart > 0)
69920>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69921>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69924>>>>>>>>>>>            Else Begin
69925>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69926>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69927>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69930>>>>>>>>>>>                
69930>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69933>>>>>>>>>>>                
69933>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69936>>>>>>>>>>>            End
69936>>>>>>>>>>>>
69936>>>>>>>>>>>        Loop
69937>>>>>>>>>>>>
69937>>>>>>>>>>>        
69937>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
69938>>>>>>>>>>>    End_Function
69939>>>>>>>>>>>    
69939>>>>>>>>>>>    
69939>>>>>>>>>>>    
69939>>>>>>>>>>>    //   Call the driver's browse connect function
69939>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
69941>>>>>>>>>>>        String  sDriver
69941>>>>>>>>>>>        String  sOutConnStr
69941>>>>>>>>>>>        Integer iArg
69941>>>>>>>>>>>        Integer iRetval
69941>>>>>>>>>>>        
69941>>>>>>>>>>>        Get psDriverID to sDriver
69942>>>>>>>>>>>        If (sDriver <> "") Begin
69944>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69945>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69950>>>>>>>>>>>        End
69950>>>>>>>>>>>>
69950>>>>>>>>>>>        
69950>>>>>>>>>>>        Function_Return sOutConnStr
69951>>>>>>>>>>>    End_Function// BrowseConnect
69952>>>>>>>>>>>    
69952>>>>>>>>>>>    
69952>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
69954>>>>>>>>>>>        String  sDriver
69954>>>>>>>>>>>        String  sOutConnStr
69954>>>>>>>>>>>        Integer iArg
69954>>>>>>>>>>>        Integer iRetval
69954>>>>>>>>>>>        
69954>>>>>>>>>>>        Move 1 to iArg // Browses only local
69955>>>>>>>>>>>        
69955>>>>>>>>>>>        Get psDriverID to sDriver
69956>>>>>>>>>>>        If (sDriver <> "") Begin
69958>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69959>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69964>>>>>>>>>>>        End
69964>>>>>>>>>>>>
69964>>>>>>>>>>>        
69964>>>>>>>>>>>        Function_Return sOutConnStr
69965>>>>>>>>>>>    End_Function// BrowseConnect
69966>>>>>>>>>>>    
69966>>>>>>>>>>>    
69966>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
69968>>>>>>>>>>>        
69968>>>>>>>>>>>        String  sServerList
69968>>>>>>>>>>>        Integer iNumServers
69968>>>>>>>>>>>        Integer iDriver
69968>>>>>>>>>>>        Integer iClientVersion
69968>>>>>>>>>>>        String  sDriver
69968>>>>>>>>>>>        
69968>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
69969>>>>>>>>>>>        
69969>>>>>>>>>>>        If (iDriver) Begin
69971>>>>>>>>>>>            
69971>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
69974>>>>>>>>>>>            
69974>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
69975>>>>>>>>>>>            
69975>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
69976>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
69978>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
69979>>>>>>>>>>>            End
69979>>>>>>>>>>>>
69979>>>>>>>>>>>            Else Begin
69980>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
69981>>>>>>>>>>>            End
69981>>>>>>>>>>>>
69981>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
69982>>>>>>>>>>>        End
69982>>>>>>>>>>>>
69982>>>>>>>>>>>        
69982>>>>>>>>>>>        Function_Return iNumServers
69983>>>>>>>>>>>        
69983>>>>>>>>>>>    End_Function
69984>>>>>>>>>>>    
69984>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
69984>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
69984>>>>>>>>>>>    //   This may take a long time.
69984>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
69984>>>>>>>>>>>    Function EnumerateServers Returns Integer
69986>>>>>>>>>>>        
69986>>>>>>>>>>>        Integer iNumServers
69986>>>>>>>>>>>        Integer iNetworkLocal
69986>>>>>>>>>>>        
69986>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
69987>>>>>>>>>>>        
69987>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69988>>>>>>>>>>>        
69988>>>>>>>>>>>        Function_Return iNumServers
69989>>>>>>>>>>>        
69989>>>>>>>>>>>    End_Function
69990>>>>>>>>>>>    
69990>>>>>>>>>>>    
69990>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
69990>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
69990>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
69990>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
69992>>>>>>>>>>>        
69992>>>>>>>>>>>        Integer iNumServers
69992>>>>>>>>>>>        Integer iNetworkLocal
69992>>>>>>>>>>>        
69992>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
69993>>>>>>>>>>>        
69993>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69994>>>>>>>>>>>        
69994>>>>>>>>>>>        Function_Return iNumServers
69995>>>>>>>>>>>        
69995>>>>>>>>>>>    End_Function
69996>>>>>>>>>>>    
69996>>>>>>>>>>>    
69996>>>>>>>>>>>    
69996>>>>>>>>>>>    //   Enumerate database in a given server.
69996>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
69998>>>>>>>>>>>        Integer hoSQL
69998>>>>>>>>>>>        String  sConnect
69998>>>>>>>>>>>        String  sDatabase
69998>>>>>>>>>>>        Integer hdbc
69998>>>>>>>>>>>        Integer hstmt
69998>>>>>>>>>>>        Integer iFetchResult
69998>>>>>>>>>>>        
69998>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70001>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70004>>>>>>>>>>>        
70004>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70007>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70009>>>>>>>>>>>        
70009>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70011>>>>>>>>>>>            Move Current_Object to hoSQL
70012>>>>>>>>>>>        End_Object
70013>>>>>>>>>>>        
70013>>>>>>>>>>>        If (hoSQL <> 0) Begin
70015>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70016>>>>>>>>>>>            If (hdbc <> 0) Begin
70018>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
70019>>>>>>>>>>>                If (hstmt <> 0) Begin
70021>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70021>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70021>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70021>>>>>>>>>>>                    //   stay the same.
70021>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70022>>>>>>>>>>>                    Send SQLCall to hstmt
70023>>>>>>>>>>>                    Repeat
70023>>>>>>>>>>>>
70023>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70024>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
70026>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70027>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70028>>>>>>>>>>>                        End
70028>>>>>>>>>>>>
70028>>>>>>>>>>>                    Until (iFetchResult = 0)
70030>>>>>>>>>>>                    
70030>>>>>>>>>>>                    Send SQLClose to hstmt
70031>>>>>>>>>>>                End
70031>>>>>>>>>>>>
70031>>>>>>>>>>>                Send SQLDisconnect to hdbc
70032>>>>>>>>>>>            End
70032>>>>>>>>>>>>
70032>>>>>>>>>>>        End
70032>>>>>>>>>>>>
70032>>>>>>>>>>>        Send Destroy_Object to hoSQL
70033>>>>>>>>>>>        
70033>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
70034>>>>>>>>>>>    End_Function
70035>>>>>>>>>>>    
70035>>>>>>>>>>>    
70035>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70037>>>>>>>>>>>        
70037>>>>>>>>>>>        String  sSqlServerClientVersionName
70037>>>>>>>>>>>        
70037>>>>>>>>>>>        
70037>>>>>>>>>>>        Case Begin
70037>>>>>>>>>>>            
70037>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70039>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70040>>>>>>>>>>>                Case Break
70041>>>>>>>>>>>                
70041>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70044>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70045>>>>>>>>>>>                Case Break
70046>>>>>>>>>>>            
70046>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70049>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70050>>>>>>>>>>>                Case Break
70051>>>>>>>>>>>            
70051>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70054>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70055>>>>>>>>>>>                Case Break
70056>>>>>>>>>>>            
70056>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70059>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70060>>>>>>>>>>>                Case Break
70061>>>>>>>>>>>            
70061>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70064>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70065>>>>>>>>>>>                Case Break
70066>>>>>>>>>>>            
70066>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70069>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70070>>>>>>>>>>>                Case Break
70071>>>>>>>>>>>            
70071>>>>>>>>>>>            Case Else
70071>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70072>>>>>>>>>>>                
70072>>>>>>>>>>>        Case End
70072>>>>>>>>>>>        
70072>>>>>>>>>>>        
70072>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
70073>>>>>>>>>>>        
70073>>>>>>>>>>>    End_Function
70074>>>>>>>>>>>
70074>>>>>>>>>>>
70074>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70076>>>>>>>>>>>        
70076>>>>>>>>>>>        String  sSqlServerClientDriverName
70076>>>>>>>>>>>        
70076>>>>>>>>>>>        Case Begin
70076>>>>>>>>>>>            
70076>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70078>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70079>>>>>>>>>>>                Case Break
70080>>>>>>>>>>>                
70080>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70083>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70084>>>>>>>>>>>                Case Break
70085>>>>>>>>>>>            
70085>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70088>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70089>>>>>>>>>>>                Case Break
70090>>>>>>>>>>>            
70090>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70093>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70094>>>>>>>>>>>                Case Break
70095>>>>>>>>>>>            
70095>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70098>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70099>>>>>>>>>>>                Case Break
70100>>>>>>>>>>>            
70100>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70103>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70104>>>>>>>>>>>                Case Break
70105>>>>>>>>>>>            
70105>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70108>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70109>>>>>>>>>>>                Case Break
70110>>>>>>>>>>>            
70110>>>>>>>>>>>            Case Else
70110>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70111>>>>>>>>>>>                
70111>>>>>>>>>>>        Case End
70111>>>>>>>>>>>        
70111>>>>>>>>>>>        
70111>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
70112>>>>>>>>>>>        
70112>>>>>>>>>>>    End_Function
70113>>>>>>>>>>>    
70113>>>>>>>>>>>    
70113>>>>>>>>>>>End_Class
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
70114>>>>>>>>>>>// DB2_DRV.PKG                                                          
70114>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
70114>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
70114>>>>>>>>>>>//   specific code to a DataFlex application.                           
70114>>>>>>>>>>>
70114>>>>>>>>>>>Use Cli.pkg
70114>>>>>>>>>>>
70114>>>>>>>>>>>// Driver attributes
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>>>// Driver Indentification
70114>>>>>>>>>>>
70114>>>>>>>>>>>// Error number constants
70114>>>>>>>>>>>
70114>>>>>>>>>>>// Call driver function identifiers
70114>>>>>>>>>>>
70114>>>>>>>>>>>// DB2 specific data types
70114>>>>>>>>>>>Define SQL_CLOB           for   (-99)
70114>>>>>>>>>>>Define SQL_BLOB           for   (-98)
70114>>>>>>>>>>>Define SQL_XML            for   (-370)
70114>>>>>>>>>>>// DB2 Graphic types are Unicode types
70114>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
70114>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
70114>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
70114>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>>>// Extra DB2 commands
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
70114>>>>>>>>>>>//   Setup a constraint for a file.                                     
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>>>
70114>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
70115>>>>>>>>>>>    
70115>>>>>>>>>>>    Procedure Construct_Object
70117>>>>>>>>>>>        Forward Send Construct_Object
70119>>>>>>>>>>>        
70119>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
70120>>>>>>>>>>>    End_Procedure
70121>>>>>>>>>>>    
70121>>>>>>>>>>>    
70121>>>>>>>>>>>    
70121>>>>>>>>>>>    // Reset the datasource list to the beginning
70121>>>>>>>>>>>    Procedure SeedDataSources
70123>>>>>>>>>>>        String  sDriver
70123>>>>>>>>>>>        String  sVoid
70123>>>>>>>>>>>        Integer iRetval
70123>>>>>>>>>>>        
70123>>>>>>>>>>>        Get psDriverID to sDriver
70124>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
70131>>>>>>>>>>>    End_Procedure
70132>>>>>>>>>>>    
70132>>>>>>>>>>>    
70132>>>>>>>>>>>    
70132>>>>>>>>>>>    // Call the driver's data sources function
70132>>>>>>>>>>>    Function DataSources Returns String
70134>>>>>>>>>>>        String  sDriver
70134>>>>>>>>>>>        String  sDataSource
70134>>>>>>>>>>>        String  sDescription
70134>>>>>>>>>>>        Integer iLength
70134>>>>>>>>>>>        Integer iRetval
70134>>>>>>>>>>>        
70134>>>>>>>>>>>        Get psDriverID to sDriver
70135>>>>>>>>>>>        If (sDriver <> "") Begin
70137>>>>>>>>>>>            Move 8192 to iLength
70138>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
70139>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
70140>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
70145>>>>>>>>>>>        End
70145>>>>>>>>>>>>
70145>>>>>>>>>>>        
70145>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
70148>>>>>>>>>>>        Else ;            Function_Return ""
70150>>>>>>>>>>>    End_Function
70151>>>>>>>>>>>    
70151>>>>>>>>>>>End_Class
70152>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
70152>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
70152>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
70152>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
70152>>>>>>>>>>>
70152>>>>>>>>>>>Use Cli.pkg
70152>>>>>>>>>>>
70152>>>>>>>>>>>// Driver Indentification
70152>>>>>>>>>>>
70152>>>>>>>>>>>// Error number constants
70152>>>>>>>>>>>
70152>>>>>>>>>>>// Call driver function identifiers
70152>>>>>>>>>>>
70152>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
70153>>>>>>>>>>>    
70153>>>>>>>>>>>    Procedure Construct_Object
70155>>>>>>>>>>>        Forward Send Construct_Object
70157>>>>>>>>>>>        
70157>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
70158>>>>>>>>>>>    End_Procedure
70159>>>>>>>>>>>    
70159>>>>>>>>>>>    
70159>>>>>>>>>>>    
70159>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
70159>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
70161>>>>>>>>>>>        String  sDriver
70161>>>>>>>>>>>        String  sVoid
70161>>>>>>>>>>>        Integer iRetval
70161>>>>>>>>>>>        
70161>>>>>>>>>>>        Get psDriverID to sDriver
70162>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
70169>>>>>>>>>>>    End_Procedure
70170>>>>>>>>>>>    
70170>>>>>>>>>>>    
70170>>>>>>>>>>>    // Call the driver's data sources function
70170>>>>>>>>>>>    Function DataSources Returns String
70172>>>>>>>>>>>        String  sDriver
70172>>>>>>>>>>>        String  sDataSource
70172>>>>>>>>>>>        String  sDescription
70172>>>>>>>>>>>        Integer iLength
70172>>>>>>>>>>>        Integer iRetval
70172>>>>>>>>>>>        
70172>>>>>>>>>>>        Get psDriverID to sDriver
70173>>>>>>>>>>>        If (sDriver <> "") Begin
70175>>>>>>>>>>>            Move 8192 to iLength
70176>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
70177>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
70178>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
70183>>>>>>>>>>>        End
70183>>>>>>>>>>>>
70183>>>>>>>>>>>        
70183>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
70186>>>>>>>>>>>        Else ;            Function_Return ""
70188>>>>>>>>>>>    End_Function
70189>>>>>>>>>>>    
70189>>>>>>>>>>>End_Class
70190>>>>>>>>>>>
70190>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
70190>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
70190>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
70190>>>>>>>>>>>//               specific functions in the DFBTRDRV.
70190>>>>>>>>>>>Use Ui
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Driver Indentification
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>// Driver attributes
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Call_Driver functions ID's
70190>>>>>>>>>>>//
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// DFBTRFN_SET_OWNER options
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to create all vars which may be needed
70190>>>>>>>>>>>// in other commands.
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to set the owner of a Btrieve file.
70190>>>>>>>>>>>// File must have been opened.
70190>>>>>>>>>>>// Filenumber needs to be passed.
70190>>>>>>>>>>>// To clear set the owner to "".
70190>>>>>>>>>>>// Examples:
70190>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
70190>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
70190>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
70190>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
70190>>>>>>>>>>>// To clear:
70190>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
70190>>>>>>>>>>>// options.
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to parse for Callback
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
70190>>>>>>>>>>>// File must have been opened.
70190>>>>>>>>>>>// Filenumber needs to be passed.
70190>>>>>>>>>>>// Examples:
70190>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
70190>>>>>>>>>>>// which will be tries when opening files.
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
70190>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
70190>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
70190>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to change the transaction type.
70190>>>>>>>>>>>// Valid types are:
70190>>>>>>>>>>>//     DFBTRTT_NONE
70190>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
70190>>>>>>>>>>>//     DFBTRTT_CONCURRENT
70190>>>>>>>>>>>//
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to get the current transaction type.
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to set explicit_locking
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to get explicit locking
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>//
70190>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
70190>>>>>>>>>>>//
70190>>>>>>>>>>>
70190>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
70190>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
70190>>>>>>>>>>>
70190>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
70191>>>>>>>>>>>    
70191>>>>>>>>>>>    Procedure Construct_Object Integer iImage
70193>>>>>>>>>>>        Forward Send Construct_object iImage
70195>>>>>>>>>>>        
70195>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
70196>>>>>>>>>>>    End_Procedure
70197>>>>>>>>>>>    
70197>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
70197>>>>>>>>>>>    //
70197>>>>>>>>>>>    
70197>>>>>>>>>>>    Function CKRevision Returns String
70199>>>>>>>>>>>        String  sDriverID
70199>>>>>>>>>>>        String  sRevision
70199>>>>>>>>>>>        String  sVoid
70199>>>>>>>>>>>        Integer iRetval
70199>>>>>>>>>>>        
70199>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70199>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70199>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70199>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70200>>>>>>>>>>>        Get psDriverID to sDriverID
70201>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
70202>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
70207>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70208>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
70210>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70210>>>>>>>>>>>            Move "0.0.0.0" to sRevision
70211>>>>>>>>>>>        End
70211>>>>>>>>>>>>
70211>>>>>>>>>>>        Function_Return sRevision
70212>>>>>>>>>>>    End_Function
70213>>>>>>>>>>>    
70213>>>>>>>>>>>    Function CkUsesUri Returns Integer
70215>>>>>>>>>>>        String  sDriverID
70215>>>>>>>>>>>        String  sVoid1
70215>>>>>>>>>>>        String  sVoid2
70215>>>>>>>>>>>        Integer iRetval
70215>>>>>>>>>>>        
70215>>>>>>>>>>>        Get psDriverID to sDriverID
70216>>>>>>>>>>>        
70216>>>>>>>>>>>        Move 0 to iRetval
70217>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70217>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70217>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
70217>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70218>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
70223>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70224>>>>>>>>>>>        
70224>>>>>>>>>>>        Function_Return iRetval
70225>>>>>>>>>>>    End_Function
70226>>>>>>>>>>>    
70226>>>>>>>>>>>    
70226>>>>>>>>>>>    
70226>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
70226>>>>>>>>>>>    //
70226>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
70226>>>>>>>>>>>    //
70226>>>>>>>>>>>    
70226>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
70228>>>>>>>>>>>        Integer iPartRev
70228>>>>>>>>>>>        Integer iCurrentPart
70228>>>>>>>>>>>        Integer iSeparatorPos
70228>>>>>>>>>>>        
70228>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
70231>>>>>>>>>>>        
70231>>>>>>>>>>>        Move 0 to iCurrentPart
70232>>>>>>>>>>>        Repeat
70232>>>>>>>>>>>>
70232>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
70233>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
70235>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
70236>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
70237>>>>>>>>>>>                Increment iCurrentPart
70238>>>>>>>>>>>            End
70238>>>>>>>>>>>>
70238>>>>>>>>>>>            Else If (sRevision <> "") Begin
70241>>>>>>>>>>>                Move sRevision to iPartRev
70242>>>>>>>>>>>                Move "" to sRevision
70243>>>>>>>>>>>                Increment iCurrentPart
70244>>>>>>>>>>>            End
70244>>>>>>>>>>>>
70244>>>>>>>>>>>            Else ;                Move -1 to iPartRev
70246>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
70248>>>>>>>>>>>        
70248>>>>>>>>>>>        Function_Return iPartRev
70249>>>>>>>>>>>    End_Function
70250>>>>>>>>>>>    
70250>>>>>>>>>>>    
70250>>>>>>>>>>>    
70250>>>>>>>>>>>    //
70250>>>>>>>>>>>    //  Returns the major revision of the CK
70250>>>>>>>>>>>    //
70250>>>>>>>>>>>    
70250>>>>>>>>>>>    Function CKMajorRevision Returns Integer
70252>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
70253>>>>>>>>>>>    End_Function
70254>>>>>>>>>>>    
70254>>>>>>>>>>>    
70254>>>>>>>>>>>    
70254>>>>>>>>>>>    //  Returns the minor revision of the CK
70254>>>>>>>>>>>    //
70254>>>>>>>>>>>    
70254>>>>>>>>>>>    Function CKMinorRevision Returns Integer
70256>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
70257>>>>>>>>>>>    End_Function
70258>>>>>>>>>>>    
70258>>>>>>>>>>>    
70258>>>>>>>>>>>    //  Returns the release revision of the CK
70258>>>>>>>>>>>    //
70258>>>>>>>>>>>    
70258>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
70260>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
70261>>>>>>>>>>>    End_Function
70262>>>>>>>>>>>    
70262>>>>>>>>>>>    
70262>>>>>>>>>>>    //  Returns the major revision of the CK
70262>>>>>>>>>>>    //
70262>>>>>>>>>>>    
70262>>>>>>>>>>>    Function CKBuildRevision Returns Integer
70264>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
70265>>>>>>>>>>>    End_Function
70266>>>>>>>>>>>    
70266>>>>>>>>>>>    
70266>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
70266>>>>>>>>>>>    //
70266>>>>>>>>>>>    
70266>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
70268>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
70271>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
70274>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
70277>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
70280>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
70283>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
70287>>>>>>>>>>>            End
70287>>>>>>>>>>>>
70287>>>>>>>>>>>        End
70287>>>>>>>>>>>>
70287>>>>>>>>>>>        
70287>>>>>>>>>>>        Function_Return (False)
70288>>>>>>>>>>>    End_Function
70289>>>>>>>>>>>    
70289>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
70289>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
70289>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
70289>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
70289>>>>>>>>>>>    //
70289>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
70289>>>>>>>>>>>    //   in the following format:
70289>>>>>>>>>>>    //       <version>.<revision>.<type>
70289>>>>>>>>>>>    //   possible values for <type>:
70289>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
70289>>>>>>>>>>>    //         server using Workgroup authentication mode
70289>>>>>>>>>>>    //       C for client cache engine
70289>>>>>>>>>>>    //       D for DOS workstation
70289>>>>>>>>>>>    //       N for client Requester
70289>>>>>>>>>>>    //       S for NetWare server
70289>>>>>>>>>>>    //       T for 32-bit Windows server engine
70289>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
70289>>>>>>>>>>>    //
70289>>>>>>>>>>>    //   example:
70289>>>>>>>>>>>    //       8.50.T
70289>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
70289>>>>>>>>>>>    //   32-bits Windows server.
70289>>>>>>>>>>>    //
70289>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
70289>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
70289>>>>>>>>>>>    //
70289>>>>>>>>>>>    //   If the version information is not available or can not be obtained
70289>>>>>>>>>>>    //   the functions will return "0.0.0"
70289>>>>>>>>>>>    
70289>>>>>>>>>>>    //  Returns the version information of the
70289>>>>>>>>>>>    //           Pervasive.SQL Client requester.
70289>>>>>>>>>>>    
70289>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
70291>>>>>>>>>>>        
70291>>>>>>>>>>>        String  sDriverID
70291>>>>>>>>>>>        String  sVersion
70291>>>>>>>>>>>        String  sVoid
70291>>>>>>>>>>>        Integer iRetval
70291>>>>>>>>>>>        
70291>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70291>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70291>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70291>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70292>>>>>>>>>>>        Get psDriverID to sDriverID
70293>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70294>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70299>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70300>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70302>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70302>>>>>>>>>>>            Move "0.0.0" to sVersion
70303>>>>>>>>>>>        End
70303>>>>>>>>>>>>
70303>>>>>>>>>>>        Function_Return sVersion
70304>>>>>>>>>>>    End_Function
70305>>>>>>>>>>>    
70305>>>>>>>>>>>    //           Pervasive.SQL Engine
70305>>>>>>>>>>>    
70305>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
70307>>>>>>>>>>>        
70307>>>>>>>>>>>        String  sDriverID
70307>>>>>>>>>>>        String  sVersion
70307>>>>>>>>>>>        String  sVoid
70307>>>>>>>>>>>        Integer iRetval
70307>>>>>>>>>>>        
70307>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70307>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70307>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70307>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70308>>>>>>>>>>>        Get psDriverID to sDriverID
70309>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70310>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70315>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70316>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70318>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70318>>>>>>>>>>>            Move "0.0.0" to sVersion
70319>>>>>>>>>>>        End
70319>>>>>>>>>>>>
70319>>>>>>>>>>>        Function_Return sVersion
70320>>>>>>>>>>>    End_Function
70321>>>>>>>>>>>    
70321>>>>>>>>>>>    //  Returns the version information of the
70321>>>>>>>>>>>    //           Pervasive.SQL Server Engine
70321>>>>>>>>>>>    
70321>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
70323>>>>>>>>>>>        
70323>>>>>>>>>>>        String  sDriverID
70323>>>>>>>>>>>        String  sVersion
70323>>>>>>>>>>>        String  sVoid
70323>>>>>>>>>>>        Integer iRetval
70323>>>>>>>>>>>        
70323>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70323>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70323>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70323>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70324>>>>>>>>>>>        Get psDriverID to sDriverID
70325>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70326>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70331>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70332>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70334>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70334>>>>>>>>>>>            Move "0.0.0" to sVersion
70335>>>>>>>>>>>        End
70335>>>>>>>>>>>>
70335>>>>>>>>>>>        Function_Return sVersion
70336>>>>>>>>>>>    End_Function
70337>>>>>>>>>>>    
70337>>>>>>>>>>>End_Class
70338>>>>>>>>>>>
70338>>>>>>>>>>>
70338>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
70338>>>>>>>>>>>//****************************************************************************
70338>>>>>>>>>>>// $Module type: Include file
70338>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
70338>>>>>>>>>>>//
70338>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
70338>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
70338>>>>>>>>>>>// E-mail      : support@rdctools.com
70338>>>>>>>>>>>// Web-site    : http://www.rdctools.com
70338>>>>>>>>>>>//
70338>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
70338>>>>>>>>>>>//
70338>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
70338>>>>>>>>>>>//
70338>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70338>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70338>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70338>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70338>>>>>>>>>>>// in the help folder for more details.
70338>>>>>>>>>>>//
70338>>>>>>>>>>>Use Winkern.pkg
70338>>>>>>>>>>>Use cIniFile.pkg
70338>>>>>>>>>>>    Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
70338>>>>>>>>>>>>>Use VdfBase.pkg
70338>>>>>>>>>>>>>
70338>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
70338>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
70338>>>>>>>>>>>>>>>// Algorithm classes
70338>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
70338>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Algorithm types
70338>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
70338>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Generic sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// RSA sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
70338>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
70338>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
70338>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// DSS sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
70338>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// DES sub_ids
70338>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
70338>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
70338>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
70338>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
70338>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
70338>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
70338>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
70338>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
70338>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
70338>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
70338>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
70338>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
70338>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Fortezza sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
70338>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// RC2 sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Stream cipher sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
70338>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
70338>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
70338>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Hash sub ids
70338>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
70338>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
70338>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
70338>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
70338>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
70338>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
70338>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
70338>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
70338>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
70338>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
70338>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
70338>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
70338>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
70338>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// secure channel sub ids
70338>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
70338>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
70338>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
70338>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
70338>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
70338>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
70338>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// algorithm identifier definitions
70338>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
70338>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
70338>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
70338>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
70338>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
70338>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
70338>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
70338>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
70338>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
70338>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
70338>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
70338>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
70338>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
70338>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
70338>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
70338>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
70338>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
70338>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
70338>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
70338>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
70338>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
70338>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
70338>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
70338>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
70338>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
70338>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
70338>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
70338>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
70338>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
70338>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
70338>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
70338>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
70338>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
70338>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
70338>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
70338>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
70338>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
70338>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
70338>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
70338>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
70338>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
70338>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
70338>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
70338>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Providers
70338>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
70338>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
70338>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
70338>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
70338>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
70338>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
70338>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
70338>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
70338>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
70338>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
70338>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
70338>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
70338>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
70338>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
70338>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
70338>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
70338>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
70338>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
70338>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
70338>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
70338>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
70338>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
70338>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
70338>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
70338>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
70338>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// Provider types
70338>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
70338>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
70338>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
70338>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
70338>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
70338>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
70338>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
70338>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
70338>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
70338>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
70338>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
70338>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
70338>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
70338>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
70338>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
70338>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
70338>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
70338>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// KP_MODE
70338>>>>>>>>>>>>>>>// KP_MODE
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
70338>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
70338>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
70338>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
70338>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
70338>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
70338>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
70338>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
70338>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
70338>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
70338>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
70338>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
70338>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
70338>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
70338>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
70338>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
70338>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
70338>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
70338>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
70338>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
70338>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
70338>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
70338>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
70338>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
70338>>>>>>>>>>>>>>>Define KP_RP                            for 23
70338>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
70338>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
70338>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
70338>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
70338>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
70338>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
70338>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
70338>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
70338>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
70338>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
70338>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
70338>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
70338>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
70338>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
70338>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
70338>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
70338>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
70338>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
70338>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
70338>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
70338>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
70338>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
70338>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>// key BLOB types
70338>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
70338>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
70338>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
70338>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
70338>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
70338>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
70338>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
70338>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>//  Structure cryptimportkey
70338>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
70338>>>>>>>>>>>>>>>    UChar    bType
70338>>>>>>>>>>>>>>>    UChar    bVersion
70338>>>>>>>>>>>>>>>    UShort   reserved
70338>>>>>>>>>>>>>>>    UInteger aiKeyAlg
70338>>>>>>>>>>>>>>>End_Struct
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
70338>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
70338>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
70338>>>>>>>>>>>>>>>    UInteger       dwKeySize
70338>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
70338>>>>>>>>>>>>>>>End_Struct
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
70338>>>>>>>>>>>>>>>Struct HMAC_INFO
70338>>>>>>>>>>>>>>>    UInteger HashAlgid
70338>>>>>>>>>>>>>>>    Pointer pbInnerString
70338>>>>>>>>>>>>>>>    DWord cbInnerString
70338>>>>>>>>>>>>>>>    Pointer pbOuterString
70338>>>>>>>>>>>>>>>    DWord cbOuterString
70338>>>>>>>>>>>>>>>End_Struct
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>
70338>>>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
70339>>>>>>>>>>>>>>>
70339>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
70340>>>>>>>>>>>>>>>
70340>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
70341>>>>>>>>>>>>>>>
70341>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
70342>>>>>>>>>>>>>>>
70342>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
70343>>>>>>>>>>>>>>>
70343>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
70344>>>>>>>>>>>>>>>
70344>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
70345>>>>>>>>>>>>>>>
70345>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
70346>>>>>>>>>>>>>>>
70346>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
70347>>>>>>>>>>>>>>>
70347>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
70348>>>>>>>>>>>>>>>    
70348>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
70349>>>>>>>>>>>>>>>
70349>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
70350>>>>>>>>>>>>>>>
70350>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
70351>>>>>>>>>>>>>>>
70351>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
70352>>>>>>>>>>>>>>>    
70352>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
70353>>>>>>>>>>>>>>>    
70353>>>>>>>>>>>>>
70353>>>>>>>>>>>>>Class cCryptographer is a cObject
70354>>>>>>>>>>>>>    
70354>>>>>>>>>>>>>    Procedure Construct_Object
70356>>>>>>>>>>>>>        Forward Send Construct_Object
70358>>>>>>>>>>>>>        
70358>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
70359>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
70360>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
70361>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
70362>>>>>>>>>>>>>        
70362>>>>>>>>>>>>>        // Private properties
70362>>>>>>>>>>>>>        Property Handle     Private_phProv
70363>>>>>>>>>>>>>    End_Procedure
70364>>>>>>>>>>>>>    
70364>>>>>>>>>>>>>    
70364>>>>>>>>>>>>>    // Acquire key container handle
70364>>>>>>>>>>>>>    Function AcquireContext Returns Handle
70366>>>>>>>>>>>>>        Integer iProvider
70366>>>>>>>>>>>>>        String sProvider
70366>>>>>>>>>>>>>        Handle hProv
70366>>>>>>>>>>>>>        Boolean bOk
70366>>>>>>>>>>>>>        Address addrProv
70366>>>>>>>>>>>>>        
70366>>>>>>>>>>>>>        Move 0 to hProv
70367>>>>>>>>>>>>>        Get piProvider to iProvider
70368>>>>>>>>>>>>>        Get psProvider to sProvider
70369>>>>>>>>>>>>>        
70369>>>>>>>>>>>>>        //  Determine address to be passed as provider
70369>>>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
70371>>>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
70372>>>>>>>>>>>>>        End
70372>>>>>>>>>>>>>>
70372>>>>>>>>>>>>>        Else Begin
70373>>>>>>>>>>>>>            Move 0 to addrProv
70374>>>>>>>>>>>>>        End
70374>>>>>>>>>>>>>>
70374>>>>>>>>>>>>>        
70374>>>>>>>>>>>>>        //  Acquire Crypto Context
70374>>>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
70375>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
70377>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
70378>>>>>>>>>>>>>        End
70378>>>>>>>>>>>>>>
70378>>>>>>>>>>>>>        
70378>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
70380>>>>>>>>>>>>>            // Fallback to original
70380>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
70381>>>>>>>>>>>>>            
70381>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
70383>>>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
70384>>>>>>>>>>>>>            End
70384>>>>>>>>>>>>>>
70384>>>>>>>>>>>>>        End
70384>>>>>>>>>>>>>>
70384>>>>>>>>>>>>>        Set Private_phProv to hProv
70385>>>>>>>>>>>>>        
70385>>>>>>>>>>>>>        Function_Return hProv
70386>>>>>>>>>>>>>    End_Function
70387>>>>>>>>>>>>>    
70387>>>>>>>>>>>>>    // Releases key container handle
70387>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
70389>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
70390>>>>>>>>>>>>>    End_Function
70391>>>>>>>>>>>>>    
70391>>>>>>>>>>>>>    // Creates hash object
70391>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
70393>>>>>>>>>>>>>        Integer iAlgorithm
70393>>>>>>>>>>>>>        Handle hHash
70393>>>>>>>>>>>>>        Boolean bOk
70393>>>>>>>>>>>>>        
70393>>>>>>>>>>>>>        Move 0 to hHash
70394>>>>>>>>>>>>>        Get piHash to iAlgorithm
70395>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
70396>>>>>>>>>>>>>        
70396>>>>>>>>>>>>>        Function_Return hHash
70397>>>>>>>>>>>>>    End_Function
70398>>>>>>>>>>>>>    
70398>>>>>>>>>>>>>    // Destroys the hash object
70398>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
70400>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
70401>>>>>>>>>>>>>    End_Function
70402>>>>>>>>>>>>>    
70402>>>>>>>>>>>>>    // Adds data to hash object
70402>>>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
70404>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
70405>>>>>>>>>>>>>    End_Function
70406>>>>>>>>>>>>>    
70406>>>>>>>>>>>>>    // Generates session key
70406>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
70408>>>>>>>>>>>>>        Integer iAlgorithm
70408>>>>>>>>>>>>>        Handle hKey
70408>>>>>>>>>>>>>        Boolean bOk
70408>>>>>>>>>>>>>        
70408>>>>>>>>>>>>>        Move 0 to hKey
70409>>>>>>>>>>>>>        Get piCipher to iAlgorithm
70410>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
70411>>>>>>>>>>>>>        
70411>>>>>>>>>>>>>        Function_Return hKey
70412>>>>>>>>>>>>>    End_Function
70413>>>>>>>>>>>>>    
70413>>>>>>>>>>>>>    // Imports a plain text key
70413>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
70415>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
70415>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
70415>>>>>>>>>>>>>        Boolean   bSuccess
70415>>>>>>>>>>>>>        Handle    hKey
70415>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
70415>>>>>>>>>>>>>        UChar[]   ucaKeyblob
70416>>>>>>>>>>>>>        Integer iVoid
70416>>>>>>>>>>>>>        
70416>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
70417>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
70418>>>>>>>>>>>>>        
70418>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
70419>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
70420>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
70421>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
70422>>>>>>>>>>>>>        
70422>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
70423>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
70424>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
70425>>>>>>>>>>>>>        
70425>>>>>>>>>>>>>        Move 0 to hKey
70426>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
70427>>>>>>>>>>>>>        If (not(bSuccess)) Begin
70429>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
70430>>>>>>>>>>>>>        End
70430>>>>>>>>>>>>>>
70430>>>>>>>>>>>>>        
70430>>>>>>>>>>>>>        Function_Return hKey
70431>>>>>>>>>>>>>    End_Function
70432>>>>>>>>>>>>>    
70432>>>>>>>>>>>>>    // Destroys the key
70432>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
70434>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
70435>>>>>>>>>>>>>    End_Function
70436>>>>>>>>>>>>>    
70436>>>>>>>>>>>>>    // Retrieves key data
70436>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
70438>>>>>>>>>>>>>        Integer iBuffer iLen
70438>>>>>>>>>>>>>        Boolean bOk
70438>>>>>>>>>>>>>        
70438>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
70439>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
70440>>>>>>>>>>>>>        Function_Return iBuffer
70441>>>>>>>>>>>>>    End_Function
70442>>>>>>>>>>>>>    
70442>>>>>>>>>>>>>    // Retrieves a hash value
70442>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
70444>>>>>>>>>>>>>        String  lsHash
70444>>>>>>>>>>>>>        Integer liResult
70444>>>>>>>>>>>>>        DWord   dwDataLen
70444>>>>>>>>>>>>>        
70444>>>>>>>>>>>>>        Move 0 to dwDataLen
70445>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
70446>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
70449>>>>>>>>>>>>>        
70449>>>>>>>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
70450>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
70451>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
70454>>>>>>>>>>>>>        
70454>>>>>>>>>>>>>        Function_Return lsHash
70455>>>>>>>>>>>>>    End_Function
70456>>>>>>>>>>>>>
70456>>>>>>>>>>>>>    // Encrypts data
70456>>>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
70458>>>>>>>>>>>>>        Handle hProv hHash hKey
70458>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
70458>>>>>>>>>>>>>        Boolean bOk
70458>>>>>>>>>>>>>        
70458>>>>>>>>>>>>>        Get AcquireContext to hProv
70459>>>>>>>>>>>>>        If (hProv) Begin
70461>>>>>>>>>>>>>            Get CreateHash hProv to hHash
70462>>>>>>>>>>>>>            If (hHash) Begin
70464>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
70465>>>>>>>>>>>>>                If (bOk) Begin
70467>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
70468>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
70469>>>>>>>>>>>>>                End
70469>>>>>>>>>>>>>>
70469>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
70470>>>>>>>>>>>>>            End
70470>>>>>>>>>>>>>>
70470>>>>>>>>>>>>>            
70470>>>>>>>>>>>>>            If (hKey) Begin
70472>>>>>>>>>>>>>                //  First call to determine resulting data size
70472>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
70473>>>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
70474>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
70475>>>>>>>>>>>>>                
70475>>>>>>>>>>>>>                //  Reserve space in string
70475>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
70477>>>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
70478>>>>>>>>>>>>>                End
70478>>>>>>>>>>>>>>
70478>>>>>>>>>>>>>                
70478>>>>>>>>>>>>>                //  Call to really decrypt
70478>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
70479>>>>>>>>>>>>>                //If (not(bOk)) Begin
70479>>>>>>>>>>>>>                //Move "" to sData
70479>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
70479>>>>>>>>>>>>>                //End
70479>>>>>>>>>>>>>                
70479>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
70480>>>>>>>>>>>>>            End 
70480>>>>>>>>>>>>>>
70480>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
70481>>>>>>>>>>>>>        End 
70481>>>>>>>>>>>>>>
70481>>>>>>>>>>>>>        Function_Return sData
70482>>>>>>>>>>>>>    End_Function
70483>>>>>>>>>>>>>    
70483>>>>>>>>>>>>>    // Decrypts data
70483>>>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
70485>>>>>>>>>>>>>        Handle hProv hHash hKey
70485>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
70485>>>>>>>>>>>>>        Boolean bOk
70485>>>>>>>>>>>>>        
70485>>>>>>>>>>>>>        Get AcquireContext to hProv
70486>>>>>>>>>>>>>        If (hProv) Begin
70488>>>>>>>>>>>>>            Get CreateHash hProv to hHash
70489>>>>>>>>>>>>>            If (hHash) Begin
70491>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
70492>>>>>>>>>>>>>                If (bOk) Begin
70494>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
70495>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
70496>>>>>>>>>>>>>                End
70496>>>>>>>>>>>>>>
70496>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
70497>>>>>>>>>>>>>            End
70497>>>>>>>>>>>>>>
70497>>>>>>>>>>>>>            
70497>>>>>>>>>>>>>            If (hKey) Begin
70499>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
70500>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
70501>>>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
70501>>>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
70503>>>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
70504>>>>>>>>>>>>>                End
70504>>>>>>>>>>>>>>
70504>>>>>>>>>>>>>                
70504>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
70505>>>>>>>>>>>>>            End
70505>>>>>>>>>>>>>>
70505>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
70506>>>>>>>>>>>>>        End
70506>>>>>>>>>>>>>>
70506>>>>>>>>>>>>>        Function_Return sData
70507>>>>>>>>>>>>>    End_Function
70508>>>>>>>>>>>>>    
70508>>>>>>>>>>>>>    //  Generates random data.
70508>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
70510>>>>>>>>>>>>>        Handle hProv
70510>>>>>>>>>>>>>        UChar[] uaResult
70511>>>>>>>>>>>>>        Boolean bRes
70511>>>>>>>>>>>>>        
70511>>>>>>>>>>>>>        Get AcquireContext to hProv
70512>>>>>>>>>>>>>        
70512>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
70513>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
70514>>>>>>>>>>>>>        
70514>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
70515>>>>>>>>>>>>>        
70515>>>>>>>>>>>>>        Function_Return uaResult
70516>>>>>>>>>>>>>    End_Function
70517>>>>>>>>>>>>>    
70517>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
70517>>>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
70519>>>>>>>>>>>>>        String sResult
70519>>>>>>>>>>>>>        UChar[] aData
70520>>>>>>>>>>>>>        Address pBase64
70520>>>>>>>>>>>>>        Integer iVoid
70520>>>>>>>>>>>>>        
70520>>>>>>>>>>>>>        Get GenerateRandom iLenght to aData
70521>>>>>>>>>>>>>        
70521>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
70522>>>>>>>>>>>>>        Move pBase64 to sResult
70523>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
70524>>>>>>>>>>>>>        
70524>>>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
70525>>>>>>>>>>>>>    End_Function
70526>>>>>>>>>>>>>    
70526>>>>>>>>>>>>>End_Class
70527>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
70527>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
70527>>>>>>>>>>>>>//>
70527>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
70527>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
70527>>>>>>>>>>>>>//>
70527>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
70527>>>>>>>>>>>>>//> strings.
70527>>>>>>>>>>>>>//>
70527>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
70527>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
70527>>>>>>>>>>>>>//>
70527>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
70527>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
70527>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
70527>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
70527>>>>>>>>>>>>>
70527>>>>>>>>>>>>>Use VdfBase.pkg
70527>>>>>>>>>>>>>
70527>>>>>>>>>>>>>// Functions in vdfBase64.dll
70527>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
70528>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
70529>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
70530>>>>>>>>>>>>>
70530>>>>>>>>>>>>>// Structure
70530>>>>>>>>>>>>>Struct txxfBase64Buffer
70530>>>>>>>>>>>>>    Pointer pData
70530>>>>>>>>>>>>>    Integer iLength
70530>>>>>>>>>>>>>End_Struct 
70530>>>>>>>>>>>>>
70530>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
70530>>>>>>>>>>>>>
70530>>>>>>>>>>>>>Object _oBase64Functions is a cObject
70532>>>>>>>>>>>>>    Move Self to oBase64Functions
70533>>>>>>>>>>>>>
70533>>>>>>>>>>>>>
70533>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
70536>>>>>>>>>>>>>        Address pBase64
70536>>>>>>>>>>>>>        String sResult
70536>>>>>>>>>>>>>        Integer iVoid
70536>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
70537>>>>>>>>>>>>>        Move pBase64 to sResult
70538>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
70539>>>>>>>>>>>>>        Function_Return sResult
70540>>>>>>>>>>>>>    End_Function
70541>>>>>>>>>>>>>
70541>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
70544>>>>>>>>>>>>>        Address pBinary
70544>>>>>>>>>>>>>        String sBinary
70544>>>>>>>>>>>>>        Integer iVoid iLen
70544>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
70545>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
70546>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
70547>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
70548>>>>>>>>>>>>>        Function_Return sBinary
70549>>>>>>>>>>>>>    End_Function
70550>>>>>>>>>>>>>
70550>>>>>>>>>>>>>End_Object
70551>>>>>>>>>>>Use MSSqldrv.pkg
70551>>>>>>>>>>>Use db2_drv.pkg
70551>>>>>>>>>>>Use odbc_drv.pkg
70551>>>>>>>>>>>Use DFBtrDrv.pkg
70551>>>>>>>>>>>Use vWin32fh.pkg
70551>>>>>>>>>>>
70551>>>>>>>>>>>Use DUFLanguageConstants.inc
70551>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
70551>>>>>>>>>>>>>//
70551>>>>>>>>>>>>>// Use of Mertech drivers:
70551>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
70551>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
70551>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
70551>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
70551>>>>>>>>>>>>>// MySQL Data Types
70551>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
70551>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
70551>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
70551>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
70551>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
70551>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
70551>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
70551>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
70551>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
70551>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
70551>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
70551>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
70551>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
70551>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
70551>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
70551>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
70551>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
70551>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
70551>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
70551>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
70551>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
70551>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
70551>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
70551>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
70551>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
70551>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
70551>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
70551>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
70551>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
70551>>>>>>>>>>>>>
70551>>>>>>>>>>>>>// Oracle Data Types
70551>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
70551>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
70551>>>>>>>>>>>>>Define eOracle_INT                                  for   3
70551>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
70551>>>>>>>>>>>>>Define eOracle_STRING                               for   5
70551>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
70551>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
70551>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
70551>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
70551>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
70551>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
70551>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
70551>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
70551>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
70551>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
70551>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
70551>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
70551>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
70551>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
70551>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
70551>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
70551>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
70551>>>>>>>>>>>>>
70551>>>>>>>>>>>>>// PostgreSQL Data Types
70551>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
70551>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
70551>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
70551>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
70551>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
70551>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
70551>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
70551>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
70551>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
70551>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
70551>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
70551>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
70551>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
70551>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
70551>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
70551>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
70551>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
70551>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
70551>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
70551>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
70551>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
70551>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
70551>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
70551>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
70551>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
70551>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
70551>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
70551>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
70551>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
70551>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
70551>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
70551>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
70551>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
70551>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
70551>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
70551>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
70551>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
70551>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
70551>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
70551>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
70551>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
70551>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
70551>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
70551>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
70551>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
70551>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
70551>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
70551>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
70551>>>>>>>>>>>>>
70551>>>>>>>>>>>>>// SQL Server Data Types
70551>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
70551>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
70551>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
70551>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
70551>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
70551>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
70551>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
70551>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
70551>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
70551>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
70551>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
70551>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
70551>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
70551>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
70551>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
70551>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
70551>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
70551>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
70551>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
70551>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
70551>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
70551>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
70551>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
70551>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
70551>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
70551>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
70551>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
70551>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
70551>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
70551>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
70551>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
70551>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
70551>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
70551>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
70551>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
70551>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
70551>>>>>>>>>>>>>
70551>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
70551>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
70551>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
70551>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
70551>>>>>>>>>>>>>>>
70551>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
70551>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSQLScriptArray
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
70552>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
70552>>>>>>>>>>>>>>>    String[] sSQLScriptArray
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSqlErrorArray
70552>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
70552>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
70552>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSqlColumnNew
70552>>>>>>>>>>>>>>>    String  sBaseColumnName
70552>>>>>>>>>>>>>>>    String  sBaseTableName
70552>>>>>>>>>>>>>>>    String  sLabel
70552>>>>>>>>>>>>>>>    Integer iSqlType
70552>>>>>>>>>>>>>>>    Integer iSize
70552>>>>>>>>>>>>>>>    Integer iPrecision
70552>>>>>>>>>>>>>>>    Integer iDFType
70552>>>>>>>>>>>>>>>    Integer iDFNativeType
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tColumnType
70552>>>>>>>>>>>>>>>    String  sSQLType
70552>>>>>>>>>>>>>>>    Integer iSQLType
70552>>>>>>>>>>>>>>>    Boolean bCanEditSize
70552>>>>>>>>>>>>>>>    Integer iDefaultSize
70552>>>>>>>>>>>>>>>    Integer iMinSize
70552>>>>>>>>>>>>>>>    Number  nMaxSize
70552>>>>>>>>>>>>>>>    String  sDataFlexType
70552>>>>>>>>>>>>>>>    Integer iDataFlexType
70552>>>>>>>>>>>>>>>    Boolean bNativeDataType
70552>>>>>>>>>>>>>>>    String  sPrecision
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
70552>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
70552>>>>>>>>>>>>>>>// keywords.
70552>>>>>>>>>>>>>>>Struct tSQLKeyWords
70552>>>>>>>>>>>>>>>    Integer iSQLWord
70552>>>>>>>>>>>>>>>    Integer iSQLDbType
70552>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSQLRelation
70552>>>>>>>>>>>>>>>    Integer iFileNumber
70552>>>>>>>>>>>>>>>    Integer iFieldNumber
70552>>>>>>>>>>>>>>>    String  sFileName
70552>>>>>>>>>>>>>>>    String  sFieldName
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
70552>>>>>>>>>>>>>>>    String sUser
70552>>>>>>>>>>>>>>>    String sProgram
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
70552>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
70552>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
70552>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
70552>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
70552>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
70552>>>>>>>>>>>>>>>//       so that it is filled with all SQL
70552>>>>>>>>>>>>>>>//       keywords for that new type.
70552>>>>>>>>>>>>>>>Enum_List
70552>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
70552>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
70552>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
70552>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
70552>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
70552>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
70552>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
70552>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
70552>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
70552>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
70552>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
70552>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
70552>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
70552>>>>>>>>>>>>>>>End_Enum_List
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
70552>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
70552>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
70552>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
70552>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
70552>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
70552>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
70552>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
70552>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
70552>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
70552>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
70552>>>>>>>>>>>>>>>Enum_List
70552>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
70552>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
70552>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
70552>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
70552>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
70552>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
70552>>>>>>>>>>>>>>>End_Enum_List
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
70552>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
70552>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// These are not defined pre DF 18:
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
70552>>>>>>>>>>>>>>>    String sDriverName
70552>>>>>>>>>>>>>>>    String sServerName
70552>>>>>>>>>>>>>>>    String sDatabaseName
70552>>>>>>>>>>>>>>>    String sSchemaName
70552>>>>>>>>>>>>>>>    Boolean bRecnumTable
70552>>>>>>>>>>>>>>>    Integer iPrimaryIndex
70552>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
70552>>>>>>>>>>>>>>>    String sTableCharacterFormat
70552>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
70552>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
70552>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
70552>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
70552>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
70552>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
70552>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
70552>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
70552>>>>>>>>>>>>>>>    String sFileIndexTablespace
70552>>>>>>>>>>>>>>>    String sFileLongTablespace
70552>>>>>>>>>>>>>>>    String sTableTablespace
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
70552>>>>>>>>>>>>>>>    Integer iFieldNumber
70552>>>>>>>>>>>>>>>    Integer iFieldIndex
70552>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
70552>>>>>>>>>>>>>>>    Integer iFieldRelatedField
70552>>>>>>>>>>>>>>>    Integer iIndexNumber
70552>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
70552>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
70552>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
70552>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
70552>>>>>>>>>>>>>>>    String  sIndexName
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIColumn
70552>>>>>>>>>>>>>>>    Integer iFieldNumber
70552>>>>>>>>>>>>>>>    String  sFieldName
70552>>>>>>>>>>>>>>>    Integer iType
70552>>>>>>>>>>>>>>>    String  sType
70552>>>>>>>>>>>>>>>    Integer iLength
70552>>>>>>>>>>>>>>>    Integer iPrecision
70552>>>>>>>>>>>>>>>    Integer iOptions
70552>>>>>>>>>>>>>>>    Boolean bIsSQLType
70552>>>>>>>>>>>>>>>    Boolean bAllowNULL
70552>>>>>>>>>>>>>>>    String  sDefaultValue
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIColumnCompare
70552>>>>>>>>>>>>>>>    Integer iFieldNumber
70552>>>>>>>>>>>>>>>    // FROM database:
70552>>>>>>>>>>>>>>>    Boolean bExistsFrom
70552>>>>>>>>>>>>>>>    String  sFieldNameFrom
70552>>>>>>>>>>>>>>>    Integer iTypeFrom
70552>>>>>>>>>>>>>>>    String  sTypeFrom
70552>>>>>>>>>>>>>>>    Integer iLengthFrom
70552>>>>>>>>>>>>>>>    Integer iPrecisionFrom
70552>>>>>>>>>>>>>>>    Integer iOptionsFrom
70552>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
70552>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
70552>>>>>>>>>>>>>>>    String  sDefaultValueFrom
70552>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
70552>>>>>>>>>>>>>>>    Boolean bCancelFrom
70552>>>>>>>>>>>>>>>    Boolean bErrorFrom
70552>>>>>>>>>>>>>>>    // TO database:
70552>>>>>>>>>>>>>>>    Boolean bExistsTo
70552>>>>>>>>>>>>>>>    Integer iFieldNumberTo
70552>>>>>>>>>>>>>>>    String  sFieldNameTo
70552>>>>>>>>>>>>>>>    Integer iTypeTo
70552>>>>>>>>>>>>>>>    String  sTypeTo
70552>>>>>>>>>>>>>>>    Integer iLengthTo
70552>>>>>>>>>>>>>>>    Integer iPrecisionTo
70552>>>>>>>>>>>>>>>    Integer iOptionsTo
70552>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
70552>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
70552>>>>>>>>>>>>>>>    String  sDefaultValueTo
70552>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
70552>>>>>>>>>>>>>>>    Boolean bCancelTo
70552>>>>>>>>>>>>>>>    Boolean bErrorTo
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIRelation
70552>>>>>>>>>>>>>>>    Handle  hTableFrom
70552>>>>>>>>>>>>>>>    Integer iColumnFrom
70552>>>>>>>>>>>>>>>    Handle  hTableTo
70552>>>>>>>>>>>>>>>    Integer iColumnTo
70552>>>>>>>>>>>>>>>    String  sLogicalNameFrom
70552>>>>>>>>>>>>>>>    String  sLogicalNameTo
70552>>>>>>>>>>>>>>>    String  sFieldNameFrom
70552>>>>>>>>>>>>>>>    String  sFieldNameTo
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIRelationCompare
70552>>>>>>>>>>>>>>>    // Common:
70552>>>>>>>>>>>>>>>    Handle  hTableFrom
70552>>>>>>>>>>>>>>>    Integer iColumnFrom
70552>>>>>>>>>>>>>>>    Handle  hTableTo
70552>>>>>>>>>>>>>>>    Integer iColumnTo
70552>>>>>>>>>>>>>>>    // FROM database:
70552>>>>>>>>>>>>>>>    Boolean bExistsFrom
70552>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
70552>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
70552>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
70552>>>>>>>>>>>>>>>    String  sFieldNameTo_From
70552>>>>>>>>>>>>>>>    Boolean bShouldChange_From
70552>>>>>>>>>>>>>>>    Boolean bCancel_From
70552>>>>>>>>>>>>>>>    Boolean bError_From
70552>>>>>>>>>>>>>>>    // TO database:
70552>>>>>>>>>>>>>>>    Boolean bExistsTo
70552>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
70552>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
70552>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
70552>>>>>>>>>>>>>>>    String  sFieldNameTo_To
70552>>>>>>>>>>>>>>>    Boolean bShouldChange_To
70552>>>>>>>>>>>>>>>    Boolean bCancel_To
70552>>>>>>>>>>>>>>>    Boolean bError_To
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIIndexSegment
70552>>>>>>>>>>>>>>>    Integer iFieldNumber
70552>>>>>>>>>>>>>>>    String  sFieldName
70552>>>>>>>>>>>>>>>    Boolean bUppercase
70552>>>>>>>>>>>>>>>    Boolean bAscending
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIIndex
70552>>>>>>>>>>>>>>>    Integer iIndexNumber
70552>>>>>>>>>>>>>>>    Integer iPrimaryIndex
70552>>>>>>>>>>>>>>>    String  sSQLIndexName
70552>>>>>>>>>>>>>>>    Integer iSQLIndexType
70552>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
70552>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPIIndexCompare
70552>>>>>>>>>>>>>>>    // Common:
70552>>>>>>>>>>>>>>>    Integer iIndexNumber
70552>>>>>>>>>>>>>>>    // FROM database:
70552>>>>>>>>>>>>>>>    Boolean bExistsFrom
70552>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
70552>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
70552>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
70552>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
70552>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
70552>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
70552>>>>>>>>>>>>>>>    Boolean bCancelFrom
70552>>>>>>>>>>>>>>>    Boolean bErrorFrom
70552>>>>>>>>>>>>>>>    // TO database:
70552>>>>>>>>>>>>>>>    Boolean bExistsTo
70552>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
70552>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
70552>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
70552>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
70552>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
70552>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
70552>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
70552>>>>>>>>>>>>>>>    Boolean bCancelTo
70552>>>>>>>>>>>>>>>    Boolean bErrorTo
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPITableNameInfo
70552>>>>>>>>>>>>>>>    Integer iTableNumber
70552>>>>>>>>>>>>>>>    String  sRootName
70552>>>>>>>>>>>>>>>    String  sLogicalName
70552>>>>>>>>>>>>>>>    String  sDisplayName
70552>>>>>>>>>>>>>>>    String  sDriverID
70552>>>>>>>>>>>>>>>    Boolean bIsAlias
70552>>>>>>>>>>>>>>>    Boolean bIsSQL
70552>>>>>>>>>>>>>>>    Boolean bIsSystemFile
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
70552>>>>>>>>>>>>>>>    Integer iTableNumber
70552>>>>>>>>>>>>>>>    // FROM
70552>>>>>>>>>>>>>>>    Boolean bExistsFrom
70552>>>>>>>>>>>>>>>    String  sRootNameFrom
70552>>>>>>>>>>>>>>>    String  sLogicalNameFrom
70552>>>>>>>>>>>>>>>    String  sDisplayNameFrom
70552>>>>>>>>>>>>>>>    String  sDriverIDFrom
70552>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
70552>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
70552>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
70552>>>>>>>>>>>>>>>    // TO database:
70552>>>>>>>>>>>>>>>    Boolean bExistsTo
70552>>>>>>>>>>>>>>>    String  sRootNameTo
70552>>>>>>>>>>>>>>>    String  sLogicalNameTo
70552>>>>>>>>>>>>>>>    String  sDisplayNameTo
70552>>>>>>>>>>>>>>>    String  sDriverIDTo
70552>>>>>>>>>>>>>>>    Boolean bIsAliasTo
70552>>>>>>>>>>>>>>>    Boolean bIsSQLTo
70552>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPITable
70552>>>>>>>>>>>>>>>    Handle hTable
70552>>>>>>>>>>>>>>>    Boolean bFromTable
70552>>>>>>>>>>>>>>>    Boolean bToTable
70552>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
70552>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
70552>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
70552>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
70552>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
70552>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
70552>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
70552>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
70552>>>>>>>>>>>>>>>    Boolean bShouldChange
70552>>>>>>>>>>>>>>>    Boolean bCancel
70552>>>>>>>>>>>>>>>    Boolean bError
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPITableCompare
70552>>>>>>>>>>>>>>>    Handle hTable
70552>>>>>>>>>>>>>>>    // FROM database:
70552>>>>>>>>>>>>>>>    Boolean bExistsFrom
70552>>>>>>>>>>>>>>>    // TO database:
70552>>>>>>>>>>>>>>>    Boolean bExistsTo
70552>>>>>>>>>>>>>>>    // Both:
70552>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
70552>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
70552>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
70552>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
70552>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
70552>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
70552>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
70552>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
70552>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
70552>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
70552>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Struct tAPITableBooleans
70552>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
70552>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
70552>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
70552>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
70552>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
70552>>>>>>>>>>>>>>>End_Struct
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
70552>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
70552>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
70552>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
70552>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
70552>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
70552>>>>>>>>>>>>>>>Enum_List
70552>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
70552>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
70552>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
70552>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
70552>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
70552>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
70552>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
70552>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
70552>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
70552>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
70552>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
70552>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
70552>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
70552>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
70552>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
70552>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
70552>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
70552>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
70552>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
70552>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
70552>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
70552>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
70552>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
70552>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
70552>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
70552>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
70552>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
70552>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
70552>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
70552>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
70552>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
70552>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
70552>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
70552>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
70552>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
70552>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
70552>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
70552>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
70552>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
70552>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
70552>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
70552>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
70552>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
70552>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
70552>>>>>>>>>>>>>>>End_Enum_List
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>>>>>
70552>>>>>>>>>>>
70552>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
70552>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
70552>>>>>>>>>>>
70552>>>>>>>>>>>
70552>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
70552>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Define MDSDB2    for "MDS_DB2"
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
70552>>>>>>>>>>>
70552>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
70552>>>>>>>>>>>// They can have slightly different SQL keywords.
70552>>>>>>>>>>>// Note: If a new type is added to the list,
70552>>>>>>>>>>>//       the struct array xxx must be adjusted
70552>>>>>>>>>>>//       so that it is filled with all SQL
70552>>>>>>>>>>>//       keywords for that new type.
70552>>>>>>>>>>>Enum_List  
70552>>>>>>>>>>>End_Enum_List
70552>>>>>>>>>>>
70552>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
70552>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
70552>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
70552>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
70552>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
70552>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
70552>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
70552>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
70552>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
70552>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
70552>>>>>>>>>>>
70552>>>>>>>>>>>
70552>>>>>>>>>>>// SQLConnection.ini constants:
70552>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
70552>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
70552>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
70552>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
70552>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
70552>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
70552>>>>>>>>>>>
70552>>>>>>>>>>>// DF 19 ini-file settings:
70552>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
70552>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
70552>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
70552>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
70552>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
70552>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
70552>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
70552>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
70552>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
70552>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
70552>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
70552>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
70552>>>>>>>>>>>
70552>>>>>>>>>>>// Database Update Framework extended settings:
70552>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
70552>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
70552>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
70552>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
70552>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
70552>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
70552>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
70552>>>>>>>>>>>
70552>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
70552>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
70552>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
70552>>>>>>>>>>>
70552>>>>>>>>>>>Struct tSQLConnection
70552>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
70552>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
70552>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
70552>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
70552>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
70552>>>>>>>>>>>    String sDatabase                // 6. SQL Database
70552>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
70552>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
70552>>>>>>>>>>>    String sUserID                  // 9. User ID
70552>>>>>>>>>>>    String sPassword                // 10. Password
70552>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
70552>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
70552>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
70552>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
70552>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
70552>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
70552>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
70552>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
70552>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
70552>>>>>>>>>>>End_Struct
70552>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
70552>>>>>>>>>
70552>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
70553>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
70555>>>>>>>>>        Handle hoSQLManagerMT
70555>>>>>>>>>
70555>>>>>>>>>        Property String private.psUseDatabase ""
70556>>>>>>>>>
70556>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
70556>>>>>>>>>        Property Handle  private.phCurrentTable 0
70557>>>>>>>>>        Property Integer private.piCurrentField 0
70558>>>>>>>>>
70558>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
70559>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
70560>>>>>>>>>
70560>>>>>>>>>        Property Handle phoSQLManagerMT
70561>>>>>>>>>
70561>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
70562>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
70563>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
70564>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
70565>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
70566>>>>>>>>>
70566>>>>>>>>>        Property Boolean pbHandleQueryErrors True
70567>>>>>>>>>
70567>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
70568>>>>>>>>>        Property String[] paSQLFetchResults
70569>>>>>>>>>
70569>>>>>>>>>        // Error handling
70569>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
70570>>>>>>>>>        Property Boolean pbSqlError False
70571>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
70572>>>>>>>>>        Property Boolean pbProcessingError False
70573>>>>>>>>>
70573>>>>>>>>>        // Statistics on query
70573>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
70574>>>>>>>>>        Property TimeSpan ptsQueryExec
70575>>>>>>>>>        Property TimeSpan ptsFetchResults
70576>>>>>>>>>        Property Integer piColumns 0
70577>>>>>>>>>        Property Integer piRows 0
70578>>>>>>>>>        Property Integer piRowType 0
70579>>>>>>>>>        Property String[] paQueryMessages
70580>>>>>>>>>        Property String psSQLStatementString
70581>>>>>>>>>
70581>>>>>>>>>        Property Integer[] paTableConvertExceptions
70582>>>>>>>>>
70582>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
70583>>>>>>>>>
70583>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
70583>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
70583>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
70583>>>>>>>>>        Property Integer piChunkMax 500
70584>>>>>>>>>
70584>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
70584>>>>>>>>>        Send SetupSQLKeywordArray
70585>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
70586>>>>>>>>>    End_Procedure
70587>>>>>>>>>
70587>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
70587>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
70589>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
70591>>>>>>>>>            Function_Return (EQ)
70592>>>>>>>>>        End
70592>>>>>>>>>>
70592>>>>>>>>>        Function_Return (GT)
70593>>>>>>>>>    End_Function
70594>>>>>>>>>
70594>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
70594>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
70596>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
70599>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
70602>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
70605>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
70608>>>>>>>>>
70608>>>>>>>>>        Function_Return (EQ)
70609>>>>>>>>>    End_Function
70610>>>>>>>>>
70610>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
70612>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
70612>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
70613>>>>>>>>>        Integer iSize
70613>>>>>>>>>
70613>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
70614>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
70615>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
70616>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
70617>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
70618>>>>>>>>>
70618>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
70619>>>>>>>>>    End_Procedure
70620>>>>>>>>>
70620>>>>>>>>>    // Creates a struct array with all SQL keywords
70620>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
70620>>>>>>>>>    // have slightly different wording.
70620>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
70620>>>>>>>>>    // needs to be done for every keyword group below.
70620>>>>>>>>>    Procedure SetupSQLKeywordArray
70622>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
70622>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
70624>>>>>>>>>
70624>>>>>>>>>        // This should only be called once; but in case it is
70624>>>>>>>>>        // we delete the array first.
70624>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
70625>>>>>>>>>
70625>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
70625>>>>>>>>>        //
70625>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
70626>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
70627>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
70628>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
70629>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
70630>>>>>>>>>
70630>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
70631>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
70632>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
70633>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
70634>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
70635>>>>>>>>>
70635>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
70636>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
70637>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
70638>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
70639>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
70640>>>>>>>>>
70640>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
70641>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
70642>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
70643>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
70644>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
70645>>>>>>>>>
70645>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
70646>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
70647>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
70648>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
70649>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
70650>>>>>>>>>
70650>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
70651>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
70652>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
70653>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
70654>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
70655>>>>>>>>>
70655>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
70656>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
70657>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
70658>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
70659>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
70660>>>>>>>>>
70660>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
70661>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
70662>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
70663>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
70664>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
70665>>>>>>>>>
70665>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
70666>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
70667>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
70668>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
70669>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
70670>>>>>>>>>
70670>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
70671>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
70672>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
70673>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
70674>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
70675>>>>>>>>>
70675>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
70676>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
70677>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
70678>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
70679>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
70680>>>>>>>>>
70680>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
70681>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
70682>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
70683>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
70684>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
70685>>>>>>>>>
70685>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
70686>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
70687>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
70688>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
70689>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
70690>>>>>>>>>
70690>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
70691>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
70692>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
70693>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
70694>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
70695>>>>>>>>>
70695>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
70696>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
70697>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
70698>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
70699>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
70700>>>>>>>>>
70700>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
70701>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
70702>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
70703>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
70704>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
70705>>>>>>>>>
70705>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
70706>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
70707>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
70708>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
70709>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
70710>>>>>>>>>
70710>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
70711>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
70712>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
70713>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
70714>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
70715>>>>>>>>>
70715>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
70716>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
70717>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
70718>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
70719>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
70720>>>>>>>>>
70720>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
70721>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
70722>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
70723>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
70724>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
70725>>>>>>>>>
70725>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
70726>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
70727>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
70728>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
70729>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
70730>>>>>>>>>
70730>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
70731>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
70732>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
70733>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
70734>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
70735>>>>>>>>>
70735>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
70736>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
70737>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
70738>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
70739>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
70740>>>>>>>>>
70740>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
70741>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
70742>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
70743>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
70744>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
70745>>>>>>>>>
70745>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
70746>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
70747>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
70748>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
70749>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
70750>>>>>>>>>
70750>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
70751>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
70752>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
70753>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
70754>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
70755>>>>>>>>>
70755>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
70756>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
70757>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
70758>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
70759>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
70760>>>>>>>>>
70760>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
70761>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
70762>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
70763>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
70764>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
70765>>>>>>>>>
70765>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
70766>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
70767>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
70768>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
70769>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
70770>>>>>>>>>
70770>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
70771>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
70772>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
70773>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
70774>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
70775>>>>>>>>>
70775>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
70776>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
70777>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
70778>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
70779>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
70780>>>>>>>>>
70780>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
70781>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
70782>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
70783>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
70784>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
70785>>>>>>>>>
70785>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
70786>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
70787>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
70788>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
70789>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
70790>>>>>>>>>
70790>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
70791>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
70792>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
70793>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
70794>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
70795>>>>>>>>>
70795>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
70796>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
70797>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
70798>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
70799>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
70800>>>>>>>>>
70800>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
70801>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
70802>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
70803>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
70804>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
70805>>>>>>>>>
70805>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
70806>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
70807>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
70808>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
70809>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
70810>>>>>>>>>
70810>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
70811>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
70812>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
70813>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
70814>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
70815>>>>>>>>>
70815>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
70816>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
70817>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
70818>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
70819>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
70820>>>>>>>>>
70820>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
70821>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
70822>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
70823>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
70824>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
70825>>>>>>>>>
70825>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
70826>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
70827>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
70828>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
70829>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
70830>>>>>>>>>
70830>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
70831>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
70832>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
70833>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
70834>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
70835>>>>>>>>>
70835>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
70836>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
70837>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
70838>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
70839>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
70840>>>>>>>>>
70840>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
70841>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
70842>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
70843>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
70844>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
70845>>>>>>>>>
70845>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
70845>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
70846>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
70847>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
70848>>>>>>>>>
70848>>>>>>>>>    End_Procedure
70849>>>>>>>>>
70849>>>>>>>>>End_Class
70850>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
70850>>>>>>>>>//****************************************************************************
70850>>>>>>>>>// $Module type: Class
70850>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
70850>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
70850>>>>>>>>>// Web-site    : http://www.rdctools.com
70850>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
70850>>>>>>>>>//
70850>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
70850>>>>>>>>>//
70850>>>>>>>>>// $Rev History:
70850>>>>>>>>>//    2015-08-11  Module header created
70850>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
70850>>>>>>>>>//                Added a new structure for passing connection data back & forth.
70850>>>>>>>>>//                Added better error handling.
70850>>>>>>>>>//                Added a decompose message for the connection string.
70850>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
70850>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
70850>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
70850>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
70850>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
70850>>>>>>>>>//****************************************************************************
70850>>>>>>>>>Use cli.pkg
70850>>>>>>>>>Use MSSqldrv.pkg
70850>>>>>>>>>Use db2_drv.pkg
70850>>>>>>>>>Use odbc_drv.pkg
70850>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
70850>>>>>>>>>>>//****************************************************************************
70850>>>>>>>>>>>// $Module type: Class
70850>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
70850>>>>>>>>>>>//
70850>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
70850>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
70850>>>>>>>>>>>// E-mail      : support@rdctools.com
70850>>>>>>>>>>>// Web-site    : http://www.rdctools.com
70850>>>>>>>>>>>//
70850>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
70850>>>>>>>>>>>//
70850>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
70850>>>>>>>>>>>//               properties of that object.
70850>>>>>>>>>>>//
70850>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70850>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70850>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70850>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70850>>>>>>>>>>>// in the help folder for more details.
70850>>>>>>>>>>>//
70850>>>>>>>>>>>Use cSQLConnectionIniFile.inc
70850>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
70850>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
70850>>>>>>>>>>>>>
70850>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
70851>>>>>>>>>>>>>    Procedure Construct_Object
70853>>>>>>>>>>>>>        Forward Send Construct_Object
70855>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
70856>>>>>>>>>>>>>    End_Procedure
70857>>>>>>>>>>>>>
70857>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
70859>>>>>>>>>>>>>        String sRetval
70859>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
70861>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
70862>>>>>>>>>>>>>        End                                        
70862>>>>>>>>>>>>>>
70862>>>>>>>>>>>>>        Else Begin
70863>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
70864>>>>>>>>>>>>>        End
70864>>>>>>>>>>>>>>
70864>>>>>>>>>>>>>            
70864>>>>>>>>>>>>>        Function_Return sRetval
70865>>>>>>>>>>>>>    End_Function
70866>>>>>>>>>>>>>
70866>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
70868>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
70868>>>>>>>>>>>>>
70868>>>>>>>>>>>>>        Get psDriverID to sDriverID
70869>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
70870>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
70871>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
70873>>>>>>>>>>>>>            Move "" to sDatabase
70874>>>>>>>>>>>>>        End
70874>>>>>>>>>>>>>>
70874>>>>>>>>>>>>>        
70874>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
70874>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
70874>>>>>>>>>>>>>//            Function_Return sConnect
70874>>>>>>>>>>>>>//        End
70874>>>>>>>>>>>>>
70874>>>>>>>>>>>>>        If (sDatabase <> "") Begin
70876>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
70877>>>>>>>>>>>>>        End
70877>>>>>>>>>>>>>>
70877>>>>>>>>>>>>>        If (bTrusted = True) Begin
70879>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
70880>>>>>>>>>>>>>        End
70880>>>>>>>>>>>>>>
70880>>>>>>>>>>>>>        Else Begin
70881>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
70882>>>>>>>>>>>>>        End
70882>>>>>>>>>>>>>>
70882>>>>>>>>>>>>>        Function_Return sConnect
70883>>>>>>>>>>>>>    End_Function
70884>>>>>>>>>>>>>
70884>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70886>>>>>>>>>>>>>        Boolean bLoginSuccessful
70886>>>>>>>>>>>>>        String sDriverID
70886>>>>>>>>>>>>>
70886>>>>>>>>>>>>>        Get psDriverID to sDriverID
70887>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
70889>>>>>>>>>>>>>            Function_Return True
70890>>>>>>>>>>>>>        End
70890>>>>>>>>>>>>>>
70890>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
70891>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
70893>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
70894>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
70896>>>>>>>>>>>>>        End
70896>>>>>>>>>>>>>>
70896>>>>>>>>>>>>>        Else Begin
70897>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
70899>>>>>>>>>>>>>        End
70899>>>>>>>>>>>>>>
70899>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
70900>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70901>>>>>>>>>>>>>    End_Function
70902>>>>>>>>>>>>>End_Class
70903>>>>>>>>>>>>>
70903>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
70904>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
70906>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
70907>>>>>>>>>>>>>    End_Function
70908>>>>>>>>>>>>>End_Class
70909>>>>>>>>>>>>>
70909>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
70910>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70912>>>>>>>>>>>>>        Boolean bLoginSuccessful
70912>>>>>>>>>>>>>        String sDriverID
70912>>>>>>>>>>>>>
70912>>>>>>>>>>>>>        Get psDriverID to sDriverID
70913>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
70914>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
70916>>>>>>>>>>>>>            Function_Return True
70917>>>>>>>>>>>>>        End
70917>>>>>>>>>>>>>>
70917>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
70918>>>>>>>>>>>>>        If (bTrusted = False) Begin
70920>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
70922>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
70923>>>>>>>>>>>>>            End
70923>>>>>>>>>>>>>>
70923>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
70926>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
70927>>>>>>>>>>>>>            End
70927>>>>>>>>>>>>>>
70927>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
70929>>>>>>>>>>>>>        End
70929>>>>>>>>>>>>>>
70929>>>>>>>>>>>>>        Else Begin
70930>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
70932>>>>>>>>>>>>>        End
70932>>>>>>>>>>>>>>
70932>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
70933>>>>>>>>>>>>>
70933>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70934>>>>>>>>>>>>>    End_Function
70935>>>>>>>>>>>>>End_Class
70936>>>>>>>>>>>>>
70936>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
70937>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70939>>>>>>>>>>>>>        Boolean bLoginSuccessful
70939>>>>>>>>>>>>>        String sDriverID
70939>>>>>>>>>>>>>
70939>>>>>>>>>>>>>        Move False to Err
70940>>>>>>>>>>>>>        Get psDriverID to sDriverID
70941>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
70943>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
70944>>>>>>>>>>>>>        End
70944>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
70946>>>>>>>>>>>>>
70946>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
70947>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70948>>>>>>>>>>>>>    End_Function
70949>>>>>>>>>>>>>End_Class
70950>>>>>>>>>>>>>
70950>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
70951>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70953>>>>>>>>>>>>>        Boolean bLoginSuccessful
70953>>>>>>>>>>>>>        String sDriverID
70953>>>>>>>>>>>>>
70953>>>>>>>>>>>>>        Move False to Err
70954>>>>>>>>>>>>>        Get psDriverID to sDriverID
70955>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
70955>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
70955>>>>>>>>>>>>>//        End
70955>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
70957>>>>>>>>>>>>>
70957>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
70958>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70959>>>>>>>>>>>>>    End_Function
70960>>>>>>>>>>>>>End_Class
70961>>>>>>>>>>>>>
70961>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
70962>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
70964>>>>>>>>>>>>>        Function_Return ""
70965>>>>>>>>>>>>>    End_Function
70966>>>>>>>>>>>>>End_Class
70967>>>>>>>>>>>>>
70967>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
70968>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70970>>>>>>>>>>>>>        Boolean bLoginSuccessful
70970>>>>>>>>>>>>>        String sDriverID
70970>>>>>>>>>>>>>
70970>>>>>>>>>>>>>        Get psDriverID to sDriverID
70971>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
70971>>>>>>>>>>>>>        Move False to Err
70972>>>>>>>>>>>>>        If (bTrusted = False) Begin
70974>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
70976>>>>>>>>>>>>>        End
70976>>>>>>>>>>>>>>
70976>>>>>>>>>>>>>        Else Begin
70977>>>>>>>>>>>>>            Login sServer "" "" sDriverID
70979>>>>>>>>>>>>>        End
70979>>>>>>>>>>>>>>
70979>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
70980>>>>>>>>>>>>>
70980>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70981>>>>>>>>>>>>>    End_Function
70982>>>>>>>>>>>>>End_Class
70983>>>>>>>>>>>>>
70983>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
70984>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
70986>>>>>>>>>>>>>        Boolean bLoginSuccessful
70986>>>>>>>>>>>>>        String sDriverID
70986>>>>>>>>>>>>>        Integer iPos
70986>>>>>>>>>>>>>
70986>>>>>>>>>>>>>        Get psDriverID to sDriverID
70987>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
70988>>>>>>>>>>>>>        If (iPos = 0) Begin
70990>>>>>>>>>>>>>            If (sDatabase <> "") Begin
70992>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
70993>>>>>>>>>>>>>            End
70993>>>>>>>>>>>>>>
70993>>>>>>>>>>>>>        End
70993>>>>>>>>>>>>>>
70993>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
70993>>>>>>>>>>>>>        Move False to Err
70994>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
70994>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
70996>>>>>>>>>>>>>
70996>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
70997>>>>>>>>>>>>>        Function_Return bLoginSuccessful
70998>>>>>>>>>>>>>    End_Function
70999>>>>>>>>>>>>>End_Class
71000>>>>>>>>>>>>>
71000>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
71001>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
71003>>>>>>>>>>>>>        Boolean bLoginSuccessful
71003>>>>>>>>>>>>>        String sDriverID
71003>>>>>>>>>>>>>
71003>>>>>>>>>>>>>        Get psDriverID to sDriverID
71004>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
71004>>>>>>>>>>>>>        Move False to Err
71005>>>>>>>>>>>>>        If (bTrusted = False) Begin
71007>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
71009>>>>>>>>>>>>>        End
71009>>>>>>>>>>>>>>
71009>>>>>>>>>>>>>        Else Begin
71010>>>>>>>>>>>>>            Login sServer "" "" sDriverID
71012>>>>>>>>>>>>>        End
71012>>>>>>>>>>>>>>
71012>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
71013>>>>>>>>>>>>>        Function_Return bLoginSuccessful
71014>>>>>>>>>>>>>    End_Function
71015>>>>>>>>>>>>>End_Class
71016>>>>>>>>>>>>>
71016>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
71017>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
71019>>>>>>>>>>>>>        Boolean bLoginSuccessful
71019>>>>>>>>>>>>>        String sDriverID
71019>>>>>>>>>>>>>
71019>>>>>>>>>>>>>        Get psDriverID to sDriverID
71020>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
71020>>>>>>>>>>>>>        Move False to Err
71021>>>>>>>>>>>>>        If (bTrusted = False) Begin
71023>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
71025>>>>>>>>>>>>>        End
71025>>>>>>>>>>>>>>
71025>>>>>>>>>>>>>        Else Begin
71026>>>>>>>>>>>>>            Login sServer "" "" sDriverID
71028>>>>>>>>>>>>>        End
71028>>>>>>>>>>>>>>
71028>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
71029>>>>>>>>>>>>>        Function_Return bLoginSuccessful
71030>>>>>>>>>>>>>    End_Function
71031>>>>>>>>>>>>>End_Class
71032>>>>>>>>>>>>>
71032>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
71033>>>>>>>>>>>>>    Procedure Construct_Object
71035>>>>>>>>>>>>>        Forward Send Construct_Object
71037>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
71038>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
71039>>>>>>>>>>>>>    End_Procedure
71040>>>>>>>>>>>>>
71040>>>>>>>>>>>>>    Function CreateDriver Returns Handle
71042>>>>>>>>>>>>>        String sDriverID
71042>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
71042>>>>>>>>>>>>>
71042>>>>>>>>>>>>>        Get psDriverID to sDriverID
71043>>>>>>>>>>>>>        Case Begin
71043>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
71045>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
71046>>>>>>>>>>>>>                Case Break
71047>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
71050>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
71051>>>>>>>>>>>>>                Case Break
71052>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
71055>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
71056>>>>>>>>>>>>>                Case Break               
71057>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
71057>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
71057>>>>>>>>>>>>>//                Case Break
71057>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
71060>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
71061>>>>>>>>>>>>>                Case Break
71062>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
71065>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
71066>>>>>>>>>>>>>                Case Break
71067>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
71070>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
71071>>>>>>>>>>>>>                Case Break
71072>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
71075>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
71076>>>>>>>>>>>>>                Case Break
71077>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
71077>>>>>>>>>>>>>            Case Else
71077>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
71078>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
71079>>>>>>>>>>>>>        Case End
71079>>>>>>>>>>>>>
71079>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
71080>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
71081>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
71082>>>>>>>>>>>>>
71082>>>>>>>>>>>>>        Function_Return hoDriver
71083>>>>>>>>>>>>>    End_Function
71084>>>>>>>>>>>>>
71084>>>>>>>>>>>>>    Procedure DestroyDriver
71086>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
71088>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
71089>>>>>>>>>>>>>        End
71089>>>>>>>>>>>>>>
71089>>>>>>>>>>>>>    End_Procedure
71090>>>>>>>>>>>>>
71090>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
71092>>>>>>>>>>>>>        String sConnect
71092>>>>>>>>>>>>>        Handle hoDriver
71092>>>>>>>>>>>>>
71092>>>>>>>>>>>>>        Get CreateDriver to hoDriver
71093>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
71094>>>>>>>>>>>>>        Send DestroyDriver
71095>>>>>>>>>>>>>        Function_Return sConnect
71096>>>>>>>>>>>>>    End_Function
71097>>>>>>>>>>>>>
71097>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
71099>>>>>>>>>>>>>        Boolean bLoginSuccessful
71099>>>>>>>>>>>>>        Handle hoDriver
71099>>>>>>>>>>>>>
71099>>>>>>>>>>>>>        Get CreateDriver to hoDriver
71100>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
71101>>>>>>>>>>>>>        Send DestroyDriver
71102>>>>>>>>>>>>>        Function_Return bLoginSuccessful
71103>>>>>>>>>>>>>    End_Function
71104>>>>>>>>>>>>>
71104>>>>>>>>>>>>>End_Class
71105>>>>>>>>>>>
71105>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
71105>>>>>>>>>>>>>Use cCryptographer.pkg
71105>>>>>>>>>>>>>
71105>>>>>>>>>>>>>Class cLoginEncryption is a cObject
71106>>>>>>>>>>>>>    
71106>>>>>>>>>>>>>    Procedure Construct_Object
71108>>>>>>>>>>>>>        Forward Send Construct_Object
71110>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
71110>>>>>>>>>>>>>        Property String psEncryptPassword ""
71111>>>>>>>>>>>>>        
71111>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographer
71113>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
71114>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
71115>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
71116>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
71117>>>>>>>>>>>>>        End_Object
71118>>>>>>>>>>>>>    End_Procedure
71119>>>>>>>>>>>>>    
71119>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
71119>>>>>>>>>>>>>    // hidden mechanism desired.
71119>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
71121>>>>>>>>>>>>>        String sPassword
71121>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
71122>>>>>>>>>>>>>        Function_Return sPassword
71123>>>>>>>>>>>>>    End_Function
71124>>>>>>>>>>>>>    
71124>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
71124>>>>>>>>>>>>>    //
71124>>>>>>>>>>>>>    // Params:
71124>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
71124>>>>>>>>>>>>>    // Returns:
71124>>>>>>>>>>>>>    //   Base64 encoded hash.
71124>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
71126>>>>>>>>>>>>>        String sEncryptPassword sBinary sBase64
71126>>>>>>>>>>>>>        Address pBase64
71126>>>>>>>>>>>>>        Integer iVoid
71126>>>>>>>>>>>>>        
71126>>>>>>>>>>>>>        //  Encrypt Key
71126>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
71127>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
71129>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
71130>>>>>>>>>>>>>>
71130>>>>>>>>>>>>>        End
71130>>>>>>>>>>>>>>
71130>>>>>>>>>>>>>        
71130>>>>>>>>>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
71131>>>>>>>>>>>>>        
71131>>>>>>>>>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
71133>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
71134>>>>>>>>>>>>>>
71134>>>>>>>>>>>>>            Function_Return ""
71135>>>>>>>>>>>>>        End
71135>>>>>>>>>>>>>>
71135>>>>>>>>>>>>>        
71135>>>>>>>>>>>>>        //  Encode binary hash to Base64
71135>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
71136>>>>>>>>>>>>>        Move pBase64 to sBase64
71137>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
71138>>>>>>>>>>>>>        
71138>>>>>>>>>>>>>        Function_Return sBase64
71139>>>>>>>>>>>>>    End_Function
71140>>>>>>>>>>>>>    
71140>>>>>>>>>>>>>    
71140>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
71140>>>>>>>>>>>>>    //
71140>>>>>>>>>>>>>    // Params:
71140>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
71140>>>>>>>>>>>>>    // Returns:
71140>>>>>>>>>>>>>    //   Readable plain text password
71140>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
71142>>>>>>>>>>>>>        String sEncryptPassword sPlainText sBinary
71142>>>>>>>>>>>>>        Boolean bIsHex
71142>>>>>>>>>>>>>        Integer iLen iVoid
71142>>>>>>>>>>>>>        Address pBinary
71142>>>>>>>>>>>>>        
71142>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
71144>>>>>>>>>>>>>            //  Decode from Base64
71144>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
71145>>>>>>>>>>>>>            
71145>>>>>>>>>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
71146>>>>>>>>>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
71147>>>>>>>>>>>>>            
71147>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
71148>>>>>>>>>>>>>            
71148>>>>>>>>>>>>>            //  Encrypted binary hash to string
71148>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
71149>>>>>>>>>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
71150>>>>>>>>>>>>>        End
71150>>>>>>>>>>>>>>
71150>>>>>>>>>>>>>        
71150>>>>>>>>>>>>>        Function_Return sPlainText
71151>>>>>>>>>>>>>    End_Function
71152>>>>>>>>>>>>>End_Class
71153>>>>>>>>>>>
71153>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
71154>>>>>>>>>>>    Procedure Construct_Object
71156>>>>>>>>>>>        Forward Send Construct_Object
71158>>>>>>>>>>>
71158>>>>>>>>>>>        Property String Private_psIniFilePath
71159>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
71160>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
71161>>>>>>>>>>>
71161>>>>>>>>>>>        Property Boolean pbDFConnId False
71162>>>>>>>>>>>
71162>>>>>>>>>>>        // *** You really want to change this value! ***
71162>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
71162>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
71163>>>>>>>>>>>
71163>>>>>>>>>>>    End_Procedure
71164>>>>>>>>>>>
71164>>>>>>>>>>>    Procedure End_Construct_Object
71166>>>>>>>>>>>        Forward Send End_Construct_Object
71168>>>>>>>>>>>    End_Procedure
71169>>>>>>>>>>>
71169>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
71171>>>>>>>>>>>        String sIniFile
71171>>>>>>>>>>>        Get vFolderFormat sPath to sPath
71172>>>>>>>>>>>        Set private_psIniFilePath to sPath
71173>>>>>>>>>>>        Get psIniFileName to sIniFile
71174>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
71175>>>>>>>>>>>    End_Procedure
71176>>>>>>>>>>>
71176>>>>>>>>>>>    Function psIniFilePath Returns String
71178>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
71179>>>>>>>>>>>    End_Function
71180>>>>>>>>>>>
71180>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
71182>>>>>>>>>>>        String sPath
71182>>>>>>>>>>>        Get psIniFilePath to sPath
71183>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
71184>>>>>>>>>>>        Set private_psIniFileName to sFileName
71185>>>>>>>>>>>    End_Procedure
71186>>>>>>>>>>>
71186>>>>>>>>>>>    Function psIniFileName Returns String
71188>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
71189>>>>>>>>>>>    End_Function
71190>>>>>>>>>>>
71190>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
71190>>>>>>>>>>>    // Sets a value in the program's ini file (write)
71190>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
71190>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
71192>>>>>>>>>>>        String sIniFile sPath
71192>>>>>>>>>>>
71192>>>>>>>>>>>        Get psIniFilePath to sPath
71193>>>>>>>>>>>        Get psIniFileName to sIniFile
71194>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
71195>>>>>>>>>>>        Set psFileName to sIniFile
71196>>>>>>>>>>>        Send WriteString sSection sValueName sValue
71197>>>>>>>>>>>    End_Procedure
71198>>>>>>>>>>>
71198>>>>>>>>>>>    // Get a value from program's ini-file (read)
71198>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
71198>>>>>>>>>>>    // Returns the value
71198>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
71200>>>>>>>>>>>        String sValue sIniFile sPath
71200>>>>>>>>>>>
71200>>>>>>>>>>>        Get psIniFilePath to sPath
71201>>>>>>>>>>>        Get psIniFileName to sIniFile
71202>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
71203>>>>>>>>>>>        Set psFileName to sIniFile
71204>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
71205>>>>>>>>>>>
71205>>>>>>>>>>>        Function_Return sValue
71206>>>>>>>>>>>    End_Function
71207>>>>>>>>>>>
71207>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
71207>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
71209>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
71212>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
71215>>>>>>>>>>>
71215>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
71218>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
71221>>>>>>>>>>>
71221>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
71224>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
71227>>>>>>>>>>>
71227>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
71230>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
71233>>>>>>>>>>>
71233>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
71236>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
71239>>>>>>>>>>>
71239>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
71242>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
71245>>>>>>>>>>>
71245>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
71248>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
71251>>>>>>>>>>>
71251>>>>>>>>>>>        Function_Return (EQ)
71252>>>>>>>>>>>    End_Function
71253>>>>>>>>>>>
71253>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
71255>>>>>>>>>>>        Handle hoSections
71255>>>>>>>>>>>        Integer iItems
71255>>>>>>>>>>>
71255>>>>>>>>>>>        Send ReadSections hoSections
71256>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
71257>>>>>>>>>>>        Function_Return iItems
71258>>>>>>>>>>>    End_Function
71259>>>>>>>>>>>
71259>>>>>>>>>>>    // The normal connection string looks something like this;
71259>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
71259>>>>>>>>>>>    // ...but the full connection string looks like this;
71259>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
71259>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
71259>>>>>>>>>>>//        String sSection
71259>>>>>>>>>>>//        Integer iCount
71259>>>>>>>>>>>//
71259>>>>>>>>>>>//        Move False to Err
71259>>>>>>>>>>>//        Get psIniSectionName to sSection
71259>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
71259>>>>>>>>>>>//        Increment iCount
71259>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
71259>>>>>>>>>>>//
71259>>>>>>>>>>>//        Function_Return (Err = False)
71259>>>>>>>>>>>//    End_Function
71259>>>>>>>>>>>
71259>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
71261>>>>>>>>>>>        Integer iCount
71261>>>>>>>>>>>        Boolean bExists
71261>>>>>>>>>>>        String sSection
71261>>>>>>>>>>>
71261>>>>>>>>>>>        Move False to Err
71262>>>>>>>>>>>        Move 1 to iCount
71263>>>>>>>>>>>        Get psIniSectionName to sSection
71264>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
71265>>>>>>>>>>>        While (bExists = True)
71269>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
71270>>>>>>>>>>>            Increment iCount
71271>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
71272>>>>>>>>>>>        Loop
71273>>>>>>>>>>>>
71273>>>>>>>>>>>        Function_Return (Err = False)
71274>>>>>>>>>>>    End_Function
71275>>>>>>>>>>>
71275>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
71277>>>>>>>>>>>        Integer iCount
71277>>>>>>>>>>>        String sSection
71277>>>>>>>>>>>        Boolean bExists
71277>>>>>>>>>>>
71277>>>>>>>>>>>        Move False to Err
71278>>>>>>>>>>>        Move 1 to iCount
71279>>>>>>>>>>>        Get psIniSectionName to sSection
71280>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
71281>>>>>>>>>>>        While (bExists = True)
71285>>>>>>>>>>>            If (iCount = iItem) Begin
71287>>>>>>>>>>>                Send DeleteSection sSection
71288>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
71288>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
71289>>>>>>>>>>>            End
71289>>>>>>>>>>>>
71289>>>>>>>>>>>            Increment iCount
71290>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
71291>>>>>>>>>>>        Loop
71292>>>>>>>>>>>>
71292>>>>>>>>>>>
71292>>>>>>>>>>>        Function_Return (Err = False)
71293>>>>>>>>>>>    End_Function
71294>>>>>>>>>>>
71294>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
71294>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
71294>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
71296>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71296>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71297>>>>>>>>>>>        tSQLConnection   SQLConnection
71297>>>>>>>>>>>        tSQLConnection   SQLConnection
71297>>>>>>>>>>>        Integer iIndex
71297>>>>>>>>>>>
71297>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
71298>>>>>>>>>>>        If (iIndex = -1) Begin
71300>>>>>>>>>>>            Move True to SQLConnection.bError
71301>>>>>>>>>>>            Function_Return SQLConnection
71302>>>>>>>>>>>        End
71302>>>>>>>>>>>>
71302>>>>>>>>>>>
71302>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
71303>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
71304>>>>>>>>>>>
71304>>>>>>>>>>>        Function_Return SQLConnection
71305>>>>>>>>>>>    End_Function
71306>>>>>>>>>>>
71306>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
71306>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
71308>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71308>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71309>>>>>>>>>>>        Integer iRetval iCount iSize
71309>>>>>>>>>>>        String sValue
71309>>>>>>>>>>>        Boolean bExists
71309>>>>>>>>>>>
71309>>>>>>>>>>>        Move -1 to iRetval
71310>>>>>>>>>>>
71310>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
71311>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
71312>>>>>>>>>>>        Decrement iSize
71313>>>>>>>>>>>        For iCount from 0 to iSize
71319>>>>>>>>>>>>
71319>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
71320>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
71321>>>>>>>>>>>            If (bExists) Begin
71323>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
71324>>>>>>>>>>>                Move iSize to iCount         // We're done!
71325>>>>>>>>>>>            End
71325>>>>>>>>>>>>
71325>>>>>>>>>>>        Loop
71326>>>>>>>>>>>>
71326>>>>>>>>>>>
71326>>>>>>>>>>>        Function_Return iRetval
71327>>>>>>>>>>>    End_Function
71328>>>>>>>>>>>
71328>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
71328>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
71328>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
71330>>>>>>>>>>>        Integer iCount iSize iItems
71330>>>>>>>>>>>        String sValue
71330>>>>>>>>>>>        Boolean bExists
71330>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71330>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71331>>>>>>>>>>>
71331>>>>>>>>>>>        Move 0 to iItems
71332>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
71333>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
71334>>>>>>>>>>>        Decrement iSize
71335>>>>>>>>>>>        For iCount from 0 to iSize
71341>>>>>>>>>>>>
71341>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
71342>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
71343>>>>>>>>>>>            If (bExists) Begin
71345>>>>>>>>>>>                Increment iItems
71346>>>>>>>>>>>            End
71346>>>>>>>>>>>>
71346>>>>>>>>>>>        Loop
71347>>>>>>>>>>>>
71347>>>>>>>>>>>
71347>>>>>>>>>>>        Function_Return (iItems > 1)
71348>>>>>>>>>>>    End_Function
71349>>>>>>>>>>>
71349>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
71349>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
71351>>>>>>>>>>>        Boolean bOK
71351>>>>>>>>>>>        Integer iSize iCount
71351>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71351>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71352>>>>>>>>>>>        tSQLConnection SQLConnection
71352>>>>>>>>>>>        tSQLConnection SQLConnection
71352>>>>>>>>>>>        String sConnectionString
71352>>>>>>>>>>>
71352>>>>>>>>>>>        Move False to Err
71353>>>>>>>>>>>        Get psConnectionString to sConnectionString
71354>>>>>>>>>>>
71354>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
71355>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
71356>>>>>>>>>>>        Decrement iSize
71357>>>>>>>>>>>        // Set all current connection to inactive.
71357>>>>>>>>>>>        For iCount from 0 to iSize
71363>>>>>>>>>>>>
71363>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
71364>>>>>>>>>>>        Loop
71365>>>>>>>>>>>>
71365>>>>>>>>>>>
71365>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
71366>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
71367>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
71368>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
71369>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
71370>>>>>>>>>>>
71370>>>>>>>>>>>        Function_Return (bOK = True)
71371>>>>>>>>>>>    End_Function
71372>>>>>>>>>>>
71372>>>>>>>>>>>    // Used for updating an existing connection with new data.
71372>>>>>>>>>>>    // Returns True if successful.
71372>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
71374>>>>>>>>>>>        Boolean bOK
71374>>>>>>>>>>>        Integer iItem iSize iCount
71374>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71374>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71375>>>>>>>>>>>
71375>>>>>>>>>>>        Move False to Err
71376>>>>>>>>>>>        Move -1 to iItem
71377>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
71378>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
71379>>>>>>>>>>>        Decrement iSize
71380>>>>>>>>>>>        // Set all current connection to inactive.
71380>>>>>>>>>>>        For iCount from 0 to iSize
71386>>>>>>>>>>>>
71386>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
71387>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
71389>>>>>>>>>>>                Move iCount to iItem
71390>>>>>>>>>>>            End
71390>>>>>>>>>>>>
71390>>>>>>>>>>>        Loop
71391>>>>>>>>>>>>
71391>>>>>>>>>>>
71391>>>>>>>>>>>        If (iItem <> -1) Begin
71393>>>>>>>>>>>            Move True to SQLConnection.bEnabled
71394>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
71395>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
71396>>>>>>>>>>>        End
71396>>>>>>>>>>>>
71396>>>>>>>>>>>
71396>>>>>>>>>>>        Function_Return (bOK = True)
71397>>>>>>>>>>>    End_Function
71398>>>>>>>>>>>
71398>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
71400>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71400>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
71401>>>>>>>>>>>        String sSection sValue
71401>>>>>>>>>>>        Integer iCount
71401>>>>>>>>>>>        Boolean bExists
71401>>>>>>>>>>>
71401>>>>>>>>>>>        Get psIniSectionName to sSection
71402>>>>>>>>>>>        Get SectionExists sSection to bExists
71403>>>>>>>>>>>        If (bExists = False) Begin
71405>>>>>>>>>>>            Function_Return SQLConnectionsArray
71406>>>>>>>>>>>        End
71406>>>>>>>>>>>>
71406>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
71407>>>>>>>>>>>        If (bExists = True) Begin
71409>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
71410>>>>>>>>>>>>
71410>>>>>>>>>>>        End
71410>>>>>>>>>>>>
71410>>>>>>>>>>>
71410>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
71411>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
71412>>>>>>>>>>>
71412>>>>>>>>>>>        While (bExists = True)                 
71416>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
71416>>>>>>>>>>>            // We always put the enabled/active connection at the top
71416>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
71416>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
71416>>>>>>>>>>>
71416>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
71417>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
71418>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
71419>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
71420>>>>>>>>>>>
71420>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
71420>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
71421>>>>>>>>>>>            If (sValue = "99") Begin
71423>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
71424>>>>>>>>>>>            End
71424>>>>>>>>>>>>
71424>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
71425>>>>>>>>>>>
71425>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
71426>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
71427>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
71429>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
71430>>>>>>>>>>>            End
71430>>>>>>>>>>>>
71430>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
71432>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
71433>>>>>>>>>>>            End
71433>>>>>>>>>>>>
71433>>>>>>>>>>>
71433>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
71434>>>>>>>>>>>
71434>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
71435>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
71436>>>>>>>>>>>
71436>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
71437>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
71438>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
71440>>>>>>>>>>>                Get DecryptPassword sValue to sValue
71441>>>>>>>>>>>            End
71441>>>>>>>>>>>>
71441>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
71442>>>>>>>>>>>
71442>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
71442>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
71443>>>>>>>>>>>
71443>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
71444>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
71445>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
71446>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
71447>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
71448>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
71449>>>>>>>>>>>
71449>>>>>>>>>>>            Increment iCount
71450>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
71451>>>>>>>>>>>        Loop
71452>>>>>>>>>>>>
71452>>>>>>>>>>>
71452>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
71452>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
71454>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
71455>>>>>>>>>>>        End
71455>>>>>>>>>>>>
71455>>>>>>>>>>>
71455>>>>>>>>>>>        Function_Return SQLConnectionsArray
71456>>>>>>>>>>>    End_Function
71457>>>>>>>>>>>
71457>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
71459>>>>>>>>>>>        Integer iCount iSize
71459>>>>>>>>>>>        Boolean bOK
71459>>>>>>>>>>>        String sSection sValue
71459>>>>>>>>>>>
71459>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
71459>>>>>>>>>>>        Move 0 to iCount
71460>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
71461>>>>>>>>>>>        If (bOK = False) Begin
71463>>>>>>>>>>>            Function_Return False
71464>>>>>>>>>>>        End
71464>>>>>>>>>>>>
71464>>>>>>>>>>>
71464>>>>>>>>>>>        Move False to Err
71465>>>>>>>>>>>        Get psIniSectionName to sSection
71466>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
71466>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
71467>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
71468>>>>>>>>>>>        Decrement iSize
71469>>>>>>>>>>>
71469>>>>>>>>>>>        For iCount from 0 to iSize
71475>>>>>>>>>>>>
71475>>>>>>>>>>>            // DF 19 compatible settings:
71475>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
71476>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
71477>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
71478>>>>>>>>>>>            
71478>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
71479>>>>>>>>>>>
71479>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
71480>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
71482>>>>>>>>>>>                Get EncryptPassword sValue to sValue
71483>>>>>>>>>>>            End
71483>>>>>>>>>>>>
71483>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
71484>>>>>>>>>>>
71484>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
71486>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
71487>>>>>>>>>>>            End
71487>>>>>>>>>>>>
71487>>>>>>>>>>>
71487>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
71488>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
71489>>>>>>>>>>>
71489>>>>>>>>>>>            // The Database Update Framework extended settings:
71489>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
71490>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
71491>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
71492>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
71493>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
71494>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
71495>>>>>>>>>>>        Loop
71496>>>>>>>>>>>>
71496>>>>>>>>>>>
71496>>>>>>>>>>>        Function_Return (bOK and Err = False)
71497>>>>>>>>>>>    End_Function
71498>>>>>>>>>>>
71498>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
71498>>>>>>>>>>>    //
71498>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
71498>>>>>>>>>>>    // corresponding to the passed iDbType.
71498>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
71500>>>>>>>>>>>        String sRetval
71500>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
71502>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
71503>>>>>>>>>>>        End
71503>>>>>>>>>>>>
71503>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
71505>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
71506>>>>>>>>>>>        End
71506>>>>>>>>>>>>
71506>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
71508>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
71509>>>>>>>>>>>        End
71509>>>>>>>>>>>>
71509>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
71511>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
71512>>>>>>>>>>>        End
71512>>>>>>>>>>>>
71512>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
71514>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
71515>>>>>>>>>>>        End
71515>>>>>>>>>>>>
71515>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
71517>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
71518>>>>>>>>>>>        End
71518>>>>>>>>>>>>
71518>>>>>>>>>>>        Function_Return sRetval
71519>>>>>>>>>>>    End_Function
71520>>>>>>>>>>>
71520>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
71520>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
71520>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
71522>>>>>>>>>>>        Integer iRetval
71522>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
71524>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
71525>>>>>>>>>>>        End
71525>>>>>>>>>>>>
71525>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
71527>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
71528>>>>>>>>>>>        End
71528>>>>>>>>>>>>
71528>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
71530>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
71531>>>>>>>>>>>        End
71531>>>>>>>>>>>>
71531>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
71533>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
71534>>>>>>>>>>>        End
71534>>>>>>>>>>>>
71534>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
71536>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
71537>>>>>>>>>>>        End
71537>>>>>>>>>>>>
71537>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
71539>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
71540>>>>>>>>>>>        End
71540>>>>>>>>>>>>
71540>>>>>>>>>>>        Function_Return iRetval
71541>>>>>>>>>>>    End_Function
71542>>>>>>>>>>>
71542>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
71542>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
71542>>>>>>>>>>>    // the SQL Connection program's grid.
71542>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
71544>>>>>>>>>>>        String sRetval
71544>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
71546>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
71547>>>>>>>>>>>        End
71547>>>>>>>>>>>>
71547>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
71549>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
71550>>>>>>>>>>>        End
71550>>>>>>>>>>>>
71550>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
71552>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
71553>>>>>>>>>>>        End
71553>>>>>>>>>>>>
71553>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
71555>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
71556>>>>>>>>>>>        End
71556>>>>>>>>>>>>
71556>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
71558>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
71559>>>>>>>>>>>        End
71559>>>>>>>>>>>>
71559>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
71561>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
71562>>>>>>>>>>>        End
71562>>>>>>>>>>>>
71562>>>>>>>>>>>        Function_Return sRetval
71563>>>>>>>>>>>    End_Function
71564>>>>>>>>>>>
71564>>>>>>>>>>>    // Pass a driver id and the function will return
71564>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
71564>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
71564>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
71566>>>>>>>>>>>        Integer iRetval
71566>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
71568>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
71569>>>>>>>>>>>        End
71569>>>>>>>>>>>>
71569>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
71571>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
71572>>>>>>>>>>>        End
71572>>>>>>>>>>>>
71572>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
71574>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
71575>>>>>>>>>>>        End
71575>>>>>>>>>>>>
71575>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
71577>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
71578>>>>>>>>>>>        End
71578>>>>>>>>>>>>
71578>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
71580>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
71581>>>>>>>>>>>        End
71581>>>>>>>>>>>>
71581>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
71583>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
71584>>>>>>>>>>>        End
71584>>>>>>>>>>>>
71584>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
71586>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
71587>>>>>>>>>>>        End
71587>>>>>>>>>>>>
71587>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
71589>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
71590>>>>>>>>>>>        End
71590>>>>>>>>>>>>
71590>>>>>>>>>>>        Function_Return iRetval
71591>>>>>>>>>>>    End_Function
71592>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
71592>>>>>>>>>>>>
71592>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
71594>>>>>>>>>>>>    Integer iStart iEnd
71594>>>>>>>>>>>>    String sRetval
71594>>>>>>>>>>>>
71594>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
71595>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
71596>>>>>>>>>>>>    If (iStart = 0) Begin
71598>>>>>>>>>>>>        Function_Return ""
71599>>>>>>>>>>>>    End
71599>>>>>>>>>>>>>
71599>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
71600>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
71601>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
71603>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
71604>>>>>>>>>>>>    End
71604>>>>>>>>>>>>>
71604>>>>>>>>>>>>    Else Begin
71605>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
71606>>>>>>>>>>>>    End
71606>>>>>>>>>>>>>
71606>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
71608>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
71609>>>>>>>>>>>>        Decrement iEnd
71610>>>>>>>>>>>>    End
71610>>>>>>>>>>>>>
71610>>>>>>>>>>>>    If (iEnd <> 0) Begin
71612>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
71613>>>>>>>>>>>>    End
71613>>>>>>>>>>>>>
71613>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
71614>>>>>>>>>>>>
71614>>>>>>>>>>>>    Function_Return (Trim(sRetval))
71615>>>>>>>>>>>>End_Function
71616>>>>>>>>>>>>
71616>>>>>>>>>>>>
71616>>>>>>>>>>>
71616>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
71618>>>>>>>>>>>        String sConnect
71618>>>>>>>>>>>        Handle hoDriver
71618>>>>>>>>>>>
71618>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
71619>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
71620>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
71621>>>>>>>>>>>        Send Destroy of hoDriver
71622>>>>>>>>>>>
71622>>>>>>>>>>>        Function_Return sConnect
71623>>>>>>>>>>>    End_Function
71624>>>>>>>>>>>
71624>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
71624>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
71626>>>>>>>>>>>        String sConnect
71626>>>>>>>>>>>
71626>>>>>>>>>>>        Case Begin
71626>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
71628>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
71629>>>>>>>>>>>                If (sDatabase <> "") Begin
71631>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71632>>>>>>>>>>>                End
71632>>>>>>>>>>>>
71632>>>>>>>>>>>                Case Break
71633>>>>>>>>>>>
71633>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
71636>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
71638>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
71639>>>>>>>>>>>                End
71639>>>>>>>>>>>>
71639>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
71642>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
71643>>>>>>>>>>>                End
71643>>>>>>>>>>>>
71643>>>>>>>>>>>
71643>>>>>>>>>>>                If (sDatabase <> "") Begin
71645>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71646>>>>>>>>>>>                End
71646>>>>>>>>>>>>
71646>>>>>>>>>>>                Case Break
71647>>>>>>>>>>>
71647>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
71650>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
71651>>>>>>>>>>>                If (sDatabase <> "") Begin
71653>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71654>>>>>>>>>>>                End
71654>>>>>>>>>>>>
71654>>>>>>>>>>>                Case Break
71655>>>>>>>>>>>
71655>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
71658>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
71659>>>>>>>>>>>                If (sDatabase <> "") Begin
71661>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71662>>>>>>>>>>>                End
71662>>>>>>>>>>>>
71662>>>>>>>>>>>                Case Break
71663>>>>>>>>>>>
71663>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
71666>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
71667>>>>>>>>>>>                If (sDatabase <> "") Begin
71669>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71670>>>>>>>>>>>                End
71670>>>>>>>>>>>>
71670>>>>>>>>>>>                Case Break
71671>>>>>>>>>>>
71671>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
71674>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
71675>>>>>>>>>>>                If (sDatabase <> "") Begin
71677>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
71678>>>>>>>>>>>                End
71678>>>>>>>>>>>>
71678>>>>>>>>>>>                Case Break
71679>>>>>>>>>>>
71679>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
71682>>>>>>>>>>>                Break
71683>>>>>>>>>>>
71683>>>>>>>>>>>            Case Else
71683>>>>>>>>>>>                Move "" to sConnect
71684>>>>>>>>>>>        Case End
71684>>>>>>>>>>>
71684>>>>>>>>>>>        Function_Return sConnect
71685>>>>>>>>>>>    End_Function
71686>>>>>>>>>>>
71686>>>>>>>>>>>    // Use Base64
71686>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
71688>>>>>>>>>>>        String sRetval
71688>>>>>>>>>>>        Handle hoLoginEncryption
71688>>>>>>>>>>>
71688>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
71689>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
71690>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
71691>>>>>>>>>>>        Send Destroy of hoLoginEncryption
71692>>>>>>>>>>>          
71692>>>>>>>>>>>        Function_Return sRetval
71693>>>>>>>>>>>    End_Function
71694>>>>>>>>>>>
71694>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
71696>>>>>>>>>>>        String sRetval
71696>>>>>>>>>>>        Handle hoLoginEncryption
71696>>>>>>>>>>>
71696>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
71697>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
71698>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
71699>>>>>>>>>>>        Send Destroy of hoLoginEncryption
71700>>>>>>>>>>>
71700>>>>>>>>>>>        Function_Return sRetval
71701>>>>>>>>>>>    End_Function
71702>>>>>>>>>>>
71702>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
71702>>>>>>>>>>>    Function ApplicationPath Returns String
71704>>>>>>>>>>>        String sApplicationFileName sPath
71704>>>>>>>>>>>        Integer iNumChars iRetval
71704>>>>>>>>>>>
71704>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
71705>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
71706>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
71707>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
71708>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
71709>>>>>>>>>>>
71709>>>>>>>>>>>        Function_Return sPath
71710>>>>>>>>>>>    End_Function
71711>>>>>>>>>>>
71711>>>>>>>>>>>    // Pass a filename including the extension. The return value
71711>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
71711>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
71711>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
71713>>>>>>>>>>>        Boolean bExists
71713>>>>>>>>>>>        Handle hoPaths hoIniFile
71713>>>>>>>>>>>        String[] asWorkSpaceFiles
71714>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
71714>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
71714>>>>>>>>>>>        
71714>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
71715>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
71716>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
71717>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
71718>>>>>>>>>>>        If (bExists = True) Begin
71720>>>>>>>>>>>            Function_Return sProgramsPath
71721>>>>>>>>>>>        End                      
71721>>>>>>>>>>>>
71721>>>>>>>>>>>    
71721>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
71722>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
71724>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
71725>>>>>>>>>>>        End                                              
71725>>>>>>>>>>>>
71725>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
71726>>>>>>>>>>>        
71726>>>>>>>>>>>        Move False to bExists
71727>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
71728>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
71729>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
71730>>>>>>>>>>>        Decrement iSize       
71731>>>>>>>>>>>        
71731>>>>>>>>>>>        For iCount from 0 to iSize
71737>>>>>>>>>>>>
71737>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
71738>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
71739>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
71740>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
71741>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
71747>>>>>>>>>>>>
71747>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
71748>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
71749>>>>>>>>>>>                // Check if there are more than one path specified;
71749>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
71750>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
71752>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
71753>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
71759>>>>>>>>>>>>
71759>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
71760>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
71761>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
71762>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
71763>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
71764>>>>>>>>>>>                        If (bExists = True) Begin
71766>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
71767>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
71768>>>>>>>>>>>                            Move iSize to iCount
71769>>>>>>>>>>>                        End                                                    
71769>>>>>>>>>>>>
71769>>>>>>>>>>>                    Loop
71770>>>>>>>>>>>>
71770>>>>>>>>>>>                End
71770>>>>>>>>>>>>
71770>>>>>>>>>>>                Else Begin
71771>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
71772>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
71773>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
71774>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
71775>>>>>>>>>>>                    If (bExists = True) Begin
71777>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
71778>>>>>>>>>>>                        Move iSize to iCount
71779>>>>>>>>>>>                    End                                                    
71779>>>>>>>>>>>>
71779>>>>>>>>>>>                End
71779>>>>>>>>>>>>
71779>>>>>>>>>>>            Loop
71780>>>>>>>>>>>>
71780>>>>>>>>>>>            If (bExists = False) Begin
71782>>>>>>>>>>>                Move "" to sPath    
71783>>>>>>>>>>>            End
71783>>>>>>>>>>>>
71783>>>>>>>>>>>            Send Destroy of hoIniFile          
71784>>>>>>>>>>>        Loop        
71785>>>>>>>>>>>>
71785>>>>>>>>>>>        Send Destroy of hoPaths
71786>>>>>>>>>>>        
71786>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
71786>>>>>>>>>>>        If (sPath = "") Begin
71788>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
71789>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
71790>>>>>>>>>>>        End                  
71790>>>>>>>>>>>>
71790>>>>>>>>>>>        
71790>>>>>>>>>>>        Function_Return sPath    
71791>>>>>>>>>>>    End_Function
71792>>>>>>>>>>>    
71792>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
71792>>>>>>>>>>>    // with one or more .ws file names.
71792>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
71792>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
71792>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
71792>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
71794>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
71796>>>>>>>>>>>        String sFile sHomePath sDirSep
71796>>>>>>>>>>>        Integer iCh iSize
71796>>>>>>>>>>>        Boolean bExists      
71796>>>>>>>>>>>        Handle hoIniFile 
71796>>>>>>>>>>>        
71796>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
71797>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
71798>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
71800>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
71801>>>>>>>>>>>        End                                              
71801>>>>>>>>>>>>
71801>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
71802>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
71803>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
71804>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
71805>>>>>>>>>>>        
71805>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
71805>>>>>>>>>>>        // read the name of the .ws file name.
71805>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
71806>>>>>>>>>>>        If (bExists = True) Begin
71808>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
71809>>>>>>>>>>>            If (iCh < 0) Begin
71811>>>>>>>>>>>                Function_Return asSWSFiles
71812>>>>>>>>>>>            End                                 
71812>>>>>>>>>>>>
71812>>>>>>>>>>>            
71812>>>>>>>>>>>            Repeat
71812>>>>>>>>>>>>
71812>>>>>>>>>>>                Readln channel iCh sFile
71814>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
71816>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
71817>>>>>>>>>>>                End
71817>>>>>>>>>>>>
71817>>>>>>>>>>>            Until (SeqEof = True)
71819>>>>>>>>>>>            Send Seq_Close_Channel iCh    
71820>>>>>>>>>>>            
71820>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
71821>>>>>>>>>>>            If (iSize <> 0) Begin
71823>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
71824>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
71824>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
71824>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
71825>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
71826>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
71827>>>>>>>>>>>                If (sFile <> "") Begin
71829>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
71830>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
71831>>>>>>>>>>>                    File_Exist sFile bExists
71832>>>>>>>>>>>                    If (bExists = True) Begin
71834>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
71835>>>>>>>>>>>                    End
71835>>>>>>>>>>>>
71835>>>>>>>>>>>                End
71835>>>>>>>>>>>>
71835>>>>>>>>>>>                Send Destroy of hoIniFile
71836>>>>>>>>>>>            End
71836>>>>>>>>>>>>
71836>>>>>>>>>>>        End
71836>>>>>>>>>>>>
71836>>>>>>>>>>>        
71836>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
71836>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
71838>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
71839>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
71840>>>>>>>>>>>            If (bExists = False) Begin
71842>>>>>>>>>>>                Function_Return asWorkspaceFiles
71843>>>>>>>>>>>            End
71843>>>>>>>>>>>>
71843>>>>>>>>>>>        
71843>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
71844>>>>>>>>>>>            If (iCh < 0) Begin
71846>>>>>>>>>>>                Function_Return asWorkspaceFiles
71847>>>>>>>>>>>            End                                 
71847>>>>>>>>>>>>
71847>>>>>>>>>>>            
71847>>>>>>>>>>>            Repeat
71847>>>>>>>>>>>>
71847>>>>>>>>>>>                Readln channel iCh sFile
71849>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
71851>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
71852>>>>>>>>>>>                End
71852>>>>>>>>>>>>
71852>>>>>>>>>>>            Until (SeqEof = True)
71854>>>>>>>>>>>            Send Seq_Close_Channel iCh
71855>>>>>>>>>>>        End
71855>>>>>>>>>>>>
71855>>>>>>>>>>>        
71855>>>>>>>>>>>        Function_Return asWorkspaceFiles
71856>>>>>>>>>>>    End_Function
71857>>>>>>>>>>>
71857>>>>>>>>>>>End_Class
71858>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
71858>>>>>>>>>Use vWin32fh.pkg
71858>>>>>>>>>
71858>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
71858>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
71858>>>>>>>>>
71858>>>>>>>>>// We're making references to this object handle so we need it defined
71858>>>>>>>>>// here as well as for the cDbUpdateHandler class
71858>>>>>>>>>
71858>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
71858>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
71859>>>>>>>>>
71859>>>>>>>>>Class cSQLConnectionHandler is a cObject
71860>>>>>>>>>
71860>>>>>>>>>    Procedure Construct_Object
71862>>>>>>>>>        Forward Send Construct_Object
71864>>>>>>>>>        Move Self to ghoSQLConnectionHandler
71865>>>>>>>>>
71865>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
71866>>>>>>>>>
71866>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
71866>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
71866>>>>>>>>>        // methods to this class.
71866>>>>>>>>>        Property Boolean pbUseConnectionID True
71867>>>>>>>>>        Property Boolean pbToANSI          True
71868>>>>>>>>>        Property Boolean pbRecnum          True
71869>>>>>>>>>        Property Boolean pbCopyData        True
71870>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
71871>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
71872>>>>>>>>>        Property Boolean pbCompareIndexAscending False
71873>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
71874>>>>>>>>>
71874>>>>>>>>>        // Driver default value settings:
71874>>>>>>>>>        // Note: When the object is created the corresponding values
71874>>>>>>>>>        // from the driver .int files are read.
71874>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
71874>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
71875>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
71876>>>>>>>>>        Property String psDriverDefaultValueDate     ""
71877>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
71878>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
71879>>>>>>>>>        Property String psDriverDefaultValueText     ""
71880>>>>>>>>>
71880>>>>>>>>>        // Driver "nullability" settings:
71880>>>>>>>>>        // Note: When the object is created the corresponding values
71880>>>>>>>>>        // from the driver .int files are read.
71880>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
71880>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
71881>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
71882>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
71883>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
71884>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
71885>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
71886>>>>>>>>>
71886>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
71886>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
71886>>>>>>>>>        //     driver interfaces.
71886>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
71886>>>>>>>>>        //     of the struct they are all routed throu this struct property.
71886>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
71887>>>>>>>>>
71887>>>>>>>>>    End_Procedure
71888>>>>>>>>>
71888>>>>>>>>>    Procedure End_Construct_Object
71890>>>>>>>>>        tSQLConnection SQLConnection
71890>>>>>>>>>        tSQLConnection SQLConnection
71890>>>>>>>>>
71890>>>>>>>>>        Forward Send End_Construct_Object
71892>>>>>>>>>
71892>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
71892>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
71893>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
71894>>>>>>>>>    End_Procedure
71895>>>>>>>>>
71895>>>>>>>>>    // *** Properties ***
71895>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
71895>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
71895>>>>>>>>>    // merely here for conveniance.
71895>>>>>>>>>    //
71895>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
71895>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
71895>>>>>>>>>    // This struct property contains all the connection data.
71895>>>>>>>>>    //
71895>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
71897>>>>>>>>>        Boolean bOK
71897>>>>>>>>>
71897>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
71898>>>>>>>>>
71898>>>>>>>>>        // When starting a program we might not have a connection id yet:
71898>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
71900>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
71900>>>>>>>>>            Procedure_Return
71901>>>>>>>>>        End
71901>>>>>>>>>>
71901>>>>>>>>>
71901>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
71901>>>>>>>>>        // be logged in already and don't want to do it again.
71901>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
71903>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
71903>>>>>>>>>            // driver interfaces about the change & make a new login.
71903>>>>>>>>>            Get SQLLogin SQLConnection to bOK
71904>>>>>>>>>            If (bOK = False) Begin
71906>>>>>>>>>                Error DFERR_PROGRAM "Login error."
71907>>>>>>>>>>
71907>>>>>>>>>            End
71907>>>>>>>>>>
71907>>>>>>>>>        End
71907>>>>>>>>>>
71907>>>>>>>>>
71907>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
71907>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
71908>>>>>>>>>
71908>>>>>>>>>    End_Procedure
71909>>>>>>>>>
71909>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
71909>>>>>>>>>    // attempt to load the driver.
71909>>>>>>>>>    // Returns true if the passed driver is SQL based.
71909>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
71911>>>>>>>>>        Boolean bOK
71911>>>>>>>>>
71911>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
71912>>>>>>>>>        If (bOK = False) Begin
71914>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
71915>>>>>>>>>        End
71915>>>>>>>>>>
71915>>>>>>>>>
71915>>>>>>>>>        Function_Return bOK
71916>>>>>>>>>    End_Function
71917>>>>>>>>>
71917>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
71917>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
71919>>>>>>>>>        String sAttributeValue
71919>>>>>>>>>        Integer iDriverID
71919>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
71919>>>>>>>>>
71919>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
71920>>>>>>>>>        If (bSQLDriver = False) Begin
71922>>>>>>>>>            Procedure_Return
71923>>>>>>>>>        End                                      
71923>>>>>>>>>>
71923>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
71924>>>>>>>>>        If (bIsMertechDriver = True) Begin
71926>>>>>>>>>            Procedure_Return
71927>>>>>>>>>        End
71927>>>>>>>>>>
71927>>>>>>>>>        
71927>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
71928>>>>>>>>>
71928>>>>>>>>>        // Driver default values for various data types:
71928>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
71931>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
71932>>>>>>>>>
71932>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
71935>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
71936>>>>>>>>>
71936>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
71939>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
71940>>>>>>>>>
71940>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
71943>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
71944>>>>>>>>>
71944>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
71947>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
71948>>>>>>>>>
71948>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
71951>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
71952>>>>>>>>>
71952>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
71952>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
71955>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
71956>>>>>>>>>
71956>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
71959>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
71960>>>>>>>>>
71960>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
71963>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
71964>>>>>>>>>
71964>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
71967>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
71968>>>>>>>>>
71968>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
71971>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
71972>>>>>>>>>
71972>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
71975>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
71976>>>>>>>>>
71976>>>>>>>>>    End_Procedure
71977>>>>>>>>>
71977>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
71979>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
71979>>>>>>>>>        String sConnectionString
71979>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
71979>>>>>>>>>        Integer iDriverID
71979>>>>>>>>>
71979>>>>>>>>>        Move False to bOK
71980>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
71981>>>>>>>>>        If (bIsDaw = False) Begin
71983>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
71984>>>>>>>>>            If (bIsMertech = False) Begin
71986>>>>>>>>>                Function_Return False
71987>>>>>>>>>            End
71987>>>>>>>>>>
71987>>>>>>>>>        End
71987>>>>>>>>>>
71987>>>>>>>>>
71987>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
71988>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
71989>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
71990>>>>>>>>>        If (iDriverID = 0) Begin
71992>>>>>>>>>            Move hoErrorObj to Error_Object_Id
71993>>>>>>>>>            Function_Return False
71994>>>>>>>>>        End
71994>>>>>>>>>>
71994>>>>>>>>>
71994>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
71994>>>>>>>>>        If (bIsMertech = False) Begin
71996>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
71999>>>>>>>>>        End
71999>>>>>>>>>>
71999>>>>>>>>>
71999>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
72000>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
72001>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
72002>>>>>>>>>        Send Destroy   of hoDriver
72003>>>>>>>>>
72003>>>>>>>>>        Function_Return bOK
72004>>>>>>>>>    End_Function
72005>>>>>>>>>
72005>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
72007>>>>>>>>>        tSQLConnection SQLConnection
72007>>>>>>>>>        tSQLConnection SQLConnection
72007>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72008>>>>>>>>>        Function_Return SQLConnection
72009>>>>>>>>>    End_Function
72010>>>>>>>>>
72010>>>>>>>>>    Procedure Set psConnectionID String sValue
72012>>>>>>>>>        tSQLConnection SQLConnection
72012>>>>>>>>>        tSQLConnection SQLConnection
72012>>>>>>>>>
72012>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72013>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
72015>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
72016>>>>>>>>>        End
72016>>>>>>>>>>
72016>>>>>>>>>
72016>>>>>>>>>        // Else we might want to change the current connection ID
72016>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
72019>>>>>>>>>            Move False to Err
72020>>>>>>>>>            Logout SQLConnection.sDriverID
72021>>>>>>>>>            // This will also make a login to the new server.
72021>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
72022>>>>>>>>>        End
72022>>>>>>>>>>
72022>>>>>>>>>        Set pSQLConnection to SQLConnection
72023>>>>>>>>>    End_Procedure
72024>>>>>>>>>
72024>>>>>>>>>    Function psConnectionID Returns String
72026>>>>>>>>>        tSQLConnection SQLConnection
72026>>>>>>>>>        tSQLConnection SQLConnection
72026>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72027>>>>>>>>>        Function_Return SQLConnection.sConnectionID
72028>>>>>>>>>    End_Function
72029>>>>>>>>>
72029>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
72029>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
72029>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
72029>>>>>>>>>    //       for a connection string has the wrong format for that driver.
72029>>>>>>>>>    Procedure Set psDriverID String sValue
72031>>>>>>>>>        tSQLConnection SQLConnection
72031>>>>>>>>>        tSQLConnection SQLConnection
72031>>>>>>>>>        Get pSQLConnection to SQLConnection
72032>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
72033>>>>>>>>>        Set pSQLConnection to SQLConnection
72034>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
72036>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72037>>>>>>>>>        End
72037>>>>>>>>>>
72037>>>>>>>>>    End_Procedure
72038>>>>>>>>>
72038>>>>>>>>>    Function psDriverID Returns String
72040>>>>>>>>>        tSQLConnection SQLConnection
72040>>>>>>>>>        tSQLConnection SQLConnection
72040>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72041>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
72043>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
72044>>>>>>>>>        End
72044>>>>>>>>>>
72044>>>>>>>>>        Function_Return SQLConnection.sDriverID
72045>>>>>>>>>    End_Function
72046>>>>>>>>>
72046>>>>>>>>>    Procedure Set psConnectionString String sValue
72048>>>>>>>>>        tSQLConnection SQLConnection
72048>>>>>>>>>        tSQLConnection SQLConnection
72048>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72049>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
72050>>>>>>>>>        Set pSQLConnection to SQLConnection
72051>>>>>>>>>    End_Procedure
72052>>>>>>>>>
72052>>>>>>>>>    Function psConnectionString Returns String
72054>>>>>>>>>        tSQLConnection SQLConnection
72054>>>>>>>>>        tSQLConnection SQLConnection
72054>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72055>>>>>>>>>        Function_Return SQLConnection.sConnectionString
72056>>>>>>>>>    End_Function
72057>>>>>>>>>
72057>>>>>>>>>    Procedure Set psServer String sValue
72059>>>>>>>>>        tSQLConnection SQLConnection
72059>>>>>>>>>        tSQLConnection SQLConnection
72059>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72060>>>>>>>>>        Move sValue        to SQLConnection.sServer
72061>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72062>>>>>>>>>        Set pSQLConnection to SQLConnection
72063>>>>>>>>>    End_Procedure
72064>>>>>>>>>
72064>>>>>>>>>    Function psServer Returns String
72066>>>>>>>>>        tSQLConnection SQLConnection
72066>>>>>>>>>        tSQLConnection SQLConnection
72066>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72067>>>>>>>>>        Function_Return SQLConnection.sServer
72068>>>>>>>>>    End_Function
72069>>>>>>>>>
72069>>>>>>>>>    Procedure Set psDatabase String sValue
72071>>>>>>>>>        tSQLConnection SQLConnection
72071>>>>>>>>>        tSQLConnection SQLConnection
72071>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72072>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
72073>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72074>>>>>>>>>        Set pSQLConnection to SQLConnection
72075>>>>>>>>>    End_Procedure
72076>>>>>>>>>
72076>>>>>>>>>    Function psDatabase Returns String
72078>>>>>>>>>        tSQLConnection SQLConnection
72078>>>>>>>>>        tSQLConnection SQLConnection
72078>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72079>>>>>>>>>        Function_Return SQLConnection.sDatabase
72080>>>>>>>>>    End_Function
72081>>>>>>>>>
72081>>>>>>>>>    Procedure Set psUserID String sValue
72083>>>>>>>>>        tSQLConnection SQLConnection
72083>>>>>>>>>        tSQLConnection SQLConnection
72083>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72084>>>>>>>>>        Move sValue        to SQLConnection.sUserID
72085>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72086>>>>>>>>>        Set pSQLConnection to SQLConnection
72087>>>>>>>>>    End_Procedure
72088>>>>>>>>>
72088>>>>>>>>>    Function psUserID Returns String
72090>>>>>>>>>        tSQLConnection SQLConnection
72090>>>>>>>>>        tSQLConnection SQLConnection
72090>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72091>>>>>>>>>        Function_Return SQLConnection.sUserID
72092>>>>>>>>>    End_Function
72093>>>>>>>>>
72093>>>>>>>>>    // This is the uncrypted password
72093>>>>>>>>>    Procedure Set psPassword String sValue
72095>>>>>>>>>        tSQLConnection SQLConnection
72095>>>>>>>>>        tSQLConnection SQLConnection
72095>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72096>>>>>>>>>        Move sValue        to SQLConnection.sPassword
72097>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72098>>>>>>>>>        Set pSQLConnection to SQLConnection
72099>>>>>>>>>    End_Procedure
72100>>>>>>>>>
72100>>>>>>>>>    Function psPassword Returns String
72102>>>>>>>>>        tSQLConnection SQLConnection
72102>>>>>>>>>        tSQLConnection SQLConnection
72102>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72103>>>>>>>>>        Function_Return SQLConnection.sPassword
72104>>>>>>>>>    End_Function
72105>>>>>>>>>
72105>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
72107>>>>>>>>>        tSQLConnection SQLConnection
72107>>>>>>>>>        tSQLConnection SQLConnection
72107>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72108>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
72109>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
72110>>>>>>>>>        Set pSQLConnection to SQLConnection
72111>>>>>>>>>    End_Procedure
72112>>>>>>>>>
72112>>>>>>>>>    Function pbTrusted Returns Boolean
72114>>>>>>>>>        tSQLConnection SQLConnection
72114>>>>>>>>>        tSQLConnection SQLConnection
72114>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72115>>>>>>>>>        Function_Return SQLConnection.bTrusted
72116>>>>>>>>>    End_Function
72117>>>>>>>>>
72117>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
72117>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
72117>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
72117>>>>>>>>>    //     the central pSQLConnection "hub".
72117>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
72119>>>>>>>>>        tSQLConnection SQLConnection
72119>>>>>>>>>        tSQLConnection SQLConnection
72119>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72120>>>>>>>>>        Move bValue to SQLConnection.bTrusted
72121>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72122>>>>>>>>>    End_Procedure
72123>>>>>>>>>
72123>>>>>>>>>    Function pbSilentLogin Returns Boolean
72125>>>>>>>>>        tSQLConnection SQLConnection
72125>>>>>>>>>        tSQLConnection SQLConnection
72125>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72126>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
72127>>>>>>>>>    End_Function
72128>>>>>>>>>
72128>>>>>>>>>    Procedure Set piDbType Integer iValue
72130>>>>>>>>>        tSQLConnection SQLConnection
72130>>>>>>>>>        tSQLConnection SQLConnection
72130>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72131>>>>>>>>>        Move iValue to SQLConnection.iDbType
72132>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72133>>>>>>>>>    End_Procedure
72134>>>>>>>>>
72134>>>>>>>>>    Function piDbType Returns Integer
72136>>>>>>>>>        tSQLConnection SQLConnection
72136>>>>>>>>>        tSQLConnection SQLConnection
72136>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72137>>>>>>>>>        Function_Return SQLConnection.iDbType
72138>>>>>>>>>    End_Function
72139>>>>>>>>>
72139>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
72141>>>>>>>>>        tSQLConnection SQLConnection
72141>>>>>>>>>        tSQLConnection SQLConnection
72141>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72142>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
72143>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72144>>>>>>>>>    End_Procedure
72145>>>>>>>>>
72145>>>>>>>>>    Function psBaseTableSpace Returns String
72147>>>>>>>>>        tSQLConnection SQLConnection
72147>>>>>>>>>        tSQLConnection SQLConnection
72147>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72148>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
72149>>>>>>>>>    End_Function
72150>>>>>>>>>
72150>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
72152>>>>>>>>>        tSQLConnection SQLConnection
72152>>>>>>>>>        tSQLConnection SQLConnection
72152>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72153>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
72154>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72155>>>>>>>>>    End_Procedure
72156>>>>>>>>>
72156>>>>>>>>>    Function psIndexTableSpace Returns String
72158>>>>>>>>>        tSQLConnection SQLConnection
72158>>>>>>>>>        tSQLConnection SQLConnection
72158>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72159>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
72160>>>>>>>>>    End_Function
72161>>>>>>>>>
72161>>>>>>>>>    Procedure Set psLongTableSpace String sValue
72163>>>>>>>>>        tSQLConnection SQLConnection
72163>>>>>>>>>        tSQLConnection SQLConnection
72163>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72164>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
72165>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72166>>>>>>>>>    End_Procedure
72167>>>>>>>>>
72167>>>>>>>>>    Function psLongTableSpace Returns String
72169>>>>>>>>>        tSQLConnection SQLConnection
72169>>>>>>>>>        tSQLConnection SQLConnection
72169>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72170>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
72171>>>>>>>>>    End_Function
72172>>>>>>>>>
72172>>>>>>>>>    Procedure Set psSchema String sValue
72174>>>>>>>>>        tSQLConnection SQLConnection
72174>>>>>>>>>        tSQLConnection SQLConnection
72174>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72175>>>>>>>>>        Move sValue to SQLConnection.sSchema
72176>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72177>>>>>>>>>    End_Procedure
72178>>>>>>>>>
72178>>>>>>>>>    Function psSchema Returns String
72180>>>>>>>>>        tSQLConnection SQLConnection
72180>>>>>>>>>        tSQLConnection SQLConnection
72180>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72181>>>>>>>>>        Function_Return SQLConnection.sSchema
72182>>>>>>>>>    End_Function
72183>>>>>>>>>
72183>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
72185>>>>>>>>>        tSQLConnection SQLConnection
72185>>>>>>>>>        tSQLConnection SQLConnection
72185>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72186>>>>>>>>>        Move bValue to SQLConnection.bEnabled
72187>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
72188>>>>>>>>>    End_Procedure
72189>>>>>>>>>
72189>>>>>>>>>    Function pbEnabled Returns Boolean
72191>>>>>>>>>        tSQLConnection SQLConnection
72191>>>>>>>>>        tSQLConnection SQLConnection
72191>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
72192>>>>>>>>>        Function_Return SQLConnection.bEnabled
72193>>>>>>>>>    End_Function
72194>>>>>>>>>
72194>>>>>>>>>
72194>>>>>>>>>    // ************************************
72194>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
72196>>>>>>>>>        tSQLConnection SQLConnection
72196>>>>>>>>>        tSQLConnection SQLConnection
72196>>>>>>>>>
72196>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
72196>>>>>>>>>        // deferr reading SQL connection values until later.
72196>>>>>>>>>        If (bReadDFConnSettings = True) Begin
72198>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
72198>>>>>>>>>            If (ghoConnection > 0) Begin
72200>>>>>>>>>                Get ReadcConnections to SQLConnection
72201>>>>>>>>>            End
72201>>>>>>>>>>
72201>>>>>>>>>
72201>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
72201>>>>>>>>>            // object is used.
72201>>>>>>>>>            If (bReadSQLConnections = True) Begin
72203>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
72204>>>>>>>>>            End
72204>>>>>>>>>>
72204>>>>>>>>>        End
72204>>>>>>>>>>
72204>>>>>>>>>
72204>>>>>>>>>        Function_Return SQLConnection
72205>>>>>>>>>    End_Function
72206>>>>>>>>>
72206>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
72206>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
72208>>>>>>>>>        tConnection Connection
72208>>>>>>>>>        tConnection Connection
72208>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
72208>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
72208>>>>>>>>>        Integer iRetval iDbType
72208>>>>>>>>>        Boolean bOK bConnected
72208>>>>>>>>>        String sConnectionID
72208>>>>>>>>>
72208>>>>>>>>>            tConnection[] Connections
72208>>>>>>>>>            tConnection[] Connections
72209>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
72209>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
72209>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
72209>>>>>>>>>            //   we then generate an error and abort the program...
72209>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
72210>>>>>>>>>            If (bOK = False) Begin
72212>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
72213>>>>>>>>>>
72213>>>>>>>>>                Abort
72214>>>>>>>>>>
72214>>>>>>>>>            End
72214>>>>>>>>>>
72214>>>>>>>>>            If (sConnectionID = "") Begin
72216>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
72217>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
72219>>>>>>>>>                    Move Connections[0].sId to sConnectionID
72220>>>>>>>>>                End
72220>>>>>>>>>>
72220>>>>>>>>>            End
72220>>>>>>>>>>
72220>>>>>>>>>
72220>>>>>>>>>            Move 0 to iRetval
72221>>>>>>>>>            // DAW DF19 connection info:
72221>>>>>>>>>            // We first check that the connection is OK:
72221>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
72222>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
72222>>>>>>>>>            If (iRetval = -1) Begin
72224>>>>>>>>>                Function_Return SQLConnectionEmpty
72225>>>>>>>>>            End
72225>>>>>>>>>>
72225>>>>>>>>>
72225>>>>>>>>>            If (sConnectionID <> "") Begin
72227>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
72228>>>>>>>>>            End
72228>>>>>>>>>>
72228>>>>>>>>>            If (Connection.sId = "") Begin
72230>>>>>>>>>                Move True to SQLConnectionEmpty.bError
72231>>>>>>>>>                Function_Return SQLConnectionEmpty
72232>>>>>>>>>            End
72232>>>>>>>>>>
72232>>>>>>>>>
72232>>>>>>>>>            // DUF connection info struct property:
72232>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
72233>>>>>>>>>
72233>>>>>>>>>            Move Connection.sId to sConnectionID
72234>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
72235>>>>>>>>>
72235>>>>>>>>>            If (bConnected = False) Begin
72237>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
72238>>>>>>>>>                If (iRetval <> 0) Begin
72240>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
72241>>>>>>>>>                    Send Exit_Application
72242>>>>>>>>>                End
72242>>>>>>>>>>
72242>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
72243>>>>>>>>>                // We need to get the DAW connection info again as it might have
72243>>>>>>>>>                // been changed in the DAW db login dialog.
72243>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
72244>>>>>>>>>            End
72244>>>>>>>>>>
72244>>>>>>>>>
72244>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
72245>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
72246>>>>>>>>>
72246>>>>>>>>>            // Not used in DUF:
72246>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
72246>>>>>>>>>
72246>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
72247>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
72248>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
72249>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
72250>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
72251>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
72252>>>>>>>>>
72252>>>>>>>>>            // Not used in DUF:
72252>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
72252>>>>>>>>>
72252>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
72252>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
72252>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
72254>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
72255>>>>>>>>>            End
72255>>>>>>>>>>
72255>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
72257>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
72258>>>>>>>>>                If (SQLConnection.sServer = "") Begin
72260>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
72261>>>>>>>>>                End
72261>>>>>>>>>>
72261>>>>>>>>>            End
72261>>>>>>>>>>
72261>>>>>>>>>
72261>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
72262>>>>>>>>>
72262>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
72262>>>>>>>>>            // the value from the driver id:
72262>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
72263>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
72263>>>>>>>>>            Get piDbType                                     to iDbType
72264>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
72266>>>>>>>>>                Move iDbType to SQLConnection.iDbType
72267>>>>>>>>>            End
72267>>>>>>>>>>
72267>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
72268>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
72269>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
72270>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
72271>>>>>>>>>
72271>>>>>>>>>            // We finally set the struct property to the newly fetched values.
72271>>>>>>>>>            Set pSQLConnection to SQLConnection
72272>>>>>>>>>
72272>>>>>>>>>        Function_Return SQLConnection
72273>>>>>>>>>    End_Function
72274>>>>>>>>>
72274>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
72274>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
72274>>>>>>>>>    // connection id for a particular driver.
72274>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
72274>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
72274>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
72274>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
72274>>>>>>>>>    // connections of the DAW cConnect class.
72274>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
72276>>>>>>>>>        tConnection[] ConnIdArray
72276>>>>>>>>>        tConnection[] ConnIdArray
72277>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
72277>>>>>>>>>        Boolean bEnabled bFound
72277>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
72277>>>>>>>>>
72277>>>>>>>>>        Move False to bFound
72278>>>>>>>>>        If (ghoConnection > 0) Begin
72280>>>>>>>>>
72280>>>>>>>>>            // The property of the cDbUpdateHandler container object
72280>>>>>>>>>            Get psDriverID to sDriverID
72281>>>>>>>>>
72281>>>>>>>>>            Move 0 to iConnectionIDCounter
72282>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
72282>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
72283>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
72284>>>>>>>>>            Decrement iSize
72285>>>>>>>>>            For iCount from 0 to iSize
72291>>>>>>>>>>
72291>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
72292>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
72293>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
72294>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
72294>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
72294>>>>>>>>>                If (sConnectionID = "") Begin
72296>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
72297>>>>>>>>>                End
72297>>>>>>>>>>
72297>>>>>>>>>                Else Begin
72298>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
72300>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
72301>>>>>>>>>                    End
72301>>>>>>>>>>
72301>>>>>>>>>                End
72301>>>>>>>>>>
72301>>>>>>>>>
72301>>>>>>>>>                If (bFound = True) Begin
72303>>>>>>>>>                    Increment iConnectionIDCounter
72304>>>>>>>>>                End
72304>>>>>>>>>>
72304>>>>>>>>>            Loop
72305>>>>>>>>>>
72305>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
72306>>>>>>>>>            If (bFound = True) Begin
72308>>>>>>>>>                Move sConnectionID2 to sConnectionID
72309>>>>>>>>>            End
72309>>>>>>>>>>
72309>>>>>>>>>        End
72309>>>>>>>>>>
72309>>>>>>>>>
72309>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
72309>>>>>>>>>        // but no DFConn.ini record has been created.
72309>>>>>>>>>        If (iSize = -1) Begin
72311>>>>>>>>>            Move True to bFound
72312>>>>>>>>>        End
72312>>>>>>>>>>
72312>>>>>>>>>
72312>>>>>>>>>        Function_Return bFound
72313>>>>>>>>>    End_Function
72314>>>>>>>>>
72314>>>>>>>>>    // Send on object creation to read the default connection string settings, and
72314>>>>>>>>>    // create a connection to the server.
72314>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
72316>>>>>>>>>        String sPath sFileName
72316>>>>>>>>>        Boolean bExists bActive
72316>>>>>>>>>        tSQLConnection[] SQLConnectionArray
72316>>>>>>>>>        tSQLConnection[] SQLConnectionArray
72317>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
72317>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
72317>>>>>>>>>        Handle hoIniFile
72317>>>>>>>>>        Integer iSize iCount iRetval
72317>>>>>>>>>
72317>>>>>>>>>        Get psIniFilePath to sPath
72318>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
72319>>>>>>>>>        If (sPath = "") Begin
72321>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
72322>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
72323>>>>>>>>>        End
72323>>>>>>>>>>
72323>>>>>>>>>        Get vFolderFormat sPath to sPath
72324>>>>>>>>>        Get psIniFileName to sFileName
72325>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
72326>>>>>>>>>
72326>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
72327>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
72328>>>>>>>>>        If (iSize = 0) Begin
72330>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
72330>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
72330>>>>>>>>>            // in the cApplication object.
72330>>>>>>>>>            Get pSQLConnection to SQLConnection
72331>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
72333>>>>>>>>>                Function_Return SQLConnectionEmpty
72334>>>>>>>>>            End
72334>>>>>>>>>>
72334>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
72335>>>>>>>>>            Move 1 to iSize
72336>>>>>>>>>        End
72336>>>>>>>>>>
72336>>>>>>>>>
72336>>>>>>>>>        Move False to bActive
72337>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
72337>>>>>>>>>        Decrement iSize
72338>>>>>>>>>        For iCount from 0 to iSize
72344>>>>>>>>>>
72344>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
72345>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
72347>>>>>>>>>                Move True to bActive
72348>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
72349>>>>>>>>>            End
72349>>>>>>>>>>
72349>>>>>>>>>        Loop
72350>>>>>>>>>>
72350>>>>>>>>>
72350>>>>>>>>>        // In case all connections have been disabled, we're out of here.
72350>>>>>>>>>        If (bActive = False) Begin
72352>>>>>>>>>            Function_Return SQLConnectionEmpty
72353>>>>>>>>>        End
72353>>>>>>>>>>
72353>>>>>>>>>
72353>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
72354>>>>>>>>>
72354>>>>>>>>>        Set pSQLConnection to SQLConnection
72355>>>>>>>>>        Get AutoSetConnectionID to iRetval
72356>>>>>>>>>
72356>>>>>>>>>        Function_Return SQLConnection
72357>>>>>>>>>    End_Function
72358>>>>>>>>>
72358>>>>>>>>>    Procedure Set psIniFilePath String sPath
72360>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
72361>>>>>>>>>    End_Procedure
72362>>>>>>>>>
72362>>>>>>>>>    Function psIniFilePath Returns String
72364>>>>>>>>>        String sRetval
72364>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
72365>>>>>>>>>        Function_Return sRetval
72366>>>>>>>>>    End_Function
72367>>>>>>>>>
72367>>>>>>>>>    Procedure Set psIniFileName String sFileName
72369>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
72370>>>>>>>>>    End_Procedure
72371>>>>>>>>>
72371>>>>>>>>>    Function psIniFileName Returns String
72373>>>>>>>>>        String sRetval
72373>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
72374>>>>>>>>>        Function_Return sRetval
72375>>>>>>>>>    End_Function
72376>>>>>>>>>
72376>>>>>>>>>    Procedure Set psIniSectionName String sSection
72378>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
72379>>>>>>>>>    End_Procedure
72380>>>>>>>>>
72380>>>>>>>>>    Function psIniSectionName Returns String
72382>>>>>>>>>        String sRetval
72382>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
72383>>>>>>>>>        Function_Return sRetval
72384>>>>>>>>>    End_Function
72385>>>>>>>>>
72385>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
72387>>>>>>>>>        Handle ho
72387>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72388>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
72389>>>>>>>>>    End_Procedure
72390>>>>>>>>>
72390>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
72392>>>>>>>>>        Handle ho
72392>>>>>>>>>        String sRetval
72392>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72393>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
72394>>>>>>>>>        Function_Return sRetval
72395>>>>>>>>>    End_Function
72396>>>>>>>>>
72396>>>>>>>>>    Function SectionExists String sSection Returns Boolean
72398>>>>>>>>>        Handle ho
72398>>>>>>>>>        Boolean bRetval
72398>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72399>>>>>>>>>        Get SectionExists of ho sSection to bRetval
72400>>>>>>>>>        Function_Return bRetval
72401>>>>>>>>>    End_Function
72402>>>>>>>>>
72402>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
72404>>>>>>>>>        Handle ho
72404>>>>>>>>>        Boolean bRetval
72404>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72405>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
72406>>>>>>>>>        Function_Return bRetval
72407>>>>>>>>>    End_Function
72408>>>>>>>>>
72408>>>>>>>>>    Function EncryptPassword String sPassword Returns String
72410>>>>>>>>>        Handle ho
72410>>>>>>>>>        String sRetval
72410>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72411>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
72412>>>>>>>>>        Function_Return sRetval
72413>>>>>>>>>    End_Function
72414>>>>>>>>>
72414>>>>>>>>>    Function DecryptPassword String sPassword Returns String
72416>>>>>>>>>        Handle ho
72416>>>>>>>>>        String sRetval
72416>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72417>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
72418>>>>>>>>>        Function_Return sRetval
72419>>>>>>>>>    End_Function
72420>>>>>>>>>
72420>>>>>>>>>    // *** Main Connection Message ***
72420>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
72422>>>>>>>>>        Handle hoDriver
72422>>>>>>>>>        String sConnectionString sError
72422>>>>>>>>>        Boolean bLoginSuccessful
72422>>>>>>>>>
72422>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
72423>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
72424>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
72425>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
72426>>>>>>>>>        If (bLoginSuccessful = False) Begin
72428>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
72429>>>>>>>>>>
72429>>>>>>>>>            If (bExitProgram = True) Begin
72431>>>>>>>>>                Send Exit_Application
72432>>>>>>>>>            End
72432>>>>>>>>>>
72432>>>>>>>>>        End
72432>>>>>>>>>>
72432>>>>>>>>>        Send Destroy of hoDriver
72433>>>>>>>>>    End_Procedure
72434>>>>>>>>>
72434>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
72436>>>>>>>>>        Integer iRetval
72436>>>>>>>>>        Handle hoCLI
72436>>>>>>>>>        String sDriverID
72436>>>>>>>>>
72436>>>>>>>>>        Get psDriverID to sDriverID
72437>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
72438>>>>>>>>>        If (hoCLI <> 0) Begin
72440>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
72441>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
72442>>>>>>>>>            Send Destroy of hoCLI
72443>>>>>>>>>        End
72443>>>>>>>>>>
72443>>>>>>>>>
72443>>>>>>>>>        Function_Return iRetval
72444>>>>>>>>>    End_Function
72445>>>>>>>>>
72445>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
72447>>>>>>>>>        tSQLConnection SQLConnection
72447>>>>>>>>>        tSQLConnection SQLConnection
72447>>>>>>>>>
72447>>>>>>>>>        Set psDriverID to sDriverID
72448>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
72449>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
72450>>>>>>>>>    End_Procedure
72451>>>>>>>>>
72451>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
72451>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
72451>>>>>>>>>    // or the one in the DataFlex Bin folder.)
72451>>>>>>>>>    // We then need to delete the current one before creating a new one.
72451>>>>>>>>>    // This is because the parameters may differ between the program code and the
72451>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
72451>>>>>>>>>    // when one tries to create a Connection ID that already exists.
72451>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
72453>>>>>>>>>        Integer iResult iDriver iNumConn iConn
72453>>>>>>>>>        Handle hoCLI
72453>>>>>>>>>        String sID
72453>>>>>>>>>
72453>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
72455>>>>>>>>>            Procedure_Return
72456>>>>>>>>>        End
72456>>>>>>>>>>
72456>>>>>>>>>
72456>>>>>>>>>        Move 0 to iResult
72457>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
72458>>>>>>>>>        If (hoCLI <> 0) Begin
72460>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
72461>>>>>>>>>            Get DriverIndex sDriverID to iDriver
72462>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
72465>>>>>>>>>            Decrement iNumConn
72466>>>>>>>>>            For iConn from 0 to iNumConn
72472>>>>>>>>>>
72472>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
72475>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
72477>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
72478>>>>>>>>>                End
72478>>>>>>>>>>
72478>>>>>>>>>            Loop
72479>>>>>>>>>>
72479>>>>>>>>>            Send Destroy of hoCLI
72480>>>>>>>>>        End
72480>>>>>>>>>>
72480>>>>>>>>>
72480>>>>>>>>>    End_Procedure
72481>>>>>>>>>
72481>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
72483>>>>>>>>>        Integer iResult iDriver iNumConn iConn
72483>>>>>>>>>        Handle hoCLI
72483>>>>>>>>>        String sID sConnectionString sVal sDatabase
72483>>>>>>>>>        tSQLConnection SQLConnection
72483>>>>>>>>>        tSQLConnection SQLConnection
72483>>>>>>>>>        Boolean bTrusted
72483>>>>>>>>>
72483>>>>>>>>>        Move 0 to iResult
72484>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
72485>>>>>>>>>        If (hoCLI <> 0) Begin
72487>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
72488>>>>>>>>>            Get DriverIndex sDriverID to iDriver
72489>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
72492>>>>>>>>>            Decrement iNumConn
72493>>>>>>>>>            For iConn from 0 to iNumConn
72499>>>>>>>>>>
72499>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
72502>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
72504>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
72505>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
72508>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
72511>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
72512>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
72515>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
72516>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
72517>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
72518>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
72519>>>>>>>>>
72519>>>>>>>>>                    Case Begin
72519>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
72521>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
72522>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
72523>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
72524>>>>>>>>>                            Case Break
72525>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
72528>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
72529>>>>>>>>>                            Case Break
72530>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
72533>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
72534>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
72536>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
72537>>>>>>>>>                            End
72537>>>>>>>>>>
72537>>>>>>>>>                            Case Break
72538>>>>>>>>>                        Case (sDriverID = SQLFLEX)
72541>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
72542>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
72543>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
72545>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
72546>>>>>>>>>                            End
72546>>>>>>>>>>
72546>>>>>>>>>                            Else Begin
72547>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
72548>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
72549>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
72550>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
72551>>>>>>>>>                            End
72551>>>>>>>>>>
72551>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
72552>>>>>>>>>                            Case Break
72553>>>>>>>>>                        Case (sDriverID = MDSMySQL)
72556>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
72557>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
72558>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
72560>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
72561>>>>>>>>>                            End
72561>>>>>>>>>>
72561>>>>>>>>>                            Else Begin
72562>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
72563>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
72564>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
72565>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
72566>>>>>>>>>                            End
72566>>>>>>>>>>
72566>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
72567>>>>>>>>>                            Case Break
72568>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
72571>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
72572>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
72573>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
72575>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
72576>>>>>>>>>                            End
72576>>>>>>>>>>
72576>>>>>>>>>                            Else Begin
72577>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
72578>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
72579>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
72580>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
72581>>>>>>>>>                            End
72581>>>>>>>>>>
72581>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
72582>>>>>>>>>                            Case Break
72583>>>>>>>>>
72583>>>>>>>>>                        Case (sDriverID = ORAFLEX)
72586>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
72587>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
72588>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
72589>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
72591>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
72592>>>>>>>>>                            End
72592>>>>>>>>>>
72592>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
72594>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
72595>>>>>>>>>                            End
72595>>>>>>>>>>
72595>>>>>>>>>                            Else Begin
72596>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
72597>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
72598>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
72599>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
72600>>>>>>>>>                            End
72600>>>>>>>>>>
72600>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
72601>>>>>>>>>                            Case Break
72602>>>>>>>>>                        Case Else
72602>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
72603>>>>>>>>>>
72603>>>>>>>>>                            Case Break
72604>>>>>>>>>                    Case End
72604>>>>>>>>>                End
72604>>>>>>>>>>
72604>>>>>>>>>            Loop
72605>>>>>>>>>>
72605>>>>>>>>>            Send Destroy of hoCLI
72606>>>>>>>>>        End
72606>>>>>>>>>>
72606>>>>>>>>>
72606>>>>>>>>>        Function_Return SQLConnection
72607>>>>>>>>>    End_Function
72608>>>>>>>>>
72608>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
72610>>>>>>>>>        String  sCurrentDriver
72610>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
72610>>>>>>>>>
72610>>>>>>>>>        Move 0 to iDriver
72611>>>>>>>>>        Move 0 to iCount
72612>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
72615>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
72621>>>>>>>>>>
72621>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
72624>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
72626>>>>>>>>>                Function_Return iCount
72627>>>>>>>>>            End
72627>>>>>>>>>>
72627>>>>>>>>>        Loop
72628>>>>>>>>>>
72628>>>>>>>>>
72628>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
72628>>>>>>>>>        If (iDriver = 0) Begin
72630>>>>>>>>>            Move 0 to LastErr
72631>>>>>>>>>            Load_Driver sDriverID
72632>>>>>>>>>            // If driver could not be loaded.
72632>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
72634>>>>>>>>>                Move -1 to iCount
72635>>>>>>>>>            End
72635>>>>>>>>>>
72635>>>>>>>>>        End
72635>>>>>>>>>>
72635>>>>>>>>>        Function_Return iCount
72636>>>>>>>>>    End_Function
72637>>>>>>>>>
72637>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
72637>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
72639>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
72639>>>>>>>>>        Boolean bTrusted bSilent
72639>>>>>>>>>        Integer iRetval
72639>>>>>>>>>
72639>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
72640>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
72641>>>>>>>>>        Move SQLConnection.sServer       to sServer
72642>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
72643>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
72644>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
72645>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
72646>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
72647>>>>>>>>>
72647>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
72648>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
72648>>>>>>>>>        Get AutoSetConnectionID to iRetval
72649>>>>>>>>>    End_Procedure
72650>>>>>>>>>
72650>>>>>>>>>    // Called when the object is constructed.
72650>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
72650>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
72650>>>>>>>>>    // the database is needed.
72650>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
72652>>>>>>>>>        String sConnectionID sDriverID sConnectionString
72652>>>>>>>>>        Integer iDriver iRetval
72652>>>>>>>>>        Handle hoCLI
72652>>>>>>>>>        Boolean bOK bSilent bMertechDriver
72652>>>>>>>>>
72652>>>>>>>>>        Get pbSilentLogin      to bSilent
72653>>>>>>>>>        Get psConnectionID     to sConnectionID
72654>>>>>>>>>        Get psConnectionString to sConnectionString
72655>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
72655>>>>>>>>>        Get psDriverID to sDriverID
72656>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
72657>>>>>>>>>        If (bOK = False) Begin
72659>>>>>>>>>            Function_Return False
72660>>>>>>>>>        End
72660>>>>>>>>>>
72660>>>>>>>>>
72660>>>>>>>>>        // Mertech drivers can't use connection ID's.
72660>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
72661>>>>>>>>>        If (bMertechDriver = True) Begin
72663>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
72663>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
72663>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
72664>>>>>>>>>            Function_Return (hoCLI <> 0)
72665>>>>>>>>>        End
72665>>>>>>>>>>
72665>>>>>>>>>
72665>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
72666>>>>>>>>>        // If driver not loaded; load it.
72666>>>>>>>>>        If (iDriver = 0) Begin
72668>>>>>>>>>            Load_Driver sDriverID
72669>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
72670>>>>>>>>>        End
72670>>>>>>>>>>
72670>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
72670>>>>>>>>>        If (iDriver = 0) Begin
72672>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
72673>>>>>>>>>>
72673>>>>>>>>>            Function_Return False
72674>>>>>>>>>        End           
72674>>>>>>>>>>
72674>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
72677>>>>>>>>>        
72677>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
72678>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
72679>>>>>>>>>        // Delete the connection first; in case it exists
72679>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
72680>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
72681>>>>>>>>>        Send Destroy of hoCLI
72682>>>>>>>>>
72682>>>>>>>>>        Function_Return (iRetval = 0)
72683>>>>>>>>>    End_Function
72684>>>>>>>>>
72684>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
72684>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
72684>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
72684>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
72684>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
72684>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
72686>>>>>>>>>        Handle hoSQLHandler
72686>>>>>>>>>        String sDriverID sServer sDatabase
72686>>>>>>>>>
72686>>>>>>>>>        Move 0 to hoSQLHandler
72687>>>>>>>>>        Get psDriverID to sDriverID
72688>>>>>>>>>        Get psServer   to sServer
72689>>>>>>>>>        Get psDatabase to sDatabase
72690>>>>>>>>>
72690>>>>>>>>>        Function_Return hoSQLHandler
72691>>>>>>>>>    End_Function
72692>>>>>>>>>
72692>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
72694>>>>>>>>>        Boolean bOK bMertechDriver
72694>>>>>>>>>
72694>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
72695>>>>>>>>>
72695>>>>>>>>>        If (bOK = False) Begin
72697>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
72698>>>>>>>>>        End
72698>>>>>>>>>>
72698>>>>>>>>>
72698>>>>>>>>>        If (bOK = False) Begin
72700>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
72701>>>>>>>>>            If (bMertechDriver = True) Begin
72703>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
72704>>>>>>>>>>
72704>>>>>>>>>            End
72704>>>>>>>>>>
72704>>>>>>>>>            Else Begin
72705>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
72706>>>>>>>>>>
72706>>>>>>>>>            End
72706>>>>>>>>>>
72706>>>>>>>>>            Function_Return False
72707>>>>>>>>>        End
72707>>>>>>>>>>
72707>>>>>>>>>
72707>>>>>>>>>        Function_Return True
72708>>>>>>>>>    End_Function
72709>>>>>>>>>
72709>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
72711>>>>>>>>>        Boolean bOK
72711>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
72712>>>>>>>>>        Function_Return bOK
72713>>>>>>>>>    End_Function
72714>>>>>>>>>
72714>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
72716>>>>>>>>>        Boolean bOK
72716>>>>>>>>>        Move False to bOK
72717>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
72717>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
72718>>>>>>>>>//        #ENDIF
72718>>>>>>>>>        Function_Return bOK
72719>>>>>>>>>    End_Function
72720>>>>>>>>>
72720>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
72722>>>>>>>>>        Handle hoIniFile
72722>>>>>>>>>        String sConnect
72722>>>>>>>>>
72722>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
72723>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
72724>>>>>>>>>
72724>>>>>>>>>        Function_Return sConnect
72725>>>>>>>>>    End_Function
72726>>>>>>>>>
72726>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
72726>>>>>>>>>    // Pass a complete driver connection string
72726>>>>>>>>>    // Returns the following as a struct:
72726>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
72726>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
72726>>>>>>>>>    //
72726>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
72728>>>>>>>>>        tSQLConnection SQLConnection
72728>>>>>>>>>        tSQLConnection SQLConnection
72728>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
72728>>>>>>>>>        Boolean bTrusted bSilent bOK
72728>>>>>>>>>        Integer iPos
72728>>>>>>>>>
72728>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
72729>>>>>>>>>        If (bOK = False) Begin
72731>>>>>>>>>            Function_Return SQLConnection
72732>>>>>>>>>        End
72732>>>>>>>>>>
72732>>>>>>>>>
72732>>>>>>>>>        Move False to bTrusted
72733>>>>>>>>>        Move False to bSilent
72734>>>>>>>>>
72734>>>>>>>>>        Case Begin
72734>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
72736>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
72737>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
72738>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
72739>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
72740>>>>>>>>>                If (bTrusted = False) Begin
72742>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
72743>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
72744>>>>>>>>>                End
72744>>>>>>>>>>
72744>>>>>>>>>                Case Break
72745>>>>>>>>>
72745>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
72748>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
72750>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
72751>>>>>>>>>                End
72751>>>>>>>>>>
72751>>>>>>>>>                Else Begin
72752>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
72753>>>>>>>>>                End
72753>>>>>>>>>>
72753>>>>>>>>>
72753>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
72754>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
72755>>>>>>>>>                If (bTrusted = False) Begin
72757>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
72758>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
72759>>>>>>>>>                End
72759>>>>>>>>>>
72759>>>>>>>>>                Case Break
72760>>>>>>>>>
72760>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
72763>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
72764>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
72765>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
72766>>>>>>>>>                Case Break
72767>>>>>>>>>
72767>>>>>>>>>            Case (sDriverID = SQLFLEX)
72770>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
72771>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
72772>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
72773>>>>>>>>>                If (bTrusted = False) Begin
72775>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
72776>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
72777>>>>>>>>>                End
72777>>>>>>>>>>
72777>>>>>>>>>                Case Break
72778>>>>>>>>>
72778>>>>>>>>>            Case (sDriverID = ORAFLEX)
72781>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
72782>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
72783>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
72785>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
72786>>>>>>>>>                End
72786>>>>>>>>>>
72786>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
72787>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
72788>>>>>>>>>                Case Break
72789>>>>>>>>>
72789>>>>>>>>>            Case (sDriverID = MDSPgSQL)
72792>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
72793>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
72794>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
72795>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
72796>>>>>>>>>                Case Break
72797>>>>>>>>>
72797>>>>>>>>>            Case (sDriverID = MDSMySQL)
72800>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
72801>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
72802>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
72803>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
72804>>>>>>>>>                Case Break
72805>>>>>>>>>
72805>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
72808>>>>>>>>>                Break
72809>>>>>>>>>        Case End
72809>>>>>>>>>
72809>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
72810>>>>>>>>>
72810>>>>>>>>>        // bSilent?
72810>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
72811>>>>>>>>>        If (iPos = 0) Begin
72813>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
72814>>>>>>>>>        End
72814>>>>>>>>>>
72814>>>>>>>>>        If (iPos = 0) Begin
72816>>>>>>>>>            Move "0"                                                            to sValue
72817>>>>>>>>>        End
72817>>>>>>>>>>
72817>>>>>>>>>        Else Begin
72818>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
72819>>>>>>>>>        End
72819>>>>>>>>>>
72819>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
72820>>>>>>>>>
72820>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
72821>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
72822>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
72823>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
72824>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
72825>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
72826>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
72827>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
72828>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
72829>>>>>>>>>
72829>>>>>>>>>        Function_Return SQLConnection
72830>>>>>>>>>    End_Function
72831>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
72831>>>>>>>>>>
72831>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
72833>>>>>>>>>>    Integer iStart iEnd
72833>>>>>>>>>>    String sRetval
72833>>>>>>>>>>
72833>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
72834>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
72835>>>>>>>>>>    If (iStart = 0) Begin
72837>>>>>>>>>>        Function_Return ""
72838>>>>>>>>>>    End
72838>>>>>>>>>>>
72838>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
72839>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
72840>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
72842>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
72843>>>>>>>>>>    End
72843>>>>>>>>>>>
72843>>>>>>>>>>    Else Begin
72844>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
72845>>>>>>>>>>    End
72845>>>>>>>>>>>
72845>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
72847>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
72848>>>>>>>>>>        Decrement iEnd
72849>>>>>>>>>>    End
72849>>>>>>>>>>>
72849>>>>>>>>>>    If (iEnd <> 0) Begin
72851>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
72852>>>>>>>>>>    End
72852>>>>>>>>>>>
72852>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
72853>>>>>>>>>>
72853>>>>>>>>>>    Function_Return (Trim(sRetval))
72854>>>>>>>>>>End_Function
72855>>>>>>>>>>
72855>>>>>>>>>>
72855>>>>>>>>>
72855>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
72855>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
72857>>>>>>>>>        Handle ho
72857>>>>>>>>>        Integer iIndex
72857>>>>>>>>>        Boolean bRetval bOK
72857>>>>>>>>>        tSQLConnection SQLConnection
72857>>>>>>>>>        tSQLConnection SQLConnection
72857>>>>>>>>>
72857>>>>>>>>>        Get pSQLConnection to SQLConnection
72858>>>>>>>>>        Get phoSQLConnectionIniFile to ho
72859>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
72860>>>>>>>>>        If (iIndex = -1) Begin
72862>>>>>>>>>            Function_Return False
72863>>>>>>>>>        End
72863>>>>>>>>>>
72863>>>>>>>>>
72863>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
72864>>>>>>>>>        Send UpdateConnectionString SQLConnection
72865>>>>>>>>>        If (ghoConnection > 0) Begin
72867>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
72868>>>>>>>>>            If (iIndex <> -1) Begin
72870>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
72871>>>>>>>>>            End
72871>>>>>>>>>>
72871>>>>>>>>>        End
72871>>>>>>>>>>
72871>>>>>>>>>
72871>>>>>>>>>        Function_Return bRetval
72872>>>>>>>>>    End_Function
72873>>>>>>>>>
72873>>>>>>>>>End_Class
72874>>>>>>>Use vWin32fh.pkg
72874>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
72874>>>>>>>>>
72874>>>>>>>>>Use LanguageText.pkg
72874>>>>>>>>>Use Windows.pkg
72874>>>>>>>>>Use Dfclient.pkg
72874>>>>>>>>>Use DFbitmap.pkg
72874>>>>>>>>>Use GlobalFunctionsProcedures.pkg
72874>>>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
72874>>>>>>>>>>>Use Windows.pkg
72874>>>>>>>>>>>Use cEdit_Mixin.pkg
72874>>>>>>>>>>>
72874>>>>>>>>>>>// constants used for RichEdit Properties
72874>>>>>>>>>>>// peAlignment
72874>>>>>>>>>>>Enum_List
72874>>>>>>>>>>>    Define alLeft   for 1
72874>>>>>>>>>>>    Define alRight  for 2
72874>>>>>>>>>>>    Define alCenter for 3
72874>>>>>>>>>>>End_Enum_List
72874>>>>>>>>>>>
72874>>>>>>>>>>>// peBullets
72874>>>>>>>>>>>Enum_List
72874>>>>>>>>>>>    Define buNone
72874>>>>>>>>>>>    Define buBullets
72874>>>>>>>>>>>    Define buArabicNumbers
72874>>>>>>>>>>>    Define buLowerLetters
72874>>>>>>>>>>>    Define buUpperLetters
72874>>>>>>>>>>>    Define buLowerRomans
72874>>>>>>>>>>>    Define buUpperRomans
72874>>>>>>>>>>>End_Enum_List
72874>>>>>>>>>>>
72874>>>>>>>>>>>// peBulletStyle
72874>>>>>>>>>>>Enum_List
72874>>>>>>>>>>>    Define busRightParen   for 0
72874>>>>>>>>>>>    Define busEncloseParen for 256
72874>>>>>>>>>>>    Define busPeriod       for 512
72874>>>>>>>>>>>    Define busNumberOnly   for 768
72874>>>>>>>>>>>    Define busNoDisplay    for 1024
72874>>>>>>>>>>>End_Enum_List
72874>>>>>>>>>>>
72874>>>>>>>>>>>// peLineSpacingType
72874>>>>>>>>>>>Enum_List
72874>>>>>>>>>>>    Define lstSingle
72874>>>>>>>>>>>    Define lstSingleAndOneHalf
72874>>>>>>>>>>>    Define lstDouble
72874>>>>>>>>>>>End_Enum_List
72874>>>>>>>>>>>
72874>>>>>>>>>>>Class cRichEdit is a DFBaseRichEdit
72875>>>>>>>>>>>    
72875>>>>>>>>>>>    Procedure Construct_Object
72877>>>>>>>>>>>        Forward Send Construct_Object
72879>>>>>>>>>>>        Send Define_cEdit_Mixin
72880>>>>>>>>>>>        
72880>>>>>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
72881>>>>>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
72882>>>>>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
72883>>>>>>>>>>>        
72883>>>>>>>>>>>    End_Procedure
72884>>>>>>>>>>>    
72884>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
72885>>>>>>>>>>>    
72885>>>>>>>>>>>    Procedure ToggleBold
72887>>>>>>>>>>>        Set pbBold to (not(pbBold(Self)))
72888>>>>>>>>>>>    End_Procedure
72889>>>>>>>>>>>    
72889>>>>>>>>>>>    Procedure ToggleItalics
72891>>>>>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
72892>>>>>>>>>>>    End_Procedure
72893>>>>>>>>>>>    
72893>>>>>>>>>>>    Procedure ToggleUnderline
72895>>>>>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
72896>>>>>>>>>>>    End_Procedure
72897>>>>>>>>>>>    
72897>>>>>>>>>>>End_Class
72898>>>>>>>>>>>
72898>>>>>>>>>>>
72898>>>>>>>>>Use cTextEdit.pkg
72898>>>>>>>>>Use cRichEdit.pkg
72898>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
72898>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
72898>>>>>>>>>>>>>Use VDFBase.pkg
72898>>>>>>>>>>>>>
72898>>>>>>>>>>>>>Class cFormatter is an cObject
72899>>>>>>>>>>>>>    
72899>>>>>>>>>>>>>    Procedure Construct_object
72901>>>>>>>>>>>>>        Integer iCh
72901>>>>>>>>>>>>>        Forward Send construct_object
72903>>>>>>>>>>>>>        Property String  psCurrencySymbol
72904>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
72905>>>>>>>>>>>>>        
72905>>>>>>>>>>>>>        Property String  psLeft
72906>>>>>>>>>>>>>        Property String  psright
72907>>>>>>>>>>>>>        Property Integer pbThousandsSep
72908>>>>>>>>>>>>>        Property Integer piPoints
72909>>>>>>>>>>>>>        
72909>>>>>>>>>>>>>        Property String  psCurPosLeft
72910>>>>>>>>>>>>>        Property String  psCurPosright
72911>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
72912>>>>>>>>>>>>>        Property Integer piCurPosPoints
72913>>>>>>>>>>>>>        
72913>>>>>>>>>>>>>        Property String  psCurNegLeft
72914>>>>>>>>>>>>>        Property String  psCurNegright
72915>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
72916>>>>>>>>>>>>>        Property Integer piCurNegPoints
72917>>>>>>>>>>>>>        
72917>>>>>>>>>>>>>        Property String  psNumPosLeft
72918>>>>>>>>>>>>>        Property String  psNumPosright
72919>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
72920>>>>>>>>>>>>>        Property Integer piNumPosPoints
72921>>>>>>>>>>>>>        
72921>>>>>>>>>>>>>        Property String  psNumNegLeft
72922>>>>>>>>>>>>>        Property String  psNumNegright
72923>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
72924>>>>>>>>>>>>>        Property Integer piNumNegPoints
72925>>>>>>>>>>>>>        
72925>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
72926>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
72927>>>>>>>>>>>>>        
72927>>>>>>>>>>>>>    End_Procedure
72928>>>>>>>>>>>>>    
72928>>>>>>>>>>>>>    // internal
72928>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
72928>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
72930>>>>>>>>>>>>>        
72930>>>>>>>>>>>>>        String sLeft sRight sDigit
72930>>>>>>>>>>>>>        Integer bSep iPos i iDigits
72930>>>>>>>>>>>>>        
72930>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
72930>>>>>>>>>>>>>        // some literals are special. $ . , / #
72930>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
72931>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
72932>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
72933>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
72934>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
72935>>>>>>>>>>>>>        Move (Character(9)) to sDigit
72936>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
72937>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
72938>>>>>>>>>>>>>        
72938>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
72939>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
72942>>>>>>>>>>>>>        
72942>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
72943>>>>>>>>>>>>>        
72943>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
72944>>>>>>>>>>>>>        
72944>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
72944>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
72945>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
72946>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
72947>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
72948>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
72949>>>>>>>>>>>>>        
72949>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
72951>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
72952>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
72954>>>>>>>>>>>>>                Move -2 to iDigits
72955>>>>>>>>>>>>>                Increment i
72956>>>>>>>>>>>>>            End
72956>>>>>>>>>>>>>>
72956>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
72960>>>>>>>>>>>>>                Increment i
72961>>>>>>>>>>>>>            Loop
72962>>>>>>>>>>>>>>
72962>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
72963>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
72966>>>>>>>>>>>>>            //
72966>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
72967>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
72971>>>>>>>>>>>>>                Increment i
72972>>>>>>>>>>>>>            Loop
72973>>>>>>>>>>>>>>
72973>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
72974>>>>>>>>>>>>>        End
72974>>>>>>>>>>>>>>
72974>>>>>>>>>>>>>        Else Begin                             // we have no decinal
72975>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
72976>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
72977>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
72979>>>>>>>>>>>>>                Move sFmt to sLeft
72980>>>>>>>>>>>>>                Move ""   to sRight
72981>>>>>>>>>>>>>            End
72981>>>>>>>>>>>>>>
72981>>>>>>>>>>>>>            Else Begin
72982>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
72983>>>>>>>>>>>>>                Move 1 to i
72984>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
72988>>>>>>>>>>>>>                    Increment i
72989>>>>>>>>>>>>>                Loop
72990>>>>>>>>>>>>>>
72990>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
72991>>>>>>>>>>>>>            End
72991>>>>>>>>>>>>>>
72991>>>>>>>>>>>>>        End
72991>>>>>>>>>>>>>>
72991>>>>>>>>>>>>>        // set temporary format properties and exit
72991>>>>>>>>>>>>>        Set pbThousandsSep to bSep
72992>>>>>>>>>>>>>        Set psLeft         to sLeft
72993>>>>>>>>>>>>>        Set psRight        to sRight
72994>>>>>>>>>>>>>        Set piPoints       to iDigits
72995>>>>>>>>>>>>>    End_Procedure
72996>>>>>>>>>>>>>    
72996>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
72996>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
72996>>>>>>>>>>>>>    //
72996>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
72996>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
72998>>>>>>>>>>>>>        String sPos sNeg
72998>>>>>>>>>>>>>        Integer iPos
72998>>>>>>>>>>>>>        
72998>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
72999>>>>>>>>>>>>>        If iPos Begin
73001>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
73002>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
73003>>>>>>>>>>>>>        End
73003>>>>>>>>>>>>>>
73003>>>>>>>>>>>>>        Else Begin
73004>>>>>>>>>>>>>            Move sFmt         to sPos
73005>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
73006>>>>>>>>>>>>>        End
73006>>>>>>>>>>>>>>
73006>>>>>>>>>>>>>        Send ParseFormat sPos
73007>>>>>>>>>>>>>        If bCurrency Begin
73009>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
73010>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
73011>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
73012>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
73013>>>>>>>>>>>>>        End
73013>>>>>>>>>>>>>>
73013>>>>>>>>>>>>>        Else Begin
73014>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
73015>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
73016>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
73017>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
73018>>>>>>>>>>>>>        End
73018>>>>>>>>>>>>>>
73018>>>>>>>>>>>>>        
73018>>>>>>>>>>>>>        Send ParseFormat sNeg
73019>>>>>>>>>>>>>        If bCurrency Begin
73021>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
73022>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
73023>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
73024>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
73025>>>>>>>>>>>>>        End
73025>>>>>>>>>>>>>>
73025>>>>>>>>>>>>>        Else Begin
73026>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
73027>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
73028>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
73029>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
73030>>>>>>>>>>>>>        End
73030>>>>>>>>>>>>>>
73030>>>>>>>>>>>>>    End_Procedure
73031>>>>>>>>>>>>>    
73031>>>>>>>>>>>>>    // low level formatting. Pass parameters
73031>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
73033>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
73033>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
73033>>>>>>>>>>>>>        
73033>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
73036>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
73037>>>>>>>>>>>>>        
73037>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
73038>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
73039>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
73040>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
73041>>>>>>>>>>>>>        // format for decimal separator
73041>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
73044>>>>>>>>>>>>>        
73044>>>>>>>>>>>>>        // format for thousand sep.
73044>>>>>>>>>>>>>        If bSep Begin
73046>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
73049>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
73050>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
73051>>>>>>>>>>>>>            While (iLen>3)
73055>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
73056>>>>>>>>>>>>>                Move (iLen-3) to iLen
73057>>>>>>>>>>>>>            Loop
73058>>>>>>>>>>>>>>
73058>>>>>>>>>>>>>        End
73058>>>>>>>>>>>>>>
73058>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
73058>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
73061>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
73062>>>>>>>>>>>>>    End_Function
73063>>>>>>>>>>>>>    
73063>>>>>>>>>>>>>    // Public: Format for currency
73063>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
73065>>>>>>>>>>>>>        String  sLeft sRight
73065>>>>>>>>>>>>>        Integer bSep
73065>>>>>>>>>>>>>        If (nNumber<0) Begin
73067>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
73068>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
73069>>>>>>>>>>>>>            Get psCurNegRight        to sRight
73070>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
73073>>>>>>>>>>>>>        End
73073>>>>>>>>>>>>>>
73073>>>>>>>>>>>>>        Else Begin
73074>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
73075>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
73076>>>>>>>>>>>>>            Get psCurPosRight        to sRight
73077>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
73080>>>>>>>>>>>>>        End
73080>>>>>>>>>>>>>>
73080>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
73081>>>>>>>>>>>>>    End_Function
73082>>>>>>>>>>>>>    
73082>>>>>>>>>>>>>    // Public: Format for numeric
73082>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
73084>>>>>>>>>>>>>        String  sLeft sRight
73084>>>>>>>>>>>>>        Integer bSep
73084>>>>>>>>>>>>>        If (nNumber<0) Begin
73086>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
73087>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
73088>>>>>>>>>>>>>            Get psNumNegRight        to sRight
73089>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
73092>>>>>>>>>>>>>        End
73092>>>>>>>>>>>>>>
73092>>>>>>>>>>>>>        Else Begin
73093>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
73094>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
73095>>>>>>>>>>>>>            Get psNumPosRight        to sRight
73096>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
73099>>>>>>>>>>>>>        End
73099>>>>>>>>>>>>>>
73099>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
73100>>>>>>>>>>>>>    End_Function
73101>>>>>>>>>>>>>    
73101>>>>>>>>>>>>>    
73101>>>>>>>>>>>>>    // Public: Format passing format string
73101>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
73103>>>>>>>>>>>>>        Integer iPos bIsNeg
73103>>>>>>>>>>>>>        String  sLeft sRight
73103>>>>>>>>>>>>>        Integer iPoints bSep
73103>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
73104>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
73105>>>>>>>>>>>>>        Case Begin
73105>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
73108>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
73112>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
73116>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
73118>>>>>>>>>>>>>        Case End
73118>>>>>>>>>>>>>        Send ParseFormat sFmt
73119>>>>>>>>>>>>>        Get pbThousandsSep to bSep
73120>>>>>>>>>>>>>        Get psLeft         to sLeft
73121>>>>>>>>>>>>>        Get psRight        to sRight
73122>>>>>>>>>>>>>        Get piPoints       to iPoints
73123>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
73124>>>>>>>>>>>>>    End_Function
73125>>>>>>>>>>>>>    
73125>>>>>>>>>>>>>End_Class
73126>>>>>>>>>>>
73126>>>>>>>>>>>Global_Variable Handle ghoFormatter
73126>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
73127>>>>>>>>>>>
73127>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
73129>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
73130>>>>>>>>>>>End_Function
73131>>>>>>>>>>>
73131>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
73133>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
73134>>>>>>>>>>>End_Function
73135>>>>>>>>>>>
73135>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
73137>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
73138>>>>>>>>>>>End_Function
73139>>>>>>>>>>>
73139>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
73141>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
73142>>>>>>>>>>>End_Procedure
73143>>>>>>>>>>>
73143>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
73145>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
73146>>>>>>>>>>>End_Procedure
73147>>>>>>>>>>>
73147>>>>>>>>>>>
73147>>>>>>>>>Use tWinStructs.pkg
73147>>>>>>>>>
73147>>>>>>>>>Use cli.pkg
73147>>>>>>>>>Use DFBTRDRV.PKG
73147>>>>>>>>>Use MSSqldrv.pkg
73147>>>>>>>>>Use db2_drv.pkg
73147>>>>>>>>>Use odbc_drv.pkg
73147>>>>>>>>>Use seq_chnl.pkg
73147>>>>>>>>>
73147>>>>>>>>>Register_Function phoWorkspace Returns Handle
73147>>>>>>>>>Register_Function Help_filename Returns String
73147>>>>>>>>>Register_Function GetHelpFile Returns String
73147>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
73147>>>>>>>>>
73147>>>>>>>>>// Use of Mertech drivers:
73147>>>>>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>// *** Constant Declarations: ***
73147>>>>>>>>>//
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>// System icon menu constants. If the upper left hand
73147>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
73147>>>>>>>>>    Define SC_RESTORE  for |CI$F120
73147>>>>>>>>>    Define SC_MOVE     for |CI$F010
73147>>>>>>>>>    Define SC_SIZE     for |CI$F000
73147>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
73147>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
73147>>>>>>>>>    Define SC_CLOSE    for |CI$F060
73147>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
73147>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
73147>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
73147>>>>>>>>>
73147>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
73147>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
73147>>>>>>>>>Define CS_VerifyCredentials  for "verify"
73147>>>>>>>>>Define CS_VerifyFileParam    for "/a"
73147>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
73147>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
73147>>>>>>>>>
73147>>>>>>>>>// *** Struct Declarations: ***
73147>>>>>>>>>
73147>>>>>>>>>Struct AboutSHELLEXECUTEINFO
73147>>>>>>>>>    DWord   cbSize
73147>>>>>>>>>    Integer fMask
73147>>>>>>>>>    Handle  hwnd
73147>>>>>>>>>    Pointer lpVerb
73147>>>>>>>>>    Pointer lpFile
73147>>>>>>>>>    Pointer lpParameters
73147>>>>>>>>>    Pointer lpDirectory
73147>>>>>>>>>    Integer nShow
73147>>>>>>>>>    Pointer hInstApp
73147>>>>>>>>>    Pointer lpIDList
73147>>>>>>>>>    Pointer lpClass
73147>>>>>>>>>    Handle  hkeyClass
73147>>>>>>>>>    DWord   dwHotKey
73147>>>>>>>>>    Handle  hIconMonitor // Union
73147>>>>>>>>>    //Handle  hMonitor     // Union
73147>>>>>>>>>    Handle  hProcess
73147>>>>>>>>>End_Struct
73147>>>>>>>>>
73147>>>>>>>>>
73147>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
73147>>>>>>>>>//Type MEMORYSTATUS
73147>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
73147>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
73147>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
73147>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
73147>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
73147>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
73147>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
73147>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
73147>>>>>>>>>//End_Type
73147>>>>>>>>>
73147>>>>>>>>>// *** External Function calls: ***
73147>>>>>>>>>//
73147>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
73148>>>>>>>>>
73148>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
73149>>>>>>>>>
73149>>>>>>>>>
73149>>>>>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
73150>>>>>>>>>
73150>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
73151>>>>>>>>>
73151>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
73152>>>>>>>>>
73152>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
73153>>>>>>>>>
73153>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
73154>>>>>>>>>
73154>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
73155>>>>>>>>>
73155>>>>>>>>>// *** Global/Desktop Function Declarations: ***
73155>>>>>>>>>
73155>>>>>>>>>Function ComputerName Desktop Returns String
73157>>>>>>>>>    String sName
73157>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
73158>>>>>>>>>>
73158>>>>>>>>>    Function_Return sName
73159>>>>>>>>>End_Function
73160>>>>>>>>>
73160>>>>>>>>>Function Network_User_Name Desktop Returns String
73162>>>>>>>>>    String sName
73162>>>>>>>>>    Get_Environment "USERNAME" to sName
73163>>>>>>>>>>
73163>>>>>>>>>    Function_Return sName
73164>>>>>>>>>End_Function
73165>>>>>>>>>
73165>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
73167>>>>>>>>>    String sClient sDriver sClientDriver
73167>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
73167>>>>>>>>>    Handle hoMsqlDrv
73167>>>>>>>>>
73167>>>>>>>>>    Move 0 to iDriver
73168>>>>>>>>>    Move "" to sClient
73169>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
73172>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
73178>>>>>>>>>>
73178>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
73181>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
73183>>>>>>>>>            Move iCount to iDriver
73184>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
73185>>>>>>>>>        End
73185>>>>>>>>>>
73185>>>>>>>>>    Loop
73186>>>>>>>>>>
73186>>>>>>>>>
73186>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
73186>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
73188>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
73191>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
73192>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
73193>>>>>>>>>        Send Destroy of hoMsqlDrv
73194>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
73195>>>>>>>>>    End
73195>>>>>>>>>>
73195>>>>>>>>>
73195>>>>>>>>>    Function_Return sClient
73196>>>>>>>>>End_Function
73197>>>>>>>>>
73197>>>>>>>>>// *** Class Declarations: ***
73197>>>>>>>>>//
73197>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
73198>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
73200>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
73201>>>>>>>>>    End_Procedure
73202>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
73204>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
73206>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
73207>>>>>>>>>    End_Procedure
73208>>>>>>>>>End_Class
73209>>>>>>>>>
73209>>>>>>>>>Class cCopyEditorContentButton is a Button
73210>>>>>>>>>    Procedure Construct_Object
73212>>>>>>>>>        Forward Send Construct_Object
73214>>>>>>>>>        Property Handle phoEditorHandle
73215>>>>>>>>>        Set psToolTip to C_$DescCopy
73216>>>>>>>>>    End_Procedure
73217>>>>>>>>>
73217>>>>>>>>>    Procedure CopyToWindowsClipboard
73219>>>>>>>>>        Handle hoEditor
73219>>>>>>>>>        Boolean bCanCopy
73219>>>>>>>>>        Address aEditorAddress
73219>>>>>>>>>
73219>>>>>>>>>        Get phoEditorHandle to hoEditor
73220>>>>>>>>>        Send Select_All of hoEditor
73221>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
73222>>>>>>>>>        If (bCanCopy = True) Begin
73224>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
73225>>>>>>>>>            Send Copy   of hoEditor
73226>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
73226>>>>>>>>>            Send Beginning_of_Data of hoEditor
73227>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
73228>>>>>>>>>        End
73228>>>>>>>>>>
73228>>>>>>>>>    End_Procedure
73229>>>>>>>>>End_Class
73230>>>>>>>>>
73230>>>>>>>>>Class SysinfoDisplay is a cTextEdit
73231>>>>>>>>>    Procedure Construct_Object
73233>>>>>>>>>        Forward Send Construct_Object
73235>>>>>>>>>
73235>>>>>>>>>        Set Size to 100 245
73236>>>>>>>>>        Set Location to 6 6
73237>>>>>>>>>        Set Border_Style to Border_None
73238>>>>>>>>>        Set Read_Only_State to True
73239>>>>>>>>>        Set pbWrap to True
73240>>>>>>>>>        Set peAnchors to anAll
73241>>>>>>>>>    End_Procedure
73242>>>>>>>>>
73242>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
73242>>>>>>>>>
73242>>>>>>>>>    Procedure AppendTextLn String sText
73244>>>>>>>>>        String sWorkspaceWSFile
73244>>>>>>>>>
73244>>>>>>>>>        // Only works for English:
73244>>>>>>>>>        If (ghoApplication > 0) Begin
73246>>>>>>>>>            If (sText contains "Workspace Name") Begin
73248>>>>>>>>>                Move "Workspace Config Filename:" to sText
73249>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
73250>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
73251>>>>>>>>>            End
73251>>>>>>>>>>
73251>>>>>>>>>        End
73251>>>>>>>>>>
73251>>>>>>>>>        Send AppendText sText
73252>>>>>>>>>        Send AppendText (character(10))
73253>>>>>>>>>    End_Procedure
73254>>>>>>>>>
73254>>>>>>>>>    //    This method will show the name Of the current directory in the system
73254>>>>>>>>>    //    information box
73254>>>>>>>>>    Procedure Show_Current_Directory
73256>>>>>>>>>        String sDir
73256>>>>>>>>>
73256>>>>>>>>>        Get_Current_Directory To sDir
73257>>>>>>>>>
73257>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
73258>>>>>>>>>    End_Procedure
73259>>>>>>>>>
73259>>>>>>>>>    Procedure Show_Windows_Directory
73261>>>>>>>>>        String sWindir
73261>>>>>>>>>
73261>>>>>>>>>        Get_Windows_Directory To sWindir
73262>>>>>>>>>
73262>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
73263>>>>>>>>>    End_Procedure
73264>>>>>>>>>
73264>>>>>>>>>    Procedure Show_Current_User
73266>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
73267>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
73268>>>>>>>>>    End_Procedure
73269>>>>>>>>>
73269>>>>>>>>>    Procedure Show_Number_Format
73271>>>>>>>>>        Integer iFormat
73271>>>>>>>>>        String sFormatText
73271>>>>>>>>>
73271>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
73274>>>>>>>>>        Move (Character (iFormat)) To sFormatText
73275>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
73276>>>>>>>>>
73276>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
73279>>>>>>>>>        Move (Character (iFormat)) to sFormatText
73280>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
73281>>>>>>>>>    End_Procedure
73282>>>>>>>>>
73282>>>>>>>>>    Procedure Show_Filelist_Name
73284>>>>>>>>>        String sFilename
73284>>>>>>>>>
73284>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
73287>>>>>>>>>
73287>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
73288>>>>>>>>>    End_Procedure
73289>>>>>>>>>
73289>>>>>>>>>    Procedure Show_Lock_Delay
73291>>>>>>>>>        Integer iLockdelay
73291>>>>>>>>>
73291>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
73294>>>>>>>>>
73294>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
73295>>>>>>>>>    End_Procedure
73296>>>>>>>>>
73296>>>>>>>>>    Procedure Show_Lock_Timeout
73298>>>>>>>>>        Integer iLockTimeout
73298>>>>>>>>>
73298>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
73301>>>>>>>>>
73301>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
73302>>>>>>>>>    End_Procedure
73303>>>>>>>>>
73303>>>>>>>>>    Procedure Show_Screen_Size
73305>>>>>>>>>        Integer iYscreensize iXscreensize
73305>>>>>>>>>
73305>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
73306>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
73307>>>>>>>>>
73307>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
73308>>>>>>>>>    End_Procedure
73309>>>>>>>>>
73309>>>>>>>>>    Procedure Show_Page_Size
73311>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
73312>>>>>>>>>    End_procedure
73313>>>>>>>>>
73313>>>>>>>>>    Procedure Show_Date
73315>>>>>>>>>        Date dToday
73315>>>>>>>>>
73315>>>>>>>>>        Move (CurrentDateTime()) to dToday
73316>>>>>>>>>
73316>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
73317>>>>>>>>>    End_procedure
73318>>>>>>>>>
73318>>>>>>>>>    Procedure Show_Date_Format
73320>>>>>>>>>        Integer iDateFormat
73320>>>>>>>>>        String sDateFormat
73320>>>>>>>>>
73320>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
73323>>>>>>>>>        Case Begin
73323>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
73325>>>>>>>>>                Move C_$USA To sDateFormat
73326>>>>>>>>>                Case Break
73327>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
73330>>>>>>>>>                Move C_$European To sDateFormat
73331>>>>>>>>>                Case Break
73332>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
73335>>>>>>>>>                Move C_$Military To sDateFormat
73336>>>>>>>>>                Case Break
73337>>>>>>>>>            Case Else
73337>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
73338>>>>>>>>>                Case Break
73339>>>>>>>>>        Case End
73339>>>>>>>>>
73339>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
73340>>>>>>>>>    End_Procedure
73341>>>>>>>>>
73341>>>>>>>>>    // 2013-08-14 NGS
73341>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
73341>>>>>>>>>    Procedure Show_Systemresources
73343>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
73343>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
73343>>>>>>>>>        Integer iRetval
73343>>>>>>>>>        Number nValue
73343>>>>>>>>>        String sValue
73343>>>>>>>>>
73343>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
73344>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
73345>>>>>>>>>        If (iRetval = 0) Begin
73347>>>>>>>>>            Move (ShowLastError ()) to iRetval
73348>>>>>>>>>            Procedure_Return
73349>>>>>>>>>        End
73349>>>>>>>>>>
73349>>>>>>>>>
73349>>>>>>>>>        Send AppendTextLn ""
73350>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
73351>>>>>>>>>
73351>>>>>>>>>        // Show memory in Gigabytes:
73351>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
73352>>>>>>>>>        Move (Round(nValue)) to nValue
73353>>>>>>>>>        Get FormatNumber nValue 2 to sValue
73354>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
73355>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
73356>>>>>>>>>
73356>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
73356>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
73357>>>>>>>>>        Move (Round(nValue)) to nValue
73358>>>>>>>>>        Get FormatNumber nValue 0 to sValue
73359>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
73360>>>>>>>>>
73360>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
73360>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
73361>>>>>>>>>        Move (Round(nValue)) to nValue
73362>>>>>>>>>        Get FormatNumber nValue 0 to sValue
73363>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
73364>>>>>>>>>
73364>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
73364>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
73365>>>>>>>>>        Move (Round(nValue)) to nValue
73366>>>>>>>>>        Get FormatNumber nValue 0 to sValue
73367>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
73368>>>>>>>>>
73368>>>>>>>>>        // Add an empty row after the memory information:
73368>>>>>>>>>        Send AppendTextLn ""
73369>>>>>>>>>    End_Procedure
73370>>>>>>>>>
73370>>>>>>>>>    Procedure Show_Registration
73372>>>>>>>>>        String sRegName
73372>>>>>>>>>        Integer iSN iUsersMax iUserCount
73372>>>>>>>>>
73372>>>>>>>>>        Registration sRegName iSN
73373>>>>>>>>>>
73373>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
73374>>>>>>>>>        Get_Current_User_Count to iUserCount
73375>>>>>>>>>
73375>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
73376>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
73377>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
73378>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
73379>>>>>>>>>    End_Procedure
73380>>>>>>>>>
73380>>>>>>>>>    //****************************************************************************
73380>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
73380>>>>>>>>>    // To the workspace object passing the an object and message To send back
73380>>>>>>>>>    // To this object. It is expected that the workspace object will send this
73380>>>>>>>>>    // message for every line Of information it wants displayed (passing the
73380>>>>>>>>>    // information To be displayed
73380>>>>>>>>>    //****************************************************************************
73380>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
73380>>>>>>>>>
73380>>>>>>>>>    Procedure Show_ServicePack
73382>>>>>>>>>        String sKey sVersion sDataFlex
73382>>>>>>>>>        Handle hoRegistry
73382>>>>>>>>>        Boolean bExists bOpened
73382>>>>>>>>>
73382>>>>>>>>>        Move "DataFlex"        to sDataFlex
73383>>>>>>>>>
73383>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
73384>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
73385>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
73386>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
73387>>>>>>>>>
73387>>>>>>>>>        If (bExists) Begin
73389>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
73390>>>>>>>>>        End
73390>>>>>>>>>>
73390>>>>>>>>>        Else Begin
73391>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
73392>>>>>>>>>        End
73392>>>>>>>>>>
73392>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
73393>>>>>>>>>        If (bExists) Begin
73395>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
73396>>>>>>>>>            If (bOpened) Begin
73398>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
73399>>>>>>>>>                If (bExists) Begin
73401>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
73402>>>>>>>>>                End
73402>>>>>>>>>>
73402>>>>>>>>>                Send CloseKey of hoRegistry
73403>>>>>>>>>            End
73403>>>>>>>>>>
73403>>>>>>>>>        End
73403>>>>>>>>>>
73403>>>>>>>>>        Send Destroy of hoRegistry
73404>>>>>>>>>
73404>>>>>>>>>        If (sVersion <> "") Begin
73406>>>>>>>>>           Send AppendTextLn sVersion
73407>>>>>>>>>           Send AppendTextLn ""
73408>>>>>>>>>        End
73408>>>>>>>>>>
73408>>>>>>>>>    End_Procedure
73409>>>>>>>>>
73409>>>>>>>>>    Procedure Show_WorkspaceInformation
73411>>>>>>>>>        Integer hoWorkspace
73411>>>>>>>>>
73411>>>>>>>>>        If (ghoApplication <> 0) Begin
73413>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
73414>>>>>>>>>            If (hoWorkspace <> 0) Begin
73416>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
73417>>>>>>>>>            End
73417>>>>>>>>>>
73417>>>>>>>>>        End
73417>>>>>>>>>>
73417>>>>>>>>>    End_Procedure
73418>>>>>>>>>
73418>>>>>>>>>    //****************************************************************************
73418>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
73418>>>>>>>>>    // to the connection manager object passing the an object and message to send
73418>>>>>>>>>    // back to this object. It is expected that the connection manager object will
73418>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
73418>>>>>>>>>    // the information To be displayed
73418>>>>>>>>>    //****************************************************************************
73418>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
73418>>>>>>>>>
73418>>>>>>>>>    Procedure Show_ConnectionIdInformation
73420>>>>>>>>>        If (ghoConnection > 0) Begin
73422>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
73423>>>>>>>>>            Send AppendTextLn ""
73424>>>>>>>>>        End
73424>>>>>>>>>>
73424>>>>>>>>>    End_Procedure
73425>>>>>>>>>
73425>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
73427>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
73428>>>>>>>>>    End_Function
73429>>>>>>>>>
73429>>>>>>>>>    Procedure Show_Versions
73431>>>>>>>>>        Integer iVersion iRevision iBuild
73431>>>>>>>>>
73431>>>>>>>>>        Version_information iVersion iRevision iBuild
73433>>>>>>>>>
73433>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
73434>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
73435>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
73436>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
73437>>>>>>>>>    End_Procedure
73438>>>>>>>>>
73438>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
73440>>>>>>>>>        Boolean bOK
73440>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
73441>>>>>>>>>        Function_Return bOK
73442>>>>>>>>>    End_Function
73443>>>>>>>>>
73443>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
73445>>>>>>>>>        Boolean bOK
73445>>>>>>>>>        Function_Return bOK
73446>>>>>>>>>    End_Function
73447>>>>>>>>>
73447>>>>>>>>>    //***
73447>>>>>>>>>    //*** BW
73447>>>>>>>>>    //*** Procedure: Show_Drivers
73447>>>>>>>>>    //*** Purpose  : Show loaded database drivers
73447>>>>>>>>>    //***
73447>>>>>>>>>
73447>>>>>>>>>    Procedure Show_Drivers
73449>>>>>>>>>        String sDriverID sVersion sClient sValue
73449>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
73449>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
73449>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
73449>>>>>>>>>
73449>>>>>>>>>        Move False to bStudioLicense
73450>>>>>>>>>
73450>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
73451>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
73452>>>>>>>>>
73452>>>>>>>>>        // For testing purposes:
73452>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
73452>>>>>>>>>//        Load_Driver MSSQLDRV_ID
73452>>>>>>>>>//        Load_Driver ODBC_DRV_ID
73452>>>>>>>>>//        Load_Driver DB2_DRV_ID
73452>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
73452>>>>>>>>>//
73452>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
73452>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
73452>>>>>>>>>//            Load_Driver SQLFLEX
73452>>>>>>>>>//            Load_Driver MDSPgSQL
73452>>>>>>>>>//            Load_Driver MDSMySQL
73452>>>>>>>>>//            Load_Driver ORAFLEX
73452>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
73452>>>>>>>>>//        #ENDIF
73452>>>>>>>>>        Move False to Err
73453>>>>>>>>>
73453>>>>>>>>>        // Loop through all loaded drivers.
73453>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
73456>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
73458>>>>>>>>>            Send AppendTextLn ""
73459>>>>>>>>>        End
73459>>>>>>>>>>
73459>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
73465>>>>>>>>>>
73465>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
73465>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
73465>>>>>>>>>            // would be thrown, so we safeguard from that here.
73465>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
73466>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
73469>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
73470>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
73471>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
73472>>>>>>>>>
73472>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
73474>>>>>>>>>
73474>>>>>>>>>                // Pervasive/Btrieve database
73474>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
73476>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
73477>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
73478>>>>>>>>>                    If (sClient <> "0.0.0") Begin
73480>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
73481>>>>>>>>>                    End
73481>>>>>>>>>>
73481>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
73482>>>>>>>>>                    If (sClient <> "0.0.0") Begin
73484>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
73485>>>>>>>>>                    End
73485>>>>>>>>>>
73485>>>>>>>>>                End
73485>>>>>>>>>>
73485>>>>>>>>>
73485>>>>>>>>>                Else Begin
73486>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
73487>>>>>>>>>                    Move 0 to iNumServers
73488>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
73490>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
73493>>>>>>>>>                    End
73493>>>>>>>>>>
73493>>>>>>>>>
73493>>>>>>>>>                    If (bIsDAWDriver = True) Begin
73495>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
73497>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
73498>>>>>>>>>                        End
73498>>>>>>>>>>
73498>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
73499>>>>>>>>>                    End
73499>>>>>>>>>>
73499>>>>>>>>>
73499>>>>>>>>>                    If (bIsMertechDriver = True) Begin
73501>>>>>>>>>                    End
73501>>>>>>>>>>
73501>>>>>>>>>
73501>>>>>>>>>                    // If the serialnumber is = 0, it means that the
73501>>>>>>>>>                    // Studio licens is in use and there is no
73501>>>>>>>>>                    // number of max users defined because the driver is
73501>>>>>>>>>                    // relying on the info from the VDF license.
73501>>>>>>>>>                    If (bStudioLicense = False) Begin
73503>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
73504>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
73505>>>>>>>>>                    End
73505>>>>>>>>>>
73505>>>>>>>>>                End
73505>>>>>>>>>>
73505>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
73506>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
73508>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
73509>>>>>>>>>                End
73509>>>>>>>>>>
73509>>>>>>>>>                If (iNumServers <> 0) Begin
73511>>>>>>>>>                    For iCount from 1 to iNumServers
73517>>>>>>>>>>
73517>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
73520>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
73522>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
73523>>>>>>>>>                        End
73523>>>>>>>>>>
73523>>>>>>>>>                    Loop
73524>>>>>>>>>>
73524>>>>>>>>>                End
73524>>>>>>>>>>
73524>>>>>>>>>            End
73524>>>>>>>>>>
73524>>>>>>>>>        Loop
73525>>>>>>>>>>
73525>>>>>>>>>
73525>>>>>>>>>        Send AppendTextLn ""
73526>>>>>>>>>        If (bStudioLicense = False) Begin
73528>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
73529>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
73530>>>>>>>>>        End
73530>>>>>>>>>>
73530>>>>>>>>>        Else Begin
73531>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
73532>>>>>>>>>        End
73532>>>>>>>>>>
73532>>>>>>>>>        Send Destroy of hoCLIHandler
73533>>>>>>>>>        Send Destroy of hoBtrvHandler
73534>>>>>>>>>    End_Procedure
73535>>>>>>>>>
73535>>>>>>>>>    Procedure Show_HelpFile
73537>>>>>>>>>        String sHelpFile
73537>>>>>>>>>        Integer eHelpType
73537>>>>>>>>>
73537>>>>>>>>>        If (ghoApplication <> 0) Begin
73539>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
73540>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
73542>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
73543>>>>>>>>>            End
73543>>>>>>>>>>
73543>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
73546>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
73547>>>>>>>>>            End
73547>>>>>>>>>>
73547>>>>>>>>>            Else Begin
73548>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
73549>>>>>>>>>            End
73549>>>>>>>>>>
73549>>>>>>>>>
73549>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
73550>>>>>>>>>        End
73550>>>>>>>>>>
73550>>>>>>>>>    End_Procedure
73551>>>>>>>>>
73551>>>>>>>>>    Procedure Show_EnterAsTab
73553>>>>>>>>>        Boolean bEnterKeyAsTabKey
73553>>>>>>>>>        String sText
73553>>>>>>>>>
73553>>>>>>>>>        If (ghoApplication <> 0) Begin
73555>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
73556>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
73558>>>>>>>>>                Move "True" To sText
73559>>>>>>>>>            End
73559>>>>>>>>>>
73559>>>>>>>>>            Else Begin
73560>>>>>>>>>                Move "False" To sText
73561>>>>>>>>>            End
73561>>>>>>>>>>
73561>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
73562>>>>>>>>>        End
73562>>>>>>>>>>
73562>>>>>>>>>    End_Procedure
73563>>>>>>>>>
73563>>>>>>>>>    //    During activation we will remove the old information and add the newly
73563>>>>>>>>>    //    found systeminformation
73563>>>>>>>>>    Procedure Add_Focus Integer hoRoot
73565>>>>>>>>>        Forward Send Add_Focus hoRoot
73567>>>>>>>>>
73567>>>>>>>>>        Send Delete_Data
73568>>>>>>>>>
73568>>>>>>>>>        Set Changed_State To False
73569>>>>>>>>>        Set Read_Only_State To True
73570>>>>>>>>>
73570>>>>>>>>>        Send Show_Registration
73571>>>>>>>>>        Send Show_Drivers
73572>>>>>>>>>        Send Show_ServicePack
73573>>>>>>>>>        Send Show_Versions
73574>>>>>>>>>        Send AppendTextLn ""
73575>>>>>>>>>
73575>>>>>>>>>        If (ghoApplication <> 0) Begin
73577>>>>>>>>>            Send Show_WorkSpaceInformation
73578>>>>>>>>>            Send Show_HelpFile
73579>>>>>>>>>            Send AppendTextLn ""
73580>>>>>>>>>        End
73580>>>>>>>>>>
73580>>>>>>>>>        Else Begin
73581>>>>>>>>>            Send AppendTextLn ""
73582>>>>>>>>>        End
73582>>>>>>>>>>
73582>>>>>>>>>
73582>>>>>>>>>        If (ghoConnection <> 0) Begin
73584>>>>>>>>>            Send Show_ConnectionIdInformation
73585>>>>>>>>>        End
73585>>>>>>>>>>
73585>>>>>>>>>
73585>>>>>>>>>        Send Show_Current_User
73586>>>>>>>>>        Send Show_Windows_Directory
73587>>>>>>>>>        Send Show_Current_Directory
73588>>>>>>>>>
73588>>>>>>>>>        // This is already shown in the workspace details,
73588>>>>>>>>>        // unless no workspace object is present:
73588>>>>>>>>>        If (ghoApplication = 0) Begin
73590>>>>>>>>>            Send Show_Filelist_Name
73591>>>>>>>>>        End
73591>>>>>>>>>>
73591>>>>>>>>>
73591>>>>>>>>>        If (ghoApplication <> 0) Begin
73593>>>>>>>>>            Send AppendTextLn ""
73594>>>>>>>>>            Send Show_EnterAsTab
73595>>>>>>>>>        End
73595>>>>>>>>>>
73595>>>>>>>>>
73595>>>>>>>>>        Send Show_Screen_Size
73596>>>>>>>>>        Send Show_Page_Size
73597>>>>>>>>>        Send Show_Number_Format
73598>>>>>>>>>        Send Show_Date_Format
73599>>>>>>>>>        Send Show_Lock_Delay
73600>>>>>>>>>        Send Show_Lock_Timeout
73601>>>>>>>>>        Send Show_Date
73602>>>>>>>>>        Send Show_Systemresources
73603>>>>>>>>>        Send Beginning_of_Data
73604>>>>>>>>>
73604>>>>>>>>>        Set Icon to 'default.ico'
73605>>>>>>>>>    End_Procedure
73606>>>>>>>>>End_Class
73607>>>>>>>>>
73607>>>>>>>>>Class SysInfoDialog is a ModalPanel
73608>>>>>>>>>    Procedure Construct_Object
73610>>>>>>>>>        Forward Send Construct_Object
73612>>>>>>>>>
73612>>>>>>>>>        Set Label to C_$SystemInformation
73613>>>>>>>>>        Set Size to 140 267
73614>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
73615>>>>>>>>>        Set Border_Style to Border_Thick
73616>>>>>>>>>        Set Sysmenu_Icon to False
73617>>>>>>>>>
73617>>>>>>>>>        // "+1" will make the panel to paint correctly.
73617>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
73618>>>>>>>>>
73618>>>>>>>>>        // 2014-09-14 NGS
73618>>>>>>>>>        // Added a container object around the cTexteditor
73618>>>>>>>>>        // object to get a border around the text.
73618>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
73620>>>>>>>>>            Set Location to 2 4
73621>>>>>>>>>            Set Size to 110 255
73622>>>>>>>>>            Set Border_Style to Border_ClientEdge
73623>>>>>>>>>            Set Color to clWhite
73624>>>>>>>>>            Set peAnchors to anAll
73625>>>>>>>>>
73625>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
73627>>>>>>>>>            End_Object
73628>>>>>>>>>
73628>>>>>>>>>        End_Object
73629>>>>>>>>>
73629>>>>>>>>>        Object oCloseButton is a Button
73631>>>>>>>>>            Set Label to C_$Close
73632>>>>>>>>>            Set Location to 120 210
73633>>>>>>>>>            Set Message item 0 to msg_Close_Panel
73634>>>>>>>>>            Set Default_State To True
73635>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
73635>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
73635>>>>>>>>>            // for that situation.
73635>>>>>>>>>            Set peAnchors to anBottomRight
73636>>>>>>>>>        End_Object
73637>>>>>>>>>
73637>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
73639>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
73640>>>>>>>>>            Set Size to 14 50
73641>>>>>>>>>            Set Location to 120 158
73642>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
73642>>>>>>>>>            // we might as well prepare the object for it.
73642>>>>>>>>>            Set peAnchors to anBottomRight
73643>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
73644>>>>>>>>>        End_Object
73645>>>>>>>>>
73645>>>>>>>>>        On_Key kCancel Send Close_Panel
73646>>>>>>>>>    End_Procedure
73647>>>>>>>>>
73647>>>>>>>>>    Procedure Page Integer iPageObject
73649>>>>>>>>>        Handle hMenu
73649>>>>>>>>>        Integer iPrevState
73649>>>>>>>>>
73649>>>>>>>>>        Forward Send Page iPageObject
73651>>>>>>>>>
73651>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
73651>>>>>>>>>        //
73651>>>>>>>>>    End_Procedure
73652>>>>>>>>>
73652>>>>>>>>>End_Class
73653>>>>>>>>>
73653>>>>>>>>>Class cAboutEdit is an cRichEdit
73654>>>>>>>>>    Procedure Construct_Object
73656>>>>>>>>>        Forward Send Construct_Object
73658>>>>>>>>>
73658>>>>>>>>>        Property String psContentText
73659>>>>>>>>>
73659>>>>>>>>>        Set Size to 77 153
73660>>>>>>>>>        Set Location to 8 60
73661>>>>>>>>>        Set Read_Only_State to True
73662>>>>>>>>>        Set Skip_State to True
73663>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
73663>>>>>>>>>        // or 1/20 of a printer's point.
73663>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
73664>>>>>>>>>        Set Border_Style  to Border_None
73665>>>>>>>>>    End_Procedure
73666>>>>>>>>>
73666>>>>>>>>>    // Adds a line of text to the edit object
73666>>>>>>>>>    Procedure Add_Line String sText
73668>>>>>>>>>        String sContentText
73668>>>>>>>>>        Get psContentText to sContentText
73669>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
73670>>>>>>>>>        Set psContentText to sContentText
73671>>>>>>>>>    End_Procedure
73672>>>>>>>>>
73672>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
73672>>>>>>>>>    // Note that we use a property psContentText and add to it,
73672>>>>>>>>>    // because the object isn't paged yet when we add these
73672>>>>>>>>>    // values and the COM edit object needs to be paged
73672>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
73672>>>>>>>>>    Procedure Add_LineLn String sText
73674>>>>>>>>>        String sContentText sCR
73674>>>>>>>>>
73674>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
73675>>>>>>>>>        Get psContentText to sContentText
73676>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
73677>>>>>>>>>        Set psContentText to sContentText
73678>>>>>>>>>    End_Procedure
73679>>>>>>>>>
73679>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
73681>>>>>>>>>        String sLinkText
73681>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
73682>>>>>>>>>        Send Show_HomePage sLinkText
73683>>>>>>>>>    End_Procedure
73684>>>>>>>>>
73684>>>>>>>>>    Procedure Page Integer iPageObject
73686>>>>>>>>>        String sContentText
73686>>>>>>>>>
73686>>>>>>>>>        Forward Send Page iPageObject
73688>>>>>>>>>        Get psContentText to sContentText
73689>>>>>>>>>        Send AppendText sContentText
73690>>>>>>>>>        send Beginning_of_Data
73691>>>>>>>>>    End_Procedure
73692>>>>>>>>>
73692>>>>>>>>>End_Class
73693>>>>>>>>>
73693>>>>>>>>>Class AboutDialog is a ModalPanel
73694>>>>>>>>>    Procedure Construct_Object
73696>>>>>>>>>
73696>>>>>>>>>        Forward Send Construct_Object
73698>>>>>>>>>
73698>>>>>>>>>        Set Label to C_$About
73699>>>>>>>>>        Set Size to 118 230
73700>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
73701>>>>>>>>>        Set Border_Style to Border_Thick
73702>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
73703>>>>>>>>>
73703>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
73705>>>>>>>>>        End_Object
73706>>>>>>>>>
73706>>>>>>>>>        Object oBox is a Container3d
73708>>>>>>>>>            Set Border_Style to Border_Normal
73709>>>>>>>>>            Set Size to 90 220
73710>>>>>>>>>            Set Location to 4 5
73711>>>>>>>>>            Set Color to clWhite
73712>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
73712>>>>>>>>>            // we might as well prepare the object for it.
73712>>>>>>>>>            Set peAnchors to anAll
73713>>>>>>>>>
73713>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
73715>>>>>>>>>                Set Border_Style To Border_None
73716>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
73717>>>>>>>>>                Set Color to clWhite
73718>>>>>>>>>                Set Size to 45 50
73719>>>>>>>>>                Set Location to 0 3
73720>>>>>>>>>            End_Object
73721>>>>>>>>>
73721>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
73723>>>>>>>>>                Set Border_Style to Border_None
73724>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
73725>>>>>>>>>                Set Color to clWhite
73726>>>>>>>>>                Set Size to 30 55
73727>>>>>>>>>                Set Location to 50 3
73728>>>>>>>>>            End_Object
73729>>>>>>>>>
73729>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
73731>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
73731>>>>>>>>>                // we might as well prepare the object for it.
73731>>>>>>>>>                Set peAnchors to anAll
73732>>>>>>>>>            End_Object
73733>>>>>>>>>
73733>>>>>>>>>            // These objects are here for backwards compatability only.
73733>>>>>>>>>            // They are not used.
73733>>>>>>>>>            Object oProductName is a TextBox
73735>>>>>>>>>                Set Label To C_$ProductName
73736>>>>>>>>>                Set Size To 10 45
73737>>>>>>>>>                Set Location To 8 53
73738>>>>>>>>>                Set Visible_State to False
73739>>>>>>>>>                Set Focus_Mode to NonFocusable
73740>>>>>>>>>            End_Object
73741>>>>>>>>>
73741>>>>>>>>>            Object oVersion is a TextBox
73743>>>>>>>>>                Set Label To C_$Version
73744>>>>>>>>>                Set Size To 10 25
73745>>>>>>>>>                Set Location To 21 53
73746>>>>>>>>>                Set Visible_State to False
73747>>>>>>>>>                Set Focus_Mode to NonFocusable
73748>>>>>>>>>            End_Object
73749>>>>>>>>>
73749>>>>>>>>>            Object oCopyright is a TextBox
73751>>>>>>>>>                Set Label To C_$Copyright
73752>>>>>>>>>                Set Size To 10 31
73753>>>>>>>>>                Set Location To 34 53
73754>>>>>>>>>                Set Visible_State to False
73755>>>>>>>>>                Set Focus_Mode to NonFocusable
73756>>>>>>>>>            End_Object
73757>>>>>>>>>
73757>>>>>>>>>            Object oAuthor is a TextBox
73759>>>>>>>>>                Set Label To C_$Author
73760>>>>>>>>>                Set Size To 10 22
73761>>>>>>>>>                Set Location To 46 53
73762>>>>>>>>>                Set Visible_State to False
73763>>>>>>>>>                Set Focus_Mode to NonFocusable
73764>>>>>>>>>            End_Object
73765>>>>>>>>>
73765>>>>>>>>>        End_Object
73766>>>>>>>>>
73766>>>>>>>>>        Object oOKButton is a Button
73768>>>>>>>>>            On_Item C_$Close Send Close_Panel
73769>>>>>>>>>            Set Location to 98 176
73770>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
73770>>>>>>>>>            // we might as well prepare the object for it.
73770>>>>>>>>>            Set peAnchors to anBottomRight
73771>>>>>>>>>        End_Object
73772>>>>>>>>>
73772>>>>>>>>>        Object oSysInfoButton is a Button
73774>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
73775>>>>>>>>>            Set Location to 98 123
73776>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
73776>>>>>>>>>            // we might as well prepare the object for it.
73776>>>>>>>>>            Set peAnchors to anBottomRight
73777>>>>>>>>>        End_Object
73778>>>>>>>>>
73778>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
73780>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
73781>>>>>>>>>            Set Size to 14 50
73782>>>>>>>>>            Set Location to 98 70
73783>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
73783>>>>>>>>>            // we might as well prepare the object for it.
73783>>>>>>>>>            Set peAnchors to anBottomRight
73784>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
73785>>>>>>>>>        End_Object
73786>>>>>>>>>
73786>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
73787>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
73788>>>>>>>>>        Set LogoDF to "DF32.bmp"
73789>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
73789>>>>>>>>>    End_Procedure
73790>>>>>>>>>
73790>>>>>>>>>    Procedure Page Integer iPageObject
73792>>>>>>>>>        Handle hMenu
73792>>>>>>>>>        Integer iPrevState
73792>>>>>>>>>
73792>>>>>>>>>        Forward Send Page iPageObject
73794>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
73794>>>>>>>>>        Set Icon to "Default.ico"
73795>>>>>>>>>
73795>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
73795>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
73796>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73797>>>>>>>>>        // The "Move" menu command may come in handy to have.
73797>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73797>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73798>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73799>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73800>>>>>>>>>        // The "Close" menu command may be good to have.
73800>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
73800>>>>>>>>>    End_Procedure
73801>>>>>>>>>
73801>>>>>>>>>    Procedure Set ProductName String sText
73803>>>>>>>>>        Set Value of oProductName to sText
73804>>>>>>>>>    End_Procedure
73805>>>>>>>>>
73805>>>>>>>>>    Procedure Set Copyright String sText
73807>>>>>>>>>        Set Value of oCopyright to sText
73808>>>>>>>>>    End_Procedure
73809>>>>>>>>>
73809>>>>>>>>>    Procedure Set Author String sText
73811>>>>>>>>>        Set Value of oAuthor to sText
73812>>>>>>>>>    End_Procedure
73813>>>>>>>>>
73813>>>>>>>>>    Procedure Set Version String sVersion
73815>>>>>>>>>        Handle hoVersionInfo
73815>>>>>>>>>        Boolean bIncluded
73815>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
73815>>>>>>>>>        Date dCompileDate
73815>>>>>>>>>        String sCertInfo
73815>>>>>>>>>
73815>>>>>>>>>        If (sVersion = "") Begin
73817>>>>>>>>>            // This automatically shows the program version of the program, if available.
73817>>>>>>>>>            // It will be displayed as the second item in the edit object.
73817>>>>>>>>>            If (ghoApplication <> 0) Begin
73819>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
73820>>>>>>>>>                If (hoVersionInfo <> 0) Begin
73822>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
73823>>>>>>>>>                    If (bIncluded) Begin
73825>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
73826>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
73827>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
73828>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
73829>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
73830>>>>>>>>>                    End
73830>>>>>>>>>>
73830>>>>>>>>>                End
73830>>>>>>>>>>
73830>>>>>>>>>            End
73830>>>>>>>>>>
73830>>>>>>>>>        End
73830>>>>>>>>>>
73830>>>>>>>>>
73830>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
73830>>>>>>>>>        Get GetCompileDate to dCompileDate
73831>>>>>>>>>        If (sVersion <> "") Begin
73833>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
73834>>>>>>>>>        End
73834>>>>>>>>>>
73834>>>>>>>>>
73834>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
73835>>>>>>>>>        If (sCertInfo <> "-1") Begin
73837>>>>>>>>>            If (sCertInfo <> "") Begin
73839>>>>>>>>>                Send Add_LineLn sCertInfo
73840>>>>>>>>>            End
73840>>>>>>>>>>
73840>>>>>>>>>            Else Begin
73841>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
73842>>>>>>>>>            End
73842>>>>>>>>>>
73842>>>>>>>>>        End
73842>>>>>>>>>>
73842>>>>>>>>>    End_Procedure
73843>>>>>>>>>
73843>>>>>>>>>    Function IsDate Desktop String sDate Returns Boolean
73845>>>>>>>>>        Boolean bIsDate
73845>>>>>>>>>        String sGoodCharacters sChar
73845>>>>>>>>>        Integer iCount iLength
73845>>>>>>>>>
73845>>>>>>>>>        Move True to bIsDate
73846>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
73847>>>>>>>>>        Move (Length(sDate)) to iLength
73848>>>>>>>>>        For iCount from 1 to iLength
73854>>>>>>>>>>
73854>>>>>>>>>            Move (Left(sDate, 1)) to sChar
73855>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
73856>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
73857>>>>>>>>>            If (bIsDate = False) Begin
73859>>>>>>>>>                Move iLength to iCount
73860>>>>>>>>>            End
73860>>>>>>>>>>
73860>>>>>>>>>        Loop
73861>>>>>>>>>>
73861>>>>>>>>>        Function_Return bIsDate
73862>>>>>>>>>    End_Function
73863>>>>>>>>>
73863>>>>>>>>>    Function GetCompileDate Returns Date
73865>>>>>>>>>        Date dCompileDate
73865>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
73865>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
73865>>>>>>>>>        Boolean bIsValid
73865>>>>>>>>>
73865>>>>>>>>>        Move 0 to dCompileDate
73866>>>>>>>>>        // Get full path to the current running executable
73866>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
73867>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
73868>>>>>>>>>
73868>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
73868>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
73869>>>>>>>>>
73869>>>>>>>>>        Get_Argument_Size to iSize
73870>>>>>>>>>        Set_Argument_Size 15000000
73871>>>>>>>>>>
73871>>>>>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
73873>>>>>>>>>        Move (Pos(sProgram,sData)) to iPos
73874>>>>>>>>>        If (iPos > 0) Begin
73876>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
73876>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
73877>>>>>>>>>
73877>>>>>>>>>            // If the current date format is non US, we need to temporary
73877>>>>>>>>>            // change the format and then move the string to the date variable.
73877>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
73880>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
73883>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
73884>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
73887>>>>>>>>>        End
73887>>>>>>>>>>
73887>>>>>>>>>//        Else Begin
73887>>>>>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
73887>>>>>>>>>//        End
73887>>>>>>>>>
73887>>>>>>>>>        Send Seq_Close_Channel iChannel
73888>>>>>>>>>        Set_Argument_Size iSize
73889>>>>>>>>>>
73889>>>>>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
73889>>>>>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
73889>>>>>>>>>
73889>>>>>>>>>        // The data is padded with Character(0)s. Strip them out
73889>>>>>>>>>//        Move (CString(sData)) to sData
73889>>>>>>>>>
73889>>>>>>>>>        // The compile date is after the first ", ", so string parsing is required
73889>>>>>>>>>//        Move (Pos(", ", sData)) to iPos
73889>>>>>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
73889>>>>>>>>>        // If the current date format is non US, we need to temporary
73889>>>>>>>>>        // change the format and then move the string to the date variable.
73889>>>>>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
73889>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
73889>>>>>>>>>//
73889>>>>>>>>>//        // Note the build in IsDateValid can return the wrong result
73889>>>>>>>>>//        // when controls characters are part of the sCompileDate.
73889>>>>>>>>>//        Get IsDate sCompileDate))           to bIsValid
73889>>>>>>>>>//        If (bIsValid = True) Begin
73889>>>>>>>>>//            Move (Date(sCompileDate))       to dCompileDate
73889>>>>>>>>>//        End
73889>>>>>>>>>//
73889>>>>>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
73889>>>>>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
73889>>>>>>>>>//        // until we encounter the program name that appears just in front of the compile date.
73889>>>>>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
73889>>>>>>>>>//        If (dCompileDate = 0) Begin
73889>>>>>>>>>//            Move "" to sCompileDate
73889>>>>>>>>>//            Move 30000 to iSize
73889>>>>>>>>>//            For iCount from 1 to iSize
73889>>>>>>>>>//                Readln channel iChannel sData
73889>>>>>>>>>//                Move (Pos(sProgram, sData)) to iPos
73889>>>>>>>>>//                If (iPos <> 0) Begin
73889>>>>>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
73889>>>>>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
73889>>>>>>>>>//                    Move iSize to iCount // We're out of here.
73889>>>>>>>>>//                End
73889>>>>>>>>>//            Loop
73889>>>>>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
73889>>>>>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
73889>>>>>>>>>//            End
73889>>>>>>>>>//            Get IsDate sCompileDate)) to bIsValid
73889>>>>>>>>>//            If (bIsValid = True) Begin
73889>>>>>>>>>//                Move (Date(sCompileDate)) to dCompileDate
73889>>>>>>>>>//            End
73889>>>>>>>>>//        End
73889>>>>>>>>>//        Send Seq_Close_Channel iChannel
73889>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
73889>>>>>>>>>
73889>>>>>>>>>        Function_Return dCompileDate
73890>>>>>>>>>    End_Function
73891>>>>>>>>>
73891>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
73891>>>>>>>>>    // (the passed program), has been finished
73891>>>>>>>>>    // The DOS box does also _not_ flash briefly.
73891>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
73893>>>>>>>>>        Handle hProcess
73893>>>>>>>>>        Integer iVoid
73893>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
73893>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
73893>>>>>>>>>
73893>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
73894>>>>>>>>>
73894>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
73895>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
73896>>>>>>>>>
73896>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
73897>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
73898>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
73898>>>>>>>>>        Move 0                       to sInfo.nShow
73899>>>>>>>>>
73899>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
73900>>>>>>>>>        Move sInfo.hProcess to hProcess
73901>>>>>>>>>        If (hProcess) Begin
73903>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
73904>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
73905>>>>>>>>>        End
73905>>>>>>>>>>
73905>>>>>>>>>    End_Procedure
73906>>>>>>>>>
73906>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
73908>>>>>>>>>        String sDirSep
73908>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
73909>>>>>>>>>        Move (Trim(sPath)) to sPath
73910>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
73912>>>>>>>>>            Move (sPath + sDirSep) to sPath
73913>>>>>>>>>        End
73913>>>>>>>>>>
73913>>>>>>>>>        Function_Return sPath
73914>>>>>>>>>    End_Function
73915>>>>>>>>>
73915>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
73915>>>>>>>>>    // or there is a problem with the certificate.
73915>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
73915>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
73915>>>>>>>>>    Function IsProgramDigitallySigned Returns String
73917>>>>>>>>>        Boolean bExists
73917>>>>>>>>>        String sPath sProgram sParams sRetval
73917>>>>>>>>>        Integer iCh
73917>>>>>>>>>
73917>>>>>>>>>        Move "" to sRetval
73918>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
73919>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
73920>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
73921>>>>>>>>>        If (bExists = False) Begin
73923>>>>>>>>>            Function_Return "-1"
73924>>>>>>>>>        End
73924>>>>>>>>>>
73924>>>>>>>>>
73924>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
73925>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
73926>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
73927>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
73928>>>>>>>>>        Get Seq_New_Channel to iCh
73929>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
73931>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
73934>>>>>>>>>        Close_Output channel iCh
73936>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
73936>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
73937>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
73939>>>>>>>>>            Readln channel iCh sRetval
73941>>>>>>>>>            Readln channel iCh sRetval
73943>>>>>>>>>            Readln channel iCh sRetval
73945>>>>>>>>>            Readln channel iCh sRetval
73947>>>>>>>>>        Close_Input channel iCh
73949>>>>>>>>>        Send Seq_Release_Channel iCh
73950>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
73952>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
73953>>>>>>>>>        End
73953>>>>>>>>>>
73953>>>>>>>>>        Else Begin
73954>>>>>>>>>            Move "" to sRetval
73955>>>>>>>>>        End
73955>>>>>>>>>>
73955>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
73955>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
73956>>>>>>>>>>
73956>>>>>>>>>        Function_Return sRetval
73957>>>>>>>>>    End_Function
73958>>>>>>>>>
73958>>>>>>>>>    Procedure Add_LineLn String sValue
73960>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
73961>>>>>>>>>    End_Procedure
73962>>>>>>>>>
73962>>>>>>>>>    Procedure Add_Line String sValue
73964>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
73965>>>>>>>>>    End_Procedure
73966>>>>>>>>>
73966>>>>>>>>>    Procedure Set Logo string sLogo
73968>>>>>>>>>        // Square bitmaps of 80x80 work best
73968>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
73969>>>>>>>>>    End_Procedure
73970>>>>>>>>>
73970>>>>>>>>>    Procedure Set LogoDF String sLogo
73972>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
73973>>>>>>>>>    End_Procedure
73974>>>>>>>>>
73974>>>>>>>>>    Procedure Show_Sysinfo
73976>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
73977>>>>>>>>>    End_Procedure
73978>>>>>>>>>
73978>>>>>>>>>    Procedure Show_HomePage String sWebpage
73980>>>>>>>>>        Handle hWnd
73980>>>>>>>>>        Get Window_Handle to hWnd
73981>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
73982>>>>>>>>>    End_Procedure
73983>>>>>>>>>
73983>>>>>>>>>End_Class
73984>>>>>>>
73984>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
73984>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
73984>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
73984>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
73984>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
73984>>>>>>>//
73984>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
73984>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
73984>>>>>>>
73984>>>>>>>
73984>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
73984>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
73984>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
73984>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
73984>>>>>>>//
73984>>>>>>>
73984>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
73985>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
73986>>>>>>>>
73986>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
73988>>>>>>>>    Integer iStart iEnd
73988>>>>>>>>    String sRetval
73988>>>>>>>>
73988>>>>>>>>    Move (Trim(sConnect)) to sConnect
73989>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
73990>>>>>>>>    If (iStart = 0) Begin
73992>>>>>>>>        Function_Return ""
73993>>>>>>>>    End
73993>>>>>>>>>
73993>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
73994>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
73995>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
73997>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
73998>>>>>>>>    End
73998>>>>>>>>>
73998>>>>>>>>    Else Begin
73999>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
74000>>>>>>>>    End
74000>>>>>>>>>
74000>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
74002>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
74003>>>>>>>>        Decrement iEnd
74004>>>>>>>>    End
74004>>>>>>>>>
74004>>>>>>>>    If (iEnd <> 0) Begin
74006>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
74007>>>>>>>>    End
74007>>>>>>>>>
74007>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
74008>>>>>>>>
74008>>>>>>>>    Function_Return (Trim(sRetval))
74009>>>>>>>>End_Function
74010>>>>>>>>
74010>>>>>>>>
74010>>>>>>>
74010>>>>>>>    Procedure Construct_Object
74012>>>>>>>        Handle ho
74012>>>>>>>        Forward Send Construct_Object
74014>>>>>>>
74014>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
74015>>>>>>>
74015>>>>>>>        Send CreateDbUpdateLibraryProperties
74016>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
74016>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
74016>>>>>>>        // etc settings.
74016>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
74018>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
74019>>>>>>>            Set phoSQLConnectionHandler to ho
74020>>>>>>>        End   
74020>>>>>>>>
74020>>>>>>>        
74020>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
74021>>>>>>>
74021>>>>>>>    End_Procedure
74022>>>>>>>
74022>>>>>>>    Procedure End_Construct_Object
74024>>>>>>>        Forward Send End_Construct_Object
74026>>>>>>>    End_Procedure
74027>>>>>>>
74027>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
74027>>>>>>>    //
74027>>>>>>>    // * Dummy function for the Studio's Code Explorer *
74027>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
74029>>>>>>>        Function_Return False
74030>>>>>>>    End_Function
74031>>>>>>>
74031>>>>>>>    // Function for creating a new *Database*.
74031>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
74031>>>>>>>    // Returns True if successful.
74031>>>>>>>    // ToDo: Currently only works for MS-SQL...
74031>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
74033>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
74033>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
74033>>>>>>>        Handle hConnection hStmt hoSQLManager
74033>>>>>>>        Integer iFetchResult iDbType
74033>>>>>>>        Boolean bOK bMertechDriver bExists
74033>>>>>>>
74033>>>>>>>        Get piDbType to iDbType
74034>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
74034>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
74036>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
74037>>>>>>>>
74037>>>>>>>            Function_Return False
74038>>>>>>>        End
74038>>>>>>>>
74038>>>>>>>
74038>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
74039>>>>>>>        If (bExists = True) Begin
74041>>>>>>>            Function_Return True
74042>>>>>>>        End
74042>>>>>>>>
74042>>>>>>>
74042>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74043>>>>>>>        If (bMertechDriver = False) Begin
74045>>>>>>>            Get phoSQLManager to hoSQLManager
74046>>>>>>>        End
74046>>>>>>>>
74046>>>>>>>        Else Begin
74047>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
74048>>>>>>>        End
74048>>>>>>>>
74048>>>>>>>
74048>>>>>>>        Get psConnectionID     to sConnectionID
74049>>>>>>>        Get psConnectionString to sConnectionString
74050>>>>>>>        Move 0 to LastErr
74051>>>>>>>
74051>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
74053>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
74053>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
74053>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
74053>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
74053>>>>>>>//                If (iPos > 0) Begin
74053>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
74053>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
74053>>>>>>>//                End
74053>>>>>>>//            End
74053>>>>>>>        End
74053>>>>>>>>
74053>>>>>>>
74053>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
74054>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
74055>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
74056>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
74058>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
74059>>>>>>>>
74059>>>>>>>            Function_Return False
74060>>>>>>>        End
74060>>>>>>>>
74060>>>>>>>
74060>>>>>>>        Get SqlOpen of hConnection to hStmt
74061>>>>>>>
74061>>>>>>>        If (hStmt = 0) Begin
74063>>>>>>>            Send SqlDisconnect of hoSQLManager
74064>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
74065>>>>>>>>
74065>>>>>>>            Function_Return False
74066>>>>>>>        End
74066>>>>>>>>
74066>>>>>>>
74066>>>>>>>        Get psCollation to sCollation
74067>>>>>>>
74067>>>>>>>        Case Begin
74067>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
74069>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
74070>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
74071>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
74072>>>>>>>
74072>>>>>>>                // Check if database exists
74072>>>>>>>                Send SqlExecDirect of hStmt sSQL
74073>>>>>>>                Get SqlFetch of hStmt to iFetchResult
74074>>>>>>>                Send SqlClose of hStmt
74075>>>>>>>                Send SqlDisconnect of hConnection
74076>>>>>>>                // If database already exists we're out of here!
74076>>>>>>>                // Note that we return True as this is not an error.
74076>>>>>>>                If (iFetchResult > 0) Begin
74078>>>>>>>                    Function_Return True
74079>>>>>>>                End
74079>>>>>>>>
74079>>>>>>>                // Database doesn't exist, create it.
74079>>>>>>>                If (iFetchResult = 0) Begin
74081>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
74082>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74083>>>>>>>                    If (sCollation <> "") Begin
74085>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
74086>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
74087>>>>>>>                    End
74087>>>>>>>>
74087>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
74088>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74089>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
74091>>>>>>>                        Function_Return False
74092>>>>>>>                    End
74092>>>>>>>>
74092>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
74092>>>>>>>                    Sleep 1
74093>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
74094>>>>>>>                End
74094>>>>>>>>
74094>>>>>>>                Case Break
74095>>>>>>>
74095>>>>>>>            Case (sDriverID = MDSPgSQL)
74098>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
74098>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
74099>>>>>>>                Case Break
74100>>>>>>>
74100>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
74103>>>>>>>                // ToDo: How should this be set/checked?
74103>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
74103>>>>>>>//                    Set psCollation to "utf8"
74103>>>>>>>//                End
74103>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
74103>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
74104>>>>>>>                Case Break
74105>>>>>>>
74105>>>>>>>            Case (sDriverID = MDSDB2)
74108>>>>>>>                Case Break
74109>>>>>>>
74109>>>>>>>            Case Else
74109>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
74110>>>>>>>>
74110>>>>>>>        Case End
74110>>>>>>>
74110>>>>>>>        If (Err = False) Begin
74112>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
74113>>>>>>>        End
74113>>>>>>>>
74113>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
74113>>>>>>>        // the one we just created.
74113>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
74115>>>>>>>            Set psDatabase to sDatabase
74116>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
74116>>>>>>>            If (bPermanantly = True) Begin
74118>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
74120>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
74121>>>>>>>                End
74121>>>>>>>>
74121>>>>>>>            End
74121>>>>>>>>
74121>>>>>>>        End
74121>>>>>>>>
74121>>>>>>>
74121>>>>>>>        Function_Return (Err = False)
74122>>>>>>>    End_Function
74123>>>>>>>
74123>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
74123>>>>>>>    // will be used.
74123>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
74125>>>>>>>        Boolean bOK bExists bShowProgress bErr
74125>>>>>>>        String sStatement sDriverID
74125>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
74125>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
74125>>>>>>>        Integer iDbType
74125>>>>>>>
74125>>>>>>>        If (sDatabase = "") Begin
74127>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
74128>>>>>>>>
74128>>>>>>>            Function_Return False
74129>>>>>>>        End
74129>>>>>>>>
74129>>>>>>>        If (sBackupName = "") Begin
74131>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
74132>>>>>>>>
74132>>>>>>>            Function_Return False
74133>>>>>>>        End
74133>>>>>>>>
74133>>>>>>>
74133>>>>>>>        // Create backup-folder if it doesn't exist
74133>>>>>>>        Get vFolderExists sPath to bExists
74134>>>>>>>        If (bExists = False) Begin
74136>>>>>>>            Get vCreateDirectory sPath to bErr
74137>>>>>>>            If (bErr = True) Begin
74139>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
74140>>>>>>>>
74140>>>>>>>                Function_Return False
74141>>>>>>>            End
74141>>>>>>>>
74141>>>>>>>        End
74141>>>>>>>>
74141>>>>>>>        // Make sure the path ends with a back-slash
74141>>>>>>>        If (sPath <> "") Begin
74143>>>>>>>            Get vFolderFormat sPath to sPath
74144>>>>>>>        End
74144>>>>>>>>
74144>>>>>>>
74144>>>>>>>        Get psDriverID to sDriverID
74145>>>>>>>        Get piDbType   to iDbType
74146>>>>>>>        If (num_arguments > 3) Begin
74148>>>>>>>            Move bShowProg to bShowProgress
74149>>>>>>>        End
74149>>>>>>>>
74149>>>>>>>
74149>>>>>>>        Case Begin
74149>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
74151>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
74151>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
74151>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
74152>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
74153>>>>>>>
74153>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
74154>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
74155>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
74156>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
74157>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
74158>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
74159>>>>>>>                Case Break
74160>>>>>>>            Case Else
74160>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
74161>>>>>>>        Case End
74161>>>>>>>
74161>>>>>>>        Function_Return bOK
74162>>>>>>>    End_Function
74163>>>>>>>
74163>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
74165>>>>>>>//        Boolean bOK bExists
74165>>>>>>>        String sStatement sDriverID sRetval //sPrevious
74165>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
74165>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
74165>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
74165>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
74165>>>>>>>        tSQLConnection SQLConnection
74165>>>>>>>        tSQLConnection SQLConnection
74165>>>>>>>
74165>>>>>>>        If (sDatabase = "") Begin
74167>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
74168>>>>>>>>
74168>>>>>>>            Function_Return ""
74169>>>>>>>        End
74169>>>>>>>>
74169>>>>>>>
74169>>>>>>>        Move "" to sRetval
74170>>>>>>>        Get psDriverID to sDriverID
74171>>>>>>>        Get piDbType   to iDbType
74172>>>>>>>
74172>>>>>>>        Case Begin
74172>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
74174>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
74174>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
74175>>>>>>>
74175>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
74176>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
74177>>>>>>>                Get phoSQLManager to hoSQLHandler
74178>>>>>>>
74178>>>>>>>                If (hoSQLHandler <> 0) Begin
74180>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
74181>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
74182>>>>>>>
74182>>>>>>>                    If (hoSQLConnect <> 0) Begin
74184>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
74185>>>>>>>                        If (hstmt <> 0) Begin
74187>>>>>>>                            Send SqlExecDirect of hstmt sStatement
74188>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
74189>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
74190>>>>>>>                            If (iFetchResult <> 0) Begin
74192>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
74193>>>>>>>                            End
74193>>>>>>>>
74193>>>>>>>                            Send SQLClose of hstmt
74194>>>>>>>                        End
74194>>>>>>>>
74194>>>>>>>                        Send SQLDisconnect of hoSQLConnect
74195>>>>>>>                    End
74195>>>>>>>>
74195>>>>>>>                End
74195>>>>>>>>
74195>>>>>>>                Case Break
74196>>>>>>>            Case Else
74196>>>>>>>                If (bSilent = False) Begin
74198>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
74199>>>>>>>                End
74199>>>>>>>>
74199>>>>>>>        Case End
74199>>>>>>>
74199>>>>>>>        Function_Return sRetval
74200>>>>>>>    End_Function
74201>>>>>>>
74201>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
74203>>>>>>>        Boolean bMertechDriver // bOK bExists 
74203>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
74203>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
74203>>>>>>>        Handle hConnection hStmt hoSQLManager
74203>>>>>>>        Integer iDbType // iFetchResult
74203>>>>>>>
74203>>>>>>>        If (sDatabase = "") Begin
74205>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
74206>>>>>>>>
74206>>>>>>>            Function_Return False
74207>>>>>>>        End
74207>>>>>>>>
74207>>>>>>>
74207>>>>>>>        If (sSQLCollation = "") Begin
74209>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
74210>>>>>>>>
74210>>>>>>>            Function_Return False
74211>>>>>>>        End
74211>>>>>>>>
74211>>>>>>>
74211>>>>>>>        Get psDriverID to sDriverID
74212>>>>>>>        Get piDbType   to iDbType
74213>>>>>>>
74213>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74214>>>>>>>        If (bMertechDriver = False) Begin
74216>>>>>>>            Get phoSQLManager to hoSQLManager
74217>>>>>>>        End
74217>>>>>>>>
74217>>>>>>>        Else Begin
74218>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
74219>>>>>>>        End
74219>>>>>>>>
74219>>>>>>>
74219>>>>>>>        Get psConnectionID     to sConnectionID
74220>>>>>>>        Get psConnectionString to sConnectionString
74221>>>>>>>        Move 0 to LastErr
74222>>>>>>>
74222>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
74223>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
74224>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
74225>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
74227>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
74228>>>>>>>>
74228>>>>>>>            Function_Return False
74229>>>>>>>        End
74229>>>>>>>>
74229>>>>>>>
74229>>>>>>>        Get SqlOpen of hConnection to hStmt
74230>>>>>>>
74230>>>>>>>        If (hStmt = 0) Begin
74232>>>>>>>            Send SqlDisconnect of hoSQLManager
74233>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
74234>>>>>>>>
74234>>>>>>>            Function_Return False
74235>>>>>>>        End
74235>>>>>>>>
74235>>>>>>>
74235>>>>>>>        // Check if collation already exists
74235>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
74236>>>>>>>        // If the current collate is the same as the new; do nothing.
74236>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
74238>>>>>>>            Function_Return True
74239>>>>>>>        End
74239>>>>>>>>
74239>>>>>>>
74239>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
74240>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
74241>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
74242>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
74243>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
74244>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
74245>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
74246>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
74247>>>>>>>
74247>>>>>>>        // MS-SQL Syntax:
74247>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
74247>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
74247>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
74247>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
74248>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
74249>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
74250>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
74250>>>>>>>
74250>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74251>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
74252>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74253>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
74255>>>>>>>           Function_Return False
74256>>>>>>>        End
74256>>>>>>>>
74256>>>>>>>
74256>>>>>>>        Function_Return (Err = False)
74257>>>>>>>    End_Function
74258>>>>>>>
74258>>>>>>>
74258>>>>>>>    // * Dummy function for the Studio's Code Explorer *
74258>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
74260>>>>>>>        Function_Return False
74261>>>>>>>    End_Function
74262>>>>>>>
74262>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
74262>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
74262>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
74262>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
74262>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
74262>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
74264>>>>>>>        Handle hToTable
74264>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
74264>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
74264>>>>>>>        tSQLConnection SQLConnection
74264>>>>>>>        tSQLConnection SQLConnection
74264>>>>>>>        Integer iPos iMaxRecords
74264>>>>>>>
74264>>>>>>>        Get psDriverID to sDriverID
74265>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
74266>>>>>>>        If (bExists = False) Begin
74268>>>>>>>            Function_Return False
74269>>>>>>>        End
74269>>>>>>>>
74269>>>>>>>
74269>>>>>>>        If (num_arguments > 1) Begin
74271>>>>>>>            Move bCpyDat to bCopyData
74272>>>>>>>        End
74272>>>>>>>>
74272>>>>>>>        Else Begin
74273>>>>>>>            Move False to bCopyData
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>
74274>>>>>>>        Open hTable
74276>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
74279>>>>>>>        If (bOpened = False) Begin
74281>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
74282>>>>>>>>
74282>>>>>>>            Function_Return False
74283>>>>>>>        End
74283>>>>>>>>
74283>>>>>>>        Move 0 to hToTable
74284>>>>>>>
74284>>>>>>>        Move 16711679 to iMaxRecords
74285>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
74288>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
74289>>>>>>>        If (iPos > 0) Begin
74291>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
74292>>>>>>>        End
74292>>>>>>>>
74292>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
74295>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
74296>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
74297>>>>>>>
74297>>>>>>>        If (ghoProgressBar <> 0) Begin
74299>>>>>>>            Send DoAdvance of ghoProgressBar
74300>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
74301>>>>>>>        End
74301>>>>>>>>
74301>>>>>>>
74301>>>>>>>        Move False to Err
74302>>>>>>>
74302>>>>>>>        Structure_Start hToTable DATAFLEX_ID
74303>>>>>>>            Structure_Copy hTable to hToTable
74304>>>>>>>
74304>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
74307>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
74310>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
74313>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
74316>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
74319>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
74320>>>>>>>
74320>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
74322>>>>>>>
74322>>>>>>>        Set Action_Text of ghoStatusPanel to ""
74323>>>>>>>        Move (not(Err)) to bOK
74324>>>>>>>        If (bOK = True and bCopyData = True) Begin
74326>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
74327>>>>>>>        End
74327>>>>>>>>
74327>>>>>>>
74327>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74328>>>>>>>        If (bMertechDriver = True) Begin
74330>>>>>>>            Open hTable
74332>>>>>>>        End
74332>>>>>>>>
74332>>>>>>>
74332>>>>>>>        // This must be after copying data...
74332>>>>>>>        If (Err = False) Begin
74334>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
74337>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
74340>>>>>>>        End
74340>>>>>>>>
74340>>>>>>>        Move (not(Err)) to bOK
74341>>>>>>>
74341>>>>>>>        Function_Return (bOK = True)
74342>>>>>>>    End_Function
74343>>>>>>>
74343>>>>>>>    Function AddFolderDelimiter String sPath Returns String
74345>>>>>>>        String sDirSep
74345>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74346>>>>>>>        Move (Trim(sPath)) to sPath
74347>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
74349>>>>>>>            Move (sPath + sDirSep) to sPath
74350>>>>>>>        End
74350>>>>>>>>
74350>>>>>>>        Function_Return sPath
74351>>>>>>>    End_Function
74352>>>>>>>
74352>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
74352>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
74352>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
74354>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
74354>>>>>>>        Integer iDbType
74354>>>>>>>        Boolean bExists
74354>>>>>>>
74354>>>>>>>        Get psDriverID to sDriverID
74355>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74356>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
74357>>>>>>>        If (bExists = True) Begin
74359>>>>>>>            Function_Return False
74360>>>>>>>        End
74360>>>>>>>>
74360>>>>>>>
74360>>>>>>>        Get psDataPathFirstPart to sPath
74361>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
74362>>>>>>>
74362>>>>>>>        Get piDbType to iDbType
74363>>>>>>>        Get _SqlProperTableName sTableName to sTableName
74364>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
74365>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
74366>>>>>>>
74366>>>>>>>        Move False to Err
74367>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74368>>>>>>>
74368>>>>>>>        Function_Return (Err = False)
74369>>>>>>>    End_Function
74370>>>>>>>
74370>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
74370>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
74370>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
74372>>>>>>>        String sSQLString sPath sCreateTable sDriverID
74372>>>>>>>        Integer iDbType
74372>>>>>>>        Boolean bExists
74372>>>>>>>
74372>>>>>>>        Get psDriverID to sDriverID
74373>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
74374>>>>>>>        If (bExists = True) Begin
74376>>>>>>>            Function_Return False
74377>>>>>>>        End
74377>>>>>>>>
74377>>>>>>>
74377>>>>>>>        Get psDataPathFirstPart to sPath
74378>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
74379>>>>>>>        If (bExists = True) Begin
74381>>>>>>>            // ToDo: What should we do if an .int file already exists?
74381>>>>>>>        End
74381>>>>>>>>
74381>>>>>>>
74381>>>>>>>        Get piDbType to iDbType
74382>>>>>>>        Get _SqlProperTableName sTableName to sTableName
74383>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
74384>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
74385>>>>>>>
74385>>>>>>>        Move False to Err
74386>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74387>>>>>>>
74387>>>>>>>        Function_Return (Err = False)
74388>>>>>>>    End_Function
74389>>>>>>>    
74389>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
74389>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
74389>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
74391>>>>>>>        Boolean bOK                                                            
74391>>>>>>>        String sStatement
74391>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
74392>>>>>>>        Function_Return bOK
74393>>>>>>>    End_Function
74394>>>>>>>    
74394>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
74394>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
74394>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
74394>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
74396>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
74396>>>>>>>        Integer iRetval iDbType
74396>>>>>>>        Boolean bExists bMertechDriver bOK
74396>>>>>>>
74396>>>>>>>        Get psDriverID to sDriverID
74397>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74398>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74399>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
74400>>>>>>>        If (bExists = False) Begin
74402>>>>>>>            Function_Return False
74403>>>>>>>        End
74403>>>>>>>>
74403>>>>>>>
74403>>>>>>>        Get psDataPathFirstPart to sPath
74404>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
74405>>>>>>>
74405>>>>>>>        Get piDbType to iDbType
74406>>>>>>>        Get _SqlProperTableName sTableName to sTableName
74407>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
74408>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
74409>>>>>>>
74409>>>>>>>        Move False to Err
74410>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74411>>>>>>>
74411>>>>>>>        // We also need to remove the cache-file since the table has been changed
74411>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74412>>>>>>>
74412>>>>>>>        Function_Return (Err = False)
74413>>>>>>>    End_Function
74414>>>>>>>
74414>>>>>>>    // First deletes the data cache file and then drops the passed data table.
74414>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
74416>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
74416>>>>>>>        Integer iRetval iDbType
74416>>>>>>>        Boolean bMertechDriver bOK
74416>>>>>>>
74416>>>>>>>        Get psDriverID to sDriverID
74417>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74418>>>>>>>        Get psDataPathFirstPart to sPath
74419>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
74420>>>>>>>
74420>>>>>>>        Get piDbType to iDbType
74421>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
74422>>>>>>>        Get psSchema to sSchema
74423>>>>>>>        If (sSchema = "") Begin
74425>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
74426>>>>>>>        End
74426>>>>>>>>
74426>>>>>>>        Move (Uppercase(sTableName)) to sVal
74427>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
74429>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
74430>>>>>>>        End
74430>>>>>>>>
74430>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
74431>>>>>>>
74431>>>>>>>        Move False to Err
74432>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74433>>>>>>>
74433>>>>>>>        // We also need to remove the cache-file since the table has been changed
74433>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74434>>>>>>>
74434>>>>>>>        Function_Return (Err = False)
74435>>>>>>>    End_Function
74436>>>>>>>
74436>>>>>>>    // *** Sql View Messages ***
74436>>>>>>>
74436>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
74436>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
74438>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
74438>>>>>>>        Integer iRetval
74438>>>>>>>        Boolean bMertechDriver bOK
74438>>>>>>>
74438>>>>>>>        Get psDriverID to sDriverID
74439>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74440>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
74441>>>>>>>
74441>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
74442>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
74443>>>>>>>        Set psSQLStatementString to sSQLString
74444>>>>>>>
74444>>>>>>>        // As we don't check if the view exist or not, it might happen
74444>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
74444>>>>>>>        Move False to Err
74445>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
74446>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74447>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
74448>>>>>>>        Move 0 to LastErr
74449>>>>>>>
74449>>>>>>>        // We also need to remove the cache-file since the table has been changed
74449>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
74450>>>>>>>
74450>>>>>>>        Function_Return (Err = False)
74451>>>>>>>    End_Function
74452>>>>>>>
74452>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
74454>>>>>>>        Boolean bOK
74454>>>>>>>        Integer iDbType
74454>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
74454>>>>>>>
74454>>>>>>>        Get psDriverID to sDriverID
74455>>>>>>>        Get piDbType   to iDbType
74456>>>>>>>
74456>>>>>>>        Case Begin
74456>>>>>>>            Case (iDbType = EN_DbTypeDB2)
74458>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
74459>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
74460>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
74461>>>>>>>            Break
74462>>>>>>>
74462>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
74465>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
74466>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
74467>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
74468>>>>>>>            Break
74469>>>>>>>
74469>>>>>>>            Case (iDbType = EN_DbTypeOracle)
74472>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
74473>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
74474>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
74475>>>>>>>            Break
74476>>>>>>>
74476>>>>>>>            Case (iDbType = EN_DbTypePostgre)
74479>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
74480>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
74481>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
74482>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
74483>>>>>>>            Break
74484>>>>>>>
74484>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
74487>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
74488>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
74489>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
74490>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
74491>>>>>>>            Break
74492>>>>>>>        Case End
74492>>>>>>>
74492>>>>>>>        Move False to Err
74493>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
74494>>>>>>>        Move (Err = False) to bOK
74495>>>>>>>
74495>>>>>>>        Function_Return bOK
74496>>>>>>>    End_Function
74497>>>>>>>
74497>>>>>>>    // * Dummy function for the Studio's Code Explorer *
74497>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
74499>>>>>>>        Function_Return False
74500>>>>>>>    End_Function
74501>>>>>>>
74501>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
74501>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
74503>>>>>>>        Integer iLength iDecimals
74503>>>>>>>        String sColumnValue
74503>>>>>>>        String sTableName sDriverID
74503>>>>>>>        Boolean bOK bInitializeValue
74503>>>>>>>
74503>>>>>>>        Get psDriverID to sDriverID
74504>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74505>>>>>>>        If (bOK = False) Begin
74507>>>>>>>            Function_Return False
74508>>>>>>>        End
74508>>>>>>>>
74508>>>>>>>
74508>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74509>>>>>>>        If (sTableName = "") Begin
74511>>>>>>>            Function_Return False
74512>>>>>>>        End
74512>>>>>>>>
74512>>>>>>>
74512>>>>>>>        If (num_arguments > 3) Begin
74514>>>>>>>            Move iLen     to iLength
74515>>>>>>>            Move iDec     to iDecimals
74516>>>>>>>            Move bInitVal to bInitializeValue
74517>>>>>>>            Move sColVal  to sColumnValue
74518>>>>>>>        End
74518>>>>>>>>
74518>>>>>>>
74518>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
74519>>>>>>>
74519>>>>>>>        Function_Return (bOK = True)
74520>>>>>>>    End_Function
74521>>>>>>>
74521>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
74521>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
74523>>>>>>>        Integer iDbType iLength iDecimals iDriver
74523>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
74523>>>>>>>        String sDriverID sNotNull
74523>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
74523>>>>>>>        Handle hTable
74523>>>>>>>
74523>>>>>>>        Get psDriverID to sDriverID
74524>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74525>>>>>>>        If (bOK = False) Begin
74527>>>>>>>            Function_Return True
74528>>>>>>>        End
74528>>>>>>>>
74528>>>>>>>
74528>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
74529>>>>>>>        If (hTable = 0) Begin
74531>>>>>>>            Get NextFreeFilelistSlot to hTable
74532>>>>>>>        End
74532>>>>>>>>
74532>>>>>>>
74532>>>>>>>        Get piDbType to iDbType
74533>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
74533>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
74534>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
74536>>>>>>>            Function_Return True
74537>>>>>>>        End
74537>>>>>>>>
74537>>>>>>>
74537>>>>>>>        Get DriverIndex sDriverID to iDriver
74538>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
74539>>>>>>>        If (bIsMertechDriver = False) Begin
74541>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74544>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
74547>>>>>>>        End
74547>>>>>>>>
74547>>>>>>>
74547>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
74548>>>>>>>        If (num_arguments > 3) Begin
74550>>>>>>>            Move iLen     to iLength
74551>>>>>>>            Move iDec     to iDecimals
74552>>>>>>>            Move bInitVal to bInitializeValue
74553>>>>>>>            Move sColVal  to sColumnValue
74554>>>>>>>        End
74554>>>>>>>>
74554>>>>>>>
74554>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
74555>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
74556>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
74557>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
74558>>>>>>>
74558>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
74559>>>>>>>        If (bFixed = False) Begin
74561>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
74562>>>>>>>        End
74562>>>>>>>>
74562>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
74563>>>>>>>
74563>>>>>>>        Move False to Err
74564>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
74565>>>>>>>
74565>>>>>>>        If (bInitializeValue = True and Err = False) Begin
74567>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
74568>>>>>>>        End
74568>>>>>>>>
74568>>>>>>>
74568>>>>>>>        If (Err = False) Begin
74570>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
74571>>>>>>>        End
74571>>>>>>>>
74571>>>>>>>
74571>>>>>>>        Move (not(Err)) to bRetval
74572>>>>>>>
74572>>>>>>>        // We also need to remove the cache-file since the table has been changed
74572>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74573>>>>>>>        If (bIsMertechDriver = False) Begin
74575>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74578>>>>>>>        End
74578>>>>>>>>
74578>>>>>>>        Function_Return bRetval
74579>>>>>>>    End_Function
74580>>>>>>>
74580>>>>>>>    // To update all current rows for a table column with a common value.
74580>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
74582>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
74582>>>>>>>        Boolean bRetval bSQLDriver
74582>>>>>>>        Integer iCurrErr iDbType
74582>>>>>>>
74582>>>>>>>        Move False to bRetval
74583>>>>>>>        Get piDbType to iDbType
74584>>>>>>>        Get psDriverID to sDriverID
74585>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
74586>>>>>>>        If (bSQLDriver = False) Begin
74588>>>>>>>            Function_Return bRetval
74589>>>>>>>        End
74589>>>>>>>>
74589>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74590>>>>>>>
74590>>>>>>>        Move Err to iCurrErr
74591>>>>>>>        Move False to Err
74592>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
74593>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
74594>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
74595>>>>>>>        If (sDriverID = MDSMySQL) Begin
74597>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
74598>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
74599>>>>>>>        End
74599>>>>>>>>
74599>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
74599>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
74601>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
74602>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
74603>>>>>>>        End
74603>>>>>>>>
74603>>>>>>>        Else Begin
74604>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
74605>>>>>>>        End
74605>>>>>>>>
74605>>>>>>>
74605>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
74606>>>>>>>        Move (Err = False) to bRetval
74607>>>>>>>        Move iCurrErr to Err
74608>>>>>>>
74608>>>>>>>        Function_Return bRetval
74609>>>>>>>    End_Function
74610>>>>>>>
74610>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
74610>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
74610>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
74612>>>>>>>        String sDriverID sTableName
74612>>>>>>>        Boolean bOK
74612>>>>>>>
74612>>>>>>>        Get psDriverID to sDriverID
74613>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74614>>>>>>>        If (bOK = False) Begin
74616>>>>>>>            Function_Return False
74617>>>>>>>        End
74617>>>>>>>>
74617>>>>>>>
74617>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74618>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
74619>>>>>>>
74619>>>>>>>        Function_Return (Err = False)
74620>>>>>>>    End_Function
74621>>>>>>>
74621>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
74621>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
74621>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
74621>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
74623>>>>>>>        Integer iDbType iLength iDecimals
74623>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
74623>>>>>>>        Boolean bExists bOK bFixed
74623>>>>>>>        Handle hTable
74623>>>>>>>
74623>>>>>>>        Get psDriverID to sDriverID
74624>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74625>>>>>>>        If (bOK = False) Begin
74627>>>>>>>            Function_Return False
74628>>>>>>>        End
74628>>>>>>>>
74628>>>>>>>
74628>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
74629>>>>>>>        If (hTable = 0) Begin
74631>>>>>>>            Get NextFreeFilelistSlot to hTable
74632>>>>>>>        End
74632>>>>>>>>
74632>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
74633>>>>>>>        If (bExists = False) Begin
74635>>>>>>>            Function_Return False
74636>>>>>>>        End
74636>>>>>>>>
74636>>>>>>>
74636>>>>>>>        If (num_arguments > 3) Begin
74638>>>>>>>            Move iLen to iLength
74639>>>>>>>        End
74639>>>>>>>>
74639>>>>>>>        If (num_arguments > 4) Begin
74641>>>>>>>            Move iDec to iDecimals
74642>>>>>>>        End
74642>>>>>>>>
74642>>>>>>>
74642>>>>>>>        Get piDbType to iDbType
74643>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
74644>>>>>>>
74644>>>>>>>        Move False to Err
74645>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
74646>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
74647>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
74648>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
74649>>>>>>>
74649>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
74650>>>>>>>        If (bFixed = False) Begin
74652>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
74653>>>>>>>        End
74653>>>>>>>>
74653>>>>>>>
74653>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
74654>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
74655>>>>>>>
74655>>>>>>>        // We also need to remove the cache-file since the table has been changed
74655>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74656>>>>>>>
74656>>>>>>>        Function_Return (Err = False)
74657>>>>>>>    End_Function
74658>>>>>>>
74658>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
74660>>>>>>>        Boolean bOK bErr bIsSQLDriver
74660>>>>>>>        String sDriverID
74660>>>>>>>        Integer iDataType
74660>>>>>>>
74660>>>>>>>        Get psDriverID to sDriverID
74661>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
74662>>>>>>>        If (bIsSQLDriver = False) Begin
74664>>>>>>>            Function_Return False
74665>>>>>>>        End
74665>>>>>>>>
74665>>>>>>>
74665>>>>>>>        Move Err to bErr
74666>>>>>>>        Move False to bErr
74667>>>>>>>
74667>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
74667>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
74667>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
74668>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
74671>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
74673>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
74674>>>>>>>        End
74674>>>>>>>>
74674>>>>>>>
74674>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
74677>>>>>>>        Move (not(Err)) to bOK
74678>>>>>>>        Move bErr to Err
74679>>>>>>>
74679>>>>>>>        Function_Return bOK
74680>>>>>>>    End_Function
74681>>>>>>>
74681>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
74683>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
74683>>>>>>>        String sDriverID
74683>>>>>>>
74683>>>>>>>        Get psDriverID to sDriverID
74684>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
74685>>>>>>>        If (bIsSQLDriver = False) Begin
74687>>>>>>>            Function_Return False
74688>>>>>>>        End
74688>>>>>>>>
74688>>>>>>>
74688>>>>>>>        Move Err to bErr
74689>>>>>>>        Move False to bErr
74690>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
74693>>>>>>>        If (bNullable = bCurrentState) Begin
74695>>>>>>>            Function_Return True
74696>>>>>>>        End
74696>>>>>>>>
74696>>>>>>>
74696>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
74699>>>>>>>        If (bOpen = False) Begin
74701>>>>>>>            Get AutoConnectionIDLogin to bOK
74702>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
74703>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
74704>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74705>>>>>>>            Open hTable
74707>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
74708>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
74709>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
74710>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
74713>>>>>>>        End
74713>>>>>>>>
74713>>>>>>>        If (bOpen = True) Begin
74715>>>>>>>            Structure_Start hTable sDriverID
74716>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
74719>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
74720>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
74722>>>>>>>            Set Action_Text of ghoStatusPanel to ""
74723>>>>>>>        End
74723>>>>>>>>
74723>>>>>>>
74723>>>>>>>        Move (not(Err)) to bOK
74724>>>>>>>        Move bErr to Err
74725>>>>>>>
74725>>>>>>>        Function_Return bOK
74726>>>>>>>    End_Function
74727>>>>>>>
74727>>>>>>>    // Drop column by its table handle
74727>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
74729>>>>>>>        String sDriverID sTableName
74729>>>>>>>        Boolean bOK
74729>>>>>>>
74729>>>>>>>        Get psDriverID to sDriverID
74730>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74731>>>>>>>        If (bOK = False) Begin
74733>>>>>>>            Function_Return False
74734>>>>>>>        End
74734>>>>>>>>
74734>>>>>>>
74734>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74735>>>>>>>        If (sTableName = "") Begin
74737>>>>>>>            Function_Return False
74738>>>>>>>        End
74738>>>>>>>>
74738>>>>>>>
74738>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
74739>>>>>>>
74739>>>>>>>        Function_Return (bOK = True)
74740>>>>>>>    End_Function
74741>>>>>>>
74741>>>>>>>    // Drop column by its table name as a string.
74741>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
74743>>>>>>>        Integer iDbType iDriver
74743>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
74743>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
74743>>>>>>>        Handle hTable
74743>>>>>>>
74743>>>>>>>        Get psDriverID to sDriverID
74744>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74745>>>>>>>        If (bOK = False) Begin
74747>>>>>>>            Function_Return False
74748>>>>>>>        End
74748>>>>>>>>
74748>>>>>>>
74748>>>>>>>        Get DriverIndex sDriverID to iDriver
74749>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74752>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
74755>>>>>>>
74755>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
74756>>>>>>>        If (hTable <> 0) Begin
74758>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
74759>>>>>>>            If (bExists = False) Begin
74761>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74764>>>>>>>                Function_Return False
74765>>>>>>>            End
74765>>>>>>>>
74765>>>>>>>        End
74765>>>>>>>>
74765>>>>>>>
74765>>>>>>>        Get piDbType to iDbType
74766>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
74768>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
74769>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
74770>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74773>>>>>>>            Function_Return bOK
74774>>>>>>>        End
74774>>>>>>>>
74774>>>>>>>
74774>>>>>>>        Move False to Err
74775>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
74776>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
74777>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
74778>>>>>>>
74778>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
74779>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
74780>>>>>>>        Move (not(Err)) to bRetval
74781>>>>>>>
74781>>>>>>>        // We also need to remove the cache-file since the table has been changed
74781>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74782>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
74785>>>>>>>
74785>>>>>>>        Function_Return bRetval
74786>>>>>>>    End_Function
74787>>>>>>>
74787>>>>>>>    // Rename a field/column by table handle (filelist number)
74787>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
74789>>>>>>>        String sDriverID sTableName
74789>>>>>>>        Boolean bOK
74789>>>>>>>
74789>>>>>>>        Get psDriverID to sDriverID
74790>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74791>>>>>>>        If (bOK = False) Begin
74793>>>>>>>            Function_Return False
74794>>>>>>>        End
74794>>>>>>>>
74794>>>>>>>
74794>>>>>>>        Get UtilTableHandleToString hTable to sTableName
74795>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
74796>>>>>>>
74796>>>>>>>        Function_Return (Err = False)
74797>>>>>>>    End_Function
74798>>>>>>>
74798>>>>>>>    // Rename a field/column by table name.
74798>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
74800>>>>>>>        Integer iDbType iDataType
74800>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
74800>>>>>>>        Boolean bOK bRetval
74800>>>>>>>        Handle hTable
74800>>>>>>>
74800>>>>>>>        Move sTableName to sOrgTableName
74801>>>>>>>        Get psDriverID to sDriverID
74802>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74803>>>>>>>        If (bOK = False) Begin
74805>>>>>>>            Function_Return False
74806>>>>>>>        End
74806>>>>>>>>
74806>>>>>>>
74806>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
74807>>>>>>>        If (sVal = "") Begin
74809>>>>>>>            Function_Return False
74810>>>>>>>        End
74810>>>>>>>>
74810>>>>>>>
74810>>>>>>>        Get piDbType to iDbType
74811>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
74812>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
74813>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
74814>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
74815>>>>>>>
74815>>>>>>>        Case Begin
74815>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
74817>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
74818>>>>>>>                Case Break
74819>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
74819>>>>>>>            Case (iDbType = EN_dbTypeOracle)
74822>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
74823>>>>>>>                Case Break
74824>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
74824>>>>>>>            Case (iDbType = EN_dbTypeDB2)
74827>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
74828>>>>>>>                Case Break
74829>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
74829>>>>>>>            Case (iDbType = EN_dbTypePostgre)
74832>>>>>>>                Move sOrgTableName to sTableName
74833>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
74834>>>>>>>                Case Break
74835>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
74838>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
74838>>>>>>>                Move sOrgTableName to sTableName
74839>>>>>>>                Get psDatabase to sDatabase
74840>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
74841>>>>>>>                If (hTable = 0) Begin
74843>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
74844>>>>>>>                    If (bOK = False) Begin
74846>>>>>>>                        Function_Return False
74847>>>>>>>                    End
74847>>>>>>>>
74847>>>>>>>                    Get NextFreeFilelistSlot to hTable
74848>>>>>>>                End
74848>>>>>>>>
74848>>>>>>>                Else Begin
74849>>>>>>>                    Open hTable
74851>>>>>>>                End
74851>>>>>>>>
74851>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
74852>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
74853>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
74854>>>>>>>                Case Break
74855>>>>>>>            Case Else
74855>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
74856>>>>>>>        Case End
74856>>>>>>>
74856>>>>>>>        Move False to Err
74857>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
74858>>>>>>>        Move (Err = False) to bRetval
74859>>>>>>>        // We also need to remove the cache-file since the table has been changed
74859>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
74860>>>>>>>
74860>>>>>>>        Function_Return bRetval
74861>>>>>>>    End_Function
74862>>>>>>>
74862>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
74864>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
74864>>>>>>>        Boolean bMertechDriver
74864>>>>>>>        Integer iNumCols iCount iDataType
74864>>>>>>>        String sValue
74864>>>>>>>
74864>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74865>>>>>>>        If (bMertechDriver = False) Begin
74867>>>>>>>            Get phoSQLManager to hoSQLHandler
74868>>>>>>>        End
74868>>>>>>>>
74868>>>>>>>        Else Begin
74869>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
74870>>>>>>>        End
74870>>>>>>>>
74870>>>>>>>
74870>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
74871>>>>>>>        If (hSQLConnect <> 0) Begin
74873>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
74874>>>>>>>            If (hStmt <> 0) Begin
74876>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
74877>>>>>>>
74877>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
74878>>>>>>>                For iCount from 1 to iNumCols
74884>>>>>>>>
74884>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
74885>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
74887>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
74888>>>>>>>                        Move iNumCols to iCount // We're out of here
74889>>>>>>>                    End
74889>>>>>>>>
74889>>>>>>>                Loop
74890>>>>>>>>
74890>>>>>>>
74890>>>>>>>                Send SQLClose of hStmt
74891>>>>>>>            End
74891>>>>>>>>
74891>>>>>>>            Send SQLDisconnect of hSQLConnect
74892>>>>>>>        End
74892>>>>>>>>
74892>>>>>>>
74892>>>>>>>        Function_Return iDataType
74893>>>>>>>    End_Function
74894>>>>>>>
74894>>>>>>>    // * Dummy function for the Studio's Code Explorer *
74894>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
74896>>>>>>>        Function_Return False
74897>>>>>>>    End_Function
74898>>>>>>>
74898>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
74900>>>>>>>        String sMessage // sConnectionString
74900>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
74900>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
74900>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
74903>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
74903>>>>>>>        TimeSpan tsQuery tsFetch
74903>>>>>>>        tSqlErrorArray aSqlErrorArray
74903>>>>>>>        tSqlErrorArray aSqlErrorArray
74903>>>>>>>        Boolean bOK bMertechDriver bShowProgress
74903>>>>>>>        tSQLConnection SQLConnection
74903>>>>>>>        tSQLConnection SQLConnection
74903>>>>>>>
74903>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
74904>>>>>>>        If (bOK = False) Begin
74906>>>>>>>            Procedure_Return
74907>>>>>>>        End
74907>>>>>>>>
74907>>>>>>>
74907>>>>>>>        If (num_arguments > 2) Begin
74909>>>>>>>            Move bShowProgr to bShowProgress
74910>>>>>>>        End
74910>>>>>>>>
74910>>>>>>>
74910>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
74911>>>>>>>
74911>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
74912>>>>>>>        If (bMertechDriver = True) Begin
74914>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
74915>>>>>>>        End
74915>>>>>>>>
74915>>>>>>>        If (bMertechDriver = False) Begin
74917>>>>>>>            Get phoSQLManager to hoSqlHandler
74918>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
74919>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
74920>>>>>>>        End
74920>>>>>>>>
74920>>>>>>>
74920>>>>>>>        If (hoSQLConnect <> 0) Begin
74922>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
74923>>>>>>>            If (hoStmt <> 0) Begin
74925>>>>>>>                // record starting date/time stamp
74925>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
74926>>>>>>>                // turn on error handling if enabled
74926>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
74928>>>>>>>                    Set pbSqlError to False
74929>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
74930>>>>>>>                    Move Error_Object_Id to hoError
74931>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
74933>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
74934>>>>>>>                    End
74934>>>>>>>>
74934>>>>>>>                    Else Begin
74935>>>>>>>                        Move Self to Error_Object_Id
74936>>>>>>>                    End
74936>>>>>>>>
74936>>>>>>>                End
74936>>>>>>>>
74936>>>>>>>
74936>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
74936>>>>>>>                Set psSQLStatementString to sStmt
74937>>>>>>>                Send Cursor_Wait of Cursor_Control
74938>>>>>>>                Send SqlExecDirect of hoStmt sStmt
74939>>>>>>>                Send Cursor_Ready of Cursor_Control
74940>>>>>>>
74940>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
74942>>>>>>>                    Move hoError to Error_Object_Id
74943>>>>>>>                End
74943>>>>>>>>
74943>>>>>>>
74943>>>>>>>                Move 0 to iMsgs
74944>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
74944>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
74944>>>>>>>                If (bMertechDriver = False) Begin
74946>>>>>>>                    Move Err to iErr
74947>>>>>>>                    Move LastErr to iLastErr
74948>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
74949>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
74950>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
74951>>>>>>>                    Send _SqlColumnInfo hoStmt
74952>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
74953>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
74954>>>>>>>                    Repeat
74954>>>>>>>>
74954>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
74955>>>>>>>                        If (iFetchResult <> 0) Begin
74957>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
74958>>>>>>>                        End
74958>>>>>>>>
74958>>>>>>>                    Until (iFetchResult = 0)
74960>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
74961>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
74962>>>>>>>                    Move iErr to Err
74963>>>>>>>                    Move iLastErr to LastErr
74964>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
74965>>>>>>>                End
74965>>>>>>>>
74965>>>>>>>
74965>>>>>>>                Set piRows    to iRows
74966>>>>>>>                Set piRowType to iRowType
74967>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
74968>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
74969>>>>>>>
74969>>>>>>>                If (iMsgs <> 0) Begin
74971>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
74973>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
74974>>>>>>>                    End
74974>>>>>>>>
74974>>>>>>>                    For i from 1 to iMsgs
74980>>>>>>>>
74980>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
74981>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
74982>>>>>>>                        If (bShowProgress = True) Begin
74984>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
74986>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
74987>>>>>>>                            End
74987>>>>>>>>
74987>>>>>>>                            Else Begin
74988>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
74990>>>>>>>                            End
74990>>>>>>>>
74990>>>>>>>                        End
74990>>>>>>>>
74990>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
74991>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
74992>>>>>>>                    Loop
74993>>>>>>>>
74993>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
74995>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
74996>>>>>>>                    End
74996>>>>>>>>
74996>>>>>>>                    Set paQueryMessages to sMsg
74997>>>>>>>                End
74997>>>>>>>>
74997>>>>>>>                Else Begin
74998>>>>>>>                    If (bShowProgress = True) Begin
75000>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
75001>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
75003>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
75004>>>>>>>                            Decrement iMsgs
75005>>>>>>>                            For i from 0 to iMsgs
75011>>>>>>>>
75011>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
75014>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
75017>>>>>>>                            Loop
75018>>>>>>>>
75018>>>>>>>                        End
75018>>>>>>>>
75018>>>>>>>                    End
75018>>>>>>>>
75018>>>>>>>                End
75018>>>>>>>>
75018>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
75019>>>>>>>            End
75019>>>>>>>>
75019>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
75020>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
75021>>>>>>>            Set ptsQueryExec to tsQuery
75022>>>>>>>            Set ptsFetchResults to tsFetch
75023>>>>>>>            Send SqlClose of hoStmt
75024>>>>>>>        End
75024>>>>>>>>
75024>>>>>>>
75024>>>>>>>        Send SqlDisconnect of hoSQLConnect
75025>>>>>>>    End_Procedure
75026>>>>>>>
75026>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
75026>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
75026>>>>>>>    // Returns False if no error occured.
75026>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
75028>>>>>>>        Boolean bOK bShowProgress
75028>>>>>>>        tSQLScriptArray SQLScriptArray
75028>>>>>>>        tSQLScriptArray SQLScriptArray
75028>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
75028>>>>>>>        TimeSpan tsTotalTime
75028>>>>>>>
75028>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
75029>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
75030>>>>>>>        If (SQLScriptArray.bError = True) Begin
75032>>>>>>>            Function_Return False
75033>>>>>>>        End
75033>>>>>>>>
75033>>>>>>>
75033>>>>>>>        If (num_arguments > 3) Begin
75035>>>>>>>            Move bShowProgr to bShowProgress
75036>>>>>>>        End
75036>>>>>>>>
75036>>>>>>>
75036>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
75037>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
75038>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
75039>>>>>>>
75039>>>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
75041>>>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
75042>>>>>>>>
75042>>>>>>>        End
75042>>>>>>>>
75042>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
75043>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
75044>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
75045>>>>>>>
75045>>>>>>>        Function_Return bOK
75046>>>>>>>    End_Function
75047>>>>>>>
75047>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
75047>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
75047>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
75047>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
75049>>>>>>>        Integer iChannel iArgumentSize iCount
75049>>>>>>>        Number nByteCount
75049>>>>>>>        String sSQLScript
75049>>>>>>>        tSQLScriptArray SqlScriptArray
75049>>>>>>>        tSQLScriptArray SqlScriptArray
75049>>>>>>>        UChar[] uCharData
75050>>>>>>>
75050>>>>>>>        Move False to Err
75051>>>>>>>        Get Seq_New_Channel to iChannel
75052>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75054>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
75055>>>>>>>>
75055>>>>>>>            Move True to SqlScriptArray.bError
75056>>>>>>>            Function_Return SqlScriptArray
75057>>>>>>>        End
75057>>>>>>>>
75057>>>>>>>
75057>>>>>>>        // First decide the size of the script
75057>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
75059>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
75061>>>>>>>        Close_Input channel iChannel
75063>>>>>>>
75063>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
75064>>>>>>>        If (nByteCount  < 1) Begin
75066>>>>>>>            Send Seq_Release_Channel iChannel
75067>>>>>>>            Move True to SqlScriptArray.bError
75068>>>>>>>            Function_Return SqlScriptArray
75069>>>>>>>        End
75069>>>>>>>>
75069>>>>>>>
75069>>>>>>>        // If necessary change the string argument_size
75069>>>>>>>        Get_Argument_Size to iArgumentSize
75070>>>>>>>        If (nByteCount >= iArgumentSize) Begin
75072>>>>>>>            Move (nByteCount + 2048) to nByteCount
75073>>>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
75074>>>>>>>>
75074>>>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
75075>>>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
75076>>>>>>>        End
75076>>>>>>>>
75076>>>>>>>        Else Begin
75077>>>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
75078>>>>>>>        End
75078>>>>>>>>
75078>>>>>>>        // Read the script file from memory line-by-line
75078>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
75080>>>>>>>            Move 0 to iCount
75081>>>>>>>            Repeat
75081>>>>>>>>
75081>>>>>>>                Readln channel iChannel sSQLScript
75083>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
75084>>>>>>>                Increment iCount
75085>>>>>>>            Until (SeqEof = True)
75087>>>>>>>        Close_Input channel iChannel
75089>>>>>>>        Send Seq_Release_Channel iChannel
75090>>>>>>>
75090>>>>>>>        // Finally "sanitize" the script by removing all comments.
75090>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
75091>>>>>>>
75091>>>>>>>        Function_Return SqlScriptArray
75092>>>>>>>    End_Function
75093>>>>>>>
75093>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
75095>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
75095>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
75095>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
75095>>>>>>>        String[] sMsg aSQLQueryMessages
75097>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
75097>>>>>>>        TimeSpan tsQuery
75097>>>>>>>        tSqlErrorArray aSqlErrorArray
75097>>>>>>>        tSqlErrorArray aSqlErrorArray
75097>>>>>>>        tSQLConnection SQLConnection
75097>>>>>>>        tSQLConnection SQLConnection
75097>>>>>>>        Boolean bMertechDriver bShowProgress
75097>>>>>>>
75097>>>>>>>        If (num_arguments > 4) Begin
75099>>>>>>>            Move bShowProgr to bShowProgress
75100>>>>>>>        End
75100>>>>>>>>
75100>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
75101>>>>>>>        If (bMertechDriver = False) Begin
75103>>>>>>>            Get phoSQLManager to hoSql
75104>>>>>>>        End
75104>>>>>>>>
75104>>>>>>>        Else Begin
75105>>>>>>>            Get _MertechSQLManagerHandle to hoSql
75106>>>>>>>        End
75106>>>>>>>>
75106>>>>>>>
75106>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
75107>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
75107>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
75107>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
75107>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
75107>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
75107>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
75107>>>>>>>        Get piChunkMax to iChunkMax
75108>>>>>>>        Move 0 to iChunkCounter
75109>>>>>>>        Move "" to sStmt
75110>>>>>>>
75110>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
75111>>>>>>>        Move (Character(13) + Character(10)) to sCR
75112>>>>>>>
75112>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
75113>>>>>>>
75113>>>>>>>        If (bMertechDriver = True) Begin
75115>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
75116>>>>>>>        End
75116>>>>>>>>
75116>>>>>>>        If (bMertechDriver = False) Begin
75118>>>>>>>            Get phoSQLManager  to hoSQL
75119>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
75121>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
75123>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
75124>>>>>>>                    If (iPos > 0) Begin
75126>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
75127>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
75128>>>>>>>                    End
75128>>>>>>>>
75128>>>>>>>                End
75128>>>>>>>>
75128>>>>>>>            End
75128>>>>>>>>
75128>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
75129>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
75130>>>>>>>        End
75130>>>>>>>>
75130>>>>>>>
75130>>>>>>>        If (hoSQLConnect <> 0) Begin
75132>>>>>>>            Move False to Err
75133>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
75134>>>>>>>            If (hoStmt <> 0) Begin
75136>>>>>>>
75136>>>>>>>                // If the embedded resource should be written as a script file to disk:
75136>>>>>>>                If (bCreateScriptFile = True) Begin
75138>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
75139>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
75140>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
75141>>>>>>>                    Get Seq_New_Channel to iOut
75142>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75144>>>>>>>                        Direct_Output channel iOut sExportFile
75146>>>>>>>                    End
75146>>>>>>>>
75146>>>>>>>                End
75146>>>>>>>>
75146>>>>>>>
75146>>>>>>>                // Record starting date/time stamp
75146>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
75147>>>>>>>                // Turn on error handling if enabled
75147>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
75149>>>>>>>                    Set pbSqlError to False
75150>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
75151>>>>>>>                    Move Error_Object_Id to hoError
75152>>>>>>>                    Move Self to Error_Object_Id
75153>>>>>>>                End
75153>>>>>>>>
75153>>>>>>>
75153>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
75154>>>>>>>                Decrement iRows
75155>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
75157>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
75158>>>>>>>                End
75158>>>>>>>>
75158>>>>>>>
75158>>>>>>>                For iCount from 0 to iRows
75164>>>>>>>>
75164>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
75165>>>>>>>
75165>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
75167>>>>>>>                        If (sSQLVal <> "") Begin
75169>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
75170>>>>>>>                        End
75170>>>>>>>>
75170>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
75171>>>>>>>                    End
75171>>>>>>>>
75171>>>>>>>
75171>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
75171>>>>>>>                    // or if at the very end of the script.
75171>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
75173>>>>>>>
75173>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
75173>>>>>>>                        // instead of all in one go.
75173>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
75174>>>>>>>
75174>>>>>>>                        If (bCreateScriptFile = True) Begin
75176>>>>>>>                            Write channel iOut sStmt
75178>>>>>>>                        End
75178>>>>>>>>
75178>>>>>>>                        Move "" to sStmt
75179>>>>>>>                        Move 0 to iChunkCounter
75180>>>>>>>                    End
75180>>>>>>>>
75180>>>>>>>                    Increment iChunkCounter
75181>>>>>>>                Loop
75182>>>>>>>>
75182>>>>>>>
75182>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
75182>>>>>>>                //       so not used for now.
75182>>>>>>>                If (bMertechDriver = False) Begin
75184>>>>>>>                    Repeat
75184>>>>>>>>
75184>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
75186>>>>>>>                            Move hoError to Error_Object_Id
75187>>>>>>>                        End
75187>>>>>>>>
75187>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
75188>>>>>>>
75188>>>>>>>                        Send _SqlColumnInfo hoStmt
75189>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
75190>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
75191>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
75192>>>>>>>                        Set piRows    to iRows
75193>>>>>>>                        Set piRowType to iRowType
75194>>>>>>>
75194>>>>>>>                        If (iMsgs <> 0) Begin
75196>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
75198>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
75199>>>>>>>                            End
75199>>>>>>>>
75199>>>>>>>                            For i from 1 to iMsgs
75205>>>>>>>>
75205>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
75206>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
75207>>>>>>>                                If (bShowProgress = True) Begin
75209>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
75211>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
75212>>>>>>>                                    End
75212>>>>>>>>
75212>>>>>>>                                    Else Begin
75213>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
75215>>>>>>>                                    End
75215>>>>>>>>
75215>>>>>>>                                End
75215>>>>>>>>
75215>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
75216>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
75217>>>>>>>                            Loop
75218>>>>>>>>
75218>>>>>>>
75218>>>>>>>
75218>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
75220>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
75221>>>>>>>                            End
75221>>>>>>>>
75221>>>>>>>                            Set paQueryMessages to sMsg
75222>>>>>>>                        End
75222>>>>>>>>
75222>>>>>>>
75222>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
75223>>>>>>>                    Until (iNextSet = 0)
75225>>>>>>>                End
75225>>>>>>>>
75225>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
75226>>>>>>>            End
75226>>>>>>>>
75226>>>>>>>
75226>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
75227>>>>>>>            Set ptsQueryExec to tsQuery
75228>>>>>>>            Send SqlClose of hoStmt
75229>>>>>>>
75229>>>>>>>            If (bCreateScriptFile = True) Begin
75231>>>>>>>                Close_Output channel iOut
75233>>>>>>>                Send Seq_Release_Channel iOut
75234>>>>>>>            End
75234>>>>>>>>
75234>>>>>>>        End
75234>>>>>>>>
75234>>>>>>>        Send SqlDisconnect of hoSQLConnect
75235>>>>>>>
75235>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
75236>>>>>>>    End_Function
75237>>>>>>>
75237>>>>>>>    // * Dummy function for the Studio's Code Explorer *
75237>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
75239>>>>>>>        Function_Return False
75240>>>>>>>    End_Function
75241>>>>>>>
75241>>>>>>>    // Does three things with auxilirary files;
75241>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
75241>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
75241>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
75241>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
75243>>>>>>>        String sDataPath sDDSrcPath sDriverID
75243>>>>>>>        Boolean bOK bExists bMertechDriver
75243>>>>>>>        Integer iCount iCh iPos
75243>>>>>>>
75243>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
75243>>>>>>>        If (sTableName contains ".") Begin
75245>>>>>>>            Move (Pos(".", sTableName)) to iPos
75246>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
75247>>>>>>>        End
75247>>>>>>>>
75247>>>>>>>
75247>>>>>>>        Get psDriverID to sDriverID
75248>>>>>>>        Get psDataPathFirstPart to sDataPath
75249>>>>>>>        Get vFolderExists sDataPath to bOK
75250>>>>>>>        If (bOK = False) Begin
75252>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
75253>>>>>>>>
75253>>>>>>>            Function_Return False
75254>>>>>>>        End
75254>>>>>>>>
75254>>>>>>>
75254>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
75255>>>>>>>        // First delete the cache file:
75255>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
75256>>>>>>>
75256>>>>>>>        Get Seq_New_Channel to iCh
75257>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75259>>>>>>>            Function_Return False
75260>>>>>>>        End
75260>>>>>>>>
75260>>>>>>>
75260>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
75261>>>>>>>        If (bExists = False) Begin
75263>>>>>>>            Function_Return False
75264>>>>>>>        End
75264>>>>>>>>
75264>>>>>>>
75264>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
75265>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
75265>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
75266>>>>>>>
75266>>>>>>>        // If in development environment; output new .fd file:
75266>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
75267>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
75268>>>>>>>        If (iCount > 1) Begin
75270>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
75271>>>>>>>        End
75271>>>>>>>>
75271>>>>>>>        Get vFolderExists sDDSrcPath to bExists
75272>>>>>>>        If (bExists = True) Begin
75274>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
75275>>>>>>>            Move False to Err
75276>>>>>>>            Get AutoConnectionIDLogin to bOK
75277>>>>>>>            If (hTable <> 0) Begin
75279>>>>>>>                Open hTable
75281>>>>>>>            End
75281>>>>>>>>
75281>>>>>>>            Else Begin
75282>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
75283>>>>>>>            End
75283>>>>>>>>
75283>>>>>>>
75283>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
75286>>>>>>>            If (bOK = True) Begin
75288>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
75290>>>>>>>            End
75290>>>>>>>>
75290>>>>>>>            If (Err = True) Begin
75292>>>>>>>                Move False to bOK
75293>>>>>>>            End
75293>>>>>>>>
75293>>>>>>>        End
75293>>>>>>>>
75293>>>>>>>
75293>>>>>>>        Function_Return (bOK = True)
75294>>>>>>>    End_Function
75295>>>>>>>
75295>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
75297>>>>>>>        Integer iChIn iChOut // iCount
75297>>>>>>>        Boolean bExists
75297>>>>>>>        String sExistingColumn
75297>>>>>>>
75297>>>>>>>        Move False to bExists
75298>>>>>>>        Get Seq_New_Channel to iChIn
75299>>>>>>>        Get Seq_New_Channel to iChOut
75300>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75302>>>>>>>            Function_Return True
75303>>>>>>>        End
75303>>>>>>>>
75303>>>>>>>
75303>>>>>>>        Move False to Err
75304>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
75304>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
75306>>>>>>>        While (not(SeqEof))
75310>>>>>>>            Readln channel iChIn sExistingColumn
75312>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
75314>>>>>>>                Move True to bExists
75315>>>>>>>            End
75315>>>>>>>>
75315>>>>>>>            If (Trim(sExistingColumn) = "") Begin
75317>>>>>>>                Move True to SeqEof
75318>>>>>>>            End
75318>>>>>>>>
75318>>>>>>>        Loop
75319>>>>>>>>
75319>>>>>>>        Close_Input channel iChIn
75321>>>>>>>        Send Seq_Release_Channel iChIn
75322>>>>>>>
75322>>>>>>>        If (bExists = False) Begin
75324>>>>>>>            Append_Output channel iChOut sFullTAGFileName
75326>>>>>>>            Writeln channel iChOut sColumnName
75329>>>>>>>            Close_Output channel iChOut
75331>>>>>>>            Send Seq_Release_Channel iChOut
75332>>>>>>>        End
75332>>>>>>>>
75332>>>>>>>
75332>>>>>>>        Function_Return (Err = False)
75333>>>>>>>    End_Function
75334>>>>>>>
75334>>>>>>>    // Message for changing .int files to use connection ID's
75334>>>>>>>    //
75334>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
75334>>>>>>>    // OR changes an existing connection id to a new id.
75334>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
75334>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
75334>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
75336>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
75336>>>>>>>        String[] sFilesData
75337>>>>>>>        Boolean bOK bCancel
75337>>>>>>>        Integer iSize iCount
75337>>>>>>>
75337>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
75338>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
75339>>>>>>>        If (iSize = 0) Begin
75341>>>>>>>            If (ghoStatusPanel <> 0) Begin
75343>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
75345>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
75346>>>>>>>                End
75346>>>>>>>>
75346>>>>>>>            End
75346>>>>>>>>
75346>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
75347>>>>>>>            Procedure_Return
75348>>>>>>>        End
75348>>>>>>>>
75348>>>>>>>
75348>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
75349>>>>>>>        Get vFolderFormat sDataPath to sDataPath
75350>>>>>>>        Decrement iSize
75351>>>>>>>        For iCount from 0 to iSize
75357>>>>>>>>
75357>>>>>>>            Move sFilesData[iCount] to sFileName
75358>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
75358>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
75359>>>>>>>            If (ghoStatusPanel <> 0) Begin
75361>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
75363>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
75364>>>>>>>                    If (bCancel = True) Begin
75366>>>>>>>                        Send Deactivate of ghoStatusPanel
75367>>>>>>>                        Procedure_Return
75368>>>>>>>                    End
75368>>>>>>>>
75368>>>>>>>                End
75368>>>>>>>>
75368>>>>>>>            End
75368>>>>>>>>
75368>>>>>>>        Loop
75369>>>>>>>>
75369>>>>>>>
75369>>>>>>>        Get psDriverID to sDriverID
75370>>>>>>>
75370>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
75370>>>>>>>        Move "" to sFileName
75371>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
75373>>>>>>>            Move "MSSQLDrv.int" to sFileName
75374>>>>>>>        End
75374>>>>>>>>
75374>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
75376>>>>>>>            Move "DB2_Drv.int" to sFileName
75377>>>>>>>        End
75377>>>>>>>>
75377>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
75379>>>>>>>            Move "ODBC_Drv.int" to sFileName
75380>>>>>>>        End
75380>>>>>>>>
75380>>>>>>>        If (sFileName <> "") Begin
75382>>>>>>>            Move "" to sDriverFile
75383>>>>>>>            Get_File_Path sFileName to sDriverFile
75384>>>>>>>            If (sDriverFile <> "") Begin
75386>>>>>>>                Get psConnectionString to sConnectionString
75387>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
75388>>>>>>>            End
75388>>>>>>>>
75388>>>>>>>        End
75388>>>>>>>>
75388>>>>>>>    End_Procedure
75389>>>>>>>
75389>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
75389>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
75391>>>>>>>        String[] sDatabaseArray
75392>>>>>>>        String sVal sServer sDriverID
75392>>>>>>>        Integer iCount iSize iPos
75392>>>>>>>        Boolean bExists
75392>>>>>>>        tSQLConnection SQLConnection
75392>>>>>>>        tSQLConnection SQLConnection
75392>>>>>>>
75392>>>>>>>        Move False to bExists
75393>>>>>>>        Get psDriverID to sDriverID
75394>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
75394>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
75396>>>>>>>            Function_Return bExists
75397>>>>>>>        End
75397>>>>>>>>
75397>>>>>>>
75397>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
75398>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
75400>>>>>>>            Function_Return False
75401>>>>>>>        End
75401>>>>>>>>
75401>>>>>>>
75401>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
75402>>>>>>>        Move SQLConnection.sServer to sServer
75403>>>>>>>
75403>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
75403>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
75405>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
75406>>>>>>>        End
75406>>>>>>>>
75406>>>>>>>        Else If (sServer contains "/") Begin
75409>>>>>>>            Move (Pos("/", sServer)) to iPos
75410>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
75411>>>>>>>        End
75411>>>>>>>>
75411>>>>>>>
75411>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
75412>>>>>>>        Decrement iSize
75413>>>>>>>        For iCount from 0 to iSize
75419>>>>>>>>
75419>>>>>>>            Move sDatabaseArray[iCount] to sVal
75420>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
75422>>>>>>>                Move True to bExists
75423>>>>>>>                If (bExists = True) Begin
75425>>>>>>>                    Move iSize to iCount // We're done.
75426>>>>>>>                End
75426>>>>>>>>
75426>>>>>>>            End
75426>>>>>>>>
75426>>>>>>>        Loop
75427>>>>>>>>
75427>>>>>>>
75427>>>>>>>        Function_Return bExists
75428>>>>>>>    End_Function
75429>>>>>>>
75429>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
75429>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
75431>>>>>>>        String sDatabase sSchema sTableName sVal
75431>>>>>>>        Boolean bExists
75431>>>>>>>        String[] sTablesArray
75432>>>>>>>        Integer iSize iCount
75432>>>>>>>
75432>>>>>>>        Move False to bExists
75433>>>>>>>        Get UtilTableHandleToString hTable to sTableName
75434>>>>>>>        Get psDatabase to sDatabase
75435>>>>>>>        Get psSchema   to sSchema
75436>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
75437>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
75438>>>>>>>        Decrement iSize
75439>>>>>>>        For iCount from 0 to iSize
75445>>>>>>>>
75445>>>>>>>            Move sTablesArray[iCount] to sVal
75446>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
75448>>>>>>>                Move True to bExists
75449>>>>>>>                Move iSize to iCount // We're done!
75450>>>>>>>            End
75450>>>>>>>>
75450>>>>>>>        Loop
75451>>>>>>>>
75451>>>>>>>
75451>>>>>>>        Function_Return bExists
75452>>>>>>>    End_Function
75453>>>>>>>
75453>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
75453>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
75455>>>>>>>        String sDatabase sSchema sVal
75455>>>>>>>        Boolean bExists
75455>>>>>>>        String[] sTablesArray
75456>>>>>>>        Integer iSize iCount
75456>>>>>>>
75456>>>>>>>        Move False to bExists
75457>>>>>>>        Get psDatabase to sDatabase
75458>>>>>>>        Get psSchema   to sSchema
75459>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
75460>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
75461>>>>>>>        Decrement iSize
75462>>>>>>>        For iCount from 0 to iSize
75468>>>>>>>>
75468>>>>>>>            Move sTablesArray[iCount] to sVal
75469>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
75471>>>>>>>                Move True to bExists
75472>>>>>>>                Move iSize to iCount // We're done!
75473>>>>>>>            End
75473>>>>>>>>
75473>>>>>>>        Loop
75474>>>>>>>>
75474>>>>>>>
75474>>>>>>>        Function_Return bExists
75475>>>>>>>    End_Function
75476>>>>>>>
75476>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
75478>>>>>>>        String sVal sTableSpelledCorrectly
75478>>>>>>>        Boolean bExists
75478>>>>>>>        String[] sTablesArray
75479>>>>>>>        Integer iSize iCount
75479>>>>>>>
75479>>>>>>>        Move False to bExists
75480>>>>>>>        Move sTableName to sTableSpelledCorrectly
75481>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
75482>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
75483>>>>>>>        Decrement iSize
75484>>>>>>>        For iCount from 0 to iSize
75490>>>>>>>>
75490>>>>>>>            Move sTablesArray[iCount] to sVal
75491>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
75493>>>>>>>                Move sVal to sTableSpelledCorrectly
75494>>>>>>>                Move iSize to iCount // We're done!
75495>>>>>>>            End
75495>>>>>>>>
75495>>>>>>>        Loop
75496>>>>>>>>
75496>>>>>>>
75496>>>>>>>        Function_Return sTableSpelledCorrectly
75497>>>>>>>    End_Function
75498>>>>>>>
75498>>>>>>>    // ToDo: This index name function needs to be finished...
75498>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
75500>>>>>>>        String sSchema sTableName sDriverID
75500>>>>>>>        Boolean bExists
75500>>>>>>>
75500>>>>>>>        Get psDriverID to sDriverID
75501>>>>>>>        Get psSchema to sSchema
75502>>>>>>>        Get UtilTableHandleToString hTable to sTableName
75503>>>>>>>
75503>>>>>>>        Function_Return bExists
75504>>>>>>>    End_Function
75505>>>>>>>
75505>>>>>>>    // Checks if a column/field name exists in a SQL table definition
75505>>>>>>>    // Returns True if it does
75505>>>>>>>    // Sample:
75505>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
75505>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
75507>>>>>>>        Integer iNumColumns iColumn
75507>>>>>>>        String sColumn sDriverID
75507>>>>>>>        String[] sColumnsArray
75508>>>>>>>        Boolean bExists bOK
75508>>>>>>>
75508>>>>>>>        Move False to bExists
75509>>>>>>>        Get AutoConnectionIDLogin to bOK
75510>>>>>>>        Get psDriverID to sDriverID
75511>>>>>>>
75511>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
75512>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
75513>>>>>>>        Decrement iNumColumns
75514>>>>>>>        For iColumn from 0 to iNumColumns
75520>>>>>>>>
75520>>>>>>>            Move sColumnsArray[iColumn] to sColumn
75521>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
75523>>>>>>>                Move True to bExists
75524>>>>>>>                Move iNumColumns to iColumn // We're out of here
75525>>>>>>>            End
75525>>>>>>>>
75525>>>>>>>        Loop
75526>>>>>>>>
75526>>>>>>>
75526>>>>>>>        Function_Return bExists
75527>>>>>>>    End_Function
75528>>>>>>>
75528>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
75530>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
75530>>>>>>>        Boolean bOpened bOK
75530>>>>>>>        String sColumnName sNativeTypeName
75530>>>>>>>
75530>>>>>>>        Get AutoConnectionIDLogin to bOK
75531>>>>>>>        Get OpenTableExclusive hTable to bOK
75532>>>>>>>        If (bOK = False) Begin
75534>>>>>>>            Function_Return False
75535>>>>>>>        End
75535>>>>>>>>
75535>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
75538>>>>>>>        If (bOpened = False) Begin
75540>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
75541>>>>>>>>
75541>>>>>>>            Function_Return False
75542>>>>>>>        End
75542>>>>>>>>
75542>>>>>>>
75542>>>>>>>        Move False to Err
75543>>>>>>>
75543>>>>>>>        Structure_Start hTable
75544>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
75547>>>>>>>
75547>>>>>>>            For iColumn from 1 to iNumColumns
75553>>>>>>>>
75553>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
75556>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
75559>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
75562>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
75565>>>>>>>
75565>>>>>>>                Case Begin
75565>>>>>>>                    Case (iDFType = DF_DATE)
75567>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
75569>>>>>>>                            // Convert datetime to date
75569>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
75572>>>>>>>                        End
75572>>>>>>>>
75572>>>>>>>                        Case Break
75573>>>>>>>                    Case (iDFType = DF_DATETIME)
75576>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
75578>>>>>>>                            // Convert datetime to datetime2
75578>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
75581>>>>>>>                        End
75581>>>>>>>>
75581>>>>>>>                        Case Break
75582>>>>>>>                    Case (iDFType = DF_ASCII)
75585>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
75587>>>>>>>                            // Convert char to varchar
75587>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
75590>>>>>>>                        End
75590>>>>>>>>
75590>>>>>>>                        Case Break
75591>>>>>>>                    Case (iDFType = DF_TEXT)
75594>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
75596>>>>>>>                            // Convert text to varchar(max)
75596>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
75599>>>>>>>                        End
75599>>>>>>>>
75599>>>>>>>                        Case Break
75600>>>>>>>                    Case (iDFType = DF_BINARY)
75603>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
75605>>>>>>>                            // Convert image to varbinary(max)
75605>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
75608>>>>>>>                        End
75608>>>>>>>>
75608>>>>>>>                        Case Break
75609>>>>>>>                Case End
75609>>>>>>>            Loop
75610>>>>>>>>
75610>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
75611>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
75613>>>>>>>
75613>>>>>>>        Set Action_Text of ghoStatusPanel to ""
75614>>>>>>>        Function_Return (Err = False)
75615>>>>>>>    End_Function
75616>>>>>>>
75616>>>>>>>
75616>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
75616>>>>>>>    // the DbUpdateVersion database revision in.
75616>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
75616>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
75616>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
75618>>>>>>>        Boolean bOK bOpened
75618>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
75618>>>>>>>
75618>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
75621>>>>>>>        Get _TableNameOnly sTableName to sTableName
75622>>>>>>>        If (sTableName = "") Begin
75624>>>>>>>            Function_Return False
75625>>>>>>>        End
75625>>>>>>>>
75625>>>>>>>
75625>>>>>>>        // This just creates the table and a "dummy" column.
75625>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
75626>>>>>>>        If (bOK = False) Begin
75628>>>>>>>            Function_Return False
75629>>>>>>>        End
75629>>>>>>>>
75629>>>>>>>
75629>>>>>>>        Close hTable
75630>>>>>>>        Move False to Err
75631>>>>>>>
75631>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
75632>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
75633>>>>>>>        Move "Decimal" to sDataType
75634>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
75635>>>>>>>
75635>>>>>>>        // Adds the "sColumnName" passed to the function
75635>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
75636>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
75637>>>>>>>
75637>>>>>>>        // Now we can delete the dummy column:
75637>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
75638>>>>>>>
75638>>>>>>>        // Finally, we attach to the newly created table.
75638>>>>>>>        If (Err = False) Begin
75640>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
75641>>>>>>>        End
75641>>>>>>>>
75641>>>>>>>        Open hTable
75643>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
75646>>>>>>>
75646>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
75647>>>>>>>    End_Function
75648>>>>>>>
75648>>>>>>>    // The table must already exist in the filelist for this function to work.
75648>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
75648>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
75650>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
75650>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
75650>>>>>>>        String[] sIndexArray
75651>>>>>>>        Integer iCount iCh iSize
75651>>>>>>>
75651>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
75652>>>>>>>        Get psConnectionString to sConnectionString
75653>>>>>>>
75653>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
75654>>>>>>>        If (bANSI = False) Begin
75656>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
75657>>>>>>>        End
75657>>>>>>>>
75657>>>>>>>
75657>>>>>>>        Get psDataPathFirstPart to sDataPath
75658>>>>>>>        Get vFolderExists sDataPath to bOK
75659>>>>>>>        If (bOK = False) Begin
75661>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
75662>>>>>>>>
75662>>>>>>>            Function_Return False
75663>>>>>>>        End
75663>>>>>>>>
75663>>>>>>>        Get vFolderFormat sDataPath to sDataPath
75664>>>>>>>
75664>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
75667>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
75670>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
75671>>>>>>>        Move sLogicalName  to sPhysicalFileName
75672>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
75673>>>>>>>
75673>>>>>>>        Get IsMertechDriver sDriverID to bMertech
75674>>>>>>>        If (bMertech = True) Begin
75676>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
75676>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
75676>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
75676>>>>>>>            Function_Return (bOK = True)
75677>>>>>>>        End
75677>>>>>>>>
75677>>>>>>>
75677>>>>>>>        Get psSchema hTable to sSchemaName
75678>>>>>>>        If (sSchemaName = "") Begin
75680>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
75681>>>>>>>        End
75681>>>>>>>>
75681>>>>>>>
75681>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
75681>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
75682>>>>>>>        If (bExists = True) Begin
75684>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
75685>>>>>>>        End
75685>>>>>>>>
75685>>>>>>>
75685>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
75686>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
75687>>>>>>>
75687>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
75688>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
75693>>>>>>>            If (bUseConnectionID = True) Begin
75695>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
75702>>>>>>>            End
75702>>>>>>>>
75702>>>>>>>            Else Begin
75703>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
75710>>>>>>>            End
75710>>>>>>>>
75710>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
75715>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
75720>>>>>>>            // There seems to be a new order how these are set from DF19.
75720>>>>>>>            If (bSysFile = True) Begin
75722>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
75727>>>>>>>            End
75727>>>>>>>>
75727>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
75732>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
75737>>>>>>>            If (bSysFile = True) Begin
75739>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
75744>>>>>>>            End
75744>>>>>>>>
75744>>>>>>>
75744>>>>>>>            If (bSysFile = False) Begin
75746>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
75747>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
75748>>>>>>>                If (iSize > 0) Begin
75750>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
75753>>>>>>>                    Writeln channel iCh // Just an empty line
75755>>>>>>>                End
75755>>>>>>>>
75755>>>>>>>                Decrement iSize
75756>>>>>>>                For iCount from 0 to iSize
75762>>>>>>>>
75762>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
75765>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
75768>>>>>>>                    Writeln channel iCh
75770>>>>>>>                Loop
75771>>>>>>>>
75771>>>>>>>            End
75771>>>>>>>>
75771>>>>>>>        Send Seq_Close_Channel iCh
75772>>>>>>>
75772>>>>>>>        // Wait a sec for Windows to finish writing the file:
75772>>>>>>>        Sleep 1
75773>>>>>>>
75773>>>>>>>        Function_Return (bOK = True)
75774>>>>>>>    End_Function
75775>>>>>>>
75775>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
75775>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
75775>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
75775>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
75775>>>>>>>    // column types.
75775>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
75777>>>>>>>        Handle hDatabase
75777>>>>>>>        Integer iDriver iServers iCount
75777>>>>>>>        String sValue
75777>>>>>>>
75777>>>>>>>        If (sServer = "") Begin
75779>>>>>>>            Function_Return 0
75780>>>>>>>        End
75780>>>>>>>>
75780>>>>>>>
75780>>>>>>>        Get DriverIndex sDriverID to iDriver
75781>>>>>>>        If (iDriver = 0) Begin
75783>>>>>>>            Function_Return 0
75784>>>>>>>        End
75784>>>>>>>>
75784>>>>>>>
75784>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
75787>>>>>>>        For iCount from 1 to iServers
75793>>>>>>>>
75793>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
75796>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
75798>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
75801>>>>>>>            End
75801>>>>>>>>
75801>>>>>>>        Loop
75802>>>>>>>>
75802>>>>>>>
75802>>>>>>>        Function_Return hDatabase
75803>>>>>>>    End_Function
75804>>>>>>>
75804>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
75804>>>>>>>//        String sRootName
75804>>>>>>>//        Boolean bOK
75804>>>>>>>//
75804>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
75804>>>>>>>//        Move (sRootName contains sDriverID) to bOK
75804>>>>>>>//
75804>>>>>>>//        Function_Return bOK
75804>>>>>>>//    End_Function
75804>>>>>>>
75804>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
75804>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
75804>>>>>>>//        Integer iDbType
75804>>>>>>>//        Boolean bOK
75804>>>>>>>//
75804>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
75804>>>>>>>//        If (bOK = True) Begin
75804>>>>>>>//            Function_Return False
75804>>>>>>>//        End
75804>>>>>>>//
75804>>>>>>>//        Get psDriverID to sDriverID
75804>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
75804>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
75804>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
75804>>>>>>>//
75804>>>>>>>//        Get psDriverID to sDriverID
75804>>>>>>>//        Get piDbType   to iDbType
75804>>>>>>>//        Get psSchema   to sSchema
75804>>>>>>>//        If (sSchema = "") Begin
75804>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
75804>>>>>>>//        End
75804>>>>>>>//
75804>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
75804>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
75804>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
75804>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
75804>>>>>>>//            End
75804>>>>>>>//            Else Begin
75804>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
75804>>>>>>>//            End
75804>>>>>>>//        End
75804>>>>>>>//
75804>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
75804>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
75804>>>>>>>//
75804>>>>>>>//        Function_Return True
75804>>>>>>>//    End_Function
75804>>>>>>>
75804>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
75804>>>>>>>    // from the passed filelist.
75804>>>>>>>    // Returns the number of tables affected.
75804>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
75806>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
75806>>>>>>>        Integer iRetval
75806>>>>>>>        Handle hTable
75806>>>>>>>
75806>>>>>>>        // We first save the current filelist as the passed filelist name
75806>>>>>>>        // may come from another workspace, to restore it when we're ready.
75806>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
75809>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
75812>>>>>>>        Move 0 to hTable
75813>>>>>>>        Move 0 to iRetval
75814>>>>>>>
75814>>>>>>>        Repeat
75814>>>>>>>>
75814>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
75817>>>>>>>            If (hTable <> 0) Begin
75819>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
75822>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
75825>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
75828>>>>>>>                Move (Uppercase(sRootName)) to sVal
75829>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
75831>>>>>>>                    // Prefixes:
75831>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
75832>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
75833>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
75834>>>>>>>                    // Suffixes:
75834>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
75835>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
75836>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
75837>>>>>>>
75837>>>>>>>                    // Change Filelist entry:
75837>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
75840>>>>>>>
75840>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
75841>>>>>>>                    If (sVal contains "dbo.") Begin
75843>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
75844>>>>>>>
75844>>>>>>>                        // Change Filelist entry:
75844>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
75847>>>>>>>                    End
75847>>>>>>>>
75847>>>>>>>                    Increment iRetval
75848>>>>>>>                End
75848>>>>>>>>
75848>>>>>>>            End
75848>>>>>>>>
75848>>>>>>>        Until (hTable = 0)
75850>>>>>>>
75850>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
75853>>>>>>>
75853>>>>>>>        Function_Return iRetval
75854>>>>>>>    End_Function
75855>>>>>>>
75855>>>>>>>    // To open all Sql based tables in Filelist.cfg
75855>>>>>>>    Procedure SqlUtilOpenAllTables
75857>>>>>>>        Handle hTable
75857>>>>>>>        String sRoot sDriverID
75857>>>>>>>        Boolean bOK
75857>>>>>>>
75857>>>>>>>        Move 0 to hTable
75858>>>>>>>        Move "" to sDriverID
75859>>>>>>>        Get AutoConnectionIDLogin to bOK
75860>>>>>>>
75860>>>>>>>        Repeat
75860>>>>>>>>
75860>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
75863>>>>>>>            If (hTable > 0) Begin
75865>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
75868>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
75870>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
75873>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
75875>>>>>>>                        Open hTable
75877>>>>>>>                    End
75877>>>>>>>>
75877>>>>>>>                End
75877>>>>>>>>
75877>>>>>>>            End
75877>>>>>>>>
75877>>>>>>>
75877>>>>>>>        Until (hTable = 0)
75879>>>>>>>    End_Procedure
75880>>>>>>>
75880>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
75880>>>>>>>//        String sRetval sDriverID
75880>>>>>>>//        String sTableName
75880>>>>>>>//        Integer iDbType iIndex
75880>>>>>>>//        Boolean bOK
75880>>>>>>>//
75880>>>>>>>//        Get psDriverID to sDriverID
75880>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
75880>>>>>>>//        If (hTable = 0 or bOK = False) Begin
75880>>>>>>>//            Function_Return ""
75880>>>>>>>//        End
75880>>>>>>>//
75880>>>>>>>//        Move False to Err
75880>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
75880>>>>>>>//        Get piDbType to iDbType
75880>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
75880>>>>>>>//        If (iIndex = -1) Begin
75880>>>>>>>//            Function_Return ""
75880>>>>>>>//        End
75880>>>>>>>//
75880>>>>>>>//        Function_Return sRetval
75880>>>>>>>//    End_Function
75880>>>>>>>
75880>>>>>>>    // Checks if the passed Table;
75880>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
75880>>>>>>>    // 2) It has an .int file.
75880>>>>>>>    // If both is True it should already be connected to SQL
75880>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
75882>>>>>>>        Boolean bExists bRootName
75882>>>>>>>        String sRootName sDataPath
75882>>>>>>>
75882>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
75885>>>>>>>        Move (sRootName contains sDriverID) to bRootName
75886>>>>>>>
75886>>>>>>>        Get psDataPathFirstPart to sDataPath
75887>>>>>>>        Get vFolderExists sDataPath to bExists
75888>>>>>>>        If (bExists = False) Begin
75890>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
75890>>>>>>>            Function_Return False
75891>>>>>>>        End
75891>>>>>>>>
75891>>>>>>>
75891>>>>>>>        Get vFolderFormat sDataPath to sDataPath
75892>>>>>>>        Get _TableNameOnly sRootName to sRootName
75893>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
75894>>>>>>>
75894>>>>>>>        Function_Return (bRootName = True and bExists = True)
75895>>>>>>>    End_Function
75896>>>>>>>
75896>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
75898>>>>>>>        Boolean bViewTableType bOpen bOK
75898>>>>>>>        Integer iTableCount iNumTables
75898>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
75898>>>>>>>        Handle hoCliHandler
75898>>>>>>>        tSQLConnection SQLConnection
75898>>>>>>>        tSQLConnection SQLConnection
75898>>>>>>>
75898>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
75901>>>>>>>        If (bOpen = False) Begin
75903>>>>>>>            Get AutoConnectionIDLogin to bOK
75904>>>>>>>            Open hTable
75906>>>>>>>        End
75906>>>>>>>>
75906>>>>>>>
75906>>>>>>>        Get pSQLConnection to SQLConnection
75907>>>>>>>        Get phoCLIHandler to hoCliHandler
75908>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
75909>>>>>>>
75909>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
75912>>>>>>>        Get _TableNameOnly sTableName to sTableName
75913>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
75916>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
75917>>>>>>>
75917>>>>>>>        For iTableCount from 1 to iNumTables
75923>>>>>>>>
75923>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
75924>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
75925>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
75927>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
75928>>>>>>>                Move iNumTables to iTableCount // We're done.
75929>>>>>>>            End
75929>>>>>>>>
75929>>>>>>>        Loop
75930>>>>>>>>
75930>>>>>>>
75930>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
75931>>>>>>>        If (bOpen = False) Begin
75933>>>>>>>            Close hTable
75934>>>>>>>        End
75934>>>>>>>>
75934>>>>>>>
75934>>>>>>>        Function_Return bViewTableType
75935>>>>>>>    End_Function
75936>>>>>>>
75936>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
75936>>>>>>>    //
75936>>>>>>>    // SQL utility function that returns a database type (string) constant
75936>>>>>>>    // corresponding to the passed iDbType.
75936>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
75938>>>>>>>        String sRetval
75938>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
75939>>>>>>>        Function_Return sRetval
75940>>>>>>>    End_Function
75941>>>>>>>
75941>>>>>>>    // SQL utility function that returns a database type constant (integer)
75941>>>>>>>    // corresponding to the passed sDbType string constant.
75941>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
75943>>>>>>>        Integer iRetval
75943>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
75944>>>>>>>        Function_Return iRetval
75945>>>>>>>    End_Function
75946>>>>>>>
75946>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
75946>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
75946>>>>>>>    // the SQL Connection program's grid.
75946>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
75948>>>>>>>        String sRetval
75948>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
75949>>>>>>>        Function_Return sRetval
75950>>>>>>>    End_Function
75951>>>>>>>
75951>>>>>>>    // Pass a driver name as a string and the function will return
75951>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
75951>>>>>>>    // quite work and always returns "MS SQL Server"
75951>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
75953>>>>>>>        Integer iRetval
75953>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
75954>>>>>>>        Function_Return iRetval
75955>>>>>>>    End_Function
75956>>>>>>>
75956>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
75956>>>>>>>    // that "fits" in the max allowed length for table names.
75956>>>>>>>    // Max number of characters allowed for table names;
75956>>>>>>>    // IBM DB2      = 128
75956>>>>>>>    // MS-SQL       = 128
75956>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
75956>>>>>>>    // MySQL        = 64
75956>>>>>>>    // PostgreSQL   = 64
75956>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
75958>>>>>>>        String sGUIDName
75958>>>>>>>        Integer iDbType iLength
75958>>>>>>>
75958>>>>>>>        Get piDbType to iDbType
75959>>>>>>>        Move (RandomHexUUID()) to sGUIDName
75960>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
75961>>>>>>>        Move (Length(sGUIDName)) to iLength
75962>>>>>>>
75962>>>>>>>        Case Begin
75962>>>>>>>            Case (iDbType = EN_DbTypeDB2)
75964>>>>>>>            If (iLength > 128) Begin
75966>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
75967>>>>>>>            End
75967>>>>>>>>
75967>>>>>>>            Case Break
75968>>>>>>>
75968>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
75971>>>>>>>            If (iLength > 128) Begin
75973>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
75974>>>>>>>            End
75974>>>>>>>>
75974>>>>>>>            Case Break
75975>>>>>>>
75975>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
75978>>>>>>>            If (iLength > 128) Begin
75980>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
75981>>>>>>>            End
75981>>>>>>>>
75981>>>>>>>            Case Break
75982>>>>>>>
75982>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
75985>>>>>>>            If (iLength > 64) Begin
75987>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
75988>>>>>>>            End
75988>>>>>>>>
75988>>>>>>>            Case Break
75989>>>>>>>
75989>>>>>>>            Case (iDbType = EN_DbTypePostgre)
75992>>>>>>>            If (iLength > 64) Begin
75994>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
75995>>>>>>>            End
75995>>>>>>>>
75995>>>>>>>        Case End
75995>>>>>>>
75995>>>>>>>        Function_Return sGUIDName
75996>>>>>>>    End_Function
75997>>>>>>>
75997>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
75997>>>>>>>    // Pass the memory resource file reference and the filename to be created,
75997>>>>>>>    // including full path.
75997>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
75999>>>>>>>        String sText
75999>>>>>>>        Integer iCh iSize iArgSize
75999>>>>>>>
75999>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
76000>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
76001>>>>>>>        Get_Channel_Size iCh to iSize
76002>>>>>>>        Get_Argument_Size to iArgSize
76003>>>>>>>        If (iSize > iArgSize) Begin
76005>>>>>>>            Set_Argument_Size iSize
76006>>>>>>>>
76006>>>>>>>        End
76006>>>>>>>>
76006>>>>>>>        Read_Block channel iCh sText iSize
76008>>>>>>>        Send Seq_Close_Channel iCh
76009>>>>>>>
76009>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
76010>>>>>>>            Write channel iCh sText
76012>>>>>>>        Send Seq_Close_Channel iCh
76013>>>>>>>
76013>>>>>>>        If (iSize <> iArgSize) Begin
76015>>>>>>>            Set_Argument_Size iArgSize
76016>>>>>>>>
76016>>>>>>>        End
76016>>>>>>>>
76016>>>>>>>        // Wait for file to be written to disk.
76016>>>>>>>        Sleep 2
76017>>>>>>>    End_Procedure
76018>>>>>>>
76018>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
76020>>>>>>>        String sNotNull sRetval sDefaultValue
76020>>>>>>>        Boolean bOK
76020>>>>>>>
76020>>>>>>>        Get IsSQLDriver sDriverID to bOK
76021>>>>>>>        If (bOK = False) Begin
76023>>>>>>>            Function_Return ""
76024>>>>>>>        End
76024>>>>>>>>
76024>>>>>>>
76024>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
76025>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
76026>>>>>>>
76026>>>>>>>        Case Begin
76026>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
76028>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
76029>>>>>>>                Case Break
76030>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
76033>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
76034>>>>>>>                Case Break
76035>>>>>>>            Case (iDbType = EN_dbTypePostgre)
76038>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
76039>>>>>>>                Case Break
76040>>>>>>>            Case (iDbType = EN_dbTypeDB2)
76043>>>>>>>                Move (String(sNotNull))                                     to sRetval
76044>>>>>>>                Case Break
76045>>>>>>>
76045>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76045>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
76045>>>>>>>            Case (iDbType = EN_dbTypeOracle)
76048>>>>>>>                Move  ""                                                    to sRetval
76049>>>>>>>                Case Break
76050>>>>>>>
76050>>>>>>>            Case Else
76050>>>>>>>                Move  ""                                                    to sRetval
76051>>>>>>>        Case End
76051>>>>>>>
76051>>>>>>>        Function_Return sRetval
76052>>>>>>>    End_Function
76053>>>>>>>
76053>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
76055>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
76055>>>>>>>        Boolean bOpened bOK bMertech
76055>>>>>>>
76055>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
76055>>>>>>>        // which makes the program unable to run because they can't be opened.
76055>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
76055>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
76055>>>>>>>        // proper .int files for the two tables.
76055>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
76057>>>>>>>            Function_Return True
76058>>>>>>>        End
76058>>>>>>>>
76058>>>>>>>
76058>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
76061>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
76062>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
76063>>>>>>>        Move CS_ANSI_Txt to sNewFormat
76064>>>>>>>        Get AutoConnectionIDLogin to bOK
76065>>>>>>>
76065>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
76065>>>>>>>        Sleep 1
76066>>>>>>>
76066>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
76069>>>>>>>        If (bOpened = False) Begin
76071>>>>>>>            Open hTable
76073>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
76076>>>>>>>        End
76076>>>>>>>>
76076>>>>>>>        If (bOpened = False) Begin
76078>>>>>>>            Function_Return False
76079>>>>>>>        End
76079>>>>>>>>
76079>>>>>>>
76079>>>>>>>        Get psDriverID to sDriverID
76080>>>>>>>        Get IsMertechDriver sDriverID to bMertech
76081>>>>>>>        If (bMertech = True) Begin
76083>>>>>>>            Get psDataPathFirstPart to sDataPath
76084>>>>>>>            Get vFolderExists sDataPath to bOK
76085>>>>>>>            If (bOK = False) Begin
76087>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
76088>>>>>>>>
76088>>>>>>>                Function_Return False
76089>>>>>>>            End
76089>>>>>>>>
76089>>>>>>>            Get vFolderFormat sDataPath to sDataPath
76090>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
76093>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
76094>>>>>>>            Move sDatabaseName to sPhysicalFileName
76095>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
76096>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
76097>>>>>>>            Function_Return (bOK = True)
76098>>>>>>>        End
76098>>>>>>>>
76098>>>>>>>
76098>>>>>>>        Move False to Err
76099>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
76102>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
76103>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
76103>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
76103>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
76104>>>>>>>
76104>>>>>>>        Move False to Err
76105>>>>>>>
76105>>>>>>>        If (hTable > 0) Begin
76107>>>>>>>            Structure_Start hTable
76108>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
76111>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
76114>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
76116>>>>>>>        End
76116>>>>>>>>
76116>>>>>>>        Else Begin
76117>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
76120>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
76123>>>>>>>        End
76123>>>>>>>>
76123>>>>>>>        Function_Return (Err = False)
76124>>>>>>>    End_Function
76125>>>>>>>
76125>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
76127>>>>>>>        String[] sReturnArray
76128>>>>>>>        String sValue // sUserID sPassword
76128>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
76128>>>>>>>        Integer iFetchResult iRetval
76128>>>>>>>        tSQLConnection SQLConnection
76128>>>>>>>        tSQLConnection SQLConnection
76128>>>>>>>
76128>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
76129>>>>>>>        If (hoSQLHandler <> 0) Begin
76131>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
76132>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
76133>>>>>>>            If (hoSQLConnect <> 0) Begin
76135>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
76136>>>>>>>                If (hStmt <> 0) Begin
76138>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
76139>>>>>>>                    If (sArgument <> "") Begin
76141>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
76142>>>>>>>                    End
76142>>>>>>>>
76142>>>>>>>                    Send SQLCall of hStmt
76143>>>>>>>
76143>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
76144>>>>>>>                    If (iRetval = 0) Begin
76146>>>>>>>                        Repeat
76146>>>>>>>>
76146>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
76147>>>>>>>                            If (iFetchResult <> 0) Begin
76149>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
76150>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
76151>>>>>>>                            End
76151>>>>>>>>
76151>>>>>>>                        Until (iFetchResult = 0)
76153>>>>>>>                        Send SQLClose of hStmt
76154>>>>>>>                    End
76154>>>>>>>>
76154>>>>>>>                End
76154>>>>>>>>
76154>>>>>>>                Send SQLDisconnect of hoSQLConnect
76155>>>>>>>            End
76155>>>>>>>>
76155>>>>>>>        End
76155>>>>>>>>
76155>>>>>>>
76155>>>>>>>        Function_Return sReturnArray
76156>>>>>>>    End_Function
76157>>>>>>>
76157>>>>>>>    // * Dummy function for the Studio's Code Explorer *
76157>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
76159>>>>>>>        Function_Return False
76160>>>>>>>    End_Function
76161>>>>>>>
76161>>>>>>>    // Enumerate SQL Servers.
76161>>>>>>>    // Pass a driver id. Returns a string array.
76161>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
76161>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
76161>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
76163>>>>>>>        String[] sReturnArray
76164>>>>>>>        Handle hoSQLHandler
76164>>>>>>>        String sServer
76164>>>>>>>        Integer iCount iNumItems iDataSourceType
76164>>>>>>>
76164>>>>>>>        If (num_arguments > 1) Begin
76166>>>>>>>            Move iDatSrcType to iDataSourceType
76167>>>>>>>        End
76167>>>>>>>>
76167>>>>>>>
76167>>>>>>>        Case Begin
76167>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76169>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
76170>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
76171>>>>>>>                For iCount from 0 to (iNumItems - 1)
76177>>>>>>>>
76177>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
76178>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
76179>>>>>>>                Loop
76180>>>>>>>>
76180>>>>>>>                Case Break
76181>>>>>>>
76181>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76184>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
76185>>>>>>>                Send SeedDataSources of hoSQLHandler
76186>>>>>>>                Move 0 to iCount
76187>>>>>>>                Repeat
76187>>>>>>>>
76187>>>>>>>                    Get DataSources of hoSQLHandler to sServer
76188>>>>>>>                    If (sServer <> "") Begin
76190>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
76191>>>>>>>                        Move sServer to sReturnArray[iCount]
76192>>>>>>>                    End
76192>>>>>>>>
76192>>>>>>>                    Increment iCount
76193>>>>>>>                Until (sServer = "")
76195>>>>>>>                Case Break
76196>>>>>>>
76196>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76199>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
76200>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
76201>>>>>>>                Move 0 to iCount
76202>>>>>>>                Repeat
76202>>>>>>>>
76202>>>>>>>                    Get DataSources of hoSQLHandler to sServer
76203>>>>>>>                    If (sServer <> "") Begin
76205>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
76206>>>>>>>                        Move sServer to sReturnArray[iCount]
76207>>>>>>>                    End
76207>>>>>>>>
76207>>>>>>>                    Increment iCount
76208>>>>>>>                Until (sServer = "")
76210>>>>>>>                Case Break
76211>>>>>>>
76211>>>>>>>            Case (sDriverID = SQLFLEX)
76214>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
76215>>>>>>>                Case Break
76216>>>>>>>
76216>>>>>>>            Case (sDriverID = ORAFLEX)
76219>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
76220>>>>>>>                Case Break
76221>>>>>>>
76221>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
76221>>>>>>>            Case (sDriverID = MDSPgSQL)
76224>>>>>>>                Move "localhost" to sReturnArray[0]
76225>>>>>>>                Case Break
76226>>>>>>>
76226>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
76226>>>>>>>            Case (sDriverID = MDSMySQL)
76229>>>>>>>                Move "localhost" to sReturnArray[0]
76230>>>>>>>                Case Break
76231>>>>>>>
76231>>>>>>>            Case Else
76231>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
76232>>>>>>>>
76232>>>>>>>        Case End
76232>>>>>>>
76232>>>>>>>        Function_Return sReturnArray
76233>>>>>>>    End_Function
76234>>>>>>>
76234>>>>>>>    // Returns all databases as a string array for the passed driver id.
76234>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
76236>>>>>>>        String[] sReturnArray
76237>>>>>>>        String sServer sVal
76237>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
76237>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
76238>>>>>>>        tSQLConnection SQLConnection
76238>>>>>>>        tSQLConnection SQLConnection
76238>>>>>>>        Boolean bOK
76238>>>>>>>        Integer iCount iSize
76238>>>>>>>
76238>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76239>>>>>>>        If (bOK = False) Begin
76241>>>>>>>            Function_Return sReturnArray
76242>>>>>>>        End
76242>>>>>>>>
76242>>>>>>>
76242>>>>>>>        Case Begin
76242>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76244>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
76245>>>>>>>                Case Break
76246>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76249>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
76250>>>>>>>                Case Break
76251>>>>>>>
76251>>>>>>>            // This is needed to be able to check if a database exists or not.
76251>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76254>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
76255>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
76257>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
76259>>>>>>>                        // If a FILEDSN: (can only be one database name)
76259>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
76260>>>>>>>                    End
76260>>>>>>>>
76260>>>>>>>                    Else Begin
76261>>>>>>>                        // Else the DSN's were read from the registry.
76261>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
76262>>>>>>>                        Move SQLConnection.sServer to sServer
76263>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
76264>>>>>>>                        Decrement iSize
76265>>>>>>>                        for iCount from 0 to iSize
76271>>>>>>>>
76271>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
76272>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
76274>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
76275>>>>>>>                                Move iSize to iCount // We're done.
76276>>>>>>>                            End
76276>>>>>>>>
76276>>>>>>>                        Loop
76277>>>>>>>>
76277>>>>>>>                    End
76277>>>>>>>>
76277>>>>>>>                End
76277>>>>>>>>
76277>>>>>>>                Case Break
76278>>>>>>>
76278>>>>>>>            Case (sDriverID = SQLFLEX)
76281>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
76282>>>>>>>                Case Break
76283>>>>>>>
76283>>>>>>>            Case (sDriverID = MDSPgSQL)
76286>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
76287>>>>>>>                Case Break
76288>>>>>>>
76288>>>>>>>            Case (sDriverID = MDSMySQL)
76291>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
76292>>>>>>>                Case Break
76293>>>>>>>
76293>>>>>>>            Case (sDriverID = ORAFLEX)
76296>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
76297>>>>>>>                Case Break
76298>>>>>>>
76298>>>>>>>            Case Else
76298>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
76298>>>>>>>        Case End
76298>>>>>>>
76298>>>>>>>        Function_Return sReturnArray
76299>>>>>>>    End_Function
76300>>>>>>>
76300>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
76300>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
76302>>>>>>>        String[] sReturnArray
76303>>>>>>>        Boolean bOK
76303>>>>>>>
76303>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76304>>>>>>>        If (bOK = False) Begin
76306>>>>>>>            Function_Return sReturnArray
76307>>>>>>>        End
76307>>>>>>>>
76307>>>>>>>
76307>>>>>>>        Case Begin
76307>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76309>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
76310>>>>>>>                Case Break
76311>>>>>>>
76311>>>>>>>            Case (sDriverID = MDSPgSQL)
76314>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
76315>>>>>>>                Case Break
76316>>>>>>>
76316>>>>>>>            Case (sDriverID = ORAFLEX)
76319>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
76320>>>>>>>                Case Break
76321>>>>>>>
76321>>>>>>>            Case Else
76321>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
76322>>>>>>>>
76322>>>>>>>                Case Break
76323>>>>>>>        Case End
76323>>>>>>>
76323>>>>>>>        Function_Return sReturnArray
76324>>>>>>>    End_Function
76325>>>>>>>
76325>>>>>>>    // Returns all schemas as a string array for the passed driver id.
76325>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
76327>>>>>>>        String[] sReturnArray
76328>>>>>>>        Boolean bOK
76328>>>>>>>
76328>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76329>>>>>>>        If (bOK = False) Begin
76331>>>>>>>            Function_Return sReturnArray
76332>>>>>>>        End
76332>>>>>>>>
76332>>>>>>>
76332>>>>>>>        Case Begin
76332>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76334>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
76335>>>>>>>                Case Break
76336>>>>>>>
76336>>>>>>>            Case (sDriverID = MDSPgSQL)
76339>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
76340>>>>>>>                Case Break
76341>>>>>>>
76341>>>>>>>            Case (sDriverID = ORAFLEX)
76344>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
76345>>>>>>>                Case Break
76346>>>>>>>
76346>>>>>>>            Case Else
76346>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
76347>>>>>>>>
76347>>>>>>>                Case Break
76348>>>>>>>        Case End
76348>>>>>>>
76348>>>>>>>        Function_Return sReturnArray
76349>>>>>>>    End_Function
76350>>>>>>>
76350>>>>>>>    // Returns a string array with all tables for the current database.
76350>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
76352>>>>>>>        String[] sReturnArray sArray
76354>>>>>>>        String sConnectionString sSelect
76354>>>>>>>        Integer iSize iCount iDbType
76354>>>>>>>        Boolean bOK
76354>>>>>>>
76354>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
76356>>>>>>>            Function_Return sArray
76357>>>>>>>        End
76357>>>>>>>>
76357>>>>>>>
76357>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76358>>>>>>>        If (bOK = False) Begin
76360>>>>>>>            Function_Return sReturnArray
76361>>>>>>>        End
76361>>>>>>>>
76361>>>>>>>        If (sSchema = "") Begin
76363>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
76364>>>>>>>        End
76364>>>>>>>>
76364>>>>>>>
76364>>>>>>>        Get psConnectionString to sConnectionString
76365>>>>>>>
76365>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
76365>>>>>>>        // the dbType.
76365>>>>>>>        Get piDbType to iDbType
76366>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
76368>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
76370>>>>>>>                Move MDSMySQL to sDriverID
76371>>>>>>>            End
76371>>>>>>>>
76371>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
76373>>>>>>>                Move MSSQLDRV_ID to sDriverID
76374>>>>>>>            End
76374>>>>>>>>
76374>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
76376>>>>>>>                Move DB2_DRV_ID to sDriverID
76377>>>>>>>            End
76377>>>>>>>>
76377>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
76379>>>>>>>                Move MDSPgSQL to sDriverID
76380>>>>>>>            End
76380>>>>>>>>
76380>>>>>>>        End
76380>>>>>>>>
76380>>>>>>>
76380>>>>>>>        Case Begin
76380>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76382>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
76383>>>>>>>                Case Break
76384>>>>>>>
76384>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76387>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
76388>>>>>>>                Case Break
76389>>>>>>>
76389>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76392>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
76393>>>>>>>                Case Break
76394>>>>>>>
76394>>>>>>>            Case (sDriverID = SQLFLEX)
76397>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
76398>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
76399>>>>>>>                Case Break
76400>>>>>>>
76400>>>>>>>            Case (sDriverID = MDSMySQL)
76403>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
76404>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
76405>>>>>>>                Case Break
76406>>>>>>>
76406>>>>>>>            Case (sDriverID = MDSPgSQL)
76409>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
76410>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
76411>>>>>>>                Case Break
76412>>>>>>>
76412>>>>>>>            Case (sDriverID = ORAFLEX)
76415>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
76416>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
76417>>>>>>>                Move (SizeOfArray(sArray)) to iSize
76418>>>>>>>                Decrement iSize
76419>>>>>>>                For iCount from 0 to iSize
76425>>>>>>>>
76425>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
76427>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
76428>>>>>>>                    End
76428>>>>>>>>
76428>>>>>>>                Loop
76429>>>>>>>>
76429>>>>>>>                Case Break
76430>>>>>>>
76430>>>>>>>            Case Else
76430>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
76431>>>>>>>>
76431>>>>>>>                Case Break
76432>>>>>>>        Case End
76432>>>>>>>
76432>>>>>>>        Function_Return sReturnArray
76433>>>>>>>    End_Function
76434>>>>>>>
76434>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
76434>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
76436>>>>>>>        String[] sReturnArray
76437>>>>>>>        String sConnectionString sSelect sSchema
76437>>>>>>>        Boolean bOK
76437>>>>>>>        Integer iDbType
76437>>>>>>>
76437>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76438>>>>>>>        If (bOK = False) Begin
76440>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
76441>>>>>>>>
76441>>>>>>>            Function_Return sReturnArray
76442>>>>>>>        End
76442>>>>>>>>
76442>>>>>>>
76442>>>>>>>        Get psConnectionString to sConnectionString
76443>>>>>>>        Get psSchema to sSchema
76444>>>>>>>
76444>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
76444>>>>>>>        // the dbType.
76444>>>>>>>        Get piDbType to iDbType
76445>>>>>>>
76445>>>>>>>        Case Begin
76445>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76447>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
76449>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
76450>>>>>>>                End
76450>>>>>>>>
76450>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
76452>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
76453>>>>>>>                End
76453>>>>>>>>
76453>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
76455>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
76456>>>>>>>                End
76456>>>>>>>>
76456>>>>>>>
76456>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
76457>>>>>>>                Case Break
76458>>>>>>>
76458>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76461>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
76462>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
76463>>>>>>>                Case Break
76464>>>>>>>
76464>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76467>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
76468>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
76469>>>>>>>                Case Break
76470>>>>>>>
76470>>>>>>>            Case (sDriverID = SQLFLEX)
76473>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
76474>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
76475>>>>>>>                Case Break
76476>>>>>>>
76476>>>>>>>            Case (sDriverID = MDSMySQL)
76479>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
76480>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
76481>>>>>>>                Case Break
76482>>>>>>>
76482>>>>>>>            Case (sDriverID = MDSPgSQL)
76485>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
76486>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
76487>>>>>>>                Case Break
76488>>>>>>>
76488>>>>>>>            Case (sDriverID = ORAFLEX)
76491>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
76492>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
76493>>>>>>>                Case Break
76494>>>>>>>
76494>>>>>>>            Case Else
76494>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
76495>>>>>>>>
76495>>>>>>>                Case Break
76496>>>>>>>        Case End
76496>>>>>>>
76496>>>>>>>        Function_Return sReturnArray
76497>>>>>>>    End_Function
76498>>>>>>>
76498>>>>>>>
76498>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
76498>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
76500>>>>>>>        String[] sReturnArray sReturnArray2
76502>>>>>>>        String sConnectionString sSelect sSchema
76502>>>>>>>        Boolean bOK
76502>>>>>>>        Integer iCount iSize
76502>>>>>>>
76502>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76503>>>>>>>        If (bOK = False) Begin
76505>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
76506>>>>>>>>
76506>>>>>>>            Function_Return sReturnArray
76507>>>>>>>        End
76507>>>>>>>>
76507>>>>>>>
76507>>>>>>>        Get psConnectionString to sConnectionString
76508>>>>>>>        Get psSchema to sSchema
76509>>>>>>>
76509>>>>>>>        Case Begin
76509>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76511>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
76512>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
76513>>>>>>>                Case Break
76514>>>>>>>
76514>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76517>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76518>>>>>>>>
76518>>>>>>>//                Move () to sSelect
76518>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
76518>>>>>>>                Case Break
76519>>>>>>>
76519>>>>>>>            Case (sDriverID = SQLFLEX)
76522>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76523>>>>>>>>
76523>>>>>>>//                Move () to sSelect
76523>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76523>>>>>>>                Case Break
76524>>>>>>>
76524>>>>>>>            Case (sDriverID = MDSMySQL)
76527>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76528>>>>>>>>
76528>>>>>>>//                Move () to sSelect
76528>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76528>>>>>>>                Case Break
76529>>>>>>>
76529>>>>>>>            Case (sDriverID = MDSPgSQL)
76532>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76533>>>>>>>>
76533>>>>>>>//                Move () to sSelect
76533>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76533>>>>>>>                Case Break
76534>>>>>>>
76534>>>>>>>            Case (sDriverID = ORAFLEX)
76537>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76538>>>>>>>>
76538>>>>>>>//                Move () to sSelect
76538>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
76538>>>>>>>                Case Break
76539>>>>>>>
76539>>>>>>>            Case Else
76539>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
76540>>>>>>>>
76540>>>>>>>                Case Break
76541>>>>>>>        Case End
76541>>>>>>>
76541>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
76542>>>>>>>        Decrement iSize
76543>>>>>>>        For iCount from 0 to iSize
76549>>>>>>>>
76549>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
76551>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
76552>>>>>>>            End
76552>>>>>>>>
76552>>>>>>>        Loop
76553>>>>>>>>
76553>>>>>>>
76553>>>>>>>        Function_Return sReturnArray2
76554>>>>>>>    End_Function
76555>>>>>>>
76555>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
76555>>>>>>>    // The format of the array is "TableName.FieldName"
76555>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
76557>>>>>>>        String[] sFileNameArray sFieldNameArray
76559>>>>>>>        tSQLRelation[] sRelationsArray
76559>>>>>>>        tSQLRelation[] sRelationsArray
76560>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
76560>>>>>>>        Boolean bOK
76560>>>>>>>        Integer iCount iSize iLength
76560>>>>>>>
76560>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
76561>>>>>>>        If (bOK = False) Begin
76563>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
76564>>>>>>>>
76564>>>>>>>            Function_Return sRelationsArray
76565>>>>>>>        End
76565>>>>>>>>
76565>>>>>>>
76565>>>>>>>        Get psConnectionString to sConnectionString
76566>>>>>>>        Get psSchema to sSchema
76567>>>>>>>
76567>>>>>>>        Case Begin
76567>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76569>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
76570>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
76571>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76572>>>>>>>                Case Break
76573>>>>>>>
76573>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76576>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76577>>>>>>>>
76577>>>>>>>//                Move () to sSelect
76577>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
76577>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76577>>>>>>>                Case Break
76578>>>>>>>
76578>>>>>>>            Case (sDriverID = SQLFLEX)
76581>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76582>>>>>>>>
76582>>>>>>>//                Move () to sSelect
76582>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76582>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76582>>>>>>>                Case Break
76583>>>>>>>
76583>>>>>>>            Case (sDriverID = MDSMySQL)
76586>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76587>>>>>>>>
76587>>>>>>>//                Move () to sSelect
76587>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76587>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76587>>>>>>>                Case Break
76588>>>>>>>
76588>>>>>>>            Case (sDriverID = MDSPgSQL)
76591>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76592>>>>>>>>
76592>>>>>>>//                Move () to sSelect
76592>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
76592>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76592>>>>>>>                Case Break
76593>>>>>>>
76593>>>>>>>            Case (sDriverID = ORAFLEX)
76596>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
76597>>>>>>>>
76597>>>>>>>//                Move () to sSelect
76597>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
76597>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
76597>>>>>>>                Case Break
76598>>>>>>>
76598>>>>>>>            Case Else
76598>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
76599>>>>>>>>
76599>>>>>>>                Case Break
76600>>>>>>>        Case End
76600>>>>>>>
76600>>>>>>>        Move (Length(sTableName)) to iLength
76601>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
76602>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
76603>>>>>>>        Decrement iSize
76604>>>>>>>        For iCount from 0 to iSize
76610>>>>>>>>
76610>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
76612>>>>>>>                Move sFileNameArray[iCount]         to sFileName
76613>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
76614>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
76615>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
76616>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
76617>>>>>>>            End
76617>>>>>>>>
76617>>>>>>>        Loop
76618>>>>>>>>
76618>>>>>>>
76618>>>>>>>        Function_Return sRelationsArray
76619>>>>>>>    End_Function
76620>>>>>>>
76620>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
76622>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
76622>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
76623>>>>>>>        String[] sUsers sPrograms
76625>>>>>>>        String sSelect
76625>>>>>>>        Integer iSize iCount
76625>>>>>>>
76625>>>>>>>        Case Begin
76625>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76627>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
76628>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
76629>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
76630>>>>>>>                Case Break
76631>>>>>>>            Case (sDriverID = SQLFLEX)
76634>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
76635>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
76636>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
76637>>>>>>>                Case Break
76638>>>>>>>            Case Else
76638>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
76639>>>>>>>>
76639>>>>>>>        Case End
76639>>>>>>>
76639>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
76640>>>>>>>        Decrement iSize
76641>>>>>>>        For iCount from 0 to iSize
76647>>>>>>>>
76647>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
76648>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
76649>>>>>>>        Loop
76650>>>>>>>>
76650>>>>>>>
76650>>>>>>>        Function_Return SQLLoggedInUser
76651>>>>>>>    End_Function
76652>>>>>>>
76652>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
76652>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
76652>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
76654>>>>>>>        String[] sFilesData
76655>>>>>>>        Boolean bExists
76655>>>>>>>        Integer iCh
76655>>>>>>>        String sFileName sExt
76655>>>>>>>
76655>>>>>>>        Get vFolderExists sDataPath to bExists
76656>>>>>>>        If (bExists = True) Begin
76658>>>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
76659>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
76660>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
76661>>>>>>>            Direct_Input channel iCh sDataPath
76663>>>>>>>                Repeat
76663>>>>>>>>
76663>>>>>>>                    Readln channel iCh sFileName
76665>>>>>>>                    Get ParseFileExtension sFileName to sExt
76666>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
76668>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
76670>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
76671>>>>>>>                        End
76671>>>>>>>>
76671>>>>>>>                    End
76671>>>>>>>>
76671>>>>>>>                Until (SeqEof = True)
76673>>>>>>>            Close_Input channel iCh
76675>>>>>>>            Send Seq_Release_Channel iCh
76676>>>>>>>        End
76676>>>>>>>>
76676>>>>>>>        Function_Return sFilesData
76677>>>>>>>    End_Function
76678>>>>>>>
76678>>>>>>>    // Only done for MSSQLDRV_ID so far...
76678>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
76680>>>>>>>        Boolean bMertechDriver
76680>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
76680>>>>>>>        String sDescription sFrom sSys sValue sPrevious
76680>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
76680>>>>>>>        Integer iFetchResult iRows iColumn iPos
76680>>>>>>>        tSQLConnection SQLConnection
76680>>>>>>>        tSQLConnection SQLConnection
76680>>>>>>>        String[] asCollations
76681>>>>>>>        
76681>>>>>>>        If (sDriverID = "") Begin
76683>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
76684>>>>>>>>
76684>>>>>>>            Function_Return asCollations
76685>>>>>>>        End
76685>>>>>>>>
76685>>>>>>>
76685>>>>>>>        // Only done for MSSQLDRV_ID so far...
76685>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
76687>>>>>>>            Function_Return asCollations
76688>>>>>>>        End                 
76688>>>>>>>>
76688>>>>>>>
76688>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
76689>>>>>>>        If (bMertechDriver = False) Begin
76691>>>>>>>            Get phoSQLManager to hoSQLManager
76692>>>>>>>        End
76692>>>>>>>>
76692>>>>>>>        Else Begin
76693>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
76694>>>>>>>        End
76694>>>>>>>>
76694>>>>>>>
76694>>>>>>>        Get psConnectionID     to sConnectionID
76695>>>>>>>        Get psConnectionString to sConnectionString
76696>>>>>>>        Move 0 to LastErr
76697>>>>>>>
76697>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
76698>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
76699>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
76700>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
76702>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
76703>>>>>>>>
76703>>>>>>>            Function_Return asCollations
76704>>>>>>>        End
76704>>>>>>>>
76704>>>>>>>
76704>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
76705>>>>>>>
76705>>>>>>>        If (hStmt = 0) Begin
76707>>>>>>>            Send SqlDisconnect of hoSQLManager
76708>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
76709>>>>>>>>
76709>>>>>>>            Function_Return asCollations
76710>>>>>>>        End
76710>>>>>>>>
76710>>>>>>>
76710>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
76711>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
76712>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
76713>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
76714>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
76715>>>>>>>
76715>>>>>>>        // MS-SQL Syntax:  
76715>>>>>>>        // SELECT name, description
76715>>>>>>>        //   from sys.fn_helpcollations();
76715>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
76716>>>>>>>
76716>>>>>>>        Move 1 to iColumn
76717>>>>>>>        Send SqlExecDirect of hStmt sSQL
76718>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
76719>>>>>>>        Repeat
76719>>>>>>>>
76719>>>>>>>            Get SQLFetch of hStmt to iFetchResult
76720>>>>>>>            If (iFetchResult <> 0) Begin
76722>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
76723>>>>>>>                If (sValue <> sPrevious) Begin         
76725>>>>>>>                    // We need to skip all collations starting with "SQL" because they
76725>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
76725>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
76726>>>>>>>                    If (iPos <> 1) Begin
76728>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
76729>>>>>>>                    End
76729>>>>>>>>
76729>>>>>>>                End
76729>>>>>>>>
76729>>>>>>>                Move sValue to sPrevious
76730>>>>>>>            End
76730>>>>>>>>
76730>>>>>>>        Until (iFetchResult = 0)
76732>>>>>>>        Send SQLClose of hStmt
76733>>>>>>>        Send SQLDisconnect of hoSQLConnect
76734>>>>>>>
76734>>>>>>>        Function_Return asCollations
76735>>>>>>>    End_Function
76736>>>>>>>
76736>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
76736>>>>>>>    // for DAW drivers.
76736>>>>>>>    // Returns: A string array.
76736>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
76738>>>>>>>        String[] sReturnArray
76739>>>>>>>        String sValue sPrevious
76739>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
76739>>>>>>>        Integer iFetchResult iRows
76739>>>>>>>        tSQLConnection SQLConnection
76739>>>>>>>        tSQLConnection SQLConnection
76739>>>>>>>
76739>>>>>>>        Get phoSQLManager to hoSQLHandler
76740>>>>>>>
76740>>>>>>>        If (hoSQLHandler <> 0) Begin
76742>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
76743>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
76744>>>>>>>
76744>>>>>>>            If (hoSQLConnect <> 0) Begin
76746>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
76747>>>>>>>                If (hstmt <> 0) Begin
76749>>>>>>>                    Send SqlExecDirect of hstmt sStmt
76750>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
76751>>>>>>>                    Repeat
76751>>>>>>>>
76751>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76752>>>>>>>                        If (iFetchResult <> 0) Begin
76754>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
76755>>>>>>>                            If (sValue <> sPrevious) Begin
76757>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
76758>>>>>>>                            End
76758>>>>>>>>
76758>>>>>>>                            Move sValue to sPrevious
76759>>>>>>>                        End
76759>>>>>>>>
76759>>>>>>>                    Until (iFetchResult = 0)
76761>>>>>>>                    Send SQLClose of hstmt
76762>>>>>>>                End
76762>>>>>>>>
76762>>>>>>>                Send SQLDisconnect of hoSQLConnect
76763>>>>>>>            End
76763>>>>>>>>
76763>>>>>>>        End
76763>>>>>>>>
76763>>>>>>>
76763>>>>>>>        Function_Return sReturnArray
76764>>>>>>>    End_Function
76765>>>>>>>
76765>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
76765>>>>>>>    // for Mertech drivers.
76765>>>>>>>    // Returns: A string array.
76765>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
76767>>>>>>>        String[] sReturnArray
76768>>>>>>>        String sValue
76768>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
76768>>>>>>>        Integer iFetchResult iRows
76768>>>>>>>        tSQLConnection SQLConnection
76768>>>>>>>        tSQLConnection SQLConnection
76768>>>>>>>
76768>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
76769>>>>>>>
76769>>>>>>>        If (hoSQLHandler <> 0) Begin
76771>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
76772>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
76773>>>>>>>
76773>>>>>>>            If (hoSQLConnect <> 0) Begin
76775>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
76776>>>>>>>                If (hStmt <> 0) Begin
76778>>>>>>>                    Send SqlExecDirect of hStmt sStmt
76779>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
76780>>>>>>>                    Repeat
76780>>>>>>>>
76780>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
76781>>>>>>>                        If (iFetchResult <> 0) Begin
76783>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
76784>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
76785>>>>>>>                        End
76785>>>>>>>>
76785>>>>>>>                    Until (iFetchResult = 0)
76787>>>>>>>                    Send SQLClose of hStmt
76788>>>>>>>                End
76788>>>>>>>>
76788>>>>>>>                Send SQLDisconnect of hoSQLConnect
76789>>>>>>>            End
76789>>>>>>>>
76789>>>>>>>        End
76789>>>>>>>>
76789>>>>>>>
76789>>>>>>>        Function_Return sReturnArray
76790>>>>>>>    End_Function
76791>>>>>>>
76791>>>>>>>    // * Dummy function for the Studio's Code Explorer *
76791>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
76793>>>>>>>        Function_Return False
76794>>>>>>>    End_Function
76795>>>>>>>
76795>>>>>>>    // Returns the index for the passed sTableName
76795>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
76795>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
76797>>>>>>>        Integer iIndex iSize iCount
76797>>>>>>>        String[] sTablesArray
76798>>>>>>>        String sDatabase sSchema sVal sConnectionString
76798>>>>>>>
76798>>>>>>>        Move -1 to iIndex
76799>>>>>>>        Get psConnectionString to sConnectionString
76800>>>>>>>        Get psDatabase to sDatabase
76801>>>>>>>        Get psSchema   to sSchema
76802>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
76803>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
76804>>>>>>>        Decrement iSize
76805>>>>>>>        For iCount from 0 to iSize
76811>>>>>>>>
76811>>>>>>>            Move sTablesArray[iCount] to sVal
76812>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
76814>>>>>>>                Move iCount to iIndex // We found it!
76815>>>>>>>                Move iSize to iCount  // End the loop
76816>>>>>>>            End
76816>>>>>>>>
76816>>>>>>>        Loop
76817>>>>>>>>
76817>>>>>>>
76817>>>>>>>        Function_Return iIndex
76818>>>>>>>    End_Function
76819>>>>>>>
76819>>>>>>>    // Helper function that builds a string like;
76819>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
76819>>>>>>>    Function _SqlSelectFromWhereName Returns String
76821>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
76821>>>>>>>
76821>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
76822>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
76823>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
76824>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
76825>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
76826>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
76827>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
76828>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
76829>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
76830>>>>>>>        Function_Return sRetval
76831>>>>>>>    End_Function
76832>>>>>>>
76832>>>>>>>    // Helper function to create a SQL statement like;
76832>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
76832>>>>>>>    // Used for checking if an index exists.
76832>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
76834>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
76834>>>>>>>
76834>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
76835>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
76836>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
76837>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
76838>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
76839>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
76840>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
76841>>>>>>>
76841>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
76842>>>>>>>
76842>>>>>>>        Function_Return sRetval
76843>>>>>>>    End_Function
76844>>>>>>>
76844>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
76844>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
76844>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
76846>>>>>>>        String sRetval
76846>>>>>>>        If (iLength <> 0) Begin
76848>>>>>>>            Move ("(" + String(iLength)) to sRetval
76849>>>>>>>            If (iDecimals <> 0) Begin
76851>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
76852>>>>>>>            End
76852>>>>>>>>
76852>>>>>>>            Move (sRetval + ")") to sRetval
76853>>>>>>>        End
76853>>>>>>>>
76853>>>>>>>        Function_Return sRetval
76854>>>>>>>    End_Function
76855>>>>>>>
76855>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
76857>>>>>>>        Integer i iCols iItem
76857>>>>>>>        tSqlColumnNew[] aQueryColumns
76857>>>>>>>        tSqlColumnNew[] aQueryColumns
76858>>>>>>>
76858>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
76859>>>>>>>        For i from 1 to iCols
76865>>>>>>>>
76865>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
76866>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
76867>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
76868>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
76869>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
76870>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
76871>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
76872>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
76873>>>>>>>        Loop
76874>>>>>>>>
76874>>>>>>>        Set piColumns to iCols
76875>>>>>>>        Set paQueryColumns to aQueryColumns
76876>>>>>>>    End_Procedure
76877>>>>>>>
76877>>>>>>>    // Checks that the passed sDriverID is defined.
76877>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
76877>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
76879>>>>>>>        Boolean bOK
76879>>>>>>>        Integer iDriver
76879>>>>>>>
76879>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
76881>>>>>>>            Function_Return False
76882>>>>>>>        End
76882>>>>>>>>
76882>>>>>>>
76882>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
76883>>>>>>>
76883>>>>>>>        If (bOK = False) Begin
76885>>>>>>>            Get IsMertechDriver sDriverID to bOK
76886>>>>>>>        End
76886>>>>>>>>
76886>>>>>>>
76886>>>>>>>        If (bOK = False) Begin
76888>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
76889>>>>>>>>
76889>>>>>>>            Function_Return False
76890>>>>>>>        End
76890>>>>>>>>
76890>>>>>>>
76890>>>>>>>        Get DriverIndex sDriverID to iDriver
76891>>>>>>>        If (iDriver = 0) Begin
76893>>>>>>>            Load_Driver sDriverID
76894>>>>>>>        End
76894>>>>>>>>
76894>>>>>>>
76894>>>>>>>        Function_Return True
76895>>>>>>>    End_Function
76896>>>>>>>
76896>>>>>>>    // Checks that the length parameter has been passed correctly.
76896>>>>>>>    // This is only of concern for certain SQL data types.
76896>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
76898>>>>>>>        Integer iLength
76898>>>>>>>        Boolean bOK bCheckTypeLength
76898>>>>>>>
76898>>>>>>>        If (num_arguments > 1) Begin
76900>>>>>>>            Move iLen to iLength
76901>>>>>>>        End
76901>>>>>>>>
76901>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
76902>>>>>>>
76902>>>>>>>        If (bCheckTypeLength = True) Begin
76904>>>>>>>            Move (iLength > 0) to bOK
76905>>>>>>>        End
76905>>>>>>>>
76905>>>>>>>
76905>>>>>>>        Function_Return (bOK = True)
76906>>>>>>>    End_Function
76907>>>>>>>
76907>>>>>>>    Function _SqlProperTableName String sTableName Returns String
76909>>>>>>>        String sVal sSchema sDriverID
76909>>>>>>>        Integer iDbType
76909>>>>>>>
76909>>>>>>>        If (Trim(sTableName) = "") Begin
76911>>>>>>>            Function_Return ""
76912>>>>>>>        End
76912>>>>>>>>
76912>>>>>>>
76912>>>>>>>        Get psDriverID to sDriverID
76913>>>>>>>        Get piDbType   to iDbType
76914>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
76916>>>>>>>            Get psUserID to sSchema
76917>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
76917>>>>>>>            Move (Uppercase(sSchema)) to sSchema
76918>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
76919>>>>>>>            Function_Return sTableName
76920>>>>>>>        End
76920>>>>>>>>
76920>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
76922>>>>>>>            Get psDatabase to sVal
76923>>>>>>>            Move (sVal + "." + sTableName) to sTableName
76924>>>>>>>            Function_Return sTableName
76925>>>>>>>        End
76925>>>>>>>>
76925>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
76927>>>>>>>            Move ('"' + sTableName + '"') to sTableName
76928>>>>>>>            Function_Return sTableName
76929>>>>>>>        End
76929>>>>>>>>
76929>>>>>>>
76929>>>>>>>        Get psSchema to sSchema
76930>>>>>>>        If (sSchema = "") Begin
76932>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
76933>>>>>>>        End
76933>>>>>>>>
76933>>>>>>>
76933>>>>>>>        Move (Uppercase(sTableName)) to sVal
76934>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
76936>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
76938>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
76939>>>>>>>            End
76939>>>>>>>>
76939>>>>>>>            Else Begin
76940>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
76941>>>>>>>            End
76941>>>>>>>>
76941>>>>>>>        End
76941>>>>>>>>
76941>>>>>>>
76941>>>>>>>        Function_Return sTableName
76942>>>>>>>    End_Function
76943>>>>>>>
76943>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
76943>>>>>>>    // the passed sFieldName has the correct spelling.
76943>>>>>>>    // Used with Embedded SQL statement calls.
76943>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
76943>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
76945>>>>>>>        String sRetval sValue sDriverID
76945>>>>>>>        String[] sColumnNamesArray
76946>>>>>>>        Integer iCount iColumns
76946>>>>>>>
76946>>>>>>>        Move "" to sRetval
76947>>>>>>>        Get psDriverID to sDriverID
76948>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
76949>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
76950>>>>>>>        Decrement iColumns
76951>>>>>>>
76951>>>>>>>        For iCount from 0 to iColumns
76957>>>>>>>>
76957>>>>>>>            Move sColumnNamesArray[iCount] to sValue
76958>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
76960>>>>>>>                Move sValue to sRetval
76961>>>>>>>                Move iColumns to iCount // We're done.
76962>>>>>>>            End
76962>>>>>>>>
76962>>>>>>>        Loop
76963>>>>>>>>
76963>>>>>>>
76963>>>>>>>        Function_Return sRetval
76964>>>>>>>    End_Function
76965>>>>>>>
76965>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
76967>>>>>>>        String[] sReturnArray
76968>>>>>>>        Handle hoSQLHandler
76968>>>>>>>        Integer iCount iSize iItem
76968>>>>>>>        String sServer
76968>>>>>>>        tSQLConnection SQLConnection
76968>>>>>>>        tSQLConnection SQLConnection
76968>>>>>>>
76968>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
76969>>>>>>>        Send Delete_Data    of hoSQLHandler
76970>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
76971>>>>>>>
76971>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
76972>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
76973>>>>>>>        Decrement iSize
76974>>>>>>>
76974>>>>>>>        For iCount from 0 to iSize
76980>>>>>>>>
76980>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
76981>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
76982>>>>>>>            Increment iItem
76983>>>>>>>        Loop
76984>>>>>>>>
76984>>>>>>>
76984>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
76985>>>>>>>
76985>>>>>>>        Function_Return sReturnArray
76986>>>>>>>    End_Function
76987>>>>>>>
76987>>>>>>>    Function _SqlTableArrayDAW Returns String[]
76989>>>>>>>        String[] sReturnArray
76990>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
76990>>>>>>>        Handle hoSQLHandler
76990>>>>>>>        Integer iCount iSize iItem iPos
76990>>>>>>>        Boolean bOK
76990>>>>>>>        tSQLConnection SQLConnection
76990>>>>>>>        tSQLConnection SQLConnection
76990>>>>>>>
76990>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
76991>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
76993>>>>>>>            Function_Return sReturnArray
76994>>>>>>>        End
76994>>>>>>>>
76994>>>>>>>
76994>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
76995>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
76996>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
76997>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
76998>>>>>>>
76998>>>>>>>        Get phoCLIHandler to hoSQLHandler
76999>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
77000>>>>>>>        Send Delete_Data  of hoSQLHandler
77001>>>>>>>
77001>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77002>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
77003>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
77003>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
77003>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
77003>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
77003>>>>>>>//                If (iPos > 0) Begin
77003>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
77003>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
77003>>>>>>>//                End
77003>>>>>>>//            End
77003>>>>>>>//        End
77003>>>>>>>
77003>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
77004>>>>>>>        Move False to Err
77005>>>>>>>        Move 0 to iItem
77006>>>>>>>
77006>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
77006>>>>>>>        for iCount from 1 to iSize
77012>>>>>>>>
77012>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
77013>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
77014>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
77015>>>>>>>            If (sSchema = "") Begin
77017>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
77018>>>>>>>            End
77018>>>>>>>>
77018>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
77019>>>>>>>            Move (Trim(sTable)) to sTable
77020>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
77022>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
77023>>>>>>>            End
77023>>>>>>>>
77023>>>>>>>            Else Begin
77024>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
77025>>>>>>>            End
77025>>>>>>>>
77025>>>>>>>            If (bOK = True) Begin
77027>>>>>>>                Move sTable to sReturnArray[iItem]
77028>>>>>>>                Increment iItem
77029>>>>>>>            End
77029>>>>>>>>
77029>>>>>>>        Loop
77030>>>>>>>>
77030>>>>>>>
77030>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77031>>>>>>>
77031>>>>>>>        Function_Return sReturnArray
77032>>>>>>>    End_Function
77033>>>>>>>
77033>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
77035>>>>>>>        String[] sReturnArray
77036>>>>>>>        String sValue
77036>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
77036>>>>>>>        Integer iRetval iCols iFetchResult
77036>>>>>>>        tSQLConnection SQLConnection
77036>>>>>>>        tSQLConnection SQLConnection
77036>>>>>>>
77036>>>>>>>        Get phoSQLManager to hoSQLHandler
77037>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
77038>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
77039>>>>>>>
77039>>>>>>>        If (hoSQLConnect <> 0) Begin
77041>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
77042>>>>>>>            If (hStmt <> 0) Begin
77044>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
77045>>>>>>>                If (sArgument <> "") Begin
77047>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
77048>>>>>>>                End
77048>>>>>>>>
77048>>>>>>>
77048>>>>>>>                Send SqlCall             of hStmt
77049>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
77050>>>>>>>                If (iRetval = 0) Begin
77052>>>>>>>                    Repeat
77052>>>>>>>>
77052>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
77053>>>>>>>                        If (iCols > 0) Begin
77055>>>>>>>                            Repeat
77055>>>>>>>>
77055>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
77056>>>>>>>                                If (iFetchResult <> 0) Begin
77058>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
77059>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
77060>>>>>>>                                End
77060>>>>>>>>
77060>>>>>>>                            Until (iFetchResult = 0)
77062>>>>>>>                        End
77062>>>>>>>>
77062>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
77063>>>>>>>                    Until (iRetval = 0)
77065>>>>>>>                    Send SqlClose of hStmt
77066>>>>>>>                End
77066>>>>>>>>
77066>>>>>>>            End
77066>>>>>>>>
77066>>>>>>>            Send SqlDisconnect of hoSQLConnect
77067>>>>>>>        End
77067>>>>>>>>
77067>>>>>>>        Function_Return sReturnArray
77068>>>>>>>    End_Function
77069>>>>>>>
77069>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
77071>>>>>>>        String[] sReturnArray
77072>>>>>>>        String sDataSource
77072>>>>>>>        Handle hoSQLHandler
77072>>>>>>>        Integer iItem
77072>>>>>>>
77072>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
77073>>>>>>>        Send SeedDataSources of hoSQLHandler
77074>>>>>>>
77074>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77075>>>>>>>
77075>>>>>>>        Repeat
77075>>>>>>>>
77075>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
77076>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
77077>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
77078>>>>>>>            Increment iItem
77079>>>>>>>        Until (sDataSource = "")
77081>>>>>>>
77081>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77082>>>>>>>
77082>>>>>>>        Function_Return sReturnArray
77083>>>>>>>    End_Function
77084>>>>>>>
77084>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
77086>>>>>>>        String[] sReturnArray
77087>>>>>>>        String sDataSource
77087>>>>>>>        Handle hoSQLHandler
77087>>>>>>>        Integer iItem
77087>>>>>>>
77087>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
77088>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77089>>>>>>>
77089>>>>>>>        Send SeedDataSources of hoSQLHandler
77090>>>>>>>
77090>>>>>>>        Repeat
77090>>>>>>>>
77090>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
77091>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
77093>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
77094>>>>>>>                Increment iItem
77095>>>>>>>            End
77095>>>>>>>>
77095>>>>>>>        Until (sDataSource = "")
77097>>>>>>>
77097>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
77098>>>>>>>
77098>>>>>>>        Function_Return sReturnArray
77099>>>>>>>    End_Function
77100>>>>>>>
77100>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
77102>>>>>>>        String[] sDataSources
77103>>>>>>>        tSQLConnection SQLConnection
77103>>>>>>>        tSQLConnection SQLConnection
77103>>>>>>>        tSQLIntTableInfo[] sReturnArray
77103>>>>>>>        tSQLIntTableInfo[] sReturnArray
77104>>>>>>>        Integer iDataSources iCount iItem
77104>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
77104>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
77104>>>>>>>        Boolean bExists bKeyOpened
77104>>>>>>>
77104>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
77105>>>>>>>        Move SQLConnection.sConnectionString to sConnection
77106>>>>>>>        Move SQLConnection.sServer           to sServer
77107>>>>>>>
77107>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
77107>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77109>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
77110>>>>>>>            Set psFileName of hoIniFile to sServer
77111>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
77112>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
77113>>>>>>>            Send Destroy of hoIniFile
77114>>>>>>>        End
77114>>>>>>>>
77114>>>>>>>
77114>>>>>>>        // DSN - read DATABASE name from the registry
77114>>>>>>>        Else Begin
77115>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
77116>>>>>>>
77116>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
77116>>>>>>>            // most probably place the info is kept that we're after.
77116>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
77117>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
77118>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
77119>>>>>>>            If (bExists = True) Begin
77121>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
77122>>>>>>>            End
77122>>>>>>>>
77122>>>>>>>            Else Begin
77123>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
77124>>>>>>>            End
77124>>>>>>>>
77124>>>>>>>
77124>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
77125>>>>>>>            If (bExists) Begin
77127>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
77128>>>>>>>                If (bKeyOpened) Begin
77130>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
77131>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
77132>>>>>>>                    If (iDataSources > 0) Begin
77134>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
77135>>>>>>>                        Decrement iDataSources
77136>>>>>>>                        for iCount from 0 to iDataSources
77142>>>>>>>>
77142>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
77143>>>>>>>                        Loop
77144>>>>>>>>
77144>>>>>>>                        Move 0 to iItem
77145>>>>>>>                        for iCount from 0 to iDataSources
77151>>>>>>>>
77151>>>>>>>                            Move sDataSources[iCount] to sSubKey
77152>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
77153>>>>>>>                            If (bKeyOpened = True) Begin
77155>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
77156>>>>>>>                                If (bExists = True) Begin
77158>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
77159>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
77160>>>>>>>                                    Increment iItem
77161>>>>>>>                                End
77161>>>>>>>>
77161>>>>>>>                            End
77161>>>>>>>>
77161>>>>>>>                        Loop
77162>>>>>>>>
77162>>>>>>>                    End
77162>>>>>>>>
77162>>>>>>>                    Send CloseKey of hoRegistry
77163>>>>>>>                    Send Destroy of hoODBCDataSources
77164>>>>>>>                End
77164>>>>>>>>
77164>>>>>>>            End
77164>>>>>>>>
77164>>>>>>>
77164>>>>>>>            // We then check the "User DNS" area in the registry.
77164>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
77165>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
77166>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
77167>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
77168>>>>>>>
77168>>>>>>>            If (bExists) Begin
77170>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
77171>>>>>>>                If (bKeyOpened) Begin
77173>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
77174>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
77175>>>>>>>                    If (iDataSources > 0) Begin
77177>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
77178>>>>>>>                        Decrement iDataSources
77179>>>>>>>                        for iCount from 0 to iDataSources
77185>>>>>>>>
77185>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
77186>>>>>>>                        Loop
77187>>>>>>>>
77187>>>>>>>                        for iCount from 0 to iDataSources
77193>>>>>>>>
77193>>>>>>>                            Move sDataSources[iCount] to sSubKey
77194>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
77195>>>>>>>                            If (bKeyOpened = True) Begin
77197>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
77198>>>>>>>                                If (bExists = True) Begin
77200>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
77201>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
77202>>>>>>>                                    Increment iItem
77203>>>>>>>                                End
77203>>>>>>>>
77203>>>>>>>                            End
77203>>>>>>>>
77203>>>>>>>                        Loop
77204>>>>>>>>
77204>>>>>>>                    End
77204>>>>>>>>
77204>>>>>>>                    Send CloseKey of hoRegistry
77205>>>>>>>                    Send Destroy of hoODBCDataSources
77206>>>>>>>                End
77206>>>>>>>>
77206>>>>>>>            End
77206>>>>>>>>
77206>>>>>>>
77206>>>>>>>            Send Destroy of hoRegistry
77207>>>>>>>        End
77207>>>>>>>>
77207>>>>>>>
77207>>>>>>>        Function_Return sReturnArray
77208>>>>>>>    End_Function
77209>>>>>>>
77209>>>>>>>    // We might have a split Sql script where the info about which database to use is
77209>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
77209>>>>>>>    // insert it for scriplets to come after the first one.
77209>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
77211>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
77211>>>>>>>        Integer iStart iEnd iDbType
77211>>>>>>>        Boolean bOK
77211>>>>>>>
77211>>>>>>>        Get piDbType to iDbType
77212>>>>>>>        Get psDriverID to sDriverID
77213>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
77214>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
77215>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
77216>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
77217>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
77218>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
77220>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
77221>>>>>>>            Move (Pos("]", sTmp)) to iEnd
77222>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
77223>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
77224>>>>>>>            Set Private.psUseDatabase to sUseDatabase
77225>>>>>>>        End
77225>>>>>>>>
77225>>>>>>>        Else Begin
77226>>>>>>>            Move (Uppercase(sStmt)) to sTmp
77227>>>>>>>
77227>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
77227>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
77229>>>>>>>                Get Private.psUseDatabase to sUseDatabase
77230>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
77231>>>>>>>            End
77231>>>>>>>>
77231>>>>>>>
77231>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
77231>>>>>>>            // We will get an error when trying to create a view if it already exists.
77231>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
77231>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
77234>>>>>>>                // Make sure we only have one space between statements/words.
77234>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
77235>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
77236>>>>>>>                Move (Trim(sTmp)) to sTmp
77237>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
77238>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
77239>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
77241>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
77242>>>>>>>                End
77242>>>>>>>>
77242>>>>>>>                Move (Trim(sTmp)) to sTmp
77243>>>>>>>                // Remove data view as it already exists!
77243>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
77244>>>>>>>            End
77244>>>>>>>>
77244>>>>>>>        End
77244>>>>>>>>
77244>>>>>>>
77244>>>>>>>        Function_Return sStmt
77245>>>>>>>    End_Function
77246>>>>>>>
77246>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
77246>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
77248>>>>>>>        String sRetval
77248>>>>>>>        Integer iDbType iIndex
77248>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77248>>>>>>>        tSQLKeyWords[] SQLKeywordArray
77249>>>>>>>        tSQLKeyWords   SQLKeyWords
77249>>>>>>>        tSQLKeyWords   SQLKeyWords
77249>>>>>>>
77249>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
77249>>>>>>>        Move "" to sRetval
77250>>>>>>>        Get piDbType to iDbType
77251>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
77252>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
77253>>>>>>>
77253>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77254>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
77255>>>>>>>        If (iIndex >= 0) Begin
77257>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
77258>>>>>>>        End
77258>>>>>>>>
77258>>>>>>>
77258>>>>>>>        Function_Return sRetval
77259>>>>>>>    End_Function
77260>>>>>>>
77260>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
77260>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
77262>>>>>>>        String[] sSQLScriptArray
77263>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
77263>>>>>>>        Integer iSize iCount
77263>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
77263>>>>>>>
77263>>>>>>>        Move False to bCommentStart
77264>>>>>>>        Move False to bCommentEnd
77265>>>>>>>        Move False to bDashComment
77266>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
77267>>>>>>>        Move "*/"  to sCommentEnd
77268>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
77269>>>>>>>
77269>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
77270>>>>>>>        Decrement iSize
77271>>>>>>>        Move "" to sText
77272>>>>>>>
77272>>>>>>>        For iCount from 0 to iSize
77278>>>>>>>>
77278>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
77279>>>>>>>            Move (Trim(sLine)) to sTmp
77280>>>>>>>            If (sTmp <> "") Begin
77282>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
77283>>>>>>>                If (bCommentStart = False) Begin
77285>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
77286>>>>>>>                    If (bCommentStart = False) Begin
77288>>>>>>>                    End
77288>>>>>>>>
77288>>>>>>>                End
77288>>>>>>>>
77288>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
77289>>>>>>>                If (bCommentEnd = True) Begin
77291>>>>>>>                    Move False to bCommentStart
77292>>>>>>>                End
77292>>>>>>>>
77292>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
77294>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
77295>>>>>>>                End
77295>>>>>>>>
77295>>>>>>>            End
77295>>>>>>>>
77295>>>>>>>        Loop
77296>>>>>>>>
77296>>>>>>>
77296>>>>>>>        // Update the retval struct array:
77296>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
77297>>>>>>>        Function_Return SqlScriptArray
77298>>>>>>>    End_Function
77299>>>>>>>
77299>>>>>>>
77299>>>>>>>    // *** Database API Functions: ***
77299>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
77299>>>>>>>    // make changes/updates to the database.
77299>>>>>>>
77299>>>>>>>    // * Dummy function for the Studio's Code Explorer *
77299>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
77301>>>>>>>        Function_Return False
77302>>>>>>>    End_Function
77303>>>>>>>
77303>>>>>>>    // This might not do what you think - Here's what it does:
77303>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
77303>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
77303>>>>>>>    // to the SQL table.
77303>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
77303>>>>>>>    // already exists in SQL.
77303>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
77303>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
77303>>>>>>>    // restructuring an existing table.
77303>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
77305>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
77305>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
77305>>>>>>>        Handle hToTable
77305>>>>>>>
77305>>>>>>>        Move True to bUseConnectionID
77306>>>>>>>        If (num_arguments > 1) Begin
77308>>>>>>>            Move bUseConnID to bUseConnectionID
77309>>>>>>>        End
77309>>>>>>>>
77309>>>>>>>
77309>>>>>>>        Get psDriverID to sDriverID
77310>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
77310>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
77311>>>>>>>        If (bExists = False) Begin
77313>>>>>>>            Function_Return False
77314>>>>>>>        End
77314>>>>>>>>
77314>>>>>>>
77314>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
77315>>>>>>>
77315>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
77316>>>>>>>        If (bOK = False) Begin
77318>>>>>>>            Function_Return False
77319>>>>>>>        End
77319>>>>>>>>
77319>>>>>>>
77319>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
77319>>>>>>>        // we do nothing
77319>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
77320>>>>>>>        If (bExists = True) Begin
77322>>>>>>>            Function_Return False
77323>>>>>>>        End
77323>>>>>>>>
77323>>>>>>>
77323>>>>>>>        Get psConnectionID     to sConnectionID
77324>>>>>>>        Get psConnectionString to sConnectionString
77325>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
77327>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
77328>>>>>>>>
77328>>>>>>>            Function_Return False
77329>>>>>>>        End
77329>>>>>>>>
77329>>>>>>>
77329>>>>>>>        Set Private.phCurrentTable to hTable
77330>>>>>>>        Get psSchema to sSchema
77331>>>>>>>        If (sSchema = "") Begin
77333>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
77334>>>>>>>        End
77334>>>>>>>>
77334>>>>>>>
77334>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
77335>>>>>>>
77335>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
77335>>>>>>>        // was a programmer's error and we adjust for it here.
77335>>>>>>>        If (bMertechDriver = True) Begin
77337>>>>>>>            Move False to bUseConnectionID
77338>>>>>>>        End
77338>>>>>>>>
77338>>>>>>>
77338>>>>>>>        // If we should use a connection id we need to check it exists;
77338>>>>>>>        // else we create it before attempting creating the table
77338>>>>>>>        If (bUseConnectionID = True) Begin
77340>>>>>>>            Get AutoConnectionIDLogin to bOK
77341>>>>>>>            If (bOk = False) Begin
77343>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
77344>>>>>>>>
77344>>>>>>>                Function_Return False
77345>>>>>>>            End
77345>>>>>>>>
77345>>>>>>>        End
77345>>>>>>>>
77345>>>>>>>
77345>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
77348>>>>>>>        Get _TableNameOnly sRootName to sRootName
77349>>>>>>>        If (sRootName = "") Begin
77351>>>>>>>            Function_Return False
77352>>>>>>>        End
77352>>>>>>>>
77352>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
77353>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
77356>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
77359>>>>>>>
77359>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
77359>>>>>>>        //
77359>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
77359>>>>>>>        // because then the table should not be visible to users.
77359>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
77359>>>>>>>//        If (iPos <> 1) Begin
77359>>>>>>>//            If (sDisplayName contains ".") Begin
77359>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
77359>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
77359>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
77359>>>>>>>//            End
77359>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
77359>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
77359>>>>>>>//            End
77359>>>>>>>//        End
77359>>>>>>>
77359>>>>>>>        If (bIsAlias = False) Begin
77361>>>>>>>            Get OpenTableExclusive hTable to bOpened
77362>>>>>>>            If (bOpened = False) Begin
77364>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
77365>>>>>>>>
77365>>>>>>>                Function_Return False
77366>>>>>>>            End
77366>>>>>>>>
77366>>>>>>>        End
77366>>>>>>>>
77366>>>>>>>
77366>>>>>>>        If (ghoProgressBar <> 0) Begin
77368>>>>>>>            Send DoAdvance of ghoProgressBar
77369>>>>>>>            Set Message_Text of ghoStatusPanel to ""
77370>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
77371>>>>>>>        End
77371>>>>>>>>
77371>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
77371>>>>>>>        Move hTable to hToTable
77372>>>>>>>        Move False to Err
77373>>>>>>>
77373>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
77373>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
77373>>>>>>>        // a proper and updated .int file.
77373>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
77376>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
77377>>>>>>>
77377>>>>>>>        If (bIsAlias = False) Begin
77379>>>>>>>            Structure_Start hToTable sDriverID
77380>>>>>>>                Set Private.phCurrentTable to hTable
77381>>>>>>>                If (bUseConnectionID = True) Begin
77383>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
77386>>>>>>>                End
77386>>>>>>>>
77386>>>>>>>                Else Begin
77387>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
77390>>>>>>>                End
77390>>>>>>>>
77390>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
77393>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
77393>>>>>>>                Move False to Err
77394>>>>>>>                Move 0 to LastErr
77395>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
77396>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
77398>>>>>>>            Set Action_Text of ghoStatusPanel to ""
77399>>>>>>>        End
77399>>>>>>>>
77399>>>>>>>
77399>>>>>>>        Move (not(Err)) to bOK
77400>>>>>>>        If (bOK = True) Begin
77402>>>>>>>            // The attributes set above will always trigger an error
77402>>>>>>>            // We also adjust the Filelist entries
77402>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
77405>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
77408>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
77411>>>>>>>
77411>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
77411>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
77412>>>>>>>        End
77412>>>>>>>>
77412>>>>>>>
77412>>>>>>>        Function_Return (bOK = True)
77413>>>>>>>    End_Function
77414>>>>>>>
77414>>>>>>>    // Sample usage:
77414>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
77414>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
77414>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
77416>>>>>>>        Boolean bOK bIsSQLTable
77416>>>>>>>
77416>>>>>>>        Get AutoConnectionIDLogin to bOK
77417>>>>>>>        Move False to Err
77418>>>>>>>        Get OpenTableExclusive hTable to bOK
77419>>>>>>>        If (bOK = False) Begin
77421>>>>>>>            Function_Return False
77422>>>>>>>        End
77422>>>>>>>>
77422>>>>>>>
77422>>>>>>>        // ToDo: Add to all table change functions!
77422>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
77423>>>>>>>            If (bIsSQLTable = True) Begin
77425>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
77428>>>>>>>            End
77428>>>>>>>>
77428>>>>>>>
77428>>>>>>>        Set Private.phCurrentTable to hTable
77429>>>>>>>        Structure_Start hTable
77430>>>>>>>            Set_Attribute iAttribute of hTable to iValue
77433>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
77434>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
77436>>>>>>>
77436>>>>>>>        Set Action_Text of ghoStatusPanel to ""
77437>>>>>>>        Function_Return (Err = False)
77438>>>>>>>    End_Function
77439>>>>>>>
77439>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
77441>>>>>>>        Boolean bOK
77441>>>>>>>        
77441>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
77442>>>>>>>        If (bOK = True) Begin
77444>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
77445>>>>>>>        End
77445>>>>>>>>
77445>>>>>>>        
77445>>>>>>>        Function_Return (bOK = True)
77446>>>>>>>    End_Function
77447>>>>>>>    
77447>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
77447>>>>>>>    // or to change the filelist slot names.
77447>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
77449>>>>>>>        String sFileListName
77449>>>>>>>        
77449>>>>>>>        Move False to Err
77450>>>>>>>
77450>>>>>>>        If (ghoProgressBar <> 0) Begin
77452>>>>>>>            Send DoAdvance of ghoProgressBar
77453>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
77454>>>>>>>        End
77454>>>>>>>>
77454>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
77454>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
77456>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
77459>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
77462>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
77465>>>>>>>            Function_Return (Err = False) // And we're done.
77466>>>>>>>        End
77466>>>>>>>>
77466>>>>>>>
77466>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
77468>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
77468>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
77469>>>>>>>        End
77469>>>>>>>>
77469>>>>>>>//        Else Begin
77469>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
77469>>>>>>>//        End
77469>>>>>>>//
77469>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
77469>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
77469>>>>>>>
77469>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
77472>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
77475>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
77478>>>>>>>        
77478>>>>>>>        Function_Return (Err = False)
77479>>>>>>>    End_Function
77480>>>>>>>
77480>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
77482>>>>>>>        Boolean bOK
77482>>>>>>>
77482>>>>>>>        Get AutoConnectionIDLogin to bOK
77483>>>>>>>        Move False to Err
77484>>>>>>>        Get OpenTableExclusive hTable to bOK
77485>>>>>>>        If (bOK = False) Begin
77487>>>>>>>            Function_Return False
77488>>>>>>>        End
77488>>>>>>>>
77488>>>>>>>
77488>>>>>>>        Set Private.phCurrentTable to hTable
77489>>>>>>>        Structure_Start hTable
77490>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
77493>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
77494>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
77496>>>>>>>
77496>>>>>>>        Set Action_Text of ghoStatusPanel to ""
77497>>>>>>>        Function_Return (Err = False)
77498>>>>>>>    End_Function
77499>>>>>>>
77499>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
77501>>>>>>>        Boolean bOK bIsSQLTable
77501>>>>>>>
77501>>>>>>>        Move False to Err
77502>>>>>>>        Get AutoConnectionIDLogin to bOK
77503>>>>>>>        Open hToTable
77505>>>>>>>        Get OpenTableExclusive hTable to bOK
77506>>>>>>>        If (bOK = False) Begin
77508>>>>>>>            Function_Return False
77509>>>>>>>        End
77509>>>>>>>>
77509>>>>>>>
77509>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
77510>>>>>>>            If (bIsSQLTable = True) Begin
77512>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
77515>>>>>>>            End
77515>>>>>>>>
77515>>>>>>>
77515>>>>>>>        Set Private.phCurrentTable to hTable
77516>>>>>>>        Structure_Start hTable
77517>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
77520>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
77523>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
77524>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
77526>>>>>>>
77526>>>>>>>        Set Action_Text of ghoStatusPanel to ""
77527>>>>>>>        Function_Return (Err = False)
77528>>>>>>>    End_Function
77529>>>>>>>
77529>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
77531>>>>>>>        Integer[] aTableConvertExceptions
77532>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
77533>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
77534>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
77535>>>>>>>    End_Procedure
77536>>>>>>>
77536>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
77538>>>>>>>        Integer[] aTableDateCorrectionExceptions
77539>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
77540>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
77541>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
77542>>>>>>>    End_Procedure
77543>>>>>>>
77543>>>>>>>    Procedure ApiTableConvertALLToSql
77545>>>>>>>        Integer[] iTablesArray
77546>>>>>>>        Integer iSize iCount
77546>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
77546>>>>>>>        String sDriverID
77546>>>>>>>
77546>>>>>>>        Get psDriverID to sDriverID
77547>>>>>>>        Get pbUseConnectionID to bUseConnectionID
77548>>>>>>>        Get pbToANSI          to bToANSI
77549>>>>>>>        Get pbRecnum          to bRecnum
77550>>>>>>>        Get pbCopyData        to bCopyData
77551>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
77553>>>>>>>            Get pbContinueOnError to bContinueOnError
77554>>>>>>>        End
77554>>>>>>>>
77554>>>>>>>
77554>>>>>>>        Get _AllTablesToConvert to iTablesArray
77555>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
77556>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
77557>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
77558>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
77559>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
77560>>>>>>>
77560>>>>>>>        Decrement iSize
77561>>>>>>>        For iCount from 0 to iSize
77567>>>>>>>>
77567>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
77568>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
77569>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
77569>>>>>>>            // if there was an error converting one table...
77569>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
77569>>>>>>>        Loop
77570>>>>>>>>
77570>>>>>>>
77570>>>>>>>    End_Procedure
77571>>>>>>>
77571>>>>>>>    Procedure ApiTableAttachALLToSql
77573>>>>>>>        Integer[] iTablesArray
77574>>>>>>>        Integer iSize iCount
77574>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
77574>>>>>>>        String sDriverID
77574>>>>>>>
77574>>>>>>>        Get psDriverID to sDriverID
77575>>>>>>>        Get pbUseConnectionID to bUseConnectionID
77576>>>>>>>        Get pbToANSI          to bToANSI
77577>>>>>>>        Get pbRecnum          to bRecnum
77578>>>>>>>        Get pbCopyData        to bCopyData
77579>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
77581>>>>>>>            Get pbContinueOnError to bContinueOnError
77582>>>>>>>        End
77582>>>>>>>>
77582>>>>>>>
77582>>>>>>>        Get _AllTablesToConvert to iTablesArray
77583>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
77584>>>>>>>        Decrement iSize
77585>>>>>>>        For iCount from 0 to iSize
77591>>>>>>>>
77591>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
77592>>>>>>>        Loop
77593>>>>>>>>
77593>>>>>>>
77593>>>>>>>    End_Procedure
77594>>>>>>>
77594>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
77594>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
77596>>>>>>>        Handle hTable
77596>>>>>>>        String sConnectionID
77596>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
77596>>>>>>>
77596>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
77597>>>>>>>        If (bSameTableNames = True) Begin
77599>>>>>>>            Function_Return True
77600>>>>>>>        End
77600>>>>>>>>
77600>>>>>>>
77600>>>>>>>        Move True to bOK
77601>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
77602>>>>>>>        Set Private.phCurrentTable              to hTable
77603>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
77606>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
77609>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
77612>>>>>>>
77612>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
77614>>>>>>>            Get psConnectionID to sConnectionID
77615>>>>>>>            Get UtilTableExists hTable to bTableExists
77616>>>>>>>            If (bTableExists = True) Begin
77618>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
77619>>>>>>>            End
77619>>>>>>>>
77619>>>>>>>            Else Begin
77620>>>>>>>                Get pbToANSI to bANSI
77621>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
77622>>>>>>>            End
77622>>>>>>>>
77622>>>>>>>        End
77622>>>>>>>>
77622>>>>>>>
77622>>>>>>>        Function_Return bOK
77623>>>>>>>    End_Function
77624>>>>>>>
77624>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
77626>>>>>>>        Handle hToTable hoLogFile
77626>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
77626>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
77626>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
77626>>>>>>>        tSQLConnection SQLConnection
77626>>>>>>>        tSQLConnection SQLConnection
77626>>>>>>>
77626>>>>>>>        Get UtilTableExists hTable to bExists
77627>>>>>>>        If (bExists = False) Begin
77629>>>>>>>            Set Private.phCurrentTable to hTable
77630>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
77631>>>>>>>>
77631>>>>>>>            Function_Return False
77632>>>>>>>        End
77632>>>>>>>>
77632>>>>>>>
77632>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
77633>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
77633>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
77633>>>>>>>        If (bIsAlias = True) Begin
77635>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
77638>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
77640>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
77643>>>>>>>                Get psConnectionID to sConnectionID
77644>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
77645>>>>>>>            End
77645>>>>>>>>
77645>>>>>>>            Function_Return True
77646>>>>>>>        End
77646>>>>>>>>
77646>>>>>>>
77646>>>>>>>        Set Private.phCurrentTable to hTable
77647>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
77650>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
77653>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
77656>>>>>>>
77656>>>>>>>        If (ghoProgressBar <> 0) Begin
77658>>>>>>>            Send DoAdvance of ghoProgressBar
77659>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
77660>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
77661>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
77662>>>>>>>        End
77662>>>>>>>>
77662>>>>>>>
77662>>>>>>>        // Marco Kuipers suggestion;
77662>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
77662>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
77662>>>>>>>        // SQL table.
77662>>>>>>>        Get UtilTableIsSQL hTable to bOK
77663>>>>>>>        If (bOK = False) Begin
77665>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
77666>>>>>>>            If (bExists = True) Begin
77668>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
77668>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
77668>>>>>>>                Get phoLogFile to hoLogFile
77669>>>>>>>                If (hoLogFile <> 0) Begin          
77671>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
77672>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
77672>>>>>>>                    Send LogError sWarning False
77673>>>>>>>                End
77673>>>>>>>>
77673>>>>>>>                Else Begin
77674>>>>>>>                    Error DFERR_PROGRAM sWarning
77675>>>>>>>>
77675>>>>>>>                End                                                       
77675>>>>>>>>
77675>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
77676>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
77677>>>>>>>            End
77677>>>>>>>>
77677>>>>>>>        End
77677>>>>>>>>
77677>>>>>>>
77677>>>>>>>        // Does the rootname contain a driver?
77677>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
77679>>>>>>>            // Does the table already exist as an SQL table?
77679>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
77680>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
77680>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
77680>>>>>>>            If (bExists = False) Begin
77682>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
77683>>>>>>>            End
77683>>>>>>>>
77683>>>>>>>            If (bExists = True) Begin
77685>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
77686>>>>>>>                Function_Return False
77687>>>>>>>            End
77687>>>>>>>>
77687>>>>>>>        End
77687>>>>>>>>
77687>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
77688>>>>>>>
77688>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
77689>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
77689>>>>>>>        // passed as True, we adjust for that here.
77689>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
77690>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
77692>>>>>>>            Move False to bUseConnectionID
77693>>>>>>>        End
77693>>>>>>>>
77693>>>>>>>
77693>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
77694>>>>>>>        Move SQLConnection.sSchema           to sSchema
77695>>>>>>>        If (sSchema = "") Begin
77697>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
77698>>>>>>>            Move (Lowercase(sSchema))        to sSchema
77699>>>>>>>        End
77699>>>>>>>>
77699>>>>>>>
77699>>>>>>>        If (sDriverID = ORAFLEX) Begin
77701>>>>>>>            Move SQLConnection.sUserID       to sSchema
77702>>>>>>>        End
77702>>>>>>>>
77702>>>>>>>
77702>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
77703>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
77704>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
77705>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
77707>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
77708>>>>>>>>
77708>>>>>>>            Function_Return False
77709>>>>>>>        End
77709>>>>>>>>
77709>>>>>>>
77709>>>>>>>        Get AutoConnectionIDLogin to bOK
77710>>>>>>>        Open hTable
77712>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
77715>>>>>>>        If (bOpened = False) Begin
77717>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
77718>>>>>>>>
77718>>>>>>>            Function_Return False
77719>>>>>>>        End
77719>>>>>>>>
77719>>>>>>>
77719>>>>>>>        If (ghoProgressBar <> 0) Begin
77721>>>>>>>            Send DoAdvance of ghoProgressBar
77722>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
77723>>>>>>>        End
77723>>>>>>>>
77723>>>>>>>
77723>>>>>>>        Move 0 to hToTable
77724>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
77725>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
77726>>>>>>>
77726>>>>>>>        Case Begin
77726>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77728>>>>>>>                Case Break
77729>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77732>>>>>>>                Case Break
77733>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77736>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
77737>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
77738>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
77739>>>>>>>                Case Break
77740>>>>>>>            Case (sDriverID = ORAFLEX)
77743>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
77744>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
77745>>>>>>>                Case Break
77746>>>>>>>            Case (sDriverID = MDSMySQL)
77749>>>>>>>                Case Break
77750>>>>>>>            Case (sDriverID = MDSPgSQL)
77753>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
77754>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
77755>>>>>>>                Case Break
77756>>>>>>>            Case (sDriverID = DATAFLEX_ID)
77759>>>>>>>                Case Break
77760>>>>>>>            Case Else
77760>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
77761>>>>>>>>
77761>>>>>>>                Case Break
77762>>>>>>>        Case End
77762>>>>>>>
77762>>>>>>>        Move False to Err
77763>>>>>>>
77763>>>>>>>        If (bMertechDriver = True) Begin
77765>>>>>>>            // Note: This function also sets the Err flag.
77765>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
77766>>>>>>>        End
77766>>>>>>>>
77766>>>>>>>
77766>>>>>>>        If (bMertechDriver = False) Begin
77768>>>>>>>            Structure_Start hToTable sDriverID
77769>>>>>>>                Structure_Copy hTable to hToTable
77770>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
77773>>>>>>>
77773>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
77775>>>>>>>                    If (bUseConnectionID = True) Begin
77777>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
77780>>>>>>>                    End
77780>>>>>>>>
77780>>>>>>>                    Else Begin
77781>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
77784>>>>>>>                    End
77784>>>>>>>>
77784>>>>>>>
77784>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
77787>>>>>>>
77787>>>>>>>                    If (sSchema <> "") Begin
77789>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
77792>>>>>>>                    End
77792>>>>>>>>
77792>>>>>>>
77792>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
77794>>>>>>>                        If (sLongTableSpace <> "") Begin
77796>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
77799>>>>>>>                        End
77799>>>>>>>>
77799>>>>>>>                        If (sBaseTableSpace <> "") Begin
77801>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
77804>>>>>>>                        End
77804>>>>>>>>
77804>>>>>>>                        If (sIndexTableSpace <> "") Begin
77806>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
77809>>>>>>>                        End
77809>>>>>>>>
77809>>>>>>>                    End
77809>>>>>>>>
77809>>>>>>>                End
77809>>>>>>>>
77809>>>>>>>
77809>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
77810>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
77812>>>>>>>            Set Action_Text of ghoStatusPanel to ""
77813>>>>>>>        End
77813>>>>>>>>
77813>>>>>>>
77813>>>>>>>        Move (not(Err)) to bOK
77814>>>>>>>
77814>>>>>>>        If (bOK = True and bCopyData = True) Begin
77816>>>>>>>            If (bMertechDriver = False) Begin
77818>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
77819>>>>>>>            End
77819>>>>>>>>
77819>>>>>>>            Else Begin
77820>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
77821>>>>>>>            End
77821>>>>>>>>
77821>>>>>>>
77821>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
77823>>>>>>>                Get pbContinueOnError to bContinueOnError
77824>>>>>>>            End
77824>>>>>>>>
77824>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
77824>>>>>>>            // rename it by adding a GUID to the end of the table name
77824>>>>>>>            // - or as much as "fit" because different SQL back-ends have
77824>>>>>>>            // different rules how long a table name can be.
77824>>>>>>>            // The new table will probably contain data but something went
77824>>>>>>>            // wrong while converting the data from embedded to SQL.
77824>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
77826>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
77827>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
77828>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
77829>>>>>>>>
77829>>>>>>>            End
77829>>>>>>>>
77829>>>>>>>        End
77829>>>>>>>>
77829>>>>>>>
77829>>>>>>>        // This must be after copying data...
77829>>>>>>>        If (Err = False) Begin
77831>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
77834>>>>>>>            // It seems the Studio does not do this any more, so commented out.
77834>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
77834>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
77834>>>>>>>            //                // The max length for the display_name is 31 characters...
77834>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
77834>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
77834>>>>>>>            //                End
77834>>>>>>>            //            End
77834>>>>>>>        End
77834>>>>>>>>
77834>>>>>>>
77834>>>>>>>        Close hTable
77835>>>>>>>        Move (not(Err)) to bOK
77836>>>>>>>        Function_Return bOK
77837>>>>>>>    End_Function
77838>>>>>>>
77838>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
77838>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
77838>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
77838>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
77840>>>>>>>        Boolean bOpened bOK
77840>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
77840>>>>>>>        String sErrorFile sEmpty sPath
77840>>>>>>>
77840>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
77843>>>>>>>        Get AutoConnectionIDLogin to bOK
77844>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
77846>>>>>>>            Send IncreaseSortBufferSize
77847>>>>>>>//            Send SetAllIndexesToBatch hToTable
77847>>>>>>>        End
77847>>>>>>>>
77847>>>>>>>
77847>>>>>>>        Move False to Err
77848>>>>>>>        Open sPhysicalName as hToTable
77850>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
77853>>>>>>>        If (bOpened = False) Begin
77855>>>>>>>            Function_Return False
77856>>>>>>>        End
77856>>>>>>>>
77856>>>>>>>
77856>>>>>>>        If (ghoStatusPanel <> 0) Begin
77858>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
77859>>>>>>>            Set piMinimum of ghoProgressBar to 0
77860>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
77861>>>>>>>        End
77861>>>>>>>>
77861>>>>>>>
77861>>>>>>>        Move "" to sEmpty
77862>>>>>>>        Move False to Err
77863>>>>>>>        Move True to bOK
77864>>>>>>>        Set Private.phCurrentTable to hToTable
77865>>>>>>>
77865>>>>>>>        // No need to get the record identifier
77865>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
77868>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
77871>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
77873>>>>>>>            // Remove all indices to speed up copying of data:
77873>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
77878>>>>>>>            If (iRetval <> 0) Begin       
77880>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
77881>>>>>>>>
77881>>>>>>>                Close hToTable
77882>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
77885>>>>>>>                Function_Return False
77886>>>>>>>            End
77886>>>>>>>>
77886>>>>>>>        End
77886>>>>>>>>
77886>>>>>>>
77886>>>>>>>        Move (sRootName + ".err") to sErrorFile
77887>>>>>>>        Move 0 to iIndex
77888>>>>>>>        Move False to Err
77889>>>>>>>
77889>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77891>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
77894>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
77899>>>>>>>            If (iRetval <> 0) Begin
77901>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
77902>>>>>>>>
77902>>>>>>>                Close hToTable
77903>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
77906>>>>>>>                Function_Return False
77907>>>>>>>            End
77907>>>>>>>>
77907>>>>>>>        End
77907>>>>>>>>
77907>>>>>>>        Else Begin
77908>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
77911>>>>>>>        End
77911>>>>>>>>
77911>>>>>>>
77911>>>>>>>        If (Err = False) Begin
77913>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
77914>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
77915>>>>>>>        End
77915>>>>>>>>
77915>>>>>>>
77915>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
77917>>>>>>>            // Recreate indices:
77917>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
77922>>>>>>>            If (iRetval <> 0) Begin
77924>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
77925>>>>>>>>
77925>>>>>>>                Close hToTable
77926>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
77929>>>>>>>                Function_Return False
77930>>>>>>>            End
77930>>>>>>>>
77930>>>>>>>        End
77930>>>>>>>>
77930>>>>>>>
77930>>>>>>>        Close hToTable
77931>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
77934>>>>>>>
77934>>>>>>>        If (bOK = True) Begin
77936>>>>>>>            Move (not(Err)) to bOK
77937>>>>>>>        End
77937>>>>>>>>
77937>>>>>>>
77937>>>>>>>        If (ghoStatusPanel <> 0) Begin
77939>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
77940>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
77941>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
77942>>>>>>>        End
77942>>>>>>>>
77942>>>>>>>
77942>>>>>>>        Function_Return (bOK = True)
77943>>>>>>>    End_Function
77944>>>>>>>
77944>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
77944>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
77944>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
77946>>>>>>>        Handle hFile
77946>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
77946>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
77946>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
77946>>>>>>>        tSQLConnection SQLConnection
77946>>>>>>>        tSQLConnection SQLConnection
77946>>>>>>>        tAPIColumn[] aColumns
77946>>>>>>>        tAPIColumn[] aColumns
77947>>>>>>>        tColumnType ColumnType
77947>>>>>>>        tColumnType ColumnType
77947>>>>>>>
77947>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
77947>>>>>>>        Get UtilTableExists hTable to bOk
77948>>>>>>>        If (bOk = True) Begin
77950>>>>>>>            Function_Return False
77951>>>>>>>        End
77951>>>>>>>>
77951>>>>>>>
77951>>>>>>>        Set Private.phCurrentTable to hTable
77952>>>>>>>        Move sLogicalName to sTableName
77953>>>>>>>        If (ghoProgressBar <> 0) Begin
77955>>>>>>>            Send DoAdvance of ghoProgressBar
77956>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
77957>>>>>>>        End
77957>>>>>>>>
77957>>>>>>>
77957>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
77958>>>>>>>        Get psDriverID to sDriverID
77959>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
77960>>>>>>>        Get piDbType to iDbType
77961>>>>>>>
77961>>>>>>>        // If no columns passed in, we need to create a "dummy" column
77961>>>>>>>        Move False to bDeleteDummy
77962>>>>>>>        If (Num_Arguments = 8) Begin
77964>>>>>>>            Move aColumnIn to aColumns
77965>>>>>>>        End
77965>>>>>>>>
77965>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
77967>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
77968>>>>>>>            Move ColumnType.iSQLType to iDataType
77969>>>>>>>            If (bRecnum = False) Begin
77971>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
77972>>>>>>>            End
77972>>>>>>>>
77972>>>>>>>            Else Begin
77973>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
77974>>>>>>>            End
77974>>>>>>>>
77974>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
77975>>>>>>>            Move True to bDeleteDummy
77976>>>>>>>        End
77976>>>>>>>>
77976>>>>>>>
77976>>>>>>>        // If columns have been passed as an array we need to check if an identity column
77976>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
77976>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
77976>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
77976>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
77978>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
77979>>>>>>>            Decrement iSize
77980>>>>>>>            for iCount from 0 to iSize
77986>>>>>>>>
77986>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
77988>>>>>>>                    Move False to bRecnum
77989>>>>>>>                    Move iSize to iCount
77990>>>>>>>                End
77990>>>>>>>>
77990>>>>>>>            Loop
77991>>>>>>>>
77991>>>>>>>        End
77991>>>>>>>>
77991>>>>>>>
77991>>>>>>>        // If this is a SQL based driver we also check if the table exists
77991>>>>>>>        // in the SQL back end; in case we do nothing.
77991>>>>>>>        If (bSqlDriver = True) Begin
77993>>>>>>>            // Get all connection properties
77993>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
77994>>>>>>>            Move SQLConnection.sSchema to sSchema
77995>>>>>>>            If (sSchema = "") Begin
77997>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
77998>>>>>>>            End
77998>>>>>>>>
77998>>>>>>>
77998>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
77999>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
77999>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
77999>>>>>>>            If (bExists = False) Begin
78001>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
78002>>>>>>>            End
78002>>>>>>>>
78002>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
78002>>>>>>>            // we will just add it to Filelist.cfg
78002>>>>>>>            If (bExists = True) Begin
78004>>>>>>>                If (bExistsInFilelist = False) Begin
78006>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
78008>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
78009>>>>>>>                    End
78009>>>>>>>>
78009>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
78012>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
78015>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
78018>>>>>>>                    Move False to bSysFile
78019>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
78020>>>>>>>                End
78020>>>>>>>>
78020>>>>>>>                Function_Return False
78021>>>>>>>            End
78021>>>>>>>>
78021>>>>>>>        End
78021>>>>>>>>
78021>>>>>>>
78021>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
78022>>>>>>>        If (num_arguments > 6) Begin
78024>>>>>>>            If (bANSI = False) Begin
78026>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
78027>>>>>>>            End
78027>>>>>>>>
78027>>>>>>>        End
78027>>>>>>>>
78027>>>>>>>
78027>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
78027>>>>>>>        // is a programmer's error and we auto-correct for it here.
78027>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
78027>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
78027>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
78027>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
78027>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
78028>>>>>>>        If (bMertechDriver = True) Begin
78030>>>>>>>            If (bUseConnectionID = True) Begin
78032>>>>>>>                Move False to bUseConnectionID
78033>>>>>>>            End
78033>>>>>>>>
78033>>>>>>>            Move sDriverID to sOriginalDriverID
78034>>>>>>>            Move DATAFLEX_ID to sDriverID
78035>>>>>>>        End
78035>>>>>>>>
78035>>>>>>>
78035>>>>>>>        Move False to Err
78036>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
78038>>>>>>>            Move sRootName to sPhysicalFile
78039>>>>>>>        End
78039>>>>>>>>
78039>>>>>>>
78039>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
78041>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
78042>>>>>>>
78042>>>>>>>            // If DAW driver and we should use a connection id we need to
78042>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
78042>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
78044>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
78045>>>>>>>                If (bExists = False) Begin
78047>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
78048>>>>>>>                    If (bOk = False) Begin
78050>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
78051>>>>>>>>
78051>>>>>>>                        Function_Return False
78052>>>>>>>                    End
78052>>>>>>>>
78052>>>>>>>                End
78052>>>>>>>>
78052>>>>>>>            End
78052>>>>>>>>
78052>>>>>>>
78052>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
78054>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
78055>>>>>>>            End
78055>>>>>>>>
78055>>>>>>>            Else Begin
78056>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
78057>>>>>>>            End
78057>>>>>>>>
78057>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
78058>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
78058>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
78058>>>>>>>//            End
78058>>>>>>>        End
78058>>>>>>>>
78058>>>>>>>        Move False to Err
78059>>>>>>>        Move 0 to hFile
78060>>>>>>>
78060>>>>>>>        Structure_Start hFile sDriverID
78061>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
78063>>>>>>>                If (bUseConnectionID = True) Begin
78065>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
78068>>>>>>>                End
78068>>>>>>>>
78068>>>>>>>                Else Begin
78069>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
78072>>>>>>>                End
78072>>>>>>>>
78072>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
78075>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
78078>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
78081>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
78084>>>>>>>
78084>>>>>>>                If (sSchema <> "") Begin
78086>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
78089>>>>>>>                End
78089>>>>>>>>
78089>>>>>>>
78089>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
78091>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
78093>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
78096>>>>>>>                    End
78096>>>>>>>>
78096>>>>>>>                End
78096>>>>>>>>
78096>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
78098>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
78100>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
78103>>>>>>>                    End
78103>>>>>>>>
78103>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
78105>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
78108>>>>>>>                    End
78108>>>>>>>>
78108>>>>>>>                End
78108>>>>>>>>
78108>>>>>>>            End
78108>>>>>>>>
78108>>>>>>>
78108>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
78111>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
78112>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78113>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78115>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78116>>>>>>>
78116>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
78116>>>>>>>        If (bMertechDriver = True) Begin
78118>>>>>>>            Move sOriginalDriverID to sDriverID
78119>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
78121>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
78122>>>>>>>            End
78122>>>>>>>>
78122>>>>>>>            // Note: This function also sets the Err flag.
78122>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
78122>>>>>>>        End
78122>>>>>>>>
78122>>>>>>>
78122>>>>>>>        Move (not(Err)) to bOK
78123>>>>>>>        If (bOk = True) Begin
78125>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
78127>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
78128>>>>>>>            End
78128>>>>>>>>
78128>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
78131>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
78134>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
78137>>>>>>>
78137>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
78137>>>>>>>            If (bDeleteDummy) Begin
78139>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
78140>>>>>>>            End
78140>>>>>>>>
78140>>>>>>>        End
78140>>>>>>>>
78140>>>>>>>
78140>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
78141>>>>>>>        Close hTable
78142>>>>>>>        Function_Return (bOK = True)
78143>>>>>>>    End_Function
78144>>>>>>>
78144>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
78146>>>>>>>        Move False to Err
78147>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
78150>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
78153>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
78156>>>>>>>
78156>>>>>>>        Function_Return (Err = False)
78157>>>>>>>    End_Function
78158>>>>>>>
78158>>>>>>>    // ToDo: Needs to be revised
78158>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
78160>>>>>>>        Handle hTable
78160>>>>>>>        String sDEFName sDataPath
78160>>>>>>>        Boolean bExists
78160>>>>>>>
78160>>>>>>>        // Do nothing if MSSQL Driver.
78160>>>>>>>//        Get IsMSSQLDriver to bExists
78160>>>>>>>//        If (bExists = True) Begin
78160>>>>>>>//            Procedure_Return
78160>>>>>>>//        End
78160>>>>>>>
78160>>>>>>>        Get psDataPathFirstPart to sDataPath
78161>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
78162>>>>>>>        If (bExists = True) Begin
78164>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
78164>>>>>>>            // still be missing from the filelist and needs to be added.
78164>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
78165>>>>>>>            If (bExists = True) Begin
78167>>>>>>>                Procedure_Return
78168>>>>>>>            End
78168>>>>>>>>
78168>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
78168>>>>>>>            Else Begin
78169>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
78172>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
78175>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
78178>>>>>>>                Procedure_Return
78179>>>>>>>            End
78179>>>>>>>>
78179>>>>>>>        End
78179>>>>>>>>
78179>>>>>>>
78179>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
78180>>>>>>>        Move 0 to hTable
78181>>>>>>>        Move False to Err
78182>>>>>>>
78182>>>>>>>        Structure_Start hTable DATAFLEX_ID
78183>>>>>>>            Load_Def sDEFName Onto hTable
78184>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
78187>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78188>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78190>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78191>>>>>>>
78191>>>>>>>        Move iFilelistSlot to hTable
78192>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
78195>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
78198>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
78201>>>>>>>
78201>>>>>>>    End_Procedure
78202>>>>>>>
78202>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
78204>>>>>>>        Boolean bTmp bErr bOK
78204>>>>>>>        String sTableName sDisplayName sFileName
78204>>>>>>>
78204>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
78204>>>>>>>        Move Err to bTmp
78205>>>>>>>        Move False to Err
78206>>>>>>>
78206>>>>>>>        Get AutoConnectionIDLogin to bOK
78207>>>>>>>        // First get the info for the current filelist slot:
78207>>>>>>>        Open iFromFileSlot
78209>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
78212>>>>>>>        If (bOK = True) Begin
78214>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
78217>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
78220>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
78223>>>>>>>
78223>>>>>>>            //...then move it.
78223>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
78226>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
78229>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
78232>>>>>>>
78232>>>>>>>            //...and finally remove the old filelist values.
78232>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
78235>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
78238>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
78241>>>>>>>        End
78241>>>>>>>>
78241>>>>>>>        Close iFromFileSlot
78242>>>>>>>
78242>>>>>>>        Move Err to bErr
78243>>>>>>>        Move bTmp to Err
78244>>>>>>>        Function_Return (bErr = False)
78245>>>>>>>    End_Function
78246>>>>>>>
78246>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
78248>>>>>>>        Handle hTable
78248>>>>>>>        Boolean bOK
78248>>>>>>>        String sDriverID
78248>>>>>>>
78248>>>>>>>        Get UtilTableExists hTableFrom to bOK
78249>>>>>>>        If (bOK = False) Begin
78251>>>>>>>            Set Private.phCurrentTable to hTableFrom
78252>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
78253>>>>>>>>
78253>>>>>>>            Function_Return False
78254>>>>>>>        End
78254>>>>>>>>
78254>>>>>>>
78254>>>>>>>        Get UtilTableExists hTableTo to bOK
78255>>>>>>>        If (bOK = False) Begin
78257>>>>>>>            Set Private.phCurrentTable to hTableTo
78258>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
78259>>>>>>>>
78259>>>>>>>            Function_Return False
78260>>>>>>>        End
78260>>>>>>>>
78260>>>>>>>
78260>>>>>>>        Get AutoConnectionIDLogin to bOK
78261>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
78262>>>>>>>        If (bOK = False) Begin
78264>>>>>>>            Function_Return False
78265>>>>>>>        End
78265>>>>>>>>
78265>>>>>>>
78265>>>>>>>        Move False to Err
78266>>>>>>>        Open hTableTo
78268>>>>>>>
78268>>>>>>>        Move hTableFrom to hTable
78269>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
78272>>>>>>>        Set Private.phCurrentTable to hTable
78273>>>>>>>
78273>>>>>>>        Structure_Start hTable sDriverID
78274>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
78277>>>>>>>            If (iColumnTo <> 0) Begin
78279>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
78282>>>>>>>            End
78282>>>>>>>>
78282>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78283>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78285>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78286>>>>>>>
78286>>>>>>>        If (hTableTo > 0) Begin
78288>>>>>>>            Close hTableTo
78289>>>>>>>        End
78289>>>>>>>>
78289>>>>>>>
78289>>>>>>>        Function_Return (Err = False)
78290>>>>>>>    End_Function
78291>>>>>>>
78291>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
78291>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
78293>>>>>>>        String sTableName sDriverID
78293>>>>>>>        Boolean bOk
78293>>>>>>>        String sDataPath
78293>>>>>>>
78293>>>>>>>        Get AutoConnectionIDLogin to bOK
78294>>>>>>>        Move False to Err
78295>>>>>>>        Get psDriverID to sDriverID
78296>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
78297>>>>>>>        If (sTableName = "") Begin
78299>>>>>>>            Function_Return False
78300>>>>>>>        End
78300>>>>>>>>
78300>>>>>>>
78300>>>>>>>        Set Private.phCurrentTable to hTable
78301>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
78302>>>>>>>        Delete_db sTableName
78303>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
78304>>>>>>>
78304>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
78306>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
78306>>>>>>>            Get psDataPathFirstPart to sDataPath
78307>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
78308>>>>>>>        End
78308>>>>>>>>
78308>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
78308>>>>>>>        If (hTable <> 0) Begin
78310>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
78313>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
78316>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
78319>>>>>>>        End
78319>>>>>>>>
78319>>>>>>>
78319>>>>>>>        Close hTable
78320>>>>>>>        Function_Return (hTable <> 0)
78321>>>>>>>    End_Function
78322>>>>>>>
78322>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
78324>>>>>>>        Handle hTable
78324>>>>>>>        Boolean bOK
78324>>>>>>>
78324>>>>>>>        Get AutoConnectionIDLogin to bOK
78325>>>>>>>        Move False to Err
78326>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
78328>>>>>>>        Move hTableFrom to hTable
78329>>>>>>>
78329>>>>>>>        Structure_Start hTable
78330>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
78333>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78334>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78336>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78337>>>>>>>
78337>>>>>>>        Close hTableFrom
78338>>>>>>>        Function_Return (Err = False)
78339>>>>>>>    End_Function
78340>>>>>>>
78340>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
78342>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
78342>>>>>>>        Boolean bOK bExists bOpened
78342>>>>>>>        tAPITableNameInfo APITableNameInfo
78342>>>>>>>        tAPITableNameInfo APITableNameInfo
78342>>>>>>>
78342>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
78345>>>>>>>        If (bOpened = False) Begin
78347>>>>>>>            Get OpenTableExclusive hTable to bOpened
78348>>>>>>>            If (bOpened = False) Begin
78350>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
78351>>>>>>>                Function_Return False
78352>>>>>>>            End
78352>>>>>>>>
78352>>>>>>>        End
78352>>>>>>>>
78352>>>>>>>
78352>>>>>>>        Set Private.phCurrentTable to hTable
78353>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
78354>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
78355>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
78356>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
78357>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
78358>>>>>>>        If (bExists = True) Begin
78360>>>>>>>            Function_Return True
78361>>>>>>>        End
78361>>>>>>>>
78361>>>>>>>
78361>>>>>>>        Set Private.phCurrentTable to hTable
78362>>>>>>>        Move False to Err
78363>>>>>>>        Get psDataPathFirstPart to sDataPath
78364>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
78367>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
78370>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
78373>>>>>>>
78373>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
78376>>>>>>>        Close hTable
78377>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
78379>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
78380>>>>>>>            If (bExists = True) Begin
78382>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
78384>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
78387>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
78387>>>>>>>                    // might report "File in use..." and the deletion will fail.
78387>>>>>>>                    Sleep 2
78388>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
78389>>>>>>>                End
78389>>>>>>>>
78389>>>>>>>            End
78389>>>>>>>>
78389>>>>>>>        End
78389>>>>>>>>
78389>>>>>>>
78389>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
78391>>>>>>>            If (not(sPhysicalName contains ".")) Begin
78393>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
78394>>>>>>>            End
78394>>>>>>>>
78394>>>>>>>
78394>>>>>>>            // Change the table name in the .int file to the new table new:
78394>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
78395>>>>>>>            If (bOK = False) Begin
78397>>>>>>>                Function_Return False
78398>>>>>>>            End
78398>>>>>>>>
78398>>>>>>>
78398>>>>>>>            // Change table name at the SQL side:
78398>>>>>>>            Get psSchema to sSchema
78399>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
78400>>>>>>>
78400>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
78401>>>>>>>            // Remove cache file and Rename the physical file names:
78401>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
78402>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
78403>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
78404>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
78405>>>>>>>
78405>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
78405>>>>>>>//            If (not(sDisplayName contains ".")) Begin
78405>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
78405>>>>>>>//            End
78405>>>>>>>        End
78405>>>>>>>>
78405>>>>>>>
78405>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
78408>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
78411>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
78414>>>>>>>
78414>>>>>>>        Function_Return (Err = False)
78415>>>>>>>    End_Function
78416>>>>>>>
78416>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
78418>>>>>>>        Move False to Err
78419>>>>>>>        Set Private.phCurrentTable to hTable
78420>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
78423>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
78426>>>>>>>
78426>>>>>>>        Function_Return (Err = False)
78427>>>>>>>    End_Function
78428>>>>>>>
78428>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
78428>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
78428>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
78430>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
78430>>>>>>>        Handle hTable
78430>>>>>>>        Boolean bIsSame
78430>>>>>>>
78430>>>>>>>        Move APITableInfo.iTableNumber      to hTable
78431>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
78432>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
78435>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
78436>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
78439>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
78442>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
78443>>>>>>>
78443>>>>>>>        If (bCompareFilelistUppercase = True) Begin
78445>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
78446>>>>>>>        End
78446>>>>>>>>
78446>>>>>>>        Else Begin
78447>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
78448>>>>>>>        End
78448>>>>>>>>
78448>>>>>>>
78448>>>>>>>        Function_Return bIsSame
78449>>>>>>>    End_Function
78450>>>>>>>
78450>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
78450>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
78452>>>>>>>        Handle hTable
78452>>>>>>>        String sTableName
78452>>>>>>>        String sDriverIDFrom sDriverIDTo
78452>>>>>>>        Integer iDbType
78452>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
78452>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
78452>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
78452>>>>>>>        tSQLConnection SQLConnection
78452>>>>>>>        tSQLConnection SQLConnection
78452>>>>>>>        tAPITable      APITableFrom APITableTo
78452>>>>>>>        tAPITable      APITableFrom APITableTo
78452>>>>>>>        tColumnType    ColumnType
78452>>>>>>>        tColumnType    ColumnType
78452>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
78452>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
78453>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
78453>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
78454>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
78454>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
78455>>>>>>>
78455>>>>>>>        // We don't allow changes to the framework's DbVersion table.
78455>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
78457>>>>>>>            Function_Return False
78458>>>>>>>        End
78458>>>>>>>>
78458>>>>>>>
78458>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
78459>>>>>>>        Get piDbType                            to iDbType
78460>>>>>>>        Get pbRecnum                            to bRecnum
78461>>>>>>>        Get pbToANSI                            to bToANSI
78462>>>>>>>        Get pbCopyData                          to bCopyData
78463>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
78464>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
78465>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
78466>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
78467>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
78468>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
78469>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
78471>>>>>>>            Move False                          to bUseConnectionID
78472>>>>>>>        End
78472>>>>>>>>
78472>>>>>>>
78472>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
78473>>>>>>>        Set Private.phCurrentTable              to hTable
78474>>>>>>>        Get UtilTableExists  hTable             to bTableExists
78475>>>>>>>
78475>>>>>>>        If (ghoProgressBar <> 0) Begin
78477>>>>>>>            Send DoAdvance of ghoProgressBar
78478>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
78479>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
78480>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
78481>>>>>>>        End
78481>>>>>>>>
78481>>>>>>>
78481>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
78482>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
78483>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
78484>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
78485>>>>>>>        Move True                               to APITableFrom.bFromTable
78486>>>>>>>        Move hTable                             to APITableFrom.hTable
78487>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
78488>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
78489>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
78490>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
78491>>>>>>>
78491>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
78493>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
78494>>>>>>>            If (bOk = True) Begin
78496>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
78497>>>>>>>                Function_Return bOk
78498>>>>>>>            End 
78498>>>>>>>>
78498>>>>>>>        End
78498>>>>>>>>
78498>>>>>>>
78498>>>>>>>        If (bTableExists = True) Begin
78500>>>>>>>            If (bIsSQLTableTo = True) Begin
78502>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
78503>>>>>>>            End
78503>>>>>>>>
78503>>>>>>>
78503>>>>>>>            Get OpenTableExclusive hTable to bOpened
78504>>>>>>>            If (bOpened = False) Begin
78506>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
78507>>>>>>>                Function_Return False
78508>>>>>>>            End
78508>>>>>>>>
78508>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
78509>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
78510>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
78511>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
78512>>>>>>>        End
78512>>>>>>>>
78512>>>>>>>
78512>>>>>>>        Move False to Err
78513>>>>>>>        Case Begin
78513>>>>>>>            // Alias table:
78513>>>>>>>            Case (bIsAliasFrom = True)
78515>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
78516>>>>>>>                Case Break
78517>>>>>>>
78517>>>>>>>            // New Table:
78517>>>>>>>            Case (bTableExists = False)
78520>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
78521>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
78521>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
78523>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
78524>>>>>>>                End                                                                 
78524>>>>>>>>
78524>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
78525>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
78526>>>>>>>                Case Break
78527>>>>>>>
78527>>>>>>>            // Update table:
78527>>>>>>>            Case (bTableExists = True)
78530>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
78531>>>>>>>                If (bIsSame = True) Begin
78533>>>>>>>                    Case Break
78534>>>>>>>                End
78534>>>>>>>>
78534>>>>>>>                If (bFilelistError = True) Begin
78536>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
78537>>>>>>>                    If (bOk = False) Begin
78539>>>>>>>                        Case Break
78540>>>>>>>                    End
78540>>>>>>>>
78540>>>>>>>                End
78540>>>>>>>>
78540>>>>>>>
78540>>>>>>>                If (ghoProgressBar <> 0) Begin
78542>>>>>>>                    Send DoAdvance of ghoProgressBar
78543>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
78544>>>>>>>                End
78544>>>>>>>>
78544>>>>>>>
78544>>>>>>>                // Columns:
78544>>>>>>>                Move True to bOk
78545>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
78546>>>>>>>                If (bIsSame = False) Begin
78548>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
78549>>>>>>>                End
78549>>>>>>>>
78549>>>>>>>                If (bOk = False) Begin
78551>>>>>>>                    Case Break
78552>>>>>>>                End
78552>>>>>>>>
78552>>>>>>>
78552>>>>>>>                // Indexes:
78552>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
78553>>>>>>>                If (bIsSame = False) Begin
78555>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
78556>>>>>>>                End
78556>>>>>>>>
78556>>>>>>>
78556>>>>>>>                // Relations:
78556>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
78557>>>>>>>                If (bIsSame = False) Begin
78559>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
78560>>>>>>>                    If (bOk = False) Begin
78562>>>>>>>                        Case Break
78563>>>>>>>                    End
78563>>>>>>>>
78563>>>>>>>                End
78563>>>>>>>>
78563>>>>>>>
78563>>>>>>>                Case Break
78564>>>>>>>
78564>>>>>>>            Case Else
78564>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
78565>>>>>>>>
78565>>>>>>>                Move False to bOk
78566>>>>>>>        Case End
78566>>>>>>>        
78566>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
78566>>>>>>>        // or convert an embedded table to SQL
78566>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
78568>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
78569>>>>>>>            If (bOk = False) Begin
78571>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
78572>>>>>>>            End
78572>>>>>>>>
78572>>>>>>>        End
78572>>>>>>>>
78572>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
78575>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
78576>>>>>>>        End
78576>>>>>>>>
78576>>>>>>>        
78576>>>>>>>        // Filelist Names:
78576>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
78577>>>>>>>        Close hTable
78578>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
78579>>>>>>>
78579>>>>>>>        Function_Return (bOK = True)
78580>>>>>>>    End_Function
78581>>>>>>>
78581>>>>>>>    // * Dummy function for the Studio's Code Explorer *
78581>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
78583>>>>>>>        Function_Return False
78584>>>>>>>    End_Function
78585>>>>>>>
78585>>>>>>>    // Adds a column name to the passed table number.
78585>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
78587>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
78587>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
78587>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
78587>>>>>>>
78587>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
78588>>>>>>>        If (bExists = True) Begin
78590>>>>>>>            Function_Return False
78591>>>>>>>        End
78591>>>>>>>>
78591>>>>>>>
78591>>>>>>>        Move False to Err
78592>>>>>>>        If (num_arguments > 4) Begin
78594>>>>>>>            Move iPrec to iPrecision
78595>>>>>>>        End
78595>>>>>>>>
78595>>>>>>>        If (num_arguments > 6) Begin
78597>>>>>>>            Move bInitVal to bInitializeValue
78598>>>>>>>            Move sColVal  to sColumnValue
78599>>>>>>>        End
78599>>>>>>>>
78599>>>>>>>        If (iType < -1490) Begin
78601>>>>>>>            Move (iType + 1500) to iType
78602>>>>>>>        End
78602>>>>>>>>
78602>>>>>>>
78602>>>>>>>        Move hTable to iFile
78603>>>>>>>        Get psDriverID to sDriverID
78604>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
78605>>>>>>>        Get AutoConnectionIDLogin to bOK
78606>>>>>>>        Move False to Err
78607>>>>>>>        Move LastErr to iLastErr
78608>>>>>>>        Get OpenTableExclusive iFile to bOK
78609>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
78609>>>>>>>        Set Private.phCurrentTable to hTable
78610>>>>>>>        Structure_Start iFile sDriverID
78611>>>>>>>            Move 0 to iColumn
78612>>>>>>>            Set Private.piCurrentField to iColumn
78613>>>>>>>            Create_Field hTable At iColumn
78614>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
78617>>>>>>>            If (bMertechDriver = True) Begin
78619>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
78620>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
78621>>>>>>>            End
78621>>>>>>>>
78621>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
78624>>>>>>>            If (bMertechDriver = True) Begin
78626>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
78627>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
78628>>>>>>>                Move False to Err
78629>>>>>>>                Move iLastErr to LastErr
78630>>>>>>>            End
78630>>>>>>>>
78630>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
78633>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
78636>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78637>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78639>>>>>>>
78639>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78640>>>>>>>
78640>>>>>>>        // If in development environment; create .fd file:
78640>>>>>>>        Open hTable
78642>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
78643>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
78644>>>>>>>        If (iCount > 1) Begin
78646>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
78647>>>>>>>        End
78647>>>>>>>>
78647>>>>>>>        Get vFolderExists sDDSrcPath to bExists
78648>>>>>>>        If (bExists = True) Begin
78650>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
78651>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
78654>>>>>>>            Get _TableNameOnly sTableName to sTableName
78655>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
78657>>>>>>>        End
78657>>>>>>>>
78657>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
78659>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
78660>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
78661>>>>>>>            If (iCount > 1) Begin
78663>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
78664>>>>>>>            End
78664>>>>>>>>
78664>>>>>>>            Get vFolderFormat sDataPath to sDataPath
78665>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
78665>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
78665>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
78665>>>>>>>        End
78665>>>>>>>>
78665>>>>>>>        // Check for a default value
78665>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
78667>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
78668>>>>>>>        End
78668>>>>>>>>
78668>>>>>>>        Close hTable
78669>>>>>>>
78669>>>>>>>        Function_Return (Err = False)
78670>>>>>>>    End_Function
78671>>>>>>>
78671>>>>>>>    // Adds a column name to the passed table number.
78671>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
78673>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
78673>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
78673>>>>>>>        String sDdSrcPath sTableName
78673>>>>>>>
78673>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
78674>>>>>>>        Move False to Err
78675>>>>>>>        If (bExists = True) Begin
78677>>>>>>>            Function_Return False
78678>>>>>>>        End
78678>>>>>>>>
78678>>>>>>>        If (num_arguments > 4) Begin
78680>>>>>>>            Move iPrec to iPrecision
78681>>>>>>>        End
78681>>>>>>>>
78681>>>>>>>        If (iType < -1490) Begin
78683>>>>>>>            Move (iType + 1500) to iType
78684>>>>>>>        End
78684>>>>>>>>
78684>>>>>>>
78684>>>>>>>        Get AutoConnectionIDLogin to bOK
78685>>>>>>>        Move False to Err
78686>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
78687>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
78687>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
78687>>>>>>>        Get piDbType to iDbType
78688>>>>>>>        If (bIsSQLTypeTo = False) Begin
78690>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
78691>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
78693>>>>>>>                Move DF_DATE to iType
78694>>>>>>>            End
78694>>>>>>>>
78694>>>>>>>        End
78694>>>>>>>>
78694>>>>>>>
78694>>>>>>>        // Structure_start will change the value of hTable...
78694>>>>>>>        Move hTable to iFile
78695>>>>>>>        Get OpenTableExclusive iFile to bOK
78696>>>>>>>        If (bOK = False) Begin
78698>>>>>>>            Function_Return False
78699>>>>>>>        End
78699>>>>>>>>
78699>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
78702>>>>>>>
78702>>>>>>>        // If the passed column number is higher than the current number of fields
78702>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
78702>>>>>>>        // a new field to the end:
78702>>>>>>>        If (iColumn > iNumberOfFields) Begin
78704>>>>>>>            Move 0 to iColumn
78705>>>>>>>        End
78705>>>>>>>>
78705>>>>>>>
78705>>>>>>>        Set Private.phCurrentTable to hTable
78706>>>>>>>        Set Private.piCurrentField to iColumn
78707>>>>>>>
78707>>>>>>>        Structure_Start iFile
78708>>>>>>>            Create_Field iFile At iColumn
78709>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
78712>>>>>>>            If (bIsSQLTypeTo = False) Begin
78714>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
78717>>>>>>>            End
78717>>>>>>>>
78717>>>>>>>            Else Begin
78718>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
78721>>>>>>>            End
78721>>>>>>>>
78721>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
78722>>>>>>>            If (bIsDateType = False) Begin
78724>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
78727>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
78730>>>>>>>            End
78730>>>>>>>>
78730>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78731>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78733>>>>>>>
78733>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78734>>>>>>>        // If in development environment; create .fd file:
78734>>>>>>>        Open hTable
78736>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
78737>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
78738>>>>>>>        If (iCount > 1) Begin
78740>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
78741>>>>>>>        End
78741>>>>>>>>
78741>>>>>>>        Get vFolderExists sDDSrcPath to bExists
78742>>>>>>>        If (bExists = True) Begin
78744>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
78745>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
78748>>>>>>>            Get _TableNameOnly sTableName to sTableName
78749>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
78751>>>>>>>        End
78751>>>>>>>>
78751>>>>>>>
78751>>>>>>>        // Check for a default value
78751>>>>>>>        Close hTable
78752>>>>>>>
78752>>>>>>>        Function_Return (Err = False)
78753>>>>>>>    End_Function
78754>>>>>>>
78754>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
78754>>>>>>>//        Integer iColumn iCount iFile
78754>>>>>>>//        Boolean bExists bOK
78754>>>>>>>//        String sDdSrcPath sTableName
78754>>>>>>>//
78754>>>>>>>//        Get AutoConnectionIDLogin to bOK
78754>>>>>>>//        Move False to Err
78754>>>>>>>//
78754>>>>>>>//        // Structure_start will change the value of hTable...
78754>>>>>>>//        Move hTable to iFile
78754>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
78754>>>>>>>//
78754>>>>>>>//        Structure_Start iFile
78754>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
78754>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78754>>>>>>>//
78754>>>>>>>//        // If in development environment; create .fd file:
78754>>>>>>>//        Open hTable
78754>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
78754>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
78754>>>>>>>//        If (iCount > 1) Begin
78754>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
78754>>>>>>>//        End
78754>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
78754>>>>>>>//        If (bExists = True) Begin
78754>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
78754>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
78754>>>>>>>//            Get _TableNameOnly sTableName to sTableName
78754>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
78754>>>>>>>//        End
78754>>>>>>>//        Close hTable
78754>>>>>>>//
78754>>>>>>>//        Function_Return (Err = False)
78754>>>>>>>//    End_Function
78754>>>>>>>
78754>>>>>>>    // To update all records for a table column with a fixed value.
78754>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
78756>>>>>>>        Integer iRecs iCurrErr iField iRecord
78756>>>>>>>        Boolean bRetval bOpen
78756>>>>>>>
78756>>>>>>>        Move 0 to iRecs
78757>>>>>>>        Move False to bRetval
78758>>>>>>>        Move Err to iCurrErr
78759>>>>>>>        Move False to Err
78760>>>>>>>
78760>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
78763>>>>>>>        If (bOpen = False) Begin
78765>>>>>>>            Open hTable
78767>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
78770>>>>>>>            If (bOpen = False) Begin
78772>>>>>>>                Function_Return bRetval
78773>>>>>>>            End
78773>>>>>>>>
78773>>>>>>>        End
78773>>>>>>>>
78773>>>>>>>
78773>>>>>>>        Field_Map hTable sFieldName to iField
78775>>>>>>>        If (iField <> 0) Begin
78777>>>>>>>            Set Private.phCurrentTable to hTable
78778>>>>>>>            Set Private.piCurrentField to iField
78779>>>>>>>            Clear hTable
78780>>>>>>>            Repeat
78780>>>>>>>>
78780>>>>>>>                Vfind hTable 0 GT
78782>>>>>>>                If (Found) Begin
78784>>>>>>>                    If (ghoStatusPanel <> 0) Begin
78786>>>>>>>                        Get_Field_Value hTable 0 to iRecord
78789>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
78790>>>>>>>                    End
78790>>>>>>>>
78790>>>>>>>                    Reread hTable
78794>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
78797>>>>>>>                        SaveRecord hTable
78798>>>>>>>                    Unlock
78799>>>>>>>>
78799>>>>>>>                End
78799>>>>>>>>
78799>>>>>>>           Until (not(Found))
78801>>>>>>>        End
78801>>>>>>>>
78801>>>>>>>
78801>>>>>>>        Move (Err = False) to bRetval
78802>>>>>>>        Move iCurrErr to Err
78803>>>>>>>
78803>>>>>>>        Function_Return bRetval
78804>>>>>>>    End_Function
78805>>>>>>>
78805>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
78805>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
78807>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
78807>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
78807>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
78807>>>>>>>
78807>>>>>>>//        Set Private.phCurrentTable to hTable
78807>>>>>>>        Get psDriverID to sDriverID
78808>>>>>>>        Get piDbType to iDbType
78809>>>>>>>        Get UtilTableHandleToString hTable to sTableName
78810>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
78811>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
78812>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
78813>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
78815>>>>>>>            Move True to bIsSqlTable
78816>>>>>>>        End
78816>>>>>>>>
78816>>>>>>>        Move False to bIsOpen
78817>>>>>>>        If (hTable > 0) Begin
78819>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
78822>>>>>>>        End
78822>>>>>>>>
78822>>>>>>>        If (bIsOpen = True) Begin
78824>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
78827>>>>>>>        End
78827>>>>>>>>
78827>>>>>>>        Else Begin
78828>>>>>>>            Get pbRecnum to bRecnumTable
78829>>>>>>>        End
78829>>>>>>>>
78829>>>>>>>
78829>>>>>>>        Move False to Err
78830>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
78831>>>>>>>        Decrement iSize
78832>>>>>>>        for iCount from 0 to iSize
78838>>>>>>>>
78838>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
78839>>>>>>>            If (hTable > 0) Begin
78841>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
78842>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
78843>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
78846>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
78847>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
78848>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
78849>>>>>>>            End
78849>>>>>>>>
78849>>>>>>>            Else Begin
78850>>>>>>>                Move False to bFieldExists
78851>>>>>>>            End
78851>>>>>>>>
78851>>>>>>>
78851>>>>>>>            If (bFieldExists = False) Begin
78853>>>>>>>                Move 0 to iColumn
78854>>>>>>>                Create_Field hTable At iColumn
78855>>>>>>>            End
78855>>>>>>>>
78855>>>>>>>            Else Begin
78856>>>>>>>                Move iCount to iColumn
78857>>>>>>>            End
78857>>>>>>>>
78857>>>>>>>
78857>>>>>>>            Set Private.piCurrentField to iColumn
78858>>>>>>>
78858>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
78859>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
78862>>>>>>>
78862>>>>>>>            Move aColumns[iCount].iType to iType
78863>>>>>>>            Move (not(iType < -1490)) to bNativeType
78864>>>>>>>            If (iType < -1490) Begin
78866>>>>>>>                Move (iType + 1500) to iType
78867>>>>>>>            End
78867>>>>>>>>
78867>>>>>>>
78867>>>>>>>            If (bIsSqlTable = True) Begin
78869>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
78871>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
78872>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
78875>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
78878>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
78881>>>>>>>
78881>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
78882>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
78884>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
78885>>>>>>>                    End
78885>>>>>>>>
78885>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
78888>>>>>>>
78888>>>>>>>                End
78888>>>>>>>>
78888>>>>>>>                Else Begin
78889>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
78892>>>>>>>                End
78892>>>>>>>>
78892>>>>>>>            End
78892>>>>>>>>
78892>>>>>>>            Else Begin
78893>>>>>>>                If (bCreating = False) Begin
78895>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
78896>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
78898>>>>>>>                        Move DF_DATE to iType
78899>>>>>>>                    End
78899>>>>>>>>
78899>>>>>>>                End
78899>>>>>>>>
78899>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
78902>>>>>>>            End
78902>>>>>>>>
78902>>>>>>>
78902>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
78903>>>>>>>            If (bIsDateType = False) Begin
78905>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
78908>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
78911>>>>>>>            End
78911>>>>>>>>
78911>>>>>>>
78911>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
78913>>>>>>>                Move 0 to iIndex
78914>>>>>>>                Create_Index hTable at iIndex
78915>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
78918>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
78921>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
78924>>>>>>>
78924>>>>>>>                // If we have an identity table - we must create a primary_key table.
78924>>>>>>>                If (bIsSqlTable = True) Begin
78926>>>>>>>                End
78926>>>>>>>>
78926>>>>>>>            End
78926>>>>>>>>
78926>>>>>>>        Loop
78927>>>>>>>>
78927>>>>>>>
78927>>>>>>>        Function_Return (Err = False)
78928>>>>>>>    End_Function
78929>>>>>>>
78929>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
78929>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
78931>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
78931>>>>>>>        Boolean bOK bIsSqlTable
78931>>>>>>>        String sFieldNameTo
78931>>>>>>>
78931>>>>>>>        If (num_arguments > 4) Begin
78933>>>>>>>            Move iPrec to iPrecFrom
78934>>>>>>>        End
78934>>>>>>>>
78934>>>>>>>        If (iTypeFrom < -1490) Begin
78936>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
78937>>>>>>>        End
78937>>>>>>>>
78937>>>>>>>
78937>>>>>>>        Get AutoConnectionIDLogin to bOK
78938>>>>>>>        Move False to Err
78939>>>>>>>        Get OpenTableExclusive hTable to bOK
78940>>>>>>>        If (bOK = False) Begin
78942>>>>>>>            Function_Return False
78943>>>>>>>        End
78943>>>>>>>>
78943>>>>>>>
78943>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
78944>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
78945>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
78947>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
78948>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
78949>>>>>>>        If (Err = True) Begin
78951>>>>>>>            Function_Return False
78952>>>>>>>        End
78952>>>>>>>>
78952>>>>>>>
78952>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
78955>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
78956>>>>>>>        If (bIsSqlTable = False) Begin
78958>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
78961>>>>>>>        End
78961>>>>>>>>
78961>>>>>>>        Else Begin
78962>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
78965>>>>>>>        End
78965>>>>>>>>
78965>>>>>>>        // Let the driver decide the other values;
78965>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
78968>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
78971>>>>>>>
78971>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
78973>>>>>>>            Function_Return False
78974>>>>>>>        End
78974>>>>>>>>
78974>>>>>>>
78974>>>>>>>        Set Private.phCurrentTable to hTable
78975>>>>>>>        Set Private.piCurrentField to iColumn
78976>>>>>>>
78976>>>>>>>        Structure_Start hTable
78977>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
78980>>>>>>>//            If (bIsSqlTable = False) Begin
78980>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
78983>>>>>>>//            End
78983>>>>>>>//            Else Begin
78983>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
78983>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
78983>>>>>>>//            End
78983>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
78986>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
78989>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
78990>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
78992>>>>>>>
78992>>>>>>>        Set Action_Text of ghoStatusPanel to ""
78993>>>>>>>        Function_Return (Err = False)
78994>>>>>>>    End_Function
78995>>>>>>>
78995>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
78995>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
78997>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
78997>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
78997>>>>>>>        String sFieldNameTo sDriverIDTo
78997>>>>>>>        tColumnType ColumnType
78997>>>>>>>        tColumnType ColumnType
78997>>>>>>>
78997>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
78998>>>>>>>        Get piDbType to iDbType
78999>>>>>>>        If (num_arguments > 4) Begin
79001>>>>>>>            Move iPrec to iPrecFrom
79002>>>>>>>            Move iOpt  to iOptionFrom
79003>>>>>>>        End
79003>>>>>>>>
79003>>>>>>>        If (iTypeFrom < -1490) Begin
79005>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
79006>>>>>>>        End
79006>>>>>>>>
79006>>>>>>>
79006>>>>>>>        Get AutoConnectionIDLogin to bOK
79007>>>>>>>        Move False to Err
79008>>>>>>>        Close hTable
79009>>>>>>>        Get OpenTableExclusive hTable to bOK
79010>>>>>>>        If (bOK = False) Begin
79012>>>>>>>            Function_Return False
79013>>>>>>>        End
79013>>>>>>>>
79013>>>>>>>
79013>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
79016>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
79019>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
79020>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
79022>>>>>>>            Move DF_DATE to iDataFlexType
79023>>>>>>>        End
79023>>>>>>>>
79023>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
79026>>>>>>>
79026>>>>>>>        If (bIsSQLTableTo = True) Begin
79028>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
79031>>>>>>>        End
79031>>>>>>>>
79031>>>>>>>        Else Begin
79032>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
79035>>>>>>>        End
79035>>>>>>>>
79035>>>>>>>
79035>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
79038>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
79041>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
79044>>>>>>>
79044>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
79044>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
79044>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
79046>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
79047>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
79049>>>>>>>                Move DF_DATE to iTypeTo  
79050>>>>>>>            End
79050>>>>>>>>
79050>>>>>>>        End
79050>>>>>>>>
79050>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
79053>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
79054>>>>>>>        End
79054>>>>>>>>
79054>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
79055>>>>>>>
79055>>>>>>>        If (bCompareDate_DateTime = False) Begin
79057>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
79058>>>>>>>            If (bSkip = True) Begin
79060>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
79062>>>>>>>                    Function_Return True
79063>>>>>>>                End
79063>>>>>>>>
79063>>>>>>>            End
79063>>>>>>>>
79063>>>>>>>        End
79063>>>>>>>>
79063>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
79066>>>>>>>            Function_Return True
79067>>>>>>>        End
79067>>>>>>>>
79067>>>>>>>
79067>>>>>>>        Set Private.phCurrentTable to hTable
79068>>>>>>>        Set Private.piCurrentField to iColumn
79069>>>>>>>
79069>>>>>>>        Structure_Start hTable
79070>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
79072>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
79075>>>>>>>            End
79075>>>>>>>>
79075>>>>>>>
79075>>>>>>>            If (bIsSameDataType = False) Begin
79077>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
79080>>>>>>>                If (bIsSQLTableTo = True) Begin
79082>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
79085>>>>>>>                End
79085>>>>>>>>
79085>>>>>>>            End
79085>>>>>>>>
79085>>>>>>>
79085>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
79087>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
79090>>>>>>>            End
79090>>>>>>>>
79090>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
79092>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
79095>>>>>>>            End
79095>>>>>>>>
79095>>>>>>>
79095>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
79097>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
79097>>>>>>>                If (bRecnumTable = True) Begin
79099>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
79102>>>>>>>                End
79102>>>>>>>>
79102>>>>>>>
79102>>>>>>>                // We might need to create an index here.
79102>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
79102>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
79102>>>>>>>                // index update checking logic.
79102>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
79105>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
79107>>>>>>>                    Create_Index hTable At iIndex
79108>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
79111>>>>>>>                End
79111>>>>>>>>
79111>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
79114>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
79117>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
79120>>>>>>>                If (bIsSQLTableTo = True) Begin
79122>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
79125>>>>>>>                End
79125>>>>>>>>
79125>>>>>>>            End
79125>>>>>>>>
79125>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79126>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79128>>>>>>>
79128>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79129>>>>>>>        Function_Return (Err = False)
79130>>>>>>>    End_Function
79131>>>>>>>
79131>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
79133>>>>>>>        Boolean bOK
79133>>>>>>>
79133>>>>>>>        Get AutoConnectionIDLogin to bOK
79134>>>>>>>        Move False to Err
79135>>>>>>>        Get OpenTableExclusive hTable to bOK
79136>>>>>>>        If (bOK = False) Begin
79138>>>>>>>            Function_Return False
79139>>>>>>>        End
79139>>>>>>>>
79139>>>>>>>
79139>>>>>>>        Structure_Start hTable
79140>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
79143>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79144>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79146>>>>>>>
79146>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79147>>>>>>>        Function_Return (Err = False)
79148>>>>>>>    End_Function
79149>>>>>>>
79149>>>>>>>    // To move an existing field to another position in a table.
79149>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
79151>>>>>>>        String sColumn sDriverID
79151>>>>>>>        Integer iType
79151>>>>>>>        Boolean bOK bIsDate
79151>>>>>>>
79151>>>>>>>        Close hTable
79152>>>>>>>        Get AutoConnectionIDLogin to bOK
79153>>>>>>>        Get OpenTableExclusive hTable to bOK
79154>>>>>>>        If (bOK = False) Begin
79156>>>>>>>            Function_Return False
79157>>>>>>>        End
79157>>>>>>>>
79157>>>>>>>
79157>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
79160>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
79162>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
79163>>>>>>>>
79163>>>>>>>            Function_Return False
79164>>>>>>>        End
79164>>>>>>>>
79164>>>>>>>
79164>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
79167>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
79170>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
79171>>>>>>>
79171>>>>>>>        Set Private.phCurrentTable to hTable
79172>>>>>>>        Set Private.piCurrentField to iOld
79173>>>>>>>
79173>>>>>>>//        If (bIsDate = False) Begin
79173>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
79173>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
79173>>>>>>>//        End
79173>>>>>>>//        Else Begin
79173>>>>>>>//            Move 6 to iLength
79173>>>>>>>//            Move 0 to iPrecision
79173>>>>>>>//        End
79173>>>>>>>
79173>>>>>>>        Move False to Err
79174>>>>>>>
79174>>>>>>>        Structure_Start hTable
79175>>>>>>>            Delete_Field hTable iOld
79176>>>>>>>            Create_Field hTable At iNew
79177>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
79180>>>>>>>
79180>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
79183>>>>>>>            If (bIsSQLType = False) Begin
79185>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
79188>>>>>>>            End
79188>>>>>>>>
79188>>>>>>>            Else Begin
79189>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
79192>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
79192>>>>>>>            End
79192>>>>>>>>
79192>>>>>>>
79192>>>>>>>            If (bIsDate = False) Begin
79194>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
79197>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
79200>>>>>>>            End
79200>>>>>>>>
79200>>>>>>>
79200>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79201>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79203>>>>>>>
79203>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79204>>>>>>>        Function_Return (Err = False)
79205>>>>>>>    End_Function
79206>>>>>>>
79206>>>>>>>    // Deletes a column name for the passed table number (and column number).
79206>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
79208>>>>>>>        Integer iColumn
79208>>>>>>>        Boolean bOK
79208>>>>>>>
79208>>>>>>>        Get AutoConnectionIDLogin to bOK
79209>>>>>>>        Move False to Err
79210>>>>>>>        Close hTable
79211>>>>>>>        Get OpenTableExclusive hTable to bOK
79212>>>>>>>        If (bOK = False) Begin
79214>>>>>>>            Function_Return False
79215>>>>>>>        End
79215>>>>>>>>
79215>>>>>>>
79215>>>>>>>        If (not(Err)) Begin
79217>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79218>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79219>>>>>>>            Field_Map hTable sFieldName to iColumn
79221>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
79222>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79223>>>>>>>            If (iColumn = 0) Begin
79225>>>>>>>                Move 0 to LastErr
79226>>>>>>>                Function_Return False
79227>>>>>>>            End
79227>>>>>>>>
79227>>>>>>>            Move False to Err
79228>>>>>>>
79228>>>>>>>            Set Private.phCurrentTable to hTable
79229>>>>>>>            Set Private.piCurrentField to iColumn
79230>>>>>>>
79230>>>>>>>            Structure_Start hTable
79231>>>>>>>                Delete_Field hTable iColumn
79232>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
79233>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79235>>>>>>>            Set Action_Text of ghoStatusPanel to ""
79236>>>>>>>        End
79236>>>>>>>>
79236>>>>>>>        Else Begin
79237>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
79238>>>>>>>>
79238>>>>>>>        End
79238>>>>>>>>
79238>>>>>>>
79238>>>>>>>        Function_Return (Err = False)
79239>>>>>>>    End_Function
79240>>>>>>>
79240>>>>>>>    // Renames a field for the passed table number & old field name & new field name
79240>>>>>>>    // Returns True if no errors occured.
79240>>>>>>>    // Sample usage:
79240>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
79240>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
79242>>>>>>>        Integer iField
79242>>>>>>>        Boolean bOK bExists bIsOpen
79242>>>>>>>
79242>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
79243>>>>>>>        If (bExists = True) Begin
79245>>>>>>>            Function_Return False
79246>>>>>>>        End
79246>>>>>>>>
79246>>>>>>>
79246>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
79246>>>>>>>        //       opened exclusively, so we first open it in normal mode.
79246>>>>>>>        Close hTable
79247>>>>>>>        Open hTable
79249>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
79252>>>>>>>        If (bIsOpen = False) Begin
79254>>>>>>>            Function_Return False
79255>>>>>>>        End
79255>>>>>>>>
79255>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79256>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79257>>>>>>>        Field_Map hTable sOldFieldName to iField
79259>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79260>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79261>>>>>>>
79261>>>>>>>        Get AutoConnectionIDLogin to bOK
79262>>>>>>>        Get OpenTableExclusive hTable to bOK
79263>>>>>>>        If (bOK = False) Begin
79265>>>>>>>            Function_Return False
79266>>>>>>>        End
79266>>>>>>>>
79266>>>>>>>
79266>>>>>>>        Move False to Err
79267>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
79268>>>>>>>        Set Private.phCurrentTable to hTable
79269>>>>>>>        Set Private.piCurrentField to iField
79270>>>>>>>
79270>>>>>>>        If (iField > 0) Begin
79272>>>>>>>            Structure_Start hTable
79273>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
79276>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
79277>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79279>>>>>>>        End
79279>>>>>>>>
79279>>>>>>>        Else Begin
79280>>>>>>>            Move 0 to LastErr
79281>>>>>>>            Move False to Err
79282>>>>>>>        End
79282>>>>>>>>
79282>>>>>>>
79282>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79283>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
79284>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79285>>>>>>>
79285>>>>>>>        Function_Return (Err = False)
79286>>>>>>>    End_Function
79287>>>>>>>
79287>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
79289>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
79289>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
79290>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
79290>>>>>>>        Boolean bRenameField
79290>>>>>>>
79290>>>>>>>        Open hTable
79292>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79293>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79294>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
79295>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
79298>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
79299>>>>>>>        Decrement iSize
79300>>>>>>>        for iCount from 0 to iSize
79306>>>>>>>>
79306>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
79308>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79309>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79310>>>>>>>
79310>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
79312>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
79314>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
79315>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
79316>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
79318>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
79319>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
79320>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
79321>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
79322>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
79323>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
79324>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
79325>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
79326>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
79327>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
79328>>>>>>>                        Increment iItem
79329>>>>>>>                    End
79329>>>>>>>>
79329>>>>>>>                End
79329>>>>>>>>
79329>>>>>>>            End
79329>>>>>>>>
79329>>>>>>>        Loop
79330>>>>>>>>
79330>>>>>>>
79330>>>>>>>        Move False to Err
79331>>>>>>>        Move 0 to LastErr
79332>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79333>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
79334>>>>>>>        Function_Return aAPIColumnsToInsert
79335>>>>>>>    End_Function
79336>>>>>>>
79336>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
79338>>>>>>>        Integer iSize iCount
79338>>>>>>>        Boolean bOK
79338>>>>>>>        tAPIColumn[] aColumnsTo
79338>>>>>>>        tAPIColumn[] aColumnsTo
79339>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79339>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79340>>>>>>>
79340>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
79341>>>>>>>        If (iSize = 0) Begin
79343>>>>>>>            Function_Return True
79344>>>>>>>        End
79344>>>>>>>>
79344>>>>>>>
79344>>>>>>>        Move False to Err
79345>>>>>>>        Decrement iSize
79346>>>>>>>        for iCount from 0 to iSize
79352>>>>>>>>
79352>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
79353>>>>>>>        Loop
79354>>>>>>>>
79354>>>>>>>
79354>>>>>>>        Function_Return bOK
79355>>>>>>>    End_Function
79356>>>>>>>
79356>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
79356>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
79358>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
79358>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
79359>>>>>>>        Integer iSize iCount iItem iShouldMove
79359>>>>>>>
79359>>>>>>>        Move 0 to iItem
79360>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
79361>>>>>>>        Decrement iSize
79362>>>>>>>        for iCount from 0 to iSize
79368>>>>>>>>
79368>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
79370>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
79371>>>>>>>                If (iShouldMove <> -1) Begin
79373>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
79374>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
79375>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
79376>>>>>>>                    Increment iItem
79377>>>>>>>                End
79377>>>>>>>>
79377>>>>>>>            End
79377>>>>>>>>
79377>>>>>>>        Loop
79378>>>>>>>>
79378>>>>>>>
79378>>>>>>>        Move False to Err
79379>>>>>>>        Move 0 to LastErr
79380>>>>>>>        Function_Return aAPIColumnsToMove
79381>>>>>>>    End_Function
79382>>>>>>>
79382>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
79384>>>>>>>        Integer iSize iCount
79384>>>>>>>        Boolean bOK
79384>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79384>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79385>>>>>>>
79385>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
79386>>>>>>>        If (iSize = 0) Begin
79388>>>>>>>            Function_Return True
79389>>>>>>>        End
79389>>>>>>>>
79389>>>>>>>
79389>>>>>>>        Move False to Err
79390>>>>>>>        Decrement iSize
79391>>>>>>>        for iCount from 0 to iSize
79397>>>>>>>>
79397>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79398>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
79399>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
79401>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
79402>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
79403>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79404>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
79405>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
79407>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
79408>>>>>>>                    Decrement iSize
79409>>>>>>>                    Move 0 to iCount
79410>>>>>>>                End
79410>>>>>>>>
79410>>>>>>>            End
79410>>>>>>>>
79410>>>>>>>        Loop
79411>>>>>>>>
79411>>>>>>>
79411>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79412>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
79413>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
79415>>>>>>>            Move 0 to LastErr
79416>>>>>>>        End
79416>>>>>>>>
79416>>>>>>>        Function_Return bOK
79417>>>>>>>    End_Function
79418>>>>>>>
79418>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
79418>>>>>>>    // We then assume this field should be renamed.
79418>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
79418>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
79418>>>>>>>//
79418>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79418>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
79418>>>>>>>//
79418>>>>>>>//        If (bDifferentFieldNames = True) Begin
79418>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
79418>>>>>>>//            If (bShouldBeRenamed = False) Begin
79418>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
79418>>>>>>>//                Function_Return False
79418>>>>>>>//            End
79418>>>>>>>//
79418>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
79418>>>>>>>//            If (bShouldBeRenamed = False) Begin
79418>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
79418>>>>>>>//                Function_Return False
79418>>>>>>>//            End
79418>>>>>>>//
79418>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
79418>>>>>>>//            If (bShouldBeRenamed = False) Begin
79418>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
79418>>>>>>>//                Function_Return False
79418>>>>>>>//            End
79418>>>>>>>//
79418>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
79418>>>>>>>//            If (bShouldBeRenamed = False) Begin
79418>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
79418>>>>>>>//                Function_Return False
79418>>>>>>>//            End
79418>>>>>>>//        End
79418>>>>>>>//
79418>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
79418>>>>>>>//        Function_Return True
79418>>>>>>>//    End_Function
79418>>>>>>>
79418>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
79418>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
79418>>>>>>>    // - The "FROM" field name is <> "TO" field name
79418>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
79418>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
79418>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
79420>>>>>>>        Boolean bShouldRename
79420>>>>>>>        String sFieldNameFrom sFieldNameTo
79420>>>>>>>
79420>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
79421>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
79422>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
79424>>>>>>>            Function_Return False
79425>>>>>>>        End
79425>>>>>>>>
79425>>>>>>>
79425>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
79426>>>>>>>//        If (bShouldRename = False) Begin
79426>>>>>>>//            Function_Return False
79426>>>>>>>//        End
79426>>>>>>>//
79426>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
79426>>>>>>>//            Function_Return True
79426>>>>>>>//        End
79426>>>>>>>
79426>>>>>>>        Function_Return bShouldRename
79427>>>>>>>    End_Function
79428>>>>>>>
79428>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
79428>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
79428>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
79430>>>>>>>        Integer iCount iSize iRetval
79430>>>>>>>        String sFieldNameFrom
79430>>>>>>>
79430>>>>>>>        Move -1 to iRetval
79431>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
79433>>>>>>>            Function_Return iRetval
79434>>>>>>>        End
79434>>>>>>>>
79434>>>>>>>
79434>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
79435>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
79436>>>>>>>        Decrement iSize
79437>>>>>>>        for iCount from 0 to iSize
79443>>>>>>>>
79443>>>>>>>            // We're only interested in fields other than the passed field/column number:
79443>>>>>>>            If (iCount <> iColumn) Begin
79445>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
79447>>>>>>>                    Move (iCount + 1) to iRetval
79448>>>>>>>                End
79448>>>>>>>>
79448>>>>>>>            End
79448>>>>>>>>
79448>>>>>>>        Loop
79449>>>>>>>>
79449>>>>>>>
79449>>>>>>>        Move 0 to LastErr
79450>>>>>>>        Function_Return iRetval
79451>>>>>>>    End_Function
79452>>>>>>>
79452>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
79454>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
79454>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
79455>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
79455>>>>>>>        Boolean bRenameField
79455>>>>>>>
79455>>>>>>>        Open hTable
79457>>>>>>>        Move 0 to iItem
79458>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
79459>>>>>>>        Decrement iSize
79460>>>>>>>        for iCount from 0 to iSize
79466>>>>>>>>
79466>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
79468>>>>>>>                // Check if the field exists in another position (other field number)
79468>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
79469>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
79470>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
79472>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
79473>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
79474>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
79475>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
79476>>>>>>>                    Increment iItem
79477>>>>>>>                End
79477>>>>>>>>
79477>>>>>>>            End
79477>>>>>>>>
79477>>>>>>>        Loop
79478>>>>>>>>
79478>>>>>>>
79478>>>>>>>        Move False to Err
79479>>>>>>>        Move 0 to LastErr
79480>>>>>>>        Function_Return aAPIColumnsToRename
79481>>>>>>>    End_Function
79482>>>>>>>
79482>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
79484>>>>>>>        Integer iSize iCount
79484>>>>>>>        Boolean bOK
79484>>>>>>>        tAPIColumn[] aColumnsTo
79484>>>>>>>        tAPIColumn[] aColumnsTo
79485>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79485>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
79486>>>>>>>
79486>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
79487>>>>>>>        If (iSize = 0) Begin
79489>>>>>>>            Function_Return True
79490>>>>>>>        End
79490>>>>>>>>
79490>>>>>>>
79490>>>>>>>        Move False to Err
79491>>>>>>>        Decrement iSize
79492>>>>>>>        For iCount from 0 to iSize
79498>>>>>>>>
79498>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79499>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
79500>>>>>>>        Loop
79501>>>>>>>>
79501>>>>>>>
79501>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79502>>>>>>>        Function_Return bOK
79503>>>>>>>    End_Function
79504>>>>>>>
79504>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
79506>>>>>>>        Boolean bDateType
79506>>>>>>>
79506>>>>>>>        If (bIsSQLTableTo = True) Begin
79508>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
79509>>>>>>>        End
79509>>>>>>>>
79509>>>>>>>        Else Begin
79510>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
79511>>>>>>>        End
79511>>>>>>>>
79511>>>>>>>
79511>>>>>>>        Function_Return bDateType
79512>>>>>>>    End_Function
79513>>>>>>>
79513>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
79515>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
79515>>>>>>>        Integer iCount2 iColumn2
79515>>>>>>>        Handle hFile
79515>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
79515>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
79515>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
79515>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
79515>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
79520>>>>>>>        tColumnType ColumnType
79520>>>>>>>        tColumnType ColumnType
79520>>>>>>>
79520>>>>>>>        Move False to Err
79521>>>>>>>        Close hTable
79522>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
79523>>>>>>>        If (bIsOpen = False) Begin
79525>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
79526>>>>>>>>
79526>>>>>>>            Function_Return False
79527>>>>>>>        End 
79527>>>>>>>>
79527>>>>>>>        
79527>>>>>>>        Get piDbType to iDbType
79528>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
79531>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
79532>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
79533>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
79536>>>>>>>
79536>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79537>>>>>>>
79537>>>>>>>        // Before we start to change the table we need to do three things;
79537>>>>>>>        // 1) Insert any new fields
79537>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
79538>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
79540>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
79541>>>>>>>            If (bOK = False) Begin
79543>>>>>>>                Function_Return False
79544>>>>>>>            End
79544>>>>>>>>
79544>>>>>>>            // Update info with changes made.
79544>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
79545>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79546>>>>>>>        End
79546>>>>>>>>
79546>>>>>>>
79546>>>>>>>        // 2) Move fields with same names
79546>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
79547>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
79549>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
79550>>>>>>>            If (bOK = False) Begin
79552>>>>>>>                Function_Return False
79553>>>>>>>            End
79553>>>>>>>>
79553>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
79554>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79555>>>>>>>        End
79555>>>>>>>>
79555>>>>>>>        
79555>>>>>>>        // 3) Rename fields
79555>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
79556>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
79558>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
79559>>>>>>>            If (bOK = False) Begin
79561>>>>>>>                Function_Return False
79562>>>>>>>            End
79562>>>>>>>>
79562>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
79563>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79564>>>>>>>        End
79564>>>>>>>>
79564>>>>>>>
79564>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
79564>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
79564>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
79564>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
79564>>>>>>>//            If (bOK = False) Begin
79564>>>>>>>//                Function_Return False
79564>>>>>>>//            End
79564>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
79564>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79564>>>>>>>//        End
79564>>>>>>>
79564>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
79564>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
79566>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
79567>>>>>>>            If (bIsSame = True) Begin
79569>>>>>>>                Function_Return True
79570>>>>>>>            End
79570>>>>>>>>
79570>>>>>>>        End
79570>>>>>>>>
79570>>>>>>>
79570>>>>>>>        // We can now continue to make standard field changes:
79570>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
79571>>>>>>>        Set Private.phCurrentTable to hTable
79572>>>>>>>        Move hTable to hFile
79573>>>>>>>        Structure_Start hFile sDriverIDTo
79574>>>>>>>
79574>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
79575>>>>>>>            Decrement iColumns
79576>>>>>>>            for iCount from 0 to iColumns
79582>>>>>>>>
79582>>>>>>>                Send DoAdvance of ghoProgressBar
79583>>>>>>>
79583>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
79584>>>>>>>                Set Private.piCurrentField                  to iColumn
79585>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
79586>>>>>>>                If (bIsSame = False) Begin
79588>>>>>>>
79588>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
79589>>>>>>>                    If (bFieldExistsFrom = True) Begin
79591>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
79592>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
79593>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
79594>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
79595>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
79596>>>>>>>
79596>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
79597>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
79598>>>>>>>                        If (iTypeFrom < -1490) Begin
79600>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
79601>>>>>>>                        End
79601>>>>>>>>
79601>>>>>>>
79601>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
79601>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
79601>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
79603>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
79604>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
79606>>>>>>>                                Move DF_DATE to iTypeFrom
79607>>>>>>>                            End
79607>>>>>>>>
79607>>>>>>>                        End
79607>>>>>>>>
79607>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
79610>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
79611>>>>>>>                        End
79611>>>>>>>>
79611>>>>>>>
79611>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
79612>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
79613>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
79614>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
79615>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
79616>>>>>>>
79616>>>>>>>                        Move False to bSkipTypeChange
79617>>>>>>>                        If (bCompareDate_DateTime = False) Begin
79619>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
79620>>>>>>>                        End
79620>>>>>>>>
79620>>>>>>>
79620>>>>>>>                        If (bFieldExistsTo = False) Begin
79622>>>>>>>                            Move 0 to iColumn
79623>>>>>>>                            Create_Field hFile At iColumn
79624>>>>>>>                            Set Private.piCurrentField to iColumn
79625>>>>>>>                        End
79625>>>>>>>>
79625>>>>>>>
79625>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
79627>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
79630>>>>>>>                        End
79630>>>>>>>>
79630>>>>>>>
79630>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
79632>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
79635>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
79636>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
79638>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
79639>>>>>>>                            End
79639>>>>>>>>
79639>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
79642>>>>>>>                        End
79642>>>>>>>>
79642>>>>>>>
79642>>>>>>>                        If (bSkipTypeChange = False) Begin
79644>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
79646>>>>>>>                                If (bIsSQLTableTo = True) Begin
79648>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
79651>>>>>>>                                End
79651>>>>>>>>
79651>>>>>>>                                Else Begin                                                   
79652>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
79654>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
79655>>>>>>>                                    End
79655>>>>>>>>
79655>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
79658>>>>>>>                                End
79658>>>>>>>>
79658>>>>>>>                            End
79658>>>>>>>>
79658>>>>>>>                        End
79658>>>>>>>>
79658>>>>>>>
79658>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
79659>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
79659>>>>>>>                        If (bIsDateType = False) Begin
79661>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
79663>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
79666>>>>>>>                            End
79666>>>>>>>>
79666>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
79668>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
79671>>>>>>>                            End
79671>>>>>>>>
79671>>>>>>>                        End
79671>>>>>>>>
79671>>>>>>>
79671>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
79673>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
79673>>>>>>>                            If (bRecnumTable = True) Begin
79675>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
79678>>>>>>>                            End
79678>>>>>>>>
79678>>>>>>>
79678>>>>>>>                            // We might need to create an index here.
79678>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
79678>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
79678>>>>>>>                            // index update checking logic.
79678>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
79681>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
79683>>>>>>>                                Create_Index hFile at iIndex
79684>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
79687>>>>>>>                            End
79687>>>>>>>>
79687>>>>>>>
79687>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
79690>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
79693>>>>>>>                                // Note: The order of these two are crucial!
79693>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
79696>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
79699>>>>>>>                        End
79699>>>>>>>>
79699>>>>>>>                    End
79699>>>>>>>>
79699>>>>>>>                    Else Begin
79700>>>>>>>                        Delete_Field hFile iColumn
79701>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
79702>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
79703>>>>>>>                        Decrement iCount2
79704>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
79704>>>>>>>                        // starting with the array number we just deleted the field for.
79704>>>>>>>                        for iColumn2 from iCount to iCount2
79710>>>>>>>>
79710>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
79711>>>>>>>                        Loop
79712>>>>>>>>
79712>>>>>>>                        Decrement iCount
79713>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
79714>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
79715>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
79717>>>>>>>                            Move iColumns to iCount 
79718>>>>>>>                        End
79718>>>>>>>>
79718>>>>>>>                    End
79718>>>>>>>>
79718>>>>>>>                End
79718>>>>>>>>
79718>>>>>>>            Loop
79719>>>>>>>>
79719>>>>>>>
79719>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79720>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79722>>>>>>>
79722>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79723>>>>>>>        Function_Return (Err = False)
79724>>>>>>>    End_Function
79725>>>>>>>
79725>>>>>>>    // * Dummy function for the Studio's Code Explorer *
79725>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
79727>>>>>>>        Function_Return False
79728>>>>>>>    End_Function
79729>>>>>>>
79729>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
79729>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
79729>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
79729>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
79731>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
79731>>>>>>>        String sDriverID
79731>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
79731>>>>>>>
79731>>>>>>>        Get AutoConnectionIDLogin to bOK
79732>>>>>>>        Get OpenTableExclusive hTable to bOK
79733>>>>>>>        If (bOK = False) Begin
79735>>>>>>>            Function_Return False
79736>>>>>>>        End
79736>>>>>>>>
79736>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
79739>>>>>>>
79739>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
79740>>>>>>>            If (bIsSQLTable = True) Begin
79742>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
79745>>>>>>>            End
79745>>>>>>>>
79745>>>>>>>
79745>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
79748>>>>>>>            Move (iIndexSegments > 0) to bExists
79749>>>>>>>        If (bExists = True) Begin
79751>>>>>>>            Function_Return True
79752>>>>>>>        End
79752>>>>>>>>
79752>>>>>>>
79752>>>>>>>        Move -1 to iSegment1
79753>>>>>>>        Move -1 to iSegment2
79754>>>>>>>        Move -1 to iSegment3
79755>>>>>>>        Move -1 to iSegment4
79756>>>>>>>        Move -1 to iSegment5
79757>>>>>>>        Move -1 to iSegment6
79758>>>>>>>        Move -1 to iSegment7
79759>>>>>>>        Move -1 to iSegment8
79760>>>>>>>        Move -1 to iSegment9
79761>>>>>>>        Move -1 to iSegment10
79762>>>>>>>
79762>>>>>>>        If (num_arguments > 3) Begin
79764>>>>>>>            Move iSgmnt1 to iSegment1
79765>>>>>>>        End
79765>>>>>>>>
79765>>>>>>>        If (num_arguments > 4) Begin
79767>>>>>>>            Move iSgmnt2 to iSegment2
79768>>>>>>>        End
79768>>>>>>>>
79768>>>>>>>        If (num_arguments > 5) Begin
79770>>>>>>>            Move iSgmnt3 to iSegment3
79771>>>>>>>        End
79771>>>>>>>>
79771>>>>>>>        If (num_arguments > 6) Begin
79773>>>>>>>            Move iSgmnt4 to iSegment4
79774>>>>>>>        End
79774>>>>>>>>
79774>>>>>>>        If (num_arguments > 7) Begin
79776>>>>>>>            Move iSgmnt5 to iSegment5
79777>>>>>>>        End
79777>>>>>>>>
79777>>>>>>>        If (num_arguments > 8) Begin
79779>>>>>>>            Move iSgmnt6 to iSegment6
79780>>>>>>>        End
79780>>>>>>>>
79780>>>>>>>        If (num_arguments > 9) Begin
79782>>>>>>>            Move iSgmnt7 to iSegment7
79783>>>>>>>        End
79783>>>>>>>>
79783>>>>>>>        If (num_arguments > 10) Begin
79785>>>>>>>            Move iSgmnt8 to iSegment8
79786>>>>>>>        End
79786>>>>>>>>
79786>>>>>>>        If (num_arguments > 11) Begin
79788>>>>>>>            Move iSgmnt9 to iSegment9
79789>>>>>>>        End
79789>>>>>>>>
79789>>>>>>>        If (num_arguments > 12) Begin
79791>>>>>>>            Move iSgmnt10 to iSegment10
79792>>>>>>>        End
79792>>>>>>>>
79792>>>>>>>
79792>>>>>>>        Move False to Err
79793>>>>>>>        Move hTable to iTableNo
79794>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79795>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79796>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
79797>>>>>>>
79797>>>>>>>        // We start by deleting the index, if it exists.
79797>>>>>>>        If (bExists = True) Begin
79799>>>>>>>            Structure_Start hTable sDriverID
79800>>>>>>>                Delete_Index iTableNo iIndex
79801>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
79802>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79804>>>>>>>        End
79804>>>>>>>>
79804>>>>>>>
79804>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
79805>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79806>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
79807>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79808>>>>>>>        Move False to Err
79809>>>>>>>        Move 0 to LastErr
79810>>>>>>>
79810>>>>>>>        // Need to re-open if index deleted.
79810>>>>>>>        Move iTableNo to hTable
79811>>>>>>>        Get OpenTableExclusive hTable to bOK
79812>>>>>>>        If (bOK = False) Begin
79814>>>>>>>            Function_Return False
79815>>>>>>>        End
79815>>>>>>>>
79815>>>>>>>
79815>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79816>>>>>>>        Structure_Start hTable sDriverID
79817>>>>>>>            Create_Index hTable At iIndex
79818>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
79821>>>>>>>
79821>>>>>>>            If (iSgmnt1 <> -1) Begin
79823>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
79826>>>>>>>            End
79826>>>>>>>>
79826>>>>>>>            If (iSegment2 <> -1) Begin
79828>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
79831>>>>>>>            End
79831>>>>>>>>
79831>>>>>>>            If (iSegment3 <> -1) Begin
79833>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
79836>>>>>>>            End
79836>>>>>>>>
79836>>>>>>>            If (iSegment4 <> -1) Begin
79838>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
79841>>>>>>>            End
79841>>>>>>>>
79841>>>>>>>            If (iSegment5 <> -1) Begin
79843>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
79846>>>>>>>            End
79846>>>>>>>>
79846>>>>>>>            If (iSegment6 <> -1) Begin
79848>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
79851>>>>>>>            End
79851>>>>>>>>
79851>>>>>>>            If (iSegment7 <> -1) Begin
79853>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
79856>>>>>>>            End
79856>>>>>>>>
79856>>>>>>>            If (iSegment8 <> -1) Begin
79858>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
79861>>>>>>>            End
79861>>>>>>>>
79861>>>>>>>            If (iSegment9 <> -1) Begin
79863>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
79866>>>>>>>            End
79866>>>>>>>>
79866>>>>>>>            If (iSegment10 <> -1) Begin
79868>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
79871>>>>>>>            End
79871>>>>>>>>
79871>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
79872>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
79874>>>>>>>
79874>>>>>>>        Set Action_Text of ghoStatusPanel to ""
79875>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79876>>>>>>>
79876>>>>>>>        Function_Return (Err = False)
79877>>>>>>>    End_Function
79878>>>>>>>
79878>>>>>>>    // Example:
79878>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
79878>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
79878>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
79880>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
79880>>>>>>>        String sDriverID
79880>>>>>>>        Boolean bOK bIsSQLTable
79880>>>>>>>
79880>>>>>>>        Get AutoConnectionIDLogin to bOK
79881>>>>>>>
79881>>>>>>>        Move False to Err
79882>>>>>>>        Move hTable to iTableNo
79883>>>>>>>        Get OpenTableExclusive hTable to bOK
79884>>>>>>>        If (bOK = False) Begin
79886>>>>>>>            Function_Return False
79887>>>>>>>        End
79887>>>>>>>>
79887>>>>>>>
79887>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
79890>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
79891>>>>>>>            If (bIsSQLTable = True) Begin
79893>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
79896>>>>>>>            End
79896>>>>>>>>
79896>>>>>>>
79896>>>>>>>        // We start by deleting the index
79896>>>>>>>        Structure_Start hTable sDriverID
79897>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
79898>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79899>>>>>>>            Delete_Index iTableNo iIndex
79900>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
79901>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79902>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
79904>>>>>>>
79904>>>>>>>        Move False to Err
79905>>>>>>>        Move iTableNo to hTable
79906>>>>>>>        Get OpenTableExclusive hTable to bOK
79907>>>>>>>        If (bOK = False) Begin
79909>>>>>>>            Function_Return False
79910>>>>>>>        End
79910>>>>>>>>
79910>>>>>>>
79910>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79911>>>>>>>        Structure_Start hTable sDriverID
79912>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
79913>>>>>>>
79913>>>>>>>            Create_Index hTable at iIndex
79914>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
79917>>>>>>>
79917>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
79923>>>>>>>>
79923>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
79926>>>>>>>            Loop
79927>>>>>>>>
79927>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
79929>>>>>>>
79929>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79930>>>>>>>
79930>>>>>>>        Function_Return (Err = False)
79931>>>>>>>    End_Function
79932>>>>>>>
79932>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
79934>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
79934>>>>>>>        String sDriverID sSQLIndexName
79934>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
79934>>>>>>>
79934>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
79935>>>>>>>        If (iSegmentsFrom = 0) Begin
79937>>>>>>>            Function_Return False
79938>>>>>>>        End
79938>>>>>>>>
79938>>>>>>>
79938>>>>>>>        Get AutoConnectionIDLogin to bOK
79939>>>>>>>        Move False to Err
79940>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
79941>>>>>>>        If (bIsOpen = False) Begin
79943>>>>>>>            Function_Return False
79944>>>>>>>        End
79944>>>>>>>>
79944>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
79947>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
79948>>>>>>>            If (bIsSQLTable = True) Begin
79950>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
79953>>>>>>>            End
79953>>>>>>>>
79953>>>>>>>
79953>>>>>>>        Move 0     to iSegmentsTo
79954>>>>>>>        Move 0     to iSQLIndexType
79955>>>>>>>        Move ""    to sSQLIndexName
79956>>>>>>>        Move False to bIsSQLTemporaryIndex
79957>>>>>>>        Move False to bIsSQLPrimaryKey
79958>>>>>>>        Move False to bIsSQLClustered
79959>>>>>>>
79959>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
79960>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
79963>>>>>>>        Move (iSegmentsTo > 0) to bExists
79964>>>>>>>        If (bExists = True) Begin
79966>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
79968>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
79971>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
79974>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
79975>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
79978>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
79981>>>>>>>            End
79981>>>>>>>>
79981>>>>>>>        End
79981>>>>>>>>
79981>>>>>>>
79981>>>>>>>        Move hTable to iTableNo
79982>>>>>>>        Move False to Err
79983>>>>>>>        Move 0 to LastErr
79984>>>>>>>
79984>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
79984>>>>>>>        //       _outside_ the Structure_Start/End construct.
79984>>>>>>>//        Move False to bIsSQLTemporaryIndex
79984>>>>>>>//        #IF (!@ > 170)
79984>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
79984>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
79984>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
79984>>>>>>>//                End
79984>>>>>>>//            End
79984>>>>>>>//        #ENDIF
79984>>>>>>>
79984>>>>>>>        Structure_Start hTable sDriverID
79985>>>>>>>            If (bExists = True) Begin
79987>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
79988>>>>>>>            End
79988>>>>>>>>
79988>>>>>>>
79988>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
79989>>>>>>>
79989>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
79991>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
79994>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
79997>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
80000>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
80003>>>>>>>            End
80003>>>>>>>>
80003>>>>>>>
80003>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
80006>>>>>>>
80006>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
80012>>>>>>>>
80012>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
80013>>>>>>>                If (iFieldFrom <> -1 ) Begin
80015>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
80018>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
80021>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
80024>>>>>>>                End
80024>>>>>>>>
80024>>>>>>>            Loop
80025>>>>>>>>
80025>>>>>>>
80025>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80026>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80028>>>>>>>
80028>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80029>>>>>>>
80029>>>>>>>        Function_Return (Err = False)
80030>>>>>>>    End_Function
80031>>>>>>>
80031>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
80031>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
80031>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
80033>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
80033>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
80033>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
80033>>>>>>>
80033>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
80033>>>>>>>        // so we can then not rename the index.
80033>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
80034>>>>>>>        If (bIsMertechDriver = True) Begin
80036>>>>>>>            Function_Return False
80037>>>>>>>        End    
80037>>>>>>>>
80037>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
80038>>>>>>>        
80038>>>>>>>        If (bIsSQLDriver = False) Begin
80040>>>>>>>            Function_Return False
80041>>>>>>>        End
80041>>>>>>>>
80041>>>>>>>
80041>>>>>>>        Move False to Err
80042>>>>>>>        Move hTable to iTableNo
80043>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
80046>>>>>>>        for iCount from 0 to iLastIndex
80052>>>>>>>>
80052>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
80055>>>>>>>            Move (iSegments > 0) to bExists
80056>>>>>>>            If (bExists = True) Begin
80058>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
80061>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
80063>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
80064>>>>>>>                    Structure_Start iTableNo sDriverID
80065>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
80068>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80070>>>>>>>                    Open hTable
80072>>>>>>>                End
80072>>>>>>>>
80072>>>>>>>            End
80072>>>>>>>>
80072>>>>>>>        Loop
80073>>>>>>>>
80073>>>>>>>
80073>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
80076>>>>>>>        If (bIsOpen = False) Begin
80078>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
80079>>>>>>>        End
80079>>>>>>>>
80079>>>>>>>        If (bIsOpen = False) Begin
80081>>>>>>>            Function_Return False
80082>>>>>>>        End
80082>>>>>>>>
80082>>>>>>>
80082>>>>>>>        Function_Return (Err = False)
80083>>>>>>>    End_Function
80084>>>>>>>
80084>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
80084>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
80084>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
80086>>>>>>>        Integer iSize iCount
80086>>>>>>>        Integer iRetVal
80086>>>>>>>
80086>>>>>>>        Move 0 to iRetVal
80087>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
80090>>>>>>>        If (iRetVal = 0) Begin
80092>>>>>>>            Function_Return 0
80093>>>>>>>        End
80093>>>>>>>>
80093>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
80094>>>>>>>        Decrement iSize
80095>>>>>>>        for iCount from 0 to iSize
80101>>>>>>>>
80101>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
80103>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
80105>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
80106>>>>>>>                End
80106>>>>>>>>
80106>>>>>>>            End
80106>>>>>>>>
80106>>>>>>>        Loop
80107>>>>>>>>
80107>>>>>>>
80107>>>>>>>        Function_Return iRetVal
80108>>>>>>>    End_Function
80109>>>>>>>
80109>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
80111>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
80111>>>>>>>        Boolean bIsSQLTable
80111>>>>>>>        
80111>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
80112>>>>>>>            If (bIsSQLTable = True) Begin
80114>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
80117>>>>>>>            End
80117>>>>>>>>
80117>>>>>>>
80117>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80120>>>>>>>        If (iSegment = iNumSegments) Begin
80122>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80122>>>>>>>        End
80122>>>>>>>>
80122>>>>>>>
80122>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
80125>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
80131>>>>>>>>
80131>>>>>>>                //*** Move index segment attributes
80131>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
80134>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
80137>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
80140>>>>>>>
80140>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
80143>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
80146>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
80149>>>>>>>            Loop
80150>>>>>>>>
80150>>>>>>>
80150>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80153>>>>>>>        End
80153>>>>>>>>
80153>>>>>>>
80153>>>>>>>        Function_Return (Err = False)
80154>>>>>>>    End_Function
80155>>>>>>>
80155>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
80157>>>>>>>        Integer iCount iSize iIndex
80157>>>>>>>        String sDriverID
80157>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
80157>>>>>>>
80157>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
80158>>>>>>>        If (iSize = 0) Begin
80160>>>>>>>            Function_Return True
80161>>>>>>>        End
80161>>>>>>>>
80161>>>>>>>
80161>>>>>>>        Get AutoConnectionIDLogin to bOK
80162>>>>>>>        Move False to Err
80163>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
80166>>>>>>>        If (bIsOpen = False) Begin
80168>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
80169>>>>>>>            If (bIsOpen = False) Begin
80171>>>>>>>                Function_Return False
80172>>>>>>>            End
80172>>>>>>>>
80172>>>>>>>        End
80172>>>>>>>>
80172>>>>>>>
80172>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
80175>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
80176>>>>>>>            If (bIsSQLTable = True) Begin
80178>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
80181>>>>>>>            End
80181>>>>>>>>
80181>>>>>>>
80181>>>>>>>        Move False to Err
80182>>>>>>>        Move 0 to LastErr
80183>>>>>>>        Decrement iSize
80184>>>>>>>
80184>>>>>>>        Structure_Start hTable sDriverID
80185>>>>>>>            for iCount from 0 to iSize
80191>>>>>>>>
80191>>>>>>>//                Move False to bIsSQLPrimaryKey
80191>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
80191>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80191>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
80191>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
80191>>>>>>>//                #ENDIF
80191>>>>>>>                // We can't delete if this is a primary key index:
80191>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
80191>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
80192>>>>>>>                    Delete_Index hTable iIndex
80193>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
80193>>>>>>>//                End
80193>>>>>>>            Loop
80194>>>>>>>>
80194>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80195>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80197>>>>>>>//        Move False to Err
80197>>>>>>>        Move 0 to LastErr
80198>>>>>>>
80198>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80199>>>>>>>        Function_Return (Err = False)
80200>>>>>>>    End_Function
80201>>>>>>>
80201>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
80203>>>>>>>        Boolean bOK
80203>>>>>>>
80203>>>>>>>        Get AutoConnectionIDLogin to bOK
80204>>>>>>>        Move False to Err
80205>>>>>>>        Get OpenTableExclusive hTable to bOK
80206>>>>>>>        If (bOK = False) Begin
80208>>>>>>>            Function_Return False
80209>>>>>>>        End
80209>>>>>>>>
80209>>>>>>>        Structure_Start hTable
80210>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
80213>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80214>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80216>>>>>>>
80216>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80217>>>>>>>        Function_Return (Err = False)
80218>>>>>>>    End_Function
80219>>>>>>>
80219>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
80221>>>>>>>        Integer iCase
80221>>>>>>>        Boolean bOK
80221>>>>>>>
80221>>>>>>>        If (bUppercase = True) Begin
80223>>>>>>>            Move DF_CASE_IGNORED to iCase
80224>>>>>>>        End
80224>>>>>>>>
80224>>>>>>>        Else Begin
80225>>>>>>>            Move DF_CASE_USED to iCase
80226>>>>>>>        End
80226>>>>>>>>
80226>>>>>>>
80226>>>>>>>        Get AutoConnectionIDLogin to bOK
80227>>>>>>>        Move False to Err
80228>>>>>>>        Get OpenTableExclusive hTable to bOK
80229>>>>>>>        If (bOK = False) Begin
80231>>>>>>>            Function_Return False
80232>>>>>>>        End
80232>>>>>>>>
80232>>>>>>>        Structure_Start hTable
80233>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
80236>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80237>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80239>>>>>>>
80239>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80240>>>>>>>        Function_Return (Err = False)
80241>>>>>>>    End_Function
80242>>>>>>>
80242>>>>>>>    // To delete an index
80242>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
80244>>>>>>>        Integer iTableNo iNumSegments
80244>>>>>>>        String sDriverID
80244>>>>>>>        Boolean bOK bIsSQLTable
80244>>>>>>>
80244>>>>>>>        Get AutoConnectionIDLogin to bOK
80245>>>>>>>        Move False to Err
80246>>>>>>>        Move hTable to iTableNo
80247>>>>>>>        Get OpenTableExclusive hTable to bOK
80248>>>>>>>        If (bOK = False) Begin
80250>>>>>>>            Function_Return False
80251>>>>>>>        End
80251>>>>>>>>
80251>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
80254>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
80255>>>>>>>            If (bIsSQLTable = True) Begin
80257>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
80260>>>>>>>            End
80260>>>>>>>>
80260>>>>>>>
80260>>>>>>>        // Check to see if the index exists or not...
80260>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80263>>>>>>>        If (iNumSegments = 0) Begin
80265>>>>>>>            Function_Return True // Then nothing to do.
80266>>>>>>>        End
80266>>>>>>>>
80266>>>>>>>
80266>>>>>>>        Structure_Start hTable sDriverID
80267>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
80268>>>>>>>            Delete_Index iTableNo iIndex
80269>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
80270>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80271>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80273>>>>>>>
80273>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80274>>>>>>>        Function_Return (Err = False)
80275>>>>>>>    End_Function
80276>>>>>>>
80276>>>>>>>    // Delete an Index Segment
80276>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
80278>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
80278>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
80278>>>>>>>        Integer iIndexType
80278>>>>>>>        String sDriverID
80278>>>>>>>
80278>>>>>>>        Get AutoConnectionIDLogin to bOK
80279>>>>>>>        Move False to Err
80280>>>>>>>
80280>>>>>>>        Get OpenTableExclusive hTable to bOK
80281>>>>>>>        If (bOK = False) Begin
80283>>>>>>>            Function_Return False
80284>>>>>>>        End
80284>>>>>>>>
80284>>>>>>>
80284>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
80285>>>>>>>            If (bIsSQLTable = True) Begin
80287>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
80290>>>>>>>            End
80290>>>>>>>>
80290>>>>>>>
80290>>>>>>>        // Check to see if the index exists or not...
80290>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80293>>>>>>>        If (iNumSegments = 0) Begin
80295>>>>>>>            Function_Return False
80296>>>>>>>        End
80296>>>>>>>>
80296>>>>>>>
80296>>>>>>>        Move False to bIndexTemporary
80297>>>>>>>        Get psDriverID to sDriverID
80298>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
80299>>>>>>>        If (bSQLDriver) Begin
80301>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
80304>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
80307>>>>>>>                Move True to bIndexTemporary
80308>>>>>>>        End
80308>>>>>>>>
80308>>>>>>>
80308>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
80308>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
80310>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80313>>>>>>>            If (iSegment = iNumSegments) Begin
80315>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80318>>>>>>>            End
80318>>>>>>>>
80318>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
80321>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
80327>>>>>>>>
80327>>>>>>>                    //*** Move index segment attributes
80327>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
80330>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
80333>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
80336>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
80339>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
80342>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
80345>>>>>>>                Loop
80346>>>>>>>>
80346>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80349>>>>>>>            End
80349>>>>>>>>
80349>>>>>>>        End
80349>>>>>>>>
80349>>>>>>>
80349>>>>>>>        Else Begin
80350>>>>>>>           Structure_Start hTable
80351>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80354>>>>>>>               If (iSegment = iNumSegments) Begin
80356>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80359>>>>>>>               End
80359>>>>>>>>
80359>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
80362>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
80368>>>>>>>>
80368>>>>>>>                       //*** Move index segment attributes
80368>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
80371>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
80374>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
80377>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
80380>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
80383>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
80386>>>>>>>                   Loop
80387>>>>>>>>
80387>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
80390>>>>>>>               End
80390>>>>>>>>
80390>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
80391>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80393>>>>>>>            Set Action_Text of ghoStatusPanel to ""
80394>>>>>>>        End
80394>>>>>>>>
80394>>>>>>>
80394>>>>>>>        Function_Return (Err = False)
80395>>>>>>>    End_Function
80396>>>>>>>
80396>>>>>>>    // Add/Insert an Index Segment
80396>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
80398>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
80398>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
80398>>>>>>>        Integer iIndexType
80398>>>>>>>        String sDriverId
80398>>>>>>>
80398>>>>>>>        Get AutoConnectionIDLogin to bOK
80399>>>>>>>        Move False to Err
80400>>>>>>>
80400>>>>>>>        Get OpenTableExclusive hTable to bOK
80401>>>>>>>        If (bOK = False) Begin
80403>>>>>>>            Function_Return False
80404>>>>>>>        End
80404>>>>>>>>
80404>>>>>>>
80404>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
80405>>>>>>>            If (bIsSQLTable = True) Begin
80407>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
80410>>>>>>>            End
80410>>>>>>>>
80410>>>>>>>
80410>>>>>>>        Move False to bIndexTemporary
80411>>>>>>>        // Check to see if the index exists or not...
80411>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80414>>>>>>>        If (iNumSegments = 0) Begin
80416>>>>>>>            Function_Return False
80417>>>>>>>        End
80417>>>>>>>>
80417>>>>>>>
80417>>>>>>>        Get psDriverID to sDriverID
80418>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
80419>>>>>>>        If (bSQLDriver) Begin
80421>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
80424>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
80427>>>>>>>                Move True to bIndexTemporary
80428>>>>>>>        End
80428>>>>>>>>
80428>>>>>>>
80428>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
80428>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
80430>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80433>>>>>>>
80433>>>>>>>           If (iSegment > iNumSegments) Begin
80435>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
80438>>>>>>>               Move (iNumSegments + 1) to iCurSegment
80439>>>>>>>           End
80439>>>>>>>>
80439>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
80442>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
80445>>>>>>>               Move iNumSegments to iCurSegment
80446>>>>>>>
80446>>>>>>>               While (iCurSegment > iSegment)
80450>>>>>>>                   //*** Move index segment attributes
80450>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
80453>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
80456>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
80459>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
80462>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
80465>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
80468>>>>>>>                   Decrement iCurSegment
80469>>>>>>>               Loop
80470>>>>>>>>
80470>>>>>>>
80470>>>>>>>               //*** Now set new segment attributes
80470>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
80473>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
80476>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
80479>>>>>>>           End
80479>>>>>>>>
80479>>>>>>>        End
80479>>>>>>>>
80479>>>>>>>
80479>>>>>>>        Else Begin
80480>>>>>>>        Structure_Start hTable
80481>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80484>>>>>>>
80484>>>>>>>            If (iSegment > iNumSegments) Begin
80486>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
80489>>>>>>>                Move (iNumSegments + 1) to iCurSegment
80490>>>>>>>            End
80490>>>>>>>>
80490>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
80493>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
80496>>>>>>>                Move iNumSegments to iCurSegment
80497>>>>>>>
80497>>>>>>>                While (iCurSegment > iSegment)
80501>>>>>>>                    //*** Move index segment attributes
80501>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
80504>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
80507>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
80510>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
80513>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
80516>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
80519>>>>>>>                    Decrement iCurSegment
80520>>>>>>>                Loop
80521>>>>>>>>
80521>>>>>>>
80521>>>>>>>                //*** Now set new segment attributes
80521>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
80524>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
80527>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
80530>>>>>>>            End
80530>>>>>>>>
80530>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80531>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80533>>>>>>>            Set Action_Text of ghoStatusPanel to ""
80534>>>>>>>        End
80534>>>>>>>>
80534>>>>>>>
80534>>>>>>>        Function_Return (Err = False)
80535>>>>>>>    End_Function
80536>>>>>>>
80536>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80536>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
80538>>>>>>>        Function_Return False
80539>>>>>>>    End_Function  
80540>>>>>>>    
80540>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
80540>>>>>>>    // for an SQL conversion.
80540>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
80542>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
80542>>>>>>>        
80542>>>>>>>        Move True to bConvertTo30FormatbOK
80543>>>>>>>        Move True to bRepairAndReindexOK
80544>>>>>>>        Move True to bFixBogusDatesOK
80545>>>>>>>        Move True to bMoveMiscFilesToBackupOK
80546>>>>>>>        
80546>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
80548>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
80549>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
80550>>>>>>>        End                                                                                
80550>>>>>>>>
80550>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
80552>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
80553>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
80554>>>>>>>        End
80554>>>>>>>>
80554>>>>>>>        If (bConvertTo30Format = True) Begin
80556>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
80557>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
80558>>>>>>>        End                                                 
80558>>>>>>>>
80558>>>>>>>        If (bRepairAndReindex = True) Begin
80560>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
80561>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
80562>>>>>>>        End  
80562>>>>>>>>
80562>>>>>>>        If (bFixBogusDates = True) Begin
80564>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
80565>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
80566>>>>>>>        End                                    
80566>>>>>>>>
80566>>>>>>>        
80566>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
80567>>>>>>>    End_Function
80568>>>>>>>
80568>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
80570>>>>>>>        Boolean bOK bFlexErrs bTemp
80570>>>>>>>        Handle hTable
80570>>>>>>>        String sTableName
80570>>>>>>>        Integer iCount iSize
80570>>>>>>>        
80570>>>>>>>        Move True to bOK
80571>>>>>>>        Move 0 to hTable    
80572>>>>>>>
80572>>>>>>>        Get UtilFilelistNoOfTables to iSize
80573>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
80574>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
80575>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
80576>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
80577>>>>>>>
80577>>>>>>>        Repeat
80577>>>>>>>>
80577>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
80578>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
80579>>>>>>>            Increment iCount
80580>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
80583>>>>>>>            If (hTable > 0) Begin
80585>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
80588>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
80589>>>>>>>                If (bFlexErrs = False) Begin
80591>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
80592>>>>>>>                    If (bTemp = False) Begin
80594>>>>>>>                        Move False to bOK
80595>>>>>>>                    End
80595>>>>>>>>
80595>>>>>>>                End
80595>>>>>>>>
80595>>>>>>>            End
80595>>>>>>>>
80595>>>>>>>        Until (hTable = 0)
80597>>>>>>>        
80597>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80598>>>>>>>        Function_Return bOK
80599>>>>>>>    End_Function
80600>>>>>>>    
80600>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
80600>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
80600>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
80600>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
80602>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
80602>>>>>>>        String sRevision
80602>>>>>>>        
80602>>>>>>>        Get AutoConnectionIDLogin to bOK
80603>>>>>>>        If (bOK = False) Begin
80605>>>>>>>            Function_Return True
80606>>>>>>>        End
80606>>>>>>>>
80606>>>>>>>        Get OpenTableExclusive hTable to bOK
80607>>>>>>>        If (bOK = False) Begin
80609>>>>>>>            Function_Return True
80610>>>>>>>        End
80610>>>>>>>>
80610>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
80611>>>>>>>        If (bIsEmbedded = False) Begin
80613>>>>>>>            Function_Return True
80614>>>>>>>        End                             
80614>>>>>>>>
80614>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
80615>>>>>>>        If (bIsAlias = True) Begin
80617>>>>>>>            Function_Return True
80618>>>>>>>        End                     
80618>>>>>>>>
80618>>>>>>>        
80618>>>>>>>        Move False to Err
80619>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
80622>>>>>>>        If (sRevision contains "2.3") Begin
80624>>>>>>>            Move False to Err
80625>>>>>>>            Set Private.phCurrentTable to hTable
80626>>>>>>>            Structure_Start hTable    
80627>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
80630>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
80631>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
80633>>>>>>>            Set Action_Text of ghoStatusPanel to ""
80634>>>>>>>        End
80634>>>>>>>>
80634>>>>>>>        
80634>>>>>>>        Function_Return (Err = False)
80635>>>>>>>    End_Function
80636>>>>>>>
80636>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
80638>>>>>>>        Boolean bIgnore bExists bOK bResponse
80638>>>>>>>        Handle hTable   
80638>>>>>>>        String sTableName
80638>>>>>>>        
80638>>>>>>>        Move False to Err 
80639>>>>>>>        Move True to bOK
80640>>>>>>>        Move 0 to hTable
80641>>>>>>>        Repeat
80641>>>>>>>>
80641>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
80644>>>>>>>            If (hTable > 0) Begin
80646>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
80649>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
80650>>>>>>>                If (bIgnore = False) Begin
80652>>>>>>>                    Get UtilTableExists hTable to bExists
80653>>>>>>>                    If (bExists = False) Begin
80655>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
80656>>>>>>>                        If (bResponse = False) Begin
80658>>>>>>>                            Move False to bOK
80659>>>>>>>                        End
80659>>>>>>>>
80659>>>>>>>                        
80659>>>>>>>                    End
80659>>>>>>>>
80659>>>>>>>                End
80659>>>>>>>>
80659>>>>>>>            End
80659>>>>>>>>
80659>>>>>>>        Until (hTable = 0)                     
80661>>>>>>>        
80661>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
80662>>>>>>>        Function_Return bOK
80663>>>>>>>    End_Function
80664>>>>>>>    
80664>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
80664>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
80664>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
80664>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
80664>>>>>>>    //
80664>>>>>>>    // The root of the problem is the following:
80664>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
80664>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
80664>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
80664>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
80664>>>>>>>    // an SQL error will be thrown;
80664>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
80664>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
80666>>>>>>>        Boolean bOK bIsAlias bIsSQL
80666>>>>>>>        Integer iCount iSize iDateSize
80666>>>>>>>        Handle hTable
80666>>>>>>>        String sLogicalName
80666>>>>>>>        Integer[] aTablesToCheck aDateFields
80668>>>>>>>
80668>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
80669>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
80670>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
80671>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
80672>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
80673>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
80674>>>>>>>
80674>>>>>>>        Move True to bOK
80675>>>>>>>        Decrement iSize
80676>>>>>>>        for iCount from 0 to iSize
80682>>>>>>>>
80682>>>>>>>            Move aTablesToCheck[iCount] to hTable
80683>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
80684>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
80685>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
80686>>>>>>>
80686>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
80689>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
80690>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
80691>>>>>>>
80691>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
80693>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
80694>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
80695>>>>>>>                If (iDateSize > 0) Begin
80697>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
80698>>>>>>>                    Close hTable
80699>>>>>>>                End
80699>>>>>>>>
80699>>>>>>>            End
80699>>>>>>>>
80699>>>>>>>        Loop
80700>>>>>>>>
80700>>>>>>>
80700>>>>>>>        Close DF_ALL
80701>>>>>>>        Function_Return bOK
80702>>>>>>>    End_Function
80703>>>>>>>
80703>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
80703>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
80705>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
80707>>>>>>>        Integer iSize iCount iType
80707>>>>>>>        Boolean bOpen bOK
80707>>>>>>>        
80707>>>>>>>        Get UtilTableExists hTable to bOK
80708>>>>>>>        If (bOK = False) Begin
80710>>>>>>>            Set Private.phCurrentTable to hTable
80711>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
80712>>>>>>>>
80712>>>>>>>            Function_Return aDateFieldsEmpty
80713>>>>>>>        End
80713>>>>>>>>
80713>>>>>>>        Set Private.phCurrentTable to hTable
80714>>>>>>>        Set Private.piCurrentField to 0
80715>>>>>>>
80715>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80715>>>>>>>        Open hTable
80717>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
80720>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
80720>>>>>>>        If (bOpen = False) Begin
80722>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
80722>>>>>>>            Function_Return aDateFieldsEmpty
80723>>>>>>>        End
80723>>>>>>>>
80723>>>>>>>
80723>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
80726>>>>>>>        For iCount from 1 to iSize
80732>>>>>>>>
80732>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
80735>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
80737>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
80738>>>>>>>            End
80738>>>>>>>>
80738>>>>>>>        Loop
80739>>>>>>>>
80739>>>>>>>
80739>>>>>>>        Function_Return aDateFields
80740>>>>>>>    End_Function
80741>>>>>>>
80741>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
80741>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
80741>>>>>>>    // and the record is saved
80741>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
80741>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
80741>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
80743>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
80743>>>>>>>        String sDriverID sDateMin
80743>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
80743>>>>>>>        Date dDate dDateMin
80743>>>>>>>        Integer[] iaChangeField
80744>>>>>>>
80744>>>>>>>        Get UtilTableExists hTable to bOK
80745>>>>>>>        // I believe we should just skip files not found and not report an error.
80745>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
80745>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
80745>>>>>>>        // Especially considering that this call is probably done at the very
80745>>>>>>>        // beginning of a DUF update.
80745>>>>>>>        If (bOK = False) Begin
80747>>>>>>>//            Set Private.phCurrentTable to hTable
80747>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
80747>>>>>>>//            Function_Return False
80747>>>>>>>            Function_Return True
80748>>>>>>>        End
80748>>>>>>>>
80748>>>>>>>
80748>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
80748>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
80748>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
80751>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
80754>>>>>>>
80754>>>>>>>//        Send SetAllIndexesToBatch hTable True
80754>>>>>>>        Open hTable
80756>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
80759>>>>>>>        If (bOpened = False) Begin
80761>>>>>>>            Function_Return False
80762>>>>>>>        End
80762>>>>>>>>
80762>>>>>>>        
80762>>>>>>>        Set Private.phCurrentTable to hTable
80763>>>>>>>        Move 0 to iRecord
80764>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
80765>>>>>>>        Decrement iSize
80766>>>>>>>
80766>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
80769>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
80770>>>>>>>        If (iDriverIndex <> 0) Begin
80772>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
80775>>>>>>>            If (sDateMin = "") Begin
80777>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
80778>>>>>>>            End
80778>>>>>>>>
80778>>>>>>>            Else Begin
80779>>>>>>>                If (IsDate(sDateMin)) Begin
80781>>>>>>>                    Move sDateMin to dDateMin
80782>>>>>>>                End
80782>>>>>>>>
80782>>>>>>>                Else Begin
80783>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
80784>>>>>>>                End
80784>>>>>>>>
80784>>>>>>>            End
80784>>>>>>>>
80784>>>>>>>        End
80784>>>>>>>>
80784>>>>>>>        Else Begin
80785>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
80786>>>>>>>        End
80786>>>>>>>>
80786>>>>>>>
80786>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
80789>>>>>>>        Set piPosition   of ghoProgressBar to 0
80790>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
80791>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
80792>>>>>>>        Move False to Err
80793>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80794>>>>>>>
80794>>>>>>>        Clear hTable
80795>>>>>>>        Repeat
80795>>>>>>>>
80795>>>>>>>            Vfind hTable 0 GT
80797>>>>>>>            Move Found to bFound
80798>>>>>>>            If (bFound = True) Begin
80800>>>>>>>                Move False to bSaveChanges
80801>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
80802>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
80803>>>>>>>                Decrement iSize
80804>>>>>>>                For iCount from 0 to iSize
80810>>>>>>>>
80810>>>>>>>                    Move aDateFields[iCount] to iField
80811>>>>>>>                    Get_Field_Value hTable iField to dDate
80814>>>>>>>                    If (bFixZeroDates = True) Begin
80816>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
80817>>>>>>>                    End
80817>>>>>>>>
80817>>>>>>>                    Else Begin
80818>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
80819>>>>>>>                    End
80819>>>>>>>>
80819>>>>>>>                    If (bChange = True) Begin
80821>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
80822>>>>>>>                    End
80822>>>>>>>>
80822>>>>>>>                Loop
80823>>>>>>>>
80823>>>>>>>
80823>>>>>>>                // Only change Date fields that needs to be changed.
80823>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
80825>>>>>>>                    Reread hTable
80829>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
80830>>>>>>>                        Decrement iSize
80831>>>>>>>                        For iCount from 0 to iSize
80837>>>>>>>>
80837>>>>>>>                            Move iaChangeField[iCount] to iField
80838>>>>>>>                            Set Private.piCurrentField to iField
80839>>>>>>>                            Set_Field_Value hTable iField to dDateMin
80842>>>>>>>                        Loop
80843>>>>>>>>
80843>>>>>>>                        Move False to Err
80844>>>>>>>                        SaveRecord hTable
80845>>>>>>>                    Unlock
80846>>>>>>>>
80846>>>>>>>                End
80846>>>>>>>>
80846>>>>>>>
80846>>>>>>>                Increment iRecord
80847>>>>>>>                // Increment the StatusPanel counter and check the
80847>>>>>>>                // cancel status every 100 records rather than every
80847>>>>>>>                // record, it's way faster.
80847>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
80849>>>>>>>                    Send DoAdvance of ghoProgressBar
80850>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
80851>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
80852>>>>>>>                End
80852>>>>>>>>
80852>>>>>>>            End
80852>>>>>>>>
80852>>>>>>>        Until (bFound = False)
80854>>>>>>>
80854>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
80857>>>>>>>        If (bResetIndexesToOnLine = True) Begin
80859>>>>>>>            Send SetAllIndexesToBatch hTable False
80860>>>>>>>        End
80860>>>>>>>>
80860>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80861>>>>>>>
80861>>>>>>>        Function_Return (Err = False)
80862>>>>>>>    End_Function
80863>>>>>>>
80863>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80863>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80863>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
80865>>>>>>>        Boolean bIsSame
80865>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
80865>>>>>>>
80865>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
80866>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
80867>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
80868>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
80869>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
80870>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
80871>>>>>>>
80871>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80873>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
80874>>>>>>>        End
80874>>>>>>>>
80874>>>>>>>        Else Begin
80875>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
80876>>>>>>>        End
80876>>>>>>>>
80876>>>>>>>        If (bIsSame = False) Begin
80878>>>>>>>            Function_Return False
80879>>>>>>>        End
80879>>>>>>>>
80879>>>>>>>
80879>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
80880>>>>>>>        If (bIsSame = False) Begin
80882>>>>>>>            Function_Return False
80883>>>>>>>        End
80883>>>>>>>>
80883>>>>>>>
80883>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
80884>>>>>>>        If (bIsSame = False) Begin
80886>>>>>>>            Function_Return False
80887>>>>>>>        End
80887>>>>>>>>
80887>>>>>>>
80887>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
80888>>>>>>>        If (bIsSame = False) Begin
80890>>>>>>>            Function_Return False
80891>>>>>>>        End
80891>>>>>>>>
80891>>>>>>>
80891>>>>>>>        Function_Return bIsSame
80892>>>>>>>    End_Function
80893>>>>>>>
80893>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
80895>>>>>>>        Handle hTableFrom hTableTo
80895>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
80895>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
80895>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
80895>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
80895>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
80896>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
80896>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
80897>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
80897>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
80898>>>>>>>
80898>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
80899>>>>>>>        If (bIsSame = True) Begin
80901>>>>>>>            Function_Return True
80902>>>>>>>        End
80902>>>>>>>>
80902>>>>>>>
80902>>>>>>>        Move False to bFilelistError
80903>>>>>>>        Move True to bIsSame
80904>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
80905>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
80906>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
80907>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
80908>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
80909>>>>>>>
80909>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
80910>>>>>>>        Get _TableNameOnly sRootName             to sRootName
80911>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
80912>>>>>>>
80912>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
80912>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
80912>>>>>>>        If (bCodeGenerateMode = True) Begin
80914>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
80914>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
80916>>>>>>>                Function_Return False
80917>>>>>>>            End
80917>>>>>>>>
80917>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
80918>>>>>>>            If (bIsSame = False) Begin
80920>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
80921>>>>>>>                Move True to bFilelistError
80922>>>>>>>                Function_Return False
80923>>>>>>>            End
80923>>>>>>>>
80923>>>>>>>        End
80923>>>>>>>>
80923>>>>>>>
80923>>>>>>>        If (bCodeGenerateMode = False) Begin
80925>>>>>>>            // Then we want to create this table
80925>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
80927>>>>>>>                Function_Return False
80928>>>>>>>            End
80928>>>>>>>>
80928>>>>>>>
80928>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
80929>>>>>>>            If (bIsSame = False) Begin
80931>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
80932>>>>>>>>
80932>>>>>>>                Move True to bFilelistError
80933>>>>>>>                Function_Return False
80934>>>>>>>            End
80934>>>>>>>>
80934>>>>>>>        End
80934>>>>>>>>
80934>>>>>>>
80934>>>>>>>        // Check columns:
80934>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
80935>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
80936>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
80937>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
80938>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
80939>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
80940>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
80941>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
80942>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
80943>>>>>>>        If (bIsSame = False) Begin
80945>>>>>>>            Function_Return False
80946>>>>>>>        End
80946>>>>>>>>
80946>>>>>>>
80946>>>>>>>        // ...then check indexes:
80946>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
80947>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
80948>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
80949>>>>>>>        If (bIsSame = False) Begin
80951>>>>>>>            Function_Return False
80952>>>>>>>        End
80952>>>>>>>>
80952>>>>>>>
80952>>>>>>>        // ...and finally relationships:
80952>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
80953>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
80954>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
80955>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
80956>>>>>>>
80956>>>>>>>        Function_Return (bIsSame = True)
80957>>>>>>>    End_Function
80958>>>>>>>
80958>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
80958>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
80960>>>>>>>        Handle hTable
80960>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
80960>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
80960>>>>>>>
80960>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
80962>>>>>>>            Move True to bFilelistError
80963>>>>>>>            Function_Return False
80964>>>>>>>        End
80964>>>>>>>>
80964>>>>>>>
80964>>>>>>>        Move APITableCompare.hTable to hTable
80965>>>>>>>        Move True  to bIsSame
80966>>>>>>>        Move False to bFilelistError
80967>>>>>>>
80967>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
80969>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
80970>>>>>>>        End
80970>>>>>>>>
80970>>>>>>>        Else Begin
80971>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
80972>>>>>>>        End
80972>>>>>>>>
80972>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
80973>>>>>>>
80973>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
80974>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
80975>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
80976>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
80977>>>>>>>
80977>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
80977>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
80977>>>>>>>        If (bCodeGenerateMode = True) Begin
80979>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
80979>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
80981>>>>>>>                Function_Return False
80982>>>>>>>            End
80982>>>>>>>>
80982>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
80983>>>>>>>            If (bIsSame = False) Begin
80985>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
80986>>>>>>>                Move True to bFilelistError
80987>>>>>>>                Function_Return False
80988>>>>>>>            End
80988>>>>>>>>
80988>>>>>>>        End
80988>>>>>>>>
80988>>>>>>>
80988>>>>>>>        If (bCodeGenerateMode = False) Begin
80990>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
80992>>>>>>>                // Then we might want to create this table
80992>>>>>>>                Function_Return False
80993>>>>>>>            End
80993>>>>>>>>
80993>>>>>>>
80993>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
80994>>>>>>>            If (bIsSame = False) Begin
80996>>>>>>>                Function_Return False
80997>>>>>>>            End
80997>>>>>>>>
80997>>>>>>>
80997>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
80998>>>>>>>            If (bIsSame = False) Begin
81000>>>>>>>                Function_Return False
81001>>>>>>>            End
81001>>>>>>>>
81001>>>>>>>
81001>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
81002>>>>>>>            If (bIsSame = False) Begin
81004>>>>>>>                Function_Return False
81005>>>>>>>            End
81005>>>>>>>>
81005>>>>>>>
81005>>>>>>>            // Check table names et al.
81005>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
81006>>>>>>>            If (bIsSame = False) Begin
81008>>>>>>>                Function_Return False
81009>>>>>>>            End
81009>>>>>>>>
81009>>>>>>>        End
81009>>>>>>>>
81009>>>>>>>
81009>>>>>>>        // Check Columns:
81009>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
81010>>>>>>>        If (bIsSame = False) Begin
81012>>>>>>>            Function_Return False
81013>>>>>>>        End
81013>>>>>>>>
81013>>>>>>>
81013>>>>>>>        // ...then check Indexes:
81013>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
81014>>>>>>>        If (bIsSame = False) Begin
81016>>>>>>>            Function_Return False
81017>>>>>>>        End
81017>>>>>>>>
81017>>>>>>>
81017>>>>>>>        // ...and finally Relationships:
81017>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
81018>>>>>>>
81018>>>>>>>        Function_Return (bIsSame = True)
81019>>>>>>>    End_Function
81020>>>>>>>
81020>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
81020>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
81020>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
81020>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
81020>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
81022>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81022>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81022>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
81022>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
81024>>>>>>>        tAPIColumn[]    aApiColumns
81024>>>>>>>        tAPIColumn[]    aApiColumns
81025>>>>>>>        tAPIIndex[]     aApiIndexes
81025>>>>>>>        tAPIIndex[]     aApiIndexes
81026>>>>>>>        tAPIRelation[]  aApiRelations
81026>>>>>>>        tAPIRelation[]  aApiRelations
81027>>>>>>>        Handle hTable
81027>>>>>>>        Integer iCount
81027>>>>>>>        Boolean bUserCancel bOK
81027>>>>>>>        String sLogicalName sMessageText
81027>>>>>>>
81027>>>>>>>        Get AutoConnectionIDLogin to bOK
81028>>>>>>>        Move 0 to hTable
81029>>>>>>>        If (bFromTables = True) Begin
81031>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
81032>>>>>>>            If (bCompareUtil = True) Begin
81034>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
81035>>>>>>>            End
81035>>>>>>>>
81035>>>>>>>        End
81035>>>>>>>>
81035>>>>>>>        Else Begin
81036>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
81037>>>>>>>            If (bCompareUtil = True) Begin
81039>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
81040>>>>>>>            End
81040>>>>>>>>
81040>>>>>>>        End
81040>>>>>>>>
81040>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
81041>>>>>>>
81041>>>>>>>        Get UtilFilelistNoOfTables to iCount
81042>>>>>>>        Set piMaximum of ghoProgressBar to iCount
81043>>>>>>>        Move 0 to iCount
81044>>>>>>>
81044>>>>>>>        Repeat
81044>>>>>>>>
81044>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81047>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
81049>>>>>>>
81049>>>>>>>                Open hTable
81051>>>>>>>                // ToDo: Needs to be revised
81051>>>>>>>                // For some reason tables may be reported as "unopened", while in
81051>>>>>>>                // fact the open was successful (!)
81051>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81051>>>>>>>//                If (bIsOpen = False) Begin
81051>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
81051>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
81051>>>>>>>//                    Function_Return aApiTablesEmpty
81051>>>>>>>//                End
81051>>>>>>>
81051>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81054>>>>>>>                Set piPosition of ghoProgressBar to iCount
81055>>>>>>>                Send DoAdvance of ghoProgressBarOverall
81056>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
81057>>>>>>>
81057>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
81058>>>>>>>//                Close hTable DF_PERMANENT
81058>>>>>>>                Increment iCount
81059>>>>>>>            End
81059>>>>>>>>
81059>>>>>>>
81059>>>>>>>            If (bStatusPanel = True) Begin
81061>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
81062>>>>>>>                If (bUserCancel = True) Begin
81064>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
81065>>>>>>>                    Function_Return aApiTablesEmpty
81066>>>>>>>                End
81066>>>>>>>>
81066>>>>>>>            End
81066>>>>>>>>
81066>>>>>>>
81066>>>>>>>        Until (hTable = 0)
81068>>>>>>>
81068>>>>>>>        Function_Return aApiTables
81069>>>>>>>    End_Function
81070>>>>>>>
81070>>>>>>>    // Returns a 'single' table APITable struct.
81070>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
81072>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81072>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81072>>>>>>>        tAPITable         ApiTable ApiTableEmpty
81072>>>>>>>        tAPITable         ApiTable ApiTableEmpty
81072>>>>>>>        tAPIColumn[]     aApiColumns
81072>>>>>>>        tAPIColumn[]     aApiColumns
81073>>>>>>>        tAPIIndex[]      aApiIndexes
81073>>>>>>>        tAPIIndex[]      aApiIndexes
81074>>>>>>>        tAPIRelation[]   aApiRelations
81074>>>>>>>        tAPIRelation[]   aApiRelations
81075>>>>>>>        Boolean bIsOpen
81075>>>>>>>
81075>>>>>>>        Open hTable
81077>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81080>>>>>>>        If (bIsOpen = False) Begin
81082>>>>>>>            Move True to ApiTableEmpty.bError
81083>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
81084>>>>>>>            Function_Return ApiTableEmpty
81085>>>>>>>        End
81085>>>>>>>>
81085>>>>>>>
81085>>>>>>>        // Fill Table Name Info
81085>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
81086>>>>>>>
81086>>>>>>>        // Fill columns
81086>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
81087>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
81089>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
81091>>>>>>>                Move True to ApiTableEmpty.bError
81092>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
81093>>>>>>>                Function_Return ApiTableEmpty
81094>>>>>>>            End
81094>>>>>>>>
81094>>>>>>>        End
81094>>>>>>>>
81094>>>>>>>
81094>>>>>>>        // Fill indexes
81094>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
81095>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
81097>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
81099>>>>>>>                Move True to ApiTableEmpty.bError
81100>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
81101>>>>>>>                Function_Return ApiTableEmpty
81102>>>>>>>            End
81102>>>>>>>>
81102>>>>>>>        End
81102>>>>>>>>
81102>>>>>>>
81102>>>>>>>        // Fill relationships
81102>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
81103>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
81105>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
81107>>>>>>>                Move True to ApiTableEmpty.bError
81108>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
81109>>>>>>>                Function_Return ApiTableEmpty
81110>>>>>>>            End
81110>>>>>>>>
81110>>>>>>>        End
81110>>>>>>>>
81110>>>>>>>
81110>>>>>>>        Move hTable             to ApiTable.hTable
81111>>>>>>>        Move bFromTables        to ApiTable.bFromTable
81112>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
81113>>>>>>>
81113>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
81114>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
81115>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
81116>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
81117>>>>>>>
81117>>>>>>>        Function_Return ApiTable
81118>>>>>>>    End_Function
81119>>>>>>>
81119>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
81121>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
81121>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
81121>>>>>>>        Boolean bIsOpen
81121>>>>>>>
81121>>>>>>>        Open hTable
81123>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81126>>>>>>>        If (bIsOpen = False) Begin
81128>>>>>>>            Move True   to APITableNameInfoEmpty.bError
81129>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
81130>>>>>>>            Function_Return APITableNameInfoEmpty
81131>>>>>>>        End
81131>>>>>>>>
81131>>>>>>>
81131>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
81132>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
81135>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
81138>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
81141>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
81144>>>>>>>
81144>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
81145>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
81146>>>>>>>
81146>>>>>>>        Function_Return APITableNameInfo
81147>>>>>>>    End_Function
81148>>>>>>>
81148>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
81150>>>>>>>        Integer iSize iCount iItem
81150>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81150>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81150>>>>>>>
81150>>>>>>>        Move -1 to iItem
81151>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
81152>>>>>>>        Decrement iSize
81153>>>>>>>        for iCount from 0 to iSize
81159>>>>>>>>
81159>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
81160>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
81162>>>>>>>                Move iCount to iItem
81163>>>>>>>                Move iSize  to iCount // We're done.
81164>>>>>>>            End
81164>>>>>>>>
81164>>>>>>>        Loop
81165>>>>>>>>
81165>>>>>>>
81165>>>>>>>        Function_Return iItem
81166>>>>>>>    End_Function
81167>>>>>>>
81167>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
81169>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
81172>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
81175>>>>>>>
81175>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
81178>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
81181>>>>>>>
81181>>>>>>>        Function_Return (EQ)
81182>>>>>>>    End_Function
81183>>>>>>>
81183>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
81185>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
81185>>>>>>>        Handle hTable
81185>>>>>>>        tAPITable[] aAPITableFromAndTo
81185>>>>>>>        tAPITable[] aAPITableFromAndTo
81186>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
81186>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
81186>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
81186>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
81186>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
81186>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
81187>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
81187>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
81188>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
81188>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
81189>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
81189>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
81190>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
81190>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
81190>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
81190>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
81193>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
81193>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
81196>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
81196>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
81199>>>>>>>
81199>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
81200>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
81201>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
81203>>>>>>>            Function_Return aAPITableCompare
81204>>>>>>>        End
81204>>>>>>>>
81204>>>>>>>
81204>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
81205>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
81206>>>>>>>
81206>>>>>>>        Move 0 to iItem
81207>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
81208>>>>>>>        Decrement iSize
81209>>>>>>>        for iCount from 0 to iSize
81215>>>>>>>>
81215>>>>>>>
81215>>>>>>>            Move iCount to iItemFrom
81216>>>>>>>            Move iCount to iItemTo
81217>>>>>>>            Move APITableEmpty to APITableFrom
81218>>>>>>>            Move APITableEmpty to APITableTo
81219>>>>>>>
81219>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
81221>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
81222>>>>>>>            End
81222>>>>>>>>
81222>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
81224>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
81225>>>>>>>            End
81225>>>>>>>>
81225>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
81227>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
81228>>>>>>>                Move (iCount + 1) to iItemTo
81229>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
81230>>>>>>>            End
81230>>>>>>>>
81230>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
81232>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
81233>>>>>>>                If (iItemTo <> -1) Begin
81235>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
81236>>>>>>>                End
81236>>>>>>>>
81236>>>>>>>                Else Begin
81237>>>>>>>                    Move APITableEmpty to APITableTo
81238>>>>>>>                End
81238>>>>>>>>
81238>>>>>>>            End
81238>>>>>>>>
81238>>>>>>>
81238>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
81239>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
81240>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
81241>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
81242>>>>>>>
81242>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
81243>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
81244>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
81245>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
81246>>>>>>>
81246>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
81247>>>>>>>
81247>>>>>>>            If (hTable > 0) Begin
81249>>>>>>>
81249>>>>>>>                // Table info:
81249>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
81250>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
81251>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
81252>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
81253>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
81254>>>>>>>
81254>>>>>>>                // Column info:
81254>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
81255>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
81256>>>>>>>
81256>>>>>>>                // Index info:
81256>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
81257>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
81258>>>>>>>
81258>>>>>>>                // Relation info:
81258>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
81259>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
81260>>>>>>>
81260>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
81261>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
81262>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
81263>>>>>>>                If (iItemTo > iItemFrom) Begin
81265>>>>>>>                    Increment iCount
81266>>>>>>>                End
81266>>>>>>>>
81266>>>>>>>                Increment iItem
81267>>>>>>>            End
81267>>>>>>>>
81267>>>>>>>
81267>>>>>>>        Loop
81268>>>>>>>>
81268>>>>>>>
81268>>>>>>>        Function_Return aAPITableCompare
81269>>>>>>>    End_Function
81270>>>>>>>
81270>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
81272>>>>>>>        Integer iSize iCount iItem
81272>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81272>>>>>>>        tAPITableNameInfo ApiTableNameInfo
81272>>>>>>>
81272>>>>>>>        Move -1 to iItem
81273>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
81274>>>>>>>        Decrement iSize
81275>>>>>>>        For iCount from 0 to iSize
81281>>>>>>>>
81281>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
81282>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
81284>>>>>>>                Move iCount to iItem
81285>>>>>>>                Move iSize  to iCount // We're done.
81286>>>>>>>            End
81286>>>>>>>>
81286>>>>>>>        Loop
81287>>>>>>>>
81287>>>>>>>
81287>>>>>>>        Function_Return iItem
81288>>>>>>>    End_Function
81289>>>>>>>
81289>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
81291>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
81291>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
81291>>>>>>>
81291>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
81293>>>>>>>            Function_Return APITableNameInfoCompare
81294>>>>>>>        End
81294>>>>>>>>
81294>>>>>>>
81294>>>>>>>        // FROM database info:
81294>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
81296>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
81297>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
81298>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
81299>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
81300>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
81301>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
81302>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
81303>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
81304>>>>>>>        End
81304>>>>>>>>
81304>>>>>>>
81304>>>>>>>        // TO database info:
81304>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
81306>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
81307>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
81308>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
81309>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
81310>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
81311>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
81312>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
81313>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
81314>>>>>>>        End
81314>>>>>>>>
81314>>>>>>>
81314>>>>>>>        Function_Return APITableNameInfoCompare
81315>>>>>>>    End_Function
81316>>>>>>>
81316>>>>>>>    // Note:
81316>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
81316>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
81316>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
81316>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
81316>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
81316>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
81318>>>>>>>        String sTableName
81318>>>>>>>        Boolean bOpen bExists bOK
81318>>>>>>>
81318>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
81319>>>>>>>        If (bExists = False) Begin
81321>>>>>>>            Function_Return ""
81322>>>>>>>        End
81322>>>>>>>>
81322>>>>>>>
81322>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81323>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
81326>>>>>>>        If (bOpen = False) Begin
81328>>>>>>>            Get AutoConnectionIDLogin to bOK
81329>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81330>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
81331>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
81332>>>>>>>            Open hTable
81334>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81335>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
81336>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
81337>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
81340>>>>>>>        End
81340>>>>>>>>
81340>>>>>>>        If (bOpen = True) Begin
81342>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
81343>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
81346>>>>>>>            // If blank it is an embedded table:
81346>>>>>>>            If (sTableName = "") Begin
81348>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
81351>>>>>>>                Move 0 to LastErr
81352>>>>>>>                Move False to Err
81353>>>>>>>            End
81353>>>>>>>>
81353>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
81354>>>>>>>        End
81354>>>>>>>>
81354>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81355>>>>>>>        Move 0 to LastErr
81356>>>>>>>
81356>>>>>>>        Function_Return sTableName
81357>>>>>>>    End_Function
81358>>>>>>>
81358>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
81358>>>>>>>    // Returns 0 if unsuccessful.
81358>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
81358>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
81360>>>>>>>        String sValue sPrefixTableName sDriverID
81360>>>>>>>        Handle hTable hRetval
81360>>>>>>>
81360>>>>>>>        Get psDriverID to sDriverID
81361>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
81363>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
81364>>>>>>>        End
81364>>>>>>>>
81364>>>>>>>        Move 0 to hTable
81365>>>>>>>        Move 0 to hRetval
81366>>>>>>>        Repeat
81366>>>>>>>>
81366>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81369>>>>>>>            If (hTable <> 0) Begin
81371>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
81374>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
81376>>>>>>>                    Move hTable to hRetval
81377>>>>>>>                    Move 0 to hTable
81378>>>>>>>                End
81378>>>>>>>>
81378>>>>>>>            End
81378>>>>>>>>
81378>>>>>>>        Until (hTable = 0)
81380>>>>>>>
81380>>>>>>>        Function_Return hRetval
81381>>>>>>>    End_Function
81382>>>>>>>
81382>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
81382>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
81382>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
81384>>>>>>>        Boolean bOK bExists
81384>>>>>>>        String sDataPath sBackupFolder
81384>>>>>>>
81384>>>>>>>        Close DF_ALL DF_PERMANENT
81385>>>>>>>        Send DoAdvance of ghoProgressBar
81386>>>>>>>
81386>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
81387>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
81388>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81389>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81390>>>>>>>
81390>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
81391>>>>>>>        If (bExists = False) Begin
81393>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
81394>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
81395>>>>>>>            If (bExists = False) Begin
81397>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
81398>>>>>>>>
81398>>>>>>>                Function_Return False
81399>>>>>>>            End
81399>>>>>>>>
81399>>>>>>>        End
81399>>>>>>>>
81399>>>>>>>
81399>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
81400>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
81401>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
81402>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
81403>>>>>>>        // We need to wait for Windows before we can copy files back
81403>>>>>>>        Sleep 2  
81404>>>>>>>        
81404>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
81404>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
81405>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
81406>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
81407>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
81408>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
81409>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
81410>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
81410>>>>>>>        
81410>>>>>>>
81410>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81411>>>>>>>        Function_Return True
81412>>>>>>>    End_Function
81413>>>>>>>    
81413>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
81415>>>>>>>        Boolean bOK bRetval
81415>>>>>>>        Handle hTable
81415>>>>>>>        Integer iSize iCount
81415>>>>>>>        
81415>>>>>>>        Move True to bOK
81416>>>>>>>        Get UtilFilelistNoOfTables to iSize
81417>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
81418>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
81419>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
81420>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
81421>>>>>>>
81421>>>>>>>        Repeat
81421>>>>>>>>
81421>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
81422>>>>>>>            Increment iCount
81423>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81426>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
81428>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
81429>>>>>>>                If (bRetval = False) Begin
81431>>>>>>>                    Move False to bOK
81432>>>>>>>                End
81432>>>>>>>>
81432>>>>>>>            End
81432>>>>>>>>
81432>>>>>>>        Until (hTable = 0)
81434>>>>>>>                
81434>>>>>>>        Function_Return bOK
81435>>>>>>>    End_Function           
81436>>>>>>>    
81436>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
81436>>>>>>>    // After the header has been repaired - also makes a re-index.  
81436>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
81436>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
81438>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
81438>>>>>>>        Integer iRetval
81438>>>>>>>        String sRootName sFileName sDataPath
81438>>>>>>>        
81438>>>>>>>        Move False to Err
81439>>>>>>>        Move 0 to LastErr 
81440>>>>>>>        Move True to bOK
81441>>>>>>>        
81441>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
81442>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
81444>>>>>>>            Function_Return True
81445>>>>>>>        End
81445>>>>>>>>
81445>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
81446>>>>>>>        If (bIsAlias = True) Begin
81448>>>>>>>            Function_Return True
81449>>>>>>>        End
81449>>>>>>>>
81449>>>>>>>        
81449>>>>>>>        // Check for bad file and remove if exists
81449>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81452>>>>>>>        Set private.phCurrentTable to hTable  
81453>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
81454>>>>>>>        
81454>>>>>>>        // This is important! Else it can happen that the table can't be opened,
81454>>>>>>>        // with a "4077 - File in use" error.
81454>>>>>>>        Close DF_ALL DF_PERMANENT    
81455>>>>>>>        Open hTable
81457>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81460>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81461>>>>>>>        If (bIsOpen = False) Begin
81463>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
81464>>>>>>>>
81464>>>>>>>            Function_Return False        
81465>>>>>>>        End
81465>>>>>>>>
81465>>>>>>>
81465>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
81466>>>>>>>        If (bBadExists = True) Begin
81468>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
81469>>>>>>>            Get vDeleteFile sFileName to iRetval
81470>>>>>>>        End
81470>>>>>>>>
81470>>>>>>>        
81470>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
81471>>>>>>>        
81471>>>>>>>        Move False to Err
81472>>>>>>>        // **** Repair and reindex the table. ****
81472>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
81473>>>>>>>
81473>>>>>>>        // Check for bad file: if it exists, something went wrong
81473>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81474>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81475>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
81476>>>>>>>        If (bBadExists = True) Begin
81478>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
81479>>>>>>>>
81479>>>>>>>            Move False to bOK
81480>>>>>>>        End
81480>>>>>>>>
81480>>>>>>>        Close hTable
81481>>>>>>>
81481>>>>>>>        Function_Return bOK
81482>>>>>>>    End_Function
81483>>>>>>>
81483>>>>>>>    // Repair and reindex the named DataFlex data-table.
81483>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
81483>>>>>>>    // so use with care (make sure you only pass embedded table names).
81483>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
81485>>>>>>>        String sMode
81485>>>>>>>        Integer iVoid
81485>>>>>>>
81485>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
81486>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
81487>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
81488>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
81493>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81494>>>>>>>        Function_Return (iVoid = 0)
81495>>>>>>>    End_Function
81496>>>>>>>
81496>>>>>>>    // Returns _two_ arrays.
81496>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
81496>>>>>>>    // Also returns all files that are Alias files in a second array.
81496>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
81496>>>>>>>    //            the DoSetAllMasterAndAlias message.
81496>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
81498>>>>>>>        Integer[] iaFileIsAlias
81499>>>>>>>        Integer hTable iFileAlias iSize
81499>>>>>>>        Boolean bOpen
81499>>>>>>>
81499>>>>>>>        Move 0 to hTable
81500>>>>>>>        Repeat
81500>>>>>>>>
81500>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81503>>>>>>>            If (hTable <> 0) Begin
81505>>>>>>>                Open hTable
81507>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
81510>>>>>>>                If (bOpen = True) Begin
81512>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
81515>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
81517>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
81518>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
81519>>>>>>>                    End
81519>>>>>>>>
81519>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
81522>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
81523>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
81524>>>>>>>                    End
81524>>>>>>>>
81524>>>>>>>                End
81524>>>>>>>>
81524>>>>>>>            End
81524>>>>>>>>
81524>>>>>>>        Until (hTable = 0)
81526>>>>>>>
81526>>>>>>>        Function_Return iaFileIsAlias
81527>>>>>>>    End_Function  
81528>>>>>>>    
81528>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
81528>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
81530>>>>>>>        String sMode
81530>>>>>>>        Integer iRepairNeeded bIsOpen
81530>>>>>>>
81530>>>>>>>        Move "0" to sMode
81531>>>>>>>        Set private.phCurrentTable to hTable 
81532>>>>>>>        Close hTable
81533>>>>>>>        Open hTable
81535>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81538>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
81543>>>>>>>
81543>>>>>>>        Function_Return iRepairNeeded
81544>>>>>>>    End_Function
81545>>>>>>>
81545>>>>>>>
81545>>>>>>>    // Helper function
81545>>>>>>>    // Takes two params:
81545>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
81545>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
81545>>>>>>>    // Returns:
81545>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
81545>>>>>>>    //  DF_FILE_IS_MASTER if master
81545>>>>>>>    //  DF_FILE_IS_ALIAS if alias
81545>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
81547>>>>>>>        Integer i iSize
81547>>>>>>>
81547>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
81548>>>>>>>        Decrement iSize
81549>>>>>>>        for i from 0 to iSize
81555>>>>>>>>
81555>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
81557>>>>>>>                Function_Return DF_FILE_IS_MASTER
81558>>>>>>>            End
81558>>>>>>>>
81558>>>>>>>        Loop
81559>>>>>>>>
81559>>>>>>>
81559>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
81560>>>>>>>        Decrement iSize
81561>>>>>>>        for i from 0 to iSize
81567>>>>>>>>
81567>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
81569>>>>>>>                Function_Return DF_FILE_IS_ALIAS
81570>>>>>>>            End
81570>>>>>>>>
81570>>>>>>>        Loop
81571>>>>>>>>
81571>>>>>>>
81571>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
81572>>>>>>>    End_Function
81573>>>>>>>
81573>>>>>>>    // Determine the available indexes of a table.
81573>>>>>>>    //
81573>>>>>>>    // Arguments:
81573>>>>>>>    //   Handle hTable - The number of the table
81573>>>>>>>    //
81573>>>>>>>    // Returns:
81573>>>>>>>    //   String - A string to be used with the sort command
81573>>>>>>>    //   to re-index all indexes of a table.
81573>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
81575>>>>>>>        String  sSortString
81575>>>>>>>        Integer iLastIndex iNumSegments iCount
81575>>>>>>>
81575>>>>>>>        Move "" to sSortString
81576>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
81579>>>>>>>
81579>>>>>>>        for iCount from 1 to iLastIndex
81585>>>>>>>>
81585>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
81588>>>>>>>            If iNumSegments Begin
81590>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
81593>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
81594>>>>>>>            End
81594>>>>>>>>
81594>>>>>>>        Loop
81595>>>>>>>>
81595>>>>>>>
81595>>>>>>>        Function_Return sSortString
81596>>>>>>>    End_Function
81597>>>>>>>
81597>>>>>>>    
81597>>>>>>>    // * Dummy function for the Studio's Code Explorer *
81597>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
81599>>>>>>>        Function_Return False
81600>>>>>>>    End_Function
81601>>>>>>>
81601>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
81601>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
81603>>>>>>>        Boolean bIsSame
81603>>>>>>>        Integer iCount iColumns iColumn
81603>>>>>>>
81603>>>>>>>        Move True to bIsSame
81604>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
81605>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
81606>>>>>>>        Decrement iColumns
81607>>>>>>>
81607>>>>>>>        for iCount from 0 to iColumns
81613>>>>>>>>
81613>>>>>>>            Set piPosition of ghoProgressBar to iCount
81614>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
81615>>>>>>>            If (bIsSame = False) Begin
81617>>>>>>>                Function_Return False
81618>>>>>>>            End
81618>>>>>>>>
81618>>>>>>>        Loop
81619>>>>>>>>
81619>>>>>>>
81619>>>>>>>        Function_Return (bIsSame = True)
81620>>>>>>>    End_Function
81621>>>>>>>
81621>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
81621>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
81623>>>>>>>        Integer iFromType iToType iDbType
81623>>>>>>>        tColumnType ColumnType
81623>>>>>>>        tColumnType ColumnType
81623>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
81623>>>>>>>
81623>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
81625>>>>>>>            Function_Return False
81626>>>>>>>        End
81626>>>>>>>>
81626>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
81628>>>>>>>            Function_Return False
81629>>>>>>>        End
81629>>>>>>>>
81629>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
81631>>>>>>>            Function_Return False
81632>>>>>>>        End                                                                
81632>>>>>>>>
81632>>>>>>>
81632>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
81634>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
81636>>>>>>>                Function_Return False
81637>>>>>>>            End
81637>>>>>>>>
81637>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
81639>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
81641>>>>>>>                    End
81641>>>>>>>>
81641>>>>>>>                Else Begin
81642>>>>>>>                    Function_Return False
81643>>>>>>>                End
81643>>>>>>>>
81643>>>>>>>            End
81643>>>>>>>>
81643>>>>>>>        End
81643>>>>>>>>
81643>>>>>>>
81643>>>>>>>        Get piDbType                       to iDbType
81644>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
81645>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
81646>>>>>>>
81646>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
81646>>>>>>>        // data types between Embedded and SQL.
81646>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
81648>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
81649>>>>>>>        End
81649>>>>>>>>
81649>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
81651>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
81652>>>>>>>        End
81652>>>>>>>>
81652>>>>>>>
81652>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
81653>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
81654>>>>>>>
81654>>>>>>>        // Make Date and DateTime comparison?
81654>>>>>>>        If (bCompareDate_DataTime = True) Begin
81656>>>>>>>            If (iFromType <> iToType) Begin
81658>>>>>>>                Function_Return False
81659>>>>>>>            End
81659>>>>>>>>
81659>>>>>>>        End
81659>>>>>>>>
81659>>>>>>>
81659>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
81659>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
81661>>>>>>>            If (iFromType <> iToType) Begin
81663>>>>>>>                Function_Return False
81664>>>>>>>            End
81664>>>>>>>>
81664>>>>>>>        End
81664>>>>>>>>
81664>>>>>>>
81664>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
81664>>>>>>>        If (bIsDateTypeFrom = False) Begin
81666>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
81668>>>>>>>                Function_Return False
81669>>>>>>>            End
81669>>>>>>>>
81669>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
81671>>>>>>>                Function_Return False
81672>>>>>>>            End
81672>>>>>>>>
81672>>>>>>>        End
81672>>>>>>>>
81672>>>>>>>
81672>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
81674>>>>>>>            Function_Return False
81675>>>>>>>        End
81675>>>>>>>>
81675>>>>>>>
81675>>>>>>>        Function_Return True
81676>>>>>>>    End_Function
81677>>>>>>>
81677>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
81679>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
81679>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
81679>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
81679>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
81681>>>>>>>        String sDriverID sRootName sLogicalName
81681>>>>>>>
81681>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81682>>>>>>>        Get piDbType to iDbType
81683>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81686>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81689>>>>>>>
81689>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81692>>>>>>>        If (bIsOpen = False) Begin
81694>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81695>>>>>>>            Open hTable
81697>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81698>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
81701>>>>>>>            If (bIsOpen = False) Begin
81703>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
81704>>>>>>>                Move True to APIColumnsEmpty[0].bError
81705>>>>>>>                Function_Return APIColumnsEmpty
81706>>>>>>>            End
81706>>>>>>>>
81706>>>>>>>        End
81706>>>>>>>>
81706>>>>>>>
81706>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
81709>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
81710>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
81711>>>>>>>
81711>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
81712>>>>>>>        If (bIsSqlTable = True) Begin
81714>>>>>>>            Get UtilTableExists hTable to bExists
81715>>>>>>>            If (bExists = False) Begin
81717>>>>>>>                Move True to APIColumnsEmpty[0].bError
81718>>>>>>>                Function_Return APIColumnsEmpty
81719>>>>>>>            End
81719>>>>>>>>
81719>>>>>>>        End
81719>>>>>>>>
81719>>>>>>>
81719>>>>>>>        Move 0 to iCount
81720>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
81723>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
81724>>>>>>>
81724>>>>>>>        for iColumn from 1 to iNumColumns
81730>>>>>>>>
81730>>>>>>>            Move 0 to iOptions
81731>>>>>>>            Move False to bIdentityKey
81732>>>>>>>            Move False to Err
81733>>>>>>>            Move 0     to LastErr
81734>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
81735>>>>>>>            Set piPosition of ghoProgressBar to iColumn
81736>>>>>>>            If (bDawSqlDriver = True) Begin
81738>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
81739>>>>>>>                If (bIsSqlTable = True) Begin
81741>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
81744>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
81745>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
81748>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
81751>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
81754>>>>>>>                End
81754>>>>>>>>
81754>>>>>>>                Else Begin
81755>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
81758>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
81759>>>>>>>                End
81759>>>>>>>>
81759>>>>>>>
81759>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
81759>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
81762>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
81763>>>>>>>                If (bExists = False) Begin
81765>>>>>>>                    Move 0 to APIColumns[iCount].iType
81766>>>>>>>                End
81766>>>>>>>>
81766>>>>>>>                If (bExists = True) Begin
81768>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
81771>>>>>>>                End
81771>>>>>>>>
81771>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
81772>>>>>>>                If (bIdentityKey = True) Begin
81774>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
81775>>>>>>>                End
81775>>>>>>>>
81775>>>>>>>            End
81775>>>>>>>>
81775>>>>>>>            Else Begin
81776>>>>>>>                Move False to Err
81777>>>>>>>                Move 0     to LastErr
81778>>>>>>>                If (bIsSqlTable = True) Begin
81780>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
81783>>>>>>>                End
81783>>>>>>>>
81783>>>>>>>                Else Begin
81784>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
81787>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
81788>>>>>>>                End
81788>>>>>>>>
81788>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
81788>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
81789>>>>>>>                If (bExists = False) Begin
81791>>>>>>>                    Move 0 to APIColumns[iCount].iType
81792>>>>>>>                End
81792>>>>>>>>
81792>>>>>>>            End
81792>>>>>>>>
81792>>>>>>>
81792>>>>>>>            If (bExists = True) Begin
81794>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
81795>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
81798>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
81798>>>>>>>//                If (bIsSqlTable = True) Begin
81798>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
81798>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
81798>>>>>>>//                End
81798>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
81801>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
81804>>>>>>>
81804>>>>>>>                // If the length was zero we might have an Overlap(!) field.
81804>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
81804>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
81806>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
81809>>>>>>>                    If (iType = DF_OVERLAP) Begin
81811>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
81812>>>>>>>                        Move 0 to APIColumns[iCount].iLength
81813>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
81814>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
81815>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
81816>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
81817>>>>>>>                        Decrement iCount
81818>>>>>>>                    End
81818>>>>>>>>
81818>>>>>>>                End
81818>>>>>>>>
81818>>>>>>>            End
81818>>>>>>>>
81818>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
81819>>>>>>>            If (bUserCancel = True) Begin
81821>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
81822>>>>>>>                Function_Return APIColumnsEmpty
81823>>>>>>>            End
81823>>>>>>>>
81823>>>>>>>            Increment iCount
81824>>>>>>>        Loop
81825>>>>>>>>
81825>>>>>>>
81825>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81826>>>>>>>        Function_Return APIColumns
81827>>>>>>>    End_Function
81828>>>>>>>
81828>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
81828>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
81828>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
81828>>>>>>>    // have "holes" in the series of index numbers.
81828>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
81830>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
81830>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
81831>>>>>>>        tAPIColumnCompare   APIColumnCompare
81831>>>>>>>        tAPIColumnCompare   APIColumnCompare
81831>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
81831>>>>>>>
81831>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
81832>>>>>>>        Decrement iSizeFrom
81833>>>>>>>        for iCount from 0 to iSizeFrom
81839>>>>>>>>
81839>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
81840>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
81841>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
81842>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
81843>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
81844>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
81845>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
81846>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
81847>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
81848>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
81849>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
81850>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
81851>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
81852>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
81853>>>>>>>        Loop
81854>>>>>>>>
81854>>>>>>>
81854>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
81855>>>>>>>        Decrement iSizeTo
81856>>>>>>>        for iCount from 0 to iSizeTo
81862>>>>>>>>
81862>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
81863>>>>>>>            // Search if the field number already exists in the array; else add it.
81863>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
81864>>>>>>>            If (iItem = -1) Begin
81866>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
81867>>>>>>>            End
81867>>>>>>>>
81867>>>>>>>
81867>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
81868>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
81869>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
81870>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
81871>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
81872>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
81873>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
81874>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
81875>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
81876>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
81877>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
81878>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
81879>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
81880>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
81881>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
81882>>>>>>>        Loop
81883>>>>>>>>
81883>>>>>>>
81883>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
81884>>>>>>>
81884>>>>>>>        Function_Return aAPIColumnCompare
81885>>>>>>>    End_Function
81886>>>>>>>
81886>>>>>>>    // Checks if a field name exists in a table definition
81886>>>>>>>    // Returns True if it does
81886>>>>>>>    // Sample:
81886>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
81886>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
81888>>>>>>>        Integer iNumColumns iColumn
81888>>>>>>>        String sColumn
81888>>>>>>>        Boolean bExists bOK bOpen
81888>>>>>>>
81888>>>>>>>        Get AutoConnectionIDLogin to bOK
81889>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81890>>>>>>>        Open hTable
81892>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81893>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
81896>>>>>>>        If (bOpen = False) Begin
81898>>>>>>>            Function_Return False
81899>>>>>>>        End
81899>>>>>>>>
81899>>>>>>>
81899>>>>>>>        Move False to bExists
81900>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
81903>>>>>>>        for iColumn from 1 to iNumColumns
81909>>>>>>>>
81909>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
81912>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
81914>>>>>>>                Move iNumColumns to iColumn
81915>>>>>>>                Move True to bExists
81916>>>>>>>            End
81916>>>>>>>>
81916>>>>>>>        Loop
81917>>>>>>>>
81917>>>>>>>        Close hTable
81918>>>>>>>
81918>>>>>>>        Function_Return bExists
81919>>>>>>>    End_Function
81920>>>>>>>
81920>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
81920>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
81922>>>>>>>        Integer iNumColumns iColumn iRetval
81922>>>>>>>        String sColumn
81922>>>>>>>        Boolean bOK bOpen
81922>>>>>>>
81922>>>>>>>        Get AutoConnectionIDLogin to bOK
81923>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81924>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81925>>>>>>>        Open hTable
81927>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
81928>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
81931>>>>>>>        If (bOpen = False) Begin
81933>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
81934>>>>>>>            Function_Return False
81935>>>>>>>        End
81935>>>>>>>>
81935>>>>>>>
81935>>>>>>>        Move 0 to iColumn
81936>>>>>>>        Move 0 to iRetval
81937>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
81940>>>>>>>        for iColumn from 1 to iNumColumns
81946>>>>>>>>
81946>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
81949>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
81951>>>>>>>                Move iColumn to iRetval
81952>>>>>>>                Move iNumColumns to iColumn
81953>>>>>>>            End
81953>>>>>>>>
81953>>>>>>>        Loop
81954>>>>>>>>
81954>>>>>>>        Close hTable
81955>>>>>>>
81955>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81956>>>>>>>        Function_Return iRetval
81957>>>>>>>    End_Function
81958>>>>>>>
81958>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
81958>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
81958>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
81960>>>>>>>        tColumnType RetvalType
81960>>>>>>>        tColumnType RetvalType
81960>>>>>>>
81960>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
81961>>>>>>>        Function_Return RetvalType.iSQLType
81962>>>>>>>    End_Function
81963>>>>>>>
81963>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
81963>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
81963>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
81965>>>>>>>        tColumnType RetvalType
81965>>>>>>>        tColumnType RetvalType
81965>>>>>>>
81965>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
81966>>>>>>>        Function_Return RetvalType.sSQLType
81967>>>>>>>    End_Function
81968>>>>>>>
81968>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
81970>>>>>>>        tColumnType RetvalType
81970>>>>>>>        tColumnType RetvalType
81970>>>>>>>
81970>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
81971>>>>>>>        Function_Return RetvalType.sPrecision
81972>>>>>>>    End_Function
81973>>>>>>>
81973>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
81975>>>>>>>        tColumnType RetvalType
81975>>>>>>>        tColumnType RetvalType
81975>>>>>>>
81975>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
81976>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
81976>>>>>>>        // if the column type length is _not_ fixed.
81976>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
81977>>>>>>>    End_Function
81978>>>>>>>
81978>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
81980>>>>>>>        tColumnType RetvalType
81980>>>>>>>        tColumnType RetvalType
81980>>>>>>>        String sValue
81980>>>>>>>        Integer iRetval iPos
81980>>>>>>>
81980>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
81981>>>>>>>        Move RetvalType.sPrecision to sValue
81982>>>>>>>        Move (Pos(".", sValue)) to iPos
81983>>>>>>>        If (iPos <> 0) Begin
81985>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
81986>>>>>>>        End
81986>>>>>>>>
81986>>>>>>>        Else Begin
81987>>>>>>>            Move sValue to iRetval
81988>>>>>>>        End
81988>>>>>>>>
81988>>>>>>>        Function_Return iRetval
81989>>>>>>>    End_Function
81990>>>>>>>
81990>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
81992>>>>>>>        tColumnType RetvalType
81992>>>>>>>        tColumnType RetvalType
81992>>>>>>>        String sValue
81992>>>>>>>        Integer iRetval iPos
81992>>>>>>>
81992>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
81993>>>>>>>        Move RetvalType.sPrecision to sValue
81994>>>>>>>        Move (Pos(".", sValue)) to iPos
81995>>>>>>>        If (iPos = 0) Begin
81997>>>>>>>            Function_Return 0
81998>>>>>>>        End
81998>>>>>>>>
81998>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
81999>>>>>>>
81999>>>>>>>        Function_Return iRetval
82000>>>>>>>    End_Function
82001>>>>>>>
82001>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82001>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
82003>>>>>>>        Function_Return False
82004>>>>>>>    End_Function
82005>>>>>>>
82005>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
82005>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
82007>>>>>>>        Boolean bIsSame
82007>>>>>>>        Integer iCount iSize
82007>>>>>>>
82007>>>>>>>        Move True to bIsSame
82008>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
82009>>>>>>>        Decrement iSize
82010>>>>>>>        For iCount from 0 to iSize
82016>>>>>>>>
82016>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82017>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
82018>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
82019>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
82020>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
82021>>>>>>>            If (bIsSame = False) Begin
82023>>>>>>>                Function_Return False
82024>>>>>>>            End
82024>>>>>>>>
82024>>>>>>>        Loop
82025>>>>>>>>
82025>>>>>>>
82025>>>>>>>        Function_Return bIsSame
82026>>>>>>>    End_Function
82027>>>>>>>
82027>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
82027>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
82029>>>>>>>        Boolean bIsSame
82029>>>>>>>        Integer iSegment
82029>>>>>>>
82029>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
82030>>>>>>>        If (bIsSame = False) Begin
82032>>>>>>>            Function_Return False
82033>>>>>>>        End
82033>>>>>>>>
82033>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
82034>>>>>>>        If (bIsSame = False) Begin
82036>>>>>>>            Function_Return False
82037>>>>>>>        End
82037>>>>>>>>
82037>>>>>>>
82037>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
82039>>>>>>>            // * We should probably not compare SQL index names?
82039>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
82039>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
82039>>>>>>>            //     Function_Return False
82039>>>>>>>            // End
82039>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
82040>>>>>>>            If (bIsSame = False) Begin
82042>>>>>>>                Function_Return False
82043>>>>>>>            End
82043>>>>>>>>
82043>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
82044>>>>>>>            If (bIsSame = False) Begin
82046>>>>>>>                Function_Return False
82047>>>>>>>            End
82047>>>>>>>>
82047>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
82048>>>>>>>            If (bIsSame = False) Begin
82050>>>>>>>                Function_Return False
82051>>>>>>>            End
82051>>>>>>>>
82051>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
82052>>>>>>>            If (bIsSame = False) Begin
82054>>>>>>>                Function_Return False
82055>>>>>>>            End
82055>>>>>>>>
82055>>>>>>>        End
82055>>>>>>>>
82055>>>>>>>
82055>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
82056>>>>>>>        Move (iSegment = -1) to bIsSame
82057>>>>>>>
82057>>>>>>>        Function_Return (bIsSame = True)
82058>>>>>>>    End_Function
82059>>>>>>>
82059>>>>>>>    // Compares each segment for the passed index.
82059>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
82059>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
82061>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
82061>>>>>>>        Boolean bIsSame
82061>>>>>>>
82061>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
82062>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82063>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
82064>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
82065>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
82066>>>>>>>
82066>>>>>>>        Decrement iNumSegments
82067>>>>>>>        for iSegment from 0 to iNumSegments
82073>>>>>>>>
82073>>>>>>>            Move False to bIsSame
82074>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
82076>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
82077>>>>>>>            End
82077>>>>>>>>
82077>>>>>>>            If (bIsSame = False) Begin
82079>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
82080>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
82081>>>>>>>                Function_Return iSegment
82082>>>>>>>            End
82082>>>>>>>>
82082>>>>>>>        Loop
82083>>>>>>>>
82083>>>>>>>
82083>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
82084>>>>>>>        Function_Return -1 // This means bIsSame = True
82085>>>>>>>    End_Function
82086>>>>>>>
82086>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
82088>>>>>>>        Boolean bIsSame
82088>>>>>>>
82088>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
82089>>>>>>>        If (bIsSame = False) Begin
82091>>>>>>>            Function_Return False
82092>>>>>>>        End
82092>>>>>>>>
82092>>>>>>>        If (bCompareIndexUppercase = True) Begin
82094>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
82095>>>>>>>            If (bIsSame = False) Begin
82097>>>>>>>                Function_Return False
82098>>>>>>>            End
82098>>>>>>>>
82098>>>>>>>        End
82098>>>>>>>>
82098>>>>>>>        If (bCompareIndexAscending = True) Begin
82100>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
82101>>>>>>>            If (bIsSame = False) Begin
82103>>>>>>>                Function_Return False
82104>>>>>>>            End
82104>>>>>>>>
82104>>>>>>>        End
82104>>>>>>>>
82104>>>>>>>
82104>>>>>>>        Function_Return True
82105>>>>>>>    End_Function
82106>>>>>>>
82106>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
82108>>>>>>>        Boolean bIsSame bOK
82108>>>>>>>        Integer iSize iSizeTo iCount
82108>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
82108>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
82109>>>>>>>
82109>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
82110>>>>>>>        If (iSize = 0) Begin
82112>>>>>>>            Function_Return True
82113>>>>>>>        End
82113>>>>>>>>
82113>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
82114>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
82115>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
82116>>>>>>>
82116>>>>>>>        for iCount from 0 to (iSize - 1)
82122>>>>>>>>
82122>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
82123>>>>>>>            If (bIsSame = False) Begin
82125>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
82126>>>>>>>            End
82126>>>>>>>>
82126>>>>>>>        Loop
82127>>>>>>>>
82127>>>>>>>
82127>>>>>>>        // We probably should delete other indexes if they exists.
82127>>>>>>>        for iCount from (iSize +1) to iSizeTo
82133>>>>>>>>
82133>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
82134>>>>>>>        Loop
82135>>>>>>>>
82135>>>>>>>
82135>>>>>>>        Function_Return bOK
82136>>>>>>>    End_Function
82137>>>>>>>
82137>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
82137>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
82137>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
82137>>>>>>>//        String sFieldName sDriverID
82137>>>>>>>//
82137>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82137>>>>>>>//        If (bIsOpen = False) Begin
82137>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82137>>>>>>>//            Open hTable
82137>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82137>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82137>>>>>>>//            If (bIsOpen = False) Begin
82137>>>>>>>//                Function_Return False
82137>>>>>>>//            End
82137>>>>>>>//        End
82137>>>>>>>//
82137>>>>>>>//        Move True to bEqual
82137>>>>>>>//        Get psDriverID to sDriverID
82137>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
82137>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
82137>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
82137>>>>>>>//        Decrement iSize
82137>>>>>>>//
82137>>>>>>>//        For iCount from 0 to iSize
82137>>>>>>>//            Move 0 to iOptions
82137>>>>>>>//            Move False to bIdentityKey
82137>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
82137>>>>>>>//
82137>>>>>>>//            // We need to use the column name - not the column integer as
82137>>>>>>>//            // the order does not need to be the same, and the logic should still work.
82137>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
82137>>>>>>>//            If (iColumn > 0) Begin
82137>>>>>>>//                If (bDawSqlDriver = True) Begin
82137>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
82137>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
82137>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
82137>>>>>>>//                        Move False to bEqual
82137>>>>>>>//                    End
82137>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
82137>>>>>>>//                    If (bIdentityKey = True) Begin
82137>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
82137>>>>>>>//                    End
82137>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
82137>>>>>>>//                        Move False to bEqual
82137>>>>>>>//                    End
82137>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
82137>>>>>>>//                End
82137>>>>>>>//                Else Begin
82137>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
82137>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
82137>>>>>>>//                        Move False to bEqual
82137>>>>>>>//                    End
82137>>>>>>>//                End
82137>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
82137>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
82137>>>>>>>//                    Move False to bEqual
82137>>>>>>>//                End
82137>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
82137>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
82137>>>>>>>//                    Move False to bEqual
82137>>>>>>>//                End
82137>>>>>>>//                If (bEqual = False) Begin
82137>>>>>>>//                    Function_Return False
82137>>>>>>>//                End
82137>>>>>>>//            End
82137>>>>>>>//
82137>>>>>>>//            Else Begin
82137>>>>>>>//                Function_Return False
82137>>>>>>>//            End
82137>>>>>>>//        Loop
82137>>>>>>>//
82137>>>>>>>//        Function_Return bEqual
82137>>>>>>>//    End_Function
82137>>>>>>>
82137>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
82139>>>>>>>        tAPIIndex[] APIIndexes
82139>>>>>>>        tAPIIndex[] APIIndexes
82140>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
82140>>>>>>>        String sDriverID
82140>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
82140>>>>>>>
82140>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82141>>>>>>>        Get psDriverID to sDriverID
82142>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
82143>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
82144>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82147>>>>>>>        If (bIsOpen = False) Begin
82149>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82150>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82151>>>>>>>            Open hTable
82153>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
82154>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82155>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82158>>>>>>>            If (bIsOpen = False) Begin
82160>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
82161>>>>>>>                Move True to APIIndexes[0].bError
82162>>>>>>>                Function_Return APIIndexes
82163>>>>>>>            End
82163>>>>>>>>
82163>>>>>>>        End
82163>>>>>>>>
82163>>>>>>>
82163>>>>>>>        Move 0 to iCount
82164>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
82167>>>>>>>        for iIndex from 1 to iIndexes
82173>>>>>>>>
82173>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
82173>>>>>>>            // numbers doesn't not need to be consequitive:
82173>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
82176>>>>>>>            If (iNumSegments > 0) Begin
82178>>>>>>>
82178>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
82179>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
82182>>>>>>>                If (bIsSQLTable = True) Begin
82184>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
82187>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
82190>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
82193>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
82196>>>>>>>                End
82196>>>>>>>>
82196>>>>>>>
82196>>>>>>>                Move 0 to iSegmentCount
82197>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
82200>>>>>>>                For iSegment from 1 to iNumSegments
82206>>>>>>>>
82206>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
82209>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
82210>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
82213>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
82216>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
82219>>>>>>>                    Increment iSegmentCount
82220>>>>>>>                Loop
82221>>>>>>>>
82221>>>>>>>                Increment iCount
82222>>>>>>>            End
82222>>>>>>>>
82222>>>>>>>        Loop
82223>>>>>>>>
82223>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
82224>>>>>>>
82224>>>>>>>        Function_Return APIIndexes
82225>>>>>>>    End_Function
82226>>>>>>>
82226>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
82226>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
82226>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
82226>>>>>>>    // have "holes" in the series of index numbers.
82226>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
82228>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
82228>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
82229>>>>>>>        tAPIIndexCompare   APIIndexCompare
82229>>>>>>>        tAPIIndexCompare   APIIndexCompare
82229>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
82229>>>>>>>
82229>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
82230>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
82231>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
82233>>>>>>>            Function_Return aAPIIndexCompare
82234>>>>>>>        End
82234>>>>>>>>
82234>>>>>>>
82234>>>>>>>        Decrement iSizeFrom
82235>>>>>>>        for iCount from 0 to iSizeFrom
82241>>>>>>>>
82241>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
82242>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
82243>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
82244>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
82245>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
82246>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
82247>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
82248>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
82249>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
82250>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
82251>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
82252>>>>>>>        Loop
82253>>>>>>>>
82253>>>>>>>
82253>>>>>>>        Decrement iSizeTo
82254>>>>>>>        for iCount from 0 to iSizeTo
82260>>>>>>>>
82260>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
82261>>>>>>>            // Search if the Index number already exists in the array; else add it.
82261>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
82262>>>>>>>            If (iItem = -1) Begin
82264>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
82265>>>>>>>            End
82265>>>>>>>>
82265>>>>>>>
82265>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
82266>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
82267>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
82268>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
82269>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
82270>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
82271>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
82272>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
82273>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
82274>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
82275>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
82276>>>>>>>        Loop
82277>>>>>>>>
82277>>>>>>>
82277>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
82278>>>>>>>
82278>>>>>>>        Function_Return aAPIIndexCompare
82279>>>>>>>    End_Function
82280>>>>>>>
82280>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
82280>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
82282>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
82282>>>>>>>        String sDriverID
82282>>>>>>>
82282>>>>>>>        Get psDriverID to sDriverID
82283>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
82284>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
82285>>>>>>>        If (bIsSqlTable = True) Begin
82287>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
82288>>>>>>>        End
82288>>>>>>>>
82288>>>>>>>
82288>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
82289>>>>>>>        If (bIsSame = False) Begin
82291>>>>>>>            Function_Return False
82292>>>>>>>        End
82292>>>>>>>>
82292>>>>>>>
82292>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
82294>>>>>>>            // Don't think we should do this. Or should we?
82294>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
82294>>>>>>>
82294>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
82295>>>>>>>            If (bIsSame = False) Begin
82297>>>>>>>                Function_Return False
82298>>>>>>>            End
82298>>>>>>>>
82298>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
82299>>>>>>>            If (bIsSame = False) Begin
82301>>>>>>>                Function_Return False
82302>>>>>>>            End
82302>>>>>>>>
82302>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
82303>>>>>>>            If (bIsSame = False) Begin
82305>>>>>>>                Function_Return False
82306>>>>>>>            End
82306>>>>>>>>
82306>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
82307>>>>>>>            If (bIsSame = False) Begin
82309>>>>>>>                Function_Return False
82310>>>>>>>            End
82310>>>>>>>>
82310>>>>>>>        End
82310>>>>>>>>
82310>>>>>>>
82310>>>>>>>        Function_Return bIsSame
82311>>>>>>>    End_Function
82312>>>>>>>
82312>>>>>>>    // DF_INDEX_SQL_TYPE values
82312>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
82312>>>>>>>    // returns a string with the name.
82312>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
82314>>>>>>>        String sRetval
82314>>>>>>>        Case Begin
82314>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
82316>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
82317>>>>>>>                Case Break
82318>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
82321>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
82322>>>>>>>                Case Break
82323>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
82326>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
82327>>>>>>>                Case Break
82328>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
82331>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
82332>>>>>>>                Case Break
82333>>>>>>>            Case Else
82333>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
82334>>>>>>>        Case End
82334>>>>>>>        Function_Return sRetval
82335>>>>>>>    End_Function
82336>>>>>>>
82336>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82336>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
82338>>>>>>>        Function_Return False
82339>>>>>>>    End_Function
82340>>>>>>>
82340>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
82340>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
82342>>>>>>>        Boolean bIsSame
82342>>>>>>>        Integer iSize iCount
82342>>>>>>>
82342>>>>>>>        Move True to bIsSame
82343>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
82344>>>>>>>        Decrement iSize
82345>>>>>>>        For iCount from 0 to iSize
82351>>>>>>>>
82351>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
82352>>>>>>>            If (bIsSame = False) Begin
82354>>>>>>>                Function_Return False
82355>>>>>>>            End
82355>>>>>>>>
82355>>>>>>>        Loop
82356>>>>>>>>
82356>>>>>>>
82356>>>>>>>        Function_Return bIsSame
82357>>>>>>>    End_Function
82358>>>>>>>
82358>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
82358>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
82360>>>>>>>        Boolean bIsSame
82360>>>>>>>
82360>>>>>>>        Move True to bIsSame
82361>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
82363>>>>>>>            Function_Return False
82364>>>>>>>        End
82364>>>>>>>>
82364>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
82366>>>>>>>            Function_Return False
82367>>>>>>>        End
82367>>>>>>>>
82367>>>>>>>
82367>>>>>>>        // We could also compare field names, but I don't think that is necessary...
82367>>>>>>>
82367>>>>>>>        Function_Return bIsSame
82368>>>>>>>    End_Function
82369>>>>>>>
82369>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
82369>>>>>>>    // already exists.
82369>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
82371>>>>>>>        Boolean bOK
82371>>>>>>>        Integer iSizeTo iSize iCount iColumn
82371>>>>>>>        String sDriverID
82371>>>>>>>
82371>>>>>>>        Move True to bOK
82372>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
82373>>>>>>>        If (iSizeTo > 0) Begin
82375>>>>>>>            Get AutoConnectionIDLogin to bOK
82376>>>>>>>            Move False to Err
82377>>>>>>>            Open hTable Mode DF_EXCLUSIVE
82379>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
82382>>>>>>>            Decrement iSizeTo
82383>>>>>>>
82383>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
82383>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
82383>>>>>>>            Structure_Start hTable sDriverID
82384>>>>>>>                for iCount from 0 to iSizeTo
82390>>>>>>>>
82390>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
82391>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
82394>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
82397>>>>>>>                Loop
82398>>>>>>>>
82398>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
82399>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82401>>>>>>>            Set Action_Text of ghoStatusPanel to ""
82402>>>>>>>        End
82402>>>>>>>>
82402>>>>>>>
82402>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
82403>>>>>>>        Decrement iSize
82404>>>>>>>        for iCount from 0 to iSize
82410>>>>>>>>
82410>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
82411>>>>>>>        Loop
82412>>>>>>>>
82412>>>>>>>
82412>>>>>>>        Function_Return bOK
82413>>>>>>>    End_Function
82414>>>>>>>
82414>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
82416>>>>>>>        tAPIRelation[] APIRelations
82416>>>>>>>        tAPIRelation[] APIRelations
82417>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
82417>>>>>>>        Handle hParent
82417>>>>>>>        Boolean bIsOpen
82417>>>>>>>
82417>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82418>>>>>>>        Move 0 to iCount
82419>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82422>>>>>>>        If (bIsOpen = False) Begin
82424>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82425>>>>>>>            Open hTable
82427>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
82428>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
82431>>>>>>>            If (bIsOpen = False) Begin
82433>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
82434>>>>>>>                Move True to APIRelations[0].bError
82435>>>>>>>                Function_Return APIRelations
82436>>>>>>>            End
82436>>>>>>>>
82436>>>>>>>        End
82436>>>>>>>>
82436>>>>>>>
82436>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
82439>>>>>>>        For iColumn from 1 to iNumColumns
82445>>>>>>>>
82445>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
82448>>>>>>>            If (hParent <> 0) Begin
82450>>>>>>>                Open hParent
82452>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
82453>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
82456>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
82457>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
82460>>>>>>>
82460>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
82461>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
82464>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
82467>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
82468>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
82471>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
82472>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
82473>>>>>>>                Move False                                              to APIRelations[iCount].bError
82474>>>>>>>                Close hParent
82475>>>>>>>                Increment iCount
82476>>>>>>>            End
82476>>>>>>>>
82476>>>>>>>        Loop
82477>>>>>>>>
82477>>>>>>>
82477>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
82478>>>>>>>        Function_Return APIRelations
82479>>>>>>>    End_Function
82480>>>>>>>
82480>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
82482>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
82484>>>>>>>            Function_Return (EQ)
82485>>>>>>>        End
82485>>>>>>>>
82485>>>>>>>
82485>>>>>>>        Function_Return (GT)
82486>>>>>>>    End_Function
82487>>>>>>>
82487>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
82489>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
82492>>>>>>>
82492>>>>>>>        Function_Return (GT)
82493>>>>>>>    End_Function
82494>>>>>>>
82494>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
82494>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
82494>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
82496>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
82496>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
82497>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
82497>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
82498>>>>>>>        tAPIRelationCompare   APIRelationCompare
82498>>>>>>>        tAPIRelationCompare   APIRelationCompare
82498>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
82498>>>>>>>
82498>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
82499>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
82500>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
82502>>>>>>>            Function_Return aAPIRelationCompare
82503>>>>>>>        End
82503>>>>>>>>
82503>>>>>>>
82503>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
82504>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
82505>>>>>>>
82505>>>>>>>        Decrement iSizeFrom
82506>>>>>>>        for iCount from 0 to iSizeFrom
82512>>>>>>>>
82512>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
82513>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
82514>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
82515>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
82516>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
82517>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
82518>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
82519>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
82520>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
82521>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
82522>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
82523>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
82524>>>>>>>        Loop
82525>>>>>>>>
82525>>>>>>>
82525>>>>>>>        Decrement iSizeTo
82526>>>>>>>        for iCount from 0 to iSizeTo
82532>>>>>>>>
82532>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
82533>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
82534>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
82535>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
82536>>>>>>>
82536>>>>>>>            // Search if the relation already exists in the array; else add it.
82536>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
82537>>>>>>>            If (iItem = -1) Begin
82539>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
82540>>>>>>>            End
82540>>>>>>>>
82540>>>>>>>
82540>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
82541>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
82542>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
82543>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
82544>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
82545>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
82546>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
82547>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
82548>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
82549>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
82550>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
82551>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
82552>>>>>>>        Loop
82553>>>>>>>>
82553>>>>>>>
82553>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
82554>>>>>>>
82554>>>>>>>        Function_Return aAPIRelationCompare
82555>>>>>>>    End_Function
82556>>>>>>>
82556>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82556>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
82558>>>>>>>        Function_Return False
82559>>>>>>>    End_Function
82560>>>>>>>
82560>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
82560>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
82560>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
82560>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
82562>>>>>>>        Boolean bFound
82562>>>>>>>
82562>>>>>>>        Move False to Err
82563>>>>>>>        Open CodeMast
82565>>>>>>>        Open CodeType
82567>>>>>>>
82567>>>>>>>        If (bCodeType = True) Begin
82569>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
82570>>>>>>>            Clear CodeType
82571>>>>>>>            Move sTypeValue to CODETYPE.Type
82572>>>>>>>            Find eq CODETYPE by 1
82573>>>>>>>>
82573>>>>>>>            Move Found to bFound
82574>>>>>>>            If (bFound = True) Begin
82576>>>>>>>                Reread CodeType
82580>>>>>>>            End
82580>>>>>>>>
82580>>>>>>>            Else Begin
82581>>>>>>>                Clear CodeType
82582>>>>>>>            End
82582>>>>>>>>
82582>>>>>>>
82582>>>>>>>            Move sTypeValue to CODETYPE.Type
82583>>>>>>>            Move sValue2    to CODETYPE.Description
82584>>>>>>>            Move sValue3    to CODETYPE.Comment
82585>>>>>>>            SaveRecord CODETYPE
82586>>>>>>>
82586>>>>>>>            If (bFound = True) Begin
82588>>>>>>>                Unlock
82589>>>>>>>>
82589>>>>>>>            End
82589>>>>>>>>
82589>>>>>>>        End
82589>>>>>>>>
82589>>>>>>>
82589>>>>>>>        If (bCodeType = False) Begin
82591>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
82592>>>>>>>            Clear CODEMAST
82593>>>>>>>            Move sTypeValue to CODEMAST.Type
82594>>>>>>>            Move sValue2    to CODEMAST.Code
82595>>>>>>>            Find eq CODEMAST by 1
82596>>>>>>>>
82596>>>>>>>            Move Found to bFound
82597>>>>>>>            If (bFound = True) Begin
82599>>>>>>>                Reread CODEMAST
82603>>>>>>>            End
82603>>>>>>>>
82603>>>>>>>            Else Begin
82604>>>>>>>                Clear CODEMAST
82605>>>>>>>            End
82605>>>>>>>>
82605>>>>>>>
82605>>>>>>>            Move sTypeValue to CODEMAST.Type
82606>>>>>>>            Move sValue2    to CODEMAST.Code
82607>>>>>>>            Move sValue3    to CODEMAST.Description
82608>>>>>>>            SaveRecord CODEMAST
82609>>>>>>>
82609>>>>>>>            If (bFound = True) Begin
82611>>>>>>>                Unlock
82612>>>>>>>>
82612>>>>>>>            End
82612>>>>>>>>
82612>>>>>>>        End
82612>>>>>>>>
82612>>>>>>>
82612>>>>>>>        Close CodeMast
82613>>>>>>>        Close CodeType
82614>>>>>>>
82614>>>>>>>        Function_Return (Err = False)
82615>>>>>>>    End_Function
82616>>>>>>>
82616>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
82616>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
82616>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
82618>>>>>>>        Boolean bFound
82618>>>>>>>
82618>>>>>>>        Move False to Err
82619>>>>>>>        Open CodeMast
82621>>>>>>>        Open CodeType
82623>>>>>>>
82623>>>>>>>        Clear CodeType
82624>>>>>>>        Move sFromValue to CODETYPE.Type
82625>>>>>>>        Find eq CODETYPE.Type
82626>>>>>>>>
82626>>>>>>>        If (Found = True) Begin
82628>>>>>>>            Reread CODETYPE
82632>>>>>>>                Move sToValue to CODETYPE.Type
82633>>>>>>>                SaveRecord CODETYPE
82634>>>>>>>            Unlock
82635>>>>>>>>
82635>>>>>>>        End
82635>>>>>>>>
82635>>>>>>>
82635>>>>>>>        Clear CODEMAST
82636>>>>>>>        Find gt CODEMAST by Recnum
82637>>>>>>>>
82637>>>>>>>        While (Found = True)
82641>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
82642>>>>>>>            If (bFound = True) Begin
82644>>>>>>>                Reread CODEMAST
82648>>>>>>>                    Move sToValue to CODEMAST.Type
82649>>>>>>>                    SaveRecord CODEMAST
82650>>>>>>>                Unlock
82651>>>>>>>>
82651>>>>>>>            End
82651>>>>>>>>
82651>>>>>>>            Find gt CODEMAST by Recnum
82652>>>>>>>>
82652>>>>>>>        Loop
82653>>>>>>>>
82653>>>>>>>
82653>>>>>>>        Close CodeMast
82654>>>>>>>        Close CodeType
82655>>>>>>>
82655>>>>>>>        Function_Return (Err = False)
82656>>>>>>>    End_Function
82657>>>>>>>
82657>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
82657>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
82659>>>>>>>        Boolean bFound
82659>>>>>>>
82659>>>>>>>        Move False to Err
82660>>>>>>>        Open CodeMast
82662>>>>>>>
82662>>>>>>>        Clear CODEMAST
82663>>>>>>>        Move sTypeValue to CODEMAST.Type
82664>>>>>>>        Move sValue2    to CODEMAST.Code
82665>>>>>>>        Find eq CODEMAST.Code
82666>>>>>>>>
82666>>>>>>>        Move Found to bFound
82667>>>>>>>        If (bFound = True) Begin
82669>>>>>>>            Delete CODEMAST
82670>>>>>>>        End
82670>>>>>>>>
82670>>>>>>>
82670>>>>>>>        Close CodeMast
82671>>>>>>>
82671>>>>>>>        Function_Return (Err = False)
82672>>>>>>>    End_Function
82673>>>>>>>
82673>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
82675>>>>>>>        Boolean bRecnum bToAnsi
82675>>>>>>>        Integer iCh
82675>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
82675>>>>>>>
82675>>>>>>>        If (Trim(sDataPath) = "") Begin
82677>>>>>>>            Function_Return False
82678>>>>>>>        End
82678>>>>>>>>
82678>>>>>>>
82678>>>>>>>        Move False to Err
82679>>>>>>>        Get psDriverID     to sDriverID
82680>>>>>>>        Get psConnectionID to sConnectionID
82681>>>>>>>        Get psSchema       to sSchemaName
82682>>>>>>>        Get True           to bRecnum
82683>>>>>>>        Get pbToANSI       to bToAnsi
82684>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
82685>>>>>>>        If (bToAnsi = False) Begin
82687>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
82688>>>>>>>        End
82688>>>>>>>>
82688>>>>>>>
82688>>>>>>>        Get vFolderFormat sDataPath to sDataPath
82689>>>>>>>        Move "CodeMast.int"         to sFileName
82690>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
82691>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
82694>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
82697>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
82700>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
82703>>>>>>>            Writeln channel iCh ("")
82706>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
82709>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
82712>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
82715>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
82718>>>>>>>            Writeln channel iCh ("")
82721>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
82724>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
82727>>>>>>>            Writeln channel iCh ("")
82730>>>>>>>        Send Seq_Close_Channel iCh
82731>>>>>>>
82731>>>>>>>        Get vFolderFormat sDataPath to sDataPath
82732>>>>>>>        Move "CodeType.int"         to sFileName
82733>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
82734>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
82737>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
82740>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
82743>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
82746>>>>>>>            Writeln channel iCh ("")
82749>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
82752>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
82755>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
82758>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
82761>>>>>>>            Writeln channel iCh ("")
82764>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
82767>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
82770>>>>>>>            Writeln channel iCh ("")
82773>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
82776>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
82779>>>>>>>            Writeln channel iCh ("")
82782>>>>>>>        Send Seq_Close_Channel iCh
82783>>>>>>>
82783>>>>>>>        Function_Return (Err = False)
82784>>>>>>>    End_Function
82785>>>>>>>
82785>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82785>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
82787>>>>>>>        Function_Return False
82788>>>>>>>    End_Function
82789>>>>>>>
82789>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
82789>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
82789>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
82791>>>>>>>        Boolean bOK bExists
82791>>>>>>>        String sDataPath sBackupFolder
82791>>>>>>>
82791>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
82792>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
82793>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
82794>>>>>>>        Get vFolderFormat sDataPath to sDataPath
82795>>>>>>>
82795>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
82796>>>>>>>        If (bExists = False) Begin
82798>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
82799>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
82800>>>>>>>            If (bExists = False) Begin
82802>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
82803>>>>>>>>
82803>>>>>>>                Function_Return False
82804>>>>>>>            End
82804>>>>>>>>
82804>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
82805>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
82806>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
82807>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
82808>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
82809>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
82810>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
82811>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
82812>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
82813>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
82814>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
82815>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
82816>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
82817>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
82818>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
82819>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
82820>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
82821>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
82822>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
82823>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
82824>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
82825>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
82826>>>>>>>        End
82826>>>>>>>>
82826>>>>>>>
82826>>>>>>>        Set Message_Text of ghoStatusPanel to ""
82827>>>>>>>        Function_Return True
82828>>>>>>>    End_Function
82829>>>>>>>    
82829>>>>>>>    // Check if the file exists in the Data folder,
82829>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
82829>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
82831>>>>>>>        String sPath
82831>>>>>>>        Boolean bExists
82831>>>>>>>
82831>>>>>>>        Get psDataPathFirstPart to sPath
82832>>>>>>>        Move (sPath + sFileName) to sFileName
82833>>>>>>>        Get vFilePathExists sFileName to bExists
82834>>>>>>>
82834>>>>>>>        If (bExists = False) Begin
82836>>>>>>>            // Read from memory & create file on disk.
82836>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
82837>>>>>>>            Get vFilePathExists sFileName to bExists
82838>>>>>>>        End
82838>>>>>>>>
82838>>>>>>>        Function_Return bExists
82839>>>>>>>    End_Function
82840>>>>>>>
82840>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
82842>>>>>>>        tColumnType RetvalType
82842>>>>>>>        tColumnType RetvalType
82842>>>>>>>        Integer iRetval
82842>>>>>>>
82842>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
82843>>>>>>>        Move RetvalType.iDataFlexType to iRetval
82844>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
82846>>>>>>>            If (iLength <= 255) Begin
82848>>>>>>>                Move DF_ASCII to iRetval
82849>>>>>>>            End
82849>>>>>>>>
82849>>>>>>>        End
82849>>>>>>>>
82849>>>>>>>        Function_Return iRetval
82850>>>>>>>    End_Function
82851>>>>>>>
82851>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
82853>>>>>>>        String sRetval
82853>>>>>>>
82853>>>>>>>        Case Begin
82853>>>>>>>            Case (iDataType = DF_ASCII)
82855>>>>>>>                Move "DF_ASCII" to sRetval
82856>>>>>>>                Case Break
82857>>>>>>>            Case (iDataType = DF_BCD)
82860>>>>>>>                Move "DF_BCD" to sRetval
82861>>>>>>>                Case Break
82862>>>>>>>            Case (iDataType = DF_BINARY)
82865>>>>>>>                Move "DF_BINARY" to sRetval
82866>>>>>>>                Case Break
82867>>>>>>>            Case (iDataType = DF_DATE)
82870>>>>>>>                Move "DF_DATE" to sRetval
82871>>>>>>>                Case Break
82872>>>>>>>            Case (iDataType = DF_DATETIME)
82875>>>>>>>                Move "DF_DATETIME" to sRetval
82876>>>>>>>                Case Break
82877>>>>>>>            Case (iDataType = DF_TEXT)
82880>>>>>>>                Move "DF_TEXT" to sRetval
82881>>>>>>>                Case Break
82882>>>>>>>            Case Else
82882>>>>>>>                Move "" to sRetval
82883>>>>>>>        Case End
82883>>>>>>>
82883>>>>>>>        Function_Return sRetval
82884>>>>>>>    End_Function
82885>>>>>>>
82885>>>>>>>    // The default value used for a datatype as specified in the driver int file.
82885>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
82887>>>>>>>        String sRetval sServer
82887>>>>>>>        tColumnType RetvalType
82887>>>>>>>        tColumnType RetvalType
82887>>>>>>>        Integer iDriver iDataFlexType
82887>>>>>>>        Handle hDatabase
82887>>>>>>>
82887>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
82888>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
82889>>>>>>>        Get DriverIndex sDriverID to iDriver
82890>>>>>>>        Get psServer to sServer
82891>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
82892>>>>>>>        If (hDatabase = 0) Begin
82894>>>>>>>            Function_Return ""
82895>>>>>>>        End
82895>>>>>>>>
82895>>>>>>>
82895>>>>>>>        Case Begin
82895>>>>>>>            Case (iDataFlexType = DF_ASCII)
82897>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
82900>>>>>>>                Case Break
82901>>>>>>>            Case (iDataFlexType = DF_BCD)
82904>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
82907>>>>>>>                Case Break
82908>>>>>>>            Case (iDataFlexType = DF_BINARY)
82911>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
82914>>>>>>>                Case Break
82915>>>>>>>            Case (iDataFlexType = DF_DATE)
82918>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
82921>>>>>>>                Case Break
82922>>>>>>>            Case (iDataFlexType = DF_DATETIME)
82925>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
82928>>>>>>>                Case Break
82929>>>>>>>            Case (iDataFlexType = DF_TEXT)
82932>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
82935>>>>>>>                Case Break
82936>>>>>>>            Case Else
82936>>>>>>>                Move "" to sRetval
82937>>>>>>>        Case End
82937>>>>>>>
82937>>>>>>>        Function_Return sRetval
82938>>>>>>>    End_Function
82939>>>>>>>
82939>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
82941>>>>>>>        String sDriverID sServer
82941>>>>>>>        tColumnType RetvalType
82941>>>>>>>        tColumnType RetvalType
82941>>>>>>>        Integer iDbType iDriver
82941>>>>>>>        Handle hDatabase
82941>>>>>>>
82941>>>>>>>        Get psDriverID to sDriverID
82942>>>>>>>        Get piDbType   to iDbType
82943>>>>>>>        Get DriverIndex sDriverID to iDriver
82944>>>>>>>        Get psServer to sServer
82945>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
82946>>>>>>>        If (hDatabase = 0) Begin
82948>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
82949>>>>>>>>
82949>>>>>>>            Procedure_Return
82950>>>>>>>        End
82950>>>>>>>>
82950>>>>>>>
82950>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
82953>>>>>>>
82953>>>>>>>    End_Procedure
82954>>>>>>>
82954>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
82956>>>>>>>        String sDriverID sServer
82956>>>>>>>        tColumnType RetvalType
82956>>>>>>>        tColumnType RetvalType
82956>>>>>>>        Integer iDbType iDriver
82956>>>>>>>        Handle hDatabase
82956>>>>>>>
82956>>>>>>>        Get psDriverID to sDriverID
82957>>>>>>>        Get piDbType   to iDbType
82958>>>>>>>        Get DriverIndex sDriverID to iDriver
82959>>>>>>>        Get psServer to sServer
82960>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
82961>>>>>>>        If (hDatabase = 0) Begin
82963>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
82964>>>>>>>>
82964>>>>>>>            Procedure_Return
82965>>>>>>>        End
82965>>>>>>>>
82965>>>>>>>
82965>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
82968>>>>>>>
82968>>>>>>>    End_Procedure
82969>>>>>>>
82969>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
82969>>>>>>>    // are mapped to the standard DataFlex data types.
82969>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
82969>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
82971>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
82971>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
82973>>>>>>>        String sDataType
82973>>>>>>>        Integer iDataType iDriverID iCount
82973>>>>>>>        Boolean bSQLDriver
82973>>>>>>>
82973>>>>>>>        Move 0 to iCount
82974>>>>>>>        Get DriverIndex sDriverID to iDriverID
82975>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
82976>>>>>>>        If (bSQLDriver = False) Begin
82978>>>>>>>            Function_Return EmptyArray
82979>>>>>>>        End
82979>>>>>>>>
82979>>>>>>>
82979>>>>>>>        // DF_ASCII
82979>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
82981>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
82984>>>>>>>        End
82984>>>>>>>>
82984>>>>>>>        Else Begin
82985>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
82988>>>>>>>        End
82988>>>>>>>>
82988>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
82989>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
82990>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
82991>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
82992>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
82993>>>>>>>        Increment iCount
82994>>>>>>>
82994>>>>>>>        // DF_BINARY
82994>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
82996>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
82999>>>>>>>        End
82999>>>>>>>>
82999>>>>>>>        Else Begin
83000>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83003>>>>>>>        End
83003>>>>>>>>
83003>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
83004>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
83005>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
83006>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
83007>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
83008>>>>>>>        Increment iCount
83009>>>>>>>
83009>>>>>>>        // DF_DATE
83009>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83011>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83014>>>>>>>        End
83014>>>>>>>>
83014>>>>>>>        Else Begin
83015>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83018>>>>>>>        End
83018>>>>>>>>
83018>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
83019>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
83020>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
83021>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
83022>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
83023>>>>>>>        Increment iCount
83024>>>>>>>
83024>>>>>>>        // DF_DATETIME
83024>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83026>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83029>>>>>>>        End
83029>>>>>>>>
83029>>>>>>>        Else Begin
83030>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83033>>>>>>>        End
83033>>>>>>>>
83033>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
83034>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
83035>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
83036>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
83037>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
83038>>>>>>>        Increment iCount
83039>>>>>>>
83039>>>>>>>        // DF_NUMERIC
83039>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83039>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83039>>>>>>>        // we make them here all "Numeric"...
83039>>>>>>>        Case Begin
83039>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
83041>>>>>>>                Move SQL_NUMERIC to iDataType
83042>>>>>>>                Move "numeric"   to sDataType
83043>>>>>>>                Case Break
83044>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83047>>>>>>>                Move SQL_NUMERIC to iDataType
83048>>>>>>>                Move "NUMERIC"   to sDataType
83049>>>>>>>                Case Break
83050>>>>>>>            Case (sDriverID = SQLFLEX)
83053>>>>>>>                Move eSQLServer_NUMERIC to iDataType
83054>>>>>>>                Move "numeric"   to sDataType
83055>>>>>>>                Case Break
83056>>>>>>>            Case (sDriverID = MDSMySQL)
83059>>>>>>>                Move eMySQL_DECIMAL to iDataType
83060>>>>>>>                Move "decimal"   to sDataType
83061>>>>>>>                Case Break
83062>>>>>>>            Case (sDriverID = ORAFLEX)
83065>>>>>>>                Move eOracle_NUMBER to iDataType
83066>>>>>>>                Move "NUMBER"   to sDataType
83067>>>>>>>                Case Break
83068>>>>>>>            Case (sDriverID = MDSPgSQL)
83071>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
83072>>>>>>>                Move "decimal"   to sDataType
83073>>>>>>>                Case Break
83074>>>>>>>            Case Else
83074>>>>>>>                Move DF_BCD      to iDataType
83075>>>>>>>                Move "Numeric"   to sDataType
83076>>>>>>>        Case End
83076>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
83077>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
83078>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
83079>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
83080>>>>>>>        Increment iCount
83081>>>>>>>
83081>>>>>>>        // DF_TEXT
83081>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83083>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83086>>>>>>>        End
83086>>>>>>>>
83086>>>>>>>        Else Begin
83087>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83090>>>>>>>        End
83090>>>>>>>>
83090>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
83091>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
83092>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
83093>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
83094>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
83095>>>>>>>
83095>>>>>>>        Function_Return ColumnTypeArray
83096>>>>>>>    End_Function
83097>>>>>>>
83097>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83099>>>>>>>        tColumnType[] ColumnTypeArray
83099>>>>>>>        tColumnType[] ColumnTypeArray
83100>>>>>>>        tColumnType   ColumnType
83100>>>>>>>        tColumnType   ColumnType
83100>>>>>>>        Integer iCount iSize
83100>>>>>>>
83100>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
83101>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83102>>>>>>>        Decrement iSize
83103>>>>>>>
83103>>>>>>>        for iCount from 0 to iSize
83109>>>>>>>>
83109>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
83111>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
83112>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
83113>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
83114>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
83115>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
83116>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
83117>>>>>>>                Move iSize to iCount
83118>>>>>>>            End
83118>>>>>>>>
83118>>>>>>>        Loop
83119>>>>>>>>
83119>>>>>>>
83119>>>>>>>        Function_Return ColumnType
83120>>>>>>>    End_Function
83121>>>>>>>
83121>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83121>>>>>>>    // are mapped to a DUF data type.
83121>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83123>>>>>>>        tColumnType ColumnType
83123>>>>>>>        tColumnType ColumnType
83123>>>>>>>        String sDataType
83123>>>>>>>        Integer iDriverID iCount
83123>>>>>>>
83123>>>>>>>        Move 0 to iCount
83124>>>>>>>        Get DriverIndex sDriverID to iDriverID
83125>>>>>>>
83125>>>>>>>        Case Begin
83125>>>>>>>            // DF_ASCII
83125>>>>>>>            Case (iType = DF_ASCII_DUF)
83127>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83129>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83132>>>>>>>                End
83132>>>>>>>>
83132>>>>>>>                Else Begin
83133>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83136>>>>>>>                End
83136>>>>>>>>
83136>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83137>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83138>>>>>>>                Move sDataType   to ColumnType.sSQLType
83139>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83140>>>>>>>                Move False       to ColumnType.bCanEditSize
83141>>>>>>>                Case Break
83142>>>>>>>
83142>>>>>>>            // DF_BINARY
83142>>>>>>>            Case (iType = DF_BINARY_DUF)
83145>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83147>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83150>>>>>>>                End
83150>>>>>>>>
83150>>>>>>>                Else Begin
83151>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83154>>>>>>>                End
83154>>>>>>>>
83154>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83155>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83156>>>>>>>                Move sDataType   to ColumnType.sSQLType
83157>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83158>>>>>>>                Move False       to ColumnType.bCanEditSize
83159>>>>>>>                Case Break
83160>>>>>>>
83160>>>>>>>            // DF_DATE
83160>>>>>>>            Case (iType = DF_DATE_DUF)
83163>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83165>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83168>>>>>>>                End
83168>>>>>>>>
83168>>>>>>>                Else Begin
83169>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83172>>>>>>>                End
83172>>>>>>>>
83172>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83173>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83174>>>>>>>                Move sDataType   to ColumnType.sSQLType
83175>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83176>>>>>>>                Move True        to ColumnType.bCanEditSize
83177>>>>>>>                Case Break
83178>>>>>>>
83178>>>>>>>            // DF_DATETIME
83178>>>>>>>            Case (iType = DF_DATETIME_DUF)
83181>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83183>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83186>>>>>>>                End
83186>>>>>>>>
83186>>>>>>>                Else Begin
83187>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83190>>>>>>>                End
83190>>>>>>>>
83190>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83191>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83192>>>>>>>                Move sDataType   to ColumnType.sSQLType
83193>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83194>>>>>>>                Move True        to ColumnType.bCanEditSize
83195>>>>>>>                Case Break
83196>>>>>>>
83196>>>>>>>            // DF_NUMERIC
83196>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83196>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83196>>>>>>>            // we make them here all "Numeric"...
83196>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83196>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83196>>>>>>>            // End
83196>>>>>>>            // Else Begin
83196>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83196>>>>>>>            // End
83196>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83196>>>>>>>            Case (iType = DF_BCD_DUF)
83199>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83200>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83201>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83202>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83203>>>>>>>                Move False       to ColumnType.bCanEditSize
83204>>>>>>>                Case Break
83205>>>>>>>
83205>>>>>>>            // DF_TEXT
83205>>>>>>>            Case (iType = DF_TEXT_DUF)
83208>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83210>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83213>>>>>>>                End
83213>>>>>>>>
83213>>>>>>>                Else Begin
83214>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83217>>>>>>>                End
83217>>>>>>>>
83217>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83218>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83219>>>>>>>                Move sDataType   to ColumnType.sSQLType
83220>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83221>>>>>>>                Move False       to ColumnType.bCanEditSize
83222>>>>>>>                Case Break
83223>>>>>>>
83223>>>>>>>            Case Else
83223>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83224>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83225>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83226>>>>>>>                Move -1999       to ColumnType.iSQLType
83227>>>>>>>                Move True        to ColumnType.bCanEditSize
83228>>>>>>>
83228>>>>>>>        Case End
83228>>>>>>>
83228>>>>>>>        Function_Return ColumnType
83229>>>>>>>    End_Function
83230>>>>>>>
83230>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
83232>>>>>>>        String sDataPath sDriverID
83232>>>>>>>        Boolean bMertechDriver bOK
83232>>>>>>>        Integer iPos
83232>>>>>>>
83232>>>>>>>        If (sTableName contains ".") Begin
83234>>>>>>>            Move (Pos(".", sTableName)) to iPos
83235>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
83236>>>>>>>        End
83236>>>>>>>>
83236>>>>>>>
83236>>>>>>>        Get psDriverID to sDriverID
83237>>>>>>>        Get psDataPathFirstPart to sDataPath
83238>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83239>>>>>>>        // First delete the cache file:
83239>>>>>>>        If (bMertechDriver = False) Begin
83241>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
83242>>>>>>>        End
83242>>>>>>>>
83242>>>>>>>        Else Begin
83243>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
83244>>>>>>>        End
83244>>>>>>>>
83244>>>>>>>
83244>>>>>>>        Function_Return bOK
83245>>>>>>>    End_Function
83246>>>>>>>
83246>>>>>>>    // Changes source code files.
83246>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
83246>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
83246>>>>>>>    // to use a Connection ID.
83246>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
83246>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
83246>>>>>>>    // Returns True if no errors occured.
83246>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
83248>>>>>>>        Integer iCh iRow iItems iCount
83248>>>>>>>        String sValue sRow
83248>>>>>>>        String[] sFileArray
83249>>>>>>>        Boolean bExists bIsActive
83249>>>>>>>
83249>>>>>>>        Move False to Err
83250>>>>>>>        Move 0 to iRow
83251>>>>>>>
83251>>>>>>>        If (ghoStatusPanel <> 0) Begin
83253>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
83254>>>>>>>        End
83254>>>>>>>>
83254>>>>>>>
83254>>>>>>>        Get vFilePathExists sFileName to bExists
83255>>>>>>>        If (bExists = False) Begin
83257>>>>>>>            If (bShowResult = True) Begin
83259>>>>>>>                If (bIsActive = True) Begin
83261>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
83262>>>>>>>                End
83262>>>>>>>>
83262>>>>>>>                Else Begin
83263>>>>>>>                    Showln "File does not exist: " sFileName
83266>>>>>>>                End
83266>>>>>>>>
83266>>>>>>>            End
83266>>>>>>>>
83266>>>>>>>            Function_Return False
83267>>>>>>>        End
83267>>>>>>>>
83267>>>>>>>
83267>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
83268>>>>>>>        If (iCh < 1) Begin
83270>>>>>>>            Function_Return False
83271>>>>>>>        End
83271>>>>>>>>
83271>>>>>>>
83271>>>>>>>        If (bShowResult = True) Begin
83273>>>>>>>            If (ghoStatusPanel <> 0) Begin
83275>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
83276>>>>>>>                If (bIsActive = True) Begin
83278>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
83279>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
83280>>>>>>>                    Send DoAdvance of ghoProgressBar
83281>>>>>>>                End
83281>>>>>>>>
83281>>>>>>>            End
83281>>>>>>>>
83281>>>>>>>            Else Begin
83282>>>>>>>                Showln ""
83284>>>>>>>                Showln "sFileName = " sFileName
83287>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
83292>>>>>>>            End
83292>>>>>>>>
83292>>>>>>>        End
83292>>>>>>>>
83292>>>>>>>
83292>>>>>>>        While (not(SeqEof))
83296>>>>>>>            Readln channel iCh sRow
83298>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
83300>>>>>>>//                If (bShowResult = True) Begin
83300>>>>>>>//                    If (bIsActive = True) Begin
83300>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
83300>>>>>>>//                    End
83300>>>>>>>//                    Else Begin
83300>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
83300>>>>>>>//                    End
83300>>>>>>>//                End
83300>>>>>>>                // Change the whole line to the new connection id:
83300>>>>>>>                Move sChangeTo to sRow
83301>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
83301>>>>>>>            End
83301>>>>>>>>
83301>>>>>>>            Move sRow to sFileArray[iRow]
83302>>>>>>>            Increment iRow
83303>>>>>>>        Loop
83304>>>>>>>>
83304>>>>>>>        Send Seq_Close_Channel iCh
83305>>>>>>>
83305>>>>>>>        Sleep 1 // Wait for Windows to close the file
83306>>>>>>>
83306>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
83307>>>>>>>        If (iCh < 1) Begin
83309>>>>>>>            Function_Return False
83310>>>>>>>        End
83310>>>>>>>>
83310>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
83311>>>>>>>        Decrement iItems
83312>>>>>>>
83312>>>>>>>        For iCount from 0 to iItems
83318>>>>>>>>
83318>>>>>>>            Move sFileArray[iCount] to sValue
83319>>>>>>>            Writeln channel iCh sValue
83322>>>>>>>        Loop
83323>>>>>>>>
83323>>>>>>>        Send Seq_Close_Channel iCh
83324>>>>>>>
83324>>>>>>>        Function_Return (Err = False)
83325>>>>>>>    End_Function
83326>>>>>>>
83326>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
83328>>>>>>>        Integer iRetval
83328>>>>>>>        Move 1 to iRetval
83329>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
83331>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
83332>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
83333>>>>>>>        End
83333>>>>>>>>
83333>>>>>>>        Function_Return (iRetval = 0)
83334>>>>>>>    End_Function
83335>>>>>>>
83335>>>>>>>    // *** DEPRECIATED ***
83335>>>>>>>    // Use the AutoSetConnectionID function instead.
83335>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
83335>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
83335>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
83335>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
83335>>>>>>>//        String sConnectionString sDriverID
83335>>>>>>>//        Boolean bOK bSilent bDawDriver
83335>>>>>>>//        Handle hoCLI
83335>>>>>>>//
83335>>>>>>>//        Move False to bOK
83335>>>>>>>//        Get psDriverID to sDriverID
83335>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
83335>>>>>>>//        If (bDawDriver = False) Begin
83335>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
83335>>>>>>>//            Function_Return False
83335>>>>>>>//        End
83335>>>>>>>//
83335>>>>>>>//        Get psConnectionString to sConnectionString
83335>>>>>>>//        Get pbSilentLogin      to bSilent
83335>>>>>>>//
83335>>>>>>>//        Get phoCLIHandler to hoCLI
83335>>>>>>>//        If (hoCLI <> 0) Begin
83335>>>>>>>//            Set psDriverID of hoCLI to sDriverID
83335>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
83335>>>>>>>//        End
83335>>>>>>>//
83335>>>>>>>//        Function_Return (bOK = False)
83335>>>>>>>//    End_Function
83335>>>>>>>
83335>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
83335>>>>>>>    // and opens it in "notepad.exe".
83335>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
83335>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
83335>>>>>>>    Procedure UtilShowErrorList
83337>>>>>>>        tSqlErrorArray aSqlErrorArray
83337>>>>>>>        tSqlErrorArray aSqlErrorArray
83337>>>>>>>        Integer iRows iCount iCh iErrorNum
83337>>>>>>>        String sPath sFileName sErrorTxt sStatement
83337>>>>>>>
83337>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
83338>>>>>>>        Get vFolderFormat sPath to sPath
83339>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
83340>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
83341>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
83342>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
83343>>>>>>>            If (iRows > 0) Begin
83345>>>>>>>                Decrement iRows
83346>>>>>>>                for iCount from 0 to iRows
83352>>>>>>>>
83352>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
83353>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
83354>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
83355>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
83361>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
83365>>>>>>>                Loop
83366>>>>>>>>
83366>>>>>>>            End
83366>>>>>>>>
83366>>>>>>>        Send Seq_Close_Channel iCh
83367>>>>>>>
83367>>>>>>>        If (iRows > 0) Begin
83369>>>>>>>            Runprogram Shell Background (sPath + sFileName)
83370>>>>>>>        End
83370>>>>>>>>
83370>>>>>>>    End_Procedure
83371>>>>>>>
83371>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
83371>>>>>>>    // and the table needs to exist as an SQL table.
83371>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
83373>>>>>>>        String sRootName sDriverID
83373>>>>>>>        Boolean bIsSQL
83373>>>>>>>
83373>>>>>>>        Move False to bIsSQL
83374>>>>>>>        If (hTable > 0) Begin
83376>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83379>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
83380>>>>>>>            If (bIsSQL = True) Begin
83382>>>>>>>                Get psDriverID to sDriverID
83383>>>>>>>                Get _TableNameOnly sRootName to sRootName
83384>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
83385>>>>>>>            End
83385>>>>>>>>
83385>>>>>>>        End
83385>>>>>>>>
83385>>>>>>>
83385>>>>>>>        Function_Return bIsSQL
83386>>>>>>>    End_Function
83387>>>>>>>
83387>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
83389>>>>>>>        Boolean bIsSQL
83389>>>>>>>        Move (sRootName contains ":") to bIsSQL
83390>>>>>>>        Function_Return bIsSQL
83391>>>>>>>    End_Function
83392>>>>>>>
83392>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
83392>>>>>>>    // that the embedded .dat file exists on disk.
83392>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
83394>>>>>>>        Boolean bExists bIsEmbedded
83394>>>>>>>        String sDataPath sRootName
83394>>>>>>>
83394>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
83395>>>>>>>        If (bExists = False) Begin
83397>>>>>>>            Function_Return False
83398>>>>>>>        End
83398>>>>>>>>
83398>>>>>>>
83398>>>>>>>        Move False to bIsEmbedded
83399>>>>>>>        If (hTable > 0) Begin
83401>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83404>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
83405>>>>>>>        End
83405>>>>>>>>
83405>>>>>>>        If (bIsEmbedded = True) Begin
83407>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83408>>>>>>>            Get vFolderFormat sDataPath to sDataPath
83409>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
83410>>>>>>>        End
83410>>>>>>>>
83410>>>>>>>
83410>>>>>>>        Function_Return bIsEmbedded
83411>>>>>>>    End_Function
83412>>>>>>>
83412>>>>>>>
83412>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
83412>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
83412>>>>>>>    // but the Logical name is different.
83412>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
83412>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
83414>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
83414>>>>>>>        Handle hInTable hMasterTable 
83414>>>>>>>        Boolean bIsAlias
83414>>>>>>>        
83414>>>>>>>        Move hTable to hInTable
83415>>>>>>>        Move False to bIsAlias
83416>>>>>>>        Move 0 to hMasterTable
83417>>>>>>>        
83417>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83420>>>>>>>        // Remove any prefix with a driver name.
83420>>>>>>>        Get _TableNameOnly sRootName to sRootName     
83421>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83424>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
83425>>>>>>>        
83425>>>>>>>        // If the table has the same root and logical name it can't be an alias,
83425>>>>>>>        // so we can safely return a "False".
83425>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
83427>>>>>>>            Function_Return False
83428>>>>>>>        End
83428>>>>>>>>
83428>>>>>>>        
83428>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
83428>>>>>>>        // as the passed hTable root name.
83428>>>>>>>        // A master table always has the same root and logical name.
83428>>>>>>>        Move 0 to hTable
83429>>>>>>>        Repeat
83429>>>>>>>>
83429>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83432>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
83434>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
83437>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
83438>>>>>>>                // If we found another table with the same root and logical name
83438>>>>>>>                // we have found a master table.
83438>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
83440>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
83443>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
83444>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
83446>>>>>>>                        Move hTable to hMasterTable   
83447>>>>>>>                        Move 0 to hTable // To end the loop.
83448>>>>>>>                    End
83448>>>>>>>>
83448>>>>>>>                End
83448>>>>>>>>
83448>>>>>>>            End
83448>>>>>>>>
83448>>>>>>>        Until (hTable = 0)
83450>>>>>>>        
83450>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
83452>>>>>>>            Move True to bIsAlias
83453>>>>>>>        End
83453>>>>>>>>
83453>>>>>>>        
83453>>>>>>>        Function_Return bIsAlias
83454>>>>>>>    End_Function
83455>>>>>>>
83455>>>>>>>    // To Open a table with any driver.
83455>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
83455>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
83455>>>>>>>    //
83455>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
83455>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
83455>>>>>>>    // returns a True if successful (table could be opened).
83455>>>>>>>    //
83455>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
83455>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
83455>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
83455>>>>>>>    // set properly we can open the table.
83455>>>>>>>    //
83455>>>>>>>    // DAW Driver Syntax:
83455>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
83455>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
83455>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
83455>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
83455>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
83455>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
83455>>>>>>>    //
83455>>>>>>>    // DAW Driver Sample:
83455>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
83455>>>>>>>    //
83455>>>>>>>    // Mertech Driver Samples:
83455>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
83455>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
83455>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
83455>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
83455>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
83457>>>>>>>        String sTableNameOrg
83457>>>>>>>        Boolean bOpen bOK
83457>>>>>>>        tSQLConnection SQLConnection
83457>>>>>>>        tSQLConnection SQLConnection
83457>>>>>>>        
83457>>>>>>>        Move False to bOpen
83458>>>>>>>        Move sTableName to sTableNameOrg
83459>>>>>>>        If (hTable > 0) Begin
83461>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
83462>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
83463>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
83464>>>>>>>            Send Ignore_Error of Error_Object_Id 10
83465>>>>>>>            Open hTable Mode iMode
83467>>>>>>>            Send Trap_Error of Error_Object_Id 20529
83468>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
83469>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
83470>>>>>>>            Send Trap_Error of Error_Object_Id 10
83471>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
83474>>>>>>>            If (bOpen = True) Begin
83476>>>>>>>                Function_Return True
83477>>>>>>>            End
83477>>>>>>>>
83477>>>>>>>        End
83477>>>>>>>>
83477>>>>>>>
83477>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
83478>>>>>>>        If (hTable > 0) Begin
83480>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
83483>>>>>>>        End
83483>>>>>>>>
83483>>>>>>>
83483>>>>>>>        Function_Return bOpen
83484>>>>>>>    End_Function
83485>>>>>>>
83485>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
83487>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
83487>>>>>>>        Boolean bOpen bMertechDriver bOK
83487>>>>>>>        tSQLConnection SQLConnection
83487>>>>>>>        tSQLConnection SQLConnection
83487>>>>>>>
83487>>>>>>>        If (hTable < 1) Begin
83489>>>>>>>            Function_Return False
83490>>>>>>>        End
83490>>>>>>>>
83490>>>>>>>
83490>>>>>>>        Move sTableName to sTableNameOrg
83491>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83492>>>>>>>        Move SQLConnection.sDriverID to sDriverID
83493>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83494>>>>>>>        Move SQLConnection.sConnectionString to sConnection
83495>>>>>>>        Move SQLConnection.sSchema to sSchema
83496>>>>>>>        If (sSchema = "") Begin
83498>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
83499>>>>>>>        End
83499>>>>>>>>
83499>>>>>>>
83499>>>>>>>        // We need to remove the ".int" part of the table name because
83499>>>>>>>        // the table name after the "#" in the connection syntax below wants the
83499>>>>>>>        // "bare" table name without any extension.
83499>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
83501>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
83503>>>>>>>                Get ParseFileExtension sTableName to sExt
83504>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
83505>>>>>>>            End
83505>>>>>>>>
83505>>>>>>>            Else Begin
83506>>>>>>>                Move sTableName to sTableNameShort
83507>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
83508>>>>>>>            End
83508>>>>>>>>
83508>>>>>>>            If (bMertechDriver = False) Begin
83510>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
83511>>>>>>>                Move sConnection to sTableName
83512>>>>>>>            End
83512>>>>>>>>
83512>>>>>>>        End
83512>>>>>>>>
83512>>>>>>>
83512>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
83513>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
83514>>>>>>>        If (hTable = 0) Begin
83516>>>>>>>            Get NextFreeFilelistSlot to hTable
83517>>>>>>>        End
83517>>>>>>>>
83517>>>>>>>
83517>>>>>>>        Case Begin
83517>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
83519>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83519>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83521>>>>>>>                    Close hTable
83522>>>>>>>                    Open sTableName as hTable
83524>>>>>>>                End
83524>>>>>>>>
83524>>>>>>>                Else Begin
83525>>>>>>>                    Get OpenTableExclusive hTable to bOK
83526>>>>>>>                    If (bOK = False) Begin
83528>>>>>>>                        Function_Return False
83529>>>>>>>                    End
83529>>>>>>>>
83529>>>>>>>                End
83529>>>>>>>>
83529>>>>>>>                Case Break
83530>>>>>>>
83530>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83533>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83533>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83535>>>>>>>                    Close hTable
83536>>>>>>>                    Open sTableName as hTable
83538>>>>>>>                End
83538>>>>>>>>
83538>>>>>>>                Else Begin
83539>>>>>>>                    Get OpenTableExclusive hTable to bOK
83540>>>>>>>                    If (bOK = False) Begin
83542>>>>>>>                        Function_Return False
83543>>>>>>>                    End
83543>>>>>>>>
83543>>>>>>>                End
83543>>>>>>>>
83543>>>>>>>                Case Break
83544>>>>>>>
83544>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
83547>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83547>>>>>>>                If (iMode = DF_SHARE) Begin
83549>>>>>>>                    Close hTable
83550>>>>>>>                    Open sTableName as hTable
83552>>>>>>>                End
83552>>>>>>>>
83552>>>>>>>                Else Begin
83553>>>>>>>                    Get OpenTableExclusive hTable to bOK
83554>>>>>>>                    If (bOK = False) Begin
83556>>>>>>>                        Function_Return False
83557>>>>>>>                    End
83557>>>>>>>>
83557>>>>>>>                End
83557>>>>>>>>
83557>>>>>>>                Case Break
83558>>>>>>>
83558>>>>>>>            Case (sDriverID = SQLFLEX)
83561>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
83561>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
83561>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
83562>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83562>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83564>>>>>>>                    Close hTable
83565>>>>>>>                    Open sTableName as hTable
83567>>>>>>>                End
83567>>>>>>>>
83567>>>>>>>                Else Begin
83568>>>>>>>                    Get OpenTableExclusive hTable to bOK
83569>>>>>>>                    If (bOK = False) Begin
83571>>>>>>>                        Function_Return False
83572>>>>>>>                    End
83572>>>>>>>>
83572>>>>>>>                End
83572>>>>>>>>
83572>>>>>>>                Case Break
83573>>>>>>>
83573>>>>>>>            Case (sDriverID = MDSMySQL)
83576>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
83576>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
83577>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83577>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83579>>>>>>>                    Close hTable
83580>>>>>>>                    Open sTableName as hTable
83582>>>>>>>                End
83582>>>>>>>>
83582>>>>>>>                Else Begin
83583>>>>>>>                    Get OpenTableExclusive hTable to bOK
83584>>>>>>>                    If (bOK = False) Begin
83586>>>>>>>                        Function_Return False
83587>>>>>>>                    End
83587>>>>>>>>
83587>>>>>>>                End
83587>>>>>>>>
83587>>>>>>>                Case Break
83588>>>>>>>
83588>>>>>>>            Case (sDriverID = MDSPgSQL)
83591>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
83591>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
83592>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83592>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83594>>>>>>>                    Close hTable
83595>>>>>>>                    Open sTableName as hTable
83597>>>>>>>                End
83597>>>>>>>>
83597>>>>>>>                Else Begin
83598>>>>>>>                    Get OpenTableExclusive hTable to bOK
83599>>>>>>>                    If (bOK = False) Begin
83601>>>>>>>                        Function_Return False
83602>>>>>>>                    End
83602>>>>>>>>
83602>>>>>>>                End
83602>>>>>>>>
83602>>>>>>>                Case Break
83603>>>>>>>
83603>>>>>>>            Case (sDriverID = ORAFLEX)
83606>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
83606>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
83606>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
83607>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
83607>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
83609>>>>>>>                    Close hTable
83610>>>>>>>                    Open sTableName as hTable
83612>>>>>>>                End
83612>>>>>>>>
83612>>>>>>>                Else Begin
83613>>>>>>>                    Get OpenTableExclusive hTable to bOK
83614>>>>>>>                    If (bOK = False) Begin
83616>>>>>>>                        Function_Return False
83617>>>>>>>                    End
83617>>>>>>>>
83617>>>>>>>                End
83617>>>>>>>>
83617>>>>>>>                Case Break
83618>>>>>>>
83618>>>>>>>            Case (sDriverID = DATAFLEX_ID)
83621>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
83623>>>>>>>                    Close hTable
83624>>>>>>>                    Open sTableName as hTable
83626>>>>>>>                End
83626>>>>>>>>
83626>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
83629>>>>>>>                    Get OpenTableExclusive hTable to bOK
83630>>>>>>>                    If (bOK = False) Begin
83632>>>>>>>                        Function_Return False
83633>>>>>>>                    End
83633>>>>>>>>
83633>>>>>>>                End
83633>>>>>>>>
83633>>>>>>>                Else Begin
83634>>>>>>>                    Open hTable
83636>>>>>>>                End
83636>>>>>>>>
83636>>>>>>>                Case Break
83637>>>>>>>
83637>>>>>>>            Case Else
83637>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
83638>>>>>>>>
83638>>>>>>>        Case End
83638>>>>>>>
83638>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
83639>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
83640>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
83642>>>>>>>            Move False to Found
83643>>>>>>>        End
83643>>>>>>>>
83643>>>>>>>        // If open failed, the Err is set to true,
83643>>>>>>>        // but we don't want that because it could end our loop.
83643>>>>>>>        Move False to Err
83644>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
83647>>>>>>>
83647>>>>>>>        Function_Return bOpen
83648>>>>>>>    End_Function
83649>>>>>>>
83649>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
83649>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
83649>>>>>>>    // if it is an SQL table
83649>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
83651>>>>>>>        Boolean bExists bIsSQLTable
83651>>>>>>>        String sDataPath sRootName
83651>>>>>>>
83651>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
83652>>>>>>>        If (bExists = False) Begin
83654>>>>>>>            Function_Return False
83655>>>>>>>        End
83655>>>>>>>>
83655>>>>>>>
83655>>>>>>>        Move False to bIsSQLTable
83656>>>>>>>        If (hTable > 0) Begin
83658>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83661>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
83662>>>>>>>        End
83662>>>>>>>>
83662>>>>>>>        If (bIsSQLTable = True) Begin
83664>>>>>>>            Get UtilTableIsSQL hTable to bExists
83665>>>>>>>            Function_Return bExists
83666>>>>>>>        End
83666>>>>>>>>
83666>>>>>>>        Else Begin
83667>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83668>>>>>>>            Get vFolderFormat sDataPath to sDataPath
83669>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
83670>>>>>>>        End
83670>>>>>>>>
83670>>>>>>>
83670>>>>>>>        Function_Return bExists
83671>>>>>>>    End_Function
83672>>>>>>>
83672>>>>>>>    // Pass a table handle
83672>>>>>>>    // Returns True if the table exists in filelist.cfg.
83672>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
83674>>>>>>>        Handle hTable
83674>>>>>>>        Boolean bFound
83674>>>>>>>
83674>>>>>>>        Move False to bFound
83675>>>>>>>        Move 0 to hTable
83676>>>>>>>        Repeat
83676>>>>>>>>
83676>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83679>>>>>>>            If (hTable > 0) Begin
83681>>>>>>>                If (hTable = hCheckTable) Begin
83683>>>>>>>                    Move True to bFound
83684>>>>>>>                End
83684>>>>>>>>
83684>>>>>>>            End
83684>>>>>>>>
83684>>>>>>>            If (bFound = True) ;                Break
83687>>>>>>>        Until (hTable = 0)
83689>>>>>>>
83689>>>>>>>        Function_Return (bFound = True)
83690>>>>>>>    End_Function
83691>>>>>>>
83691>>>>>>>    // Pass a table's logical name
83691>>>>>>>    // Returns True if the table exists in filelist.cfg.
83691>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
83693>>>>>>>        Handle hTable
83693>>>>>>>        Boolean bFound
83693>>>>>>>        String sCompareTable
83693>>>>>>>
83693>>>>>>>        Move False to bFound
83694>>>>>>>        Move 0 to hTable
83695>>>>>>>        Repeat
83695>>>>>>>>
83695>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83698>>>>>>>            If (hTable > 0) Begin
83700>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
83703>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
83705>>>>>>>                    Move True to bFound
83706>>>>>>>                End
83706>>>>>>>>
83706>>>>>>>            End
83706>>>>>>>>
83706>>>>>>>            If (bFound = True) ;                Break
83709>>>>>>>        Until (hTable = 0)
83711>>>>>>>
83711>>>>>>>        Function_Return (bFound = True)
83712>>>>>>>    End_Function
83713>>>>>>>
83713>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
83713>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
83715>>>>>>>        Boolean bOK bExists
83715>>>>>>>        String sDriverID
83715>>>>>>>
83715>>>>>>>        Get UtilTableExists hTable to bExists
83716>>>>>>>        If (bExists = False) Begin
83718>>>>>>>            Function_Return DATAFLEX_ID
83719>>>>>>>        End
83719>>>>>>>>
83719>>>>>>>        Get OpenTableExclusive hTable to bOK
83720>>>>>>>        If (bOK = False) Begin
83722>>>>>>>            Function_Return DATAFLEX_ID
83723>>>>>>>        End
83723>>>>>>>>
83723>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
83726>>>>>>>        Function_Return sDriverID
83727>>>>>>>    End_Function
83728>>>>>>>
83728>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
83728>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
83730>>>>>>>        Handle hTable
83730>>>>>>>        Integer iRetval
83730>>>>>>>
83730>>>>>>>        Move 0 to hTable
83731>>>>>>>        Move 0 to iRetval
83732>>>>>>>
83732>>>>>>>        Repeat
83732>>>>>>>>
83732>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83735>>>>>>>            If (hTable > 0) Begin
83737>>>>>>>                Increment iRetval
83738>>>>>>>            End
83738>>>>>>>>
83738>>>>>>>        Until (hTable = 0)
83740>>>>>>>
83740>>>>>>>        Function_Return iRetval
83741>>>>>>>    End_Function
83742>>>>>>>
83742>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
83742>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
83744>>>>>>>        Handle hTable
83744>>>>>>>        String sRoot sDriverID
83744>>>>>>>        Boolean bIsSQLTable
83744>>>>>>>        Integer iPos
83744>>>>>>>
83744>>>>>>>        Move 0 to hTable
83745>>>>>>>        Move "" to sDriverID
83746>>>>>>>        Move False to bIsSQLTable
83747>>>>>>>
83747>>>>>>>        Repeat
83747>>>>>>>>
83747>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83750>>>>>>>            If (hTable > 0) Begin
83752>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
83755>>>>>>>                If (sRoot contains ":") Begin
83757>>>>>>>                    Move (Pos(":", sRoot)) to iPos
83758>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
83759>>>>>>>                End
83759>>>>>>>>
83759>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
83760>>>>>>>            End
83760>>>>>>>>
83760>>>>>>>
83760>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
83762>>>>>>>
83762>>>>>>>        Function_Return sDriverID
83763>>>>>>>    End_Function
83764>>>>>>>
83764>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
83766>>>>>>>        String sRootName
83766>>>>>>>        Boolean bIsSQL
83766>>>>>>>        Handle hTable
83766>>>>>>>
83766>>>>>>>        Move False to bIsSQL
83767>>>>>>>        Move 0 to hTable
83768>>>>>>>        Repeat
83768>>>>>>>>
83768>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83771>>>>>>>            If (hTable > 0) Begin
83773>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83776>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
83777>>>>>>>                If (bIsSQL = True) Begin
83779>>>>>>>                    Move 0 to hTable
83780>>>>>>>                End
83780>>>>>>>>
83780>>>>>>>            End
83780>>>>>>>>
83780>>>>>>>        Until (hTable = 0)
83782>>>>>>>
83782>>>>>>>        Function_Return (bIsSQL = False)
83783>>>>>>>    End_Function
83784>>>>>>>
83784>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83784>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
83786>>>>>>>        Function_Return False
83787>>>>>>>    End_Function
83788>>>>>>>
83788>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
83790>>>>>>>        String  sRetval
83790>>>>>>>        String[] sOverlapFieldsArray
83791>>>>>>>        Integer iType iColumn iColumns
83791>>>>>>>        Boolean bOpen bOverlap
83791>>>>>>>
83791>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
83794>>>>>>>        If (bOpen = False) Begin
83796>>>>>>>            Open hTable
83798>>>>>>>        End
83798>>>>>>>>
83798>>>>>>>
83798>>>>>>>        Move "" to sRetval
83799>>>>>>>
83799>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
83802>>>>>>>
83802>>>>>>>        for iColumn from 0 to iColumns
83808>>>>>>>>
83808>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
83811>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
83813>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
83816>>>>>>>                If (bOverlap) Begin
83818>>>>>>>                    If (sRetval <> "") Begin
83820>>>>>>>                        Append sRetval ","
83821>>>>>>>                    End
83821>>>>>>>>
83821>>>>>>>                    Append sRetval iColumn
83822>>>>>>>                End
83822>>>>>>>>
83822>>>>>>>            End
83822>>>>>>>>
83822>>>>>>>        Loop
83823>>>>>>>>
83823>>>>>>>
83823>>>>>>>        If (bOpen = False) Begin
83825>>>>>>>            Close hTable
83826>>>>>>>        End
83826>>>>>>>>
83826>>>>>>>
83826>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
83827>>>>>>>
83827>>>>>>>        Function_Return sOverlapFieldsArray
83828>>>>>>>    End_Function
83829>>>>>>>
83829>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83829>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83831>>>>>>>        tColumnType[] ColumnType
83831>>>>>>>        tColumnType[] ColumnType
83832>>>>>>>
83832>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83832>>>>>>>        // the dbType.
83832>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83834>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83836>>>>>>>                Move MDSMySQL to sDriverID
83837>>>>>>>            End
83837>>>>>>>>
83837>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83839>>>>>>>                Move MSSQLDRV_ID to sDriverID
83840>>>>>>>            End
83840>>>>>>>>
83840>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83842>>>>>>>                Move DB2_DRV_ID to sDriverID
83843>>>>>>>            End
83843>>>>>>>>
83843>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83845>>>>>>>                Move MDSPgSQL to sDriverID
83846>>>>>>>            End
83846>>>>>>>>
83846>>>>>>>        End
83846>>>>>>>>
83846>>>>>>>
83846>>>>>>>        Case Begin
83846>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83848>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83849>>>>>>>                Case Break
83850>>>>>>>
83850>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83853>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83854>>>>>>>                Case Break
83855>>>>>>>
83855>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83858>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83859>>>>>>>                Case Break
83860>>>>>>>
83860>>>>>>>            Case (sDriverID = MDSMySQL)
83863>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
83864>>>>>>>                Case Break
83865>>>>>>>
83865>>>>>>>            Case (sDriverID = ORAFLEX)
83868>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
83869>>>>>>>                Case Break
83870>>>>>>>
83870>>>>>>>            Case (sDriverID = MDSPgSQL)
83873>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
83874>>>>>>>                Case Break
83875>>>>>>>        Case End
83875>>>>>>>
83875>>>>>>>        Function_Return ColumnType
83876>>>>>>>    End_Function
83877>>>>>>>
83877>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
83879>>>>>>>        Handle hoRegistry hoODBCDriverNames
83879>>>>>>>        Boolean bExists bKeyOpened
83879>>>>>>>        String sKey
83879>>>>>>>        String[] sDrivers
83880>>>>>>>        Integer iDriverNames iDriverName
83880>>>>>>>
83880>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
83881>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
83882>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
83883>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
83884>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
83885>>>>>>>        If (bExists) Begin
83887>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
83888>>>>>>>            If (bKeyOpened) Begin
83890>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
83891>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
83892>>>>>>>                If (iDriverNames > 0) Begin
83894>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
83895>>>>>>>                    Decrement iDriverNames
83896>>>>>>>                    for iDriverName from 0 to iDriverNames
83902>>>>>>>>
83902>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
83903>>>>>>>                    Loop
83904>>>>>>>>
83904>>>>>>>                End
83904>>>>>>>>
83904>>>>>>>                Send CloseKey of hoRegistry
83905>>>>>>>            End
83905>>>>>>>>
83905>>>>>>>        End
83905>>>>>>>>
83905>>>>>>>        Send Destroy of hoRegistry
83906>>>>>>>
83906>>>>>>>        Function_Return sDrivers
83907>>>>>>>    End_Function
83908>>>>>>>
83908>>>>>>>    // DataFlex Embedded Database Data Types:
83908>>>>>>>    // Helper function for UtilEnumerateColumnTypes
83908>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
83910>>>>>>>        tColumnType[] ColumnType
83910>>>>>>>        tColumnType[] ColumnType
83911>>>>>>>        Integer i
83911>>>>>>>
83911>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
83912>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
83913>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
83914>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
83915>>>>>>>        Move "254"              to ColumnType[i].sPrecision
83916>>>>>>>        Increment i
83917>>>>>>>
83917>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
83918>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
83919>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
83920>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
83921>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
83922>>>>>>>        Increment i
83923>>>>>>>
83923>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
83924>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
83925>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
83926>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
83927>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
83928>>>>>>>        Move True               to ColumnType[i].bCanEditSize
83929>>>>>>>        Increment i
83930>>>>>>>
83930>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
83931>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
83932>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
83933>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
83934>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
83935>>>>>>>        Increment i
83936>>>>>>>
83936>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
83937>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
83938>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
83939>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
83940>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
83941>>>>>>>        Increment i
83942>>>>>>>
83942>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
83943>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
83944>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83945>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
83946>>>>>>>        Move "23"               to ColumnType[i].sPrecision
83947>>>>>>>        Move True               to ColumnType[i].bCanEditSize
83948>>>>>>>        Increment i
83949>>>>>>>
83949>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
83950>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
83951>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
83952>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
83953>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
83954>>>>>>>
83954>>>>>>>        Function_Return ColumnType
83955>>>>>>>    End_Function
83956>>>>>>>
83956>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
83958>>>>>>>        tColumnType[] aColumnType
83958>>>>>>>        tColumnType[] aColumnType
83959>>>>>>>        Integer i
83959>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
83959>>>>>>>>// Generated By The Database Update Framework
83959>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
83959>>>>>>>>// Driver COLUMN DATA TYPES
83959>>>>>>>>//
83959>>>>>>>>// Created: 2019-07-18 18:57:13.935
83959>>>>>>>>
83959>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83960>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
83961>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83962>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83963>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83964>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83965>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83966>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83967>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83968>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83969>>>>>>>>            Increment i
83970>>>>>>>>
83970>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
83971>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
83972>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83973>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83974>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
83975>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83976>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
83977>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83978>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83979>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
83980>>>>>>>>            Increment i
83981>>>>>>>>
83981>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83982>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
83983>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83984>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83985>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
83986>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
83987>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
83988>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83989>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83990>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
83991>>>>>>>>            Increment i
83992>>>>>>>>
83992>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83993>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83994>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83995>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83996>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
83997>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83998>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
83999>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84000>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84001>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84002>>>>>>>>            Increment i
84003>>>>>>>>
84003>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
84004>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
84005>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84006>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84007>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84008>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84009>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84010>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84011>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84012>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84013>>>>>>>>            Increment i
84014>>>>>>>>
84014>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
84015>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
84016>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84017>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84018>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84019>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84020>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84021>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84022>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84023>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84024>>>>>>>>            Increment i
84025>>>>>>>>
84025>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
84026>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
84027>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84028>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84029>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
84030>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
84031>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84032>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84033>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84034>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84035>>>>>>>>            Increment i
84036>>>>>>>>
84036>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
84037>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
84038>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84039>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84040>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
84041>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
84042>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
84043>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84044>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84045>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
84046>>>>>>>>            Increment i
84047>>>>>>>>
84047>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
84048>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
84049>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84050>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84051>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84052>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84053>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84054>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84055>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84056>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84057>>>>>>>>            Increment i
84058>>>>>>>>
84058>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
84059>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
84060>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84061>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84062>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84063>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84064>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84065>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84066>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84067>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84068>>>>>>>>            Increment i
84069>>>>>>>>
84069>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
84070>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
84071>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84072>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84073>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84074>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84075>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84076>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84077>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84078>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84079>>>>>>>>            Increment i
84080>>>>>>>>
84080>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
84081>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
84082>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84083>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84084>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
84085>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84086>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
84087>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84088>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84089>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
84090>>>>>>>>            Increment i
84091>>>>>>>>
84091>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
84092>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
84093>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84094>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84095>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84096>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84097>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84098>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84099>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84100>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84101>>>>>>>>            Increment i
84102>>>>>>>>
84102>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
84103>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
84104>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84105>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84106>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84107>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84108>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84109>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84110>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84111>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84112>>>>>>>>            Increment i
84113>>>>>>>>
84113>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
84114>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
84115>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84116>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84117>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84118>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84119>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84120>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84121>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84122>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84123>>>>>>>>            Increment i
84124>>>>>>>>
84124>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
84125>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
84126>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84127>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84128>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84129>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84130>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84131>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
84132>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
84133>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
84134>>>>>>>>            Increment i
84135>>>>>>>>
84135>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
84136>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
84137>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84138>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84139>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84140>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84141>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84142>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84143>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84144>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84145>>>>>>>>            Increment i
84146>>>>>>>>
84146>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
84147>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
84148>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84149>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84150>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84151>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84152>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84153>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84154>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84155>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84156>>>>>>>>            Increment i
84157>>>>>>>>
84157>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
84158>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
84159>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84160>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84161>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84162>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84163>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84164>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84165>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84166>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84167>>>>>>>>            Increment i
84168>>>>>>>>
84168>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
84169>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
84170>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84171>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84172>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84173>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84174>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84175>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84176>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84177>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84178>>>>>>>>            Increment i
84179>>>>>>>>
84179>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
84180>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
84181>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84182>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84183>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
84184>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84185>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
84186>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84187>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84188>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
84189>>>>>>>>            Increment i
84190>>>>>>>>
84190>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
84191>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
84192>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84193>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84194>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84195>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84196>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84197>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84198>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84199>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84200>>>>>>>>            Increment i
84201>>>>>>>>
84201>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
84202>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
84203>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84204>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84205>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84206>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84207>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84208>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84209>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84210>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84211>>>>>>>>            Increment i
84212>>>>>>>>
84212>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
84213>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
84214>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84215>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84216>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
84217>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
84218>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
84219>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84220>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84221>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
84222>>>>>>>>            Increment i
84223>>>>>>>>
84223>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
84224>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
84225>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84226>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84227>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
84228>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84229>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
84230>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84231>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84232>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
84233>>>>>>>>            Increment i
84234>>>>>>>>
84234>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
84235>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
84236>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84237>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84238>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84239>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84240>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84241>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84242>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84243>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84244>>>>>>>>            Increment i
84245>>>>>>>>
84245>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
84246>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
84247>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84248>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84249>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
84250>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84251>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84252>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84253>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84254>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84255>>>>>>>>            Increment i
84256>>>>>>>>
84256>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
84257>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
84258>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84259>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84260>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84261>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84262>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84263>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84264>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84265>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84266>>>>>>>>            Increment i
84267>>>>>>>>
84267>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
84268>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
84269>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84270>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84271>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84272>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84273>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84274>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84275>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84276>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84277>>>>>>>>            Increment i
84278>>>>>>>>
84278>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
84279>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
84280>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84281>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84282>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84283>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84284>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84285>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84286>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84287>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84288>>>>>>>>            Increment i
84289>>>>>>>>
84289>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
84290>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
84291>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84292>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84293>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84294>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84295>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84296>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84297>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84298>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84299>>>>>>>>            Increment i
84300>>>>>>>>
84300>>>>>>>>
84300>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
84300>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
84300>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        // ToDo: We need to change the sType when using this!
84300>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
84300>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
84300>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
84300>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
84300>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
84300>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
84300>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
84300>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
84300>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
84300>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
84300>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
84300>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
84300>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
84300>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
84300>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
84300>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
84300>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
84300>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        // ToDo: We need to change the sType when using this!
84300>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
84300>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
84300>>>>>>>//        Increment i
84300>>>>>>>//
84300>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
84300>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>//
84300>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
84300>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
84300>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
84300>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
84300>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
84300>>>>>>>
84300>>>>>>>        Function_Return aColumnType
84301>>>>>>>    End_Function
84302>>>>>>>
84302>>>>>>>    // Microsoft SQL Server Database Data Types:
84302>>>>>>>    // Helper function for UtilEnumerateColumnTypes
84302>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
84304>>>>>>>        tColumnType[] aColumnType
84304>>>>>>>        tColumnType[] aColumnType
84305>>>>>>>        Integer i
84305>>>>>>>
84305>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
84307>>>>>>>>// Generated By The Database Update Framework
84307>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
84307>>>>>>>>// Driver COLUMN DATA TYPES
84307>>>>>>>>//
84307>>>>>>>>// Created: 2019-11-15 21:57:51.001
84307>>>>>>>>
84307>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
84308>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
84309>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84310>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84311>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84312>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84313>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84314>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84315>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84316>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84317>>>>>>>>            Increment i
84318>>>>>>>>
84318>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
84319>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
84320>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84321>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84322>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84323>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84324>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84325>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84326>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84327>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84328>>>>>>>>            Increment i
84329>>>>>>>>
84329>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
84330>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
84331>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84332>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84333>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84334>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84335>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84336>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84337>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84338>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84339>>>>>>>>            Increment i
84340>>>>>>>>
84340>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
84341>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
84342>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84343>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84344>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84345>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84346>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84347>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84348>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84349>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84350>>>>>>>>            Increment i
84351>>>>>>>>
84351>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
84352>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
84353>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84354>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84355>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84356>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84357>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84358>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
84359>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
84360>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
84361>>>>>>>>            Increment i
84362>>>>>>>>
84362>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
84363>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
84364>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84365>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84366>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84367>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84368>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84369>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
84370>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
84371>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84372>>>>>>>>            Increment i
84373>>>>>>>>
84373>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
84374>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
84375>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84376>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84377>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
84378>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
84379>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84380>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
84381>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
84382>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84383>>>>>>>>            Increment i
84384>>>>>>>>
84384>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
84385>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
84386>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84387>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84388>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
84389>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
84390>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
84391>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
84392>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
84393>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
84394>>>>>>>>            Increment i
84395>>>>>>>>
84395>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
84396>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
84397>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84398>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84399>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84400>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84401>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84402>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84403>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84404>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84405>>>>>>>>            Increment i
84406>>>>>>>>
84406>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
84407>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
84408>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84409>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84410>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84411>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84412>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84413>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84414>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84415>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84416>>>>>>>>            Increment i
84417>>>>>>>>
84417>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
84418>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
84419>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84420>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84421>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84422>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84423>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84424>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84425>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84426>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84427>>>>>>>>            Increment i
84428>>>>>>>>
84428>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
84429>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
84430>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84431>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84432>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
84433>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84434>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
84435>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84436>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84437>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
84438>>>>>>>>            Increment i
84439>>>>>>>>
84439>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
84440>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
84441>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84442>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84443>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84444>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84445>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84446>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84447>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84448>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84449>>>>>>>>            Increment i
84450>>>>>>>>
84450>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
84451>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
84452>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84453>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84454>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84455>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84456>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84457>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84458>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84459>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84460>>>>>>>>            Increment i
84461>>>>>>>>
84461>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
84462>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
84463>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84464>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84465>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84466>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84467>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84468>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84469>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84470>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84471>>>>>>>>            Increment i
84472>>>>>>>>
84472>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
84473>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
84474>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84475>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84476>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84477>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84478>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84479>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84480>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84481>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84482>>>>>>>>            Increment i
84483>>>>>>>>
84483>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
84484>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
84485>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84486>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84487>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84488>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84489>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84490>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84491>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84492>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84493>>>>>>>>            Increment i
84494>>>>>>>>
84494>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
84495>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
84496>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84497>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84498>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84499>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84500>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84501>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84502>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84503>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84504>>>>>>>>            Increment i
84505>>>>>>>>
84505>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
84506>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
84507>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84508>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84509>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84510>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84511>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84512>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84513>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84514>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84515>>>>>>>>            Increment i
84516>>>>>>>>
84516>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
84517>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
84518>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84519>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84520>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84521>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84522>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84523>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
84524>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
84525>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84526>>>>>>>>            Increment i
84527>>>>>>>>
84527>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
84528>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
84529>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84530>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84531>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
84532>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84533>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
84534>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84535>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84536>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
84537>>>>>>>>            Increment i
84538>>>>>>>>
84538>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
84539>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
84540>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84541>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84542>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84543>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84544>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84545>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84546>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84547>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84548>>>>>>>>            Increment i
84549>>>>>>>>
84549>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
84550>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
84551>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84552>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84553>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84554>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84555>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84556>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84557>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84558>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84559>>>>>>>>            Increment i
84560>>>>>>>>
84560>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
84561>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
84562>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84563>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84564>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
84565>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
84566>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
84567>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84568>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84569>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
84570>>>>>>>>            Increment i
84571>>>>>>>>
84571>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
84572>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
84573>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84574>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84575>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
84576>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84577>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
84578>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84579>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84580>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
84581>>>>>>>>            Increment i
84582>>>>>>>>
84582>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
84583>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
84584>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84585>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84586>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
84587>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
84588>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
84589>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84590>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84591>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
84592>>>>>>>>            Increment i
84593>>>>>>>>
84593>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
84594>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
84595>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84596>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84597>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
84598>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84599>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84600>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84601>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84602>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84603>>>>>>>>            Increment i
84604>>>>>>>>
84604>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
84605>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
84606>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84607>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84608>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84609>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84610>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84611>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84612>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84613>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84614>>>>>>>>            Increment i
84615>>>>>>>>
84615>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
84616>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
84617>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84618>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84619>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84620>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84621>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84622>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84623>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84624>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84625>>>>>>>>            Increment i
84626>>>>>>>>
84626>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
84627>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
84628>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84629>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84630>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84631>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84632>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84633>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84634>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84635>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84636>>>>>>>>            Increment i
84637>>>>>>>>
84637>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
84638>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
84639>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84640>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84641>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
84642>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84643>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
84644>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84645>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84646>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
84647>>>>>>>>            Increment i
84648>>>>>>>>
84648>>>>>>>>
84648>>>>>>>
84648>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
84648>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
84648>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
84648>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
84648>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
84648>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
84648>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
84648>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
84648>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
84648>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
84648>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
84648>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
84648>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
84648>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
84648>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
84648>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
84648>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
84648>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
84648>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
84648>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
84648>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
84648>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
84648>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
84648>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
84648>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
84648>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
84648>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
84648>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
84648>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
84648>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>//
84648>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
84648>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
84648>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
84648>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
84648>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
84648>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
84648>>>>>>>//            Increment i
84648>>>>>>>
84648>>>>>>>        End
84648>>>>>>>>
84648>>>>>>>
84648>>>>>>>        // Mertech SQLFlex driver
84648>>>>>>>        If (sDriverID = SQLFLEX) Begin
84650>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
84650>>>>>>>>// Generated By The Database Update Framework
84650>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
84650>>>>>>>>// Driver COLUMN DATA TYPES
84650>>>>>>>>//
84650>>>>>>>>// Created: 2018-03-14 23:47:46.885
84650>>>>>>>>
84650>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
84651>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
84652>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84653>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84654>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84655>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84656>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84657>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84658>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84659>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84660>>>>>>>>            Increment i
84661>>>>>>>>
84661>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
84662>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
84663>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84664>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84665>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84666>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84667>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84668>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84669>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84670>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84671>>>>>>>>            Increment i
84672>>>>>>>>
84672>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
84673>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
84674>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84675>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84676>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
84677>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84678>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84679>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84680>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84681>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84682>>>>>>>>            Increment i
84683>>>>>>>>
84683>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
84684>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
84685>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84686>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84687>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84688>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84689>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84690>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84691>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84692>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84693>>>>>>>>            Increment i
84694>>>>>>>>
84694>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
84695>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
84696>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84697>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84698>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
84699>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84700>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84701>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84702>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84703>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84704>>>>>>>>            Increment i
84705>>>>>>>>
84705>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
84706>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
84707>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84708>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84709>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
84710>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
84711>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84712>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84713>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84714>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84715>>>>>>>>            Increment i
84716>>>>>>>>
84716>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
84717>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
84718>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84719>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84720>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
84721>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
84722>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84723>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84724>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84725>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84726>>>>>>>>            Increment i
84727>>>>>>>>
84727>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
84728>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
84729>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84730>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84731>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
84732>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
84733>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84734>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84735>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84736>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84737>>>>>>>>            Increment i
84738>>>>>>>>
84738>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
84739>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
84740>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84741>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84742>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84743>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84744>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84745>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84746>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84747>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84748>>>>>>>>            Increment i
84749>>>>>>>>
84749>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
84750>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
84751>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84752>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84753>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84754>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84755>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84756>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84757>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84758>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84759>>>>>>>>            Increment i
84760>>>>>>>>
84760>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
84761>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
84762>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84763>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84764>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84765>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84766>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84767>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84768>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84769>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84770>>>>>>>>            Increment i
84771>>>>>>>>
84771>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
84772>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
84773>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84774>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84775>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84776>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84777>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84778>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84779>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84780>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84781>>>>>>>>            Increment i
84782>>>>>>>>
84782>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
84783>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
84784>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84785>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84786>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84787>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84788>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84789>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84790>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84791>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84792>>>>>>>>            Increment i
84793>>>>>>>>
84793>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
84794>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
84795>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84796>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84797>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84798>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84799>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
84800>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84801>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84802>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
84803>>>>>>>>            Increment i
84804>>>>>>>>
84804>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
84805>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
84806>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84807>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84808>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
84809>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84810>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
84811>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84812>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84813>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
84814>>>>>>>>            Increment i
84815>>>>>>>>
84815>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
84816>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
84817>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84818>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84819>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
84820>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84821>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84822>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84823>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84824>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84825>>>>>>>>            Increment i
84826>>>>>>>>
84826>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
84827>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
84828>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84829>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84830>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84831>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84832>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
84833>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84834>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84835>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
84836>>>>>>>>            Increment i
84837>>>>>>>>
84837>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
84838>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
84839>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84840>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84841>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84842>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84843>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84844>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84845>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84846>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84847>>>>>>>>            Increment i
84848>>>>>>>>
84848>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
84849>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
84850>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84851>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84852>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
84853>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84854>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
84855>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84856>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84857>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
84858>>>>>>>>            Increment i
84859>>>>>>>>
84859>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
84860>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
84861>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84862>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84863>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84864>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84865>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
84866>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84867>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84868>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
84869>>>>>>>>            Increment i
84870>>>>>>>>
84870>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
84871>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
84872>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84873>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84874>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
84875>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84876>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
84877>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84878>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84879>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
84880>>>>>>>>            Increment i
84881>>>>>>>>
84881>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
84882>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
84883>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84884>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84885>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
84886>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
84887>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
84888>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84889>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84890>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
84891>>>>>>>>            Increment i
84892>>>>>>>>
84892>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
84893>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
84894>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84895>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84896>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
84897>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84898>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
84899>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84900>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84901>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
84902>>>>>>>>            Increment i
84903>>>>>>>>
84903>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
84904>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
84905>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84906>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84907>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
84908>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84909>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84910>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84911>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84912>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84913>>>>>>>>            Increment i
84914>>>>>>>>
84914>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
84915>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
84916>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84917>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84918>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84919>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84920>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
84921>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
84922>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
84923>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
84924>>>>>>>>            Increment i
84925>>>>>>>>
84925>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
84926>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
84927>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84928>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84929>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
84930>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
84931>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
84932>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84933>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84934>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
84935>>>>>>>>            Increment i
84936>>>>>>>>
84936>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
84937>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
84938>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84939>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84940>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
84941>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84942>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84943>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
84944>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
84945>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84946>>>>>>>>            Increment i
84947>>>>>>>>
84947>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
84948>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
84949>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84950>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84951>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
84952>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84953>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
84954>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
84955>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
84956>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
84957>>>>>>>>            Increment i
84958>>>>>>>>
84958>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
84959>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
84960>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
84961>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84962>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
84963>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
84964>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
84965>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84966>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84967>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
84968>>>>>>>>            Increment i
84969>>>>>>>>
84969>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
84970>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
84971>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84972>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84973>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
84974>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84975>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84976>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
84977>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
84978>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
84979>>>>>>>>            Increment i
84980>>>>>>>>
84980>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
84981>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
84982>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84983>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84984>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
84985>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84986>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
84987>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84988>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
84989>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
84990>>>>>>>>            Increment i
84991>>>>>>>>
84991>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
84992>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
84993>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
84994>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
84995>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
84996>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
84997>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
84998>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
84999>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85000>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
85001>>>>>>>>            Increment i
85002>>>>>>>>
85002>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
85003>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
85004>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85005>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85006>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85007>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85008>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85009>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85010>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85011>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85012>>>>>>>>            Increment i
85013>>>>>>>>
85013>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
85014>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
85015>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85016>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85017>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85018>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85019>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85020>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85021>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85022>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85023>>>>>>>>            Increment i
85024>>>>>>>>
85024>>>>>>>>
85024>>>>>>>
85024>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
85024>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
85024>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
85024>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
85024>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
85024>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
85024>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
85024>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
85024>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
85024>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
85024>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
85024>>>>>>>//            Increment i
85024>>>>>>>//
85024>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
85024>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
85024>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
85024>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
85024>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
85024>>>>>>>        End
85024>>>>>>>>
85024>>>>>>>
85024>>>>>>>        Function_Return aColumnType
85025>>>>>>>    End_Function
85026>>>>>>>
85026>>>>>>>    // MySQL Data Types
85026>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
85028>>>>>>>        tColumnType[] aColumnType
85028>>>>>>>        tColumnType[] aColumnType
85029>>>>>>>        Integer i
85029>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
85029>>>>>>>>// Generated By The Database Update Framework
85029>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
85029>>>>>>>>// Driver COLUMN DATA TYPES
85029>>>>>>>>//
85029>>>>>>>>// Created: 2018-03-14 23:46:49.593
85029>>>>>>>>
85029>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
85030>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
85031>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85032>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85033>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85034>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85035>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85036>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85037>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85038>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85039>>>>>>>>            Increment i
85040>>>>>>>>
85040>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
85041>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
85042>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85043>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85044>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
85045>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85046>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
85047>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85048>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85049>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
85050>>>>>>>>            Increment i
85051>>>>>>>>
85051>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
85052>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
85053>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85054>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85055>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85056>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85057>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85058>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85059>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85060>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85061>>>>>>>>            Increment i
85062>>>>>>>>
85062>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
85063>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
85064>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85065>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85066>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85067>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85068>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
85069>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85070>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85071>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
85072>>>>>>>>            Increment i
85073>>>>>>>>
85073>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
85074>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
85075>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85076>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85077>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85078>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85079>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85080>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
85081>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
85082>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85083>>>>>>>>            Increment i
85084>>>>>>>>
85084>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
85085>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
85086>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85087>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85088>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85089>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
85090>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
85091>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85092>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85093>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
85094>>>>>>>>            Increment i
85095>>>>>>>>
85095>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
85096>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
85097>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85098>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85099>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85100>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85101>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85102>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85103>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85104>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85105>>>>>>>>            Increment i
85106>>>>>>>>
85106>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
85107>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
85108>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85109>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85110>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85111>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85112>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85113>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85114>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85115>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85116>>>>>>>>            Increment i
85117>>>>>>>>
85117>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
85118>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
85119>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85120>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85121>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85122>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85123>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85124>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85125>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85126>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85127>>>>>>>>            Increment i
85128>>>>>>>>
85128>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
85129>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
85130>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85131>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85132>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
85133>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85134>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
85135>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85136>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85137>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
85138>>>>>>>>            Increment i
85139>>>>>>>>
85139>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
85140>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
85141>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85142>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85143>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
85144>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85145>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85146>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85147>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85148>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85149>>>>>>>>            Increment i
85150>>>>>>>>
85150>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
85151>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
85152>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85153>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85154>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
85155>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85156>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
85157>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85158>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85159>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
85160>>>>>>>>            Increment i
85161>>>>>>>>
85161>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
85162>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
85163>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85164>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85165>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85166>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85167>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85168>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85169>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85170>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85171>>>>>>>>            Increment i
85172>>>>>>>>
85172>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
85173>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
85174>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85175>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85176>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85177>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85178>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85179>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
85180>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
85181>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85182>>>>>>>>            Increment i
85183>>>>>>>>
85183>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
85184>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
85185>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85186>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85187>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85188>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85189>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85190>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85191>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85192>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85193>>>>>>>>            Increment i
85194>>>>>>>>
85194>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
85195>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
85196>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85197>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85198>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
85199>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85200>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
85201>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85202>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85203>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
85204>>>>>>>>            Increment i
85205>>>>>>>>
85205>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
85206>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
85207>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85208>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85209>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85210>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85211>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85212>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
85213>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
85214>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85215>>>>>>>>            Increment i
85216>>>>>>>>
85216>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
85217>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
85218>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85219>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85220>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
85221>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85222>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
85223>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85224>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85225>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
85226>>>>>>>>            Increment i
85227>>>>>>>>
85227>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
85228>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
85229>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85230>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85231>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
85232>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85233>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
85234>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85235>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85236>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85237>>>>>>>>            Increment i
85238>>>>>>>>
85238>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
85239>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
85240>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85241>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85242>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85243>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85244>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85245>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
85246>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
85247>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85248>>>>>>>>            Increment i
85249>>>>>>>>
85249>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
85250>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
85251>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85252>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85253>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
85254>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85255>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85256>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85257>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85258>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85259>>>>>>>>            Increment i
85260>>>>>>>>
85260>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
85261>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
85262>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85263>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85264>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85265>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
85266>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
85267>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85268>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85269>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
85270>>>>>>>>            Increment i
85271>>>>>>>>
85271>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
85272>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
85273>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85274>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85275>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
85276>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85277>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
85278>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85279>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85280>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
85281>>>>>>>>            Increment i
85282>>>>>>>>
85282>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
85283>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
85284>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85285>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85286>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
85287>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85288>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
85289>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85290>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85291>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
85292>>>>>>>>            Increment i
85293>>>>>>>>
85293>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
85294>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
85295>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85296>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85297>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
85298>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85299>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
85300>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85301>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85302>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
85303>>>>>>>>            Increment i
85304>>>>>>>>
85304>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
85305>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
85306>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85307>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85308>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
85309>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85310>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85311>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85312>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85313>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85314>>>>>>>>            Increment i
85315>>>>>>>>
85315>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
85316>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
85317>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85318>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85319>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
85320>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85321>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85322>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85323>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85324>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85325>>>>>>>>            Increment i
85326>>>>>>>>
85326>>>>>>>>
85326>>>>>>>
85326>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
85326>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
85326>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
85326>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
85326>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
85326>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
85326>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
85326>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
85326>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
85326>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
85326>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
85326>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
85326>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
85326>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
85326>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
85326>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
85326>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
85326>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
85326>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
85326>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85326>>>>>>>//        Increment i
85326>>>>>>>//
85326>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
85326>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
85326>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85326>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
85326>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
85326>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85326>>>>>>>//        Increment i
85326>>>>>>>
85326>>>>>>>        Function_Return aColumnType
85327>>>>>>>    End_Function
85328>>>>>>>
85328>>>>>>>    // Oracle Data Types
85328>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
85330>>>>>>>        tColumnType[] aColumnType
85330>>>>>>>        tColumnType[] aColumnType
85331>>>>>>>        Integer i
85331>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
85331>>>>>>>>// Generated By The Database Update Framework
85331>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
85331>>>>>>>>// Driver COLUMN DATA TYPES
85331>>>>>>>>//
85331>>>>>>>>// Created: 2018-03-14 23:47:34.82
85331>>>>>>>>
85331>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
85332>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
85333>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85334>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85335>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85336>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85337>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85338>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85339>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85340>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85341>>>>>>>>            Increment i
85342>>>>>>>>
85342>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
85343>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
85344>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85345>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85346>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85347>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85348>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
85349>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85350>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85351>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
85352>>>>>>>>            Increment i
85353>>>>>>>>
85353>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
85354>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
85355>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85356>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85357>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85358>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85359>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85360>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
85361>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
85362>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85363>>>>>>>>            Increment i
85364>>>>>>>>
85364>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
85365>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
85366>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85367>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85368>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85369>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
85370>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
85371>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
85372>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
85373>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85374>>>>>>>>            Increment i
85375>>>>>>>>
85375>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
85376>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
85377>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85378>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85379>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85380>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85381>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85382>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85383>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85384>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85385>>>>>>>>            Increment i
85386>>>>>>>>
85386>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
85387>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
85388>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85389>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85390>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85391>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85392>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85393>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85394>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85395>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85396>>>>>>>>            Increment i
85397>>>>>>>>
85397>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
85398>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
85399>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85400>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85401>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85402>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85403>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85404>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85405>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85406>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85407>>>>>>>>            Increment i
85408>>>>>>>>
85408>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
85409>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
85410>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85411>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85412>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85413>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85414>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85415>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85416>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85417>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85418>>>>>>>>            Increment i
85419>>>>>>>>
85419>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
85420>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
85421>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85422>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85423>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85424>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85425>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85426>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85427>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85428>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85429>>>>>>>>            Increment i
85430>>>>>>>>
85430>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
85431>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
85432>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85433>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85434>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85435>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85436>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85437>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85438>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85439>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85440>>>>>>>>            Increment i
85441>>>>>>>>
85441>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
85442>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
85443>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85444>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85445>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85446>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85447>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
85448>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85449>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85450>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
85451>>>>>>>>            Increment i
85452>>>>>>>>
85452>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
85453>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
85454>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85455>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85456>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
85457>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85458>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85459>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
85460>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
85461>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85462>>>>>>>>            Increment i
85463>>>>>>>>
85463>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
85464>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
85465>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85466>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85467>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85468>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85469>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85470>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85471>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85472>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85473>>>>>>>>            Increment i
85474>>>>>>>>
85474>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
85475>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
85476>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85477>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85478>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85479>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85480>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
85481>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85482>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85483>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
85484>>>>>>>>            Increment i
85485>>>>>>>>
85485>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
85486>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
85487>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85488>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85489>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85490>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85491>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
85492>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85493>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85494>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
85495>>>>>>>>            Increment i
85496>>>>>>>>
85496>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
85497>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
85498>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85499>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85500>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85501>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85502>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85503>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85504>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85505>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85506>>>>>>>>            Increment i
85507>>>>>>>>
85507>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
85508>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
85509>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85510>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85511>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85512>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85513>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85514>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85515>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85516>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85517>>>>>>>>            Increment i
85518>>>>>>>>
85518>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
85519>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
85520>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85521>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85522>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85523>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85524>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85525>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85526>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85527>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85528>>>>>>>>            Increment i
85529>>>>>>>>
85529>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
85530>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
85531>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85532>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85533>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85534>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85535>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
85536>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85537>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85538>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
85539>>>>>>>>            Increment i
85540>>>>>>>>
85540>>>>>>>>
85540>>>>>>>
85540>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
85540>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
85540>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
85540>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
85540>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
85540>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
85540>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
85540>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
85540>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
85540>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
85540>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
85540>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
85540>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
85540>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
85540>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
85540>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
85540>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
85540>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
85540>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
85540>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
85540>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
85540>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
85540>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
85540>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
85540>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
85540>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
85540>>>>>>>//        Increment i
85540>>>>>>>//
85540>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
85540>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
85540>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85540>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85540>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85540>>>>>>>
85540>>>>>>>        Function_Return aColumnType
85541>>>>>>>    End_Function
85542>>>>>>>
85542>>>>>>>    // PostgreSQL Data Types
85542>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
85544>>>>>>>        tColumnType[] aColumnType
85544>>>>>>>        tColumnType[] aColumnType
85545>>>>>>>        Integer i
85545>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
85545>>>>>>>>// Generated By The Database Update Framework
85545>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
85545>>>>>>>>// Driver COLUMN DATA TYPES
85545>>>>>>>>//
85545>>>>>>>>// Created: 2018-03-14 23:47:02.984
85545>>>>>>>>
85545>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
85546>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
85547>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85548>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85549>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85550>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85551>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85552>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85553>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85554>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85555>>>>>>>>            Increment i
85556>>>>>>>>
85556>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
85557>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
85558>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85559>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85560>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85561>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85562>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85563>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85564>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85565>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85566>>>>>>>>            Increment i
85567>>>>>>>>
85567>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
85568>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
85569>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85570>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85571>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85572>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85573>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85574>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85575>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85576>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85577>>>>>>>>            Increment i
85578>>>>>>>>
85578>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
85579>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
85580>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85581>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85582>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85583>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85584>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85585>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85586>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85587>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85588>>>>>>>>            Increment i
85589>>>>>>>>
85589>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
85590>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
85591>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85592>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85593>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85594>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85595>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85596>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85597>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85598>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85599>>>>>>>>            Increment i
85600>>>>>>>>
85600>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
85601>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
85602>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85603>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85604>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85605>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85606>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85607>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85608>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85609>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85610>>>>>>>>            Increment i
85611>>>>>>>>
85611>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
85612>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
85613>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85614>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85615>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85616>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85617>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85618>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
85619>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
85620>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85621>>>>>>>>            Increment i
85622>>>>>>>>
85622>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
85623>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
85624>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85625>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85626>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85627>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85628>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85629>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85630>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85631>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85632>>>>>>>>            Increment i
85633>>>>>>>>
85633>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
85634>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
85635>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85636>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85637>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
85638>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85639>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
85640>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85641>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85642>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
85643>>>>>>>>            Increment i
85644>>>>>>>>
85644>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
85645>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
85646>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85647>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85648>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
85649>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85650>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
85651>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85652>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85653>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
85654>>>>>>>>            Increment i
85655>>>>>>>>
85655>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
85656>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
85657>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85658>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85659>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
85660>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85661>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
85662>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85663>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85664>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
85665>>>>>>>>            Increment i
85666>>>>>>>>
85666>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
85667>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
85668>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85669>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85670>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
85671>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85672>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85673>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
85674>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
85675>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85676>>>>>>>>            Increment i
85677>>>>>>>>
85677>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
85678>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
85679>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85680>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85681>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85682>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85683>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
85684>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85685>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85686>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85687>>>>>>>>            Increment i
85688>>>>>>>>
85688>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
85689>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
85690>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85691>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85692>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
85693>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85694>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85695>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85696>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85697>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85698>>>>>>>>            Increment i
85699>>>>>>>>
85699>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
85700>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
85701>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85702>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85703>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
85704>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85705>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
85706>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
85707>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
85708>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
85709>>>>>>>>            Increment i
85710>>>>>>>>
85710>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
85711>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
85712>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85713>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85714>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85715>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85716>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85717>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85718>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85719>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85720>>>>>>>>            Increment i
85721>>>>>>>>
85721>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
85722>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
85723>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85724>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85725>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
85726>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
85727>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
85728>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85729>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85730>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
85731>>>>>>>>            Increment i
85732>>>>>>>>
85732>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
85733>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
85734>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85735>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85736>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85737>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85738>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85739>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
85740>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
85741>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85742>>>>>>>>            Increment i
85743>>>>>>>>
85743>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
85744>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
85745>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85746>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85747>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
85748>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85749>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85750>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85751>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85752>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85753>>>>>>>>            Increment i
85754>>>>>>>>
85754>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
85755>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
85756>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
85757>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85758>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
85759>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
85760>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
85761>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85762>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85763>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
85764>>>>>>>>            Increment i
85765>>>>>>>>
85765>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
85766>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
85767>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85768>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85769>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85770>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85771>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85772>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85773>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85774>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85775>>>>>>>>            Increment i
85776>>>>>>>>
85776>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
85777>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
85778>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
85779>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
85780>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
85781>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
85782>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
85783>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
85784>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
85785>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
85786>>>>>>>>            Increment i
85787>>>>>>>>
85787>>>>>>>>
85787>>>>>>>
85787>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
85787>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
85787>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
85787>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
85787>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
85787>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
85787>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
85787>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
85787>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
85787>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
85787>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
85787>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
85787>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
85787>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
85787>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
85787>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
85787>>>>>>>//        Increment i
85787>>>>>>>//
85787>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
85787>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
85787>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
85787>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
85787>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
85787>>>>>>>//        Increment i
85787>>>>>>>
85787>>>>>>>        Function_Return aColumnType
85788>>>>>>>    End_Function
85789>>>>>>>
85789>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
85789>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
85791>>>>>>>        Integer iValue iSize iCount iStart
85791>>>>>>>        tColumnType[] ColumnTypeArray
85791>>>>>>>        tColumnType[] ColumnTypeArray
85792>>>>>>>        tColumnType RetvalType
85792>>>>>>>        tColumnType RetvalType
85792>>>>>>>        String sValue
85792>>>>>>>        Boolean bFrameworkDataFlexType
85792>>>>>>>
85792>>>>>>>        Move "Undefined" to RetvalType.sSQLType
85793>>>>>>>        Move -1999       to RetvalType.iSQLType
85794>>>>>>>
85794>>>>>>>        Move 0 to iStart
85795>>>>>>>        Move (Uppercase(sType)) to sType
85796>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
85797>>>>>>>        If (bFrameworkDataFlexType = True) Begin
85799>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
85800>>>>>>>            Function_Return RetvalType
85801>>>>>>>        End
85801>>>>>>>>
85801>>>>>>>
85801>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
85802>>>>>>>
85802>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
85803>>>>>>>        Decrement iSize
85804>>>>>>>
85804>>>>>>>        for iCount from iStart to iSize
85810>>>>>>>>
85810>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
85811>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
85812>>>>>>>            If (bIntegerInputType = True) Begin
85814>>>>>>>                If (iValue = iType) Begin
85816>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
85817>>>>>>>                    Move iType                                  to RetvalType.iSQLType
85818>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
85819>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
85820>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
85821>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
85822>>>>>>>                    Move iSize to iCount // We're done!
85823>>>>>>>                End
85823>>>>>>>>
85823>>>>>>>            End
85823>>>>>>>>
85823>>>>>>>            Else Begin
85824>>>>>>>                Move (Uppercase(sValue)) to sValue
85825>>>>>>>                If (sValue = sType) Begin
85827>>>>>>>                    Move sType                                  to RetvalType.sSQLType
85828>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
85829>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
85830>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
85831>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
85832>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
85833>>>>>>>                    Move iSize to iCount // We're done!
85834>>>>>>>                End
85834>>>>>>>>
85834>>>>>>>            End
85834>>>>>>>>
85834>>>>>>>        Loop
85835>>>>>>>>
85835>>>>>>>
85835>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
85835>>>>>>>        // In which case we search for a match in DataFlex standard types:
85835>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
85837>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
85838>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
85839>>>>>>>            Decrement iSize
85840>>>>>>>
85840>>>>>>>            for iCount from iStart to iSize
85846>>>>>>>>
85846>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
85847>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
85848>>>>>>>                If (iValue = iType) Begin
85850>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
85851>>>>>>>                    Move iType                                  to RetvalType.iSQLType
85852>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
85853>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
85854>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
85855>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
85856>>>>>>>                    Move iSize to iCount // We're done!
85857>>>>>>>                End
85857>>>>>>>>
85857>>>>>>>            Loop
85858>>>>>>>>
85858>>>>>>>        End
85858>>>>>>>>
85858>>>>>>>
85858>>>>>>>        Function_Return RetvalType
85859>>>>>>>    End_Function
85860>>>>>>>
85860>>>>>>>    Function _AllTablesToConvert Returns Integer[]
85862>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
85864>>>>>>>        Handle hTable
85864>>>>>>>        Integer iIndex
85864>>>>>>>        String sTableName
85864>>>>>>>        Boolean bFlexErrs
85864>>>>>>>
85864>>>>>>>        // a) Get the exception table array the developer has specified
85864>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
85865>>>>>>>
85865>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
85865>>>>>>>        Repeat
85865>>>>>>>>
85865>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85868>>>>>>>            If (hTable <> 0) Begin
85870>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
85873>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
85874>>>>>>>                If (bFlexErrs = False) Begin
85876>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
85878>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
85879>>>>>>>                        If (iIndex = -1) Begin
85881>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
85882>>>>>>>                        End
85882>>>>>>>>
85882>>>>>>>                    End
85882>>>>>>>>
85882>>>>>>>                End
85882>>>>>>>>
85882>>>>>>>            End
85882>>>>>>>>
85882>>>>>>>        Until (hTable = 0)
85884>>>>>>>
85884>>>>>>>        Move 0 to hTable
85885>>>>>>>
85885>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
85885>>>>>>>        Repeat
85885>>>>>>>>
85885>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85888>>>>>>>            If (hTable > 0) Begin
85890>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
85893>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
85894>>>>>>>                If (bFlexErrs = False) Begin
85896>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
85897>>>>>>>                    If (iIndex = -1) Begin
85899>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
85900>>>>>>>                    End
85900>>>>>>>>
85900>>>>>>>                End
85900>>>>>>>>
85900>>>>>>>            End
85900>>>>>>>>
85900>>>>>>>        Until (hTable = 0)
85902>>>>>>>
85902>>>>>>>        Function_Return iTablesArray
85903>>>>>>>    End_Function
85904>>>>>>>
85904>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
85906>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
85908>>>>>>>        Handle hTable
85908>>>>>>>        Integer iIndex
85908>>>>>>>        String sTableName
85908>>>>>>>        Boolean bFlexErrs
85908>>>>>>>
85908>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
85909>>>>>>>        Move 0 to hTable
85910>>>>>>>
85910>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
85910>>>>>>>        Repeat
85910>>>>>>>>
85910>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85913>>>>>>>            If (hTable > 0) Begin
85915>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
85918>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
85919>>>>>>>                If (bFlexErrs = False) Begin
85921>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
85922>>>>>>>                    If (iIndex = -1) Begin
85924>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
85925>>>>>>>                    End
85925>>>>>>>>
85925>>>>>>>                End
85925>>>>>>>>
85925>>>>>>>            End
85925>>>>>>>>
85925>>>>>>>        Until (hTable = 0)
85927>>>>>>>
85927>>>>>>>        Function_Return iTablesArray
85928>>>>>>>    End_Function
85929>>>>>>>
85929>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
85931>>>>>>>        tAPIColumn NewAPIColumn
85931>>>>>>>        tAPIColumn NewAPIColumn
85931>>>>>>>
85931>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
85932>>>>>>>        Move iType      to NewAPIColumn.iType
85933>>>>>>>        Move iLength    to NewAPIColumn.iLength
85934>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
85935>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
85936>>>>>>>
85936>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
85937>>>>>>>
85937>>>>>>>        Function_Return aCurrent
85938>>>>>>>    End_Function
85939>>>>>>>
85939>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
85941>>>>>>>        String sRetval sFieldName
85941>>>>>>>        Integer iCount iSize
85941>>>>>>>
85941>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
85942>>>>>>>        Decrement iSize
85943>>>>>>>        for iCount from 0 to iSize
85949>>>>>>>>
85949>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
85950>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
85951>>>>>>>        Loop
85952>>>>>>>>
85952>>>>>>>        Move (Trim(sRetval)) to sRetval
85953>>>>>>>
85953>>>>>>>        Function_Return sRetval
85954>>>>>>>    End_Function
85955>>>>>>>
85955>>>>>>>    // *** Miscellaneous other functions ***
85955>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
85955>>>>>>>    //
85955>>>>>>>
85955>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
85955>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
85957>>>>>>>        Integer iPerc
85957>>>>>>>        Number nReady nTotal
85957>>>>>>>
85957>>>>>>>        Send DoAdvance of ghoProgressBar
85958>>>>>>>
85958>>>>>>>        If (sCallback_Text contains "Copy records") Begin
85960>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
85961>>>>>>>        End
85961>>>>>>>>
85961>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
85963>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
85964>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
85965>>>>>>>        End
85965>>>>>>>>
85965>>>>>>>        If (sCallback_Text contains "Creating index") Begin
85967>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
85968>>>>>>>        End
85968>>>>>>>>
85968>>>>>>>
85968>>>>>>>        Case Begin
85968>>>>>>>            Case (iCallback_Type = DF_Message_Text)
85970>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
85971>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
85972>>>>>>>                Case Break
85973>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
85976>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
85977>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
85978>>>>>>>                Case Break
85979>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
85982>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
85983>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
85984>>>>>>>                Case Break
85985>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
85988>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
85989>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
85990>>>>>>>                Case Break
85991>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
85994>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
85995>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
85996>>>>>>>                Case Break
85997>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
86000>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
86001>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
86002>>>>>>>                Case Break
86003>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
86006>>>>>>>                Send None
86007>>>>>>>                Case Break
86008>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
86011>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
86012>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
86013>>>>>>>                Case Break
86014>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
86017>>>>>>>                //*** Interpret numbers
86017>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
86018>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
86019>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
86020>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
86021>>>>>>>                Case Break
86022>>>>>>>            Case Else
86022>>>>>>>                Set Message_Text to ""
86023>>>>>>>                Set Action_Text  to ""
86024>>>>>>>        Case End
86024>>>>>>>
86024>>>>>>>        Send ProcessEvents of ghoStatusPanel
86025>>>>>>>        Function_Return False
86026>>>>>>>    End_Function
86027>>>>>>>
86027>>>>>>>    Procedure IncreaseSortBufferSize
86029>>>>>>>        String sNull
86029>>>>>>>        Integer iSortBufferSize
86029>>>>>>>        Boolean bBufferSet
86029>>>>>>>
86029>>>>>>>        Move "" to sNull
86030>>>>>>>        Move (1024 * 128) to iSortBufferSize
86031>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
86036>>>>>>>
86036>>>>>>>    End_Procedure
86037>>>>>>>
86037>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
86039>>>>>>>        Integer iLastIndex iIndex iNumSegments
86039>>>>>>>        Boolean bOK
86039>>>>>>>        String sDriverID
86039>>>>>>>
86039>>>>>>>        If (hTable > 0) Begin
86041>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
86042>>>>>>>            Close hTable
86043>>>>>>>            Get OpenTableExclusive hTable to bOK
86044>>>>>>>            If (bOK = False) Begin
86046>>>>>>>                Procedure_Return
86047>>>>>>>            End
86047>>>>>>>>
86047>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
86050>>>>>>>            Structure_Start hTable sDriverID
86051>>>>>>>                for iIndex from 1 to iLastIndex
86057>>>>>>>>
86057>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86060>>>>>>>                    If (iNumSegments > 0) Begin
86062>>>>>>>                        If (bSetToBatch = True) Begin
86064>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
86067>>>>>>>                        End
86067>>>>>>>>
86067>>>>>>>                        Else Begin
86068>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
86071>>>>>>>                        End
86071>>>>>>>>
86071>>>>>>>                    End
86071>>>>>>>>
86071>>>>>>>                Loop
86072>>>>>>>>
86072>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86074>>>>>>>        End
86074>>>>>>>>
86074>>>>>>>    End_Procedure
86075>>>>>>>
86075>>>>>>>    Function NextFreeFilelistSlot Returns Handle
86077>>>>>>>        Handle hTable
86077>>>>>>>
86077>>>>>>>        Move 0 to hTable
86078>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
86081>>>>>>>
86081>>>>>>>        Function_Return hTable
86082>>>>>>>    End_Function
86083>>>>>>>
86083>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
86083>>>>>>>    Procedure DebugPrint String sStmt String sFileName
86085>>>>>>>        Integer iCh
86085>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
86086>>>>>>>            Write channel iCh sStmt
86088>>>>>>>        Send Seq_Close_Channel iCh
86089>>>>>>>    End_Procedure
86090>>>>>>>
86090>>>>>>>    // Returns the integer number for the passed Driver ID that is
86090>>>>>>>    // needed by some database API calls.
86090>>>>>>>    Function DriverIndex String sDriverID Returns Integer
86092>>>>>>>        String  sCurrentDriver
86092>>>>>>>        Integer iNumberOfDrivers iDriver iCount
86092>>>>>>>
86092>>>>>>>        Move 0 to iDriver
86093>>>>>>>
86093>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
86096>>>>>>>        for iCount from 1 to iNumberOfDrivers
86102>>>>>>>>
86102>>>>>>>
86102>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
86105>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
86107>>>>>>>                Move iCount to iDriver
86108>>>>>>>            End
86108>>>>>>>>
86108>>>>>>>        Loop
86109>>>>>>>>
86109>>>>>>>
86109>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
86109>>>>>>>        If (iDriver = 0) Begin
86111>>>>>>>            Move False to Err
86112>>>>>>>            Load_Driver sDriverID
86113>>>>>>>            If (Err = False) Begin
86115>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
86118>>>>>>>            End
86118>>>>>>>>
86118>>>>>>>        End
86118>>>>>>>>
86118>>>>>>>
86118>>>>>>>        Function_Return iDriver
86119>>>>>>>    End_Function
86120>>>>>>>
86120>>>>>>>    
86120>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
86122>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
86122>>>>>>>        Integer iNumberOfDrivers iDriver iClient
86122>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
86122>>>>>>>        Boolean bOK
86122>>>>>>>        
86122>>>>>>>        Move "" to sRetval
86123>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
86124>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
86125>>>>>>>        Load_Driver MSSQLDRV_ID
86126>>>>>>>
86126>>>>>>>        // Loop through all loaded drivers.
86126>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
86129>>>>>>>        For iDriver from 1 to iNumberOfDrivers
86135>>>>>>>>
86135>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
86138>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
86140>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
86141>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
86144>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
86145>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
86146>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
86147>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
86148>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
86150>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
86151>>>>>>>                End                                
86151>>>>>>>>
86151>>>>>>>                Else Begin
86152>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
86153>>>>>>>                End
86153>>>>>>>>
86153>>>>>>>            End
86153>>>>>>>>
86153>>>>>>>        Loop
86154>>>>>>>>
86154>>>>>>>        Send Destroy of hoCLIHandler  
86155>>>>>>>        Send Destroy of hoMSSQLHandler  
86156>>>>>>>        If (bShowErrorDialog = True) Begin
86158>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
86159>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
86161>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
86162>>>>>>>                If (bExitProgram = True) Begin
86164>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
86165>>>>>>>                End
86165>>>>>>>>
86165>>>>>>>                Send Stop_Box sRetval  
86166>>>>>>>                If (bExitProgram = True) Begin
86168>>>>>>>                    Send Exit_Application
86169>>>>>>>                End
86169>>>>>>>>
86169>>>>>>>            End
86169>>>>>>>>
86169>>>>>>>        End
86169>>>>>>>>
86169>>>>>>>        
86169>>>>>>>        Function_Return sRetval
86170>>>>>>>    End_Function  
86171>>>>>>>    
86171>>>>>>>    // Returns True if first "." separated string is greater than the second.
86171>>>>>>>    // It checks from left to right, one part of the string at a time.
86171>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
86171>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
86173>>>>>>>        String[] asVersion asSQLVersion          
86175>>>>>>>        Integer iSize iCount iVersion iSQLVersion
86175>>>>>>>        
86175>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
86176>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
86177>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
86178>>>>>>>        // Make sure the two arrays are of the same size:
86178>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
86180>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
86181>>>>>>>        End
86181>>>>>>>>
86181>>>>>>>        Decrement iSize
86182>>>>>>>        for iCount from 0 to iSize
86188>>>>>>>>
86188>>>>>>>            Move asVersion[iCount]    to iVersion
86189>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
86190>>>>>>>            CompilerWarnings Off
86190>>>>>>>            If (iVersion > iSQLVersion) Break
86193>>>>>>>            CompilerWarnings On
86193>>>>>>>        Loop
86194>>>>>>>>
86194>>>>>>>        
86194>>>>>>>        Function_Return (iVersion > iSQLVersion)
86195>>>>>>>    End_Function
86196>>>>>>>
86196>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
86196>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
86196>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
86196>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
86198>>>>>>>        Integer iMode
86198>>>>>>>        Boolean bOpened
86198>>>>>>>        String sTableName
86198>>>>>>>
86198>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86199>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
86199>>>>>>>        // so we generate an error here:
86199>>>>>>>        If (IsDebuggerPresent()) Begin
86201>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
86202>>>>>>>>
86202>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
86203>>>>>>>            Function_Return False
86204>>>>>>>        End
86204>>>>>>>>
86204>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86207>>>>>>>        If (bOpened) Begin
86209>>>>>>>            If (IsDebuggerPresent()) Begin
86211>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86214>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
86216>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
86217>>>>>>>                    Function_Return True
86218>>>>>>>                End
86218>>>>>>>>
86218>>>>>>>            End
86218>>>>>>>>
86218>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
86221>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
86223>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
86224>>>>>>>                Function_Return True
86225>>>>>>>            End
86225>>>>>>>>
86225>>>>>>>            Close hTable
86226>>>>>>>        End
86226>>>>>>>>
86226>>>>>>>        Else Begin
86227>>>>>>>            Open hTable
86229>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
86232>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
86234>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86237>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
86239>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
86240>>>>>>>                    Function_Return True
86241>>>>>>>                End
86241>>>>>>>>
86241>>>>>>>            End
86241>>>>>>>>
86241>>>>>>>
86241>>>>>>>        End
86241>>>>>>>>
86241>>>>>>>
86241>>>>>>>        Close hTable
86242>>>>>>>        Open hTable Mode DF_EXCLUSIVE
86244>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86247>>>>>>>
86247>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
86248>>>>>>>        Function_Return bOpened
86249>>>>>>>    End_Function
86250>>>>>>>
86250>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
86252>>>>>>>        String sConnectionID sConnectionString sDriverID
86252>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
86252>>>>>>>        Handle hoCLI hoDriver
86252>>>>>>>        Integer iRetval
86252>>>>>>>        tSQLConnection SQLConnection
86252>>>>>>>        tSQLConnection SQLConnection
86252>>>>>>>
86252>>>>>>>        Get psDriverID to sDriverID
86253>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
86254>>>>>>>        If (bSQLDriver = False) Begin
86256>>>>>>>            Function_Return True
86257>>>>>>>        End
86257>>>>>>>>
86257>>>>>>>
86257>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86258>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
86259>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
86260>>>>>>>        Get IsMertechDriver sDriverID to bMertech
86261>>>>>>>        If (bMertech = True) Begin
86263>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
86264>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86265>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
86266>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
86267>>>>>>>            Send Destroy of hoDriver
86268>>>>>>>            Function_Return bOK
86269>>>>>>>        End
86269>>>>>>>>
86269>>>>>>>
86269>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
86270>>>>>>>
86270>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
86271>>>>>>>        If (bExists = False) Begin
86273>>>>>>>            // We always start by deleting the current connection - if any - because the
86273>>>>>>>            // login details my have changed.
86273>>>>>>>            Get phoCLIHandler to hoCLI
86274>>>>>>>            Set psDriverID    of hoCLI to sDriverID
86275>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
86276>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
86277>>>>>>>            If (bOk = False) Begin
86279>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
86280>>>>>>>>
86280>>>>>>>                Function_Return False
86281>>>>>>>            End
86281>>>>>>>>
86281>>>>>>>            Move bOK to bExists
86282>>>>>>>        End
86282>>>>>>>>
86282>>>>>>>
86282>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86283>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
86284>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
86285>>>>>>>        Send Destroy of hoDriver
86286>>>>>>>
86286>>>>>>>        Function_Return (bExists = True)
86287>>>>>>>    End_Function
86288>>>>>>>
86288>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
86288>>>>>>>    // Returns: False if nobody else is running
86288>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
86288>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
86288>>>>>>>    //      tables are not locked as DataFlex tables are.
86288>>>>>>>    Function IsDatabaseInUse Returns Boolean
86290>>>>>>>        Handle  hTable
86290>>>>>>>        String  sRootName
86290>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
86290>>>>>>>        Integer iCount iTables
86290>>>>>>>
86290>>>>>>>        Move 0 to iTables
86291>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
86292>>>>>>>        Get AutoConnectionIDLogin to bOK
86293>>>>>>>        Get UtilFilelistNoOfTables to iTables
86294>>>>>>>        Set piPosition   of ghoProgressBar to 0
86295>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
86296>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
86297>>>>>>>        Move 0 to hTable
86298>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86301>>>>>>>        Move False to bErr
86302>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
86303>>>>>>>
86303>>>>>>>        Repeat
86303>>>>>>>>
86303>>>>>>>            Set piPosition of ghoProgressBar to iCount
86304>>>>>>>            Increment iCount
86305>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86308>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
86309>>>>>>>
86309>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
86309>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
86310>>>>>>>            Move False to bOpen
86311>>>>>>>            Get UtilTableExists hTable to bExists
86312>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
86312>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
86314>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86315>>>>>>>                Open hTable
86317>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
86320>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
86321>>>>>>>                If (bOpen = True) Begin
86323>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
86323>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
86324>>>>>>>                    If (bAlias = False) Begin
86326>>>>>>>                        Close hTable
86327>>>>>>>                        Get OpenTableExclusive hTable to bOpen
86328>>>>>>>                        If (bOpen = False) Begin
86330>>>>>>>                            Move True to bErr
86331>>>>>>>                        End
86331>>>>>>>>
86331>>>>>>>                    End
86331>>>>>>>>
86331>>>>>>>                End
86331>>>>>>>>
86331>>>>>>>                Close hTable
86332>>>>>>>            End
86332>>>>>>>>
86332>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86335>>>>>>>            If (bErr = True ) ;                Break
86338>>>>>>>        Until (not(hTable))
86340>>>>>>>
86340>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86341>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
86342>>>>>>>        Move False to Err
86343>>>>>>>
86343>>>>>>>        Function_Return bErr
86344>>>>>>>    End_Function
86345>>>>>>>
86345>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
86345>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
86345>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
86345>>>>>>>    // NOTE: Only applicable for DAW drivers.
86345>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
86347>>>>>>>        String sID sConnString
86347>>>>>>>        Integer iDriver iNumConn iCount
86347>>>>>>>        Handle hoCLI
86347>>>>>>>        Boolean bOK
86347>>>>>>>
86347>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
86348>>>>>>>        If (bOK = False) Begin
86350>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
86351>>>>>>>>
86351>>>>>>>            Function_Return False
86352>>>>>>>        End
86352>>>>>>>>
86352>>>>>>>
86352>>>>>>>        Move False to bOK
86353>>>>>>>        Get phoCLIHandler to hoCLI
86354>>>>>>>        If (hoCLI <> 0) Begin
86356>>>>>>>            Set psDriverID of hoCLI to sDriverID
86357>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
86358>>>>>>>
86358>>>>>>>            // If driver not loaded; load it.
86358>>>>>>>            If (iDriver = 0) Begin
86360>>>>>>>                Load_Driver sDriverID
86361>>>>>>>                Get DriverIndex sDriverID to iDriver
86362>>>>>>>            End
86362>>>>>>>>
86362>>>>>>>            If (iDriver <> 0) Begin
86364>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86367>>>>>>>                Decrement iNumConn
86368>>>>>>>                for iCount from 0 to iNumConn
86374>>>>>>>>
86374>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
86377>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
86380>>>>>>>                    If (sID = sConnectionID) Begin
86382>>>>>>>                        Move True to bOK
86383>>>>>>>                    End
86383>>>>>>>>
86383>>>>>>>                Loop
86384>>>>>>>>
86384>>>>>>>            End
86384>>>>>>>>
86384>>>>>>>        End
86384>>>>>>>>
86384>>>>>>>
86384>>>>>>>        Function_Return bOK
86385>>>>>>>    End_Function
86386>>>>>>>
86386>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
86388>>>>>>>        Boolean bOK
86388>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
86389>>>>>>>        Function_Return bOK
86390>>>>>>>    End_Function
86391>>>>>>>
86391>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
86393>>>>>>>        Boolean bOK
86393>>>>>>>        Move False to bOK
86394>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
86395>>>>>>>        Function_Return bOK
86396>>>>>>>    End_Function
86397>>>>>>>
86397>>>>>>>    Function IsMSSQLDriver Returns Boolean
86399>>>>>>>        Integer iDriverIndex
86399>>>>>>>
86399>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
86400>>>>>>>
86400>>>>>>>        Function_Return (iDriverIndex <> 0)
86401>>>>>>>    End_Function
86402>>>>>>>
86402>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
86402>>>>>>>    // attempt to load the driver.
86402>>>>>>>    // Returns true if the passed driver is SQL based.
86402>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
86404>>>>>>>        Boolean bOK
86404>>>>>>>
86404>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
86405>>>>>>>
86405>>>>>>>        If (bOK = False) Begin
86407>>>>>>>            Get IsMertechDriver sDriverID to bOK
86408>>>>>>>        End
86408>>>>>>>>
86408>>>>>>>
86408>>>>>>>        Function_Return bOK
86409>>>>>>>    End_Function
86410>>>>>>>
86410>>>>>>>    // *** Error Handler ***
86410>>>>>>>    //
86410>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
86410>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
86410>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
86412>>>>>>>        Integer iSize iErrorMode
86412>>>>>>>        tSqlErrorArray aSqlErrorArray
86412>>>>>>>        tSqlErrorArray aSqlErrorArray
86412>>>>>>>
86412>>>>>>>        If (pbProcessingError(Self)) Begin
86414>>>>>>>            Procedure_Return
86415>>>>>>>        End
86415>>>>>>>>
86415>>>>>>>
86415>>>>>>>        Get Error_Report_Mode to iErrorMode
86416>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
86418>>>>>>>            Procedure_Return
86419>>>>>>>        End
86419>>>>>>>>
86419>>>>>>>
86419>>>>>>>        Set pbProcessingError to True
86420>>>>>>>        Set pbSqlError to True
86421>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
86422>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
86423>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
86424>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
86425>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
86426>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
86427>>>>>>>        Set pbProcessingError to False
86428>>>>>>>    End_Procedure
86429>>>>>>>
86429>>>>>>>    // *** Miscellanous Helper Functions ***
86429>>>>>>>    //
86429>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
86429>>>>>>>    // returns the table name only; stripped of any path or filename extension.
86429>>>>>>>    Function _TableNameOnly String sName Returns String
86431>>>>>>>        String sPath sExt
86431>>>>>>>
86431>>>>>>>        Get ParseFolderName sName to sPath
86432>>>>>>>        If (sPath <> "") Begin
86434>>>>>>>            Move (Replace(sPath, sName, "")) to sName
86435>>>>>>>        End
86435>>>>>>>>
86435>>>>>>>        Get ParseFileExtension sName to sExt
86436>>>>>>>        If (sExt <> "") Begin
86438>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
86439>>>>>>>        End
86439>>>>>>>>
86439>>>>>>>
86439>>>>>>>        Function_Return sName
86440>>>>>>>    End_Function
86441>>>>>>>
86441>>>>>>>    // Removes any prefix to a table name.
86441>>>>>>>    // Example mssqldrv:mytable returns mytable
86441>>>>>>>    //         dbo.mytable returns mytable
86441>>>>>>>    Function _TableNoPrefix String sName Returns String
86443>>>>>>>        Integer iPos
86443>>>>>>>
86443>>>>>>>        Move (Pos(":", sName)) to iPos
86444>>>>>>>        If (iPos <> 0) Begin
86446>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
86447>>>>>>>        End
86447>>>>>>>>
86447>>>>>>>        Move (Pos(".", sName)) to iPos
86448>>>>>>>        If (iPos <> 0) Begin
86450>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
86451>>>>>>>        End
86451>>>>>>>>
86451>>>>>>>
86451>>>>>>>        Function_Return sName
86452>>>>>>>    End_Function
86453>>>>>>>
86453>>>>>>>    // Returns the first datapath found in the psDataPath property.
86453>>>>>>>    // The returned path always ends with a "\"
86453>>>>>>>    Function psDataPathFirstPart Returns String
86455>>>>>>>        String sDataPath
86455>>>>>>>        Integer iCount
86455>>>>>>>
86455>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
86456>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
86457>>>>>>>        If (iCount > 1) Begin
86459>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
86460>>>>>>>        End
86460>>>>>>>>
86460>>>>>>>        If (sDataPath <> "") Begin
86462>>>>>>>            Get vFolderFormat sDataPath to sDataPath
86463>>>>>>>        End
86463>>>>>>>>
86463>>>>>>>
86463>>>>>>>        Function_Return sDataPath
86464>>>>>>>    End_Function
86465>>>>>>>
86465>>>>>>>    Function psLogTextFileWithPath Returns String
86467>>>>>>>        String sFileName
86467>>>>>>>        Handle hoLogFile
86467>>>>>>>        Get phoLogFile to hoLogFile
86468>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
86469>>>>>>>        Function_Return sFileName
86470>>>>>>>    End_Function
86471>>>>>>>
86471>>>>>>>    // *** Property Messages ***
86471>>>>>>>    //
86471>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
86471>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
86471>>>>>>>    //
86471>>>>>>>
86471>>>>>>>    Function pSQLConnection Returns tSQLConnection
86473>>>>>>>        tSQLConnection SQLConnection
86473>>>>>>>        tSQLConnection SQLConnection
86473>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86475>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
86475>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86476>>>>>>>>
86476>>>>>>>            Function_Return
86477>>>>>>>        End
86477>>>>>>>>
86477>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86478>>>>>>>        Function_Return SQLConnection
86479>>>>>>>    End_Function
86480>>>>>>>
86480>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86480>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
86482>>>>>>>        Function_Return False
86483>>>>>>>    End_Function
86484>>>>>>>
86484>>>>>>>    Procedure Set psServer String sValue
86486>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86488>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
86488>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86489>>>>>>>>
86489>>>>>>>            Procedure_Return
86490>>>>>>>        End
86490>>>>>>>>
86490>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
86491>>>>>>>    End_Procedure
86492>>>>>>>
86492>>>>>>>    Function psServer Returns String
86494>>>>>>>        String sValue
86494>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86496>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86497>>>>>>>>
86497>>>>>>>            Function_Return
86498>>>>>>>        End
86498>>>>>>>>
86498>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
86499>>>>>>>        Function_Return sValue
86500>>>>>>>    End_Function
86501>>>>>>>
86501>>>>>>>    Procedure Set psDatabase String sValue
86503>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86505>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86506>>>>>>>>
86506>>>>>>>            Procedure_Return
86507>>>>>>>        End
86507>>>>>>>>
86507>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
86508>>>>>>>    End_Procedure
86509>>>>>>>
86509>>>>>>>    Function psDatabase Returns String
86511>>>>>>>        String sValue
86511>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86513>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86514>>>>>>>>
86514>>>>>>>            Function_Return
86515>>>>>>>        End
86515>>>>>>>>
86515>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
86516>>>>>>>        Function_Return sValue
86517>>>>>>>    End_Function
86518>>>>>>>
86518>>>>>>>    Procedure Set psUserID String sValue
86520>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86522>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86523>>>>>>>>
86523>>>>>>>            Procedure_Return
86524>>>>>>>        End
86524>>>>>>>>
86524>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
86525>>>>>>>    End_Procedure
86526>>>>>>>
86526>>>>>>>    Function psUserID Returns String
86528>>>>>>>        String sValue
86528>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86530>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86531>>>>>>>>
86531>>>>>>>            Function_Return
86532>>>>>>>        End
86532>>>>>>>>
86532>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
86533>>>>>>>        Function_Return sValue
86534>>>>>>>    End_Function
86535>>>>>>>
86535>>>>>>>    Procedure Set psPassword String sValue
86537>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86539>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86540>>>>>>>>
86540>>>>>>>            Procedure_Return
86541>>>>>>>        End
86541>>>>>>>>
86541>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
86542>>>>>>>    End_Procedure
86543>>>>>>>
86543>>>>>>>    Function psPassword Returns String
86545>>>>>>>        String sValue
86545>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86547>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86548>>>>>>>>
86548>>>>>>>            Function_Return
86549>>>>>>>        End
86549>>>>>>>>
86549>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
86550>>>>>>>        Function_Return sValue
86551>>>>>>>    End_Function
86552>>>>>>>
86552>>>>>>>    Procedure Set pbTrusted Boolean bValue
86554>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86556>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86557>>>>>>>>
86557>>>>>>>            Procedure_Return
86558>>>>>>>        End
86558>>>>>>>>
86558>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
86559>>>>>>>    End_Procedure
86560>>>>>>>
86560>>>>>>>    Function pbTrusted Returns Boolean
86562>>>>>>>        Boolean bValue
86562>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86564>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86565>>>>>>>>
86565>>>>>>>            Function_Return
86566>>>>>>>        End
86566>>>>>>>>
86566>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
86567>>>>>>>        Function_Return bValue
86568>>>>>>>    End_Function
86569>>>>>>>
86569>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
86571>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86573>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86574>>>>>>>>
86574>>>>>>>            Procedure_Return
86575>>>>>>>        End
86575>>>>>>>>
86575>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
86576>>>>>>>    End_Procedure
86577>>>>>>>
86577>>>>>>>    Function pbSilentLogin Returns Boolean
86579>>>>>>>        Boolean bValue
86579>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86581>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86582>>>>>>>>
86582>>>>>>>            Function_Return
86583>>>>>>>        End
86583>>>>>>>>
86583>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
86584>>>>>>>        Function_Return bValue
86585>>>>>>>    End_Function
86586>>>>>>>
86586>>>>>>>    Procedure Set psConnectionID String sValue
86588>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86590>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86591>>>>>>>>
86591>>>>>>>            Procedure_Return
86592>>>>>>>        End
86592>>>>>>>>
86592>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
86593>>>>>>>    End_Procedure
86594>>>>>>>
86594>>>>>>>    Function psConnectionID Returns String
86596>>>>>>>        String sValue
86596>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86598>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86599>>>>>>>>
86599>>>>>>>            Function_Return
86600>>>>>>>        End
86600>>>>>>>>
86600>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
86601>>>>>>>        Function_Return sValue
86602>>>>>>>    End_Function
86603>>>>>>>
86603>>>>>>>    Procedure Set psConnectionString String sValue
86605>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86607>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86608>>>>>>>>
86608>>>>>>>            Procedure_Return
86609>>>>>>>        End
86609>>>>>>>>
86609>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
86610>>>>>>>    End_Procedure
86611>>>>>>>
86611>>>>>>>    Function psConnectionString Returns String
86613>>>>>>>        String sValue
86613>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86615>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86616>>>>>>>>
86616>>>>>>>            Function_Return
86617>>>>>>>        End
86617>>>>>>>>
86617>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
86618>>>>>>>        Function_Return sValue
86619>>>>>>>    End_Function
86620>>>>>>>
86620>>>>>>>    // The normal connection string looks something like this;
86620>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
86620>>>>>>>    // ...and the full connection string looks like this;
86620>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
86620>>>>>>>    Function psFullConnectionString Returns String
86622>>>>>>>        String sConnectionID sConnectionString
86622>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86624>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86625>>>>>>>>
86625>>>>>>>            Function_Return
86626>>>>>>>        End
86626>>>>>>>>
86626>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
86627>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
86628>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
86629>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
86630>>>>>>>    End_Function
86631>>>>>>>
86631>>>>>>>    Function piConnectionOptions Returns Integer
86633>>>>>>>        Integer iValue
86633>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86635>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86636>>>>>>>>
86636>>>>>>>            Function_Return
86637>>>>>>>        End
86637>>>>>>>>
86637>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
86638>>>>>>>        Function_Return iValue
86639>>>>>>>    End_Function
86640>>>>>>>
86640>>>>>>>    Procedure Set psSchema String sValue
86642>>>>>>>        tSQLConnection SQLConnection
86642>>>>>>>        tSQLConnection SQLConnection
86642>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86644>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86645>>>>>>>>
86645>>>>>>>            Procedure_Return
86646>>>>>>>        End
86646>>>>>>>>
86646>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
86647>>>>>>>    End_Procedure
86648>>>>>>>
86648>>>>>>>    Function psSchema Returns String
86650>>>>>>>        String sRetval
86650>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86652>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86653>>>>>>>>
86653>>>>>>>            Function_Return
86654>>>>>>>        End
86654>>>>>>>>
86654>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
86655>>>>>>>        Function_Return sRetval
86656>>>>>>>    End_Function
86657>>>>>>>
86657>>>>>>>    Procedure Set psBaseTableSpace String sValue
86659>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86661>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86662>>>>>>>>
86662>>>>>>>            Procedure_Return
86663>>>>>>>        End
86663>>>>>>>>
86663>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
86664>>>>>>>    End_Procedure
86665>>>>>>>
86665>>>>>>>    Function psBaseTableSpace Returns String
86667>>>>>>>        String sRetval
86667>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86669>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86670>>>>>>>>
86670>>>>>>>            Function_Return
86671>>>>>>>        End
86671>>>>>>>>
86671>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
86672>>>>>>>        Function_Return sRetval
86673>>>>>>>    End_Function
86674>>>>>>>
86674>>>>>>>    Procedure Set psLongTableSpace String sValue
86676>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86678>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86679>>>>>>>>
86679>>>>>>>            Procedure_Return
86680>>>>>>>        End
86680>>>>>>>>
86680>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
86681>>>>>>>    End_Procedure
86682>>>>>>>
86682>>>>>>>    Function psLongTableSpace Returns String
86684>>>>>>>        String sRetval
86684>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86686>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86687>>>>>>>>
86687>>>>>>>            Function_Return
86688>>>>>>>        End
86688>>>>>>>>
86688>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
86689>>>>>>>        Function_Return sRetval
86690>>>>>>>    End_Function
86691>>>>>>>
86691>>>>>>>    Procedure Set psIndexTableSpace String sValue
86693>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86695>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86696>>>>>>>>
86696>>>>>>>            Procedure_Return
86697>>>>>>>        End
86697>>>>>>>>
86697>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
86698>>>>>>>    End_Procedure
86699>>>>>>>
86699>>>>>>>    Function psIndexTableSpace Returns String
86701>>>>>>>        String sRetval
86701>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86703>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86704>>>>>>>>
86704>>>>>>>            Function_Return
86705>>>>>>>        End
86705>>>>>>>>
86705>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
86706>>>>>>>        Function_Return sRetval
86707>>>>>>>    End_Function
86708>>>>>>>
86708>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
86710>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86712>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86713>>>>>>>>
86713>>>>>>>            Procedure_Return
86714>>>>>>>        End
86714>>>>>>>>
86714>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
86715>>>>>>>    End_Procedure
86716>>>>>>>
86716>>>>>>>    Function pbUseConnectionID Returns Boolean
86718>>>>>>>        Boolean bState
86718>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86720>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86721>>>>>>>>
86721>>>>>>>            Function_Return
86722>>>>>>>        End
86722>>>>>>>>
86722>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
86723>>>>>>>        Function_Return bState
86724>>>>>>>    End_Function
86725>>>>>>>
86725>>>>>>>    Procedure Set pbToANSI Boolean bState
86727>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86729>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86730>>>>>>>>
86730>>>>>>>            Procedure_Return
86731>>>>>>>        End
86731>>>>>>>>
86731>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
86732>>>>>>>    End_Procedure
86733>>>>>>>
86733>>>>>>>    Function pbToANSI Returns Boolean
86735>>>>>>>        Boolean bState
86735>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86737>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86738>>>>>>>>
86738>>>>>>>            Function_Return
86739>>>>>>>        End
86739>>>>>>>>
86739>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
86740>>>>>>>        Function_Return bState
86741>>>>>>>    End_Function
86742>>>>>>>
86742>>>>>>>    Procedure Set pbRecnum Boolean bState
86744>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86746>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86747>>>>>>>>
86747>>>>>>>            Procedure_Return
86748>>>>>>>        End
86748>>>>>>>>
86748>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
86749>>>>>>>    End_Procedure
86750>>>>>>>
86750>>>>>>>    Function pbRecnum Returns Boolean
86752>>>>>>>        Boolean bState
86752>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86754>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86755>>>>>>>>
86755>>>>>>>            Function_Return
86756>>>>>>>        End
86756>>>>>>>>
86756>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
86757>>>>>>>        Function_Return bState
86758>>>>>>>    End_Function
86759>>>>>>>
86759>>>>>>>    Procedure Set pbCopyData Boolean bState
86761>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86763>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86764>>>>>>>>
86764>>>>>>>            Procedure_Return
86765>>>>>>>        End
86765>>>>>>>>
86765>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
86766>>>>>>>    End_Procedure
86767>>>>>>>
86767>>>>>>>    Function pbCopyData Returns Boolean
86769>>>>>>>        Boolean bState
86769>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86771>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86772>>>>>>>>
86772>>>>>>>            Function_Return
86773>>>>>>>        End
86773>>>>>>>>
86773>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
86774>>>>>>>        Function_Return bState
86775>>>>>>>    End_Function
86776>>>>>>>
86776>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
86778>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86780>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86781>>>>>>>>
86781>>>>>>>            Procedure_Return
86782>>>>>>>        End
86782>>>>>>>>
86782>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
86783>>>>>>>    End_Procedure
86784>>>>>>>
86784>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
86786>>>>>>>        Boolean bState
86786>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86788>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86789>>>>>>>>
86789>>>>>>>            Function_Return
86790>>>>>>>        End
86790>>>>>>>>
86790>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
86791>>>>>>>        Function_Return bState
86792>>>>>>>    End_Function
86793>>>>>>>
86793>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
86795>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86797>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86798>>>>>>>>
86798>>>>>>>            Procedure_Return
86799>>>>>>>        End
86799>>>>>>>>
86799>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
86800>>>>>>>    End_Procedure
86801>>>>>>>
86801>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
86803>>>>>>>        Boolean bState
86803>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86805>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86806>>>>>>>>
86806>>>>>>>            Function_Return
86807>>>>>>>        End
86807>>>>>>>>
86807>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
86808>>>>>>>        Function_Return bState
86809>>>>>>>    End_Function
86810>>>>>>>
86810>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
86812>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86814>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86815>>>>>>>>
86815>>>>>>>            Procedure_Return
86816>>>>>>>        End
86816>>>>>>>>
86816>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
86817>>>>>>>    End_Procedure
86818>>>>>>>
86818>>>>>>>    Function pbCompareIndexAscending Returns Boolean
86820>>>>>>>        Boolean bState
86820>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86822>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86823>>>>>>>>
86823>>>>>>>            Function_Return
86824>>>>>>>        End
86824>>>>>>>>
86824>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
86825>>>>>>>        Function_Return bState
86826>>>>>>>    End_Function
86827>>>>>>>
86827>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
86829>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86831>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86832>>>>>>>>
86832>>>>>>>            Procedure_Return
86833>>>>>>>        End
86833>>>>>>>>
86833>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
86834>>>>>>>    End_Procedure
86835>>>>>>>
86835>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
86837>>>>>>>        Boolean bState
86837>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86839>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
86840>>>>>>>>
86840>>>>>>>            Function_Return
86841>>>>>>>        End
86841>>>>>>>>
86841>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
86842>>>>>>>        Function_Return bState
86843>>>>>>>    End_Function
86844>>>>>>>
86844>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
86846>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86848>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86849>>>>>>>>
86849>>>>>>>            Procedure_Return
86850>>>>>>>        End
86850>>>>>>>>
86850>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
86851>>>>>>>    End_Procedure
86852>>>>>>>
86852>>>>>>>    Function psDriverDefaultValueASCII Returns String
86854>>>>>>>        String sRetval
86854>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86856>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86857>>>>>>>>
86857>>>>>>>            Function_Return
86858>>>>>>>        End
86858>>>>>>>>
86858>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
86859>>>>>>>        Function_Return sRetval
86860>>>>>>>    End_Function
86861>>>>>>>
86861>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
86863>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86865>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86866>>>>>>>>
86866>>>>>>>            Procedure_Return
86867>>>>>>>        End
86867>>>>>>>>
86867>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
86868>>>>>>>    End_Procedure
86869>>>>>>>
86869>>>>>>>    Function psDriverDefaultValueBinary Returns String
86871>>>>>>>        String sRetval
86871>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86873>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86874>>>>>>>>
86874>>>>>>>            Function_Return
86875>>>>>>>        End
86875>>>>>>>>
86875>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
86876>>>>>>>        Function_Return sRetval
86877>>>>>>>    End_Function
86878>>>>>>>
86878>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
86880>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86882>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86883>>>>>>>>
86883>>>>>>>            Procedure_Return
86884>>>>>>>        End
86884>>>>>>>>
86884>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
86885>>>>>>>    End_Procedure
86886>>>>>>>
86886>>>>>>>    Function psDriverDefaultValueDate Returns String
86888>>>>>>>        String sRetval
86888>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86890>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86891>>>>>>>>
86891>>>>>>>            Function_Return
86892>>>>>>>        End
86892>>>>>>>>
86892>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
86893>>>>>>>        Function_Return sRetval
86894>>>>>>>    End_Function
86895>>>>>>>
86895>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
86897>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86899>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86900>>>>>>>>
86900>>>>>>>            Procedure_Return
86901>>>>>>>        End
86901>>>>>>>>
86901>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
86902>>>>>>>    End_Procedure
86903>>>>>>>
86903>>>>>>>    Function psDriverDefaultValueDateTime Returns String
86905>>>>>>>        String sRetval
86905>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86907>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86908>>>>>>>>
86908>>>>>>>            Function_Return
86909>>>>>>>        End
86909>>>>>>>>
86909>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
86910>>>>>>>        Function_Return sRetval
86911>>>>>>>    End_Function
86912>>>>>>>
86912>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
86914>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86916>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86917>>>>>>>>
86917>>>>>>>            Procedure_Return
86918>>>>>>>        End
86918>>>>>>>>
86918>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
86919>>>>>>>    End_Procedure
86920>>>>>>>
86920>>>>>>>    Function psDriverDefaultValueNumeric Returns String
86922>>>>>>>        String sRetval
86922>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86924>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86925>>>>>>>>
86925>>>>>>>            Function_Return
86926>>>>>>>        End
86926>>>>>>>>
86926>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
86927>>>>>>>        Function_Return sRetval
86928>>>>>>>    End_Function
86929>>>>>>>
86929>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
86931>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86933>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86934>>>>>>>>
86934>>>>>>>            Procedure_Return
86935>>>>>>>        End
86935>>>>>>>>
86935>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
86936>>>>>>>    End_Procedure
86937>>>>>>>
86937>>>>>>>    Function psDriverDefaultValueText Returns String
86939>>>>>>>        String sRetval
86939>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86941>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86942>>>>>>>>
86942>>>>>>>            Function_Return
86943>>>>>>>        End
86943>>>>>>>>
86943>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
86944>>>>>>>        Function_Return sRetval
86945>>>>>>>    End_Function
86946>>>>>>>
86946>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
86948>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86950>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86951>>>>>>>>
86951>>>>>>>            Procedure_Return
86952>>>>>>>        End
86952>>>>>>>>
86952>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
86953>>>>>>>    End_Procedure
86954>>>>>>>
86954>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
86956>>>>>>>        Boolean bState
86956>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86958>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86959>>>>>>>>
86959>>>>>>>            Function_Return
86960>>>>>>>        End
86960>>>>>>>>
86960>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
86961>>>>>>>        Function_Return bState
86962>>>>>>>    End_Function
86963>>>>>>>
86963>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
86965>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86967>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86968>>>>>>>>
86968>>>>>>>            Procedure_Return
86969>>>>>>>        End
86969>>>>>>>>
86969>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
86970>>>>>>>    End_Procedure
86971>>>>>>>
86971>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
86973>>>>>>>        Boolean bState
86973>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86975>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86976>>>>>>>>
86976>>>>>>>            Function_Return
86977>>>>>>>        End
86977>>>>>>>>
86977>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
86978>>>>>>>        Function_Return bState
86979>>>>>>>    End_Function
86980>>>>>>>
86980>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
86982>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86984>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86985>>>>>>>>
86985>>>>>>>            Procedure_Return
86986>>>>>>>        End
86986>>>>>>>>
86986>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
86987>>>>>>>    End_Procedure
86988>>>>>>>
86988>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
86990>>>>>>>        Boolean bState
86990>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
86992>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
86993>>>>>>>>
86993>>>>>>>            Function_Return
86994>>>>>>>        End
86994>>>>>>>>
86994>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
86995>>>>>>>        Function_Return bState
86996>>>>>>>    End_Function
86997>>>>>>>
86997>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
86999>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87001>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87002>>>>>>>>
87002>>>>>>>            Procedure_Return
87003>>>>>>>        End
87003>>>>>>>>
87003>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
87004>>>>>>>    End_Procedure
87005>>>>>>>
87005>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
87007>>>>>>>        Boolean bState
87007>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87009>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87010>>>>>>>>
87010>>>>>>>            Function_Return
87011>>>>>>>        End
87011>>>>>>>>
87011>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
87012>>>>>>>        Function_Return bState
87013>>>>>>>    End_Function
87014>>>>>>>
87014>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
87016>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87018>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87019>>>>>>>>
87019>>>>>>>            Procedure_Return
87020>>>>>>>        End
87020>>>>>>>>
87020>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
87021>>>>>>>    End_Procedure
87022>>>>>>>
87022>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
87024>>>>>>>        Boolean bState
87024>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87026>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87027>>>>>>>>
87027>>>>>>>            Function_Return
87028>>>>>>>        End
87028>>>>>>>>
87028>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
87029>>>>>>>        Function_Return bState
87030>>>>>>>    End_Function
87031>>>>>>>
87031>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
87033>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87035>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87036>>>>>>>>
87036>>>>>>>            Procedure_Return
87037>>>>>>>        End
87037>>>>>>>>
87037>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
87038>>>>>>>    End_Procedure
87039>>>>>>>
87039>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
87041>>>>>>>        Boolean bState
87041>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
87043>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
87044>>>>>>>>
87044>>>>>>>            Function_Return
87045>>>>>>>        End
87045>>>>>>>>
87045>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
87046>>>>>>>        Function_Return bState
87047>>>>>>>    End_Function
87048>>>>>>>
87048>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
87048>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
87048>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
87048>>>>>>>    //       for a connection string has the wrong format for that driver.
87048>>>>>>>    Procedure Set psDriverID String sValue
87050>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87051>>>>>>>        Delegate Set psDriverID to sValue
87053>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87054>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
87055>>>>>>>    End_Procedure
87056>>>>>>>
87056>>>>>>>    Function psDriverID Returns String
87058>>>>>>>        String sDriverID
87058>>>>>>>
87058>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87059>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
87059>>>>>>>        Delegate Get psDriverID to sDriverID
87061>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87062>>>>>>>        Move False to Err
87063>>>>>>>
87063>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
87063>>>>>>>        // probably used as "utilites" from a special made program and
87063>>>>>>>        // the ghoSQLConnectionHandler must have been setup
87063>>>>>>>        If (sDriverID = "") Begin
87065>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
87066>>>>>>>        End
87066>>>>>>>>
87066>>>>>>>        Function_Return sDriverID
87067>>>>>>>    End_Function
87068>>>>>>>
87068>>>>>>>    Procedure Set piDbType Integer iValue
87070>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87071>>>>>>>        Delegate Set piDbType to iValue
87073>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87074>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
87075>>>>>>>    End_Procedure
87076>>>>>>>
87076>>>>>>>    Function piDbType Returns Integer
87078>>>>>>>        Integer iRetval
87078>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
87079>>>>>>>        Function_Return iRetval
87080>>>>>>>    End_Function
87081>>>>>>>
87081>>>>>>>    Function phoLogFile Returns Handle
87083>>>>>>>        Handle hoLogFile   
87083>>>>>>>        Boolean bErr
87083>>>>>>>        
87083>>>>>>>        Move Err to bErr
87084>>>>>>>        Move 0 to hoLogFile
87085>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
87086>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87087>>>>>>>        Delegate Get phoLogFile to hoLogFile
87089>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87090>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87091>>>>>>>        Move bErr to Err
87092>>>>>>>        
87092>>>>>>>        Function_Return hoLogFile
87093>>>>>>>    End_Function
87094>>>>>>>
87094>>>>>>>    Function pnCurrentVersionUpdate Returns Number
87096>>>>>>>        Number nCurrentVersionUpdate
87096>>>>>>>
87096>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87097>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
87099>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87100>>>>>>>
87100>>>>>>>        Function_Return nCurrentVersionUpdate
87101>>>>>>>    End_Function
87102>>>>>>>
87102>>>>>>>    Procedure LogError String sText Boolean bError
87104>>>>>>>        Handle hoLogFile
87104>>>>>>>        Number nCurrentVersionUpdate
87104>>>>>>>
87104>>>>>>>        Get phoLogFile to hoLogFile
87105>>>>>>>        If (hoLogFile = 0) Begin
87107>>>>>>>            Procedure_Return
87108>>>>>>>        End
87108>>>>>>>>
87108>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
87109>>>>>>>
87109>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87110>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
87111>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87112>>>>>>>    End_Procedure
87113>>>>>>>
87113>>>>>>>    Function pbContinueOnError Returns Boolean
87115>>>>>>>        Boolean bContinueOnError
87115>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87117>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
87118>>>>>>>        End
87118>>>>>>>>
87118>>>>>>>        Function_Return bContinueOnError
87119>>>>>>>    End_Function
87120>>>>>>>
87120>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
87120>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
87120>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
87120>>>>>>>    // Good read about which collation to select:
87120>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
87120>>>>>>>    Procedure Set psCollation String sCollation
87122>>>>>>>        Set private.psCollation to sCollation
87123>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87125>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
87126>>>>>>>        End
87126>>>>>>>>
87126>>>>>>>    End_Procedure
87127>>>>>>>
87127>>>>>>>    Function psCollation Returns String
87129>>>>>>>        String sCollation
87129>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87131>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
87132>>>>>>>        End   
87132>>>>>>>>
87132>>>>>>>        Else Begin
87133>>>>>>>            Get private.psCollation to sCollation
87134>>>>>>>        End
87134>>>>>>>>
87134>>>>>>>        Function_Return sCollation
87135>>>>>>>    End_Function
87136>>>>>>>
87136>>>>>>>
87136>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
87138>>>>>>>        Integer iMax iPos
87138>>>>>>>        String sName
87138>>>>>>>
87138>>>>>>>        Move (Lowercase(sField)) to sField
87139>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
87142>>>>>>>        for iPos from 0 to iMax
87148>>>>>>>>
87148>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
87151>>>>>>>            Move (Lowercase(sName)) to sName
87152>>>>>>>            If (sName = sField) Begin
87154>>>>>>>                Function_Return iPos
87155>>>>>>>            End
87155>>>>>>>>
87155>>>>>>>        Loop
87156>>>>>>>>
87156>>>>>>>        Function_Return -1
87157>>>>>>>    End_Function
87158>>>>>>>
87158>>>>>>>
87158>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87158>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
87160>>>>>>>        Function_Return False
87161>>>>>>>    End_Function
87162>>>>>>>
87162>>>>>>>    // *** Helper functions with compiled sql script code ***
87162>>>>>>>    //
87162>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
87162>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
87162>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
87162>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
87162>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
87162>>>>>>>    //   ALTER TABLE MyTable
87162>>>>>>>    //       REBUILD
87162>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
87164>>>>>>>        Boolean bOK
87164>>>>>>>
87164>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
87166>>>>>>>            Function_Return False
87167>>>>>>>        End
87167>>>>>>>>
87167>>>>>>>
87167>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
87167>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
87168>>>>>>>
87168>>>>>>>        Function_Return (bOK = True)
87169>>>>>>>    End_Function
87170>>>>>>>
87170>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
87170>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
87170>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
87170>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
87170>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
87170>>>>>>>    //   ALTER TABLE MyTable
87170>>>>>>>    //       REBUILD
87170>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
87172>>>>>>>        tSQLScriptArray SQLScriptArray
87172>>>>>>>        tSQLScriptArray SQLScriptArray
87172>>>>>>>        String sDriverID
87172>>>>>>>        Boolean bOK
87172>>>>>>>        Integer iSize iCount
87172>>>>>>>
87172>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
87174>>>>>>>            Function_Return False
87175>>>>>>>        End
87175>>>>>>>>
87175>>>>>>>
87175>>>>>>>        Get psDriverID to sDriverID
87176>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
87177>>>>>>>        If (SQLScriptArray.bError = True) Begin
87179>>>>>>>            Function_Return False
87180>>>>>>>        End
87180>>>>>>>>
87180>>>>>>>
87180>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
87181>>>>>>>        Decrement iSize
87182>>>>>>>
87182>>>>>>>        for iCount from 0 to iSize
87188>>>>>>>>
87188>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
87190>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
87191>>>>>>>            End
87191>>>>>>>>
87191>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
87193>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
87194>>>>>>>            End
87194>>>>>>>>
87194>>>>>>>        Loop
87195>>>>>>>>
87195>>>>>>>
87195>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
87196>>>>>>>
87196>>>>>>>        Function_Return (bOK = True)
87197>>>>>>>    End_Function
87198>>>>>>>
87198>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
87200>>>>>>>        tSQLScriptArray SQLScriptArray
87200>>>>>>>        tSQLScriptArray SQLScriptArray
87200>>>>>>>        String sDriverID sCollation
87200>>>>>>>        Boolean bOK
87200>>>>>>>        Integer iSize iCount
87200>>>>>>>
87200>>>>>>>        If (Trim(sDatabaseName) = "") Begin
87202>>>>>>>            Function_Return False
87203>>>>>>>        End
87203>>>>>>>>
87203>>>>>>>
87203>>>>>>>        Get psDriverID  to sDriverID
87204>>>>>>>        Get psCollation to sCollation
87205>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
87206>>>>>>>        If (SQLScriptArray.bError = True) Begin
87208>>>>>>>            Function_Return False
87209>>>>>>>        End
87209>>>>>>>>
87209>>>>>>>
87209>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
87210>>>>>>>        Decrement iSize
87211>>>>>>>
87211>>>>>>>        for iCount from 0 to iSize
87217>>>>>>>>
87217>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
87219>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
87220>>>>>>>            End
87220>>>>>>>>
87220>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
87222>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
87223>>>>>>>            End
87223>>>>>>>>
87223>>>>>>>        Loop
87224>>>>>>>>
87224>>>>>>>
87224>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
87225>>>>>>>
87225>>>>>>>        Function_Return (bOK = True)
87226>>>>>>>    End_Function
87227>>>>>>>
87227>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
87229>>>>>>>        tSQLScriptArray SQLScriptArray
87229>>>>>>>        tSQLScriptArray SQLScriptArray
87229>>>>>>>        String sDriverID sCollation
87229>>>>>>>        Boolean bOK
87229>>>>>>>        Integer iSize iCount
87229>>>>>>>
87229>>>>>>>        If (Trim(sDatabaseName) = "") Begin
87231>>>>>>>            Function_Return False
87232>>>>>>>        End
87232>>>>>>>>
87232>>>>>>>
87232>>>>>>>        Get psDriverID  to sDriverID
87233>>>>>>>        Get psCollation to sCollation
87234>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
87235>>>>>>>        If (SQLScriptArray.bError = True) Begin
87237>>>>>>>            Function_Return False
87238>>>>>>>        End
87238>>>>>>>>
87238>>>>>>>
87238>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
87239>>>>>>>        Decrement iSize
87240>>>>>>>
87240>>>>>>>        for iCount from 0 to iSize
87246>>>>>>>>
87246>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
87248>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
87249>>>>>>>            End
87249>>>>>>>>
87249>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
87251>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
87252>>>>>>>            End
87252>>>>>>>>
87252>>>>>>>        Loop
87253>>>>>>>>
87253>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
87253>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
87254>>>>>>>
87254>>>>>>>        Function_Return (bOK = True)
87255>>>>>>>    End_Function
87256>>>>>>>
87256>>>>>>>    // *** Helper functions for Mertech Drivers ***
87256>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
87256>>>>>>>    // and commands that the Studio editor knows nothing about.
87256>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
87258>>>>>>>        Integer iRetval
87258>>>>>>>        String sPath
87258>>>>>>>
87258>>>>>>>        If (sPath = "" or sTableName = "") Begin
87260>>>>>>>            Function_Return True
87261>>>>>>>        End
87261>>>>>>>>
87261>>>>>>>
87261>>>>>>>        Get vFolderFormat sPath to sPath
87262>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
87263>>>>>>>        Function_Return (iRetval = 0)
87264>>>>>>>    End_Function
87265>>>>>>>
87265>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
87267>>>>>>>        Boolean bOpen bOK
87267>>>>>>>        Move False to Err
87268>>>>>>>        Function_Return (Err = False)
87269>>>>>>>    End_Function
87270>>>>>>>
87270>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
87272>>>>>>>        Integer iNumItems iCount
87272>>>>>>>        String[] sReturnArray
87273>>>>>>>        String sServer
87273>>>>>>>
87273>>>>>>>
87273>>>>>>>        Function_Return sReturnArray
87274>>>>>>>    End_Function
87275>>>>>>>
87275>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
87277>>>>>>>        String[] sReturnArray
87278>>>>>>>        String sServer
87278>>>>>>>
87278>>>>>>>
87278>>>>>>>        Function_Return sReturnArray
87279>>>>>>>    End_Function
87280>>>>>>>
87280>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
87282>>>>>>>        Handle hoSQLHandler hoSQLConnect
87282>>>>>>>
87282>>>>>>>        Move 0 to hoSQLConnect
87283>>>>>>>
87283>>>>>>>        Function_Return hoSQLConnect
87284>>>>>>>    End_Function
87285>>>>>>>
87285>>>>>>>    // Returns the handle of the Mertech SQL handler.
87285>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
87285>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
87285>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
87287>>>>>>>        Handle hoSQLHandler
87287>>>>>>>        String sDriverID sServer sDatabase
87287>>>>>>>
87287>>>>>>>        Move 0 to hoSQLHandler
87288>>>>>>>        Get psDriverID to sDriverID
87289>>>>>>>        Get psServer   to sServer
87290>>>>>>>        Get psDatabase to sDatabase
87291>>>>>>>
87291>>>>>>>        Function_Return hoSQLHandler
87292>>>>>>>    End_Function
87293>>>>>>>
87293>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
87293>>>>>>>    // macro-commands <sigh!>
87293>>>>>>>    // Note: The function sets the Err flag.
87293>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
87295>>>>>>>
87295>>>>>>>        Move False to Err
87296>>>>>>>
87296>>>>>>>        Function_Return (Err = False)
87297>>>>>>>    End_Function
87298>>>>>>>
87298>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
87300>>>>>>>        Move False to Err
87301>>>>>>>        Function_Return (Err = False)
87302>>>>>>>    End_Function
87303>>>>>>>
87303>>>>>>>End_Class
87304>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\for_all.pkg)
87304>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
87304>>>>>>>//
87304>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
87304>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
87304>>>>>>>// conjunction with constraint-clauses.
87304>>>>>>>//
87304>>>>>>>// SYNTAX:
87304>>>>>>>//
87304>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
87304>>>>>>>//    <Constraints...>
87304>>>>>>>//    {DO}
87304>>>>>>>//      <loop body>
87304>>>>>>>//  End_For_All
87304>>>>>>>//
87304>>>>>>>// This set of macros implements a constraint-oriented file enumeration
87304>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
87304>>>>>>>//
87304>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
87304>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
87304>>>>>>>//   End_For_All
87304>>>>>>>//
87304>>>>>>>// To list only Customers with a Balance greater than their credit limit:
87304>>>>>>>//
87304>>>>>>>//   For_All Customer BY Index.1
87304>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
87304>>>>>>>//     DO
87304>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
87304>>>>>>>//   End_For_All
87304>>>>>>>//
87304>>>>>>>// Constraint clauses are:
87304>>>>>>>//
87304>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
87304>>>>>>>//   CONSTRAIN <File> AS <Expression>
87304>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
87304>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
87304>>>>>>>//
87304>>>>>>>// For example, to list all customers with a bad status whose names start
87304>>>>>>>// with "A" and which have not made a payment in thirty days:
87304>>>>>>>//
87304>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
87304>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
87304>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
87304>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
87304>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
87304>>>>>>>//      DO
87304>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
87304>>>>>>>//    End_For_All
87304>>>>>>>//
87304>>>>>>>
87304>>>>>>>
87304>>>>>>>//This command starts the loop process body when constraints are used;
87304>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
87304>>>>>>>//command line, and not on a line by itself
87304>>>>>>>//
87304>>>>>>>
87304>>>>>>>//Ends a For_All loop
87304>>>>>>>//
87304>>>>>>>
87304>>>>>>>
87304>>>>>
87304>>>>>
87304>>>>>Class cDbUpdateVersion is a cObject
87305>>>>>
87305>>>>>    Procedure Construct_Object    
87307>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
87307>>>>>        String[] aSQLQueryMessages
87308>>>>>        
87308>>>>>        Forward Send Construct_Object
87310>>>>>
87310>>>>>        // cDbUpdateHandler object event.
87310>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
87312>>>>>        If (bOnCreateExecuted = False) Begin    
87314>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
87316>>>>>            If (bUseCustomDbVersion = False) Begin
87318>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
87320>>>>>            End
87320>>>>>>
87320>>>>>            Delegate Send CheckIntFilesIntegrity
87322>>>>>            Delegate Send OnCreate
87324>>>>>            Delegate Set Private.pbOnCreateExecuted to True
87326>>>>>        End
87326>>>>>>
87326>>>>>
87326>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
87326>>>>>        // event was triggered, thus an actual change of the database was made.
87326>>>>>        Property Boolean pbVersionUpdate False
87327>>>>>
87327>>>>>        // This property must be manually set within each cDbUpdateVersion object
87327>>>>>        // by the programmer, to a consecutive number.
87327>>>>>        Property Number pnVersionNumber
87328>>>>>
87328>>>>>        Property Boolean pbUseConnectionID True
87329>>>>>        Property Boolean private.pbToANSI   True
87330>>>>>        Property Boolean private.pbRecnum   True
87331>>>>>        Property Boolean private.pbCopyData True
87332>>>>>        Property Boolean private.pbApiTableUpdateAuto False
87333>>>>>        Property Boolean private.pbCompareDate_DateTime False
87334>>>>>        Property Boolean private.pbCompareIndexAscending False
87335>>>>>        Property Boolean private.pbCompareIndexUppercase False
87336>>>>>        Property String private.psSchema
87337>>>>>        Property String private.psBaseTableSpace
87338>>>>>        Property String private.psLongTableSpace
87339>>>>>        Property String private.psIndexTableSpace
87340>>>>>
87340>>>>>        // Driver default value settings:
87340>>>>>        Property String private.psDriverDefaultValueASCII    ""
87341>>>>>        Property String private.psDriverDefaultValueBinary   ""
87342>>>>>        Property String private.psDriverDefaultValueDate     ""
87343>>>>>        Property String private.psDriverDefaultValueDateTime ""
87344>>>>>        Property String private.psDriverDefaultValueNumeric  ""
87345>>>>>        Property String private.psDriverDefaultValueText     ""
87346>>>>>
87346>>>>>        // Driver "nullability" settings:
87346>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
87347>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
87348>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
87349>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
87350>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
87351>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
87352>>>>>
87352>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
87352>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
87352>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
87352>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
87352>>>>>        // We reset it here for each cDbUpdateVersion object
87352>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
87354>>>>>    End_Procedure
87355>>>>>
87355>>>>>    // *** Main hook event message ***
87355>>>>>    // Place your database update logic here!
87355>>>>>    Procedure OnUpdate
87357>>>>>    End_Procedure
87358>>>>>
87358>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
87358>>>>>    // imported to the cDbUpdateHandler container class which should be a
87358>>>>>    // parent object to this object. To have the Studio's Property Panel
87358>>>>>    // "behave" aka show these properties we need to duplicate them in this
87358>>>>>    // class and "relay" them to the parent object.
87358>>>>>    Procedure Set pbToANSI Boolean bState
87360>>>>>        Set private.pbToANSI  to bState
87361>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87362>>>>>        Delegate Set pbToANSI to bState
87364>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87365>>>>>    End_Procedure
87366>>>>>
87366>>>>>    Function pbToANSI Returns Boolean
87368>>>>>        Function_Return (private.pbToAnsi(Self))
87369>>>>>    End_Function
87370>>>>>
87370>>>>>    Procedure Set pbRecnum Boolean bState
87372>>>>>        Set private.pbRecnum  to bState
87373>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87374>>>>>        Delegate Set pbRecnum to bState
87376>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87377>>>>>    End_Procedure
87378>>>>>
87378>>>>>    Function pbRecnum Returns Boolean
87380>>>>>        Function_Return (private.pbRecnum(Self))
87381>>>>>    End_Function
87382>>>>>
87382>>>>>    Procedure Set pbCopyData Boolean bState
87384>>>>>        Set private.pbCopyData  to bState
87385>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87386>>>>>        Delegate Set pbCopyData to bState
87388>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87389>>>>>    End_Procedure
87390>>>>>
87390>>>>>    Function pbCopyData Returns Boolean
87392>>>>>        Function_Return (private.pbCopyData(Self))
87393>>>>>    End_Function
87394>>>>>
87394>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
87394>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
87396>>>>>        Set private.pbApiTableUpdateAuto  to bState
87397>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87398>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
87399>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87400>>>>>    End_Procedure
87401>>>>>
87401>>>>>    Function pbApiTableUpdateAuto Returns Boolean
87403>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
87404>>>>>    End_Function
87405>>>>>
87405>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
87407>>>>>        Set private.pbCompareDate_DateTime  to bState
87408>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87409>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
87410>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87411>>>>>    End_Procedure
87412>>>>>
87412>>>>>    Function pbCompareDate_DateTime Returns Boolean
87414>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
87415>>>>>    End_Function
87416>>>>>
87416>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
87418>>>>>        Set private.pbCompareIndexAscending  to bState
87419>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87420>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
87421>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87422>>>>>    End_Procedure
87423>>>>>
87423>>>>>    Function pbCompareIndexAscending Returns Boolean
87425>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
87426>>>>>    End_Function
87427>>>>>
87427>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
87429>>>>>        Set private.pbCompareIndexUppercase  to bState
87430>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87431>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
87432>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87433>>>>>    End_Procedure
87434>>>>>
87434>>>>>    Function pbCompareIndexUppercase Returns Boolean
87436>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
87437>>>>>    End_Function
87438>>>>>
87438>>>>>    Procedure Set psSchema String sValue
87440>>>>>        Set private.psSchema  to sValue
87441>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87442>>>>>        Delegate Set psSchema to sValue
87444>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87445>>>>>    End_Procedure
87446>>>>>
87446>>>>>    // First retrieve the private value that might have been set in the object.
87446>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
87446>>>>>    // it might have been specified in the SQLConnections.ini file.
87446>>>>>    Function psSchema Returns String
87448>>>>>        String sValue
87448>>>>>        Get private.psSchema to sValue
87449>>>>>        If (sValue = "") Begin
87451>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
87452>>>>>        End
87452>>>>>>
87452>>>>>        Function_Return sValue
87453>>>>>    End_Function
87454>>>>>
87454>>>>>    Procedure Set psBaseTableSpace String sValue
87456>>>>>        Set private.psBaseTableSpace  to sValue
87457>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87458>>>>>        Delegate Set psBaseTableSpace to sValue
87460>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87461>>>>>    End_Procedure
87462>>>>>
87462>>>>>    // First retrieve the private value that might have been set in the object.
87462>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
87462>>>>>    // it might have been specified in the SQLConnections.ini file.
87462>>>>>    Function psBaseTableSpace Returns String
87464>>>>>        String sValue
87464>>>>>        Get private.psBaseTableSpace to sValue
87465>>>>>        If (sValue = "") Begin
87467>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
87468>>>>>        End
87468>>>>>>
87468>>>>>        Function_Return sValue
87469>>>>>    End_Function
87470>>>>>
87470>>>>>    Procedure Set psLongTableSpace String sValue
87472>>>>>        Set private.psLongTableSpace  to sValue
87473>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87474>>>>>        Delegate Set psLongTableSpace to sValue
87476>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87477>>>>>    End_Procedure
87478>>>>>
87478>>>>>    // First retrieve the private value that might have been set in the object.
87478>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
87478>>>>>    // it might have been specified in the SQLConnections.ini file.
87478>>>>>    Function psLongTableSpace Returns String
87480>>>>>        String sValue
87480>>>>>        Get private.psLongTableSpace to sValue
87481>>>>>        If (sValue = "") Begin
87483>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
87484>>>>>        End
87484>>>>>>
87484>>>>>        Function_Return sValue
87485>>>>>    End_Function
87486>>>>>
87486>>>>>    Procedure Set psIndexTableSpace String sValue
87488>>>>>        Set private.psIndexTableSpace  to sValue
87489>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87490>>>>>        Delegate Set psIndexTableSpace to sValue
87492>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87493>>>>>    End_Procedure
87494>>>>>
87494>>>>>    // First retrieve the private value that might have been set in the object.
87494>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
87494>>>>>    // it might have been specified in the SQLConnections.ini file.
87494>>>>>    Function psIndexTableSpace Returns String
87496>>>>>        String sValue
87496>>>>>        Get private.psIndexTableSpace to sValue
87497>>>>>        If (sValue = "") Begin
87499>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
87500>>>>>        End
87500>>>>>>
87500>>>>>        Function_Return sValue
87501>>>>>    End_Function
87502>>>>>
87502>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
87504>>>>>        Set private.psDriverDefaultValueASCII  to sValue
87505>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87506>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
87508>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87509>>>>>    End_Procedure
87510>>>>>
87510>>>>>    // First retrieve the private value that might have been set in the object.
87510>>>>>    // If blank; get it from the parent object
87510>>>>>    Function psDriverDefaultValueASCII Returns String
87512>>>>>        String sValue
87512>>>>>        Get private.psDriverDefaultValueASCII to sValue
87513>>>>>        If (sValue = "") Begin
87515>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
87517>>>>>        End
87517>>>>>>
87517>>>>>        Function_Return sValue
87518>>>>>    End_Function
87519>>>>>
87519>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
87521>>>>>        Set private.psDriverDefaultValueBinary  to sValue
87522>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87523>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
87525>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87526>>>>>    End_Procedure
87527>>>>>
87527>>>>>    // First retrieve the private value that might have been set in the object.
87527>>>>>    // If blank; get it from the parent object
87527>>>>>    Function psDriverDefaultValueBinary Returns String
87529>>>>>        String sValue
87529>>>>>        Get private.psDriverDefaultValueBinary to sValue
87530>>>>>        If (sValue = "") Begin
87532>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
87534>>>>>        End
87534>>>>>>
87534>>>>>        Function_Return sValue
87535>>>>>    End_Function
87536>>>>>
87536>>>>>    Procedure Set psDriverDefaultValueDate String sValue
87538>>>>>        Set private.psDriverDefaultValueDate  to sValue
87539>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87540>>>>>        Delegate Set psDriverDefaultValueDate to sValue
87542>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87543>>>>>    End_Procedure
87544>>>>>
87544>>>>>    // First retrieve the private value that might have been set in the object.
87544>>>>>    // If blank; get it from the parent object
87544>>>>>    Function psDriverDefaultValueDate Returns String
87546>>>>>        String sValue
87546>>>>>        Get private.psDriverDefaultValueDate to sValue
87547>>>>>        If (sValue = "") Begin
87549>>>>>            Delegate Get psDriverDefaultValueDate to sValue
87551>>>>>        End
87551>>>>>>
87551>>>>>        Function_Return sValue
87552>>>>>    End_Function
87553>>>>>
87553>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
87555>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
87556>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87557>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
87559>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87560>>>>>    End_Procedure
87561>>>>>
87561>>>>>    // First retrieve the private value that might have been set in the object.
87561>>>>>    // If blank; get it from the parent object
87561>>>>>    Function psDriverDefaultValueDateTime Returns String
87563>>>>>        String sValue
87563>>>>>        Get private.psDriverDefaultValueDateTime to sValue
87564>>>>>        If (sValue = "") Begin
87566>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
87568>>>>>        End
87568>>>>>>
87568>>>>>        Function_Return sValue
87569>>>>>    End_Function
87570>>>>>
87570>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
87572>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
87573>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87574>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
87576>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87577>>>>>    End_Procedure
87578>>>>>
87578>>>>>    // First retrieve the private value that might have been set in the object.
87578>>>>>    // If blank; get it from the parent object
87578>>>>>    Function psDriverDefaultValueNumeric Returns String
87580>>>>>        String sValue
87580>>>>>        Get private.psDriverDefaultValueNumeric to sValue
87581>>>>>        If (sValue = "") Begin
87583>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
87585>>>>>        End
87585>>>>>>
87585>>>>>        Function_Return sValue
87586>>>>>    End_Function
87587>>>>>
87587>>>>>    Procedure Set psDriverDefaultValueText String sValue
87589>>>>>        Set private.psDriverDefaultValueText  to sValue
87590>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87591>>>>>        Delegate Set psDriverDefaultValueText to sValue
87593>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87594>>>>>    End_Procedure
87595>>>>>
87595>>>>>    // First retrieve the private value that might have been set in the object.
87595>>>>>    // If blank; get it from the parent object
87595>>>>>    Function psDriverDefaultValueText Returns String
87597>>>>>        String sValue
87597>>>>>        Get private.psDriverDefaultValueText to sValue
87598>>>>>        If (sValue = "") Begin
87600>>>>>            Delegate Get psDriverDefaultValueText to sValue
87602>>>>>        End
87602>>>>>>
87602>>>>>        Function_Return sValue
87603>>>>>    End_Function
87604>>>>>
87604>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
87606>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
87607>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87608>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
87610>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87611>>>>>    End_Procedure
87612>>>>>
87612>>>>>    // First retrieve the private value that might have been set in the object.
87612>>>>>    // If blank; get it from the parent object
87612>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
87614>>>>>        Boolean bState
87614>>>>>        Get private.pbDriverDefaultNullableASCII to bState
87615>>>>>        If (bState = False) Begin
87617>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
87619>>>>>        End
87619>>>>>>
87619>>>>>        Function_Return bState
87620>>>>>    End_Function
87621>>>>>
87621>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
87623>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
87624>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87625>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
87627>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87628>>>>>    End_Procedure
87629>>>>>
87629>>>>>    // First retrieve the private value that might have been set in the object.
87629>>>>>    // If blank; get it from the parent object
87629>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
87631>>>>>        Boolean bState
87631>>>>>        Get private.pbDriverDefaultNullableBinary to bState
87632>>>>>        If (bState = False) Begin
87634>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
87636>>>>>        End
87636>>>>>>
87636>>>>>        Function_Return bState
87637>>>>>    End_Function
87638>>>>>
87638>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
87640>>>>>        Set private.pbDriverDefaultNullableDate  to bState
87641>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87642>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
87644>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87645>>>>>    End_Procedure
87646>>>>>
87646>>>>>    // First retrieve the private value that might have been set in the object.
87646>>>>>    // If blank; get it from the parent object
87646>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
87648>>>>>        Boolean bState
87648>>>>>        Get private.pbDriverDefaultNullableDate to bState
87649>>>>>        If (bState = False) Begin
87651>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
87653>>>>>        End
87653>>>>>>
87653>>>>>        Function_Return bState
87654>>>>>    End_Function
87655>>>>>
87655>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
87657>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
87658>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87659>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
87661>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87662>>>>>    End_Procedure
87663>>>>>
87663>>>>>    // First retrieve the private value that might have been set in the object.
87663>>>>>    // If blank; get it from the parent object
87663>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
87665>>>>>        Boolean bState
87665>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
87666>>>>>        If (bState = False) Begin
87668>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
87670>>>>>        End
87670>>>>>>
87670>>>>>        Function_Return bState
87671>>>>>    End_Function
87672>>>>>
87672>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
87674>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
87675>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87676>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
87678>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87679>>>>>    End_Procedure
87680>>>>>
87680>>>>>    // First retrieve the private value that might have been set in the object.
87680>>>>>    // If blank; get it from the parent object
87680>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
87682>>>>>        Boolean bState
87682>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
87683>>>>>        If (bState = False) Begin
87685>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
87687>>>>>        End
87687>>>>>>
87687>>>>>        Function_Return bState
87688>>>>>    End_Function
87689>>>>>
87689>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
87691>>>>>        Set private.pbDriverDefaultNullableText  to bState
87692>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87693>>>>>        Delegate Set pbDriverDefaultNullableText to bState
87695>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87696>>>>>    End_Procedure
87697>>>>>
87697>>>>>    // First retrieve the private value that might have been set in the object.
87697>>>>>    // If blank; get it from the parent object
87697>>>>>    Function pbDriverDefaultNullableText Returns Boolean
87699>>>>>        Boolean bState
87699>>>>>        Get private.pbDriverDefaultNullableText to bState
87700>>>>>        If (bState = False) Begin
87702>>>>>            Delegate Get pbDriverDefaultNullableText to bState
87704>>>>>        End
87704>>>>>>
87704>>>>>        Function_Return bState
87705>>>>>    End_Function
87706>>>>>
87706>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
87708>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
87708>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
87708>>>>>
87708>>>>>        Get psDriverID to sDriverID
87709>>>>>        Get psSchema to sSchema
87710>>>>>
87710>>>>>        Get psBaseTableSpace to sBaseTableSpace
87711>>>>>        If (sBaseTableSpace <> "") Begin
87713>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87714>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
87716>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87717>>>>>        End
87717>>>>>>
87717>>>>>
87717>>>>>        Get psLongTableSpace to sLongTableSpace
87718>>>>>        If (sLongTableSpace <> "") Begin
87720>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87721>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
87723>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87724>>>>>        End
87724>>>>>>
87724>>>>>
87724>>>>>        Get psIndexTableSpace to sIndexTableSpace
87725>>>>>        If (sIndexTableSpace <> "") Begin
87727>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
87728>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
87730>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
87731>>>>>        End
87731>>>>>>
87731>>>>>
87731>>>>>        Get pbUseConnectionID to bUseConnectionID
87732>>>>>        Get pbToANSI          to bToANSI
87733>>>>>        Get pbRecnum          to bRecnum
87734>>>>>        Get pbCopyData        to bCopyData
87735>>>>>
87735>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
87736>>>>>
87736>>>>>        Function_Return bOK
87737>>>>>    End_Function
87738>>>>>
87738>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
87738>>>>>//        Boolean bOK bExists
87738>>>>>//        String sDataPath sBackupFolder
87738>>>>>//        
87738>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
87738>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
87738>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
87738>>>>>//        Get vFolderFormat sDataPath to sDataPath
87738>>>>>//        
87738>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
87738>>>>>//        If (bExists = False) Begin
87738>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
87738>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
87738>>>>>//            If (bExists = False) Begin
87738>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
87738>>>>>//                Function_Return False
87738>>>>>//            End                                                                                                                                            
87738>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
87738>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
87738>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
87738>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
87738>>>>>//        End
87738>>>>>//        
87738>>>>>//        Set Message_Text of ghoStatusPanel to ""
87738>>>>>//        Function_Return bOK
87738>>>>>//    End_Function
87738>>>>>//
87738>>>>>    // This is automatically called after the OnUpdate
87738>>>>>    // event has been executed. It will automatically update the
87738>>>>>    // version database field/column with the "pnVersionNumber"
87738>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
87738>>>>>    Procedure UpdateVersionColumnValue
87740>>>>>        Number nVersion nCurrentValue
87740>>>>>        Integer hTable iColumn
87740>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
87740>>>>>
87740>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
87740>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
87740>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
87742>>>>>        Get pbVersionUpdate to bVersionUpdate
87743>>>>>
87743>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
87745>>>>>            Get pnVersionNumber to nVersion
87746>>>>>            Delegate Get piDbVersionFileNumber  to hTable
87748>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
87750>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
87750>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
87750>>>>>            Close DF_ALL DF_PERMANENT
87751>>>>>
87751>>>>>            Open hTable
87753>>>>>
87753>>>>>            // It is then the developer responsibility to take care of finding
87753>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
87753>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
87755>>>>>            If (bUseCustomDbVersion = True) Begin
87757>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
87759>>>>>            End
87759>>>>>>
87759>>>>>
87759>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
87762>>>>>            If (nCurrentValue < nVersion) Begin
87764>>>>>                Lock
87765>>>>>>
87765>>>>>                    If (bUseCustomDbVersion = False) Begin
87767>>>>>                        Vfind hTable Recnum GE                            
87769>>>>>                    End
87769>>>>>>
87769>>>>>                    Set_Field_Value hTable iColumn to nVersion
87772>>>>>                    SaveRecord hTable
87773>>>>>                Unlock
87774>>>>>>
87774>>>>>            End
87774>>>>>>
87774>>>>>            Close hTable
87775>>>>>        End
87775>>>>>>
87775>>>>>    End_Procedure
87776>>>>>
87776>>>>>// Property of the container object (cDbUpdateHandler)
87776>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
87776>>>>>
87776>>>>>    Procedure End_Construct_Object
87778>>>>>        Forward Send End_Construct_Object
87780>>>>>        Send ProcessUpdate True
87781>>>>>    End_Procedure
87782>>>>>    
87782>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
87784>>>>>        Number nVersion nCurrentValue
87784>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
87784>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
87784>>>>>        String sObjectName
87784>>>>>        tDbVersionInfo[] dbVersionInfoArray
87784>>>>>        tDbVersionInfo[] dbVersionInfoArray
87785>>>>>
87785>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
87787>>>>>
87787>>>>>        // If the programmer forgot to set the version number we do not allow for the application
87787>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
87787>>>>>        // one database update is depended on an earlier update and that earlier version
87787>>>>>        // update was never executed it could lead to disastrous results.
87787>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
87787>>>>>        Get pnVersionNumber to nVersion
87788>>>>>        If (nVersion = 0) Begin
87790>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
87791>>>>>            Move (Name(Self)) to sObjectName
87792>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
87793>>>>>>
87793>>>>>            Send Exit_Application
87794>>>>>        End
87794>>>>>>
87794>>>>>
87794>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
87794>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
87794>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
87796>>>>>        If (bOnPreUpdateExecuted = False) Begin
87798>>>>>            Delegate Send OnPreUpdate
87800>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
87802>>>>>        End
87802>>>>>>
87802>>>>>        
87802>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
87804>>>>>        
87804>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
87806>>>>>        If (bUseCustomDbVersion = False) Begin
87808>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
87808>>>>>        End
87808>>>>>>
87808>>>>>        Else Begin
87809>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
87810>>>>>            If (bTableExists = False) Begin
87812>>>>>                Delegate Send OnCreateCustomDbVersionTable
87814>>>>>            End
87814>>>>>>
87814>>>>>        End
87814>>>>>>
87814>>>>>        
87814>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
87814>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
87814>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
87816>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
87818>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
87819>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
87820>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
87821>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
87823>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
87825>>>>>        End
87825>>>>>>
87825>>>>>
87825>>>>>        Delegate Get piDbVersionFileNumber  to hTable
87827>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
87829>>>>>
87829>>>>>        Open hTable
87831>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87834>>>>>        If (bOpened = False) Begin
87836>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
87837>>>>>            Send Exit_Application
87838>>>>>        End
87838>>>>>>
87838>>>>>        
87838>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
87838>>>>>        // in case we take care of it here.
87838>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
87841>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
87843>>>>>            Vfind hTable 0 GT
87845>>>>>        End
87845>>>>>>
87845>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
87848>>>>>        If (bSystemTable = True) Begin
87850>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
87853>>>>>        End
87853>>>>>>
87853>>>>>        Else Begin
87854>>>>>            If (bUseCustomDbVersion = True) Begin
87856>>>>>                Send OnFindVersionRecord
87857>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
87860>>>>>            End
87860>>>>>>
87860>>>>>        End
87860>>>>>>
87860>>>>>
87860>>>>>        Close hTable
87861>>>>>
87861>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
87861>>>>>        // If not set we do nothing.
87861>>>>>        If (nCurrentValue < nVersion) Begin
87863>>>>>
87863>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
87863>>>>>            // execution of database update code. So if true _and_ one error
87863>>>>>            // has already occured; we're out of here.
87863>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
87865>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
87867>>>>>            If (bStopOnFirstError = True) Begin
87869>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
87871>>>>>                    Procedure_Return
87872>>>>>                End
87872>>>>>>
87872>>>>>            End
87872>>>>>>
87872>>>>>
87872>>>>>            // This is send to the parent container object (cDbUpdateHandler)
87872>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
87874>>>>>
87874>>>>>            // If the parent property pbContinueOnError = False, an update
87874>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
87874>>>>>            Delegate Get pbContinueOnError to bContinueOnError
87876>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
87878>>>>>                Procedure_Return
87879>>>>>            End
87879>>>>>>
87879>>>>>
87879>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
87881>>>>>
87881>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
87882>>>>>
87882>>>>>            // *** Programmer's main hook event for database update functions:
87882>>>>>            Send OnUpdate
87883>>>>>
87883>>>>>            Set pbVersionUpdate to True
87884>>>>>            Send UpdateVersionColumnValue
87885>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
87887>>>>>        End
87887>>>>>>
87887>>>>>
87887>>>>>    End_Procedure
87888>>>>>
87888>>>>>End_Class
87889>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
87889>>>>>//****************************************************************************
87889>>>>>// $Module type: Class
87889>>>>>// $Module name: cDbUpdateUserCount.pkg
87889>>>>>// $Author     : Emil Stojanov Quantaris B.V.
87889>>>>>//
87889>>>>>//               Collected from DAW's newsgroups.
87889>>>>>//
87889>>>>>// Description : It uses the windows API to lock bytes in a file.
87889>>>>>//               If the application or PC craches it will release the lock
87889>>>>>//               automatically.
87889>>>>>//
87889>>>>>// Note 1      : It will count the number of running app's, so if a
87889>>>>>//               user starts the app twice on one machine it will count as two users.
87889>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
87889>>>>>//               However, to not conflict with any other usage of this class it was
87889>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
87889>>>>>//               and cDbUpdateVersion classes)
87889>>>>>//
87889>>>>>// $Rev History:
87889>>>>>//    2008-10-17  Module header created (Militaty data format)
87889>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
87889>>>>>//                for easy translation to other languages.
87889>>>>>//                Added the tUserCount struct for easier passing of parameters.
87889>>>>>//                Added the ApplicationPath message.
87889>>>>>//****************************************************************************
87889>>>>>Use LanguageText.pkg
87889>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
87889>>>>>>>Use GlobalFunctionsProcedures.pkg
87889>>>>>>>// Sample:
87889>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
87889>>>>>>>
87889>>>>>>>
87889>>>>>>>// Symbols used by UserCounting
87889>>>>>>>    Define GENERIC_READ         for |CI$80000000
87889>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
87889>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
87889>>>>>>>    Define GENERIC_ALL          for |CI$10000000
87889>>>>>>>    Define CREATE_NEW           for 1
87889>>>>>>>    Define CREATE_ALWAYS        for 2
87889>>>>>>>    Define OPEN_EXISTING        for 3
87889>>>>>>>    Define OPEN_ALWAYS          for 4
87889>>>>>>>    Define TRUNCATE_EXISTING    for 5
87889>>>>>>>    Define FILE_BEGIN           for 0
87889>>>>>>>    Define FILE_CURRENT         for 1
87889>>>>>>>    Define FILE_END             for 2
87889>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
87889>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
87889>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
87889>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
87889>>>>>>>    Define _MAX_PATH  for 260
87889>>>>>>>    Define _MAX_DRIVE for 3
87889>>>>>>>    Define _MAX_DIR   for 256
87889>>>>>>>    Define _MAX_FNAME for 256
87889>>>>>>>    Define _MAX_EXT   for 256
87889>>>>>>>
87889>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
87890>>>>>>>
87890>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
87891>>>>>>>
87891>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
87892>>>>>>>
87892>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
87893>>>>>>>
87893>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
87894>>>>>>>
87894>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
87895>>>>>>>
87895>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
87896>>>>>>>
87896>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
87897>>>>>>>// Sample:
87897>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
87897>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
87899>>>>>>>    Boolean bReturn
87899>>>>>>>    Move (ToANSI(sPrinter)) to sPrinter
87900>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
87901>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
87902>>>>>>>    Function_Return bReturn
87903>>>>>>>End_Function
87904>>>>>Use vWin32fh.pkg
87904>>>>>Use seq_chnl.pkg
87904>>>>>
87904>>>>>// User interface constant strings:
87904>>>>>    Define CS_UserCountError            for "User count error:"
87904>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
87904>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
87904>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
87904>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>
87904>>>>>    Struct tUserCount
87904>>>>>        Integer iUserCount
87904>>>>>        Integer iError
87904>>>>>        String  sErrorTxt
87904>>>>>    End_Struct
87904>>>>>
87904>>>>>    Define CI_UserCountMaxUsers for 9999
87904>>>>>
87904>>>>>Class cDbUpdateUserCount is a cObject
87905>>>>>    Procedure Construct_Object
87907>>>>>        Forward Send Construct_Object
87909>>>>>
87909>>>>>        Property String  psLockFileName
87910>>>>>        Property Integer piMaxUsers
87911>>>>>        Property Boolean pbCheckDataFlexUserCount True
87912>>>>>
87912>>>>>        Property Handle  phUserCountFile
87913>>>>>        Property Integer pdwLockPosition
87914>>>>>    End_Procedure
87915>>>>>
87915>>>>>    Function IsProgramRunning Returns Boolean
87917>>>>>        tUserCount UserCount
87917>>>>>        tUserCount UserCount
87917>>>>>
87917>>>>>        Get CheckUserCount to UserCount
87918>>>>>
87918>>>>>        Function_Return (UserCount.iUserCount > 1)
87919>>>>>    End_Function
87920>>>>>
87920>>>>>    // Returns the full path of the Application (no trailing "\")
87920>>>>>    Function ApplicationPath Returns String
87922>>>>>        String sApplicationFileName sPath
87922>>>>>        Integer iNumChars iRetval
87922>>>>>
87922>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
87923>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
87924>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
87925>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
87926>>>>>        Move (CString(sApplicationFileName)) to sPath
87927>>>>>
87927>>>>>        Function_Return sPath
87928>>>>>    End_Function
87929>>>>>
87929>>>>>    Function OpenUserCountFile String sFileName Returns Handle
87931>>>>>        Handle  hFile
87931>>>>>        Pointer pFileName
87931>>>>>        String sPath sFile
87931>>>>>        Integer iCh
87931>>>>>
87931>>>>>        Move (Addressof(sFileName)) to pFileName
87932>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
87933>>>>>
87933>>>>>        // If lock file doesn't exist, create it.
87933>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
87935>>>>>            Get ApplicationPath to sPath
87936>>>>>            Get vFolderFormat sPath to sPath
87937>>>>>            Move (sPath + psLockFileName(Self)) to sFile
87938>>>>>            Get Seq_Open_Output_Channel sFile to iCh
87939>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
87941>>>>>                Function_Return 0
87942>>>>>            End
87942>>>>>>
87942>>>>>            Direct_Output channel iCh sFile
87944>>>>>                Write channel iCh ""
87946>>>>>            Send Seq_Close_Channel iCh
87947>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
87948>>>>>        End
87948>>>>>>
87948>>>>>
87948>>>>>        Function_Return hFile
87949>>>>>    End_Function
87950>>>>>
87950>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
87952>>>>>        Integer iReturnValue 
87952>>>>>        Boolean bOK
87952>>>>>
87952>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
87953>>>>>        If (iReturnValue = 0) Begin
87955>>>>>            Move False to bOK
87956>>>>>        End
87956>>>>>>
87956>>>>>        Else Begin
87957>>>>>            Move True to bOK
87958>>>>>        End
87958>>>>>>
87958>>>>>        Function_Return bOK
87959>>>>>    End_Function
87960>>>>>
87960>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
87962>>>>>        Integer iReturnValue
87962>>>>>        Boolean bOK
87962>>>>>
87962>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
87963>>>>>        If (iReturnValue = 0) Begin
87965>>>>>            Move False to bOK
87966>>>>>        End
87966>>>>>>
87966>>>>>        Else Begin
87967>>>>>            Move True to bOK
87968>>>>>        End           
87968>>>>>>
87968>>>>>        Function_Return bOK
87969>>>>>    End_Function
87970>>>>>
87970>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
87972>>>>>        dWord dwCurrPos
87972>>>>>
87972>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
87973>>>>>        Function_Return dwCurrPos
87974>>>>>    End_Function
87975>>>>>
87975>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
87977>>>>>        DWord dwCurrPos
87977>>>>>
87977>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
87978>>>>>        Function_Return dwCurrPos
87979>>>>>    End_Function
87980>>>>>
87980>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
87982>>>>>        Integer iReturnValue                               
87982>>>>>        Boolean bOK
87982>>>>>        String  sBuffer
87982>>>>>        Pointer pBuffer
87982>>>>>        String  sSize
87982>>>>>        Pointer pSize
87982>>>>>
87982>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
87983>>>>>        Move (AddressOf(sBuffer)) to pBuffer
87984>>>>>
87984>>>>>        Move (Repeat((Character(0)),4)) to sSize
87985>>>>>        Move (AddressOf(sSize)) to pSize
87986>>>>>
87986>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
87987>>>>>        If (iReturnValue = 0) Begin
87989>>>>>            Move False to bOK
87990>>>>>        End
87990>>>>>>
87990>>>>>        Else Begin
87991>>>>>            Move True to bOK
87992>>>>>        End                 
87992>>>>>>
87992>>>>>        Function_Return bOK
87993>>>>>    End_Function
87994>>>>>
87994>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
87996>>>>>        Integer iReturnValue
87996>>>>>
87996>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
87997>>>>>        Function_Return iReturnValue
87998>>>>>    End_Function
87999>>>>>
87999>>>>>    Procedure DoCheckUserCount
88001>>>>>        tUserCount UserCount
88001>>>>>        tUserCount UserCount
88001>>>>>
88001>>>>>        Get CheckUserCount to UserCount
88002>>>>>        // If all is fine, we're done.
88002>>>>>        If (UserCount.iError = 0) Begin
88004>>>>>            Procedure_Return
88005>>>>>        End
88005>>>>>>
88005>>>>>
88005>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
88006>>>>>
88006>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
88008>>>>>            Abort
88009>>>>>>
88009>>>>>        End
88009>>>>>>
88009>>>>>    End_Procedure
88010>>>>>
88010>>>>>    Function CheckUserCount Returns tUserCount
88012>>>>>        Handle  hFile
88012>>>>>        String  sPath sFile
88012>>>>>        Integer iResult
88012>>>>>        DWord   dwFilePos
88012>>>>>        Integer bLocked
88012>>>>>        Integer iMaxUsers
88012>>>>>        Integer iCurUser
88012>>>>>        tUserCount UserCount
88012>>>>>        tUserCount UserCount
88012>>>>>
88012>>>>>        Move 0 to UserCount.iError
88013>>>>>
88013>>>>>        Get phUserCountFile to hFile
88014>>>>>        If (not(hFile)) Begin
88016>>>>>            Get ApplicationPath to sPath
88017>>>>>            Get vFolderFormat sPath to sPath
88018>>>>>            Move (sPath + psLockFileName(Self)) to sFile
88019>>>>>            Get OpenUserCountFile sFile to hFile
88020>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
88022>>>>>                Move 1 to UserCount.iUserCount
88023>>>>>                Move 1 to UserCount.iError
88024>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
88025>>>>>                Function_Return UserCount
88026>>>>>            End
88026>>>>>>
88026>>>>>            Else Begin
88027>>>>>                Move False to bLocked
88028>>>>>                Set phUserCountFile to hFile
88029>>>>>                Get piMaxUsers to iMaxUsers
88030>>>>>
88030>>>>>                // Set Filepointer to beginning of the file
88030>>>>>                Get ResetUserCountPointer hFile to dwFilePos
88031>>>>>                If (dwFilePos = -1) Begin
88033>>>>>                    Move 1 to UserCount.iUserCount
88034>>>>>                    Move 2 to UserCount.iError
88035>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
88036>>>>>                    Function_Return UserCount
88037>>>>>                End
88037>>>>>>
88037>>>>>                For iCurUser from 1 to iMaxUsers
88043>>>>>>
88043>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
88044>>>>>                    If (not(iResult)) Begin  // byte is locked
88046>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
88047>>>>>                        If (dwFilePos = -1) Begin
88049>>>>>                            Move 1 to UserCount.iUserCount
88050>>>>>                            Move 3 to UserCount.iError
88051>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
88052>>>>>                            Function_Return UserCount
88053>>>>>                        End
88053>>>>>>
88053>>>>>                    End
88053>>>>>>
88053>>>>>                    Else Begin  // byte is not locked
88054>>>>>                        Set pdwLockPosition to dwFilePos
88055>>>>>                        Move True to bLocked
88056>>>>>                        Move iMaxUsers to iCurUser
88057>>>>>                    End
88057>>>>>>
88057>>>>>                Loop
88058>>>>>>
88058>>>>>                If (not(bLocked)) Begin
88060>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
88061>>>>>                    Move 4 to UserCount.iError
88062>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
88063>>>>>                    Function_Return UserCount
88064>>>>>                End
88064>>>>>>
88064>>>>>            End
88064>>>>>>
88064>>>>>        End
88064>>>>>>
88064>>>>>
88064>>>>>        Function_Return UserCount
88065>>>>>    End_Function
88066>>>>>
88066>>>>>
88066>>>>>    Procedure DoReleaseUserCount
88068>>>>>        Integer iResult
88068>>>>>        Handle  hFile
88068>>>>>        DWord   dwLockPos
88068>>>>>
88068>>>>>        Get phUserCountFile to hFile
88069>>>>>        Get pdwLockPosition to dwLockPos
88070>>>>>        If (hFile) Begin
88072>>>>>            If (dwLockPos) Begin
88074>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
88075>>>>>            End
88075>>>>>>
88075>>>>>            Get CloseUserCountFile hFile to iResult
88076>>>>>        End
88076>>>>>>
88076>>>>>    End_Procedure
88077>>>>>
88077>>>>>    Function CurrentNumberOfUsers Returns Integer
88079>>>>>        Handle  hFile
88079>>>>>        Integer iMaxUsers
88079>>>>>        DWord   dwFilePos
88079>>>>>        Integer iCurUser
88079>>>>>        Integer iResult
88079>>>>>        Integer iNumberOfLocks
88079>>>>>        String  sPath sFile
88079>>>>>
88079>>>>>        Move 0 to iNumberOfLocks
88080>>>>>
88080>>>>>        Get ApplicationPath to sPath
88081>>>>>        Get vFolderFormat sPath to sPath
88082>>>>>        Move (sPath + psLockFileName(Self)) to sFile
88083>>>>>        Get OpenUserCountFile sFile to hFile
88084>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
88086>>>>>            Send UserError CS_UnableToInitUserCountSys
88087>>>>>            Abort
88088>>>>>>
88088>>>>>        End
88088>>>>>>
88088>>>>>
88088>>>>>        If (hFile > 0) Begin
88090>>>>>            Get piMaxUsers To iMaxUsers
88091>>>>>
88091>>>>>            // Set Filepointer to beginning of the file
88091>>>>>            Get ResetUserCountPointer hFile to dwFilePos
88092>>>>>            If (dwFilePos = -1) Begin
88094>>>>>                Send UserError CS_UnableResetUserCountSys
88095>>>>>                Abort
88096>>>>>>
88096>>>>>            End
88096>>>>>>
88096>>>>>            For iCurUser from 1 to iMaxUsers
88102>>>>>>
88102>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
88103>>>>>                If (Not(iResult)) Begin  // byte is locked
88105>>>>>                    Increment iNumberOfLocks
88106>>>>>                End
88106>>>>>>
88106>>>>>                Else Begin  // byte is not locked
88107>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
88108>>>>>                End
88108>>>>>>
88108>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
88109>>>>>                If (dwFilePos = -1) Begin
88111>>>>>                    Send UserError CS_ErrorAdvancingPointer
88112>>>>>                    Abort
88113>>>>>>
88113>>>>>                End
88113>>>>>>
88113>>>>>            Loop
88114>>>>>>
88114>>>>>        End
88114>>>>>>
88114>>>>>        Get CloseUserCountFile hFile to iResult
88115>>>>>        Function_Return iNumberOfLocks
88116>>>>>    End_Function
88117>>>>>
88117>>>>>End_Class
88118>>>Use cDbUpdateFunctionLibrary.pkg
88118>>>
88118>>>//{ DataBindable=True }
88118>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
88118>>>Class cDbUpdateHandler is a cObject
88119>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
88120>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
88121>>>
88121>>>    Procedure Construct_Object
88123>>>        tUserCount UserCount
88123>>>        tUserCount UserCount
88123>>>        Integer iUserCount
88123>>>        Handle ho                     
88123>>>
88123>>>        Forward Send Construct_Object
88125>>>        Move Self to ghoDbUpdateHandler  
88126>>>        
88126>>>        // Latin1_General_CI_AS = General Insensitive collation
88126>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
88126>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
88126>>>        // Good read about which collation to select:
88126>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
88126>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
88127>>>
88127>>>        // Struct array that will contain pnVersionNumbers & object id's of
88127>>>        // all child cDbVersion objects.
88127>>>        Property tDbVersionInfo[] paDbVersionInfoArray
88128>>>
88128>>>        Property Integer Error_Processing_State False  // internal use
88129>>>        
88129>>>        Property Boolean Private.pbDbVersionCheckDone False
88130>>>
88130>>>        Property Boolean pbUseCustomDbVersion False  
88131>>>        
88131>>>        // If this property = True _and_ no DbVersion table exists 
88131>>>        // when the framework is started, a DbVersion table will be created automatically.
88131>>>        Property Boolean pbAutoCreateDbVersionTable True
88132>>>
88132>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
88132>>>        // the Filelist.cfg slot number indicated by this property will be used
88132>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
88132>>>        // an Unhandled Exception Error will be genereted and the program halted. So
88132>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
88132>>>        // to a value that corresponds to a free Filelist.cfg slot number.
88132>>>        Property Integer Private.piDbVersionFileNumber -1
88133>>>        Property Integer Private.piDbVersionFieldNumber 1
88134>>>
88134>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
88134>>>        // that creates all library properties
88134>>>        Send CreateDbUpdateLibraryProperties
88135>>>
88135>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
88136>>>
88136>>>        // Error handling:
88136>>>        Property Boolean Private.pbOnCreateExecuted False
88137>>>        Property Boolean Private.pbOnPreUpdateExecuted False
88138>>>        Property Boolean Private.pbProcessingError False
88139>>>        Property Boolean pbDbUpdateErrorHasOccured False
88140>>>        // Don't touch. It is being used by the cDbUpdateVersion
88140>>>        // subclass to tell if that particular update went OK or not.
88140>>>        Property Boolean Private.pbUpdateVersionObjectError False
88141>>>        Property String[] paSQLQueryMessages
88142>>>
88142>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
88143>>>        Move Self to Error_Object_Id
88144>>>        // Error handling:
88144>>>        // Temporarily redirect all errors to this object so we can silently
88144>>>        // log all errors that might appear while updating the database.
88144>>>        // We temporarily redirect all errors to this object so we can
88144>>>        // log and write errors to the log file. It will be reset after
88144>>>        // the database updates have been finished.
88144>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
88145>>>
88145>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
88146>>>
88146>>>        // Error Reporting Related
88146>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
88146>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
88147>>>
88147>>>        // If the pbContinueOnError = False, an update
88147>>>        // of another cDbUpdateVersion object will _not_ be
88147>>>        // performed if an error occured in a previous
88147>>>        // cDbUpdateVersion object.
88147>>>        Property Boolean pbContinueOnError False
88148>>>        // Stops execution in other cDbUpdateVersion objecs,
88148>>>        // if errors occurred in one cDbUpdateVersion object.
88148>>>        Property Boolean pbStopOnFirstError False
88149>>>        // If True errors that occured while updating the database
88149>>>        // will be shown in the default app for .txt files when done.
88149>>>        // Note: The log file will _always_ be created in the Data folder.
88149>>>        Property Boolean pbShowErrorLogPostRun True
88150>>>
88150>>>        // Be _very_ careful to set this property to true!
88150>>>        // If = True, no question will be asked if the update
88150>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
88150>>>        // the error log won't be shown. The logfile itself will still be created though.
88150>>>        // You have to know what you're doing!
88150>>>        Property Boolean pbSilentMode False
88151>>>        
88151>>>        Property Boolean pbEnableCancelButton False
88152>>>
88152>>>        // Don't touch! Very private. The value is used by the error log to write for which
88152>>>        // cDbUpdateVersion object an error occured.
88152>>>        Property Number pnCurrentVersionUpdate 0
88153>>>
88153>>>        // The user counting logic is used to safe-guard agains anybody else is
88153>>>        // using the application when a database update is to be performed.
88153>>>        // (Garters & suspenders!)
88153>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
88154>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
88155>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
88156>>>
88156>>>        // This lock file is used to guard against somebody else tries to start the
88156>>>        // application while updates are in progress.
88156>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
88157>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
88158>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
88159>>>                                                                                      // Only the current user allowed.
88159>>>        // Properties for the table & column of a system file field/column where
88159>>>        // the database version update number gets saved.
88159>>>        Property Integer Private.Data_File  0
88160>>>        Property Integer Private.Data_Field 0
88161>>>
88161>>>        // Property that is used to indicate that we have already
88161>>>        // started the database update.
88161>>>        Property Boolean Private.pbDatabaseUpdateStarted False
88162>>>
88162>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
88162>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
88162>>>        // change of the database has been made.
88162>>>        Property Boolean Private.pbDatabaseWasUpdated False
88163>>>
88163>>>        // We need to trigger the user counting system so that a bit in the
88163>>>        // user counting file is locked. This is to guard that not more than one user
88163>>>        // is currently runnning the program.
88163>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
88164>>>
88164>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
88165>>>        If (iUserCount > 0) Begin
88167>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
88168>>>            Send Exit_Application
88169>>>        End
88169>>>>
88169>>>
88169>>>        Set pbHandleQueryErrors to False
88170>>>            
88170>>>        // This can't be right?    
88170>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
88170>>>//            Move Self to ghoDbUpdateFunctionLibrary
88170>>>//        End
88170>>>
88170>>>        Property Handle phoSQLConnectionHandler 0
88171>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
88171>>>        // we will create one as it is used for all ConnectionID, ConnectionString
88171>>>        // etc information.
88171>>>        If (ghoSQLConnectionHandler = 0) Begin
88173>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
88174>>>            Set phoSQLConnectionHandler to ho
88175>>>        End             
88175>>>>
88175>>>        
88175>>>        Property Boolean pbCheckIntFiles False   
88176>>>        Property Handle  phIntFilesTable 2048
88177>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
88178>>>        
88178>>>        Set Icon to "Default.ico"
88179>>>    End_Procedure
88180>>>
88180>>>    Procedure End_Construct_Object
88182>>>        Boolean bCheckIntFiles
88182>>>        
88182>>>        Forward Send End_Construct_Object
88184>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
88186>>>            Send OnCreate
88187>>>            Set Private.pbOnCreateExecuted to True
88188>>>        End
88188>>>>
88188>>>        Send Cleanup
88189>>>    End_Procedure
88190>>>    
88190>>>    // Programmers hook event.
88190>>>    Procedure OnCreate
88192>>>    End_Procedure        
88193>>>                                 
88193>>>    // *** MAIN .Int file (and Filelist.cfg) Check Integrity Message ***
88193>>>    //                                                
88193>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
88193>>>    // cDbUpdateHandler object.
88193>>>    //
88193>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
88193>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
88193>>>    //
88193>>>    // If not done previously the phIntFilesTable will be created and filled with data
88193>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
88193>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
88193>>>    // of Filelist.cfg is made for backup purposes.
88193>>>    //
88193>>>    // Note: If an error occurrs the application will exit, as it means that at least one
88193>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
88193>>>    Procedure CheckIntFilesIntegrity
88195>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists
88195>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
88195>>>        String sFileListZipFile sParam sProgram sFile 
88195>>>        Integer iDataPaths iCount
88195>>>        Handle hTable hIntFilesTable                    
88195>>>        UChar[] asFileListArray 
88196>>>        String[] asSavedIntFile
88197>>>        tDUFIntFile[] DUFIntFiles
88197>>>        tDUFIntFile[] DUFIntFiles
88198>>>        
88198>>>        Get pbCheckIntFiles to bCheckIntFiles
88199>>>        If (bCheckIntFiles = False) Begin
88201>>>            Procedure_Return
88202>>>        End
88202>>>>
88202>>>        
88202>>>        Move True to bResult        
88203>>>        
88203>>>        // Note: Include_Resource is a compiler directive!
88203>>>        // It will embedd the Filelist.cfg from the developers machine
88203>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
88203>>>        // need to change the next code line.         
88203>>>        //
88203>>>        // This is a pickle (!) with the Filelist.cfg as it is "busy" as it is open in the Studio,
88203>>>        // when we get here and then it seems the compiler can't embedd it!        
88203>>>        // ToDo: Change compiler directives in Project properties (?)
88203>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
88203>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
88203>>>        
88203>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
88204>>>        Get vFilePathExists sFileListName to bExists 
88205>>>        If (bExists = True) Begin
88207>>>            Get ParseFolderName sFileListName to sDataPath    
88208>>>            Get vFolderFormat sDataPath to sDataPath                              
88209>>>            Get ParseFileName sFileListName to sFile
88210>>>            // We need to create a backup copy of Filelist.cfg.
88210>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
88211>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
88212>>>            If (bOK = False) Begin
88214>>>                Move False to bResult
88215>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
88216>>>>
88216>>>            End
88216>>>>
88216>>>        End
88216>>>>
88216>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
88216>>>        Else Begin
88217>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
88218>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
88218>>>            If (bOK = False) Begin   
88220>>>                Move False to bResult
88221>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
88222>>>>
88222>>>            End
88222>>>>
88222>>>        End
88222>>>>
88222>>>        
88222>>>        Get phIntFilesTable to hIntFilesTable
88223>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
88226>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
88227>>>        // This will automatically create the phIntFilesTable if not exists.
88227>>>        // It is used to save data from the current set of .int files.
88227>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
88229>>>            Send AutoCreateIntFilesTable
88230>>>        End                                                       
88230>>>>
88230>>>        
88230>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
88230>>>        // ToDo: Or should this always be attempted? Else the 
88230>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88231>>>        Move (IsDebuggerPresent()) to bDevelop
88232>>>        If (bDevelop = False) Begin
88234>>>            Get vFolderExists sDDSrcPath to bDevelop
88235>>>        End
88235>>>>
88235>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
88236>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
88237>>>        For iCount from 1 to iDataPaths
88243>>>>
88243>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
88244>>>            Get vFolderFormat sDataPath to sDataPath 
88245>>>            Get vFolderExists sDataPath to bExists
88246>>>            If (bExists = True) Begin                  
88248>>>                Move 0 to hTable
88249>>>                Repeat
88249>>>>
88249>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
88252>>>                    If (hTable <> 0) Begin
88254>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
88257>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
88258>>>                        If (bIsSQL = True) Begin
88260>>>                            Get _TableNoPrefix sIntFileName to sIntFileName
88261>>>                            Move (sIntFileName + ".int")    to sIntFileName
88262>>>                            Get IsIntFileSaved sIntFileName to bSaved  
88263>>>                            Move True to bOK            
88264>>>                            
88264>>>                            // Save .int file to database if not done previously.
88264>>>                            // We only attempt to read .int files on a development machine.
88264>>>                            If (bDevelop = True) Begin
88266>>>                                If (bSaved = False) Begin
88268>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
88269>>>                                    If (bOK = False) Begin
88271>>>                                        Move False to bResult    
88272>>>                                    End
88272>>>>
88272>>>                                End         
88272>>>>
88272>>>                                If (bOK = True) Begin
88274>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
88275>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
88277>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
88278>>>                                        If (bOK = False) Begin
88280>>>                                            Move False to bResult
88281>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
88282>>>>
88282>>>                                        End
88282>>>>
88282>>>                                    End
88282>>>>
88282>>>                                End
88282>>>>
88282>>>                            End
88282>>>>
88282>>>                            
88282>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
88283>>>                            If (bExists = False) Begin                           
88285>>>                                // If the .int file is missing on disk; create it from database.
88285>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
88286>>>                                If (bOK = False) Begin         
88288>>>                                    Move False to bResult
88289>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
88290>>>>
88290>>>                                End
88290>>>>
88290>>>                            End
88290>>>>
88290>>>                        End
88290>>>>
88290>>>                    End
88290>>>>
88290>>>                Until (hTable = 0)
88292>>>            End
88292>>>>
88292>>>        Loop       
88293>>>>
88293>>>        
88293>>>        // If an error occured we need to exit the application.
88293>>>        If (bResult = False) Begin  
88295>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
88296>>>            Send Exit_Application
88297>>>        End
88297>>>>
88297>>>        
88297>>>    End_Procedure               
88298>>>
88298>>>    // To update currently saved IntFile data to the database.
88298>>>    // Because it is much easier, we first delete all current records and
88298>>>    // then saves the changed .int file to the database.
88298>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
88300>>>        Boolean bOK
88300>>>        
88300>>>        Move False to bOK
88301>>>
88301>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
88302>>>        If (bOK = True) Begin
88304>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
88305>>>        End
88305>>>>
88305>>>        
88305>>>        Function_Return bOK
88306>>>    End_Function
88307>>>    
88307>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
88309>>>        Handle hTable
88309>>>        Boolean bOK
88309>>>        Integer iColumn iIndex   
88309>>>        String sFileName
88309>>>        
88309>>>        Move False to bOK
88310>>>        Get phIntFilesTable to hTable
88311>>>        Move 2              to iColumn // This is the "InfFileName" field no.
88312>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
88313>>>
88313>>>        Open hTable
88315>>>        Set_Field_Value hTable iColumn to sIntFileName
88318>>>        Vfind hTable iIndex GE
88320>>>        Get_Field_Value hTable iColumn to sFileName
88323>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
88325>>>            Move True to bOK    
88326>>>        End
88326>>>>
88326>>>        Close hTable
88327>>>        
88327>>>        Function_Return bOK       
88328>>>    End_Function   
88329>>>    
88329>>>    // Checks that the passed .int file is the same as what is saved in the database.
88329>>>    // If not same, the return string array will contain the read .int file,
88329>>>    // else the returned array will be empty.
88329>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
88331>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
88335>>>        Boolean bIsSame
88335>>>        
88335>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
88336>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
88337>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
88338>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
88339>>>        
88339>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
88340>>>        If (bIsSame = False) Begin
88342>>>            Move asIntFileOrg to asReturnIntFile    
88343>>>        End
88343>>>>
88343>>>        
88343>>>        Function_Return asReturnIntFile    
88344>>>    End_Function                                   
88345>>>    
88345>>>    // Takes a string array as parameter and returns a new
88345>>>    // string array without any empty rows and all rows trimmed.
88345>>>    // This is e.g. used by the HasIntFileChanged message to compare
88345>>>    // two .int file arrays. 
88345>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
88347>>>        Integer iSize iCount iRow
88347>>>        String sVal        
88347>>>        String[] asRetValArray
88348>>>        
88348>>>        Move (SizeOfArray(asIntFile)) to iSize
88349>>>        If (iSize = 0) Begin
88351>>>            Function_Return asRetValArray
88352>>>        End                          
88352>>>>
88352>>>        Decrement iSize         
88353>>>        Move 0 to iRow
88354>>>        
88354>>>        For iCount from 0  to iSize
88360>>>>
88360>>>            Move asIntFile[iCount] to sVal
88361>>>            Move (Trim(sVal)) to sVal
88362>>>            If (sVal <> "") Begin
88364>>>                Move sVal to asRetValArray[iRow]
88365>>>                Increment iRow        
88366>>>            End
88366>>>>
88366>>>        Loop
88367>>>>
88367>>>        
88367>>>        Function_Return asRetValArray
88368>>>    End_Function
88369>>>    
88369>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
88371>>>        Handle hTable
88371>>>        Boolean bOK bErr
88371>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
88371>>>        Number iID
88371>>>        String sFileName
88371>>>        String[] asIntFile
88372>>>        
88372>>>        Move Err to bErr
88373>>>        Move False to Err
88374>>>        Move False to bOK
88375>>>        Get phIntFilesTable to hTable  
88376>>>        Move 1              to iIDCol
88377>>>        Move 2              to iFileCol
88378>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
88379>>>        Move 1              to iIDIdx   // Main ID index.
88380>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
88381>>>
88381>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
88382>>>        Move (SizeOfArray(asIntFile)) to iSize
88383>>>        If (iSize = 0) Begin
88385>>>            Function_Return False
88386>>>        End
88386>>>>
88386>>>        Decrement iSize
88387>>>        Open hTable  
88389>>>                  
88389>>>        // Find the last used ID no:
88389>>>        Fill_Field hTable iIDCol with DF_HIGH
88391>>>        Vfind hTable iIDIdx LE
88393>>>        Get_Field_Value hTable iIDCol to iID 
88396>>>        // This only happens the very first time we save a record.
88396>>>        If (iID = 999999999999) Begin
88398>>>            Move 0 to iID
88399>>>        End
88399>>>>
88399>>>        Increment iID        
88400>>>        
88400>>>        Lock
88401>>>>
88401>>>            For iCount from 0 to iSize
88407>>>>
88407>>>                Clear hTable
88408>>>                Set_Field_Value hTable iIDCol   to iID     
88411>>>                Set_Field_Value hTable iFileCol to sIntFileName
88414>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
88417>>>                SaveRecord hTable
88418>>>                Increment iID
88419>>>            Loop
88420>>>>
88420>>>        Unlock
88421>>>>
88421>>>        Close hTable
88422>>>        
88422>>>        Move (not(Err)) to bOK
88423>>>        Move bErr to Err
88424>>>        
88424>>>        Function_Return bOK
88425>>>    End_Function
88426>>>    
88426>>>    // Deletes all records for the passed sIntFileName value,
88426>>>    // from the phIntFilesTable.
88426>>>    // Returns True if no errors occured.
88426>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
88428>>>        Handle hTable
88428>>>        Boolean bOK bErr bFound
88428>>>        Integer iFileCol iIndex
88428>>>        String sVal
88428>>>        String[] asIntFile
88429>>>        
88429>>>        Move Err to bErr
88430>>>        Move False to Err
88431>>>        Move False to bOK
88432>>>        Move 2              to iFileCol
88433>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
88434>>>        Get phIntFilesTable to hTable  
88435>>>        Open hTable  
88437>>>                  
88437>>>        // Find the first record
88437>>>        Set_Field_Value hTable iFileCol to sIntFileName
88440>>>        Vfind hTable iIndex GE
88442>>>        Get_Field_Value hTable iFileCol to sVal
88445>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
88446>>>        While (bFound = True)
88450>>>            Delete hTable
88451>>>            Vfind hTable iIndex GT
88453>>>            Get_Field_Value hTable iFileCol to sVal
88456>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
88457>>>        Loop
88458>>>>
88458>>>        Unlock
88459>>>>
88459>>>        Close hTable
88460>>>        
88460>>>        Move (not(Err)) to bOK
88461>>>        Move bErr to Err
88462>>>        
88462>>>        Function_Return bOK
88463>>>    End_Function
88464>>>
88464>>>    // Returns all saved phIntFilesTable records for the passed 
88464>>>    // sIntFileName value as a string array.
88464>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
88466>>>        Handle hTable
88466>>>        Boolean bOK bErr bFound
88466>>>        Integer iFileCol iTextCol iIndex
88466>>>        String sVal sFileName
88466>>>        String[] asIntFile asEmptyArray
88468>>>        
88468>>>        Move Err to bErr
88469>>>        Move False to Err
88470>>>        Move False to bOK
88471>>>        Move 2              to iFileCol
88472>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
88473>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
88474>>>        Get phIntFilesTable to hTable  
88475>>>        Open hTable  
88477>>>
88477>>>        // Find the first record
88477>>>        Set_Field_Value hTable iFileCol to sIntFileName
88480>>>        Vfind hTable iIndex GE
88482>>>        Get_Field_Value hTable iFileCol to sFileName
88485>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
88486>>>        While (bFound = True)
88490>>>            Get_Field_Value hTable iFileCol to sFileName
88493>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
88494>>>            If (bFound = True) Begin
88496>>>                Get_Field_Value hTable iTextCol to sVal
88499>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
88500>>>            End
88500>>>>
88500>>>            Vfind hTable iIndex GT
88502>>>        Loop
88503>>>>
88503>>>        
88503>>>        Close hTable
88504>>>        Move (not(Err)) to bOK
88505>>>        If (bOK = False) Begin
88507>>>            Move asEmptyArray to asIntFile
88508>>>        End
88508>>>>
88508>>>        Move bErr to Err               
88509>>>        
88509>>>        Function_Return asIntFile
88510>>>    End_Function
88511>>>
88511>>>    // Reads the passed sIntFileName from disk and returns its value
88511>>>    // as a string array.
88511>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
88513>>>        String[] asIntFile       
88514>>>        String sFileName sLine
88514>>>        Integer iCh iSize iCount
88514>>>        
88514>>>        Get vFolderFormat sPath to sPath
88515>>>        If (not(sIntFileName contains ".")) Begin
88517>>>            Move (sIntFileName + ".int") to sIntFileName
88518>>>        End
88518>>>>
88518>>>        Move (sPath + sIntFileName) to sFileName
88519>>>        Get Seq_Open_input_Channel sFileName to iCh
88520>>>        If (iCh < 0) Begin
88522>>>            Function_Return asIntFile
88523>>>        End                                 
88523>>>>
88523>>>        
88523>>>        Repeat
88523>>>>
88523>>>            Readln channel iCh sLine
88525>>>            If (SeqEof = False) Begin
88527>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
88528>>>            End
88528>>>>
88528>>>        Until (SeqEof = True)
88530>>>        Send Seq_Close_Channel iCh    
88531>>>        
88531>>>        Function_Return asIntFile
88532>>>    End_Function
88533>>>    
88533>>>    // Reads the Filelist.cfg from memeory as a resource.
88533>>>    // The Filelist.cfg has been compiled into the program.
88533>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
88535>>>        Integer iCh iCount
88535>>>        Number nByteCount
88535>>>        String[] asFileListArray sEmptyArray
88537>>>        String sLine
88537>>>        UChar[] uCharData
88538>>>        
88538>>>        Move False to Err
88539>>>        Get Seq_New_Channel to iCh
88540>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88542>>>            Error DFERR_PROGRAM 'No channel available...'
88543>>>>
88543>>>            Function_Return sEmptyArray
88544>>>        End
88544>>>>
88544>>>
88544>>>        // First decide the size of the script
88544>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
88546>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
88548>>>        Close_Input channel iCh
88550>>>        Send Seq_Release_Channel iCh
88551>>>
88551>>>        Function_Return uCharData
88552>>>    End_Function    
88553>>>    
88553>>>    // Writes a copy of the workspace Filelist.cfg to disk.
88553>>>    // It does so by reading from a memory resource, as the file has
88553>>>    // been compiled into the program.
88553>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
88555>>>        Boolean bOK bErr
88555>>>        Integer iSize iCh
88555>>>        
88555>>>        Move Err to bErr
88556>>>        Move False to Err
88557>>>        Move False to bOK
88558>>>        Move (SizeOfArray(asFileListArray)) to iSize
88559>>>        If (iSize = 0) Begin
88561>>>            Function_Return False
88562>>>        End
88562>>>>
88562>>>
88562>>>        Get Seq_New_Channel to iCh
88563>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88565>>>            Error DFERR_PROGRAM 'No channel available...'
88566>>>>
88566>>>            Function_Return False
88567>>>        End                      
88567>>>>
88567>>>        
88567>>>        Direct_Output channel iCh sFileListName
88569>>>        Writeln channel iCh asFileListArray
88572>>>                
88572>>>        Close_Input channel iCh
88574>>>        Send Seq_Release_Channel iCh
88575>>>        Move (not(Err)) to bOK
88576>>>        Move bErr to Err
88577>>>        
88577>>>        Function_Return bOK
88578>>>    End_Function
88579>>>
88579>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
88579>>>    // It first deletes the .cch file (if any).
88579>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
88581>>>        Boolean bOK bFound bExists bErr
88581>>>        Integer iCh iSize iCount
88581>>>        String sFileName sCCHFileName sVal
88581>>>        String[] asIntFile
88582>>>        
88582>>>        Move Err to bErr   
88583>>>        Move False to Err
88584>>>        Move False to bOK
88585>>>
88585>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
88586>>>        Move (SizeOfArray(asIntFile)) to iSize
88587>>>        If (iSize = 0) Begin
88589>>>            Function_Return False        
88590>>>        End                      
88590>>>>
88590>>>        Decrement iSize
88591>>>        
88591>>>        Get Seq_New_Channel to iCh
88592>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88594>>>            Function_Return False
88595>>>        End   
88595>>>>
88595>>>        
88595>>>        // Before we start to actually create the new .int file, make sure we delete
88595>>>        // the .cch file first.                                     
88595>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
88596>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
88597>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
88598>>>        If (bExists = True) Begin
88600>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
88601>>>            If (bOK = False) Begin
88603>>>                Function_Return False
88604>>>            End
88604>>>>
88604>>>        End
88604>>>>
88604>>>        
88604>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
88606>>>        For iCount from 0 to iSize
88612>>>>
88612>>>            Writeln channel iCh asIntFile[iCount]
88615>>>        Loop
88616>>>>
88616>>>        
88616>>>        Close_Input channel iCh
88618>>>        Send Seq_Release_Channel iCh
88619>>>        Move (not(Err)) to bOK
88620>>>        Move bErr to Err
88621>>>        
88621>>>        Function_Return bOK
88622>>>    End_Function   
88623>>>              
88623>>>    // Automatically writes .int files to disk that is missing.
88623>>>    // We only need to make this test this once, but because the message is called
88623>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
88623>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
88623>>>    Procedure AutoCreateIntFilesTable 
88625>>>        Integer hTable 
88625>>>        Boolean bIntFilesTablesCheckDone bTableExists
88625>>>        String sInfoTxt 
88625>>>        
88625>>>        Get phIntFilesTable to hTable  
88626>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
88627>>>        If (bIntFilesTablesCheckDone = True) Begin
88629>>>            Procedure_Return
88630>>>        End
88630>>>>
88630>>>
88630>>>        If (hTable < 1) Begin
88632>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
88633>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
88634>>>>
88634>>>            Procedure_Return
88635>>>        End
88635>>>>
88635>>>
88635>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
88636>>>        If (bTableExists = True) Begin
88638>>>            Set Private.pbIntFilesTablesCheckDone to True
88639>>>            Procedure_Return
88640>>>        End
88640>>>>
88640>>>
88640>>>        Send CreateIntFilesTable hTable
88641>>>
88641>>>        Set Private.pbIntFilesTablesCheckDone to True
88642>>>    End_Function
88643>>>                
88643>>>    Procedure CreateIntFilesTable Handle hTable
88645>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
88645>>>        Boolean bTableExists bOK bUseConnectionID bExists
88645>>>        tAPIColumn[] APIColumn
88645>>>        tAPIColumn[] APIColumn
88646>>>
88646>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
88647>>>        If (bTableExists = True) Begin
88649>>>            Procedure_Return
88650>>>        End
88650>>>>
88650>>>
88650>>>        Move False to Err
88651>>>        Get psDriverID to sDriverID
88652>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
88653>>>
88653>>>        Move CS_IntFilesTableRootName to sTableName
88654>>>
88654>>>        Move 1                  to APIColumn[0].iFieldNumber
88655>>>        Move "ID"               to APIColumn[0].sFieldName
88656>>>        Move DF_BCD             to APIColumn[0].iType
88657>>>        Move False              to APIColumn[0].bIsSQLType
88658>>>        Move 12                 to APIColumn[0].iLength
88659>>>        Move 0                  to APIColumn[0].iPrecision
88660>>>
88660>>>        Move 2                  to APIColumn[1].iFieldNumber
88661>>>        Move "IntFileName"      to APIColumn[1].sFieldName
88662>>>        Move DF_ASCII           to APIColumn[1].iType
88663>>>        Move False              to APIColumn[1].bIsSQLType
88664>>>        Move 50                 to APIColumn[1].iLength
88665>>>        Move 0                  to APIColumn[1].iPrecision
88666>>>
88666>>>        Move 3                  to APIColumn[2].iFieldNumber
88667>>>        Move "IntLineText"      to APIColumn[2].sFieldName
88668>>>        Move DF_ASCII           to APIColumn[2].iType
88669>>>        Move False              to APIColumn[2].bIsSQLType
88670>>>        Move 100                to APIColumn[2].iLength
88671>>>        Move 0                  to APIColumn[2].iPrecision
88672>>>
88672>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
88673>>>        
88673>>>        If (bOK = True and Err = False) Begin
88675>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
88676>>>        End
88676>>>>
88676>>>        Else Begin
88677>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
88678>>>            Error sInfoTxt
88679>>>>
88679>>>            Procedure_Return
88680>>>        End
88680>>>>
88680>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
88681>>>
88681>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
88682>>>        If (bOK = True) Begin
88684>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
88685>>>        End
88685>>>>
88685>>>        If (bOK = False) Begin
88687>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
88688>>>            Error sInfoTxt
88689>>>>
88689>>>            Procedure_Return
88690>>>        End                    
88690>>>>
88690>>>        
88690>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
88690>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
88691>>>        Get vFolderFormat sDataPath to sDataPath
88692>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
88693>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
88694>>>        If (bExists = True) Begin
88696>>>            Move CS_IntFilesTableRootName to sTableName
88697>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
88698>>>            If (bExists = True) Begin
88700>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
88701>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
88702>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
88703>>>            End
88703>>>>
88703>>>        End
88703>>>>
88703>>>        
88703>>>    End_Procedure
88704>>>
88704>>>    Procedure CheckAutoCreateDbVersionTable
88706>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
88706>>>        Integer iDbVersionFileNumber
88706>>>
88706>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
88707>>>        If (bDbVersionCheckDone = True) Begin
88709>>>            Procedure_Return
88710>>>        End
88710>>>>
88710>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
88711>>>        If (bUseCustomDbVersion = True) Begin
88713>>>            Procedure_Return
88714>>>        End
88714>>>>
88714>>>
88714>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
88715>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
88717>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
88718>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
88719>>>>
88719>>>            Send Exit_Application
88720>>>        End
88720>>>>
88720>>>
88720>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
88721>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
88722>>>        If (bTableExists = True) Begin
88724>>>            Set Private.pbDbVersionCheckDone to True
88725>>>            Procedure_Return
88726>>>        End
88726>>>>
88726>>>
88726>>>        Send CreateDbVersionTable iDbVersionFileNumber
88727>>>
88727>>>        // We only need to these DbVersion checks once, but because this message is called
88727>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
88727>>>        // we use a property to only run these tests once.
88727>>>        Set Private.pbDbVersionCheckDone to True
88728>>>    End_Procedure
88729>>>
88729>>>    Procedure CreateDbVersionTable Handle hTable
88731>>>        String sTableName sColumnName sInfoTxt sDriverID 
88731>>>        Boolean bTableExists bOK bUseConnectionID
88731>>>        tAPIColumn[] APIColumn
88731>>>        tAPIColumn[] APIColumn
88732>>>
88732>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
88733>>>        If (bTableExists = True) Begin
88735>>>            Procedure_Return
88736>>>        End
88736>>>>
88736>>>
88736>>>        Get psDriverID to sDriverID
88737>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
88738>>>
88738>>>        Move "DbVersion"        to sTableName
88739>>>        Move 1                  to APIColumn[0].iFieldNumber
88740>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
88741>>>        Move DF_BCD             to APIColumn[0].iType
88742>>>        Move False              to APIColumn[0].bIsSQLType
88743>>>        Move 4                  to APIColumn[0].iLength
88744>>>        Move 2                  to APIColumn[0].iPrecision
88745>>>
88745>>>        Move False to Err                                
88746>>>        
88746>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
88746>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
88746>>>        Set psDriverID to DATAFLEX_ID
88747>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
88748>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
88749>>>        Set psDriverID to sDriverID
88750>>>        
88750>>>        If (bOK = True and Err = False) Begin
88752>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
88752>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
88753>>>        End
88753>>>>
88753>>>        Else Begin
88754>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
88755>>>        End
88755>>>>
88755>>>
88755>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
88756>>>    End_Procedure
88757>>>
88757>>>    Procedure Set pbVerboseState Boolean bVerboseState
88759>>>        Handle ho
88759>>>        Get phoLogFile to ho
88760>>>        Set pbVerboseState of ho to bVerboseState
88761>>>    End_Procedure
88762>>>
88762>>>    Function pbVerboseState Returns Boolean
88764>>>        Boolean bVerboseState
88764>>>        Handle ho
88764>>>        Get phoLogFile to ho
88765>>>        Get pbVerboseState of ho to bVerboseState
88766>>>        Function_Return bVerboseState
88767>>>    End_Function
88768>>>
88768>>>    // Callback functionality used when e.g. calling driver functions directly.
88768>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
88768>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
88770>>>        Integer iPerc
88770>>>        Number nReady nTotal nVersion
88770>>>        Boolean bVerboseState
88770>>>        Handle hoLogFile
88770>>>
88770>>>        Get pbVerboseState to bVerboseState
88771>>>        Get pnCurrentVersionUpdate to nVersion
88772>>>        Get phoLogFile     to hoLogFile
88773>>>        Send DoAdvance of ghoProgressBar
88774>>>
88774>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
88776>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
88777>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
88778>>>        End
88778>>>>
88778>>>        If (sCallback_Text contains "Creating index") Begin
88780>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
88781>>>        End
88781>>>>
88781>>>
88781>>>        Case Begin
88781>>>            Case (iCallback_Type = DF_Message_Text)
88783>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88784>>>                Set Action_Text  of ghoStatusPanel to ""
88785>>>                If (bVerboseState = True) Begin
88787>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88788>>>                End
88788>>>>
88788>>>                Case Break
88789>>>            Case (iCallback_Type = DF_Message_Heading_1)
88792>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88793>>>                If (bVerboseState = True) Begin
88795>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88796>>>                End
88796>>>>
88796>>>                Case Break
88797>>>            Case (iCallback_Type = DF_Message_Heading_2)
88800>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88801>>>                Set Action_Text  of ghoStatusPanel to ""
88802>>>                If (bVerboseState = True) Begin
88804>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88805>>>                End
88805>>>>
88805>>>                Case Break
88806>>>            Case (iCallback_Type = DF_Message_Heading_3)
88809>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88810>>>                Set Action_Text  of ghoStatusPanel to ""
88811>>>                If (bVerboseState = True) Begin
88813>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88814>>>                End
88814>>>>
88814>>>                Case Break
88815>>>            Case (iCallback_Type = DF_Message_Heading_4)
88818>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88819>>>                Set Action_Text  of ghoStatusPanel to ""
88820>>>                If (bVerboseState = True) Begin
88822>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88823>>>                End
88823>>>>
88823>>>                Case Break
88824>>>            Case (iCallback_Type = DF_Message_Heading_5)
88827>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88828>>>                Set Action_Text  of ghoStatusPanel to ""
88829>>>                If (bVerboseState = True) Begin
88831>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88832>>>                End
88832>>>>
88832>>>                Case Break
88833>>>            Case (iCallback_Type = DF_Message_Warning)
88836>>>                If (bVerboseState = True) Begin
88838>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88839>>>                End
88839>>>>
88839>>>                Case Break
88840>>>            Case (iCallback_Type = DF_Message_Progress_Title)
88843>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
88844>>>                Set Action_Text  of ghoStatusPanel to ""
88845>>>                If (bVerboseState = True) Begin
88847>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
88848>>>                End
88848>>>>
88848>>>                Case Break
88849>>>            Case (iCallback_Type = DF_Message_Progress_Value)
88852>>>                //*** Interpret numbers
88852>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
88853>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
88854>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
88855>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
88856>>>                Set piPosition of ghoProgressBar to iPerc
88857>>>                Case Break
88858>>>            Case Else
88858>>>                Set Message_Text to ""
88859>>>                Set Action_Text  to ""
88860>>>        Case End
88860>>>
88860>>>        Send ProcessEvents of ghoStatusPanel
88861>>>        Function_Return False
88862>>>    End_Function
88863>>>
88863>>>    // This was made to be a procedure/function pair so we
88863>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
88863>>>
88863>>>    Procedure Set piDbType Integer iDbType
88865>>>        If (ghoSQLConnectionHandler = 0) Begin
88867>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88868>>>>
88868>>>            Procedure_Return
88869>>>        End
88869>>>>
88869>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
88870>>>    End_Procedure
88871>>>
88871>>>    Function piDbType Returns Integer
88873>>>        Integer iDbType
88873>>>        If (ghoSQLConnectionHandler = 0) Begin
88875>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88876>>>>
88876>>>            Function_Return ""
88877>>>        End
88877>>>>
88877>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
88878>>>        Function_Return iDbType
88879>>>    End_Function
88880>>>
88880>>>    Procedure Set psDriverID String sDriverID
88882>>>        If (ghoSQLConnectionHandler = 0) Begin
88884>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88885>>>>
88885>>>            Procedure_Return
88886>>>        End
88886>>>>
88886>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
88887>>>    End_Procedure
88888>>>
88888>>>    Function psDriverID Returns String
88890>>>        String sValue
88890>>>        If (ghoSQLConnectionHandler = 0) Begin
88892>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88893>>>>
88893>>>            Function_Return ""
88894>>>        End
88894>>>>
88894>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
88895>>>        Function_Return sValue
88896>>>    End_Function
88897>>>
88897>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
88899>>>        If (ghoSQLConnectionHandler = 0) Begin
88901>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88902>>>>
88902>>>            Procedure_Return
88903>>>        End
88903>>>>
88903>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
88904>>>    End_Procedure
88905>>>
88905>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
88907>>>        Integer iRetval
88907>>>        If (ghoSQLConnectionHandler = 0) Begin
88909>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88910>>>>
88910>>>            Function_Return 2
88911>>>        End
88911>>>>
88911>>>
88911>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
88912>>>        Function_Return iRetval
88913>>>    End_Function
88914>>>
88914>>>    Procedure Set psConnectionID String sValue
88916>>>        If (ghoSQLConnectionHandler = 0) Begin
88918>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88919>>>>
88919>>>            Procedure_Return
88920>>>        End
88920>>>>
88920>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
88921>>>    End_Procedure
88922>>>
88922>>>    Function psConnectionID Returns String
88924>>>        String sValue
88924>>>        If (ghoSQLConnectionHandler = 0) Begin
88926>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88927>>>>
88927>>>            Function_Return ""
88928>>>        End
88928>>>>
88928>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
88929>>>
88929>>>        Function_Return sValue
88930>>>    End_Function
88931>>>
88931>>>    // These "properties" are settings of the cCLIHandler class, but are being
88931>>>    // relayed to the ghoSQLConnectionHandler object
88931>>>    // simply by changing one of its parameters.
88931>>>    Procedure Set psServer String sValue
88933>>>        If (ghoSQLConnectionHandler = 0) Begin
88935>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88936>>>>
88936>>>            Procedure_Return
88937>>>        End
88937>>>>
88937>>>        Set psServer of ghoSQLConnectionHandler to sValue
88938>>>    End_Procedure
88939>>>
88939>>>    Function psServer Returns String
88941>>>        String sValue
88941>>>        If (ghoSQLConnectionHandler = 0) Begin
88943>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88944>>>>
88944>>>            Function_Return ""
88945>>>        End
88945>>>>
88945>>>        Get psServer of ghoSQLConnectionHandler to sValue
88946>>>
88946>>>        Function_Return sValue
88947>>>    End_Function
88948>>>
88948>>>    Procedure Set psDatabase String sValue
88950>>>        If (ghoSQLConnectionHandler = 0) Begin
88952>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88953>>>>
88953>>>            Procedure_Return
88954>>>        End
88954>>>>
88954>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
88955>>>    End_Procedure
88956>>>
88956>>>    Function psDatabase Returns String
88958>>>        String sValue
88958>>>        If (ghoSQLConnectionHandler = 0) Begin
88960>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88961>>>>
88961>>>            Function_Return ""
88962>>>        End
88962>>>>
88962>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
88963>>>
88963>>>        Function_Return sValue
88964>>>    End_Function
88965>>>
88965>>>    Procedure Set psUserID String sValue
88967>>>        If (ghoSQLConnectionHandler = 0) Begin
88969>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88970>>>>
88970>>>            Procedure_Return
88971>>>        End
88971>>>>
88971>>>        Set psUserID of ghoSQLConnectionHandler to sValue
88972>>>    End_Procedure
88973>>>
88973>>>    Function psUserID Returns String
88975>>>        String sValue
88975>>>        If (ghoSQLConnectionHandler = 0) Begin
88977>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88978>>>>
88978>>>            Function_Return ""
88979>>>        End
88979>>>>
88979>>>        Get psUserID of ghoSQLConnectionHandler to sValue
88980>>>
88980>>>        Function_Return sValue
88981>>>    End_Function
88982>>>
88982>>>    Procedure Set psPassword String sValue
88984>>>        If (ghoSQLConnectionHandler = 0) Begin
88986>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88987>>>>
88987>>>            Procedure_Return
88988>>>        End
88988>>>>
88988>>>        Set psPassword of ghoSQLConnectionHandler to sValue
88989>>>    End_Procedure
88990>>>
88990>>>    Function psPassword Returns String
88992>>>        String sValue
88992>>>        If (ghoSQLConnectionHandler = 0) Begin
88994>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
88995>>>>
88995>>>            Function_Return ""
88996>>>        End
88996>>>>
88996>>>        Get psPassword of ghoSQLConnectionHandler to sValue
88997>>>
88997>>>        Function_Return sValue
88998>>>    End_Function
88999>>>
88999>>>    Procedure Set pbTrusted Boolean bValue
89001>>>        If (ghoSQLConnectionHandler = 0) Begin
89003>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
89004>>>>
89004>>>            Procedure_Return
89005>>>        End
89005>>>>
89005>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
89006>>>    End_Procedure
89007>>>
89007>>>    Function pbTrusted Returns Boolean
89009>>>        Boolean bValue
89009>>>        If (ghoSQLConnectionHandler = 0) Begin
89011>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
89012>>>>
89012>>>            Function_Return False
89013>>>        End
89013>>>>
89013>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
89014>>>
89014>>>        Function_Return bValue
89015>>>    End_Function
89016>>>
89016>>>    Procedure Set psConnectionString String sValue
89018>>>        If (ghoSQLConnectionHandler = 0) Begin
89020>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
89021>>>>
89021>>>            Procedure_Return
89022>>>        End
89022>>>>
89022>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
89023>>>    End_Procedure
89024>>>
89024>>>    Function psConnectionString Returns String
89026>>>        String sValue
89026>>>        If (ghoSQLConnectionHandler = 0) Begin
89028>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
89029>>>>
89029>>>            Function_Return ""
89030>>>        End
89030>>>>
89030>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
89031>>>
89031>>>        Function_Return sValue
89032>>>    End_Function
89033>>>
89033>>>    Function piConnectionOptions Returns Integer
89035>>>        Integer iValue
89035>>>        If (ghoSQLConnectionHandler = 0) Begin
89037>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
89038>>>>
89038>>>            Function_Return 0
89039>>>        End
89039>>>>
89039>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
89040>>>
89040>>>        Function_Return iValue
89041>>>    End_Function
89042>>>
89042>>>
89042>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
89044>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
89045>>>    End_Procedure
89046>>>
89046>>>    Function pbCheckDataFlexUserCount Returns Boolean
89048>>>        Boolean bState
89048>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
89049>>>        Function_Return bState
89050>>>    End_Function
89051>>>
89051>>>    Procedure Set psLogTextFile String sValue
89053>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
89054>>>    End_Procedure
89055>>>
89055>>>    Function psLogTextFile Returns String
89057>>>        String sValue
89057>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
89058>>>        Function_Return sValue
89059>>>    End_Function
89060>>>
89060>>>    Procedure Set psEditorProgram String sValue
89062>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
89063>>>    End_Procedure
89064>>>
89064>>>    Function psEditorProgram Returns String
89066>>>        String sValue
89066>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
89067>>>        Function_Return sValue
89068>>>    End_Function
89069>>>
89069>>>    Procedure Set pbUseDataTableLog Boolean bState
89071>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
89072>>>    End_Procedure
89073>>>
89073>>>    Function pbUseDataTableLog Returns Boolean
89075>>>        Boolean bState
89075>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
89076>>>        Function_Return bState
89077>>>    End_Function
89078>>>
89078>>>    Procedure Set pbQuickWrite Boolean bState
89080>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
89081>>>    End_Procedure
89082>>>
89082>>>    Function pbQuickWrite Returns Boolean
89084>>>        Boolean bState
89084>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
89085>>>        Function_Return bState
89086>>>    End_Function
89087>>>
89087>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
89089>>>        Boolean bUpdateVersionObjectError bVerboseState
89089>>>        Integer iSize iCount
89089>>>        Number nVersion
89089>>>        String[] aSQLQueryMessages
89090>>>
89090>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
89091>>>        Set Private.pbDatabaseWasUpdated to bState
89092>>>        // If no errors occurred in the current cDbUpdateVersion object - write
89092>>>        // to the log that it was OK.
89092>>>        If (bUpdateVersionObjectError = False) Begin
89094>>>            Get pnCurrentVersionUpdate to nVersion
89095>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
89096>>>        End
89096>>>>
89096>>>
89096>>>        Get pbVerboseState to bVerboseState
89097>>>        If (bVerboseState = True) Begin
89099>>>            Get paSQLQueryMessages to aSQLQueryMessages
89100>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
89101>>>            Decrement iSize
89102>>>            For iCount from 0 to iSize
89108>>>>
89108>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
89109>>>            Loop
89110>>>>
89110>>>        End
89110>>>>
89110>>>
89110>>>    End_Procedure 
89111>>>    
89111>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
89113>>>        Set Private.piDbVersionFileNumber to iFileNumber
89114>>>    End_Procedure                                         
89115>>>    
89115>>>    Function piDbVersionFileNumber Returns Integer
89117>>>        Function_Return (Private.piDbVersionFileNumber(Self))
89118>>>    End_Function
89119>>>
89119>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
89121>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
89122>>>    End_Procedure                                         
89123>>>    
89123>>>    Function piDbVersionFieldNumber Returns Integer
89125>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
89126>>>    End_Function
89127>>>
89127>>>    Function pbDatabaseWasUpdated Returns Boolean
89129>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
89130>>>    End_Function
89131>>>    
89131>>>    //
89131>>>    Procedure ReinitializeFramework  
89133>>>        tDbVersionInfo[] aDbVersionInfoArray
89133>>>        tDbVersionInfo[] aDbVersionInfoArray
89134>>>        Handle hoDbVersionObject
89134>>>        Integer iSize iCount
89134>>>        
89134>>>        Set Private.pbDatabaseUpdateStarted to False
89135>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
89136>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
89137>>>        Decrement iSize
89138>>>        
89138>>>        For iCount from 0 to iSize
89144>>>>
89144>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
89145>>>            Send ProcessUpdate                  of hoDbVersionObject False
89146>>>        Loop
89147>>>>
89147>>>        Send Cleanup
89148>>>    End_Procedure
89149>>>    
89149>>>    // This event is triggered by the cDbUpdateVersion child class when
89149>>>    // a database change is to be started, and is considered private.
89149>>>    // It is only executed once for the first cDbUpateVersion object!
89149>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
89151>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
89151>>>        Integer iRetval iDataFlexUsers iUserCount
89151>>>        Handle hoUserCountSystem
89151>>>        tUserCount UserCount
89151>>>        tUserCount UserCount
89151>>>        DateTime dtUpdateStarted
89151>>>        tSQLConnection SQLConnection
89151>>>        tSQLConnection SQLConnection
89151>>>
89151>>>        // *Important:* If we already started the update; we do no further checking.
89151>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
89152>>>        If (bDatabaseUpdateStarted = True) Begin
89154>>>            Procedure_Return
89155>>>        End
89155>>>>
89155>>>
89155>>>        // If not silent mode; Ask user if OK to start database update.
89155>>>        If (pbSilentMode(Self) = False) Begin
89157>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
89158>>>            If (iRetval <> MBR_Yes) Begin
89160>>>                Send Exit_Application
89161>>>            End
89161>>>>
89161>>>        End
89161>>>>
89161>>>        
89161>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
89162>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
89163>>>        Send Start_StatusPanel      of ghoStatusPanel
89164>>>
89164>>>        // This will save the status of all open tables including Master/Alias settings,
89164>>>        // so we can restore them later;
89164>>>        Send SaveOpenTables
89165>>>
89165>>>        Move 0 to iDataFlexUsers
89166>>>        // Make various tests to check that the database is not in use.
89166>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
89167>>>        // We also use our own user counting mechanism to guard against the
89167>>>        // database isn't opened already as we need exclusive access to the tables.:
89167>>>        Get phoUserCountSystem to hoUserCountSystem
89168>>>        Get CheckUserCount of hoUserCountSystem to UserCount
89169>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
89170>>>
89170>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
89171>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
89171>>>        If (bCheckDataFlexUserCount = True) Begin
89173>>>            Get_Current_User_Count to iDataFlexUsers
89174>>>            // For some reason DataFlex - in some cases - might think that 2 users
89174>>>            // are in use while debugging from the Studio.
89174>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
89176>>>                Decrement iDataFlexUsers
89177>>>            End
89177>>>>
89177>>>        End 
89177>>>>
89177>>>        Else Begin
89178>>>            Move 1 to iDataFlexUsers 
89179>>>            Move 1 to iUserCount
89180>>>            Move False to bInUse
89181>>>        End
89181>>>>
89181>>>
89181>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
89183>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
89184>>>            If (iRetval <> MBR_Yes) Begin
89186>>>                Send Exit_Application
89187>>>            End
89187>>>>
89187>>>        End
89187>>>>
89187>>>
89187>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
89189>>>            Send Stop_Box CS_DUF_DatabaseInUseText
89190>>>            Send Exit_Application
89191>>>        End
89191>>>>
89191>>>
89191>>>        // This will put a look on the DbUpdateLock.ucf file.
89191>>>        // It is released when the update process is finished
89191>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
89192>>>
89192>>>        Move (CurrentDateTime()) to dtUpdateStarted
89193>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
89194>>>        Set Private.pbDatabaseUpdateStarted to True
89195>>>
89195>>>        // We need to close all tables before starting to make changes.
89195>>>        Close DF_ALL DF_PERMANENT
89196>>>
89196>>>        // If these properties has not exclicitly been set in the object, set them
89196>>>        // to settings from the SQLConnections.ini file;
89196>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89197>>>        If (psSchema(Self) = "") Begin
89199>>>            Set psSchema            to SQLConnection.sSchema
89200>>>        End
89200>>>>
89200>>>        If (psBaseTableSpace(Self) = "") Begin
89202>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
89203>>>        End
89203>>>>
89203>>>        If (psLongTableSpace(Self) = "") Begin
89205>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
89206>>>        End
89206>>>>
89206>>>        If (psIndexTableSpace(Self) = "") Begin
89208>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
89209>>>        End
89209>>>>
89209>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
89211>>>            Procedure_Return
89212>>>        End
89212>>>>
89212>>>
89212>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
89213>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
89215>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
89216>>>            Send Stop_StatusPanel of ghoStatusPanel
89217>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
89217>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
89218>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
89218>>>            Send Exit_Application
89219>>>        End
89219>>>>
89219>>>    End_Procedure
89220>>>
89220>>>    // *** Hook message for pre-processing ***
89220>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
89220>>>    // Aka, when another table than the standard "DbVersion" is used.
89220>>>    Procedure OnCreateCustomDbVersionTable
89222>>>    End_Procedure
89223>>>    
89223>>>    // *** Hook message for pre-processing ***
89223>>>    // The programmer can use this event for putting code that
89223>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
89223>>>    // child objects are executed.
89223>>>    Procedure OnPreUpdate
89225>>>    End_Procedure
89226>>>
89226>>>    // *** Hook message for post-processing ***
89226>>>    // The programmer should use this event for putting code that
89226>>>    // needs to be executed _after_ all database updates have finished.
89226>>>    Procedure OnPostUpdate
89228>>>    End_Procedure
89229>>>
89229>>>    // *** Hook message for custom DbVersion record find ***
89229>>>    // The programmer can use this event for putting code that
89229>>>    // needs to be executed to find a *custom* DbVersion table record.
89229>>>    // By default the DbVersion table is used but this can be
89229>>>    // customized by adding this line to the code;
89229>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
89229>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
89229>>>    //       to save the current database version to. Only if you use your own
89229>>>    //       table _and_ it is not a system table (contains only one record).
89229>>>    Procedure OnFindVersionRecord
89231>>>        // Open MyTable
89231>>>        // Move xx to MyTable.Field1
89231>>>        // Move yy to MyTable.Field2
89231>>>        // Find le MyTable by Index.x
89231>>>    End_Procedure
89232>>>
89232>>>    // Hook event for writing header error text (pre-update) to
89232>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
89232>>>    // Don't forget to Open the table first (!) as all
89232>>>    // tables have been closed at this stage.
89232>>>    // The start date & time is passed.
89232>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
89234>>>    End_Procedure
89235>>>
89235>>>    // Hook event to log errors to a database table.
89235>>>    // Only called if the pbUseDataTableLog = True.
89235>>>    // Don't forget to Open the table first (!) as all
89235>>>    // tables have been closed at this stage.
89235>>>    // If pbQuickWrite = True the DbUpdateErrorArray
89235>>>    // will contain just one row, as it is called for each error
89235>>>    // that occurred. Else it is called once at the end after all updates
89235>>>    // have run and contains all errors.
89235>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
89237>>>    End_Procedure
89238>>>
89238>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
89238>>>    Procedure Cleanup
89240>>>        Boolean bDatabaseWasUpdated bError
89240>>>
89240>>>        Send CheckAutoCreateDbVersionTable
89241>>>        Send RestoreOpenTables
89242>>>
89242>>>        // The function library have two purposes; one is to use it in the
89242>>>        // Database Update Framework, but it can also be used on its own.
89242>>>        // If that is the case it has its own error handling system, which
89242>>>        // we temporarily disbled when running updates because we have
89242>>>        // error handling/logging here too... We now restore its setting.
89242>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
89244>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
89245>>>        End
89245>>>>
89245>>>        Set pbHandleQueryErrors to True
89246>>>
89246>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
89247>>>        Get pbDbUpdateErrorHasOccured to bError
89248>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
89250>>>
89250>>>            // We should always create the log as it also contains info about
89250>>>            // the update being successful.
89250>>>            Send WriteErrorLog of (phoLogFile(Self))
89251>>>
89251>>>            // This is a programmer's hook message:
89251>>>            Send OnPostUpdate
89252>>>
89252>>>            Send Stop_StatusPanel of ghoStatusPanel
89253>>>
89253>>>            If (pbSilentMode(Self) = False) Begin
89255>>>                If (bError = True) Begin
89257>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
89259>>>                        Send ShowErrorLog of (phoLogFile(Self))
89260>>>                    End
89260>>>>
89260>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
89261>>>                    Send Exit_Application
89262>>>                End
89262>>>>
89262>>>                Else Begin
89263>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
89265>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
89266>>>                    End
89266>>>>
89266>>>                    Else Begin
89267>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
89268>>>                    End
89268>>>>
89268>>>
89268>>>                End
89268>>>>
89268>>>            End
89268>>>>
89268>>>        End
89268>>>>
89268>>>
89268>>>        // Restore the standard error handler:
89268>>>        Get piOrgErrorHandlerID to Error_Object_Id
89269>>>    End_Procedure
89270>>>
89270>>>    // We do this _before_ we close the database to make changes, and save
89270>>>    // all 'Master' & 'Alias' tables settings so we can restore when
89270>>>    // we reopen the database.
89270>>>    Procedure SaveOpenTables
89272>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89272>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89273>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
89274>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
89275>>>    End_Procedure
89276>>>
89276>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
89276>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
89276>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
89278>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89278>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89279>>>        Integer hTable iMasterAliasType iSize
89279>>>        Boolean bOpen
89279>>>
89279>>>        Move 0 to hTable
89280>>>        Repeat
89280>>>>
89280>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89283>>>            If (hTable <> 0) Begin
89285>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89288>>>                If (bOpen = True) Begin
89290>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
89293>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
89294>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
89295>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
89296>>>                End
89296>>>>
89296>>>            End
89296>>>>
89296>>>        Until (hTable = 0)
89298>>>
89298>>>        Function_Return aDbUpdateHandlerMasterAlias
89299>>>    End_Function
89300>>>
89300>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
89300>>>    // Takes one parameter:
89300>>>    //   A struct array with all master & alias
89300>>>    Procedure RestoreOpenTables
89302>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89302>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
89303>>>        Integer hTable iFileAlias iSize iCount
89303>>>        Boolean bOpen
89303>>>        String sRootName
89303>>>
89303>>>        Move 0 to hTable
89304>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
89305>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
89306>>>        Decrement iSize
89307>>>        For iCount from 0 to iSize
89313>>>>
89313>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
89314>>>            // We also need to check that the table hasn't been removed...
89314>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89317>>>            If (hTable <> 0 and sRootName <> "") Begin
89319>>>                Open hTable
89321>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89324>>>                If (bOpen = True) Begin
89326>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
89327>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
89329>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
89332>>>                    End
89332>>>>
89332>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
89335>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
89338>>>                    End
89338>>>>
89338>>>                End
89338>>>>
89338>>>            End
89338>>>>
89338>>>        Loop
89339>>>>
89339>>>    End_Procedure
89340>>>
89340>>>    // This checks for both duplicate pnVersionNumbers _and_ that
89340>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
89340>>>    Procedure CheckForDuplicates Number nVersion
89342>>>        tDbVersionInfo[] DbVersionInfoArray
89342>>>        tDbVersionInfo[] DbVersionInfoArray
89343>>>        Integer iCount iSize iHits iDuplicateIndex
89343>>>        Number nCompare
89343>>>        Handle hObject1 hObject2
89343>>>        String sObjectName1 sObjectName2
89343>>>        Boolean bObjectOrderError
89343>>>
89343>>>        Get paDbVersionInfoArray to DbVersionInfoArray
89344>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
89345>>>        Decrement iSize
89346>>>        Move 0 to iHits
89347>>>        Move 0 to nCompare
89348>>>        Move False to bObjectOrderError
89349>>>        For iCount from 0 to iSize
89355>>>>
89355>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
89357>>>                Increment iHits
89358>>>                If (iHits > 1) Begin
89360>>>                    Move iCount to iDuplicateIndex
89361>>>                    If (nCompare <> 0) Begin
89363>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
89364>>>                    End
89364>>>>
89364>>>                End
89364>>>>
89364>>>            End
89364>>>>
89364>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
89365>>>        Loop
89366>>>>
89366>>>        If (iHits > 1) Begin
89368>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
89369>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
89370>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
89371>>>            Move (Name(hObject1)) to sObjectName1
89372>>>            Move (Name(hObject2)) to sObjectName2
89373>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
89374>>>>
89374>>>            Send Exit_Application
89375>>>        End
89375>>>>
89375>>>        Else If (bObjectOrderError = True) Begin
89378>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
89379>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
89380>>>>
89380>>>            Send Exit_Application
89381>>>        End
89381>>>>
89381>>>    End_Procedure
89382>>>
89382>>>    // We take care of all errors in the Error_Report below and
89382>>>    // collect them all to an array property. So just ignore any
89382>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
89382>>>    // in some other package.
89382>>>    Procedure Ignore_Error Integer iError
89384>>>    End_Procedure
89385>>>
89385>>>    Procedure Trap_Error Integer iError
89387>>>    End_Procedure
89388>>>
89388>>>    // Build complete error description from Flexerrs and user error message.
89388>>>    Function Error_Description Integer Error# String ErrMsg Returns String
89390>>>        String Full_Error_Text
89390>>>        
89390>>>        Move (Trim(ErrMsg)) to ErrMsg
89391>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
89392>>>        
89392>>>        If (ErrMsg <> "") Begin
89394>>>            
89394>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
89396>>>                // Make sure last character of error text is a separating symbol.
89396>>>                // if not, add a "." So we have format of "error-text. error-detail"
89396>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
89399>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
89400>>>            End
89400>>>>
89400>>>            Else ;                Move ErrMsg to Full_Error_Text
89402>>>            
89402>>>        End
89402>>>>
89402>>>        
89402>>>        Function_Return Full_Error_Text
89403>>>    End_Function
89404>>>
89404>>>    // While we update the database we collect all errors in
89404>>>    // the struct array paDbUpdateErrorArray.
89404>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
89406>>>        Number nVersion
89406>>>        Handle hoLogFile 
89406>>>//        String sErrExtraText
89406>>>        
89406>>>        If (Private.pbProcessingError(Self)) Begin
89408>>>            Procedure_Return
89409>>>        End
89409>>>>
89409>>>
89409>>>        // The UtilTableNameFromHandleToString function does a:
89409>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
89409>>>        // and it generates an error if the table is of the embedded type.
89409>>>        // As we don't want to trigger an error in that very specific case,
89409>>>        // we just ignore it here.
89409>>>        //
89409>>>        // If no report mode, just set the err indicator to true.
89409>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
89411>>>            Move False to Err
89412>>>            Procedure_Return
89413>>>        End
89413>>>>
89413>>>
89413>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
89415>>>            Procedure_Return
89416>>>        End
89416>>>>
89416>>>
89416>>>        Set Private.pbProcessingError to True
89417>>>        Set Private.pbUpdateVersionObjectError to True
89418>>>
89418>>>        Set pbDbUpdateErrorHasOccured to True
89419>>>        Get pnCurrentVersionUpdate to nVersion
89420>>>        Get phoLogFile to hoLogFile
89421>>>//        Get Error_Description iErrorLine sErrorText to sErrorText
89421>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
89422>>>
89422>>>        Set Private.pbProcessingError to False
89423>>>    End_Procedure
89424>>>
89424>>>End_Class
89425>
89425>Object oHtmlHelp is a cHtmlHelp
89427>    Set pbAlwaysOnTop to False
89428>
89428>    // Overriden class message to also handle internet HTML Help links;
89428>    // which in which case we should not try to find the path to the help file.
89428>    Function GetHelpFile Returns String
89431>        String sHelpFile
89431>
89431>        Get psHelpFile of ghoApplication to sHelpFile
89432>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
89434>            Get_File_Path sHelpFile to sHelpFile
89435>        End
89435>        Function_Return sHelpFile
89436>    End_Function
89437>
89437>End_Object
89438>
89438>Object oApplication is a cApplication
89440>    Set peHelpType to htHtmlHelp
89441>
89441>    // Note: These help file settings gets changed by the Help toolbar button(s).
89441>    Set psHelpFile to "Developer5.chm"
89442>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
89442>
89442>    Set pbPreserveEnvironment to True
89443>    Set psProduct to "Database Update Framework Lab"
89444>    Set psCompany to "RDC Tools International"
89445>
89445>    // DF 19 and up.
89445>    Object oConnection is a cConnection
89447>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\LoginEncryption.pkg)
89447>>>Use cLoginEncryption.pkg
89447>>>
89447>>>Object oLoginEncryption is a cLoginEncryption
89449>>>
89449>>>    // this must be created in your appsrc directory and must contain an encryption
89449>>>    // key that is set to psEncryptPassword. It will look something like this
89449>>>    //
89449>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
89449>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
89449>>>>// Studio generated login encryption key
89449>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
89450>>>>
89450>>>    
89450>>>    // use this to register this object to your cConnection Object. This object
89450>>>    // must be created after the cConnection object
89450>>>    Move Self to ghoLoginEncryption
89451>>>End_Object
89452>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DatabaseLoginDialog.dg)
89452>>>
89452>>>Use Windows.pkg
89452>>>Use cConnection.pkg
89452>>>Use dfLine.pkg
89452>>>
89452>>>Object oDatabaseLoginDialog is a ModalPanel
89454>>>    Set Label to "Database Login"
89455>>>    Set Location to 2 2
89456>>>    Set Size to 110 211
89457>>>    
89457>>>    Property String psId
89459>>>    Property Boolean pbOk False
89461>>>    Property Boolean pbChanged False
89463>>>    Property Boolean pbAllowRemember True
89465>>>    
89465>>>    // this registers this object with the cConnection object.
89465>>>    Move Self to ghoLoginConnectDialog
89466>>>    
89466>>>    Object oUserIDForm is a Form
89468>>>        Set Label to "User Name"
89469>>>        Set Size to 12 85
89470>>>        Set Location to 34 79
89471>>>        Set Label_Col_Offset to 64
89472>>>        Set peAnchors to anTopLeftRight
89473>>>    End_Object
89474>>>    
89474>>>    Object oPwdForm is a Form
89476>>>        Set Size to 12 85
89477>>>        Set Location to 49 79
89478>>>        Set Label_Col_Offset to 64
89479>>>        Set Password_State to True
89480>>>        Set peAnchors to anTopLeftRight
89481>>>        Set Label to "Password"
89482>>>    End_Object
89483>>>    
89483>>>    Object oTrustedConnection is a CheckBox
89485>>>        Set Size to 10 50
89486>>>        Set Location to 65 79
89487>>>        Set Label to "Trusted Connection"
89488>>>    End_Object
89489>>>    
89489>>>    Object oRemember is a CheckBox
89491>>>        Set Size to 10 50
89492>>>        Set Location to 79 14
89493>>>        Set Label to "Remember and don't ask again"
89494>>>        Set Checked_State to True
89495>>>    End_Object
89496>>>    
89496>>>    Object oLogin_btn is a Button
89498>>>        Set Label to "&Login"
89499>>>        Set Location to 92 102
89500>>>        Set peAnchors to anBottomRight
89501>>>        Set Default_State to True
89502>>>        
89502>>>        Procedure OnClick
89505>>>            Boolean bTrust
89505>>>            String sUser sPwd sConn sErr sId
89505>>>            Integer iError
89505>>>            Get psId to sId
89506>>>            Get Value of oUserIDForm to sUser
89507>>>            Get Value of oPwdForm to sPwd
89508>>>            Get Checked_State of oTrustedConnection to bTrust
89509>>>            
89509>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
89510>>>            If (iError=0) Begin
89512>>>                Set pbOk to True
89513>>>                Set pbChanged to True
89514>>>                Send Close_Panel
89515>>>            End
89515>>>>
89515>>>            Else Begin
89516>>>                Get psErrorText of ghoConnection to sErr
89517>>>                Send UserError sErr "Login Error"
89518>>>            End
89518>>>>
89518>>>        End_Procedure
89519>>>    End_Object
89520>>>    
89520>>>    Object oCancel_btn is a Button
89522>>>        Set Label to "&Cancel"
89523>>>        Set Location to 92 157
89524>>>        Set peAnchors to anBottomRight
89525>>>        
89525>>>        Procedure OnClick
89528>>>            Send Close_Panel
89529>>>        End_Procedure
89530>>>    End_Object
89531>>>    
89531>>>    Object oConnectionIdInfo is a TextBox
89533>>>        Set Size to 10 50
89534>>>        Set Location to 4 14
89535>>>        Set Label to 'Connection Id='
89536>>>    End_Object
89537>>>    
89537>>>    Object oConnectionServerInfo is a TextBox
89539>>>        Set Size to 10 50
89540>>>        Set Location to 16 14
89541>>>        Set Label to 'Server'
89542>>>    End_Object
89543>>>    
89543>>>    Object oLineControl1 is a LineControl
89545>>>        Set Size to 2 202
89546>>>        Set Location to 29 5
89547>>>    End_Object
89548>>>    
89548>>>    Function LoginConnectIdDialog String sId Returns Boolean
89551>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
89551>>>        String sUser sPwd sDescription
89551>>>        tConnection Connect
89551>>>        tConnection Connect
89551>>>        
89551>>>        Get pbAllowRemember to bAllowRemember
89552>>>        
89552>>>        
89552>>>        If not bAllowRemember Begin
89554>>>            Set Enabled_State of oRemember to bRemember
89555>>>            Set Visible_State of oRemember to bRemember
89556>>>        End
89556>>>>
89556>>>        
89556>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
89557>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
89558>>>        Set Value of oConnectionServerInfo to Connect.sString
89559>>>        
89559>>>        Set psId to sId
89560>>>        Set pbOk to False
89561>>>        Set pbChanged to False
89562>>>        Set Value of oUserIDForm to Connect.sUID
89563>>>        Set Value of oPwdForm to ""
89564>>>        
89564>>>        Send Popup
89565>>>        
89565>>>        Get pbOk to bOk
89566>>>        Get pbChanged to bChanged
89567>>>        If (bChanged and bOk) Begin
89569>>>            If bAllowRemember Begin
89571>>>                Get Checked_State of oRemember to bRemember
89572>>>                If bRemember Begin
89574>>>                    Get Checked_State of oTrustedConnection to bTrusted
89575>>>                    If not (bTrusted) Begin
89577>>>                        Get Value of oUserIDForm to sUser
89578>>>                        Get Value of oPwdForm to sPwd
89579>>>                    End
89579>>>>
89579>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
89580>>>                End
89580>>>>
89580>>>            End
89580>>>>
89580>>>        End
89580>>>>
89580>>>        Function_Return bOk
89581>>>    End_Function
89582>>>    
89582>>>    
89582>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
89583>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
89584>>>End_Object
89585>>>
89585>    End_Object
89586>
89586>End_Object   
89587>
89587>Object oDbUpdateHandler is a cDbUpdateHandler 
89589>    Set piDbVersionFieldNumber to 1
89590>    Set piDbVersionFileNumber to 1
89591>    
89591>End_Object
89592>
89592>Object oCJSkinFramework is a cCJSkinFramework
89594>    Set pbLoadPreference to True
89595>End_Object
89596>
89596>Object oToolTipController is a cToolTipController
89598>    Set piDurationPopup to 10000
89599>    Set piMaxWidth to 500
89600>    Move Self to ghoToolTipController
89601>End_Object
89602>
89602>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
89602>>>Use cCJStandardMenuItemClasses.pkg
89602>>>
89602>>>Object oEditContextMenu is a cCJContextMenu
89604>>>    
89604>>>    Move Self to Default_Form_Floating_Menu_ID
89605>>>    
89605>>>    Object oUndoMenuItem is a cCJUndoMenuItem
89607>>>    End_Object
89608>>>    
89608>>>    Object oCutMenuItem is a cCJCutMenuItem
89610>>>        Set pbControlBeginGroup to True
89611>>>    End_Object
89612>>>    
89612>>>    Object oCopyMenuItem is a cCJCopyMenuItem
89614>>>    End_Object
89615>>>
89615>>>    Object oPasteMenuItem is a cCJPasteMenuItem
89617>>>    End_Object
89618>>>
89618>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
89620>>>    End_Object
89621>>>
89621>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
89623>>>        Set pbControlBeginGroup to True
89624>>>    End_Object
89625>>>
89625>>>End_Object
89626>>>
89626>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
89626>>>Use Windows.pkg
89626>>>Use cCJStandardMenuItemClasses.pkg
89626>>>Use cCJDeoMenuItemClasses.pkg
89626>>>
89626>>>
89626>>>Object oDEOEditContextMenu17 is a cCJContextMenu
89628>>>    
89628>>>    Move Self to Default_dbFloating_Menu_ID
89629>>>    
89629>>>    Object oUndoMenuItem is a cCJUndoMenuItem
89631>>>    End_Object
89632>>>    
89632>>>    Object oCutMenuItem is a cCJCutMenuItem
89634>>>        Set pbControlBeginGroup to True
89635>>>    End_Object
89636>>>    
89636>>>    Object oCopyMenuItem is a cCJCopyMenuItem
89638>>>    End_Object
89639>>>
89639>>>    Object oPasteMenuItem is a cCJPasteMenuItem
89641>>>    End_Object
89642>>>
89642>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
89644>>>    End_Object
89645>>>
89645>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
89647>>>        Set pbControlBeginGroup to True
89648>>>    End_Object
89649>>>
89649>>>    Object oPromptMenuItem is a cCJPromptMenuItem
89651>>>        Set pbControlBeginGroup to True
89652>>>    End_Object
89653>>>
89653>>>    Object oFindNextMenu is a cCJFindNextMenuItem
89655>>>        Set pbControlBeginGroup to True
89656>>>    End_Object
89657>>>
89657>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
89659>>>    End_Object
89660>>>
89660>>>    Object oClearMenuItem is a cCJClearMenuItem
89662>>>        Set pbControlBeginGroup to True
89663>>>    End_Object
89664>>>
89664>>>    Object oClearAllMenu is a cCJClearAllMenuItem
89666>>>    End_Object
89667>>>
89667>>>    Object oSaveMenu is a cCJSaveMenuItem
89669>>>    End_Object
89670>>>    
89670>>>    Object oDeleteMenu is a cCJDeleteMenuItem
89672>>>    End_Object
89673>>>
89673>>>    Object oRememberitem is a cCJRememberFieldMenuItem
89675>>>        Set pbControlBeginGroup to True
89676>>>    End_Object
89677>>>
89677>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
89679>>>    End_Object
89680>>>
89680>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
89682>>>    End_Object
89683>>>
89683>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
89685>>>    End_Object
89686>>>
89686>>>End_Object
89687>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
89687>>>Use cCJCommandBarSystem.pkg
89687>>>Use Wingdi.pkg
89687>>>Use LanguageText.pkg
89687>>>
89687>>>// User interface constant strings:
89687>>>Define CS_NoSkinShort For "-None"
89687>>>Define CS_NoSkinLong  For "Do not use a skin"
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>
89687>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
89688>>>
89688>>>    Procedure Construct_Object
89690>>>        Forward Send Construct_Object
89692>>>
89692>>>        Set peControlType to xtpControlComboBox
89693>>>
89693>>>        Property tSkinInformation[] pSkins
89694>>>
89694>>>    End_Procedure
89695>>>
89695>>>    Procedure End_Construct_Object
89697>>>        Forward Send End_Construct_Object
89699>>>    End_Procedure
89700>>>
89700>>>    // Custom array sort for the tSkinInformation struct array.
89700>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
89700>>>    // Why?
89700>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
89700>>>    // create a custom sort algorithm.
89700>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
89700>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
89700>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
89700>>>    // randomly ordered. This custom sort method will take care of that.
89700>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
89702>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
89704>>>            Function_Return (GT)
89705>>>        End
89705>>>>
89705>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
89707>>>            Function_Return (LT)
89708>>>        End
89708>>>>
89708>>>        Function_Return (EQ)
89709>>>    End_Function
89710>>>
89710>>>    Procedure OnCreateControl Handle hoObj
89712>>>        Forward Send OnCreateControl hoObj
89714>>>
89714>>>        Send LoadSkins
89715>>>        Send FillComboList hoObj
89716>>>    End_Procedure
89717>>>
89717>>>    // Load all skins. We will only look for skins in expected
89717>>>    // directory which is the Programs folder.
89717>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
89717>>>    // This is not the case with the 'standard' VDF behaviour.
89717>>>    Procedure LoadSkins
89719>>>        Integer iCount iItems iSize
89719>>>        Boolean bFound
89719>>>        String sFile sIni sSkin
89719>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
89719>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
89721>>>        tSkinInformation NoneRow
89721>>>        tSkinInformation NoneRow
89721>>>
89721>>>        If (ghoSkinFramework > 0) Begin
89723>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
89724>>>
89724>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
89725>>>            Move CS_NoSkinShort to NoneRow.sName
89726>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
89727>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
89728>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
89729>>>
89729>>>            // Get the currently loaded skin.
89729>>>            Get psSkinFile of ghoSkinFramework to sFile
89730>>>            Get psSkinIni  of ghoSkinFramework to sIni
89731>>>
89731>>>            // Remove all Extra Large and Large skins from the array.
89731>>>            Move (SizeOfArray(SkinsArray)) to iItems
89732>>>            Decrement iItems
89733>>>            For iCount From 0 to iItems
89739>>>>
89739>>>                Move SkinsArray[iCount].sSkinIni to sSkin
89740>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
89741>>>                If (bFound = False) Begin
89743>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
89744>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
89745>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
89746>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
89747>>>                End
89747>>>>
89747>>>            Loop
89748>>>>
89748>>>            Set pSkins to SkinsArrayNoLarge
89749>>>        End
89749>>>>
89749>>>    End_Procedure
89750>>>
89750>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
89750>>>    Procedure FillComboList Handle hoCombo
89752>>>        Integer iCount iItems iCurrent iTxtEntentSize
89752>>>        String  sFile sIni sCurrSkin
89752>>>        String  sSkin sSkinText
89752>>>        tSkinInformation[] SkinsArray
89752>>>        tSkinInformation[] SkinsArray
89753>>>        Integer iSize
89753>>>
89753>>>        If (ghoSkinFramework < 1) Begin
89755>>>            Procedure_Return
89756>>>        End
89756>>>>
89756>>>
89756>>>        // Get the currently loaded skin.
89756>>>        Get psSkinFile of ghoSkinFramework to sFile
89757>>>        Get psSkinIni  of ghoSkinFramework to sIni
89758>>>        Get pSkins to SkinsArray
89759>>>        Move (SizeOfArray(SkinsArray)) to iItems
89760>>>        Decrement iItems
89761>>>        Send ComClear of hoCombo
89762>>>
89762>>>        For iCount From 0 to iItems
89768>>>>
89768>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
89769>>>            Move (Replace(".ini", sSkin, "")) to sSkin
89770>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
89771>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
89772>>>            Get Text_Extent sSkinText to iSize
89773>>>            If (iSize > iTxtEntentSize) Begin
89775>>>                Move iSize to iTxtEntentSize
89776>>>            End
89776>>>>
89776>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
89777>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
89779>>>                Move iCount to iCurrent
89780>>>            End
89780>>>>
89780>>>        Loop
89781>>>>
89781>>>
89781>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
89782>>>        Set ComDropDownWidth of hoCombo  to iSize
89783>>>        Set ComWidth         of hoCombo  to (iSize + 100)
89784>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
89785>>>    End_Procedure
89786>>>
89786>>>    // Event for when an item is selected from the comboform
89786>>>    Procedure OnExecute Variant vCommandBarControl
89788>>>        Handle  hoCombo
89788>>>        Integer iSelection
89788>>>        String  sSkinFile sSkinIni
89788>>>        tSkinInformation[] SkinsArray
89788>>>        tSkinInformation[] SkinsArray
89789>>>
89789>>>        // Create and bind proxy control
89789>>>        Get CreateProxyControl vCommandBarControl to hoCombo
89790>>>        // Get the current selection
89790>>>        Get ComListIndex of hoCombo to iSelection
89791>>>        Decrement iSelection
89792>>>        Get pSkins to SkinsArray
89793>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
89794>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
89795>>>
89795>>>        Send DoChangeSkin sSkinFile sSkinIni
89796>>>
89796>>>        // Dispose of the proxy control
89796>>>        Send Destroy of hoCombo
89797>>>    End_Procedure
89798>>>
89798>>>    // Send this message to change the current skin.
89798>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
89800>>>        Handle hoClient
89800>>>
89800>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
89801>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
89802>>>        Send ApplySkin of ghoSkinFramework
89803>>>
89803>>>        // Note: The following line is essential for the resizing logic
89803>>>        // to function properly when changing a skin and a view is maximized.
89803>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
89804>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
89805>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
89806>>>    End_Procedure
89807>>>
89807>>>    // Returns: DPI setting as an integer.
89807>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
89807>>>    //                      iDPI=120 is "Medium setting" 125%
89807>>>    //                      iDPI= 144 is "Large setting" 150%
89807>>>    Function GetCurrentDPI Returns Integer
89809>>>        Handle hDC
89809>>>        Integer iPixelsX
89809>>>        Move (GetDC(0)) to hDC
89810>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
89811>>>        Move (ReleaseDC(0, hDC)) to hDC
89812>>>        Function_Return iPixelsX
89813>>>    End_Function
89814>>>
89814>>>End_Class
89815>
89815>Object oMain is a Panel
89817>    Set Label to "Test Program - The Database Update Framework"
89818>    Set Location to 2 2
89819>    Set Size to 309 493
89820>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
89821>    Set Icon to "TestTools.ico"
89822>
89822>    Property Handle phoViewMenu 0
89824>    Property Handle phoReportMenu 0
89826>
89826>    Object oCommandBarSystem is a cCJCommandBarSystem
89828>        Set pbTimerUpdate to True
89829>            Set pbAutoResizeIcons to True
89830>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
89831>            Set peVisualTheme to xtpThemeOffice2013Publisher
89832>        Set pbLargeIcons to True
89833>
89833>        Procedure OnCreateCommandBars
89836>            Handle hoOptions
89836>            
89836>            Forward Send OnCreateCommandBars
89838>            
89838>            Get OptionsObject to hoOptions
89839>            Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
89840>        End_Procedure
89841>
89841>
89841>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
89844>            Set ComShowIcons of hoTabPaintManager to True
89845>//            Send ComSetIconSize of hoTabPaintManager 24 24
89845>
89845>            // This will truncate the middle part of long items
89845>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
89846>        End_Procedure
89847>
89847>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
89847>        // the previous tab workspace view.
89847>        Object oPreviousTabAction is a cCJAction
89849>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
89850>            Procedure OnExecute Variant vCommandBarControl
89853>                Handle hoCommandBars hoClientArea
89853>                Forward Send OnExecute vCommandBarControl
89855>                Get CommandBarSystemObject to hoCommandBars
89856>                Get ClientAreaObject of hoCommandBars to hoClientArea
89857>                If hoClientArea Begin
89859>                    Send Switch_Next_View of hoClientArea
89860>                End
89860>            End_Procedure
89861>        End_Object
89862>
89862>        Object oToolBar is a cCJToolbar
89864>            Set psTitle to "Edit Toolbar"
89865>            Set pbGripper to False
89866>            Set peStretched to stStretch
89867>
89867>            Object oCutToolbarItem is a cCJCutMenuItem  
89869>                Set psImage to "ActionCut1.ico"
89870>            End_Object
89871>
89871>            Object oCopyToolbarItem is a cCJCopyMenuItem
89873>                Set psImage to "ActionCopy1.ico"
89874>            End_Object
89875>
89875>            Object oPasteToolbarItem is a cCJPasteMenuItem
89877>                Set psImage to "ActionPaste1.ico"
89878>            End_Object
89879>
89879>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
89881>                Set psImage to "ActionDelete1.ico"
89882>                Set pbControlBeginGroup to True
89883>            End_Object
89884>
89884>            Object oTheme_tb is a cCJMenuItem
89886>                Set peControlType to xtpControlLabel
89887>                Set psCaption to "Theme:"
89888>                Set pbControlBeginGroup to True
89889>            End_Object
89890>
89890>            Object oThemeItem is a cCJMenuItem
89892>                Set peControlType to xtpControlComboBox
89893>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
89894>
89894>                Procedure OnCreateControl Handle hoObj
89897>                    Integer iItem eTheme
89897>                    Set ComWidth of hoObj to 250
89898>                    Send FillComboList hoObj
89899>                    Get peVisualTheme to eTheme
89900>                    Get FindDataItem hoObj eTheme to iItem
89901>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
89902>                End_Procedure
89903>
89903>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
89906>                    Integer iCount i eTheme
89906>                    Get ComListCount of hoCombo to iCount
89907>                    For i from 1 to iCount
89913>                        Get ComItemData of hoCombo i to eTheme
89914>                        If (eTheme=eVal) Begin
89916>                            Send SetTheTheme eTheme
89917>                            Function_Return i
89918>                        End
89918>                    Loop
89919>                    Function_Return 0
89920>                End_Function
89921>
89921>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
89924>                    Integer iCount
89924>                    Get ComListCount of hoCombo to iCount
89925>                    Increment iCount
89926>                    Send ComAddItem  of hoCombo sText iCount
89927>                    Set ComItemData  of hoCombo iCount to  eTheme
89928>                End_Procedure
89929>
89929>                Procedure FillComboList Handle hoCombo
89932>                    Send ComClear     of hoCombo
89933>                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
89934>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
89935>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
89936>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
89937>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
89938>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
89939>                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
89940>                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
89941>                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
89942>                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
89943>
89943>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
89944>                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
89945>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
89946>
89946>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
89947>                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
89948>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
89949>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
89950>
89950>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
89951>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
89952>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
89953>
89953>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
89954>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
89955>
89955>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
89956>                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
89957>
89957>                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
89958>
89958>                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
89959>
89959>                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
89960>                End_Procedure
89961>
89961>                Function CurrentTheme Handle vCommandBarControl Returns Integer
89964>                    Handle hMessage hoCombo
89964>                    Integer iIndex
89964>                    // create and bind  proxy control
89964>                    Get CreateProxyControl vCommandBarControl to hoCombo
89965>                    // get the current selection
89965>                    Get ComListIndex of hoCombo to iIndex
89966>                    // note the index selections are 1 based
89966>                    If (iIndex > 0) Begin
89968>                        // get the ItemData for the selected item and send that message
89968>                        Get ComItemData of hoCombo iIndex to hMessage
89969>                        Function_Return hMessage
89970>                    End
89970>                    // dispose of the proxy control
89970>                    Send Destroy of hoCombo
89971>                    Function_Return 0
89972>                End_Function
89973>
89973>                Procedure OnExecute Variant vCommandBarControl
89976>                    Integer eTheme
89976>                    Integer iColor
89976>                    Get CurrentTheme vCommandBarControl to eTheme
89977>                    Set peVisualTheme of ghoCommandBars to eTheme
89978>                    Send ComRecalcLayout of ghoCommandBars
89979>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
89980>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
89982>                End_Procedure
89983>
89983>                Procedure SetTheTheme Integer eTheme
89986>                    Integer iColor
89986>                    Set peVisualTheme of ghoCommandBars to eTheme
89987>                    Send ComRecalcLayout of ghoCommandBars
89988>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
89989>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
89991>                End_Procedure
89992>
89992>                Function ConvertSystemColor Integer iColor Returns Integer
89995>                    Integer iSysColor
89995>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
89997>                        Move clNone to iColor
89998>                    End
89998>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
90001>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
90002>                        Move (GetSysColor(iSysColor)) to iColor
90003>                    End
90003>                    Function_Return iColor
90004>                End_Function
90005>
90005>            End_Object
90006>
90006>//            Object oSkin_tb is a cCJMenuItem
90006>//                Set peControlType to xtpControlLabel
90006>//                Set psCaption to "Skin:"
90006>//                Set pbControlBeginGroup to True
90006>//            End_Object
90006>//
90006>//            Object oSkinSelector_cf is a cSkinComboBoxCJMenuItem
90006>//                Set psToolTip to "Select a skin to change the appearance of the application. Either select a Theme OR a Skin, not both."
90006>//            End_Object
90006>//
90006>//            #IF (!@ >= 190)
90006>//            #ENDIF
90006>
90006>            Object oAbout_MenuItem is a cCJMenuItem
90008>                Set psCaption to "About"
90009>                Set psToolTip to "About Info"
90010>                Set psDescription to "About the program"
90011>                Set psImage to "ActionAbout1.ico"
90012>                Set pbControlBeginGroup to True
90013>                Procedure OnExecute Variant vCommandBarControl
90016>                    Forward Send OnExecute vCommandBarControl
90018>                    Send Activate_About of (Client_Id(ghoCommandBars))
90019>                End_Procedure
90020>            End_Object
90021>
90021>            Object oHelpMenuItem is a cCJHelpMenuItem
90023>                Set peControlType to xtpControlSplitButtonPopup
90024>                Set psImage to "ActionHelp1.ico"
90025>
90025>                Procedure OnExecute Variant vCommandBarControl
90028>                    Forward Send OnExecute vCommandBarControl
90030>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
90031>                    Send ShowProgramHelp
90032>                End_Procedure
90033>
90033>                Object oHelpMenuItemLocal is a cCJMenuItem
90035>                    Set psCaption to "Local HTML Help"
90036>                    Set psImage to "ActionHelp1.ico"
90037>                    Procedure OnExecute Variant vCommandBarControl
90040>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
90041>                        Send ShowProgramHelp
90042>                    End_Procedure
90043>                End_Object
90044>
90044>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
90046>                    Set psCaption to "Internet Online HTML Help"
90047>                    Set psImage to "ActionHelp1.ico"
90048>                    Procedure OnExecute Variant vCommandBarControl
90051>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
90052>                    End_Procedure
90053>
90053>                End_Object
90054>            End_Object
90055>
90055>            Object oExitMenuItem is a cCJExitMenuItem
90057>                Set psImage to "ActionExit1.ico"
90058>                Set psToolTip to "Exit application"
90059>                Set psDescription to "Exit the program (Alt+F4)"
90060>                Set pbControlBeginGroup to True
90061>            End_Object
90062>        End_Object
90063>
90063>//        Object oSpacerBar is a cCJToolbar
90063>//            Set pbDockNextTo to False
90063>//            Set pbShowExpandButton to False
90063>//            Set pbGripper to False
90063>//            Set peStretched to stStretch
90063>//            Set pbCustomizable to False
90063>//            Set pbCloseable to False
90063>//            Set pbEnableDocking to False
90063>//            Set pbHideWrap to True
90063>//
90063>//            Object oFiller is a cCJMenuItem
90063>//            End_Object
90063>//
90063>//        End_Object
90063>
90063>        Object oStatusBar is a cCJStatusBar
90065>
90065>            Object oStatusPane1 is a cCJStatusBarPane
90067>                Set piID to sbpIDIdlePane
90068>                Set pbStyleStretch to True
90069>            End_Object
90070>            Object oStatusPane2 is a cCJStatusBarPane
90072>                Set phoViewPane to Self
90073>                Set pbStyleStretch to True
90074>            End_Object
90075>
90075>        End_Object
90076>
90076>    End_Object
90077>
90077>    Object oClientArea is a ClientArea
90079>
90079>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
90079>
90079>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
90079>>>//************************************************************************
90079>>>// Confidential Trade Secret.
90079>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
90079>>>// as an unpublished work.  All rights reserved.
90079>>>// DataFlex is a registered trademark of Data Access Corporation.
90079>>>//
90079>>>//************************************************************************
90079>>>//************************************************************************
90079>>>//
90079>>>// $File name  : StdAbout.pkg
90079>>>// $File title : Standard about object package for VDF
90079>>>// Notice      :
90079>>>// $Author(s)  : John Tuohy
90079>>>//
90079>>>// $Rev History
90079>>>//
90079>>>// JT 06/27/97   File created
90079>>>//************************************************************************
90079>>>
90079>>>// This provides a quick and simple way to create an about package for a program.
90079>>>// You need to create a message inside you client area called Activate_About.
90079>>>// Within this message you should send the message DoAbout passing needed
90079>>>// string information.
90079>>>//
90079>>>//       Procedure Activate_About
90079>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
90079>>>//       End_Procedure
90079>>>//    where: sTitle =     Name of application. If none provided, uses caption
90079>>>//                        bar title
90079>>>//           sVersion   = Version Line. If none provided, will be blank
90079>>>//           sCopyRight = Copyright Line. If none provided, will be blank
90079>>>//           sAuthor    = Author name, blank if none provided
90079>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
90079>>>//                        is used.
90079>>>// It is expected that you will place this in your own object package. For
90079>>>// example an order about package may look like this:
90079>>>//
90079>>>//   // OrderAbout.pkg
90079>>>//   Use StdAbout.pkg
90079>>>//   Procedure Activate_About
90079>>>//      String sTitle sCopyright sVersion sAuthor
90079>>>//      Move "My Order Entry System" to sTitle
90079>>>//      Move "Version 2.1" to sVersion
90079>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
90079>>>//      Move "John Smith"  to sAuthor
90079>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
90079>>>//   end_procedure
90079>>>//   // end of file.
90079>>>
90079>>>Use DfAbout.pkg
90079>>>
90079>>>// *************************************************************************
90079>>>//  Public message. This is the default message. It is expected that you will
90079>>>//   create your own message to override this
90079>>>// *************************************************************************
90079>>>
90079>>>Procedure Activate_About
90082>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
90083>>>End_Procedure
90084>>>
90084>>>// *************************************************************************
90084>>>//  Public message. It is expected that you will send this message (most
90084>>>//  likely from Activate_About. This creates an about object, activates it
90084>>>//  and destroys it when done. It is not exepected that you will augment this.
90084>>>// *************************************************************************
90084>>>// Sample usage:
90084>>>//   The first two params will automatically be filled from the application settings if not provided.
90084>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
90084>>>
90084>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
90087>>>    Integer hoObj hoMain iArgs
90087>>>    String sValue
90087>>>
90087>>>    // Create object
90087>>>    Object About is an AboutDialog
90089>>>    // Uncomment these two lines if you would like to have a resizable About object.
90089>>>    //            Set Border_Style to Border_Thick
90089>>>    //            Set peAnchors to anAll
90089>>>
90089>>>    // Add checking for the number of arguments passed to avoid runtime errors
90089>>>    // if one of them is not passed. This makes the interface
90089>>>    // more flexible.
90089>>>        Move num_arguments to iArgs
90090>>>
90090>>>        // If no title is passed use the label of the main panel (if a main panel exists).
90090>>>        If (iArgs > 0 and sTitle = "") Begin
90092>>>            Get Main_Window of Desktop to hoMain
90093>>>            If hoMain Begin
90095>>>                Get Label of hoMain to sValue
90096>>>            End
90096>>>>
90096>>>        End
90096>>>>
90096>>>        Else If (iArgs > 0 and sTitle <> "") Begin
90099>>>            Move sTitle to sValue
90100>>>        End
90100>>>>
90100>>>        Else If (iArgs = 0) Begin
90103>>>            Get Main_Window of Desktop to hoMain
90104>>>            If hoMain Begin
90106>>>                Get Label of hoMain to sValue
90107>>>            End
90107>>>>
90107>>>        End
90107>>>>
90107>>>
90107>>>        If (sValue <> "") Begin
90109>>>            Send Add_LineLn sValue
90110>>>        End
90110>>>>
90110>>>        Move "" to sValue
90111>>>
90111>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
90111>>>        // For this to work the Project Properties Version must have been set in the Studio.
90111>>>        If (iArgs < 2) Begin
90113>>>            Move "" to sValue
90114>>>        End
90114>>>>
90114>>>        Else Begin
90115>>>            Move sVersion to sValue
90116>>>        End
90116>>>>
90116>>>        Set Version to sValue
90117>>>
90117>>>        If (iArgs > 2 and sCopyRight <> "") Begin
90119>>>            Send Add_LineLn sCopyRight
90120>>>        End
90120>>>>
90120>>>
90120>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
90120>>>        // else we do.
90120>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
90122>>>            Send Add_Line sAuthor
90123>>>        End
90123>>>>
90123>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
90126>>>            Send Add_LineLn sAuthor
90127>>>        End
90127>>>>
90127>>>
90127>>>        // Square bitmaps of 80x80 works best
90127>>>        If (iArgs > 4 and sBitmap <> "") Begin
90129>>>            Set Logo to sBitMap
90130>>>        End
90130>>>>
90130>>>
90130>>>        // Here starts handling of the five optional params:
90130>>>        If (iArgs = 6 and sParam6  <> "") Begin
90132>>>            Send Add_Line sParam6
90133>>>        End
90133>>>>
90133>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
90136>>>            Send Add_LineLn sParam6
90137>>>        End
90137>>>>
90137>>>
90137>>>        If (iArgs = 7 and sParam7  <> "") Begin
90139>>>            Send Add_Line sParam7
90140>>>        End
90140>>>>
90140>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
90143>>>            Send Add_LineLn sParam7
90144>>>        End
90144>>>>
90144>>>
90144>>>        If (iArgs = 8 and sParam8  <> "") Begin
90146>>>            Send Add_Line sParam8
90147>>>        End
90147>>>>
90147>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
90150>>>            Send Add_LineLn sParam8
90151>>>        End
90151>>>>
90151>>>
90151>>>        If (iArgs = 9 and sParam9  <> "") Begin
90153>>>            Send Add_Line sParam9
90154>>>        End
90154>>>>
90154>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
90157>>>            Send Add_LineLn sParam9
90158>>>        End
90158>>>>
90158>>>
90158>>>        If (iArgs = 10 and sParam10 <> "") Begin
90160>>>            Send Add_Line sParam10
90161>>>        End
90161>>>>
90161>>>
90161>>>        Move Self to hoObj
90162>>>    End_Object
90163>>>
90163>>>    Send Popup   of hoObj // Popup the about object
90164>>>    Send Destroy of hoObj // When done, it will be destroyed
90165>>>End_Procedure
90166>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
90166>>>Use Windows.pkg
90166>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridPromptList.pkg)
90166>>>>>Use Windows.pkg
90166>>>>>Use cCJGrid.pkg
90166>>>>>
90166>>>>>
90166>>>>>
90166>>>>>Class cCJGridPromptList is a cCJGrid
90167>>>>>    
90167>>>>>    Procedure Construct_Object
90169>>>>>        Forward Send Construct_Object
90171>>>>>        
90171>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
90172>>>>>        Property Boolean Private_pbAutoOrdering True
90173>>>>>        Property Boolean pbAutoSearch True  // pops up search window
90174>>>>>        Property Integer peUpdateMode umPromptValue
90175>>>>>        Property Integer piUpdateColumn 0
90176>>>>>        Property Integer piInitialColumn -1
90177>>>>>        Property String  psSeedValue ''
90178>>>>>        Property Handle phmPromptUpdateCallback 0
90179>>>>>        Property Integer phoInvokingObject
90180>>>>>        
90180>>>>>        Property Boolean pbStoredAutoSeed
90181>>>>>        Property Boolean pbStoredAutoOrdering
90182>>>>>        Property Boolean pbStoredAutoSearch
90183>>>>>        Property Integer peStoredUpdateMode
90184>>>>>        Property Integer piStoredUpdateColumn
90185>>>>>        Property Integer piStoredInitialColumn
90186>>>>>        Property Handle  phmStoredPromptUpdateCallback
90187>>>>>        Property Boolean pbStoredSelectionEnable
90188>>>>>        Property Boolean pbStoredMultipleSelection
90189>>>>>        
90189>>>>>        // internally set by list
90189>>>>>        // these must be set upon closing the list and can be used for manual list updates
90189>>>>>        Property Boolean pbCanceled
90190>>>>>        Property Integer[] pSelectedRows
90191>>>>>        
90191>>>>>        Property Boolean pbNeedsNewOrdering
90192>>>>>        Property Boolean pbRequestSearch
90193>>>>>        Property tGridKeyPair[] pSearchKeys
90194>>>>>        
90194>>>>>        // these properties makes a prompt list a prompt list
90194>>>>>        // and should not be changed.
90194>>>>>        Set pbEditOnKeyNavigation to False
90195>>>>>        Set pbEditOnClick to False
90196>>>>>        Set pbReadOnly to True
90197>>>>>        Set pbFocusSubItems to True
90198>>>>>        
90198>>>>>        // these could maybe be changed
90198>>>>>        Set pbShadeSortColumn to True
90199>>>>>        Set pbHeaderReorders to True
90200>>>>>        Set pbHeaderTogglesDirection to True
90201>>>>>        Set pbHeaderSelectsColumn to True
90202>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
90203>>>>>        Set piFocusCellBackColor to clNone
90204>>>>>        Set piFocusCellForeColor to clNone
90205>>>>>        Set piFocusCellRectangleColor to clBlack
90206>>>>>        Set pbUseFocusCellRectangle to False
90207>>>>>        Set pbSelectionEnable to True
90208>>>>>        
90208>>>>>        On_Key kEnter Send Ok
90209>>>>>        On_Key kCancel Send Cancel
90210>>>>>        
90210>>>>>    End_Procedure
90211>>>>>    
90211>>>>>    // reorder list automatically on column change
90211>>>>>    // this also set pbFocusSubItems which is required to make the two states work
90211>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
90213>>>>>        Set Private_pbAutoOrdering to bAutoOrder
90214>>>>>        Set pbFocusSubItems to bAutoOrder
90215>>>>>    End_Procedure
90216>>>>>    
90216>>>>>    Function pbAutoOrdering Returns Boolean
90218>>>>>        Boolean bAutoOrder
90218>>>>>        Get Private_pbAutoOrdering to bAutoOrder
90219>>>>>        Function_Return bAutoOrder
90220>>>>>    End_Function
90221>>>>>    
90221>>>>>    // augmented to handle auto-ordering and invoking the search popup list
90221>>>>>    Procedure OnIdle
90223>>>>>        Boolean bNeedsReorder bSearch bOldToggle
90223>>>>>        Handle hoCol
90223>>>>>        Integer iKy1 iKy2 iCol
90223>>>>>        
90223>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
90224>>>>>        If bNeedsReorder Begin
90226>>>>>            Get SelectedColumn to iCol
90227>>>>>            If (iCol<>-1) Begin
90229>>>>>                
90229>>>>>                Get pbHeaderTogglesDirection to bOldToggle
90230>>>>>                Set pbHeaderTogglesDirection to False
90231>>>>>                Send HeaderReorder iCol
90232>>>>>                Set pbHeaderTogglesDirection to bOldToggle
90233>>>>>                
90233>>>>>                Set pbNeedsNewOrdering to False
90234>>>>>            End
90234>>>>>>
90234>>>>>        End
90234>>>>>>
90234>>>>>        
90234>>>>>        Get pbRequestSearch to bSearch
90235>>>>>        If bSearch Begin
90237>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
90238>>>>>        End
90238>>>>>>
90238>>>>>        
90238>>>>>        Forward Send OnIdle
90240>>>>>    End_Procedure
90241>>>>>    
90241>>>>>    Procedure OnStoreDefaults
90243>>>>>        Integer iVal
90243>>>>>        Boolean bVal
90243>>>>>        
90243>>>>>        Get pbAutoSeed to bVal
90244>>>>>        Set pbStoredAutoSeed to bVal
90245>>>>>        
90245>>>>>        Get pbAutoOrdering to bVal
90246>>>>>        Set pbStoredAutoOrdering to bVal
90247>>>>>        
90247>>>>>        Get pbAutoSearch to bVal
90248>>>>>        Set pbStoredAutoSearch to bVal
90249>>>>>        
90249>>>>>        Get peUpdateMode to iVal
90250>>>>>        Set peStoredUpdateMode to iVal
90251>>>>>        
90251>>>>>        Get piUpdateColumn to iVal
90252>>>>>        Set piStoredUpdateColumn to iVal
90253>>>>>        
90253>>>>>        Get piInitialColumn to iVal
90254>>>>>        Set piStoredInitialColumn to iVal
90255>>>>>        
90255>>>>>        Get phmPromptUpdateCallback to iVal
90256>>>>>        Set phmStoredPromptUpdateCallback to iVal
90257>>>>>        
90257>>>>>        Get pbSelectionEnable to bVal
90258>>>>>        Set pbStoredSelectionEnable to bVal
90259>>>>>        
90259>>>>>        Get pbMultipleSelection to bVal
90260>>>>>        Set pbStoredMultipleSelection to bVal
90261>>>>>        
90261>>>>>    End_Procedure
90262>>>>>    
90262>>>>>    Procedure OnRestoreDefaults
90264>>>>>        Integer iVal
90264>>>>>        Boolean bVal
90264>>>>>        
90264>>>>>        Get pbStoredAutoSeed to bVal
90265>>>>>        Set pbAutoSeed to bVal
90266>>>>>        
90266>>>>>        Get pbStoredAutoOrdering to bVal
90267>>>>>        Set pbAutoOrdering to bVal
90268>>>>>        
90268>>>>>        Get pbStoredAutoSearch to bVal
90269>>>>>        Set pbAutoSearch to bVal
90270>>>>>        
90270>>>>>        Get peStoredUpdateMode to iVal
90271>>>>>        Set peUpdateMode to iVal
90272>>>>>        
90272>>>>>        Get piStoredInitialColumn to iVal
90273>>>>>        Set piInitialColumn to iVal
90274>>>>>        
90274>>>>>        Get phmStoredPromptUpdateCallback to iVal
90275>>>>>        Set phmPromptUpdateCallback to iVal
90276>>>>>        
90276>>>>>        Get pbStoredSelectionEnable to bVal
90277>>>>>        Set pbSelectionEnable to bVal
90278>>>>>        
90278>>>>>        Get pbStoredMultipleSelection to bVal
90279>>>>>        Set pbMultipleSelection to bVal
90280>>>>>        
90280>>>>>    End_Procedure
90281>>>>>    
90281>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
90281>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
90281>>>>>    // Suitable for augmentation
90281>>>>>    Procedure OnSeedData
90283>>>>>        Integer iUpdateColumn iSortColumn
90283>>>>>        Boolean bSeed bAuto
90283>>>>>        String sValue
90283>>>>>        Handle hoCol
90283>>>>>        
90283>>>>>        Get piUpdateColumn to iUpdateColumn
90284>>>>>        Get psSeedValue to sValue
90285>>>>>        Get pbAutoSeed to bSeed
90286>>>>>        Get piSortColumn to iSortColumn
90287>>>>>        Get pbAutoOrdering to bAuto
90288>>>>>        // if not yet sorted and this is auto ordering we will
90288>>>>>        // sort the data for the search column. We do this to make the
90288>>>>>        // column search GE logic work properly.
90288>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
90290>>>>>            Get ColumnObject iUpdateColumn to hoCol
90291>>>>>            Send SortGridByColumn hoCol False
90292>>>>>        End
90292>>>>>>
90292>>>>>        
90292>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
90294>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
90295>>>>>        End
90295>>>>>>
90295>>>>>        Else Begin
90296>>>>>            Send MovetoFirstRow
90297>>>>>        End
90297>>>>>>
90297>>>>>        
90297>>>>>    End_Procedure
90298>>>>>    
90298>>>>>    Procedure OnMoveValueOutByValue
90300>>>>>        String sValue
90300>>>>>        Handle hoInvokingObject hoCol  hoDataSource
90300>>>>>        Integer iRow iCol
90300>>>>>        Integer[] SelRowsIndexes
90301>>>>>        
90301>>>>>        Get phoInvokingObject to hoInvokingObject
90302>>>>>        Get pSelectedRows to SelRowsIndexes
90303>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
90305>>>>>            Get piUpdateColumn to iCol
90306>>>>>            Get ColumnObject iCol to hoCol
90307>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
90308>>>>>            Set Value of hoInvokingObject to sValue
90309>>>>>            Set Item_Changed_State of hoInvokingObject to True
90310>>>>>        End
90310>>>>>>
90310>>>>>    End_Procedure
90311>>>>>    
90311>>>>>    Procedure OnMoveValueOutByCustom
90313>>>>>    End_Procedure
90314>>>>>    
90314>>>>>    // augment to popup a search window when allowed
90314>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
90316>>>>>        Boolean bSubFocus bAutoSearch bChar
90316>>>>>        Integer iVal
90316>>>>>        
90316>>>>>        Get pbFocusSubItems to bSubFocus
90317>>>>>        Get pbAutoSearch to bAutoSearch
90318>>>>>        Forward Send OnComKeyDown llKeyCode llShift
90320>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
90322>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
90324>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
90325>>>>>                Move (iVal<>0) to bChar
90326>>>>>            End
90326>>>>>>
90326>>>>>            If bChar Begin
90328>>>>>                // this can get called multiple times before a search dialog pops up
90328>>>>>                Send AddToSearchKeys llKeyCode llShift
90329>>>>>            End
90329>>>>>>
90329>>>>>        End
90329>>>>>>
90329>>>>>    End_Procedure
90330>>>>>    
90330>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
90332>>>>>        Boolean bAutoSearch
90332>>>>>        Integer iKeyCode iShiftCode
90332>>>>>        Get pbAutoSearch to bAutoSearch
90333>>>>>        If bAutoSearch Begin
90335>>>>>            // this can get called multiple times before a search dialog pops up
90335>>>>>            Get piLastKey to iKeyCode
90336>>>>>            Get piLastKey2 to iShiftCode
90337>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
90338>>>>>        End
90338>>>>>>
90338>>>>>        Move True to llCancel
90339>>>>>    End_Procedure
90340>>>>>    
90340>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
90342>>>>>        Send ClearSearchRequest // kill any deferred search popup
90343>>>>>        Forward Send OnComRowDblClick llRow llItem
90345>>>>>    End_Procedure
90346>>>>>    
90346>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
90348>>>>>        Send Ok
90349>>>>>    End_Procedure
90350>>>>>    
90350>>>>>    
90350>>>>>    // we don't want a menu for prompt lists
90350>>>>>    Function CreateContextMenu Returns Handle
90352>>>>>        Function_Return 0
90353>>>>>    End_Function
90354>>>>>    
90354>>>>>    // if we use auto-ordering, change the order when the column changes
90354>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
90356>>>>>        Boolean bAutoOrder
90356>>>>>        Forward Send ColumnChanged iOld iNew
90358>>>>>        Get pbAutoOrdering to bAutoOrder
90359>>>>>        If bAutoOrder Begin
90361>>>>>            // will be reordered in idle event
90361>>>>>            Set pbNeedsNewOrdering to True
90362>>>>>        End
90362>>>>>>
90362>>>>>    End_Procedure
90363>>>>>    
90363>>>>>    
90363>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
90365>>>>>        Integer eMode
90365>>>>>        Integer[] SelRowsIndexes
90366>>>>>        Set pbCanceled to True // assume cancel unless changed
90367>>>>>        Set pSelectedRows to SelRowsIndexes // empty
90368>>>>>        Get peUpdateMode to eMode
90369>>>>>        If (eMode<>umPromptNonInvoking) Begin
90371>>>>>            Send OnStoreDefaults
90372>>>>>        End
90372>>>>>>
90372>>>>>        Send InitializePromptList
90373>>>>>        Forward Send Add_Focus hoParent
90375>>>>>        Send LoadData
90376>>>>>        Set psSeedValue to ""
90377>>>>>    End_Procedure
90378>>>>>    
90378>>>>>    // called before the list is activated.
90378>>>>>    Procedure InitializePromptList
90380>>>>>        Integer hoInvokingObject
90380>>>>>        Boolean bAutoColumn bAutoSeed
90380>>>>>        Integer i iOldMode eUpdateMode
90380>>>>>        String sValue
90380>>>>>        
90380>>>>>        Get peUpdateMode to eUpdateMode
90381>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
90383>>>>>            Get Focus of Desktop to hoInvokingObject
90384>>>>>            If (hoInvokingObject<=Desktop) Begin
90386>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
90387>>>>>>
90387>>>>>                Procedure_Return
90388>>>>>            End
90388>>>>>>
90388>>>>>            
90388>>>>>            Set phoInvokingObject to hoInvokingObject
90389>>>>>            
90389>>>>>            Send Prompt_Callback to hoInvokingObject Self
90390>>>>>            Get peUpdateMode to eUpdateMode
90391>>>>>        End
90391>>>>>>
90391>>>>>        
90391>>>>>        Send ClearSearchRequest // clear the search keys
90392>>>>>        Set pbNeedsNewOrdering to False
90393>>>>>        
90393>>>>>        Get pbAutoSeed to bAutoSeed
90394>>>>>        
90394>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
90396>>>>>            Get Value of hoInvokingObject to sValue
90397>>>>>            Set psSeedValue to sValue
90398>>>>>        End
90398>>>>>>
90398>>>>>        
90398>>>>>    End_Procedure
90399>>>>>    
90399>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
90399>>>>>    Procedure LoadData
90401>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
90401>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
90401>>>>>        Integer eUpdateMode
90401>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
90401>>>>>        
90401>>>>>        Get phoDataSource to hoDataSource
90402>>>>>        Get peUpdateMode to eUpdateMode
90403>>>>>        Get phoInvokingObject to hoInvokingObject
90404>>>>>        Get pbAutoSeed to bAutoSeed
90405>>>>>        Get piInitialColumn to iInitialColumn
90406>>>>>        Get piUpdateColumn to iUpdateColumn
90407>>>>>        Get RowCount of hoDataSource to iRows
90408>>>>>        
90408>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
90408>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
90408>>>>>        If (iInitialColumn=-1) Begin
90410>>>>>            Move iUpdateColumn to iInitialColumn
90411>>>>>        End
90411>>>>>>
90411>>>>>        If (iInitialColumn>=0) Begin
90413>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
90414>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
90415>>>>>        End
90415>>>>>>
90415>>>>>        Send OnSeedData // find a good starting place for the row
90416>>>>>        Get pbFocusSubItems to bSubFocus
90417>>>>>        If bSubFocus Begin
90419>>>>>            // if column focus, which is normal, go to initialcolumn
90419>>>>>            If hoInitialColumn Begin
90421>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
90422>>>>>            End
90422>>>>>>
90422>>>>>            Else Begin
90423>>>>>                Send MoveToFirstEnterableColumn
90424>>>>>            End
90424>>>>>>
90424>>>>>        End
90424>>>>>>
90424>>>>>        
90424>>>>>    End_Procedure
90425>>>>>    
90425>>>>>    // This is only called in a successful close
90425>>>>>    Procedure ClosePromptList
90427>>>>>        Handle hoDataSource hoInvokingObject
90427>>>>>        Handle hmCallBack
90427>>>>>        Integer iRow eUpdateMode
90427>>>>>        Integer[] SelRowsIndexes
90428>>>>>        
90428>>>>>        Get phoDataSource to hoDataSource
90429>>>>>        Get phoInvokingObject to hoInvokingObject
90430>>>>>        
90430>>>>>        If (pbMultipleSelection(Self)) Begin
90432>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
90433>>>>>        End
90433>>>>>>
90433>>>>>        Else Begin
90434>>>>>            Get SelectedRow of hoDataSource to iRow
90435>>>>>            If (iRow<>-1) Begin
90437>>>>>                Move iRow to SelRowsIndexes[0]
90438>>>>>            End
90438>>>>>>
90438>>>>>        End
90438>>>>>>
90438>>>>>        
90438>>>>>        Set pbCanceled to False
90439>>>>>        Set pSelectedRows to SelRowsIndexes
90440>>>>>        
90440>>>>>        Get peUpdateMode to eUpdateMode
90441>>>>>        // if non-invoking there is by definition, no move value out
90441>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
90443>>>>>            
90443>>>>>            If (eUpdateMode=umPromptValue) Begin
90445>>>>>                Send OnMoveValueOutByValue
90446>>>>>            End
90446>>>>>>
90446>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
90449>>>>>                Send OnMoveValueOutByCustom
90450>>>>>            End
90450>>>>>>
90450>>>>>            Get phmPromptUpdateCallback to hmCallBack
90451>>>>>            If hmCallBack Begin
90453>>>>>                Send hmCallBack of hoInvokingObject Self
90454>>>>>            End
90454>>>>>>
90454>>>>>        End
90454>>>>>>
90454>>>>>        
90454>>>>>        Send Close_Panel
90455>>>>>    End_Procedure
90456>>>>>    
90456>>>>>    // augment to send OnRestoreDefaults.
90456>>>>>    Procedure Release_Focus
90458>>>>>        Integer eUpdateMode
90458>>>>>        Get peUpdateMode to eUpdateMode
90459>>>>>        Forward Send Release_Focus
90461>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
90463>>>>>            Send OnRestoreDefaults
90464>>>>>        End
90464>>>>>>
90464>>>>>    End_Procedure
90465>>>>>    
90465>>>>>    Function SelectedRowIds Returns RowID[]
90467>>>>>        RowID[] SelectedRowids
90468>>>>>        Integer[] SelectedRows
90469>>>>>        Integer i iRows
90469>>>>>        Handle hoDataSource
90469>>>>>        Get phoDataSource to hoDataSource
90470>>>>>        Get pSelectedRows to SelectedRows
90471>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
90472>>>>>        For i from 0 to (iRows-1)
90478>>>>>>
90478>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
90479>>>>>        Loop
90480>>>>>>
90480>>>>>        Function_Return SelectedRowids
90481>>>>>    End_Function
90482>>>>>    
90482>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
90484>>>>>        String[] SelectedValues
90485>>>>>        Integer[] SelectedRows
90486>>>>>        Integer i iRows
90486>>>>>        Handle hoCol
90486>>>>>        Get ColumnObject iCol to hoCol
90487>>>>>        Get pSelectedRows to SelectedRows
90488>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
90489>>>>>        For i from 0 to (iRows-1)
90495>>>>>>
90495>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
90496>>>>>        Loop
90497>>>>>>
90497>>>>>        Function_Return SelectedValues
90498>>>>>    End_Function
90499>>>>>    
90499>>>>>    Procedure Ok Returns Integer
90501>>>>>        Send ClosePromptList
90502>>>>>    End_Procedure
90503>>>>>    
90503>>>>>    Procedure Cancel Returns Integer
90505>>>>>        Send Close_Panel
90506>>>>>    End_Procedure
90507>>>>>    
90507>>>>>    Procedure Search
90509>>>>>        Send Activate // give focus back to list so focus things are correct
90510>>>>>        Send Request_Search 0 0
90511>>>>>    End_Procedure
90512>>>>>    
90512>>>>>    // do a search using the current keys in the search key buffer for the sort column.
90512>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
90512>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
90512>>>>>    Procedure Request_SearchEx
90514>>>>>        tGridKeyPair[] Keys
90514>>>>>        tGridKeyPair[] Keys
90515>>>>>        Integer iCol
90515>>>>>        Handle hoCol hoSearchDialog
90515>>>>>        Boolean bOk
90515>>>>>        String sValue
90515>>>>>        
90515>>>>>        Get piSortColumn to iCol
90516>>>>>        If (iCol<>-1) Begin
90518>>>>>            Get ColumnObject iCol to hoCol
90519>>>>>            Get pSearchKeys to Keys
90520>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
90521>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
90522>>>>>            If bOk Begin
90524>>>>>                Send RequestFindColumnValue iCol sValue True 0
90525>>>>>            End
90525>>>>>>
90525>>>>>            Send Destroy of hoSearchDialog
90526>>>>>        End
90526>>>>>>
90526>>>>>        Send ClearSearchRequest // clear the search keys
90527>>>>>    End_Procedure
90528>>>>>    
90528>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
90528>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
90530>>>>>        tGridKeyPair[] Keys
90530>>>>>        tGridKeyPair[] Keys
90531>>>>>        tGridKeyPair KeyPair
90531>>>>>        tGridKeyPair KeyPair
90531>>>>>        Set pbRequestSearch to True
90532>>>>>        Move iKeyCode to KeyPair.KeyCode
90533>>>>>        Move iShiftCode to KeyPair.ShiftCode
90534>>>>>        Get pSearchKeys to Keys
90535>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
90536>>>>>        Set pSearchKeys to Keys
90537>>>>>    End_Procedure
90538>>>>>    
90538>>>>>    Procedure ClearSearchRequest
90540>>>>>        tGridKeyPair[] SearchKeys
90540>>>>>        tGridKeyPair[] SearchKeys
90541>>>>>        Set pSearchKeys to SearchKeys
90542>>>>>        Set pbRequestSearch to False
90543>>>>>    End_Procedure
90544>>>>>    
90544>>>>>End_Class
90545>>>>>
90545>>>Use cDbUpdateFunctionLibrary.pkg
90545>>>Use MSSqldrv.pkg
90545>>>Use db2_drv.pkg
90545>>>Use odbc_drv.pkg
90545>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
90545>>>>>//****************************************************************************
90545>>>>>// $Module type: Class
90545>>>>>// $Module name: cRDCModalPanel
90545>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
90545>>>>>// Created     : 2014-03-17 @ 12:33
90545>>>>>//
90545>>>>>// Description :
90545>>>>>//
90545>>>>>// $Rev History:
90545>>>>>//    2014-03-17  Module header created
90545>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
90545>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
90545>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
90545>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
90545>>>>>// in the help folder for more details.
90545>>>>>//
90545>>>>>//****************************************************************************
90545>>>>>Use Windows.pkg
90545>>>>>Use cCJCommandBarSystem.pkg   
90545>>>>>Use cCJSkinFramework.pkg
90545>>>>>
90545>>>>>Class cRDCModalPanel is a ModalPanel
90546>>>>>
90546>>>>>    Procedure Construct_Object
90548>>>>>        Forward Send Construct_Object
90550>>>>>
90550>>>>>        Set Maximize_Icon to True
90551>>>>>        Set Minimize_Icon to False
90552>>>>>        Set Border_Style to Border_Thick
90553>>>>>        Set Locate_Mode to Center_On_Parent
90554>>>>>
90554>>>>>        Property String Private_Icon
90555>>>>>        Property Handle phoDialogCommandbar
90556>>>>>    End_Procedure
90557>>>>>
90557>>>>>    Procedure Set Icon String sIcon
90559>>>>>        Forward Set Icon to sIcon
90561>>>>>        Set Private_Icon to sIcon
90562>>>>>    End_Procedure
90563>>>>>
90563>>>>>    Function Icon Returns String
90565>>>>>        String sIcon
90565>>>>>        Get Private_Icon to sIcon
90566>>>>>        Function_Return sIcon
90567>>>>>    End_Function
90568>>>>>
90568>>>>>    Procedure Page Integer iPageObject
90570>>>>>        String sIcon
90570>>>>>        Integer hWnd
90570>>>>>        
90570>>>>>        Forward Send Page iPageObject
90572>>>>>        Get Private_Icon to sIcon
90573>>>>>        If (sIcon <> "") Begin
90575>>>>>            Set Icon to sIcon
90576>>>>>        End
90576>>>>>>
90576>>>>>
90576>>>>>        Get Window_Handle to hWnd
90577>>>>>
90577>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
90579>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
90580>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
90581>>>>>        End
90581>>>>>>
90581>>>>>    End_Procedure
90582>>>>>
90582>>>>>    // Put a status bar at the bottom of the panel, which makes
90582>>>>>    // status_help work and puts a gripper in the lower right corner.
90582>>>>>    Procedure End_Construct_Object
90584>>>>>        Integer iStyle iSize iOffset
90584>>>>>
90584>>>>>        Forward Send End_Construct_Object
90586>>>>>
90586>>>>>        Get Border_Style to iStyle
90587>>>>>        Move 8 to iOffset
90588>>>>>        If (iStyle = Border_Thick) Begin
90590>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
90592>>>>>                Object oStatusBar is a cCJStatusBar
90594>>>>>                    Set phoDialogCommandbar to Self
90595>>>>>                    Object oStatusIdle is a cCJStatusBarPane
90597>>>>>                        Set piId to sbpIDIdlePane
90598>>>>>                        Set pbStyleStretch to True
90599>>>>>                    End_Object
90600>>>>>                End_Object
90601>>>>>            End_Object
90602>>>>>            Get Size to iSize
90603>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
90604>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
90605>>>>>        End
90605>>>>>>
90605>>>>>
90605>>>>>    End_Procedure
90606>>>>>
90606>>>>>    Procedure Popup
90608>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
90609>>>>>        Forward Send Popup
90611>>>>>    End_Procedure
90612>>>>>
90612>>>>>End_Class
90613>>>
90613>>>Object oDatabaseSelection_sl is a cRDCModalPanel
90615>>>    Set Label to "SQL Database Selection"
90616>>>    Set Size to 119 183
90617>>>    Set piMinSize to 89 170
90618>>>    Set Location to 2 2
90619>>>    Set Border_Style to Border_Thick
90620>>>    Set Icon to "DatabaseLookup1.ico"
90621>>>
90621>>>    Property String[] psTheData
90623>>>
90623>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
90625>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
90627>>>        End_Object
90628>>>    End
90628>>>>
90628>>>
90628>>>    Object oSelList is a cCJGridPromptList
90630>>>        Set Size to 89 167
90631>>>        Set Location to 6 6
90632>>>        Set peAnchors to anAll
90633>>>        Set pbAllowColumnRemove to False
90634>>>        Set pbUseAlternateRowBackgroundColor to True
90635>>>        Set pbGrayIfDisable to False
90636>>>        Set pbHeaderReorders to False
90637>>>        Set pbHeaderSelectsColumn to False
90638>>>        Set pbHeaderTogglesDirection to False
90639>>>        Set pbShadeSortColumn to False
90640>>>        Set piFocusCellBackColor to clDkGray
90641>>>
90641>>>        Object oName is a cCJGridColumn
90643>>>            Set piWidth to 334
90644>>>            Set psCaption to "Database Name"
90645>>>        End_Object
90646>>>
90646>>>        Procedure Activating
90649>>>            tDataSourceRow[] MyData
90649>>>            tDataSourceRow[] MyData
90650>>>            Handle hoDataSource
90650>>>            String[] sTheData
90651>>>            Integer iCount iSize
90651>>>
90651>>>            Send Cursor_Wait of Cursor_Control
90652>>>            Forward Send Activating
90654>>>
90654>>>            Get psTheData to sTheData
90655>>>            Move (SizeOfArray(sTheData)) to iSize
90656>>>            Decrement iSize
90657>>>            For iCount from 0 to iSize
90663>>>>
90663>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
90664>>>            Loop
90665>>>>
90665>>>
90665>>>            Get phoDataSource to hoDataSource
90666>>>            Send InitializeData of hoDataSource MyData
90667>>>            Send Cursor_Ready of Cursor_Control
90668>>>        End_Procedure
90669>>>
90669>>>    End_Object
90670>>>
90670>>>    Object oOK_Btn is a Button
90672>>>        Set Size to 14 50
90673>>>        Set Label    to "&OK"
90674>>>        Set Location to 98 68
90675>>>        Set peAnchors To anBottomRight
90676>>>
90676>>>        Procedure OnClick
90679>>>            Send Ok of oSelList
90680>>>        End_Procedure
90681>>>
90681>>>    End_Object
90682>>>
90682>>>    Object oCancel_Btn is a Button
90684>>>        Set Size to 14 50
90685>>>        Set Label    to "&Cancel"
90686>>>        Set Location to 98 123
90687>>>        Set peAnchors to anBottomRight
90688>>>
90688>>>        Procedure OnClick
90691>>>            Send Close_Panel
90692>>>        End_Procedure
90693>>>
90693>>>    End_Object
90694>>>
90694>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
90695>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
90696>>>End_Object
90697>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
90697>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
90697>>>Use Windows.pkg
90697>>>Use vWin32fh.pkg
90697>>>
90697>>>Object oSQLDatabaseBackup_dg is a ModalPanel
90699>>>    Set Size to 104 298
90700>>>    Set Label to "SQL Database Backup"
90701>>>    Set piMinSize to 89 211
90702>>>    Set Location to 2 4
90703>>>    Set Border_Style To Border_Thick
90704>>>
90704>>>    Property Boolean pbOK False
90706>>>    Property String  psDatabase
90708>>>    Property String  psPath
90710>>>    Property String  psBackupName
90712>>>
90712>>>    Object oDatabase_fm is a Form
90714>>>        Set Size to 13 204
90715>>>        Set Location to 14 71
90716>>>        Set Label_Justification_Mode to JMode_Right
90717>>>        Set Label_Col_Offset to 2
90718>>>        Set Label to "Database Name"
90719>>>        Set Enabled_State to False
90720>>>        Set peAnchors to anTopLeftRight
90721>>>
90721>>>        Procedure Page Integer iPageObject
90724>>>            String sValue
90724>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
90725>>>            Set Value to sValue
90726>>>            Set psDatabase to sValue
90727>>>            Forward Send Page iPageObject
90729>>>        End_Procedure
90730>>>
90730>>>    End_Object
90731>>>
90731>>>    Object oBackupName_fm is a Form
90733>>>        Set Size to 13 204
90734>>>        Set Location to 29 71
90735>>>        Set Label_Justification_Mode to JMode_Right
90736>>>        Set Label_Col_Offset to 2
90737>>>        Set Label to "Backup Name"
90738>>>        Set peAnchors to anTopLeftRight
90739>>>
90739>>>        Procedure Page Integer iPageObject
90742>>>            String sValue
90742>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
90743>>>            Set Value to sValue
90744>>>            Forward Send Page iPageObject
90746>>>        End_Procedure
90747>>>
90747>>>        Procedure OnChange
90750>>>            String sValue
90750>>>            Get Value to sValue
90751>>>            Set psBackupName to sValue
90752>>>        End_Procedure
90753>>>
90753>>>    End_Object
90754>>>
90754>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
90756>>>        Set Size to 10 50
90757>>>        Set Location to 50 71
90758>>>        Set Label to "Use Default SQL Backup Folder"
90759>>>        Set Checked_State to True
90760>>>
90760>>>        Procedure OnChange
90763>>>            Boolean bChecked
90763>>>            Get Checked_State to bChecked
90764>>>            Set Enabled_State of oPath_fm to (bChecked = False)
90765>>>        End_Procedure
90766>>>
90766>>>    End_Object
90767>>>
90767>>>    Object oPath_fm is a Form
90769>>>        Set Size to 13 204
90770>>>        Set Location to 62 71
90771>>>        Set Label_Justification_Mode to JMode_Right
90772>>>        Set Label_Col_Offset to 2
90773>>>        Set Label to "Path"
90774>>>        Set Prompt_Button_Mode to PB_PromptOn
90775>>>        Set peAnchors to anTopLeftRight
90776>>>        Set Enabled_State to False
90777>>>
90777>>>        Procedure Page Integer iPageObject
90780>>>            String sValue
90780>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
90781>>>            Get vFolderFormat sValue to sValue
90782>>>            Move (sValue + "Backup") to sValue
90783>>>            Set Value to sValue
90784>>>            Forward Send Page iPageObject
90786>>>        End_Procedure
90787>>>
90787>>>        Procedure Prompt
90790>>>            String sPath sFileMask sRetval
90790>>>
90790>>>            Get Value to sPath
90791>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
90792>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
90793>>>            If (sRetval <> "") Begin
90795>>>                Get ParseFolderName sRetval to sPath
90796>>>                If (Right(sPath, 1) ="\") Begin
90798>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
90799>>>                End
90799>>>>
90799>>>                Set Value to sPath
90800>>>            End
90800>>>>
90800>>>        End_Procedure
90801>>>
90801>>>        Procedure OnChange
90804>>>            String sValue
90804>>>            Get Value to sValue
90805>>>            Set psPath to sValue
90806>>>        End_Procedure
90807>>>
90807>>>    End_Object
90808>>>
90808>>>    Object oOK_Btn is a Button
90810>>>        Set Label    to "&OK"
90811>>>        Set Location to 81 169
90812>>>        Set peAnchors to anBottomRight
90813>>>
90813>>>        Procedure OnClick
90816>>>            Set pbOK to True
90817>>>            Send Close_Panel
90818>>>        End_Procedure
90819>>>
90819>>>    End_Object
90820>>>
90820>>>    Object oCancel_Btn is a Button
90822>>>        Set Label    to "&Cancel"
90823>>>        Set Location to 81 224
90824>>>        Set peAnchors to anBottomRight
90825>>>
90825>>>        Procedure OnClick
90828>>>            Set pbOK to False
90829>>>            Send Close_Panel
90830>>>        End_Procedure
90831>>>
90831>>>    End_Object
90832>>>
90832>>>    Object oButton1 is a Button
90834>>>        Set Size to 14 96
90835>>>        Set Location to 80 32
90836>>>        Set Label to "Enum table types"
90837>>>
90837>>>        Procedure OnClick
90840>>>            String sDriverID
90840>>>            tSQLConnection SQLConnection
90840>>>            tSQLConnection SQLConnection
90840>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
90841>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
90842>>>        End_Procedure
90843>>>
90843>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
90846>>>            Handle hoCLIHandler
90846>>>            Integer iNumTables iTableCount
90846>>>
90846>>>            Get Create U_cCLIHandler to hoCLIhandler
90847>>>            If (hoCLIHandler > 0) Begin
90849>>>                Set psDriverID of hoCLIHandler to sDriver
90850>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
90851>>>                For iTableCount from 1 to iNumTables
90857>>>>
90857>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
90859>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
90861>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
90863>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
90865>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
90865>>>//                    For iColumnCount from 1 to iNumColumns
90865>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
90865>>>//                    Loop
90865>>>                    Showln
90866>>>                Loop
90867>>>>
90867>>>                Send Destroy of hoCLIHandler
90868>>>            End
90868>>>>
90868>>>        End_Procedure
90869>>>
90869>>>    End_Object
90870>>>
90870>>>    Procedure Page Integer iPageObject
90873>>>        Set Icon to "DbBackup1.ico"
90874>>>        Forward Send Page iPageObject
90876>>>    End_Procedure
90877>>>
90877>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
90878>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
90879>>>
90879>>>End_Object
90880>>>
90880>>>// *** General purpose access method for this dialog ***
90880>>>Function MakeSQLDatabaseBackup Returns Boolean
90883>>>    Handle ho
90883>>>    Boolean bOK bDefault
90883>>>    String sDatabase sPath sBackupName
90883>>>
90883>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
90884>>>    Set pbOK of ho to False
90885>>>    Send Popup of ho
90886>>>
90886>>>    Get pbOk of ho to bOK
90887>>>    If (bOK = True) Begin
90889>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
90890>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
90891>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
90892>>>        If (bDefault = False) Begin
90894>>>            Get Value of (oPath_fm(ho)) to sPath
90895>>>        End
90895>>>>
90895>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
90896>>>    End
90896>>>>
90896>>>
90896>>>    Function_Return bOK
90897>>>End_Function
90898>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
90898>>>Use Windows.pkg
90898>>>Use DFClient.pkg
90898>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cDbScrollingContainer.pkg)
90898>>>>>// Provides support for db aware scrolling containers.
90898>>>>>// Scrolling containers is provided by creating two objects,
90898>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
90898>>>>>// The host has no public interface, you just drop the object. It should have only one child object
90898>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
90898>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
90898>>>>>
90898>>>>>Use DFClient.pkg
90898>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainerMixin.pkg)
90898>>>>>>>// Mixin classes for scrolling container support:
90898>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
90898>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
90898>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
90898>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
90898>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
90898>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
90898>>>>>>>
90898>>>>>>>Use Windows.pkg
90898>>>>>>>Use Winuser.pkg
90898>>>>>>>Use tWinStructs.pkg
90898>>>>>>>
90898>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
90898>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
90898>>>>>>>// support for the scrolling client area mixin object.
90898>>>>>>>
90898>>>>>>>Class cScrollingClientAreaMixin is a Mixin
90899>>>>>>>    
90899>>>>>>>    Procedure Define_cScrollingClientAreaMixin
90901>>>>>>>        
90901>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
90902>>>>>>>        Set Border_Style to Border_None
90903>>>>>>>        
90903>>>>>>>        Property Boolean pbAutoScroll True
90904>>>>>>>        Property Boolean pbAutoScrollFocus True
90905>>>>>>>        Property Integer piAutoScrollMarginX 5
90906>>>>>>>        Property Integer piAutoScrollMarginY 5
90907>>>>>>>        Property Integer piAutoScrollMinX 0
90908>>>>>>>        Property Integer piAutoScrollMinY 0
90909>>>>>>>        Property Boolean pbShowDisabledScrollBar False
90910>>>>>>>        
90910>>>>>>>        
90910>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
90911>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
90912>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
90913>>>>>>>        // keeps track of scrolling
90913>>>>>>>        Property Integer piCurrentVertScrolled 0
90914>>>>>>>        Property Integer piCurrentHorzScrolled 0
90915>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
90916>>>>>>>        Delegate Set phoScrollingClientArea to Self
90918>>>>>>>        
90918>>>>>>>        // set this true to make this a tabbed workspace view (design time)
90918>>>>>>>        Property Boolean pbTabWorkspaceView False
90919>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
90919>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
90920>>>>>>>    End_Procedure
90921>>>>>>>    
90921>>>>>>>    // low level event sent from windows.
90921>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
90923>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
90923>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
90924>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
90925>>>>>>>        If (wParam<0) Begin
90927>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
90928>>>>>>>        End
90928>>>>>>>>
90928>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
90929>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
90930>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
90930>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
90931>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
90932>>>>>>>        // If we have enough Clicks send OnMouseWheel
90932>>>>>>>        If (iClicks<>0) Begin
90934>>>>>>>            Send OnMouseWheel iClicks iKeys
90935>>>>>>>        End
90935>>>>>>>>
90935>>>>>>>        // tell windows that we've handled the event.
90935>>>>>>>        Set Windows_Override_State to True
90936>>>>>>>    End_Procedure
90937>>>>>>>    
90937>>>>>>>    
90937>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
90937>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
90939>>>>>>>        Integer iLineScrollUnit
90939>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
90940>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
90941>>>>>>>    End_Procedure
90942>>>>>>>    
90942>>>>>>>    // should be sent by WM_VSCROLL
90942>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
90944>>>>>>>        Boolean bOk
90944>>>>>>>        tWinScrollInfo ScrollInfo
90944>>>>>>>        tWinScrollInfo ScrollInfo
90944>>>>>>>        Integer iLineScrollUnit
90944>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
90945>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
90946>>>>>>>        If bOk Begin
90948>>>>>>>            
90948>>>>>>>            Case Begin
90948>>>>>>>                Case (iType=SB_PAGEDOWN)
90950>>>>>>>                    Send VScroll ScrollInfo.nPage
90951>>>>>>>                    Case Break
90952>>>>>>>                
90952>>>>>>>                Case (iType=SB_PAGEUP)
90955>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
90956>>>>>>>                    Case Break
90957>>>>>>>                
90957>>>>>>>                Case (iType=SB_LINEDOWN)
90960>>>>>>>                    Send VScroll iLineScrollUnit
90961>>>>>>>                    Case Break
90962>>>>>>>                
90962>>>>>>>                Case (iType=SB_LINEUP)
90965>>>>>>>                    Send VScroll (-iLineScrollUnit)
90966>>>>>>>                    Case Break
90967>>>>>>>                
90967>>>>>>>                Case (iType=SB_BOTTOM)
90970>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
90971>>>>>>>                    Case Break
90972>>>>>>>                
90972>>>>>>>                Case (iType=SB_Top)
90975>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
90976>>>>>>>                    Case Break
90977>>>>>>>                
90977>>>>>>>                Case (iType=SB_THUMBPOSITION)
90980>>>>>>>                    Case Break
90981>>>>>>>                
90981>>>>>>>                Case (iType=SB_THUMBTRACK)
90984>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
90985>>>>>>>                    Case Break
90986>>>>>>>            Case End
90986>>>>>>>        End
90986>>>>>>>>
90986>>>>>>>    End_Procedure
90987>>>>>>>    
90987>>>>>>>    // should be sent by WM_HSCROLL
90987>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
90989>>>>>>>        Boolean bOk
90989>>>>>>>        tWinScrollInfo ScrollInfo
90989>>>>>>>        tWinScrollInfo ScrollInfo
90989>>>>>>>        Integer iLineScrollUnit
90989>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
90990>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
90991>>>>>>>        If bOk Begin
90993>>>>>>>            
90993>>>>>>>            Case Begin
90993>>>>>>>                Case (iType=SB_PAGEDOWN)
90995>>>>>>>                    Send hScroll ScrollInfo.nPage
90996>>>>>>>                    Case Break
90997>>>>>>>                
90997>>>>>>>                Case (iType=SB_PAGEUP)
91000>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
91001>>>>>>>                    Case Break
91002>>>>>>>                
91002>>>>>>>                Case (iType=SB_LINEDOWN)
91005>>>>>>>                    Send hScroll iLineScrollUnit
91006>>>>>>>                    Case Break
91007>>>>>>>                
91007>>>>>>>                Case (iType=SB_LINEUP)
91010>>>>>>>                    Send hScroll (-iLineScrollUnit)
91011>>>>>>>                    Case Break
91012>>>>>>>                
91012>>>>>>>                Case (iType=SB_BOTTOM)
91015>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
91016>>>>>>>                    Case Break
91017>>>>>>>                
91017>>>>>>>                Case (iType=SB_Top)
91020>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
91021>>>>>>>                    Case Break
91022>>>>>>>                
91022>>>>>>>                Case (iType=SB_THUMBPOSITION)
91025>>>>>>>                    Case Break
91026>>>>>>>                
91026>>>>>>>                Case (iType=SB_THUMBTRACK)
91029>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
91030>>>>>>>                    Case Break
91031>>>>>>>            Case End
91031>>>>>>>        End
91031>>>>>>>>
91031>>>>>>>    End_Procedure
91032>>>>>>>    
91032>>>>>>>    
91032>>>>>>>    // this calls SetScrollInfo with proper info
91032>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
91034>>>>>>>        tWinScrollInfo ScrollInfo
91034>>>>>>>        tWinScrollInfo ScrollInfo
91034>>>>>>>        Integer iVoid
91034>>>>>>>        Handle hWnd
91034>>>>>>>        Boolean bShow
91034>>>>>>>        
91034>>>>>>>        Delegate Get Window_Handle to hWnd
91036>>>>>>>        If (hWnd <> 0) Begin
91038>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
91039>>>>>>>            
91039>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
91040>>>>>>>            Get pbShowDisabledScrollBar to bShow
91041>>>>>>>            If bShow Begin
91043>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
91044>>>>>>>            End
91044>>>>>>>>
91044>>>>>>>            Move iRangeMin to ScrollInfo.nMin
91045>>>>>>>            Move iRangeMax to ScrollInfo.nMax
91046>>>>>>>            Move iPageSize to ScrollInfo.nPage
91047>>>>>>>            Move 0 to ScrollInfo.nPos
91048>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
91049>>>>>>>            
91049>>>>>>>        End
91049>>>>>>>>
91049>>>>>>>    End_Procedure
91050>>>>>>>    
91050>>>>>>>    // this wraps GetScrollInfo
91050>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
91052>>>>>>>        Boolean bOk
91052>>>>>>>        Handle hWnd
91052>>>>>>>        
91052>>>>>>>        Delegate Get Window_Handle to hWnd
91054>>>>>>>        If (hWnd <> 0) Begin
91056>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
91057>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
91058>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
91059>>>>>>>        End
91059>>>>>>>>
91059>>>>>>>        Function_Return bOk
91060>>>>>>>    End_Function
91061>>>>>>>    
91061>>>>>>>    // this wraps SetScrollPos
91061>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
91063>>>>>>>        Integer iVoid
91063>>>>>>>        Handle hWnd
91063>>>>>>>        
91063>>>>>>>        Delegate Get Window_Handle to hWnd
91065>>>>>>>        If (hWnd <> 0) Begin
91067>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
91068>>>>>>>        End
91068>>>>>>>>
91068>>>>>>>    End_Procedure
91069>>>>>>>    
91069>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
91069>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
91069>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
91071>>>>>>>        Send ScrollClientArea
91072>>>>>>>    End_Procedure
91073>>>>>>>    
91073>>>>>>>    // augment to handle the scrolling area initialization.
91073>>>>>>>    Procedure Add_Focus Handle hoParent
91075>>>>>>>        Forward Send Add_Focus hoParent
91077>>>>>>>        // at this the scrolling container and client area should both be paged.
91077>>>>>>>        // child objects ae also paged with initial anchors applied
91077>>>>>>>        Send CalculateAutoScrollMinimums
91078>>>>>>>    End_Procedure
91079>>>>>>>    
91079>>>>>>>    Procedure Page Integer iPage
91081>>>>>>>        Forward Send Page iPage
91083>>>>>>>        If iPage Begin
91085>>>>>>>            // at this the scrolling container and client area should both be paged
91085>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
91085>>>>>>>            // the child items are paged (else they may get anchored oddly)
91085>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
91085>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
91085>>>>>>>            // before they were really needed. This should be more accurate
91085>>>>>>>            Send SetScrollBarInfo True 0 0 0
91086>>>>>>>            Send SetScrollBarInfo False 0 0 0
91087>>>>>>>        End
91087>>>>>>>>
91087>>>>>>>    End_Procedure
91088>>>>>>>    
91088>>>>>>>    // determine scrolling minimums and set the client area as required.
91088>>>>>>>    
91088>>>>>>>    Procedure CalculateAutoScrollMinimums
91090>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
91090>>>>>>>        Integer iAutoMinX iAutoMinY
91090>>>>>>>        Boolean bAutoScroll
91090>>>>>>>        Handle hoNext hoFirst
91090>>>>>>>        
91090>>>>>>>        Get pbAutoScroll to bAutoScroll
91091>>>>>>>        Get piAutoScrollMinX to iAutoMinX
91092>>>>>>>        Get piAutoScrollMinY to iAutoMinY
91093>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
91094>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
91095>>>>>>>        Move (Low(iSiz)) to iAutoMinX
91096>>>>>>>        Set piMinimumHeight to iAutoMinY
91097>>>>>>>        Set piMinimumWidth to iAutoMinX
91098>>>>>>>        
91098>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
91100>>>>>>>            
91100>>>>>>>            Get Next_Level to hoFirst
91101>>>>>>>            Move hoFirst to hoNext
91102>>>>>>>            If (hoFirst) Begin
91104>>>>>>>                Repeat
91104>>>>>>>>
91104>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
91105>>>>>>>                    Get GuiLocation of hoNext to iLoc
91106>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
91107>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
91108>>>>>>>                    Get Next_Focus of hoNext to hoNext
91109>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
91111>>>>>>>                
91111>>>>>>>                If (iAutoMinY=0) Begin
91113>>>>>>>                    Get piAutoScrollMarginY to iMargin
91114>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
91115>>>>>>>                End
91115>>>>>>>>
91115>>>>>>>                
91115>>>>>>>                If (iAutoMinX=0) Begin
91117>>>>>>>                    Get piAutoScrollMarginX to iMargin
91118>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
91119>>>>>>>                    
91119>>>>>>>                End
91119>>>>>>>>
91119>>>>>>>            End
91119>>>>>>>>
91119>>>>>>>        End
91119>>>>>>>>
91119>>>>>>>        
91119>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
91119>>>>>>>        Broadcast Set pbAnchorCreated to False
91121>>>>>>>        Send ScrollClientArea
91122>>>>>>>        // after the scroll set up, reinitialize all anchors.
91122>>>>>>>        Broadcast Send DoCreateAnchors
91124>>>>>>>    End_Procedure
91125>>>>>>>    
91125>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
91125>>>>>>>    // work of scrolling.
91125>>>>>>>    
91125>>>>>>>    Procedure ScrollClientArea
91127>>>>>>>        Integer iSiz
91127>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
91127>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
91127>>>>>>>        Integer iSzY iSzX iLocX iLocY
91127>>>>>>>        
91127>>>>>>>        Delegate Get GuiClientSize to iSiz
91129>>>>>>>        Move (Hi(iSiz)) to iHeight
91130>>>>>>>        Move (Low(iSiz)) to iWidth
91131>>>>>>>        
91131>>>>>>>        // Vertical scrolling
91131>>>>>>>        
91131>>>>>>>        Get piMinimumHeight to iOrig
91132>>>>>>>        Get piMinimumWidth to iWOrig
91133>>>>>>>        
91133>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
91135>>>>>>>            
91135>>>>>>>            If (iOrig<>0) Begin
91137>>>>>>>                Get piCurrentVertScrolled to iHCur
91138>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
91138>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
91140>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
91141>>>>>>>                    Set piCurrentVertScrolled to iHCur
91142>>>>>>>                End
91142>>>>>>>>
91142>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
91144>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
91145>>>>>>>                    Send SetScrollBarPosInfo True iHCur
91146>>>>>>>                End
91146>>>>>>>>
91146>>>>>>>                Else Begin
91147>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
91148>>>>>>>                End
91148>>>>>>>>
91148>>>>>>>            End
91148>>>>>>>>
91148>>>>>>>            
91148>>>>>>>            // Horiz scrolling
91148>>>>>>>            
91148>>>>>>>            Get piCurrentHorzScrolled to iWCur
91149>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
91149>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
91151>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
91152>>>>>>>                Set piCurrentHorzScrolled to iWCur
91153>>>>>>>            End
91153>>>>>>>>
91153>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
91155>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
91156>>>>>>>                Send SetScrollBarPosInfo False iWCur
91157>>>>>>>            End
91157>>>>>>>>
91157>>>>>>>            Else Begin
91158>>>>>>>                Send SetScrollBarInfo False 0 0 0
91159>>>>>>>            End
91159>>>>>>>>
91159>>>>>>>        End
91159>>>>>>>>
91159>>>>>>>        
91159>>>>>>>        // this could change depending on scrollbars appearing or not
91159>>>>>>>        Delegate Get GuiClientSize to iSiz
91161>>>>>>>        
91161>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
91161>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
91161>>>>>>>        // This is required to make anchors work sensibly
91161>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
91162>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
91163>>>>>>>        Move (-iHCur) to iLocY
91164>>>>>>>        Move (-iWCur) to iLocX
91165>>>>>>>        
91165>>>>>>>        // Allow chance to make modifications
91165>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
91166>>>>>>>        
91166>>>>>>>        Set GuiSize to iSzY iSzX
91167>>>>>>>        // if we've scrolled, we need to reposition the container
91167>>>>>>>        Set GuiLocation to iLocY iLocX
91168>>>>>>>    End_Procedure
91169>>>>>>>    
91169>>>>>>>    // note that scrolling never changes the size of the scrolling client.
91169>>>>>>>    // this way, it does not interfere with anchors.
91169>>>>>>>    
91169>>>>>>>    Procedure VScroll Integer iDelta
91171>>>>>>>        Integer iHeight iCur iOrig iSiz
91171>>>>>>>        Delegate Get GuiClientSize to iSiz
91173>>>>>>>        Move (hi(iSiz)) to iHeight
91174>>>>>>>        Get piCurrentVertScrolled to iCur
91175>>>>>>>        Get piMinimumHeight to iOrig
91176>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
91178>>>>>>>            Procedure_Return
91179>>>>>>>        End
91179>>>>>>>>
91179>>>>>>>        // make sure delta is within range
91179>>>>>>>        If (iDelta+iCur<0) Begin
91181>>>>>>>            Move (-iCur) to iDelta
91182>>>>>>>        End
91182>>>>>>>>
91182>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
91185>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
91186>>>>>>>        End
91186>>>>>>>>
91186>>>>>>>        If (iDelta=0) ;            Procedure_Return
91189>>>>>>>        
91189>>>>>>>        Move (iCur + iDelta) to iCur
91190>>>>>>>        Set piCurrentVertScrolled to iCur
91191>>>>>>>        Send SetScrollBarPosInfo True iCur
91192>>>>>>>        Get GuiLocation to iSiz
91193>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
91194>>>>>>>        Send ScrollClientArea
91195>>>>>>>    End_Procedure
91196>>>>>>>    
91196>>>>>>>    
91196>>>>>>>    Procedure HScroll Integer iDelta
91198>>>>>>>        Integer iHeight iCur iOrig iSiz
91198>>>>>>>        Delegate Get GuiClientSize to iSiz
91200>>>>>>>        Move (low(iSiz)) to iHeight
91201>>>>>>>        Get piCurrentHorzScrolled to iCur
91202>>>>>>>        Get piMinimumWidth to iOrig
91203>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
91205>>>>>>>            Procedure_Return
91206>>>>>>>        End
91206>>>>>>>>
91206>>>>>>>        If (iDelta+iCur<0) Begin
91208>>>>>>>            Move (-iCur) to iDelta
91209>>>>>>>        End
91209>>>>>>>>
91209>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
91212>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
91213>>>>>>>        End
91213>>>>>>>>
91213>>>>>>>        If (iDelta=0) ;            Procedure_Return
91216>>>>>>>        
91216>>>>>>>        Move (iCur + iDelta) to iCur
91217>>>>>>>        Set piCurrentHorzScrolled to iCur
91218>>>>>>>        Send SetScrollBarPosInfo False iCur
91219>>>>>>>        Get GuiLocation to iSiz
91220>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
91221>>>>>>>        Send ScrollClientArea
91222>>>>>>>    End_Procedure
91223>>>>>>>    
91223>>>>>>>    // make sure client is a 0,0
91223>>>>>>>    Procedure ScrollHome
91225>>>>>>>        Send SetVScrollbox SB_TOP 0
91226>>>>>>>        Send SetHScrollbox SB_TOP 0
91227>>>>>>>    End_Procedure
91228>>>>>>>    
91228>>>>>>>    // get relative GUI location of this object to the parent one passed.
91228>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
91230>>>>>>>        Integer ivoid
91230>>>>>>>        tWinRect Rect0 Rect1
91230>>>>>>>        tWinRect Rect0 Rect1
91230>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
91231>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
91232>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
91233>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
91234>>>>>>>    End_Procedure
91235>>>>>>>    
91235>>>>>>>    // This scrolls this object into visual range.
91235>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
91237>>>>>>>        Handle hoScrollingContainer
91237>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
91237>>>>>>>        Integer iViewHeight iViewWidth
91237>>>>>>>        Integer iRelLocHeight iRelLocWidth
91237>>>>>>>        Integer iSize iControlHeight iControlWidth
91237>>>>>>>        Integer iScroll
91237>>>>>>>        Integer iMarginX iMarginY
91237>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
91237>>>>>>>        
91237>>>>>>>        Get piAutoScrollMarginX to iMarginX
91238>>>>>>>        Get piAutoScrollMarginY to iMarginY
91239>>>>>>>        
91239>>>>>>>        // the scrolling container
91239>>>>>>>        Move Self to hoScrollingContainer
91240>>>>>>>        // the amount the SC is currently scrolled
91240>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
91241>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
91242>>>>>>>        
91242>>>>>>>        // size of view's client area (this is the viewport area)
91242>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
91243>>>>>>>        Move (hi(iSize)) to iViewHeight
91244>>>>>>>        Move (low(iSize)) to iViewWidth
91245>>>>>>>        
91245>>>>>>>        // get this object's location relative to the scrolling container
91245>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
91246>>>>>>>        
91246>>>>>>>        // we expect that the client size is the window size but just in case
91246>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
91247>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
91248>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
91249>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
91250>>>>>>>        
91250>>>>>>>        // the outer size of the control object
91250>>>>>>>        Get GUIWindowSize of hoControl to iSize
91251>>>>>>>        Move (hi(iSize)) to iControlHeight
91252>>>>>>>        Move (low(iSize)) to iControlWidth
91253>>>>>>>        
91253>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
91253>>>>>>>        
91253>>>>>>>        // Vertical Scroll
91253>>>>>>>        
91253>>>>>>>        // Vertical Scroll down
91253>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
91253>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
91255>>>>>>>            
91255>>>>>>>            // set scroll amount so that the bottom of the control is visible
91255>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
91256>>>>>>>            
91256>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
91256>>>>>>>            // top of the object appears at the bottom
91256>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
91258>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
91259>>>>>>>            End
91259>>>>>>>>
91259>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
91259>>>>>>>            If (iScroll>0) Begin
91261>>>>>>>                Send VScroll of hoScrollingContainer iScroll
91262>>>>>>>            End
91262>>>>>>>>
91262>>>>>>>        End
91262>>>>>>>>
91262>>>>>>>        // else vertical scroll up
91262>>>>>>>        // We scroll if the top of the object is not visible.
91262>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
91265>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
91265>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
91266>>>>>>>            If (iScroll<0) Begin
91268>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
91269>>>>>>>            End
91269>>>>>>>>
91269>>>>>>>        End
91269>>>>>>>>
91269>>>>>>>        
91269>>>>>>>        // Horizonal Scroll
91269>>>>>>>        
91269>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
91269>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
91271>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
91272>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
91274>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
91275>>>>>>>            End
91275>>>>>>>>
91275>>>>>>>            If (iScroll>0) Begin
91277>>>>>>>                Send HScroll of hoScrollingContainer iScroll
91278>>>>>>>            End
91278>>>>>>>>
91278>>>>>>>        End
91278>>>>>>>>
91278>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
91280>>>>>>>            // if this can fit by moving all the way to left, do so.
91280>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
91282>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
91283>>>>>>>            End
91283>>>>>>>>
91283>>>>>>>            Else Begin
91284>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
91285>>>>>>>            End
91285>>>>>>>>
91285>>>>>>>            If (iScroll<0) Begin
91287>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
91288>>>>>>>            End
91288>>>>>>>>
91288>>>>>>>        End
91288>>>>>>>>
91288>>>>>>>        
91288>>>>>>>        
91288>>>>>>>    End_Procedure
91289>>>>>>>    
91289>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
91289>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
91291>>>>>>>        Boolean bScrollOnFocus
91291>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
91292>>>>>>>        If bScrollOnFocus Begin
91294>>>>>>>            Send ScrollObjectInRange hoControl
91295>>>>>>>        End
91295>>>>>>>>
91295>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
91297>>>>>>>    End_Procedure
91298>>>>>>>    
91298>>>>>>>    
91298>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
91300>>>>>>>        Boolean bCenter
91300>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
91301>>>>>>>        Function_Return bCenter
91302>>>>>>>    End_Function
91303>>>>>>>    
91303>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
91305>>>>>>>        Boolean bTabWorkspaceView
91305>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
91306>>>>>>>        If bTabWorkspaceView Begin
91308>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
91309>>>>>>>        End
91309>>>>>>>>
91309>>>>>>>    End_Procedure
91310>>>>>>>    
91310>>>>>>>    Function ParentView Returns Handle
91312>>>>>>>        Function_Return (Parent(Parent(Self)))
91313>>>>>>>    End_Function
91314>>>>>>>    
91314>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
91316>>>>>>>        Integer iSize iMax iDiff
91316>>>>>>>        Handle hoView
91316>>>>>>>        Boolean bCenter bModal
91316>>>>>>>        Get ParentView to hoView
91317>>>>>>>        Get Block_Mouse_State of hoView to bModal
91318>>>>>>>        If not bModal Begin
91320>>>>>>>            Get CenterTabWorkspaceView to bCenter
91321>>>>>>>            Get GuiSize of hoView to iSize
91322>>>>>>>            Get piMaxSize of hoView to iMax
91323>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
91324>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
91326>>>>>>>                If bCenter Begin
91328>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
91329>>>>>>>                End
91329>>>>>>>>
91329>>>>>>>                Move (Low(iMax)) to iWidth
91330>>>>>>>            End
91330>>>>>>>>
91330>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
91332>>>>>>>                If bCenter Begin
91334>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
91335>>>>>>>                    Move (iLocy min 25) to  iLocY
91336>>>>>>>                End
91336>>>>>>>>
91336>>>>>>>                Move (Hi(imax)) to iHeight
91337>>>>>>>            End
91337>>>>>>>>
91337>>>>>>>        End
91337>>>>>>>>
91337>>>>>>>    End_Procedure
91338>>>>>>>    
91338>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
91338>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
91338>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
91338>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
91338>>>>>>>    // This should almost always yield the right answer.
91338>>>>>>>    // This is called by the scrolling container's end_constructor
91338>>>>>>>    Procedure AutoSetTabWorkspaceView
91340>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
91340>>>>>>>        Handle hoParent
91340>>>>>>>        Integer iSize
91340>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
91341>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
91343>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
91344>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
91344>>>>>>>            // change this after the commandbar is paged.
91344>>>>>>>            If (bTabView) Begin
91346>>>>>>>                Get ParentView to hoParent
91347>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
91348>>>>>>>                If (bIsView) Begin
91350>>>>>>>                    // set this as a tab workspace view
91350>>>>>>>                    Set pbTabWorkspaceView to True
91351>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
91351>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
91351>>>>>>>                    Set pbAutoScroll to True
91352>>>>>>>                    
91352>>>>>>>                End
91352>>>>>>>>
91352>>>>>>>            End
91352>>>>>>>>
91352>>>>>>>        End
91352>>>>>>>>
91352>>>>>>>    End_Procedure
91353>>>>>>>    
91353>>>>>>>End_Class
91354>>>>>>>
91354>>>>>>>// Container scrolling class support. Nothing in here is public
91354>>>>>>>Class cScrollingContainerMixin is a Mixin
91355>>>>>>>    
91355>>>>>>>    Procedure Define_cScrollingContainerMixin
91357>>>>>>>        Forward Set Border_Style to Border_None
91359>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
91360>>>>>>>        Forward Set peAnchors to anAll
91362>>>>>>>        
91362>>>>>>>        // forcing scrollbars right away seems to make painting better
91362>>>>>>>        Set Window_Style WS_HSCROLL to True
91363>>>>>>>        Set Window_Style WS_VSCROLL to True
91364>>>>>>>        
91364>>>>>>>        Property Handle phoScrollingClientArea 0
91365>>>>>>>    End_Procedure
91366>>>>>>>    
91366>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
91366>>>>>>>    Procedure Set peAnchors Integer eAnchors
91368>>>>>>>    End_Procedure
91369>>>>>>>    
91369>>>>>>>    // if a border style is set, it will not work. We won't let that happen
91369>>>>>>>    Procedure Set Border_Style Integer eStyle
91371>>>>>>>    End_Procedure
91372>>>>>>>    
91372>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
91372>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
91374>>>>>>>        Handle hoClient
91374>>>>>>>        Get phoScrollingClientArea to hoClient
91375>>>>>>>        If hoClient Begin
91377>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
91378>>>>>>>        End
91378>>>>>>>>
91378>>>>>>>    End_Procedure
91379>>>>>>>    
91379>>>>>>>    // should be sent by WM_VSCROLL
91379>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
91381>>>>>>>        Handle hoClient
91381>>>>>>>        Get phoScrollingClientArea to hoClient
91382>>>>>>>        If hoClient Begin
91384>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
91385>>>>>>>        End
91385>>>>>>>>
91385>>>>>>>    End_Procedure
91386>>>>>>>    
91386>>>>>>>    // should be sent by WM_HSCROLL
91386>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
91388>>>>>>>        Handle hoClient
91388>>>>>>>        Get phoScrollingClientArea to hoClient
91389>>>>>>>        If hoClient Begin
91391>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
91392>>>>>>>        End
91392>>>>>>>>
91392>>>>>>>    End_Procedure
91393>>>>>>>    
91393>>>>>>>    // augmented to adjust its size to the size of the parent client area.
91393>>>>>>>    // After this is set, anchors will handle any further resizing.
91393>>>>>>>    Procedure Page Integer iState
91395>>>>>>>        Integer iSiz iHeight iWidth
91395>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
91395>>>>>>>        Boolean bGroup
91395>>>>>>>        Handle hoClient
91395>>>>>>>        If (iState =1) Begin
91397>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
91399>>>>>>>            // We have special code to support groups because they
91399>>>>>>>            // draw a border inside of the client rectangle
91399>>>>>>>            If bGroup Begin
91401>>>>>>>                Get Physical_FontSize to iFontSize
91402>>>>>>>                Move (Hi(iFontSize)) to iTop
91403>>>>>>>                Move 2 to iLeft
91404>>>>>>>                Move 2 to iRight
91405>>>>>>>                Move 2 to iBottom
91406>>>>>>>            End
91406>>>>>>>>
91406>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
91406>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
91406>>>>>>>            // makes anchors work properly with unpaged tab-pages
91406>>>>>>>            Delegate Get GetContainerClientSize to iSiz
91408>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
91409>>>>>>>            Set GuiLocation to iTop iLeft
91410>>>>>>>            Send Adjust_Logicals
91411>>>>>>>        End
91411>>>>>>>>
91411>>>>>>>        Forward Send Page iState
91413>>>>>>>    End_Procedure
91414>>>>>>>    
91414>>>>>>>    Procedure End_Construct_Object
91416>>>>>>>        Handle hoClient
91416>>>>>>>        Forward Send End_Construct_Object
91418>>>>>>>        Get phoScrollingClientArea to hoClient
91419>>>>>>>        If (hoClient) Begin
91421>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
91422>>>>>>>        End
91422>>>>>>>>
91422>>>>>>>    End_Procedure
91423>>>>>>>    
91423>>>>>>>End_Class
91424>>>>>
91424>>>>>Class cDbScrollingClientArea is a dbContainer3d
91425>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
91426>>>>>    Procedure Construct_Object
91428>>>>>        Forward Send Construct_Object
91430>>>>>        Send Define_cScrollingClientAreaMixin
91431>>>>>    End_Procedure
91432>>>>>End_Class
91433>>>>>
91433>>>>>
91433>>>>>
91433>>>>>Class cDbScrollingContainer is a dbContainer3d
91434>>>>>    Import_Class_Protocol cScrollingContainerMixin
91435>>>>>    Procedure Construct_Object
91437>>>>>        Forward Send Construct_Object
91439>>>>>        Send Define_cScrollingContainerMixin
91440>>>>>    End_Procedure
91441>>>>>End_Class
91442>>>Use cDbUpdateFunctionLibrary.pkg
91442>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
91442>>>>>//****************************************************************************
91442>>>>>// $Module type: Package
91442>>>>>// $Module name: cRDCButtonDPI.pkg
91442>>>>>//
91442>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
91442>>>>>// Copyright (c) 2013 RDC Tools International
91442>>>>>// E-mail      : support@rdctools.com
91442>>>>>// Web-site    : http://www.rdctools.com
91442>>>>>//
91442>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
91442>>>>>//
91442>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
91442>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
91442>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
91442>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
91442>>>>>// in the help folder for more details.
91442>>>>>//
91442>>>>>//****************************************************************************
91442>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
91442>>>>>>>//****************************************************************************
91442>>>>>>>// $Module type: Package
91442>>>>>>>// $Module name: cRDCButton.pkg
91442>>>>>>>//
91442>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
91442>>>>>>>// Copyright (c) 2013 RDC Tools International
91442>>>>>>>// E-mail      : support@rdctools.com
91442>>>>>>>// Web-site    : http://www.rdctools.com
91442>>>>>>>//
91442>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
91442>>>>>>>//
91442>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
91442>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
91442>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
91442>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
91442>>>>>>>// in the help folder for more details.
91442>>>>>>>//
91442>>>>>>>//****************************************************************************
91442>>>>>>>Use Windows.pkg
91442>>>>>>>Use Enclient.pkg
91442>>>>>>>Use errornum.inc
91442>>>>>>>
91442>>>>>>>Class cButtonIdleHandler is a cIdleHandler
91443>>>>>>>    Procedure Construct_Object
91445>>>>>>>        Forward Send Construct_Object
91447>>>>>>>
91447>>>>>>>    End_Procedure
91448>>>>>>>
91448>>>>>>>    Procedure OnIdle
91450>>>>>>>        Delegate Send DoUpdate
91452>>>>>>>    End_Procedure
91453>>>>>>>
91453>>>>>>>End_Class
91454>>>>>>>
91454>>>>>>>Class cRDCButton is a Button
91455>>>>>>>
91455>>>>>>>    Procedure Construct_Object
91457>>>>>>>        Forward Send Construct_Object
91459>>>>>>>
91459>>>>>>>        Property Boolean pbAutoEnable False
91460>>>>>>>
91460>>>>>>>        Property Boolean pbEnabled True
91461>>>>>>>
91461>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
91462>>>>>>>
91462>>>>>>>        On_Key kCancel Send CancelIfPopupObject
91463>>>>>>>    End_Procedure
91464>>>>>>>
91464>>>>>>>    Procedure CancelIfPopupObject
91466>>>>>>>        Boolean bIsInPopupObject
91466>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
91468>>>>>>>        If (bIsInPopupObject = True) Begin
91470>>>>>>>            Send Close_Panel
91471>>>>>>>        End
91471>>>>>>>>
91471>>>>>>>    End_Procedure
91472>>>>>>>
91472>>>>>>>    Procedure End_Construct_Object
91474>>>>>>>        String sTooltip sStatus_Help
91474>>>>>>>
91474>>>>>>>        Forward Send End_Construct_Object
91476>>>>>>>
91476>>>>>>>        Get psToolTip   to sTooltip
91477>>>>>>>        Get Status_Help to sStatus_Help
91478>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
91480>>>>>>>            Set psToolTip to sStatus_Help
91481>>>>>>>        End
91481>>>>>>>>
91481>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
91483>>>>>>>            Set Status_Help to sToolTip
91484>>>>>>>        End
91484>>>>>>>>
91484>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
91485>>>>>>>    End_Procedure
91486>>>>>>>
91486>>>>>>>    Procedure DoUpdate
91488>>>>>>>        If (pbAutoEnable(Self) = False) Begin
91490>>>>>>>            Procedure_Return
91491>>>>>>>        End
91491>>>>>>>>
91491>>>>>>>        Set Enabled_State to (IsEnabled(Self))
91492>>>>>>>    End_Procedure
91493>>>>>>>
91493>>>>>>>    Function IsEnabled Returns Boolean
91495>>>>>>>        Boolean bEnabled
91495>>>>>>>        Get pbEnabled to bEnabled
91496>>>>>>>        Function_Return bEnabled
91497>>>>>>>    End_Function
91498>>>>>>>
91498>>>>>>>    // Enable the idle handler timer when the button is activated
91498>>>>>>>    Procedure Activating
91500>>>>>>>        Forward Send Activating
91502>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
91503>>>>>>>    End_Procedure
91504>>>>>>>
91504>>>>>>>    // Disable the idle handler when the button is deactivated
91504>>>>>>>    Procedure Deactivating
91506>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
91507>>>>>>>        Forward Send Deactivating
91509>>>>>>>    End_Procedure
91510>>>>>>>
91510>>>>>>>End_Class
91511>>>>>
91511>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
91511>>>>>Class cRDCButtonDPI is a cRDCButton
91512>>>>>    Procedure Construct_Object
91514>>>>>        Integer iIconSize
91514>>>>>        Forward Send Construct_Object
91516>>>>>        Set piImageMarginLeft to 10
91517>>>>>    End_Procedure
91518>>>>>
91518>>>>>    // Returns: DPI setting as an integer.
91518>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
91518>>>>>    //                      iDPI=120 is "Medium setting" 125%
91518>>>>>    //                      iDPI= 144 is "Large setting" 150%
91518>>>>>    Function GetCurrentDPI Returns Integer
91520>>>>>        Handle hDC
91520>>>>>        Integer iPixelsX
91520>>>>>        Move (GetDC(0)) to hDC
91521>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
91522>>>>>        Move (ReleaseDC(0, hDC)) to hDC
91523>>>>>        Function_Return iPixelsX
91524>>>>>    End_Function
91525>>>>>
91525>>>>>    Function GetCorrectIconSize Returns Integer
91527>>>>>        Integer iPixelsX iIndex iSize
91527>>>>>        Integer[] iaSizes
91528>>>>>
91528>>>>>        Move 16 to iaSizes[0]
91529>>>>>        Move 24 to iaSizes[1]
91530>>>>>        Move 32 to iaSizes[2]
91531>>>>>        Move 48 to iaSizes[3]
91532>>>>>        Move 64 to iaSizes[4]
91533>>>>>
91533>>>>>        Get piImageSize to iSize  // the "100%" size
91534>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
91535>>>>>        Move (0 max iIndex) to iIndex
91536>>>>>        Get GetCurrentDPI to iPixelsX
91537>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
91537>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
91537>>>>>        // will increment iIndex as many times as we need here.
91537>>>>>        Case Begin
91537>>>>>            Case (iPixelsX > 144)
91539>>>>>                Increment iIndex
91540>>>>>            Case (iPixelsX = 144)
91543>>>>>                Increment iIndex
91544>>>>>            Case (iPixelsX = 120)
91547>>>>>                Increment iIndex
91548>>>>>        Case End
91548>>>>>        Move (iIndex min 4) to iIndex
91549>>>>>        Function_Return iaSizes[iIndex]
91550>>>>>    End_Function
91551>>>>>
91551>>>>>    Procedure Set psToolTip String sToolTip
91553>>>>>        String sStatusHelp
91553>>>>>
91553>>>>>        Get Status_Help to sStatusHelp
91554>>>>>        If (sStatusHelp = "") Begin
91556>>>>>            Set Status_Help to sToolTip
91557>>>>>        End
91557>>>>>>
91557>>>>>
91557>>>>>        Forward Set psToolTip to sToolTip
91559>>>>>    End_Procedure
91560>>>>>
91560>>>>>End_Class
91561>>>Use DatabaseSelection.dg
91561>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
91561>>>>>Use Windows.pkg
91561>>>>>Use cCJGridPromptList.pkg
91561>>>>>Use MSSqldrv.pkg
91561>>>>>Use db2_drv.pkg
91561>>>>>Use odbc_drv.pkg    
91561>>>>>Use cRDCModalPanel.pkg
91561>>>>>Use cDbUpdateFunctionLibrary.pkg
91561>>>>>
91561>>>>>Object oServerSelection_sl is a cRDCModalPanel
91563>>>>>    Set Size to 105 225
91564>>>>>    Set Label to "Database Server/DSN Selection"
91565>>>>>    Set piMinSize to 89 211
91566>>>>>    Set Location to 2 2
91567>>>>>    Set Icon to "ServerLookup1.ico"
91568>>>>>
91568>>>>>    Property String[] psTheData
91570>>>>>
91570>>>>>    Object oSelList is a cCJGridPromptList
91572>>>>>        Set Size to 72 215
91573>>>>>        Set Location to 6 6
91574>>>>>        Set peAnchors to anAll
91575>>>>>        Set pbAllowColumnRemove to False
91576>>>>>        Set pbUseAlternateRowBackgroundColor to True
91577>>>>>        Set pbGrayIfDisable to False
91578>>>>>        Set pbHeaderReorders to False
91579>>>>>        Set pbHeaderSelectsColumn to False
91580>>>>>        Set pbHeaderTogglesDirection to False
91581>>>>>        Set pbShadeSortColumn to False
91582>>>>>        Set piFocusCellBackColor to clDkGray
91583>>>>>
91583>>>>>        Object oName is a cCJGridColumn
91585>>>>>            Set piWidth to 358
91586>>>>>            Set psCaption to "Name"
91587>>>>>        End_Object
91588>>>>>
91588>>>>>        Procedure Activating
91591>>>>>            tDataSourceRow[] MyData
91591>>>>>            tDataSourceRow[] MyData
91592>>>>>            Handle hoDataSource
91592>>>>>            String[] sTheData
91593>>>>>            Integer iCount iSize
91593>>>>>
91593>>>>>            Send Cursor_Wait of Cursor_Control
91594>>>>>            Get psTheData to sTheData
91595>>>>>            Move (SizeOfArray(sTheData)) to iSize
91596>>>>>            Decrement iSize
91597>>>>>            For iCount from 0 to iSize
91603>>>>>>
91603>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
91604>>>>>            Loop
91605>>>>>>
91605>>>>>
91605>>>>>            Forward Send Activating
91607>>>>>
91607>>>>>            Get phoDataSource to hoDataSource
91608>>>>>            Send InitializeData of hoDataSource MyData
91609>>>>>            Send Cursor_Ready of Cursor_Control
91610>>>>>        End_Procedure
91611>>>>>
91611>>>>>    End_Object
91612>>>>>
91612>>>>>    Object oOK_Btn is a Button
91614>>>>>        Set Size to 14 50
91615>>>>>        Set Label    to "&OK"
91616>>>>>        Set Location to 85 116
91617>>>>>        Set peAnchors To anBottomRight
91618>>>>>
91618>>>>>        Procedure OnClick
91621>>>>>            Send Ok of oSelList
91622>>>>>        End_Procedure
91623>>>>>
91623>>>>>    End_Object
91624>>>>>
91624>>>>>    Object oCancel_Btn is a Button
91626>>>>>        Set Size to 14 50
91627>>>>>        Set Label    to "&Cancel"
91628>>>>>        Set Location to 85 171
91629>>>>>        Set peAnchors to anBottomRight
91630>>>>>
91630>>>>>        Procedure OnClick
91633>>>>>            Send Close_Panel
91634>>>>>        End_Procedure
91635>>>>>
91635>>>>>    End_Object
91636>>>>>
91636>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
91637>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
91638>>>>>End_Object
91639>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
91639>>>>>Use Windows.pkg
91639>>>>>Use cCJGridPromptList.pkg
91639>>>>>Use cDbUpdateFunctionLibrary.pkg
91639>>>>>Use MSSqldrv.pkg
91639>>>>>Use db2_drv.pkg
91639>>>>>Use odbc_drv.pkg
91639>>>>>Use cCJGridColumn.pkg
91639>>>>>
91639>>>>>Object oSQLConnections is a ModalPanel
91641>>>>>    Set Label to "SQL Connections"
91642>>>>>    Set Size to 121 397
91643>>>>>    Set piMinSize to 89 185
91644>>>>>    Set Location to 2 2
91645>>>>>    Set Border_Style to Border_Thick
91646>>>>>
91646>>>>>    Property tSQLConnection[] psTheData
91648>>>>>
91648>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
91650>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
91652>>>>>        End_Object
91653>>>>>    End
91653>>>>>>
91653>>>>>
91653>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
91655>>>>>        Set Size to 90 377
91656>>>>>        Set Location to 6 6
91657>>>>>        Set peAnchors to anAll
91658>>>>>        Set pbAllowColumnRemove to False
91659>>>>>        Set pbUseAlternateRowBackgroundColor to True
91660>>>>>        Set pbGrayIfDisable to False
91661>>>>>        Set pbHeaderReorders to False
91662>>>>>        Set pbHeaderSelectsColumn to False
91663>>>>>        Set pbHeaderTogglesDirection to False
91664>>>>>        Set pbShadeSortColumn to False
91665>>>>>        Set piFocusCellBackColor to clDkGray  
91666>>>>>        Set pbRestoreLayout to True
91667>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
91668>>>>>
91668>>>>>        Object oID_Col is a cCJGridColumn
91670>>>>>            Set piWidth to 132
91671>>>>>            Set psCaption to "ID"
91672>>>>>        End_Object
91673>>>>>
91673>>>>>        Object oDbType_Col is a cCJGridColumn
91675>>>>>            Set piWidth to 182
91676>>>>>            Set psCaption to "Database Type"
91677>>>>>        End_Object
91678>>>>>
91678>>>>>        Object oServer_Col is a cCJGridColumn
91680>>>>>            Set piWidth to 296
91681>>>>>            Set psCaption to "Server/DSN"
91682>>>>>        End_Object
91683>>>>>
91683>>>>>        Object oDatabase_Col is a cCJGridColumn
91685>>>>>            Set piWidth to 211
91686>>>>>            Set psCaption to "Database"
91687>>>>>        End_Object
91688>>>>>
91688>>>>>        Object oDriverID_Col is a cCJGridColumn
91690>>>>>            Set piWidth to 121
91691>>>>>            Set psCaption to "Driver ID"
91692>>>>>        End_Object
91693>>>>>
91693>>>>>        Procedure Activating
91696>>>>>            tDataSourceRow[] MyData
91696>>>>>            tDataSourceRow[] MyData
91697>>>>>            Handle hoDataSource
91697>>>>>            Integer iCount iSize iPos
91697>>>>>            String sDriverID sConnectionID sValue
91697>>>>>            tSQLConnection[] sTheData
91697>>>>>            tSQLConnection[] sTheData
91698>>>>>
91698>>>>>            Send Cursor_Wait of Cursor_Control
91699>>>>>            Forward Send Activating
91701>>>>>
91701>>>>>            Get psTheData to sTheData
91702>>>>>            Move (SizeOfArray(sTheData)) to iSize
91703>>>>>            Decrement iSize
91704>>>>>            For iCount from 0 to iSize
91710>>>>>>
91710>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
91711>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
91712>>>>>                Move sValue                         to MyData[iCount].sValue[1]
91713>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
91714>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
91715>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
91716>>>>>            Loop
91717>>>>>>
91717>>>>>
91717>>>>>            Get phoDataSource to hoDataSource
91718>>>>>            Send InitializeData of hoDataSource MyData
91719>>>>>            Send Cursor_Ready of Cursor_Control
91720>>>>>        End_Procedure
91721>>>>>
91721>>>>>    End_Object
91722>>>>>
91722>>>>>    Object oOK_Btn is a Button
91724>>>>>        Set Label    to "&OK"
91725>>>>>        Set Location to 101 280
91726>>>>>        Set peAnchors to anBottomRight
91727>>>>>
91727>>>>>        Procedure OnClick
91730>>>>>            Send Ok of oSelListSQLConnections
91731>>>>>        End_Procedure
91732>>>>>
91732>>>>>    End_Object
91733>>>>>
91733>>>>>    Object oCancel_Btn is a Button
91735>>>>>        Set Label    to "&Cancel"
91736>>>>>        Set Location to 101 335
91737>>>>>        Set peAnchors to anBottomRight
91738>>>>>
91738>>>>>        Procedure OnClick
91741>>>>>            Send Close_Panel
91742>>>>>        End_Procedure
91743>>>>>
91743>>>>>    End_Object
91744>>>>>
91744>>>>>    Procedure Page Integer iPageObject
91747>>>>>        Set Icon to "SQLConnections1.ico"
91748>>>>>        Forward Send Page iPageObject
91750>>>>>    End_Procedure
91751>>>>>
91751>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
91752>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
91753>>>>>End_Object
91754>>>
91754>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
91764>>>>
91764>>>Object oSQLConnections_vw is a dbView
91766>>>    Set Border_Style to Border_Thick
91767>>>    Set Size to 251 427
91768>>>    Set Location to 2 2
91769>>>    Set Label to "SQL Connections"
91770>>>    Set pbAutoActivate to True
91771>>>    Set Icon to "SQLConnections1.ico"
91772>>>
91772>>>    Object oScrollingContainer1 is a cDbScrollingContainer
91774>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
91776>>>
91776>>>            Object oCurrentSettings_grp is a Group
91778>>>                Set Size to 232 402
91779>>>                Set Location to 6 12
91780>>>                Set Label to "Current Connection Settings"
91781>>>                Set peAnchors to anAll
91782>>>
91782>>>                Object oConnectionID_fm is a Form
91784>>>                    Set Size to 12 100
91785>>>                    Set Location to 12 68
91786>>>                    Set Label to "Connection ID"
91787>>>                    Set Label_Col_Offset to 2
91788>>>                    Set Label_Justification_Mode to JMode_Right
91789>>>                    Set Prompt_Button_Mode to PB_PromptOn
91790>>>                    Set Prompt_Object to (oSQLConnections(Self))
91791>>>
91791>>>                    Procedure Prompt
91794>>>                        String[] sTheData
91795>>>                        String sCurrentVal sNewVal
91795>>>                        Handle hoIniFile ho
91795>>>                        Integer iSize iCount
91795>>>                        tSQLConnection[] SQLConnectionArray
91795>>>                        tSQLConnection[] SQLConnectionArray
91796>>>
91796>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
91797>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
91798>>>                        Get Value to sCurrentVal
91799>>>                        Get Prompt_Object to ho
91800>>>                        Set psTheData of ho to SQLConnectionArray
91801>>>
91801>>>                        Forward Send Prompt
91803>>>                        Get Value to sNewVal
91804>>>                        If (sCurrentVal <> sNewVal) Begin
91806>>>                            Send Cursor_Wait of Cursor_Control
91807>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
91808>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
91810>>>                            Send Cursor_Ready of Cursor_Control
91811>>>                            Send KeyAction of oTestLogin_btn
91812>>>                        End
91812>>>>
91812>>>                    End_Procedure   
91813>>>                    
91813>>>                    Procedure PromptUpdate Handle hoPrompt
91816>>>                        String[] sSelectedNames                    
91817>>>                
91817>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
91818>>>                        If (SizeOfArray(sSelectedNames)) Begin
91820>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
91821>>>                            Delegate Send Page True // Broadcast sends refresh
91823>>>                        End
91823>>>>
91823>>>                    End_Procedure   
91824>>>
91824>>>                    Procedure Prompt_Callback Handle hoPrompt
91827>>>                        String sServer
91827>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
91828>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
91829>>>                        Get Value of oServer_fm to sServer
91830>>>                        Set psSeedValue of hoPrompt to sServer
91831>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
91832>>>                    End_Procedure
91833>>>
91833>>>                    Procedure Refresh
91836>>>                        String sValue
91836>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
91837>>>                        Set Value to sValue
91838>>>                    End_Procedure
91839>>>
91839>>>                End_Object
91840>>>
91840>>>                Object oDriverID_cf is a ComboForm
91842>>>                    Set Size to 12 91
91843>>>                    Set Location to 12 222
91844>>>                    Set Label_Col_Offset to 2
91845>>>                    Set Label_Justification_Mode to JMode_Right
91846>>>                    Set Label to "Driver ID"
91847>>>                    Set Entry_State to False
91848>>>                    Set Enabled_State to False
91849>>>
91849>>>                    Procedure Combo_Fill_List
91852>>>                        Send Combo_Add_Item MSSQLDRV_ID
91853>>>                        Send Combo_Add_Item DB2_DRV_ID
91854>>>                        Send Combo_Add_Item ODBC_DRV_ID
91855>>>                    End_Procedure
91856>>>
91856>>>                    Procedure OnChange
91859>>>                        String sValue sOrgValue
91859>>>                        Boolean bEnabled bChecked
91859>>>
91859>>>                        Get Value to sValue
91860>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
91861>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
91863>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
91864>>>                        End
91864>>>>
91864>>>                        Move (sValue <> "None") to bEnabled
91865>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
91867>>>                        Set Enabled_State to False
91868>>>                        Set Enabled_State of oConnectionString_fm to False
91869>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
91870>>>
91870>>>                        Get Checked_State of oTrusted_cb  to bChecked
91871>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
91872>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
91873>>>                    End_Procedure
91874>>>
91874>>>                    Procedure Refresh
91877>>>                        String sValue
91877>>>
91877>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
91878>>>                        Set Value to sValue
91879>>>                    End_Procedure
91880>>>
91880>>>                End_Object
91881>>>
91881>>>                Object oServer_fm is a Form
91883>>>                    Set Size to 12 100
91884>>>                    Set Location to 26 68
91885>>>                    Set Label to "Server"
91886>>>                    Set Label_Col_Offset to 2
91887>>>                    Set Label_Justification_Mode to JMode_Right
91888>>>                    Set Prompt_Button_Mode to PB_PromptOn
91889>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
91890>>>
91890>>>                    Procedure Refresh
91893>>>                        String sValue
91893>>>                        Get psServer of ghoSQLConnectionHandler to sValue
91894>>>                        Set Value to sValue
91895>>>                    End_Procedure
91896>>>
91896>>>                    Procedure Prompt
91899>>>                        String[] sTheData
91900>>>                        String sDriverID
91900>>>                        Handle ho
91900>>>
91900>>>                        Send Cursor_Wait of Cursor_Control
91901>>>                        Get Prompt_Object to ho
91902>>>                        Get Value of oDriverID_cf to sDriverID
91903>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
91904>>>                        Set psTheData of ho to sTheData
91905>>>                        Send Cursor_Ready of Cursor_Control
91906>>>
91906>>>                        Forward Send Prompt
91908>>>                    End_Procedure
91909>>>
91909>>>                End_Object
91910>>>
91910>>>                Object oDatabase_fm is a Form
91912>>>                    Set Size to 12 91
91913>>>                    Set Location to 26 222
91914>>>                    Set Label to "Database"
91915>>>                    Set Label_Col_Offset to 2
91916>>>                    Set Label_Justification_Mode to JMode_Right
91917>>>                    Set Prompt_Button_Mode to PB_PromptOn
91918>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
91919>>>                    Set peAnchors to anNone
91920>>>                    Set Entry_State to False
91921>>>
91921>>>                    Procedure Refresh
91924>>>                        String sDatabase
91924>>>
91924>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
91925>>>                        Set Value to sDatabase
91926>>>                    End_Procedure
91927>>>
91927>>>                    Procedure Prompt
91930>>>                        String[] sTheData
91931>>>                        Handle ho
91931>>>                        String sDriverID
91931>>>
91931>>>                        Get Value of oDriverID_cf to sDriverID
91932>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
91933>>>
91933>>>                        Get Prompt_Object to ho
91934>>>                        Set psTheData of ho to sTheData
91935>>>
91935>>>                        Forward Send Prompt
91937>>>                    End_Procedure
91938>>>
91938>>>                    Procedure OnChange
91941>>>                        String sValue sOrgValue
91941>>>                        Get Value to sValue
91942>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
91943>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
91945>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
91946>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
91947>>>                            Set Value of oConnectionString_fm to sValue
91948>>>                        End
91948>>>>
91948>>>                    End_Procedure
91949>>>
91949>>>                End_Object
91950>>>
91950>>>                Object oTrusted_cb is a CheckBox
91952>>>                    Set Size to 10 50
91953>>>                    Set Location to 45 68
91954>>>                    Set Label to "Use Trusted Connection"
91955>>>
91955>>>                    Procedure Refresh
91958>>>                        Boolean bValue
91958>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
91959>>>                        Set Checked_State to bValue
91960>>>                    End_Procedure
91961>>>
91961>>>                    Procedure OnChange
91964>>>                        Boolean bChecked
91964>>>
91964>>>                        Get Checked_State to bChecked
91965>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
91966>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
91967>>>                    End_Procedure
91968>>>
91968>>>                End_Object
91969>>>
91969>>>                Object oUserID_fm is a Form
91971>>>                    Set Size to 12 100
91972>>>                    Set Location to 57 68
91973>>>                    Set Label to "UserID"
91974>>>                    Set Label_Col_Offset to 2
91975>>>                    Set Label_Justification_Mode to JMode_Right
91976>>>
91976>>>                    Procedure Refresh
91979>>>                        String sValue
91979>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
91980>>>                        Set Value to sValue
91981>>>                    End_Procedure
91982>>>
91982>>>                End_Object
91983>>>
91983>>>                Object oPassword_fm is a Form
91985>>>                    Set Size to 12 91
91986>>>                    Set Location to 57 222
91987>>>                    Set Label to "Password"
91988>>>                    Set Label_Col_Offset to 2
91989>>>                    Set Label_Justification_Mode to JMode_Right
91990>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
91990>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
91991>>>                    Set Password_State to True
91992>>>
91992>>>                    Procedure Refresh
91995>>>                        String sValue
91995>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
91996>>>                        Set Value to sValue
91997>>>                    End_Procedure
91998>>>
91998>>>                End_Object
91999>>>
91999>>>                Object oViewPassword_btn is a cRDCButtonDPI
92001>>>                    Set Size to 12 19
92002>>>                    Set Location to 57 317
92003>>>                    Set psToolTip to "Toggle password"
92004>>>                    Set psImage to "ViewPassword1.ico"
92005>>>                    Set piImageMarginLeft to 0
92006>>>
92006>>>                    Procedure OnClick
92009>>>                        Boolean bState
92009>>>                        Get Password_State of oPassword_fm to bState
92010>>>                        Send Page_Object   of oPassword_fm False
92011>>>                        Set Password_State of oPassword_fm to (not(bState))
92012>>>                        Send Page_Object   of oPassword_fm True
92013>>>                    End_Procedure
92014>>>
92014>>>                End_Object
92015>>>
92015>>>                Object oTestLogin_btn is a cRDCButtonDPI
92017>>>                    Set Size to 12 56
92018>>>                    Set Location to 57 340
92019>>>                    Set Label to "Test Login"
92020>>>                    Set peAnchors to anNone
92021>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
92022>>>                    Set FontWeight to fw_Bold
92023>>>                    Set psImage to "ActionLogin1.ico"
92024>>>                    Set piImageMarginLeft to 0
92025>>>
92025>>>                    Procedure OnClick
92028>>>                        tSQLConnection SQLConnection
92028>>>                        tSQLConnection SQLConnection
92028>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
92028>>>                        Boolean bTrusted bMertechDriver bLoginSuccessful
92028>>>                        Integer iDriverID
92028>>>                        Handle hoDriver
92028>>>
92028>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
92029>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
92030>>>                        Get Value of oServer_fm          to SQLConnection.sServer
92031>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
92032>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
92033>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
92034>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
92035>>>
92035>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
92036>>>
92036>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
92037>>>                        If (iDriverID = 0) Begin
92039>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
92040>>>                            Procedure_Return
92041>>>                        End
92041>>>>
92041>>>
92041>>>                        Get IsMertechDriver of ghoSQLConnectionHandler SQLConnection.sDriverID to bMertechDriver
92042>>>                        If (bMertechDriver = False) Begin
92044>>>                            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
92047>>>                        End
92047>>>>
92047>>>
92047>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92048>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92049>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
92050>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
92051>>>                        Send Destroy   of hoDriver
92052>>>
92052>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92053>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
92055>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
92056>>>                            Set Value of oConnectionString_fm to sConnectionString
92057>>>                            Send Info_Box "Login Successful!"
92058>>>                        End
92058>>>>
92058>>>                        Else Begin
92059>>>                            Send Info_Box "Nope, that didn't work. Login failed."
92060>>>                        End
92060>>>>
92060>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
92062>>>                        Move 0 to LastErr
92063>>>                    End_Procedure
92064>>>
92064>>>                End_Object
92065>>>
92065>>>                Object oConnectionString_fm is a Form
92067>>>                    Set Size to 12 328
92068>>>                    Set Location to 82 68
92069>>>                    Set Label to "Connection String"    
92070>>>                    Set Label_Col_Offset to 2
92071>>>                    Set Label_Justification_Mode to JMode_Right
92072>>>                    Set peAnchors to anTopLeftRight
92073>>>                    Set Enabled_State to False
92074>>>
92074>>>                    Procedure Refresh
92077>>>                        String sValue
92077>>>                        tSQLConnection SQLConnection
92077>>>                        tSQLConnection SQLConnection
92077>>>
92077>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92078>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
92079>>>                        Set Value to sValue
92080>>>                    End_Procedure
92081>>>
92081>>>                End_Object
92082>>>
92082>>>                Object oInfo_tb is a TextBox
92084>>>                    Set Auto_Size_State to False
92085>>>                    Set Size to 18 303
92086>>>                    Set Location to 106 8
92087>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
92088>>>                    Set Justification_Mode to JMode_Left
92089>>>                    Set FontItalics to True
92090>>>                End_Object
92091>>>
92091>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
92093>>>                    Set Size to 21 83
92094>>>                    Set Location to 106 315
92095>>>                    Set Label to "SQL Connections"
92096>>>                    Set peAnchors to anNone
92097>>>                    Set psImage to "SQLConnections1.ico"
92098>>>
92098>>>                    Procedure OnClick
92101>>>                        Runprogram Background "SQLConnections.exe"
92102>>>                    End_Procedure
92103>>>
92103>>>                End_Object
92104>>>
92104>>>                Object oGetCollation_btn is a Button
92106>>>                    Set Size to 27 91
92107>>>                    Set Location to 154 38
92108>>>                    Set Label to 'Get Database Collation'
92109>>>                
92109>>>                    Procedure OnClick
92112>>>                        String sCollation sDatabase
92112>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
92113>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
92114>>>                        Set Value of oGetCollation_fm to sCollation
92115>>>                    End_Procedure
92116>>>                
92116>>>                End_Object
92117>>>
92117>>>                Object oGetCollation_fm is a Form
92119>>>                    Set Size to 12 148
92120>>>                    Set Location to 162 143
92121>>>                    Set Label to "Current SQL Collation Name"
92122>>>                    Set Label_Col_Offset to 0
92123>>>                    Set Label_Row_Offset to 1
92124>>>                    Set Label_Justification_Mode to JMode_Top
92125>>>                End_Object
92126>>>        
92126>>>                Object oSetCollation_btn is a Button
92128>>>                    Set Size to 27 91
92129>>>                    Set Location to 188 38
92130>>>                    Set Label to "Set Database Collation"
92131>>>                
92131>>>                    Procedure OnClick
92134>>>                        String sCollation sDatabase sErrorText
92134>>>                        Boolean bOK
92134>>>                        Integer iRetval  
92134>>>                        tSqlErrorArray aSqlErrorArray
92134>>>                        tSqlErrorArray aSqlErrorArray
92134>>>                        
92134>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
92135>>>                        Get Value of oSetCollation_fm to sCollation
92136>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
92137>>>                        If (iRetval <> MBR_Yes) Begin
92139>>>                            Procedure_Return
92140>>>                        End
92140>>>>
92140>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
92141>>>                        If (bOK = True) Begin
92143>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
92144>>>                        End
92144>>>>
92144>>>                        Else Begin                   
92145>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
92146>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
92147>>>                            Move (sErrorText + "\n")                  to sErrorText
92148>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
92149>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
92150>>>                        End
92150>>>>
92150>>>
92150>>>                    End_Procedure
92151>>>                
92151>>>                End_Object
92152>>>
92152>>>                Object oSetCollation_fm is a Form
92154>>>                    Set Size to 12 148
92155>>>                    Set Location to 197 143
92156>>>                    Set Label to "New SQL Collation Name"
92157>>>                    Set Label_Col_Offset to 0
92158>>>                    Set Label_Row_Offset to 1
92159>>>                    Set Label_Justification_Mode to JMode_Top
92160>>>                End_Object
92161>>>
92161>>>                Procedure Page Integer iPageObject
92164>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
92166>>>                    Forward Send Page iPageObject
92168>>>                End_Procedure
92169>>>
92169>>>            End_Object
92170>>>
92170>>>        End_Object
92171>>>        
92171>>>    End_Object
92172>>>
92172>>>End_Object
92173>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
92173>>>Use Windows.pkg
92173>>>Use DFClient.pkg
92173>>>Use Dfspnfrm.pkg
92173>>>Use cDbScrollingContainer.pkg
92173>>>Use cRDCButtonDPI.pkg
92173>>>Use cDbUpdateFunctionLibrary.pkg
92173>>>Use SQLDatabaseBackup.dg
92173>>>
92173>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
92183>>>>
92183>>>Object oSQLFunctions_vw is a dbView
92185>>>    Set Border_Style to Border_Thick
92186>>>    Set Size to 260 426
92187>>>    Set Location to -4 2
92188>>>    Set Label to "Functions"
92189>>>    Set pbAutoActivate to True
92190>>>    Set Icon to "Sql1.ico"
92191>>>
92191>>>    Procedure OnSetFocus
92194>>>        String sValue
92194>>>        tSQLConnection SQLConnection
92194>>>        tSQLConnection SQLConnection
92194>>>
92194>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92195>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
92196>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
92197>>>        Set Value of oSQLConnectionString_fm to sValue
92198>>>    End_Procedure
92199>>>
92199>>>    Object oScrollingContainer1 is a cDbScrollingContainer
92201>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
92203>>>
92203>>>            Object oSQLFunctionTests_grp is a Group
92205>>>                Set Size to 243 402
92206>>>                Set Location to 7 12
92207>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
92208>>>                Set peAnchors to anAll
92209>>>
92209>>>                Object oSQLConnectionString_fm is a Form
92211>>>                    Set Size to 12 375
92212>>>                    Set Location to 23 14
92213>>>                    Set Label to "Current Connection String Settings:"
92214>>>                    Set Label_Col_Offset to 0
92215>>>                    Set Label_Justification_Mode to JMode_Top
92216>>>                    Set peAnchors to anTopLeftRight
92217>>>                    Set Enabled_State to False
92218>>>                    Set Label_Row_Offset to 1
92219>>>                End_Object
92220>>>
92220>>>                Object oSQLDatabase_fm is a Form
92222>>>                    Set Size to 12 86
92223>>>                    Set Location to 50 14
92224>>>                    Set Label to "Database:"
92225>>>                    Set Label_Col_Offset to 0
92226>>>                    Set Label_Justification_Mode to JMode_Top
92227>>>                    Set Label_Row_Offset to 1
92228>>>                    Set FontWeight to fw_Bold
92229>>>                    Set Enabled_State to False
92230>>>                End_Object
92231>>>
92231>>>                Object oDriverID2_cf is a ComboForm
92233>>>                    Set Size to 12 91
92234>>>                    Set Location to 50 121
92235>>>                    Set Label_Col_Offset to 0
92236>>>                    Set Label_Justification_Mode to JMode_Top
92237>>>                    Set Label to "Driver ID:"
92238>>>                    Set Entry_State to False
92239>>>                    Set Enabled_State to False
92240>>>                    Set Label_Row_Offset to 1
92241>>>
92241>>>                    Procedure Combo_Fill_List
92244>>>                        Send Combo_Add_Item MSSQLDRV_ID
92245>>>                        Send Combo_Add_Item DB2_DRV_ID
92246>>>                        Send Combo_Add_Item ODBC_DRV_ID
92247>>>                    End_Procedure
92248>>>
92248>>>                    Procedure Refresh
92251>>>                        String sValue
92251>>>
92251>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
92252>>>                        Set Value to sValue
92253>>>                    End_Procedure
92254>>>
92254>>>                End_Object
92255>>>
92255>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
92257>>>                    Set Size to 12 109
92258>>>                    Set Location to 50 220
92259>>>                    Set Label to "Backup MS-SQL Database"
92260>>>                    Set psImage to "DbBackup1.ico"
92261>>>
92261>>>                    Procedure OnClick
92264>>>                        Boolean bOK
92264>>>
92264>>>                        // SQLDatabaseBackup dialog:
92264>>>                        Get MakeSQLDatabaseBackup to bOK
92265>>>
92265>>>                        If (bOK = True) Begin
92267>>>                            Send Info_Box "The backup of the database was successful!"
92268>>>                        End
92268>>>>
92268>>>                        Else Begin
92269>>>                            Send Info_Box "The database was not backup up"
92270>>>                        End
92270>>>>
92270>>>                    End_Procedure
92271>>>
92271>>>                End_Object
92272>>>
92272>>>                Object oDatabaseInfo_tb is a TextBox
92274>>>                    Set Auto_Size_State to False
92275>>>                    Set Size to 25 96
92276>>>                    Set Location to 64 14
92277>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
92278>>>                    Set Justification_Mode to JMode_Left
92279>>>                End_Object
92280>>>
92280>>>                Object oSQLInfo_tb is a TextBox
92282>>>                    Set Auto_Size_State to False
92283>>>                    Set Size to 37 270
92284>>>                    Set Location to 76 118
92285>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
92286>>>                    Set Justification_Mode to JMode_Left
92287>>>                End_Object
92288>>>
92288>>>                Object oSQLTableName_cf is a ComboForm
92290>>>                    Set Size to 12 96
92291>>>                    Set Location to 106 14
92292>>>                    Set Label_Col_Offset to 0
92293>>>                    Set Label_Justification_Mode to JMode_Top
92294>>>                    Set Label to "Select Table:"
92295>>>                    Set Label_Row_Offset to 1
92296>>>                    Set Entry_State to False
92297>>>
92297>>>                    Procedure OnDropDown
92300>>>                        Send DoCombo_Fill_List
92301>>>                    End_Procedure
92302>>>
92302>>>                    Procedure OnCloseUp
92305>>>                        Send Delete_Data of oSQLColumnName_cf
92306>>>                    End_Procedure
92307>>>
92307>>>                    Procedure DoCombo_Fill_List
92310>>>                        String[] sTablesArray
92311>>>                        String sDriverID
92311>>>                        Integer iCount iSize
92311>>>
92311>>>                        Send Delete_Data
92312>>>                        Get Value of oDriverID2_cf to sDriverID
92313>>>                        Get SQLUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
92314>>>                        Move (SizeOfArray(sTablesArray)) to iSize
92315>>>                        Decrement iSize
92316>>>                        For iCount from 0 to iSize
92322>>>>
92322>>>                            Send Combo_Add_Item sTablesArray[iCount]
92323>>>                        Loop
92324>>>>
92324>>>                    End_Procedure
92325>>>
92325>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
92325>>>                    // Augmented Value function.
92325>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
92325>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
92325>>>                    Function Value Integer iItem Returns String
92328>>>                        String sValue
92328>>>                        Get WinCombo_Current_Item to iItem
92329>>>                        Get WinCombo_Value iItem  to sValue
92330>>>                        Function_Return sValue
92331>>>                    End_Function
92332>>>
92332>>>                End_Object
92333>>>
92333>>>                Object oSQLColumnName_cf is a ComboForm
92335>>>                    Set Size to 12 96
92336>>>                    Set Location to 134 14
92337>>>                    Set Label_Col_Offset to 0
92338>>>                    Set Label_Justification_Mode to JMode_Top
92339>>>                    Set Label to "Select Column:"
92340>>>                    Set Label_Row_Offset to 1
92341>>>                    Set Entry_State to False
92342>>>
92342>>>                    Procedure DoCombo_Fill_List
92345>>>                        String[] sColumnsArray
92346>>>                        String sTableName sDriverID
92346>>>                        Integer iCount iSize
92346>>>
92346>>>                        Send Delete_Data
92347>>>                        Get Value of oDriverID2_cf    to sDriverID
92348>>>                        Get Value of oSQLTableName_cf to sTableName
92349>>>                        Get SQLUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
92350>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
92351>>>                        Decrement iSize
92352>>>                        For iCount from 0 to iSize
92358>>>>
92358>>>                            Send Combo_Add_Item sColumnsArray[iCount]
92359>>>                        Loop
92360>>>>
92360>>>                        If (iSize > 1) Begin
92362>>>                            Set Current_Item to 1
92363>>>                        End
92363>>>>
92363>>>                    End_Procedure
92364>>>
92364>>>                    Procedure OnDropDown
92367>>>                        Send DoCombo_Fill_List
92368>>>                    End_Procedure
92369>>>                End_Object
92370>>>
92370>>>                Object oSQLRenameColumnTo_fm is a Form
92372>>>                    Set Size to 12 96
92373>>>                    Set Location to 134 116
92374>>>                    Set Label_Col_Offset to 0
92375>>>                    Set Label_Justification_Mode to JMode_Top
92376>>>                    Set Label to "Rename Column To:"
92377>>>                    Set Label_Row_Offset to 1
92378>>>                    Set Value to "NewColumnName"
92379>>>                End_Object
92380>>>
92380>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
92382>>>                    Set Size to 12 69
92383>>>                    Set Location to 134 220
92384>>>                    Set Label to "Rename Column"
92385>>>                    Set psToolTip to "Test of SQLColumnRename function"
92386>>>                    Set MultiLineState to True
92387>>>
92387>>>                    Procedure OnClick
92390>>>                        Boolean bOk
92390>>>                        Handle hTable
92390>>>                        String sTableName sColumnName sNewColumnName sDriverID
92390>>>
92390>>>                        Get Value of oSQLTableName_cf to sTableName
92391>>>                        If (sTableName = "") Begin
92393>>>                            Send Info_Box "You need to select a table first..."
92394>>>                            Procedure_Return
92395>>>                        End
92395>>>>
92395>>>                        Get Value of oSQLColumnName_cf to sColumnName
92396>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
92398>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
92399>>>                            Procedure_Return
92400>>>                        End
92400>>>>
92400>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
92401>>>                        If (Trim(sNewColumnName) = "") Begin
92403>>>                            Send Info_Box "You need to enter a column name to rename to..."
92404>>>                            Procedure_Return
92405>>>                        End
92405>>>>
92405>>>
92405>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
92406>>>                        If (hTable = 0) Begin
92408>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
92409>>>                            Procedure_Return
92410>>>                        End
92410>>>>
92410>>>
92410>>>                        Get Value of oDriverID2_cf to sDriverID
92411>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
92412>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
92413>>>                        If (bOk = True) Begin
92415>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
92415>>>                            Send Delete_Data of oSQLColumnName_cf
92416>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
92417>>>                        End
92417>>>>
92417>>>                        Else Begin
92418>>>                            Send Info_Box "Nope, that didn't work..."
92419>>>                        End
92419>>>>
92419>>>
92419>>>                    End_Procedure
92420>>>
92420>>>                End_Object
92421>>>
92421>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
92423>>>                    Set Size to 12 91
92424>>>                    Set Location to 134 297
92425>>>                    Set Label to "Drop Column"
92426>>>                    Set psToolTip to "Test of SQLColumnRemove function"
92427>>>                    Set psImage to "DeleteColumn1.ico"
92428>>>
92428>>>                    Procedure OnClick
92431>>>                        Boolean bOk
92431>>>                        String sTableName sColumnName sDriverID
92431>>>                        Integer iRetval
92431>>>
92431>>>                        Get Value of oDriverID2_cf              to sDriverID
92432>>>                        Get Value of oSQLTableName_cf           to sTableName
92433>>>                        Get Value of oSQLColumnName_cf          to sColumnName
92434>>>
92434>>>                        If (sTableName = "" or sColumnName = "") Begin
92436>>>                            Send Info_Box "You first need to select a table and a column."
92437>>>                            Procedure_Return
92438>>>                        End
92438>>>>
92438>>>
92438>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
92439>>>                        If (iRetval <> MBR_Yes) Begin
92441>>>                            Procedure_Return
92442>>>                        End
92442>>>>
92442>>>
92442>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
92443>>>
92443>>>                        If (bOk = True) Begin
92445>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
92445>>>                            Send Delete_Data of oSQLColumnName_cf
92446>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
92447>>>                        End
92447>>>>
92447>>>                        Else Begin
92448>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
92449>>>                            Procedure_Return
92450>>>                        End
92450>>>>
92450>>>
92450>>>                    End_Procedure
92451>>>
92451>>>                End_Object
92452>>>
92452>>>                Object oSQLAddColumnName_fm is a Form
92454>>>                    Set Size to 12 96
92455>>>                    Set Location to 177 14
92456>>>                    Set Label_Col_Offset to 0
92457>>>                    Set Label_Justification_Mode to JMode_Top
92458>>>                    Set Label to "Column Name:"
92459>>>                    Set Label_Row_Offset to 1
92460>>>                    Set Value to "NewColumn"
92461>>>                End_Object
92462>>>
92462>>>                Object oSQLColumnType_cf is a ComboForm
92464>>>                    Set Size to 12 96
92465>>>                    Set Location to 177 116
92466>>>                    Set Label_Col_Offset to 0
92467>>>                    Set Label_Justification_Mode to JMode_Top
92468>>>                    Set Label_Row_Offset to 1
92469>>>                    Set Label to "Type:"
92470>>>                    Set Entry_State to False
92471>>>
92471>>>                    Procedure Combo_Fill_List
92474>>>                        tColumnType[] ColumnTypeArray
92474>>>                        tColumnType[] ColumnTypeArray
92475>>>                        Integer iSize iCount iDbType
92475>>>                        String sDriverID
92475>>>
92475>>>                        Send Delete_Data
92476>>>                        Get Value of oDriverID2_cf to sDriverID
92477>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
92478>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
92479>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
92480>>>                        Decrement iSize
92481>>>                        For iCount from 0 to iSize
92487>>>>
92487>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
92488>>>                        Loop
92489>>>>
92489>>>                        If (iSize > 0) Begin
92491>>>                            Set Value to ColumnTypeArray[0].sSQLType
92492>>>                        End
92492>>>>
92492>>>                    End_Procedure
92493>>>
92493>>>                    Procedure OnChange
92496>>>                        Integer iType iSize iDec
92496>>>                        tSQLConnection SQLConnection
92496>>>                        tSQLConnection SQLConnection
92496>>>                        Boolean bFixed
92496>>>
92496>>>                        Get SelectedType to iType
92497>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92498>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
92499>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
92500>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
92501>>>
92501>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
92502>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
92503>>>                        Set Value         of oSQLLength_sf   to iSize
92504>>>                        If (iDec = 0) Begin
92506>>>                            Set Value     of oSQLDecimals_sf to ""
92507>>>                        End
92507>>>>
92507>>>                        Else Begin
92508>>>                            Set Value     of oSQLDecimals_sf to iDec
92509>>>                        End
92509>>>>
92509>>>                        If (bFixed = False) Begin
92511>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
92512>>>                        End
92512>>>>
92512>>>                    End_Procedure
92513>>>
92513>>>                    Function SelectedType Returns Integer
92516>>>                        String sValue sDriverID
92516>>>                        Integer iType iDbType
92516>>>
92516>>>                        Get Value to sValue
92517>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
92518>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
92519>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
92520>>>
92520>>>                        Function_Return iType
92521>>>                    End_Function
92522>>>
92522>>>                End_Object
92523>>>
92523>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
92525>>>                    Set Size to 12 69
92526>>>                    Set Location to 177 220
92527>>>                    Set Label to "Add Column"
92528>>>                    Set psToolTip to "Test of SQLColumnAdd function"
92529>>>                    Set psImage to "AddColumn1.ico"
92530>>>
92530>>>                    Procedure OnClick
92533>>>                        Boolean bOk bInitialize
92533>>>                        Handle hTable
92533>>>                        String sTableName sColumnName sType sColumnValue sDriverID
92533>>>                        Integer iType iLength iDecimals
92533>>>
92533>>>                        Get Value of oDriverID2_cf              to sDriverID
92534>>>                        Get Value of oSQLTableName_cf           to sTableName
92535>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
92536>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
92537>>>                        Get Value         of oSQLColumnType_cf  to sType
92538>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
92539>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
92540>>>                        Get Value         of oSQLLength_sf      to iLength
92541>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
92542>>>
92542>>>                        If (sTableName <> "") Begin
92544>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
92545>>>                            If (hTable = 0) Begin
92547>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
92548>>>                            End
92548>>>>
92548>>>                        End
92548>>>>
92548>>>                        If (hTable = 0) Begin
92550>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
92551>>>                            Procedure_Return
92552>>>                        End
92552>>>>
92552>>>                        If (sColumnName = "") Begin
92554>>>                            Send Info_Box "You need to enter a column name"
92555>>>                            Procedure_Return
92556>>>                        End
92556>>>>
92556>>>
92556>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
92557>>>
92557>>>                        If (bOk = True) Begin
92559>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
92560>>>                        End
92560>>>>
92560>>>                        Else Begin
92561>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
92562>>>                            Procedure_Return
92563>>>                        End
92563>>>>
92563>>>
92563>>>                    End_Procedure
92564>>>
92564>>>                End_Object
92565>>>
92565>>>//                Object oTest_btn is a cRDCButtonDPI
92565>>>//                    Set Size to 13 92
92565>>>//                    Set Location to 177 298
92565>>>//                    Set Label to "Test SQL script button"
92565>>>//
92565>>>//                    Procedure OnClick
92565>>>//                        Boolean bOK
92565>>>//                        String sTableName sColumnName
92565>>>//
92565>>>//                        Get Value of oSQLTableName_cf      to sTableName
92565>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
92565>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
92565>>>//
92565>>>//                    End_Procedure
92565>>>//
92565>>>//                End_Object
92565>>>
92565>>>                Object oSQLLength_sf is a SpinForm
92567>>>                    Set Label to "Length:"
92568>>>                    Set Size to 12 40
92569>>>                    Set Location to 202 16
92570>>>                    Set Label_Col_Offset to 0
92571>>>                    Set Label_Justification_Mode to JMode_Top
92572>>>                    Set Label_Row_Offset to 1
92573>>>                    Set Value to "10"
92574>>>                    Set Maximum_Position to 500
92575>>>                    Set Minimum_Position to 1
92576>>>                End_Object
92577>>>
92577>>>                Object oSQLDecimals_sf is a SpinForm
92579>>>                    Set Label to "Decimals:"
92580>>>                    Set Size to 12 33
92581>>>                    Set Location to 202 60
92582>>>                    Set Label_Col_Offset to 0
92583>>>                    Set Label_Justification_Mode to JMode_Top
92584>>>                    Set Label_Row_Offset to 1
92585>>>                    Set Value to "0"
92586>>>                    Set Maximum_Position to 16
92587>>>                    Set Minimum_Position to 1
92588>>>                End_Object
92589>>>
92589>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
92591>>>                    Set Size to 12 85
92592>>>                    Set Location to 202 116
92593>>>                    Set Label to "Initialize Column Value"
92594>>>
92594>>>                    Procedure OnChange
92597>>>                        Boolean bChecked
92597>>>
92597>>>                        Get Checked_State to bChecked
92598>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
92599>>>                    End_Procedure
92600>>>
92600>>>                End_Object
92601>>>
92601>>>                Object oSQLColumnValue_fm is a Form
92603>>>                    Set Size to 12 96
92604>>>                    Set Location to 218 116
92605>>>                    Set Label_Col_Offset to 2
92606>>>                    Set Label_Justification_Mode to JMode_Right
92607>>>                    Set Label to "Column Value"
92608>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
92609>>>                    Set Enabled_State to False
92610>>>                End_Object
92611>>>
92611>>>                Object oEnumRelations_btn is a cRDCButtonDPI
92613>>>                    Set Size to 12 91
92614>>>                    Set Location to 116 297
92615>>>                    Set Label to "Test Enum SQL Relations"
92616>>>
92616>>>                    Procedure OnClick
92619>>>                        tSQLRelation[] SQLRelationArray
92619>>>                        tSQLRelation[] SQLRelationArray
92620>>>                        String sTableName sDriverID
92620>>>                        Integer iSize iCount
92620>>>
92620>>>                        Get Value of oDriverID2_cf to sDriverID
92621>>>                        Get Value of oSQLTableName_cf to sTableName
92622>>>                        Get SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
92623>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
92624>>>                        Decrement iSize
92625>>>                        For iCount from 0 to iSize
92631>>>>
92631>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
92640>>>                        Loop
92641>>>>
92641>>>                        If (iSize < 1) Begin
92643>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
92644>>>                        End
92644>>>>
92644>>>
92644>>>                    End_Procedure
92645>>>
92645>>>                End_Object
92646>>>
92646>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
92648>>>                    Set Size to 12 101
92649>>>                    Set Location to 177 297
92650>>>                    Set Label to "Enumerate Logged In Users"
92651>>>
92651>>>                    Procedure OnClick
92654>>>                        tSQLLoggedInUser[] SQLLoggedInUser
92654>>>                        tSQLLoggedInUser[] SQLLoggedInUser
92655>>>                        String sDriverID sDatabase
92655>>>                        Integer iSize iCount
92655>>>
92655>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
92656>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
92657>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
92658>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
92659>>>                        Decrement iSize
92660>>>
92660>>>                        Showln "SQL User Name" " and Program:"
92663>>>                        For iCount from 0 to iSize
92669>>>>
92669>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
92673>>>                        Loop
92674>>>>
92674>>>                    End_Procedure
92675>>>
92675>>>                End_Object
92676>>>
92676>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
92678>>>                    Set Size to 12 101
92679>>>                    Set Location to 193 297
92680>>>                    Set Label to "Is Table or View?"
92681>>>
92681>>>                    Procedure OnClick
92684>>>                        String sDriverID sTableName
92684>>>                        Handle hTable
92684>>>                        Boolean bViewTableType
92684>>>
92684>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
92685>>>                        Get Value of oSQLTableName_cf to sTableName
92686>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
92687>>>                        If (hTable = 0) Begin
92689>>>                            Procedure_Return
92690>>>                        End
92690>>>>
92690>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
92691>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
92692>>>                    End_Procedure
92693>>>
92693>>>                End_Object
92694>>>
92694>>>            End_Object
92695>>>
92695>>>        End_Object
92696>>>
92696>>>    End_Object
92697>>>
92697>>>End_Object
92698>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
92698>>>Use Windows.pkg
92698>>>Use DFClient.pkg
92698>>>Use Dfspnfrm.pkg
92698>>>Use Dfline.pkg
92698>>>Use cDbScrollingContainer.pkg
92698>>>Use cRDCButtonDPI.pkg
92698>>>Use cDbUpdateFunctionLibrary.pkg
92698>>>
92698>>>Define CI_Table1_FileNo for 401
92698>>>Define CI_View1_FileNo  for 402
92698>>>
92698>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
92708>>>>
92708>>>Object oAPIFunctions_vw is a dbView
92710>>>    Set Border_Style to Border_Thick
92711>>>    Set Size to 237 424
92712>>>    Set Location to 17 2
92713>>>    Set Label to "API Functions"
92714>>>    Set pbAutoActivate to True
92715>>>    Set Icon to "APIFunctions1.ico"
92716>>>
92716>>>    Property String psTableName ""
92718>>>
92718>>>    Procedure OnSetFocus
92721>>>        String sValue
92721>>>        tSQLConnection SQLConnection
92721>>>        tSQLConnection SQLConnection
92721>>>
92721>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92722>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
92723>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
92724>>>        Set Value of oApiConnectionString_fm to sValue
92725>>>    End_Procedure
92726>>>
92726>>>    Object oScrollingContainer1 is a cDbScrollingContainer
92728>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
92730>>>
92730>>>            Object oApiFunctions_grp is a Group
92732>>>                Set Size to 222 402
92733>>>                Set Location to 6 12
92734>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
92735>>>                Set peAnchors to anAll
92736>>>
92736>>>                Object oApiConnectionString_fm is a Form
92738>>>                    Set Size to 12 368
92739>>>                    Set Location to 23 14
92740>>>                    Set Label to "Current Connection String Settings:"
92741>>>                    Set Label_Col_Offset to 0
92742>>>                    Set Label_Justification_Mode to JMode_Top
92743>>>                    Set peAnchors to anTopLeftRight
92744>>>                    Set Enabled_State to False
92745>>>                    Set Label_Row_Offset to 1
92746>>>                End_Object
92747>>>
92747>>>                Object oApiDatabase_fm is a Form
92749>>>                    Set Size to 12 86
92750>>>                    Set Location to 50 14
92751>>>                    Set Label to "Database:"
92752>>>                    Set Label_Col_Offset to 0
92753>>>                    Set Label_Justification_Mode to JMode_Top
92754>>>                    Set Label_Row_Offset to 1
92755>>>                    Set Enabled_State to False
92756>>>                    Set FontWeight to fw_Bold
92757>>>//                    Set Label_FontWeight to fw_Bold
92757>>>
92757>>>                    Procedure Page Integer iPageObject
92760>>>                        String sValue
92760>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
92761>>>                        Set Value to sValue
92762>>>
92762>>>                        Forward Send Page iPageObject
92764>>>                    End_Procedure
92765>>>
92765>>>                End_Object
92766>>>
92766>>>                Object oDriverID3_cf is a ComboForm
92768>>>                    Set Size to 12 91
92769>>>                    Set Location to 51 121
92770>>>                    Set Label_Col_Offset to 0
92771>>>                    Set Label_Justification_Mode to JMode_Top
92772>>>                    Set Label to "Driver ID:"
92773>>>                    Set Entry_State to False
92774>>>                    Set Enabled_State to False
92775>>>                    Set Label_Row_Offset to 1
92776>>>                    Set Enabled_State to False
92777>>>
92777>>>                    Procedure Combo_Fill_List
92780>>>                        Send Combo_Add_Item MSSQLDRV_ID
92781>>>                        Send Combo_Add_Item DB2_DRV_ID
92782>>>                        Send Combo_Add_Item ODBC_DRV_ID
92783>>>                    End_Procedure
92784>>>
92784>>>                    Procedure Refresh
92787>>>                        String sValue
92787>>>
92787>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
92788>>>                        Set Value to sValue
92789>>>                    End_Procedure
92790>>>
92790>>>                End_Object
92791>>>
92791>>>                Object oDatabaseInfo_tb is a TextBox
92793>>>                    Set Auto_Size_State to False
92794>>>                    Set Size to 25 96
92795>>>                    Set Location to 64 14
92796>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
92797>>>                    Set Justification_Mode to JMode_Left
92798>>>                End_Object
92799>>>
92799>>>                Object oApiTableName_fm is a Form
92801>>>                    Set Size to 12 77
92802>>>                    Set Location to 114 14
92803>>>                    Set Label_Col_Offset to 0
92804>>>                    Set Label_Justification_Mode to JMode_Top
92805>>>                    Set Label to "Table Name:"
92806>>>                    Set Label_Row_Offset to 1
92807>>>                    Set Value to "NewTable"
92808>>>                    Procedure OnChange
92811>>>                        String sValue
92811>>>                        Get Value to sValue
92812>>>                        Set psTableName to sValue
92813>>>                    End_Procedure
92814>>>                    Send OnChange
92815>>>                End_Object
92816>>>
92816>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
92818>>>                    Set Size to 12 69
92819>>>                    Set Location to 114 271
92820>>>                    Set Label to "Add Table"
92821>>>                    Set psImage to "ActionAddTable1.ico"
92822>>>
92822>>>                    Procedure OnClick
92825>>>                        Boolean bOk
92825>>>                        Handle hTable
92825>>>                        String sTableName sDriverID
92825>>>
92825>>>                        Get Value of oDriverID3_cf to sDriverID
92826>>>                        Get Value of oApiTableName_fm to sTableName
92827>>>                        Move (Trim(sTableName)) to sTableName
92828>>>                        If (sTableName = "") Begin
92830>>>                            Send Info_Box "You first need to enter a table name."
92831>>>                            Procedure_Return
92832>>>                        End
92832>>>>
92832>>>
92832>>>                        Send Cursor_Wait of Cursor_Control
92833>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
92834>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
92835>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
92836>>>                        If (bOk = True) Begin
92838>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
92839>>>                        End
92839>>>>
92839>>>                        Else Begin
92840>>>                            Send Cursor_Ready of Cursor_Control
92841>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
92842>>>                            Procedure_Return
92843>>>                        End
92843>>>>
92843>>>
92843>>>                    End_Procedure
92844>>>
92844>>>                End_Object
92845>>>
92845>>>                Object oApiAddColumn_fm is a Form
92847>>>                    Set Size to 12 77
92848>>>                    Set Location to 141 14
92849>>>                    Set Label_Col_Offset to 0
92850>>>                    Set Label_Justification_Mode to JMode_Top
92851>>>                    Set Label to "Column Name:"
92852>>>                    Set Label_Row_Offset to 1
92853>>>                    Set Value to "NewColumn"
92854>>>                End_Object
92855>>>
92855>>>                Object oApiColumnType_cf is a ComboForm
92857>>>                    Set Size to 12 85
92858>>>                    Set Location to 141 96
92859>>>                    Set Label_Col_Offset to 0
92860>>>                    Set Label_Justification_Mode to JMode_Top
92861>>>                    Set Label_Row_Offset to 1
92862>>>                    Set Label to "Type:"
92863>>>                    Set Entry_State to False
92864>>>
92864>>>                    Procedure Combo_Fill_List
92867>>>                        tColumnType[] ColumnTypeArray
92867>>>                        tColumnType[] ColumnTypeArray
92868>>>                        Integer iSize iCount
92868>>>
92868>>>                        Send Delete_Data
92869>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
92870>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
92871>>>                        Decrement iSize
92872>>>                        For iCount from 0 to iSize
92878>>>>
92878>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
92879>>>                        Loop
92880>>>>
92880>>>                        Set Value to ColumnTypeArray[0].sSQLType
92881>>>                    End_Procedure
92882>>>
92882>>>                    Procedure OnChange
92885>>>                        Integer iType iSize iDec
92885>>>                        tSQLConnection SQLConnection
92885>>>                        tSQLConnection SQLConnection
92885>>>                        Boolean bFixed
92885>>>
92885>>>                        Get SelectedType to iType
92886>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92887>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
92888>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
92889>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
92890>>>
92890>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
92891>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
92892>>>                        Set Value         of oApiLength_sf   to iSize
92893>>>                        If (iDec = 0) Begin
92895>>>                            Set Value     of oApiDecimals_sf to ""
92896>>>                        End
92896>>>>
92896>>>                        Else Begin
92897>>>                            Set Value     of oApiDecimals_sf to iDec
92898>>>                        End
92898>>>>
92898>>>                        If (bFixed = False) Begin
92900>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
92901>>>                        End
92901>>>>
92901>>>                    End_Procedure
92902>>>
92902>>>                    Function SelectedType Returns Integer
92905>>>                        String sValue
92905>>>                        Integer iType
92905>>>
92905>>>                        Get Value to sValue
92906>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
92907>>>
92907>>>                        Function_Return iType
92908>>>                    End_Function
92909>>>
92909>>>                End_Object
92910>>>
92910>>>                Object oApiLength_sf is a SpinForm
92912>>>                    Set Label to "Length:"
92913>>>                    Set Size to 12 35
92914>>>                    Set Location to 141 186
92915>>>                    Set Label_Col_Offset to 0
92916>>>                    Set Label_Justification_Mode to JMode_Top
92917>>>                    Set Label_Row_Offset to 1
92918>>>                    Set Value to "10"
92919>>>                    Set Maximum_Position to 500
92920>>>                    Set Minimum_Position to 1
92921>>>                End_Object
92922>>>
92922>>>                Object oApiDecimals_sf is a SpinForm
92924>>>                    Set Label to "Decimals:"
92925>>>                    Set Size to 12 33
92926>>>                    Set Location to 141 225
92927>>>                    Set Label_Col_Offset to 0
92928>>>                    Set Label_Justification_Mode to JMode_Top
92929>>>                    Set Label_Row_Offset to 1
92930>>>                    Set Value to "0"
92931>>>                    Set Maximum_Position to 16
92932>>>                    Set Minimum_Position to 1
92933>>>                End_Object
92934>>>
92934>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
92936>>>                    Set Size to 12 69
92937>>>                    Set Location to 141 271
92938>>>                    Set Label to "Add Column"
92939>>>                    Set psToolTip to "ApiColumnAdd function"
92940>>>                    Set psImage to "ActionAddColumn1.ico"
92941>>>
92941>>>                    Procedure OnClick
92944>>>                        Boolean bOk
92944>>>                        Handle hTable
92944>>>                        String sTableName sColumnName sType sDriverID
92944>>>                        Integer iType iLength iDecimals
92944>>>
92944>>>                        Get Value of oDriverID3_cf            to sDriverID
92945>>>                        Get Value of oApiTableName_fm         to sTableName
92946>>>                        Get Value of oApiAddColumn_fm         to sColumnName
92947>>>                        Get SelectedType of oApiColumnType_cf to iType
92948>>>                        Get Value        of oApiLength_sf     to iLength
92949>>>                        Get Value        of oApiDecimals_sf   to iDecimals
92950>>>
92950>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
92951>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
92952>>>                        If (hTable = 0) Begin
92954>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
92955>>>                            Procedure_Return
92956>>>                        End
92956>>>>
92956>>>                        If (sColumnName = "") Begin
92958>>>                            Send Info_Box "You need to enter a column name"
92959>>>                            Procedure_Return
92960>>>                        End
92960>>>>
92960>>>
92960>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
92961>>>                        If (bOk = True) Begin
92963>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
92964>>>                        End
92964>>>>
92964>>>                        Else Begin
92965>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
92966>>>                            Procedure_Return
92967>>>                        End
92967>>>>
92967>>>
92967>>>                    End_Procedure
92968>>>
92968>>>                End_Object
92969>>>
92969>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
92971>>>                    Set Size to 26 77
92972>>>                    Set Location to 184 14
92973>>>                    Set Label to "Create 'New' Table with Three Columns"
92974>>>                    Set MultiLineState to True
92975>>>                    Set psImage to "ActionAddTable1.ico"
92976>>>
92976>>>                    Procedure OnClick
92979>>>                        Boolean bOk
92979>>>                        Handle hTable
92979>>>                        String sTableName sDriverID
92979>>>
92979>>>                        Get Value of oDriverID3_cf to sDriverID
92980>>>                        Get Value of oApiTableName_fm to sTableName
92981>>>                        Move (Trim(sTableName)) to sTableName
92982>>>                        If (sTableName = "") Begin
92984>>>                            Send Info_Box "You first need to enter a table name."
92985>>>                            Procedure_Return
92986>>>                        End
92986>>>>
92986>>>
92986>>>                        Send Cursor_Wait of Cursor_Control
92987>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
92988>>>
92988>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
92989>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
92990>>>                        If (bOk = True) Begin
92992>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
92993>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
92994>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
92995>>>                        End
92995>>>>
92995>>>                        Send Cursor_Ready of Cursor_Control
92996>>>
92996>>>                        If (bOk = True) Begin
92998>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
92999>>>                        End
92999>>>>
92999>>>                        Else Begin
93000>>>                            Send Cursor_Ready of Cursor_Control
93001>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
93002>>>                            Procedure_Return
93003>>>                        End
93003>>>>
93003>>>
93003>>>                    End_Procedure
93004>>>
93004>>>                End_Object
93005>>>
93005>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
93007>>>                    Set Size to 26 77
93008>>>                    Set Location to 184 96
93009>>>                    Set Label to "Remove 'New' Table"
93010>>>                    Set psImage to "ActionDeleteTable1.ico"
93011>>>                    Set MultiLineState to True
93012>>>
93012>>>                    Procedure OnClick
93015>>>                        Boolean bOk
93015>>>                        Integer iRetval
93015>>>                        Handle hTable
93015>>>                        String sTableName sDriverID
93015>>>
93015>>>                        Get Value of oDriverID3_cf to sDriverID
93016>>>                        Get Value of oApiTableName_fm to sTableName
93017>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
93018>>>                        If (iRetval = MBR_Yes) Begin
93020>>>                            Send Cursor_Wait of Cursor_Control
93021>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
93022>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
93023>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
93024>>>                            Send Cursor_Ready of Cursor_Control
93025>>>                            If (bOk = True) Begin
93027>>>                                Send Info_Box "Table removed"
93028>>>                            End
93028>>>>
93028>>>                            Else Begin
93029>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
93030>>>                            End
93030>>>>
93030>>>                        End
93030>>>>
93030>>>                    End_Procedure
93031>>>
93031>>>                End_Object
93032>>>
93032>>>                Object oLineControl1 is a LineControl
93034>>>                    Set Size to 2 387
93035>>>                    Set Location to 96 6
93036>>>                    Set peAnchors to anTopLeftRight
93037>>>                End_Object
93038>>>
93038>>>                Object oLineControl2 is a LineControl
93040>>>                    Set Size to 3 248
93041>>>                    Set Location to 171 9
93042>>>                End_Object
93043>>>
93043>>>                Object oTestError_fm is a Form
93045>>>                    Set Size to 13 64
93046>>>                    Set Location to 186 180
93047>>>                    Set Form_Datatype to 0 
93048>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
93049>>>                End_Object
93050>>>
93050>>>Register_Function FetchErrorDescription Integer iError Returns String
93050>>>                Object oFindErrorText_Btn is a Button
93052>>>                    Set Size to 13 70
93053>>>                    Set Location to 186 248
93054>>>                    Set Label to "Find Error Text"
93055>>>                
93055>>>                    Procedure OnClick
93058>>>                        String sRetval
93058>>>                        Integer iError 
93058>>>                        Handle hoLogFile
93058>>>                        
93058>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
93059>>>                        Get Value of oTestError_fm to iError
93060>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
93061>>>                        Set Value of oErrorText_fm to sRetval    
93062>>>                    End_Procedure
93063>>>                
93063>>>                End_Object
93064>>>
93064>>>                Object oErrorText_fm is a Form
93066>>>                    Set Size to 13 213
93067>>>                    Set Location to 202 180
93068>>>                End_Object
93069>>>
93069>>>            End_Object
93070>>>
93070>>>        End_Object
93071>>>
93071>>>    End_Object
93072>>>
93072>>>End_Object
93073>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
93073>>>
93073>>>Use Windows.pkg
93073>>>Use DFClient.pkg
93073>>>Use Dfline.pkg
93073>>>Use cDbScrollingContainer.pkg
93073>>>Use cRDCButtonDPI.pkg
93073>>>Use cDbUpdateFunctionLibrary.pkg
93073>>>Use Dftreevw.pkg
93073>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
93073>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
93073>>>>>//
93073>>>>>// This program is free software; you can redistribute it and/or
93073>>>>>// modify it under the terms of the GNU General Public License
93073>>>>>// as published by the Free Software Foundation; version 2
93073>>>>>// of the License.
93073>>>>>
93073>>>>>// This program is distributed in the hope that it will be useful,
93073>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
93073>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
93073>>>>>// GNU General Public License for more details.
93073>>>>>
93073>>>>>// You should have received a copy of the GNU General Public License
93073>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
93073>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
93073>>>>>Use Windows.pkg
93073>>>>>
93073>>>>>Object oWorkingMessagePanel is a ToolPanel
93075>>>>>    Set Label    to "Working"
93076>>>>>    Set Size to 48 150
93077>>>>>    Set Locate_Mode to CENTER_ON_PARENT
93078>>>>>    Set Popup_State to True
93079>>>>>
93079>>>>>    Object oWorkingMessage is a Textbox
93081>>>>>        Set Label to "Working message..."
93082>>>>>        Set Location to 15 5
93083>>>>>        Set Size to 27 123
93084>>>>>        Set Auto_Size_State to False
93085>>>>>        Set Justification_Mode to JMode_Center
93086>>>>>        Set FontWeight to fw_Bold
93087>>>>>    End_Object
93088>>>>>
93088>>>>>End_Object
93089>>>>>
93089>>>>>Procedure StartWorkingMessage Global String sText
93091>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
93092>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
93093>>>>>    Send Popup of (oWorkingMessagePanel(Self))
93094>>>>>End_Procedure
93095>>>>>
93095>>>>>Procedure StopWorkingMessage Global
93097>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
93098>>>>>End_Procedure
93099>>>Use DUFStatusPanel.pkg
93099>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCharTranslate.pkg)
93099>>>>>Use Variant.pkg
93099>>>>>Use CharTranslate.pkg
93099>>>>>
93099>>>>>// special for UTF16, which is really not a code page at all
93099>>>>>Define CP_UTF16 for -1
93099>>>>>
93099>>>>>Class cCharTranslate is a cObject
93100>>>>>    
93100>>>>>    
93100>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
93100>>>>>    
93100>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
93100>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
93100>>>>>    Function Utf16FromBuffer  Address pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Address
93102>>>>>        Address pWideBuf
93102>>>>>        Integer iWideBufLen iStrLen
93102>>>>>        Move 0 to pWideBuf
93103>>>>>        Move 0 to iLen
93104>>>>>        If (pMultiCharBuffer) Begin
93106>>>>>            Move (CStringLength(pMultiCharBuffer)) to iStrLen
93107>>>>>            If (iStrLen) Begin
93109>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
93110>>>>>                If (iLen=0) Begin
93112>>>>>                    Function_Return 0
93113>>>>>                End
93113>>>>>>
93113>>>>>            End
93113>>>>>>
93113>>>>>        End
93113>>>>>>
93113>>>>>        Function_Return pWideBuf
93114>>>>>    End_Function
93115>>>>>    
93115>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Address
93117>>>>>        Address aValue
93117>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to aValue
93118>>>>>        Function_Return aValue
93119>>>>>    End_Function
93120>>>>>    
93120>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
93120>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
93120>>>>>    Function Utf16ToBuffer Address pWideBuf Integer eCharType Integer iLen Returns Address
93122>>>>>        Address pRetBuf
93122>>>>>        Integer iRetBufLen
93122>>>>>        Move 0 to pRetBuf
93123>>>>>        If (pWideBuf and iLen) Begin
93125>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
93126>>>>>            If (iRetBufLen=0) Begin
93128>>>>>                Function_Return 0
93129>>>>>            End
93129>>>>>>
93129>>>>>        End
93129>>>>>>
93129>>>>>        Function_Return pRetBuf
93130>>>>>    End_Function
93131>>>>>    
93131>>>>>    Function Utf16ToStr Address pWideBuf Integer eCharType Integer iLen Returns String
93133>>>>>        String sValue
93133>>>>>        Address aValue
93133>>>>>        Boolean bOk
93133>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to aValue
93134>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
93136>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
93137>>>>>>
93137>>>>>        End
93137>>>>>>
93137>>>>>        Move aValue to sValue
93138>>>>>        Move (Free(aValue)) to bOk
93139>>>>>        Function_Return sValue
93140>>>>>    End_Function
93141>>>>>    
93141>>>>>    
93141>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
93141>>>>>    
93141>>>>>    Function Utf8FromBuffer Address pMultiCharBuffer Integer eCharType Returns Address
93143>>>>>        Address pWideBuf
93143>>>>>        Address pUtf8Buf
93143>>>>>        Integer iLen iMultiBufLen
93143>>>>>        Boolean bOk
93143>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
93144>>>>>        If (iLen=0) Begin
93146>>>>>            Function_Return 0
93147>>>>>        End
93147>>>>>>
93147>>>>>        Move 0 to pUtf8Buf
93148>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
93149>>>>>        Move (Free(pWideBuf)) to bOk
93150>>>>>        Function_Return pUtf8Buf
93151>>>>>    End_Function
93152>>>>>    
93152>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Address
93154>>>>>        Address aValue
93154>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to aValue
93155>>>>>        Function_Return aValue
93156>>>>>    End_Function
93157>>>>>    
93157>>>>>    Function Utf8ToBuffer Address pMultiCharBuffer Integer eCharType Returns Address
93159>>>>>        Address pRetBuf pWideBuf
93159>>>>>        Integer iWideBufLen
93159>>>>>        Integer iRetBufLen
93159>>>>>        Boolean bOk
93159>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
93160>>>>>        If (iWideBufLen=0) Begin
93162>>>>>            Function_Return 0
93163>>>>>        End
93163>>>>>>
93163>>>>>        Move 0 to pRetBuf
93164>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
93165>>>>>        Move (Free(pWideBuf)) to bOk
93166>>>>>        Function_Return pRetBuf
93167>>>>>    End_Function
93168>>>>>    
93168>>>>>    Function Utf8ToStr Address pWideBuf Integer eCharType Returns String
93170>>>>>        String sValue
93170>>>>>        Address aValue
93170>>>>>        Boolean bOk
93170>>>>>        Get Utf8ToBuffer pWideBuf eCharType to aValue
93171>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
93173>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
93174>>>>>>
93174>>>>>        End
93174>>>>>>
93174>>>>>        Move aValue to sValue
93175>>>>>        Move (Free(aValue)) to bOk
93176>>>>>        Function_Return sValue
93177>>>>>    End_Function
93178>>>>>    
93178>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
93178>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
93178>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
93178>>>>>    
93178>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
93178>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Address
93180>>>>>        Address aBSTR pRetStr
93180>>>>>        Integer iLen iBufLen
93180>>>>>        Boolean bOk
93180>>>>>        Move 0 to pRetStr
93181>>>>>        Move (VariantStringLength( vValue)) to iLen
93182>>>>>        If (iLen) Begin
93184>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to aBSTR
93185>>>>>            Move (WideToMultiBuffer(eCharType,aBSTR,iLen,AddressOf(pRetStr))) to iBufLen
93186>>>>>        End
93186>>>>>>
93186>>>>>        Function_Return pRetStr
93187>>>>>    End_Function
93188>>>>>    
93188>>>>>    // Create string from variant string. data buffer is encoded by eCharType
93188>>>>>    
93188>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
93190>>>>>        String sValue
93190>>>>>        Address aValue
93190>>>>>        Boolean bOk
93190>>>>>        Get VariantStrToBuffer vValue eCharType to aValue
93191>>>>>        If (not(ValidStringBufferLength(aValue))) Begin
93193>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
93194>>>>>>
93194>>>>>        End
93194>>>>>>
93194>>>>>        Move aValue to sValue
93195>>>>>        Move (Free(aValue)) to bOk
93196>>>>>        Function_Return sValue
93197>>>>>    End_Function
93198>>>>>    
93198>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
93198>>>>>    
93198>>>>>    Function VariantStrFromBuffer Address aSource Integer eCodeType Returns Variant
93200>>>>>        Variant vValue
93200>>>>>        Address pvValue
93200>>>>>        Boolean bOk
93200>>>>>        Address pWStr
93200>>>>>        Move "" to vValue
93201>>>>>        If (aSource) Begin
93203>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
93203>>>>>            Move 0 to pWStr
93204>>>>>            //Convert the Ansi string to Unicode
93204>>>>>            Move (MultiToWideBuffer( eCodeType, aSource, CStringLength(aSource), AddressOf(pWStr))) to bOk
93205>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
93205>>>>>            Move 0 to vValue
93206>>>>>            Move (AddressOf(vValue)) to pvValue
93207>>>>>            //Change the Variant type to VT_BSTR
93207>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
93208>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
93208>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
93209>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
93209>>>>>            Move (Free(pWStr)) to bOk
93210>>>>>        End
93210>>>>>>
93210>>>>>        Function_Return vValue
93211>>>>>    End_Function
93212>>>>>    
93212>>>>>    // Create variant string from data string. data string is encoded by eCharType
93212>>>>>    
93212>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
93214>>>>>        Variant vValue
93214>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
93215>>>>>        Function_Return vValue
93216>>>>>    End_Function
93217>>>>>    
93217>>>>>    // Create buffer of utf16 data from variant.
93217>>>>>    // Returns newly created memory address and length (by reference)
93217>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Address
93219>>>>>        Address aBSTR pRetStr
93219>>>>>        Boolean bOk
93219>>>>>        Move 0 to pRetStr
93220>>>>>        Move (VariantStringLength( vValue)) to iLen
93221>>>>>        If (iLen) Begin
93223>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to aBSTR
93224>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
93225>>>>>            Move (CopyMemory(pRetStr,aBSTR,(iLen+1 * 2))) to bOk
93226>>>>>        End
93226>>>>>>
93226>>>>>        Function_Return pRetStr
93227>>>>>    End_Function
93228>>>>>    
93228>>>>>    // Create variant from buffer of utf16 data
93228>>>>>    Function VariantStrFromUTF16 Address aSource Returns Variant
93230>>>>>        Variant vValue
93230>>>>>        Address pvValue
93230>>>>>        Boolean bOk
93230>>>>>        Move "" to vValue
93231>>>>>        If (aSource) Begin
93233>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
93233>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
93233>>>>>            Move 0 to vValue
93234>>>>>            Move (AddressOf(vValue)) to pvValue
93235>>>>>            //Change the Variant type to VT_BSTR
93235>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
93236>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
93236>>>>>            Move (StorePtr(pvValue,8,SysAllocString(aSource))) to bOk
93237>>>>>        End
93237>>>>>>
93237>>>>>        Function_Return vValue
93238>>>>>    End_Function
93239>>>>>    
93239>>>>>    // Create Uchar array from variant string.
93239>>>>>    // Data buffer is encoded by eCharType
93239>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
93241>>>>>        Address aBSTR pRetStr
93241>>>>>        Integer iLen iBufLen
93241>>>>>        Boolean bOk
93241>>>>>        UChar[] UC1
93242>>>>>        Move 0 to pRetStr
93243>>>>>        Move (VariantStringLength( vValue)) to iLen
93244>>>>>        If (iLen) Begin
93246>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to aBSTR
93247>>>>>            If (eCharType=CP_UTF16) Begin
93249>>>>>                Move (iLen*2) to iBufLen
93250>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
93251>>>>>                Move (MemCopy(AddressOf(UC1),aBSTR,iBufLen)) to bOk
93252>>>>>            End
93252>>>>>>
93252>>>>>            Else Begin
93253>>>>>                Move (WideToMultiBuffer(eCharType,aBSTR,iLen,AddressOf(pRetStr))) to iBufLen
93254>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
93255>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
93256>>>>>                Move (Free(pRetStr)) to bOk
93257>>>>>            End
93257>>>>>>
93257>>>>>        End
93257>>>>>>
93257>>>>>        Function_Return UC1
93258>>>>>    End_Function
93259>>>>>    
93259>>>>>    // Create variant string from UChar array. data is encoded by eCharType
93259>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
93261>>>>>        Variant vValue
93261>>>>>        Address pvValue
93261>>>>>        Boolean bOk
93261>>>>>        Address pWStr
93261>>>>>        Move "" to vValue
93262>>>>>        
93262>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
93262>>>>>        Move 0 to pWStr
93263>>>>>        //Convert the Ansi string to Unicode
93263>>>>>        If (eCodeType=CP_UTF16) Begin
93265>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
93266>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
93267>>>>>            Move (AddressOf(ucSource)) to pWStr
93268>>>>>        End
93268>>>>>>
93268>>>>>        Else Begin
93269>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
93270>>>>>        End
93270>>>>>>
93270>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
93270>>>>>        Move 0 to vValue
93271>>>>>        Move (AddressOf(vValue)) to pvValue
93272>>>>>        //Change the Variant type to VT_BSTR
93272>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
93273>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
93273>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
93274>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
93274>>>>>        If (eCodeType<>CP_UTF16) Begin
93276>>>>>            Move (Free(pWStr)) to bOk
93277>>>>>        End
93277>>>>>>
93277>>>>>        Function_Return vValue
93278>>>>>    End_Function
93279>>>>>    
93279>>>>>    
93279>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
93279>>>>>    // a new UChar array with to-encoding
93279>>>>>    
93279>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
93281>>>>>        Address aFromBuf aToBuf
93281>>>>>        Integer iBytes iChars
93281>>>>>        Boolean bOk
93281>>>>>        
93281>>>>>        Move (SizeOfArray(UCharData)) to iBytes
93282>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
93284>>>>>            Function_Return UCharData
93285>>>>>        End
93285>>>>>>
93285>>>>>        
93285>>>>>        If (iFromCP<>CP_UTF16) Begin
93287>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
93288>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to aFromBuf
93289>>>>>        End
93289>>>>>>
93289>>>>>        Else Begin
93290>>>>>            Move (iBytes/2) to iChars // if from is utf16
93291>>>>>        End
93291>>>>>>
93291>>>>>        
93291>>>>>        If (iToCP<>CP_UTF16) Begin
93293>>>>>            If (iFromCP=CP_UTF16) Begin
93295>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to aToBuf
93296>>>>>            End
93296>>>>>>
93296>>>>>            Else Begin
93297>>>>>                Get Utf16ToBuffer aFromBuf iToCP iChars to aToBuf
93298>>>>>                Move (Free(aFromBuf)) to bOk
93299>>>>>            End
93299>>>>>>
93299>>>>>            Move (CStringLength(aToBuf)) to iBytes
93300>>>>>        End
93300>>>>>>
93300>>>>>        Else Begin
93301>>>>>            Move (iChars*2) to iBytes
93302>>>>>            Move aFromBuf to aToBuf
93303>>>>>        End
93303>>>>>>
93303>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
93304>>>>>        Move (MemCopy(AddressOf(UCharData),aToBuf,iBytes)) to bOk
93305>>>>>        Move (Free(aToBuf)) to bOk
93306>>>>>        Function_Return UCharData
93307>>>>>    End_Function
93308>>>>>    
93308>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
93308>>>>>    // Variant strings. Binary data is always buffer
93308>>>>>    
93308>>>>>    Function Base64EncodeToStr Address pBinaryData Integer iBinaryLen Returns String
93310>>>>>        Address pBase64
93310>>>>>        String sResult
93310>>>>>        Integer iVoid iMax
93310>>>>>        Get_Argument_Size to iMax
93311>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
93312>>>>>        If (iMax<CStringLength(pBase64)) Begin
93314>>>>>            Error DFERR_PROGRAM "Base64 encoded string exceeds max string size"
93315>>>>>>
93315>>>>>        End
93315>>>>>>
93315>>>>>        Move pBase64 to sResult
93316>>>>>        Move (Free(pBase64)) to iVoid
93317>>>>>        Function_Return sResult
93318>>>>>    End_Function
93319>>>>>    
93319>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Address
93321>>>>>        Address pBinaryData
93321>>>>>        String sBinary
93321>>>>>        Integer iVoid
93321>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
93322>>>>>        Function_Return pBinaryData
93323>>>>>    End_Function
93324>>>>>    
93324>>>>>    Function Base64EncodeToVariantStr Address pBinaryData Integer iBinaryLen Returns Variant
93326>>>>>        Address aBase64
93326>>>>>        Variant vVar
93326>>>>>        Integer iBase64Len iVoid
93326>>>>>        If (pBinaryData and iBinaryLen) Begin
93328>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to aBase64
93329>>>>>            Get  VariantStrFromBuffer aBase64 CP_ACP to vVar
93330>>>>>            Move (Free(aBase64)) to iVoid
93331>>>>>        End
93331>>>>>>
93331>>>>>        Function_Return vVar
93332>>>>>    End_Function
93333>>>>>    
93333>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Address
93335>>>>>        Address aBase64 pBinaryData
93335>>>>>        Integer iVoid
93335>>>>>        Move 0 to iBinaryLen
93336>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to aBase64
93337>>>>>        If (aBase64) Begin
93339>>>>>            Move (Base64Decode(aBase64,&iBinaryLen)) to pBinaryData
93340>>>>>            Move (Free(aBase64)) to iVoid
93341>>>>>        End
93341>>>>>>
93341>>>>>        Function_Return pBinaryData
93342>>>>>    End_Function
93343>>>>>    
93343>>>>>    // base 64 Encode from Uchar array to a Uchar array
93343>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
93345>>>>>        Address aBase64
93345>>>>>        Integer iLen
93345>>>>>        Boolean bOk
93345>>>>>        
93345>>>>>        Move (SizeOfArray(UCharData)) to iLen
93346>>>>>        If (iLen) Begin
93348>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to aBase64
93349>>>>>            Move (CStringLength(aBase64)) to iLen
93350>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
93351>>>>>            Move (MemCopy(AddressOf(UCharData),aBase64,iLen)) to bOk
93352>>>>>            Move (Free(aBase64)) to bOk
93353>>>>>        End
93353>>>>>>
93353>>>>>        Function_Return UCharData
93354>>>>>    End_Function
93355>>>>>    
93355>>>>>    // base 64 Decode from Uchar array to a Uchar array
93355>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
93357>>>>>        Address aData
93357>>>>>        Integer iLen
93357>>>>>        Boolean bOk
93357>>>>>        
93357>>>>>        Move (SizeOfArray(UCharData)) to iLen
93358>>>>>        If (iLen) Begin
93360>>>>>            Move 0 to UCharData[iLen]
93361>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to aData
93362>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
93363>>>>>            Move (MemCopy(AddressOf(UCharData),aData,iLen)) to bOk
93364>>>>>            Move (Free(aData)) to bOk
93365>>>>>        End
93365>>>>>>
93365>>>>>        Function_Return UCharData
93366>>>>>    End_Function
93367>>>>>    
93367>>>>>End_Class
93368>>>>>
93368>>>>>
93368>>>
93368>>>Struct tFilelistDUF
93368>>>    Integer iFileNumber
93368>>>    String sLogicalName
93368>>>    String sRootName
93368>>>    String sDisplayName
93368>>>End_Struct
93368>>>
93368>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
93378>>>>
93378>>>Object oUtilFunctions_vw is a dbView
93380>>>    Set Border_Style to Border_Thick
93381>>>    Set Size to 291 428
93382>>>    Set Location to 2 1
93383>>>    Set Label to "Utility Functions"
93384>>>    Set pbAutoActivate to True
93385>>>    Set Icon to "TestTools1.ico"
93386>>>    Set pbAcceptDropFiles to True
93387>>>
93387>>>    Object oScrollingContainer1 is a cDbScrollingContainer
93389>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
93391>>>
93391>>>            Object oSQL_grp is a Group
93393>>>                Set Size to 88 402
93394>>>                Set Location to 7 12
93395>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
93396>>>                Set peAnchors to anTopLeftRight
93397>>>
93397>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
93399>>>                    Set Size to 14 219
93400>>>                    Set Location to 13 13
93401>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
93402>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
93403>>>                    Set psImage to "ActionCreateDatabase1.ico"
93404>>>
93404>>>                    Procedure OnClick
93407>>>                        String sInfoText sDriverID
93407>>>                        Boolean bOK
93407>>>                        TimeSpan tsTotalQueryTime
93407>>>                        Integer iRetval
93407>>>
93407>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
93407>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
93407>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
93407>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
93408>>>                        If (iRetval <> MBR_Yes) Begin
93410>>>                            Procedure_Return
93411>>>                        End
93411>>>>
93411>>>
93411>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
93412>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
93414>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
93415>>>                            Procedure_Return
93416>>>                        End
93416>>>>
93416>>>
93416>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
93417>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
93418>>>                        Send StopWorkingMessage
93419>>>
93419>>>                        If (bOK = True) Begin
93421>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
93422>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
93423>>>                        End
93423>>>>
93423>>>
93423>>>                        Else Begin
93424>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
93425>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
93426>>>                        End
93426>>>>
93426>>>
93426>>>                        Send Info_Box sInfoText
93427>>>                    End_Procedure
93428>>>
93428>>>                End_Object
93429>>>
93429>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
93431>>>                    Set Size to 14 219
93432>>>                    Set Location to 33 13
93433>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
93434>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
93435>>>                    Set psImage to "ActionCreateDatabase1.ico"
93436>>>
93436>>>                    Procedure OnClick
93439>>>                        String sInfoText sDriverID
93439>>>                        Boolean bOK
93439>>>                        TimeSpan tsTotalQueryTime
93439>>>                        Integer iRetval
93439>>>
93439>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
93439>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
93439>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
93439>>>
93439>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
93440>>>                        If (iRetval <> MBR_Yes) Begin
93442>>>                            Procedure_Return
93443>>>                        End
93443>>>>
93443>>>
93443>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
93444>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
93446>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
93447>>>                            Procedure_Return
93448>>>                        End
93448>>>>
93448>>>
93448>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
93449>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
93450>>>                        Send StopWorkingMessage
93451>>>
93451>>>                        If (bOK = True) Begin
93453>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
93454>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
93455>>>                        End
93455>>>>
93455>>>
93455>>>                        Else Begin
93456>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
93457>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
93458>>>                        End
93458>>>>
93458>>>
93458>>>                        Send Info_Box sInfoText
93459>>>                    End_Procedure
93460>>>
93460>>>                End_Object
93461>>>
93461>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
93463>>>                    Set Size to 14 219
93464>>>                    Set Location to 53 13
93465>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
93466>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
93467>>>                    Set psImage to "ActionCreateDatabase1.ico"
93468>>>
93468>>>                    Procedure OnClick
93471>>>                        String sInfoText sDriverID
93471>>>                        Boolean bOK
93471>>>                        TimeSpan tsTotalQueryTime
93471>>>                        Integer iRetval
93471>>>
93471>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
93471>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
93471>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
93471>>>
93471>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
93472>>>                        If (iRetval <> MBR_Yes) Begin
93474>>>                            Procedure_Return
93475>>>                        End
93475>>>>
93475>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
93476>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
93478>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
93479>>>                            Procedure_Return
93480>>>                        End
93480>>>>
93480>>>
93480>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
93481>>>
93481>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
93482>>>
93482>>>                        Send StopWorkingMessage
93483>>>                        If (bOK = True) Begin
93485>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
93486>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
93487>>>                        End
93487>>>>
93487>>>
93487>>>                        Else Begin
93488>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
93489>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
93490>>>                        End
93490>>>>
93490>>>
93490>>>                        Send Info_Box sInfoText
93491>>>                    End_Procedure
93492>>>
93492>>>                End_Object
93493>>>
93493>>>                Object oInfo_tb is a TextBox
93495>>>                    Set Auto_Size_State to False
93496>>>                    Set Size to 25 158
93497>>>                    Set Location to 53 238
93498>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
93499>>>                    Set Justification_Mode to JMode_Left
93500>>>                    Set peAnchors to anTopLeftRight
93501>>>                End_Object
93502>>>
93502>>>        //  This will choke the computer so don't try it!
93502>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
93502>>>        //            Set Size to 14 312
93502>>>        //            Set Location to 97 45
93502>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
93502>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
93502>>>        //
93502>>>        //            Procedure OnClick
93502>>>        //                String sInfoText
93502>>>        //                Boolean bOK
93502>>>        //                TimeSpan tsTotalQueryTime
93502>>>        //                Integer iRetval
93502>>>        //
93502>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
93502>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
93502>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
93502>>>        //Procedure_Return
93502>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
93502>>>        //                If (iRetval <> MBR_Yes) Begin
93502>>>        //                    Procedure_Return
93502>>>        //                End
93502>>>        //
93502>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
93502>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
93502>>>        //                Send StopWorkingMessage
93502>>>        //
93502>>>        //                If (bOK = True) Begin
93502>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
93502>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
93502>>>        //                End
93502>>>        //
93502>>>        //                Else Begin
93502>>>        //                    Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
93502>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
93502>>>        //                End
93502>>>        //
93502>>>        //                Send Info_Box sInfoText
93502>>>        //            End_Procedure
93502>>>        //
93502>>>        //        End_Object
93502>>>
93502>>>            End_Object
93503>>>
93503>>>            Object oChangeIntFiles_grp is a Group
93505>>>                Set Size to 65 402
93506>>>                Set Location to 102 12
93507>>>                Set Label to "Change Old .int files to use Connection ID's"
93508>>>                Set peAnchors to anTopLeftRight
93509>>>
93509>>>                Object oSelectDataPath_fm is a Form
93511>>>                    Set Size to 12 300
93512>>>                    Set Location to 22 13
93513>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
93514>>>                    Set Label_Col_Offset to 0
93515>>>                    Set Label_Row_Offset to 1
93516>>>                    Set Label_Justification_Mode to JMode_Top
93517>>>
93517>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
93517>>>        //            Set Prompt_Button_Mode to PB_PromptOn
93517>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
93518>>>                    Set peAnchors to anTopLeftRight
93519>>>
93519>>>                    Procedure Prompt
93522>>>                        String sPath sFileMask sRetval
93522>>>
93522>>>                        Get psDataPathFirstPart to sPath
93523>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
93524>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
93525>>>                        If (sRetval <> "") Begin
93527>>>                            Get ParseFolderName sRetval to sPath
93528>>>                            If (Right(sPath, 1) ="\") Begin
93530>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
93531>>>                            End
93531>>>>
93531>>>                            Set Value to sPath
93532>>>                        End
93532>>>>
93532>>>                    End_Procedure
93533>>>
93533>>>                    // Returns the first datapath found in the psDataPath property.
93533>>>                    // The returned path always ends with a "\"
93533>>>                    Function psDataPathFirstPart Returns String
93536>>>                        String sDataPath
93536>>>                        Integer iCount
93536>>>
93536>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93537>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
93538>>>                        If (iCount > 1) Begin
93540>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
93541>>>                        End
93541>>>>
93541>>>                        If (sDataPath <> "") Begin
93543>>>                            Get vFolderFormat sDataPath to sDataPath
93544>>>                        End
93544>>>>
93544>>>
93544>>>                        Function_Return sDataPath
93545>>>                    End_Function
93546>>>
93546>>>                End_Object
93547>>>
93547>>>                Object oSelectFolder_btn is a cRDCButtonDPI
93549>>>                    Set Size to 13 73
93550>>>                    Set Location to 22 320
93551>>>                    Set Label to "Select Folder"
93552>>>                    Set psToolTip to "Please select an .int file from the data folder"
93553>>>                    Set peAnchors to anTopRight
93554>>>                    Set psImage to "ActionOpen1.ico"
93555>>>
93555>>>                    Procedure OnClick
93558>>>                        Send Prompt to oSelectDataPath_fm
93559>>>                    End_Procedure
93560>>>
93560>>>                End_Object
93561>>>
93561>>>                Object oConnectionID_fm is a Form
93563>>>                    Set Size to 13 111
93564>>>                    Set Location to 38 202
93565>>>                    Set Label_Col_Offset to 2
93566>>>                    Set Label_Justification_Mode to JMode_Right
93567>>>                    Set Label to "Change to DFConnID:"
93568>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
93569>>>                    Set peAnchors to anTopRight
93570>>>                End_Object
93571>>>
93571>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
93573>>>                    Set Size to 13 68
93574>>>                    Set Location to 38 320
93575>>>                    Set Label to "GO !"
93576>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
93577>>>                    Set FontWeight to fw_Bold
93578>>>                    Set peAnchors to anTopRight
93579>>>
93579>>>                    Procedure OnClick
93582>>>                        String sDataPath sConnectionID
93582>>>                        Boolean bExists bActive
93582>>>                        Integer iRetval
93582>>>
93582>>>                        Get Value of oSelectDataPath_fm to sDataPath
93583>>>                        Get vFolderExists sDataPath to bExists
93584>>>                        If (bExists = False) Begin
93586>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
93587>>>                            Procedure_Return
93588>>>                        End
93588>>>>
93588>>>                        Get Value of oConnectionID_fm to sConnectionID
93589>>>                        Move (Trim(sConnectionID)) to sConnectionID
93590>>>                        If (sConnectionID = "") Begin
93592>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
93593>>>                            Procedure_Return
93594>>>                        End
93594>>>>
93594>>>
93594>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
93595>>>                        If (iRetval <> MBR_Yes) Begin
93597>>>                            Procedure_Return
93598>>>                        End
93598>>>>
93598>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
93599>>>                        If (iRetval <> MBR_Yes) Begin
93601>>>                            Procedure_Return
93602>>>                        End
93602>>>>
93602>>>
93602>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
93603>>>                        If (iRetval <> 0) Begin
93605>>>                            Send Info_Box "Could not delete .cch files!"
93606>>>                            Procedure_Return
93607>>>                        End
93607>>>>
93607>>>
93607>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
93608>>>                        Send Start_StatusPanel of ghoStatusPanel
93609>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
93610>>>
93610>>>                        Get Active_State of ghoStatusPanel to bActive
93611>>>                        If (bActive = False) Begin
93613>>>                            Send Info_Box "Process interupted..."
93614>>>                        End
93614>>>>
93614>>>                        Else Begin
93615>>>                            Send Stop_StatusPanel of ghoStatusPanel
93616>>>                            Send Info_Box "Ready! All .int files changed."
93617>>>                        End
93617>>>>
93617>>>                    End_Procedure
93618>>>
93618>>>                End_Object
93619>>>
93619>>>            End_Object
93620>>>
93620>>>            Object oRemoveFilelistDriverIDs_grp is a Group
93622>>>                Set Size to 59 402
93623>>>                Set Location to 171 12
93624>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
93625>>>                Set peAnchors to anTopLeftRight
93626>>>//                Set TextColor to clGreen
93626>>>//
93626>>>//                Procedure Page Integer iPage
93626>>>//                    Integer ia iz
93626>>>//                    Forward Send Page iPage
93626>>>//                    Move 0 to iz
93626>>>//                    Move (AddressOf(iz)) to ia
93626>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
93626>>>//                End_Procedure
93626>>>
93626>>>                Object oFilelistPath_fm is a Form
93628>>>                    Set Size to 13 299
93629>>>                    Set Location to 22 13
93630>>>                    Set Label to "Path and Filelist.cfg Name:"
93631>>>                    Set Label_Col_Offset to 0
93632>>>                    Set Label_Row_Offset to 1
93633>>>                    Set Label_Justification_Mode to JMode_Top
93634>>>
93634>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
93634>>>        //            Set Prompt_Button_Mode to PB_PromptOn
93634>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
93635>>>                    Set peAnchors to anTopLeftRight
93636>>>
93636>>>                    Procedure Prompt
93639>>>                        String sFileName sPath sFileMask sRetval
93639>>>
93639>>>                        Get Value to sFileName
93640>>>                        Get ParseFolderName sFileName to sPath
93641>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
93642>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
93643>>>                        If (sRetval <> "") Begin
93645>>>                            Set Value to sRetval
93646>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
93649>>>                        End
93649>>>>
93649>>>                    End_Procedure
93650>>>
93650>>>                    Procedure OnCreate
93653>>>                        String sFilelist
93653>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
93656>>>                        Set Value to sFilelist
93657>>>                    End_Procedure
93658>>>                    Send OnCreate
93659>>>
93659>>>                End_Object
93660>>>
93660>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
93662>>>                    Set Size to 13 73
93663>>>                    Set Location to 22 319
93664>>>                    Set Label to "Select Filelist.cfg"
93665>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
93666>>>                    Set peAnchors to anTopRight
93667>>>
93667>>>                    Procedure OnClick
93670>>>                        Send Prompt to oFilelistPath_fm
93671>>>                    End_Procedure
93672>>>
93672>>>                End_Object
93673>>>
93673>>>                Object oInfo_tb is a TextBox
93675>>>                    Set Size to 9 207
93676>>>                    Set Location to 40 138
93677>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
93678>>>                    Set peAnchors to anTopRight
93679>>>                End_Object
93680>>>
93680>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
93682>>>                    Set Size to 13 68
93683>>>                    Set Location to 38 319
93684>>>                    Set Label to "GO !"
93685>>>                    Set FontWeight to fw_Bold
93686>>>                    Set peAnchors to anTopRight
93687>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
93688>>>
93688>>>                    Procedure OnClick
93691>>>                        String sFileList
93691>>>                        Integer iRetval iCount
93691>>>                        Boolean bExits
93691>>>
93691>>>                        Get Value of oFilelistPath_fm to sFileList
93692>>>                        Get vFilePathExists sFileList to bExits
93693>>>                        If (bExits = False) Begin
93695>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
93696>>>                            Procedure_Return
93697>>>                        End
93697>>>>
93697>>>
93697>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
93698>>>                        If (iRetval <> MBR_Yes) Begin
93700>>>                            Procedure_Return
93701>>>                        End
93701>>>>
93701>>>                        Send Cursor_Wait of Cursor_Control
93702>>>
93702>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
93703>>>
93703>>>                        Send Cursor_Ready of Cursor_Control
93704>>>                        If (iCount <> 0) Begin
93706>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
93707>>>                        End
93707>>>>
93707>>>                        Else Begin
93708>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
93709>>>                        End
93709>>>>
93709>>>
93709>>>                    End_Procedure
93710>>>
93710>>>                End_Object
93711>>>
93711>>>            End_Object
93712>>>
93712>>>            Object oOutput_grp is a Group
93714>>>                Set Size to 47 402
93715>>>                Set Location to 234 12
93716>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
93717>>>                Set peAnchors to anTopLeftRight
93718>>>
93718>>>                Object oOutput_rg is a RadioGroup
93720>>>                    Set Location to 18 13
93721>>>                    Set Size to 25 288
93722>>>                    Set Label to "Filelist Output Order"
93723>>>
93723>>>                    Object oRadio1 is a Radio
93725>>>                        Set Label to "Filelist Number"
93726>>>                        Set Size to 10 61
93727>>>                        Set Location to 10 7
93728>>>                    End_Object
93729>>>
93729>>>                    Object oRadio2 is a Radio
93731>>>                        Set Label to "Logical Name"
93732>>>                        Set Size to 10 61
93733>>>                        Set Location to 10 77
93734>>>                    End_Object
93735>>>
93735>>>                    Object oRadio3 is a Radio
93737>>>                        Set Label to "Root Name"
93738>>>                        Set Size to 10 61
93739>>>                        Set Location to 10 147
93740>>>                    End_Object
93741>>>
93741>>>                    Object oRadio4 is a Radio
93743>>>                        Set Label to "Display Name"
93744>>>                        Set Size to 10 62
93745>>>                        Set Location to 10 213
93746>>>                    End_Object
93747>>>
93747>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
93750>>>                        Forward Send Notify_Select_State iToItem iFromItem
93752>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
93753>>>                    End_Procedure
93754>>>
93754>>>                End_Object
93755>>>                
93755>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
93757>>>                    Set Size to 13 78
93758>>>                    Set Location to 26 315
93759>>>                    Set Label to "Print to Filelist.txt"
93760>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
93761>>>                    Set psImage to "ActionDocument1.ico"
93762>>>
93762>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
93764>>>
93764>>>                    // Custom array sort function.
93764>>>                    // iSortOrder = 0 -> Filelist number order
93764>>>                    // iSortOrder = 1 -> Logical name order
93764>>>                    // iSortOrder = 2 -> Root name order
93764>>>                    // iSortOrder = 3 -> Display name order
93764>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
93767>>>                        Integer iSortOrder
93767>>>
93767>>>                        Get piSortOrder to iSortOrder
93768>>>
93768>>>                        Case Begin
93768>>>                            Case (iSortOrder = 0)
93770>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
93772>>>                                    Function_Return (GT)
93773>>>                                End
93773>>>>
93773>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
93775>>>                                    Function_Return (LT)
93776>>>                                End
93776>>>>
93776>>>                                Function_Return (EQ)
93777>>>                            Case (iSortOrder = 1)
93780>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
93782>>>                                    Function_Return (GT)
93783>>>                                End
93783>>>>
93783>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
93785>>>                                    Function_Return (LT)
93786>>>                                End
93786>>>>
93786>>>                                Function_Return (EQ)
93787>>>                            Case (iSortOrder = 2)
93790>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
93792>>>                                    Function_Return (GT)
93793>>>                                End
93793>>>>
93793>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
93795>>>                                    Function_Return (LT)
93796>>>                                End
93796>>>>
93796>>>                                Function_Return (EQ)
93797>>>                            Case (iSortOrder = 3)
93800>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
93802>>>                                    Function_Return (GT)
93803>>>                                End
93803>>>>
93803>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
93805>>>                                    Function_Return (LT)
93806>>>                                End
93806>>>>
93806>>>                                Function_Return (EQ)
93807>>>                        Case End
93807>>>
93807>>>                    End_Function
93808>>>
93808>>>                    Procedure OnClick
93811>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
93811>>>                        Integer iCh iCount iSize
93811>>>                        Handle hTable
93811>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
93811>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
93813>>>
93813>>>                        Get Value of oFilelistPath_fm to sFileList
93814>>>                        Move (Trim(sFileList)) to sFileList
93815>>>                        If (sFileList = "") Begin
93817>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
93818>>>                            Procedure_Return
93819>>>                        End
93819>>>>
93819>>>
93819>>>                        Get ParseFolderName sFileList to sPath
93820>>>                        Get vFolderFormat sPath to sPath
93821>>>                        Get ParseFileName sFileList to sOutputName
93822>>>                        Get ParseFileExtension sFileList to sExt
93823>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
93824>>>                        Move (sOutputName + "txt")           to sOutputName
93825>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
93826>>>                        If (iCh < 0) Begin
93828>>>                            Procedure_Return
93829>>>                        End
93829>>>>
93829>>>
93829>>>                        Move 0 to hTable
93830>>>                        Writeln channel iCh sFileList
93833>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
93836>>>                        Writeln channel iCh "==================================================================================================="
93839>>>                        Writeln channel iCh
93841>>>
93841>>>                        Move 0 to iCount
93842>>>                        Repeat
93842>>>>
93842>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93845>>>                            If (hTable > 0) Begin
93847>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
93848>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
93851>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
93854>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
93857>>>                                Increment iCount
93858>>>                            End
93858>>>>
93858>>>                        Until (hTable = 0)
93860>>>
93860>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
93861>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
93862>>>                        Decrement iSize
93863>>>
93863>>>                        For iCount from 0 to iSize
93869>>>>
93869>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
93870>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
93871>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
93872>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
93873>>>
93873>>>                            Get PadLeft (String(hTable))        09 to sTable
93874>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
93875>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
93876>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
93877>>>
93877>>>                            Writeln channel iCh sTable (ToANSI(sRootName)) (ToANSI(sLogicalName)) (ToANSI(sDisplayName))
93883>>>                        Loop
93884>>>>
93884>>>
93884>>>                        Writeln channel iCh "==================================================================================================="
93887>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
93891>>>                        Close_Output
93892>>>
93892>>>                        Send vShellExecute "open" sOutputName "" sPath
93893>>>                    End_Procedure
93894>>>
93894>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
93897>>>                        String sChar
93897>>>
93897>>>                        If (Num_Arguments >= 3) Begin
93899>>>                            Move sOptChar to sChar
93900>>>                        End
93900>>>>
93900>>>                        Else Begin
93901>>>                            Move " " to sChar
93902>>>                        End
93902>>>>
93902>>>
93902>>>                        While (Length(sString) < iLength)
93906>>>                            Move (sChar + sString) to sString
93907>>>                        Loop
93908>>>>
93908>>>
93908>>>                        Function_Return sString
93909>>>                    End_Function
93910>>>
93910>>>                End_Object
93911>>>            End_Object
93912>>>
93912>>>        End_Object
93913>>>
93913>>>    End_Object
93914>>>
93914>>>    Procedure OnFileDropped String sFilename Boolean bLast
93917>>>        String sTest
93917>>>        Forward Send OnFileDropped sFilename bLast
93919>>>        If (bLast = True) Begin
93921>>>            Get ParseFileName sFilename to sTest
93922>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
93924>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
93925>>>                Procedure_Return
93926>>>            End
93926>>>>
93926>>>            Set Value of oFilelistPath_fm to sFilename
93927>>>        End
93927>>>>
93927>>>    End_Procedure
93928>>>
93928>>>End_Object
93929>
93929>        Procedure Activate_About
93932>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
93933>        End_Procedure
93934>
93934>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
93935>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
93936>        On_Key Key_Ctrl+Key_W             Send Close_Panel
93937>    End_Object
93938>
93938>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
93938>    // in the oHtmlHelp object, so we need to explitetly send the message
93938>    // to that object.
93938>    Procedure ShowProgramHelp
93941>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
93942>    End_Procedure
93943>
93943>    On_Key Key_F1 Send ShowProgramHelp
93944>End_Object
93945>
93945>// We do this to activate the first view:
93945>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
93945>Start_UI
93946>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 50136
Total Resources: 9
Total Commands : 93945
Total Windows  : 0
Total Pages    : 0
Static Data    : 714153
Message area   : 609264
Total Blocks   : 73601
