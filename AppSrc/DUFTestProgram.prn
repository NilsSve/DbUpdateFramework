Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 23.0\Pkg\dfallent.pkd)
73414>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardCommandBarSystem.pkg)
73414>>>// these are all the packages used in a standard MDI menubar/toolbar system
73414>>>
73414>>>Use cCJCommandBarSystem.pkg
73414>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardMenuItemClasses.pkg)
73414>>>>>Use Dfpanel.pkg
73414>>>>>Use cCJCommandBarSystem.pkg
73414>>>>>Use LanguageText.pkg
73414>>>>>
73414>>>>>
73414>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73415>>>>>    
73415>>>>>    Procedure Construct_Object
73417>>>>>        Forward Send Construct_Object
73419>>>>>        Set psCaption   to C_$CaptionUndo
73420>>>>>        Set psToolTip to C_$ToolTipUndo
73421>>>>>        Set psDescription to C_$DescUndo
73422>>>>>        Set psImage to "ActionUndo.ico"
73423>>>>>        Set pbActiveUpdate to True
73424>>>>>        Set psCategory to C_$CategoryEdit
73425>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73426>>>>>    End_Procedure
73427>>>>>    
73427>>>>>    Procedure OnExecute Variant vCommandBarControl
73429>>>>>        Send Undo of (focus(Self))
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Function IsEnabled Returns Boolean
73433>>>>>        Boolean bEnabled
73433>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73434>>>>>        Function_Return bEnabled
73435>>>>>    End_Function
73436>>>>>    
73436>>>>>End_Class
73437>>>>>
73437>>>>>
73437>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73438>>>>>    
73438>>>>>    Procedure Construct_Object
73440>>>>>        Forward Send Construct_Object
73442>>>>>        Set psCaption   to C_$CaptionDelete
73443>>>>>        Set psToolTip to C_$ToolTipDelete
73444>>>>>        Set psDescription to C_$DescDelete
73445>>>>>        Set psImage to "actionDelete.ico"
73446>>>>>        Set psShortcut to C_$Key_Delete
73447>>>>>        Set pbActiveUpdate to True
73448>>>>>        Set psCategory to C_$CategoryEdit
73449>>>>>    End_Procedure
73450>>>>>    
73450>>>>>    
73450>>>>>    Procedure OnExecute Variant vCommandBarControl
73452>>>>>        Send Delete of (focus(Self))
73453>>>>>    End_Procedure
73454>>>>>    
73454>>>>>    Function IsEnabled Returns Boolean
73456>>>>>        Boolean bEnabled
73456>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73457>>>>>        Function_Return bEnabled
73458>>>>>    End_Function
73459>>>>>    
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>>>Class cCJCutMenuItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Set psCaption   to C_$CaptionCut
73466>>>>>        Set psToolTip to C_$TooltipCut
73467>>>>>        Set psDescription to C_$DescCut
73468>>>>>        Set psImage to "actionCut.ico"
73469>>>>>        Set psShortcut to C_$Key_Ctrl_X
73470>>>>>        Set pbActiveUpdate to True
73471>>>>>        Set psCategory to C_$CategoryEdit
73472>>>>>    End_Procedure
73473>>>>>    
73473>>>>>    
73473>>>>>    Procedure OnExecute Variant vCommandBarControl
73475>>>>>        Send Cut of (focus(Self))
73476>>>>>    End_Procedure
73477>>>>>    
73477>>>>>    Function IsEnabled Returns Boolean
73479>>>>>        Boolean bEnabled
73479>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73480>>>>>        Function_Return bEnabled
73481>>>>>    End_Function
73482>>>>>    
73482>>>>>End_Class
73483>>>>>
73483>>>>>
73483>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73484>>>>>    
73484>>>>>    Procedure Construct_Object
73486>>>>>        Forward Send Construct_Object
73488>>>>>        Set psCaption   to C_$CaptionCopy
73489>>>>>        Set psToolTip to C_$ToolTipCopy
73490>>>>>        Set psDescription to C_$DescCopy
73491>>>>>        Set psImage to "actionCopy.ico"
73492>>>>>        Set psShortcut to C_$Key_Ctrl_C
73493>>>>>        Set pbActiveUpdate to True
73494>>>>>        Set psCategory to C_$CategoryEdit
73495>>>>>    End_Procedure
73496>>>>>    
73496>>>>>    
73496>>>>>    Procedure OnExecute Variant vCommandBarControl
73498>>>>>        Send Copy of (focus(Self))
73499>>>>>    End_Procedure
73500>>>>>    
73500>>>>>    Function IsEnabled Returns Boolean
73502>>>>>        Boolean bEnabled
73502>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73503>>>>>        Function_Return bEnabled
73504>>>>>    End_Function
73505>>>>>    
73505>>>>>End_Class
73506>>>>>
73506>>>>>
73506>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73507>>>>>    
73507>>>>>    Procedure Construct_Object
73509>>>>>        Forward Send Construct_Object
73511>>>>>        Set psCaption   to C_$CaptionPaste
73512>>>>>        Set psToolTip to C_$ToolTipPaste
73513>>>>>        Set psDescription to C_$DescPaste
73514>>>>>        Set psImage to "actionPaste.ico"
73515>>>>>        Set pbActiveUpdate to True
73516>>>>>        Set psShortcut to C_$Key_Ctrl_V
73517>>>>>        Set psCategory to C_$CategoryEdit
73518>>>>>    End_Procedure
73519>>>>>    
73519>>>>>    
73519>>>>>    Procedure OnExecute Variant vCommandBarControl
73521>>>>>        Send Paste of (focus(Self))
73522>>>>>    End_Procedure
73523>>>>>    
73523>>>>>    Function IsEnabled Returns Boolean
73525>>>>>        Boolean bEnabled
73525>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73526>>>>>        Function_Return bEnabled
73527>>>>>    End_Function
73528>>>>>    
73528>>>>>End_Class
73529>>>>>
73529>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73530>>>>>    
73530>>>>>    Procedure Construct_Object
73532>>>>>        Forward Send Construct_Object
73534>>>>>        Set psCaption   to C_$CaptionSelectAll
73535>>>>>        Set psToolTip to C_$ToolTipSelectAll
73536>>>>>        Set psDescription to C_$DescSelectAll
73537>>>>>        Set pbActiveUpdate to True
73538>>>>>        Set psShortcut to C_$Key_Ctrl_A
73539>>>>>        Set psCategory to C_$CategoryEdit
73540>>>>>    End_Procedure
73541>>>>>    
73541>>>>>    
73541>>>>>    Procedure OnExecute Variant vCommandBarControl
73543>>>>>        Send Select_All of (focus(Self))
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    Function IsEnabled Returns Boolean
73547>>>>>        Boolean bEnabled
73547>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73548>>>>>        Function_Return bEnabled
73549>>>>>    End_Function
73550>>>>>    
73550>>>>>End_Class
73551>>>>>
73551>>>>>
73551>>>>>Class cCJExitMenuItem is a cCJMenuItem
73552>>>>>    
73552>>>>>    Procedure Construct_Object
73554>>>>>        Forward Send Construct_Object
73556>>>>>        Set psCaption to C_$CaptionExit
73557>>>>>        Set psToolTip to C_$ToolTipExit
73558>>>>>        Set psDescription to C_$ToolTipExit
73559>>>>>        Set psShortcut to C_$Key_Alt_F4
73560>>>>>        Set psCategory to C_$CategoryFile
73561>>>>>    End_Procedure
73562>>>>>    
73562>>>>>    Procedure OnExecute Variant vCommandBarControl
73564>>>>>        Send Exit_Application of Desktop
73565>>>>>    End_Procedure
73566>>>>>    
73566>>>>>End_Class
73567>>>>>
73567>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73568>>>>>    
73568>>>>>    Procedure Construct_Object
73570>>>>>        Forward Send Construct_Object
73572>>>>>        Set psCaption to C_$CaptionHelp
73573>>>>>        Set psDescription to C_$ToolTipHelp
73574>>>>>        Set psToolTip to C_$DescHelp
73575>>>>>        Set psImage to "ActionHelp.ico"
73576>>>>>        Set psShortcut to "F1"
73577>>>>>        Set psCategory to C_$CategoryHelp
73578>>>>>    End_Procedure
73579>>>>>    
73579>>>>>    Procedure OnExecute Variant vCommandBarControl
73581>>>>>        Send Help of (Focus(Self))
73582>>>>>    End_Procedure
73583>>>>>    
73583>>>>>End_Class
73584>>>>>
73584>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73585>>>>>    
73585>>>>>    Procedure Construct_Object
73587>>>>>        Forward Send Construct_Object
73589>>>>>        Set psCaption to C_$CaptionAddStatusbar
73590>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73591>>>>>        Set psDescription to  C_$DescAddStatusbar
73592>>>>>        Set psCategory to C_$CategoryWindow
73593>>>>>    End_Procedure
73594>>>>>    
73594>>>>>    Procedure OnExecute Variant vCommandBarControl
73596>>>>>        Handle hoCommandBars hoClientArea
73596>>>>>        Get CommandBarSystemObject to hoCommandBars
73597>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73598>>>>>        If hoClientArea Begin
73600>>>>>            // the clientarea's parent panel has message
73600>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73601>>>>>        End
73601>>>>>>
73601>>>>>    End_Procedure
73602>>>>>    
73602>>>>>    Function IsChecked Returns Boolean
73604>>>>>        Boolean bOn
73604>>>>>        Handle hoCommandBars hoClientArea
73604>>>>>        Get CommandBarSystemObject to hoCommandBars
73605>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73606>>>>>        If hoClientArea Begin
73608>>>>>            // the clientarea's parent panel has message
73608>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73609>>>>>        End
73609>>>>>>
73609>>>>>        Function_Return bOn
73610>>>>>    End_Function
73611>>>>>End_Class
73612>>>>>
73612>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73613>>>>>    
73613>>>>>    Procedure Construct_Object
73615>>>>>        Forward Send Construct_Object
73617>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73618>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73619>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73620>>>>>        Set psCategory to C_$CategoryWindow
73621>>>>>    End_Procedure
73622>>>>>    
73622>>>>>    Procedure OnExecute Variant vCommandBarControl
73624>>>>>        Handle hoCommandBars hoClientArea
73624>>>>>        Get CommandBarSystemObject to hoCommandBars
73625>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73626>>>>>        If hoClientArea Begin
73628>>>>>            // the clientarea's parent panel has message
73628>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73629>>>>>        End
73629>>>>>>
73629>>>>>    End_Procedure
73630>>>>>    
73630>>>>>    Function IsChecked Returns Boolean
73632>>>>>        Boolean bOn
73632>>>>>        Handle hoCommandBars hoClientArea
73632>>>>>        Get CommandBarSystemObject to hoCommandBars
73633>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73634>>>>>        If hoClientArea Begin
73636>>>>>            // the clientarea's parent panel has message
73636>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73637>>>>>        End
73637>>>>>>
73637>>>>>        Function_Return bOn
73638>>>>>    End_Function
73639>>>>>End_Class
73640>>>>>
73640>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73641>>>>>    
73641>>>>>    Procedure Construct_Object
73643>>>>>        Forward Send Construct_Object
73645>>>>>        Set psCaption to C_$CaptionRestoreMenus
73646>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73647>>>>>        Set psDescription to C_$DescRestoreMenus
73648>>>>>        Set psCategory to C_$CategoryWindow
73649>>>>>    End_Procedure
73650>>>>>    
73650>>>>>    Procedure OnExecute Variant vCommandBarControl
73652>>>>>        Handle hoCommandBars
73652>>>>>        Get CommandBarSystemObject to hoCommandBars
73653>>>>>        Send RestoreLayout of hoCommandBars
73654>>>>>    End_Procedure
73655>>>>>    
73655>>>>>End_Class
73656>>>>>
73656>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73657>>>>>    
73657>>>>>    Procedure Construct_Object
73659>>>>>        Forward Send Construct_Object
73661>>>>>        Set psCaption to C_$CaptionCascade
73662>>>>>        Set psToolTip to C_$ToolTipCascade
73663>>>>>        Set psDescription to  C_$DescCascade
73664>>>>>        Set psImage to "ActionCascade.ico"
73665>>>>>        Set psCategory to C_$CategoryWindow
73666>>>>>    End_Procedure
73667>>>>>    
73667>>>>>    Procedure OnExecute Variant vCommandBarControl
73669>>>>>        Handle hoCommandBars hoClientArea
73669>>>>>        Get CommandBarSystemObject to hoCommandBars
73670>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73671>>>>>        If hoClientArea Begin
73673>>>>>            Send Cascade_Windows of hoClientArea
73674>>>>>        End
73674>>>>>>
73674>>>>>    End_Procedure
73675>>>>>End_Class
73676>>>>>
73676>>>>>Class cCJTileHorizontally is a cCJMenuItem
73677>>>>>    
73677>>>>>    Procedure Construct_Object
73679>>>>>        Forward Send Construct_Object
73681>>>>>        Set psCaption to C_$CaptionTileHorizontally
73682>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73683>>>>>        Set psDescription to  C_$DescTileHorizontally
73684>>>>>        Set psImage to "ActionTileHorizontally.ico"
73685>>>>>        Set psCategory to C_$CategoryWindow
73686>>>>>    End_Procedure
73687>>>>>    
73687>>>>>    Procedure OnExecute Variant vCommandBarControl
73689>>>>>        Handle hoCommandBars hoClientArea
73689>>>>>        Get CommandBarSystemObject to hoCommandBars
73690>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73691>>>>>        If hoClientArea Begin
73693>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73694>>>>>        End
73694>>>>>>
73694>>>>>    End_Procedure
73695>>>>>End_Class
73696>>>>>
73696>>>>>Class cCJTileVertically is a cCJMenuItem
73697>>>>>    
73697>>>>>    Procedure Construct_Object
73699>>>>>        Forward Send Construct_Object
73701>>>>>        Set psCaption to C_$CaptionTileVertically
73702>>>>>        Set psToolTip to C_$ToolTipTileVertically
73703>>>>>        Set psDescription to  C_$DescTileVertically
73704>>>>>        Set psImage to "ActionTileVertically.ico"
73705>>>>>        Set psCategory to C_$CategoryWindow
73706>>>>>    End_Procedure
73707>>>>>    
73707>>>>>    Procedure OnExecute Variant vCommandBarControl
73709>>>>>        Handle hoCommandBars hoClientArea
73709>>>>>        Get CommandBarSystemObject to hoCommandBars
73710>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73711>>>>>        If hoClientArea Begin
73713>>>>>            Send Tile_Windows_Vertical of hoClientArea
73714>>>>>        End
73714>>>>>>
73714>>>>>    End_Procedure
73715>>>>>End_Class
73716>>>>>
73716>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73717>>>>>    
73717>>>>>    Procedure Construct_Object
73719>>>>>        Forward Send Construct_Object
73721>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73722>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73723>>>>>        Set psDescription to  C_$DescMinimizeWindows
73724>>>>>        Set psCategory to C_$CategoryWindow
73725>>>>>    End_Procedure
73726>>>>>    
73726>>>>>    Procedure OnExecute Variant vCommandBarControl
73728>>>>>        Handle hoCommandBars hoClientArea
73728>>>>>        Get CommandBarSystemObject to hoCommandBars
73729>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73730>>>>>        If hoClientArea Begin
73732>>>>>            // the clientarea's parent panel has message
73732>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73733>>>>>        End
73733>>>>>>
73733>>>>>    End_Procedure
73734>>>>>End_Class
73735>>>>>
73735>>>>>
73735>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73736>>>>>    
73736>>>>>    Procedure Construct_Object
73738>>>>>        Forward Send Construct_Object
73740>>>>>        Set psCaption to C_$CaptionRestoreWindows
73741>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73742>>>>>        Set psDescription to  C_$DescRestoreWindows
73743>>>>>        Set psCategory to C_$CategoryWindow
73744>>>>>    End_Procedure
73745>>>>>    
73745>>>>>    Procedure OnExecute Variant vCommandBarControl
73747>>>>>        Handle hoCommandBars hoClientArea
73747>>>>>        Get CommandBarSystemObject to hoCommandBars
73748>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73749>>>>>        If hoClientArea Begin
73751>>>>>            // the clientarea's parent panel has message
73751>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73752>>>>>        End
73752>>>>>>
73752>>>>>    End_Procedure
73753>>>>>End_Class
73754>>>>>
73754>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73755>>>>>    
73755>>>>>    Procedure Construct_Object
73757>>>>>        Forward Send Construct_Object
73759>>>>>        Set psCaption to C_$CaptionArrangeIcons
73760>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73761>>>>>        Set psDescription to  C_$DescArrangeIcons
73762>>>>>        Set psCategory to C_$CategoryWindow
73763>>>>>    End_Procedure
73764>>>>>    
73764>>>>>    Procedure OnExecute Variant vCommandBarControl
73766>>>>>        Handle hoCommandBars hoClientArea
73766>>>>>        Get CommandBarSystemObject to hoCommandBars
73767>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73768>>>>>        If hoClientArea Begin
73770>>>>>            Send Arrange_Icons of hoClientArea
73771>>>>>        End
73771>>>>>>
73771>>>>>    End_Procedure
73772>>>>>    
73772>>>>>End_Class
73773>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJAboutMenuItem.pkg)
73773>>>>>Use cCJCommandBarSystem.pkg
73773>>>>>Use LanguageText.pkg
73773>>>>>
73773>>>>>// It is expected that if you use this class that you provide an about object that is
73773>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73773>>>>>// because you may wish to create your own custom about package.
73773>>>>>
73773>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73774>>>>>
73774>>>>>    Procedure Construct_Object
73776>>>>>        Forward Send Construct_Object
73778>>>>>        Set psCaption to C_$CaptionAbout
73779>>>>>        Set psDescription to C_$ToolTipAbout
73780>>>>>        Set psToolTip to C_$DescAbout
73781>>>>>        Set psImage to "ActionAbout.ico"
73782>>>>>        Set psCategory to C_$CategoryHelp
73783>>>>>    End_Procedure
73784>>>>>    
73784>>>>>    Procedure OnExecute Variant vCommandBarControl
73786>>>>>        Handle hoCommandBars hoClientArea
73786>>>>>        Get CommandBarSystemObject to hoCommandBars
73787>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73788>>>>>        If hoClientArea Begin
73790>>>>>            Send Activate_About of hoClientArea
73791>>>>>        End
73791>>>>>>
73791>>>>>    End_Procedure
73792>>>>>
73792>>>>>End_Class
73793>>>>>
73793>>>>>
73793>>>Use cCJDeoMenuItemClasses.pkg
73793>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73793>>>>>Use cCJCommandBarSystem.pkg
73793>>>>>
73793>>>>>Register_Function Client_ID Returns Integer
73793>>>>>
73793>>>>>// only used by cCJMDIWIndowsMenuItem
73793>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73794>>>>>    
73794>>>>>    Procedure Construct_Object
73796>>>>>        Forward Send Construct_Object
73798>>>>>        Property Handle phWindow 0 // object id of view
73799>>>>>        Set pbControlFlagNoMovable to True
73800>>>>>        Set pbActiveUpdate to True
73801>>>>>    End_Procedure
73802>>>>>    
73802>>>>>    Procedure OnExecute Variant vCommandBarControl
73804>>>>>        Handle hWindow
73804>>>>>        Get phWindow to hWindow
73805>>>>>        Send Activate_View of hWindow
73806>>>>>    End_Procedure
73807>>>>>    
73807>>>>>End_Class
73808>>>>>
73808>>>>>
73808>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73809>>>>>    
73809>>>>>    Procedure Construct_Object
73811>>>>>        Forward Send Construct_Object
73813>>>>>        Property Handle[] phArrayOfWindows
73814>>>>>        Set peControlType to xtpControlPopup
73815>>>>>        Set psCategory to C_$CategoryWindow
73816>>>>>    End_Procedure
73817>>>>>    
73817>>>>>    // This adds MDI windows to the existing menu items.
73817>>>>>    // This removes any existing windows menus and always adds a new set to the end
73817>>>>>    
73817>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73819>>>>>        Handle  hClientArea hView
73819>>>>>        String  sLabel
73819>>>>>        Integer i iWindows
73819>>>>>        Handle[] hArrayOfWindows
73820>>>>>        Variant vItem
73820>>>>>        
73820>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73820>>>>>        // also assume that destroying an action removes all menu instances of that action
73820>>>>>        Get phArrayOfWindows to hArrayOfWindows
73821>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73822>>>>>        For i from 0 to (iWindows-1)
73828>>>>>>
73828>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73829>>>>>        Loop
73830>>>>>>
73830>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73831>>>>>        
73831>>>>>        // Add all views to this menu. Create the action and add the item
73831>>>>>        Move 0 to i
73832>>>>>        Get Client_Id to hClientArea // object id of client area
73833>>>>>        If (hClientArea > 0) Begin
73835>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73836>>>>>            While (hView <> 0)
73840>>>>>                If (Active_State(hView)) Begin
73842>>>>>                    // create the action
73842>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73843>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73844>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73845>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73846>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73848>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73849>>>>>                    End
73849>>>>>>
73849>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73850>>>>>                    If (i=0) Begin
73852>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73853>>>>>                    End
73853>>>>>>
73853>>>>>                    // Create a menu item for this action
73853>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73854>>>>>                    Increment i
73855>>>>>                End
73855>>>>>>
73855>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73856>>>>>            Loop
73857>>>>>>
73857>>>>>        End
73857>>>>>>
73857>>>>>        
73857>>>>>        Set phArrayOfWindows to hArrayOfWindows
73858>>>>>        
73858>>>>>    End_Procedure
73859>>>>>    
73859>>>>>End_Class
73860>Use cCJCommandBarSystem.pkg
73860>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73860>>>//****************************************************************************
73860>>>// $Module type: Class
73860>>>// $Module name: cDbUpdateHandler
73860>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73860>>>// Web-site    : http://www.rdctools.com
73860>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73860>>>//
73860>>>// Purpose     : A framework for doing automated code based updates of a database from within
73860>>>//               a program, when it is started.
73860>>>//
73860>>>// Description : Place _one_ object of this class right after the cApplication object.
73860>>>//               Then inside this object place a series of cDbUpdateVersion objects
73860>>>//               as childs. One child object for each new database update.
73860>>>//
73860>>>//               - OnPreUpdate is a pre-processing event called
73860>>>//               before any database changes are started.
73860>>>//               - OnPostUpdate is a post-processing event called after all
73860>>>//               database changes have taken place.
73860>>>//
73860>>>// Note        : If tables have been opened prior to an object of this class
73860>>>//               (e.g. in the cApplication object), those tables will be closed.
73860>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73860>>>//               tables after the last update has finished.
73860>>>//
73860>>>// Security    : Before an update is attempted; three things are checked to ensure the
73860>>>//               database is not in use. Aka nobody else is running the application.
73860>>>//               - All tables are tested for "Open in Exclusive_Mode"
73860>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73860>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73860>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73860>>>//                 folder and a bit-lock is performed for each start of the application and this
73860>>>//                 user counter is checked before an update is attempted.
73860>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73860>>>//                            against the database being "in use", there is no such guarantee! The
73860>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73860>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73860>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73860>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73860>>>//                 automatically be released after the update is completed.
73860>>>//
73860>>>//
73860>>>// Usage       :  Use cDbUpdateHandler.pkg
73860>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73860>>>//                    // Declare the table that contains a "database version" field.
73860>>>//                    Declare_Datafile Sys
73860>>>//                    // Either one of these syntaxes is fine:
73860>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73860>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73860>>>//
73860>>>//                    // Don't forget to increase the pnVersionNumber property for each
73860>>>//                    // cDbUpdateVersion object!
73860>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73860>>>//                    // with the value of pnVersionNumber after each update has been finished.
73860>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73860>>>//                        Set pnVersionNumber to 1.1
73860>>>//                        Use VersionUpdate1_1.pkg
73860>>>//                    End_Object
73860>>>//
73860>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73860>>>//                        Set pnVersionNumber to 1.2
73860>>>//                        Use VersionUpdate1_2.pkg
73860>>>//                    End_Object
73860>>>//
73860>>>//                End_Object
73860>>>//
73860>>>//
73860>>>// $Rev History:
73860>>>//    2016-09-27  Module header created
73860>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73860>>>//                take place before any tables have been opened, or errors
73860>>>//                could occur if the client database is out of sync with the
73860>>>//                compiled program.
73860>>>//                Added user counting checks + lockout while database is being
73860>>>//                updated.
73860>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73860>>>//                as it is more in line with the child class cDbUpdateVersion name.
73860>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73860>>>//****************************************************************************
73860>>>Use VdfBase.pkg
73860>>>Use Dferror.pkg
73860>>>Use seq_chnl.pkg
73860>>>Use Datadict.pkg
73860>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73860>>>>>// *** The Database Update Framework Include file for Languages ***
73860>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73860>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73860>>>>>//
73860>>>>>Use LanguageText.Pkg
73860>>>>>
73860>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73860>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73860>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73860>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73860>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73860>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73860>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73860>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73860>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73860>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73860>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73860>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73860>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73860>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73860>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73860>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73860>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73860>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73860>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73860>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73860>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73860>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73860>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73860>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73860>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73860>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73860>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73860>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73860>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73860>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73860>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73860>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73860>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73860>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73860>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73860>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73860>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>>>
73860>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73860>>>>>// StatPnl.pkg - creates the standard status_panel object.
73860>>>>>//
73860>>>>>//
73860>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73860>>>>>// invoke the standard status panel. The standard has always been that the package name
73860>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73860>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73860>>>>>// prior revisions has been replace with status panel that is part of the application.
73860>>>>>// This should work much better and faster than the old sentinel based solution.
73860>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73860>>>>>// with most applications.
73860>>>>>//
73860>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73860>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73860>>>>>// a cleaner more robust interface.
73860>>>>>//
73860>>>>>//
73860>>>>>// Compatibility Note:
73860>>>>>//
73860>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73860>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73860>>>>>//
73860>>>>>// If for some reason you application will not work using this as a replacement for the old status
73860>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73860>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73860>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73860>>>>>//
73860>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73860>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73860>>>>>//
73860>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73860>>>>>// can still access the new object via the ghoStatusPanel handle.
73860>>>>>//
73860>>>>>//
73860>>>>>// Creating your own Status Panel objects
73860>>>>>//
73860>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73860>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73860>>>>>// with a different file and object name and direct your status panel request to the new object.
73860>>>>>//
73860>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73860>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73860>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73860>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73860>>>>>// e.g.
73860>>>>>//       Procedure UpdateStatusBar
73860>>>>>//           Send DoAdvance of oProgressBar
73860>>>>>//           Send ProcessEvents
73860>>>>>//       End_Procedure
73860>>>>>//
73860>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73860>>>>>// messages this will be done for you.
73860>>>>>//
73860>>>>>// the standard Interface for status panels are:
73860>>>>>//
73860>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73860>>>>>// Send Start_StatusPanel      - start the status panel
73860>>>>>// Send Stop_StatusPanel       - stop the status panel
73860>>>>>// Send Update_StatusPanel     - update the status panel's action area
73860>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73860>>>>>//
73860>>>>>// Get/Set Caption_Text - updates the caption bar
73860>>>>>// Get/Set Title_Text   - updates the title area
73860>>>>>// Get/Set Message_Text - updates the Message area
73860>>>>>// Get/Set Action_Text  - updates the action area
73860>>>>>// Get/Set Button_Text  - updates the button area
73860>>>>>//
73860>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73860>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73860>>>>>//
73860>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73860>>>>>Use cProcessStatusPanel.pkg
73860>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJSkinFramework.pkg)
73860>>>>>>>Use windows.pkg
73860>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJComSkinFramework.pkg)
73860>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73860>>>>>>>>>Use FlexCom20.pkg
73860>>>>>>>>>
73860>>>>>>>>>// Changes to Imported package
73860>>>>>>>>>//     OLEXTPxx to XTPxx
73860>>>>>>>>>//     OLExtpxx to xtpxx
73860>>>>>>>>>//     OLESkinFramework to SkinFramework
73860>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73860>>>>>>>>>//     cCom classes to cCJ
73860>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73860>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73860>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73860>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73860>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73860>>>>>>>>>
73860>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73860>>>>>>>>>// because other Codejock classes use these.
73860>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73860>>>>>>>>>
73860>>>>>>>>>
73860>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73860>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73860>>>>>>>>>    Define xtpSkinApplyFrame for 2
73860>>>>>>>>>    Define xtpSkinApplyColors for 4
73860>>>>>>>>>    Define xtpSkinApplyMenus for 8
73860>>>>>>>>>
73860>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73860>>>>>>>>>// Dispatch interface for SkinFramework Control
73860>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73861>>>>>>>>>
73861>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73863>>>>>>>>>        SkinFrameworkApplyOptions retVal
73863>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73864>>>>>>>>>        Function_Return retVal
73865>>>>>>>>>    End_Function
73866>>>>>>>>>
73866>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73868>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73869>>>>>>>>>    End_Procedure
73870>>>>>>>>>
73870>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73872>>>>>>>>>        Boolean retVal
73872>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73873>>>>>>>>>        Function_Return retVal
73874>>>>>>>>>    End_Function
73875>>>>>>>>>
73875>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73877>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73878>>>>>>>>>    End_Procedure
73879>>>>>>>>>
73879>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73881>>>>>>>>>        Boolean retVal
73881>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73882>>>>>>>>>        Function_Return retVal
73883>>>>>>>>>    End_Function
73884>>>>>>>>>
73884>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73886>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73887>>>>>>>>>    End_Procedure
73888>>>>>>>>>
73888>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73890>>>>>>>>>        Handle hDispatchDriver
73890>>>>>>>>>        Boolean retVal
73890>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73891>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73892>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73893>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73894>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73895>>>>>>>>>        Function_Return retVal
73896>>>>>>>>>    End_Function
73897>>>>>>>>>
73897>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73899>>>>>>>>>        Handle hDispatchDriver
73899>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73900>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73901>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73902>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73903>>>>>>>>>    End_Procedure
73904>>>>>>>>>
73904>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73906>>>>>>>>>        Handle hDispatchDriver
73906>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73907>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73908>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73909>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73910>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73911>>>>>>>>>    End_Procedure
73912>>>>>>>>>
73912>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73914>>>>>>>>>        Handle hDispatchDriver
73914>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73915>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73916>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73917>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73918>>>>>>>>>    End_Procedure
73919>>>>>>>>>
73919>>>>>>>>>    Procedure ComRemoveAllWindows
73921>>>>>>>>>        Handle hDispatchDriver
73921>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73922>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73923>>>>>>>>>    End_Procedure
73924>>>>>>>>>
73924>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73926>>>>>>>>>        Handle hDispatchDriver
73926>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73927>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73928>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73929>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73930>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73931>>>>>>>>>    End_Procedure
73932>>>>>>>>>
73932>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73934>>>>>>>>>        Handle hDispatchDriver
73934>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73935>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73936>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73937>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73938>>>>>>>>>    End_Procedure
73939>>>>>>>>>
73939>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73941>>>>>>>>>        Handle hDispatchDriver
73941>>>>>>>>>        Variant retVal
73941>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73942>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73943>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73944>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73945>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73946>>>>>>>>>        Function_Return retVal
73947>>>>>>>>>    End_Function
73948>>>>>>>>>
73948>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73950>>>>>>>>>        Handle hDispatchDriver
73950>>>>>>>>>        Variant retVal
73950>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73951>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73952>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73953>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73954>>>>>>>>>        Function_Return retVal
73955>>>>>>>>>    End_Function
73956>>>>>>>>>
73956>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73958>>>>>>>>>        Handle hDispatchDriver
73958>>>>>>>>>        OLE_COLOR retVal
73958>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73959>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73960>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73961>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73962>>>>>>>>>        Function_Return retVal
73963>>>>>>>>>    End_Function
73964>>>>>>>>>
73964>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73966>>>>>>>>>        Handle hDispatchDriver
73966>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73967>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73968>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73969>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73970>>>>>>>>>    End_Procedure
73971>>>>>>>>>
73971>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73973>>>>>>>>>        Handle hDispatchDriver
73973>>>>>>>>>        Variant retVal
73973>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73974>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73975>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73976>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73977>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
73978>>>>>>>>>        Function_Return retVal
73979>>>>>>>>>    End_Function
73980>>>>>>>>>
73980>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
73982>>>>>>>>>        Handle hDispatchDriver
73982>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73983>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73984>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73985>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
73986>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
73987>>>>>>>>>    End_Procedure
73988>>>>>>>>>
73988>>>>>>>>>    Procedure ComAboutBox
73990>>>>>>>>>        Handle hDispatchDriver
73990>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73991>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
73992>>>>>>>>>    End_Procedure
73993>>>>>>>>>End_Class
73994>>>>>>>>>
73994>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
73994>>>>>>>>>// Event interface for SkinFramework Control
73994>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
73995>>>>>>>>>
73995>>>>>>>>>    Procedure RegisterComEvents
73997>>>>>>>>>    End_Procedure
73998>>>>>>>>>End_Class
73999>>>>>>>>>
73999>>>>>>>>>// CoClass
73999>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
73999>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
73999>>>>>>>>>// SkinFramework Control
73999>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74000>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74001>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74002>>>>>>>>>
74002>>>>>>>>>    Procedure Construct_Object
74004>>>>>>>>>        Forward Send Construct_Object
74006>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74007>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74008>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74009>>>>>>>>>        Set peAutoCreate to acAutoCreate
74010>>>>>>>>>    End_Procedure
74011>>>>>>>>>End_Class
74012>>>>>>>>>
74012>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74012>>>>>>>>>// SkinFramework Global Settings
74012>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74013>>>>>>>>>
74013>>>>>>>>>    Function ComLicense Returns String
74015>>>>>>>>>        String retVal
74015>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74016>>>>>>>>>        Function_Return retVal
74017>>>>>>>>>    End_Function
74018>>>>>>>>>
74018>>>>>>>>>    Procedure Set ComLicense String value
74020>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74021>>>>>>>>>    End_Procedure
74022>>>>>>>>>
74022>>>>>>>>>    Function ComTitle Returns String
74024>>>>>>>>>        String retVal
74024>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74025>>>>>>>>>        Function_Return retVal
74026>>>>>>>>>    End_Function
74027>>>>>>>>>
74027>>>>>>>>>    Procedure Set ComTitle String value
74029>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74030>>>>>>>>>    End_Procedure
74031>>>>>>>>>
74031>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74031>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74033>>>>>>>>>        Boolean retVal
74033>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74034>>>>>>>>>        Function_Return retVal
74035>>>>>>>>>    End_Function
74036>>>>>>>>>
74036>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74036>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74038>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74039>>>>>>>>>    End_Procedure
74040>>>>>>>>>
74040>>>>>>>>>    Function ComVersion Returns String
74042>>>>>>>>>        Handle hDispatchDriver
74042>>>>>>>>>        String retVal
74042>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74043>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74044>>>>>>>>>        Function_Return retVal
74045>>>>>>>>>    End_Function
74046>>>>>>>>>
74046>>>>>>>>>    Function ComUnicode Returns Boolean
74048>>>>>>>>>        Handle hDispatchDriver
74048>>>>>>>>>        Boolean retVal
74048>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74049>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74050>>>>>>>>>        Function_Return retVal
74051>>>>>>>>>    End_Function
74052>>>>>>>>>
74052>>>>>>>>>    Function ComOcxPath Returns String
74054>>>>>>>>>        Handle hDispatchDriver
74054>>>>>>>>>        String retVal
74054>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74055>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74056>>>>>>>>>        Function_Return retVal
74057>>>>>>>>>    End_Function
74058>>>>>>>>>End_Class
74059>>>>>>>>>
74059>>>>>>>>>// CoClass
74059>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74059>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74059>>>>>>>>>// SkinFramework Global Settings
74059>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74060>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74061>>>>>>>>>
74061>>>>>>>>>    Procedure Construct_Object
74063>>>>>>>>>        Forward Send Construct_Object
74065>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74066>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74067>>>>>>>>>    End_Procedure
74068>>>>>>>>>End_Class
74069>>>>>>>>>
74069>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74069>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74070>>>>>>>>>
74070>>>>>>>>>    Function ComColorScheme Returns String
74072>>>>>>>>>        String retVal
74072>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74073>>>>>>>>>        Function_Return retVal
74074>>>>>>>>>    End_Function
74075>>>>>>>>>
74075>>>>>>>>>    Procedure Set ComColorScheme String value
74077>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74078>>>>>>>>>    End_Procedure
74079>>>>>>>>>
74079>>>>>>>>>    Function ComFontSize Returns String
74081>>>>>>>>>        String retVal
74081>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>
74084>>>>>>>>>    Procedure Set ComFontSize String value
74086>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74087>>>>>>>>>    End_Procedure
74088>>>>>>>>>
74088>>>>>>>>>    Function ComIniFileName Returns String
74090>>>>>>>>>        String retVal
74090>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74091>>>>>>>>>        Function_Return retVal
74092>>>>>>>>>    End_Function
74093>>>>>>>>>
74093>>>>>>>>>    Procedure Set ComIniFileName String value
74095>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74096>>>>>>>>>    End_Procedure
74097>>>>>>>>>End_Class
74098>>>>>>>>>
74098>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74098>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74099>>>>>>>>>
74099>>>>>>>>>    Function ComName Returns String
74101>>>>>>>>>        String retVal
74101>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74102>>>>>>>>>        Function_Return retVal
74103>>>>>>>>>    End_Function
74104>>>>>>>>>
74104>>>>>>>>>    Procedure Set ComName String value
74106>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74107>>>>>>>>>    End_Procedure
74108>>>>>>>>>
74108>>>>>>>>>    Function ComPath Returns String
74110>>>>>>>>>        String retVal
74110>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74111>>>>>>>>>        Function_Return retVal
74112>>>>>>>>>    End_Function
74113>>>>>>>>>
74113>>>>>>>>>    Procedure Set ComPath String value
74115>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74116>>>>>>>>>    End_Procedure
74117>>>>>>>>>
74117>>>>>>>>>    Function ComCount Returns Integer
74119>>>>>>>>>        Handle hDispatchDriver
74119>>>>>>>>>        Integer retVal
74119>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74120>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74121>>>>>>>>>        Function_Return retVal
74122>>>>>>>>>    End_Function
74123>>>>>>>>>
74123>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74125>>>>>>>>>        Handle hDispatchDriver
74125>>>>>>>>>        Variant retVal
74125>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74126>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74127>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74128>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74129>>>>>>>>>        Function_Return retVal
74130>>>>>>>>>    End_Function
74131>>>>>>>>>
74131>>>>>>>>>    Function Com_NewEnum Returns Variant
74133>>>>>>>>>        Handle hDispatchDriver
74133>>>>>>>>>        Variant retVal
74133>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74134>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74135>>>>>>>>>        Function_Return retVal
74136>>>>>>>>>    End_Function
74137>>>>>>>>>End_Class
74138>>>>>>>>>
74138>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74138>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74139>>>>>>>>>
74139>>>>>>>>>    Function ComCount Returns Integer
74141>>>>>>>>>        Handle hDispatchDriver
74141>>>>>>>>>        Integer retVal
74141>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74142>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74143>>>>>>>>>        Function_Return retVal
74144>>>>>>>>>    End_Function
74145>>>>>>>>>
74145>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74147>>>>>>>>>        Handle hDispatchDriver
74147>>>>>>>>>        Variant retVal
74147>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74148>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74149>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74150>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74151>>>>>>>>>        Function_Return retVal
74152>>>>>>>>>    End_Function
74153>>>>>>>>>
74153>>>>>>>>>    Function Com_NewEnum Returns Variant
74155>>>>>>>>>        Handle hDispatchDriver
74155>>>>>>>>>        Variant retVal
74155>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74156>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74157>>>>>>>>>        Function_Return retVal
74158>>>>>>>>>    End_Function
74159>>>>>>>>>End_Class
74160>>>>>>>>>
74160>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74160>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74161>>>>>>>>>
74161>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74163>>>>>>>>>        Handle hDispatchDriver
74163>>>>>>>>>        OLE_COLOR retVal
74163>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74164>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74165>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74166>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74167>>>>>>>>>        Function_Return retVal
74168>>>>>>>>>    End_Function
74169>>>>>>>>>End_Class
74170>>>>>>>Use cApplication.pkg
74170>>>>>>>
74170>>>>>>>Struct tSkinInformation
74170>>>>>>>    String sName     // description of the skin
74170>>>>>>>    String sSkinfile // file path. Can be relative or full
74170>>>>>>>    String sSkinIni  // section name
74170>>>>>>>End_Struct
74170>>>>>>>
74170>>>>>>>
74170>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74171>>>>>>>    
74171>>>>>>>    Procedure Construct_Object
74173>>>>>>>        Forward Send Construct_Object
74175>>>>>>>        
74175>>>>>>>        Property String psSkinFile ""
74176>>>>>>>        Property String psSkinIni ""
74177>>>>>>>        Property Boolean pbLoadPreference False
74178>>>>>>>        
74178>>>>>>>        Set peAutoCreate to acAutoCreate
74179>>>>>>>        
74179>>>>>>>        Move Self to ghoSkinFramework
74180>>>>>>>    End_Procedure
74181>>>>>>>    
74181>>>>>>>    // return the default skin path, which is the programs directory.
74181>>>>>>>    // This requires an application object.
74181>>>>>>>    // If you want to different skin path, override this.
74181>>>>>>>    Function SkinPath Returns String
74183>>>>>>>        String sPath sPaths
74183>>>>>>>        Handle hoWorkspace
74183>>>>>>>        If ghoApplication Begin
74185>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74186>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74187>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74188>>>>>>>        End
74188>>>>>>>>
74188>>>>>>>        Else Begin
74189>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74190>>>>>>>>
74190>>>>>>>        End
74190>>>>>>>>
74190>>>>>>>        Function_Return sPath
74191>>>>>>>    End_Function
74192>>>>>>>    
74192>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74192>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74192>>>>>>>    Function SkinQFile Returns String
74194>>>>>>>        String sFile sPath sSep
74194>>>>>>>        Boolean bQualified
74194>>>>>>>        Get psSkinFile to sFile
74195>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74197>>>>>>>            Get SkinPath to sPath
74198>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74199>>>>>>>            Move (sPath - sSep - sFile) to sFile
74200>>>>>>>        End
74200>>>>>>>>
74200>>>>>>>        Function_Return sFile
74201>>>>>>>    End_Function
74202>>>>>>>    
74202>>>>>>>    // defines the default VDF window class mapping.
74202>>>>>>>    Procedure OnAddVDFWindowClasses
74204>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74205>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74206>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74207>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74208>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74209>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74210>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74211>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74212>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74213>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74214>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74215>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74216>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74217>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74218>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74219>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74220>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74221>>>>>>>        // External class
74221>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74222>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74223>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74224>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74225>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74226>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74227>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74228>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74229>>>>>>>    End_Procedure
74230>>>>>>>    
74230>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74230>>>>>>>    Procedure OnAddCustomWindowClasses
74232>>>>>>>    End_Procedure
74233>>>>>>>    
74233>>>>>>>    // called when object is created during end_construct_object.
74233>>>>>>>    Procedure OnCreate
74235>>>>>>>        Integer iOpts
74235>>>>>>>        Boolean bUseWindowsFont
74235>>>>>>>        Forward Send OnCreate
74237>>>>>>>        
74237>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74237>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74237>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74238>>>>>>>        If bUseWindowsFont Begin
74240>>>>>>>            Get ComApplyOptions to iOpts
74241>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74242>>>>>>>        End
74242>>>>>>>>
74242>>>>>>>        
74242>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74242>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74242>>>>>>>        // and this was the suggested workaround.
74242>>>>>>>        Set ComAutoApplyNewThreads to False
74243>>>>>>>        
74243>>>>>>>        Send OnAddVDFWindowClasses
74244>>>>>>>        Send OnAddCustomWindowClasses
74245>>>>>>>        
74245>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74245>>>>>>>        If (pbLoadPreference(Self)) Begin
74247>>>>>>>            Send LoadSkinPreference
74248>>>>>>>        End
74248>>>>>>>>
74248>>>>>>>        // if a skin file name exists, we apply the skin.
74248>>>>>>>        If (psSkinFile(Self)<>"") Begin
74250>>>>>>>            Send ApplySkin
74251>>>>>>>        End
74251>>>>>>>>
74251>>>>>>>    End_Procedure
74252>>>>>>>    
74252>>>>>>>    // called by framework as part of application exit.
74252>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74254>>>>>>>        Send Notify_Exit_Application
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    Procedure Notify_Exit_Application
74258>>>>>>>        If (pbLoadPreference(Self)) Begin
74260>>>>>>>            Send SaveSkinPreference
74261>>>>>>>        End
74261>>>>>>>>
74261>>>>>>>    End_Procedure
74262>>>>>>>    
74262>>>>>>>    Procedure NotifyPreApplySkin
74264>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74266>>>>>>>    End_Procedure
74267>>>>>>>    
74267>>>>>>>    Procedure NotifyPostApplySkin
74269>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74271>>>>>>>    End_Procedure
74272>>>>>>>    
74272>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74272>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74272>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74274>>>>>>>        tSkinInformation[] Skins
74274>>>>>>>        tSkinInformation[] Skins
74275>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74275>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74275>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74275>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74275>>>>>>>        Integer iPos iDfltLen
74275>>>>>>>        Boolean bUseRelativePath
74275>>>>>>>        
74275>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74276>>>>>>>        
74276>>>>>>>        Get SkinPath to sDefaultPath
74277>>>>>>>        If (sPath="") Begin
74279>>>>>>>            Move sDefaultPath to sPath
74280>>>>>>>        End
74280>>>>>>>>
74280>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74281>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74282>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74283>>>>>>>        
74283>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74284>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74286>>>>>>>            
74286>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74287>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74288>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74289>>>>>>>            
74289>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74290>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74291>>>>>>>            
74291>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74297>>>>>>>>
74297>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74298>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74299>>>>>>>                
74299>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74300>>>>>>>                
74300>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74306>>>>>>>>
74306>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74307>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74308>>>>>>>                    
74308>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74309>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74310>>>>>>>                    If bUseRelativePath Begin
74312>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74313>>>>>>>                        If iPos Begin
74315>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74316>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74320>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74321>>>>>>>                            Loop
74322>>>>>>>>
74322>>>>>>>                        End
74322>>>>>>>>
74322>>>>>>>                    End
74322>>>>>>>>
74322>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74323>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74324>>>>>>>                    
74324>>>>>>>                    Increment iArrayItem
74325>>>>>>>                Loop
74326>>>>>>>>
74326>>>>>>>            Loop
74327>>>>>>>>
74327>>>>>>>            
74327>>>>>>>            Send Destroy of hSkinDescriptions
74328>>>>>>>            Send Destroy of hSkinDescription
74329>>>>>>>            Send Destroy of hSkinIniFile
74330>>>>>>>            
74330>>>>>>>        End
74330>>>>>>>>
74330>>>>>>>        Function_Return Skins
74331>>>>>>>    End_Function
74332>>>>>>>    
74332>>>>>>>    // Save the skin preference. This requires an application object.
74332>>>>>>>    // Only do this if the application object allows it.
74332>>>>>>>    // This is called during startup if pbLoadPreference is True
74332>>>>>>>    // Suitable for override
74332>>>>>>>    Procedure SaveSkinPreference
74334>>>>>>>        String sSkin sIni
74334>>>>>>>        If ghoApplication Begin
74336>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74338>>>>>>>                Get psSkinFile to sSkin
74339>>>>>>>                Get psSkinIni to sIni
74340>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74341>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74342>>>>>>>            End
74342>>>>>>>>
74342>>>>>>>        End
74342>>>>>>>>
74342>>>>>>>        Else Begin
74343>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74344>>>>>>>>
74344>>>>>>>        End
74344>>>>>>>>
74344>>>>>>>    End_Procedure
74345>>>>>>>    
74345>>>>>>>    // Load the skin preference. This requires an application object.
74345>>>>>>>    // Only do this if the application object allows it.
74345>>>>>>>    // This is called during startup if pbLoadPreference is True
74345>>>>>>>    // Suitable for override
74345>>>>>>>    Procedure LoadSkinPreference
74347>>>>>>>        String sSkin sIni
74347>>>>>>>        Boolean bExists
74347>>>>>>>        If ghoApplication Begin
74349>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74351>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74352>>>>>>>                If bExists Begin
74354>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74355>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74356>>>>>>>                    Set psSkinFile to sSkin
74357>>>>>>>                    Set psSkinIni to sIni
74358>>>>>>>                End
74358>>>>>>>>
74358>>>>>>>            End
74358>>>>>>>>
74358>>>>>>>        End
74358>>>>>>>>
74358>>>>>>>        Else Begin
74359>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74360>>>>>>>>
74360>>>>>>>        End
74360>>>>>>>>
74360>>>>>>>    End_Procedure
74361>>>>>>>    
74361>>>>>>>    // Can be called to apply the current skin.
74361>>>>>>>    Procedure ApplySkin
74363>>>>>>>        Boolean bOk
74363>>>>>>>        String sSkin sIni
74363>>>>>>>        If (IsComObjectCreated(Self)) Begin
74365>>>>>>>            Get SkinQFile to sSkin
74366>>>>>>>            Get psSkinIni to sIni
74367>>>>>>>            
74367>>>>>>>            Send NotifyPreApplySkin
74368>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74368>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74369>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74370>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74372>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74372>>>>>>>                Send EnableVisualStyles of Desktop True
74373>>>>>>>            End
74373>>>>>>>>
74373>>>>>>>            Send NotifyPostApplySkin
74374>>>>>>>        End
74374>>>>>>>>
74374>>>>>>>    End_Procedure
74375>>>>>>>    
74375>>>>>>>    
74375>>>>>>>End_Class
74376>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProgressBar.pkg)
74376>>>>>>>Use Windows.pkg
74376>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWinControl.pkg)
74376>>>>>>>>>Use Windows.pkg
74376>>>>>>>>>
74376>>>>>>>>>// Key State Masks for Mouse Messages
74376>>>>>>>>>
74376>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74376>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74376>>>>>>>>>Define MK_SHIFT    for |CI$0004
74376>>>>>>>>>Define MK_CONTROL  for |CI$0008
74376>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74376>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74376>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74376>>>>>>>>>
74376>>>>>>>>>Enum_List // Mouse Key Flags
74376>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74376>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74376>>>>>>>>>    Define mkRight   for MK_RBUTTON
74376>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74376>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74376>>>>>>>>>    Define mkShift   for MK_SHIFT
74376>>>>>>>>>    Define mkControl for MK_CONTROL
74376>>>>>>>>>End_Enum_List
74376>>>>>>>>>
74376>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74376>>>>>>>>>    Define mbLeft
74376>>>>>>>>>    Define mbMiddle
74376>>>>>>>>>    Define mbRight
74376>>>>>>>>>    Define mbX1
74376>>>>>>>>>    Define mbX2
74376>>>>>>>>>End_Enum_List
74376>>>>>>>>>
74376>>>>>>>>>Class cWinControl is a DfBaseControl
74377>>>>>>>>>    Procedure Construct_Object
74379>>>>>>>>>        Forward Send Construct_Object
74381>>>>>>>>>        Property Integer private_pbEnabled True
74382>>>>>>>>>        Property Integer private_pbVisible True
74383>>>>>>>>>    End_Procedure
74384>>>>>>>>>    
74384>>>>>>>>>    Procedure End_Construct_Object
74386>>>>>>>>>        Forward Send End_Construct_Object
74388>>>>>>>>>        
74388>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74389>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74390>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74391>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74392>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74393>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74394>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74395>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74396>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74397>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74398>>>>>>>>>    End_Procedure
74399>>>>>>>>>    
74399>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74401>>>>>>>>>        //Intentionally cancelled
74401>>>>>>>>>    End_Procedure
74402>>>>>>>>>    
74402>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74404>>>>>>>>>        //Intentionally cancelled
74404>>>>>>>>>    End_Procedure
74405>>>>>>>>>    
74405>>>>>>>>>    Procedure DoRecreateWindow
74407>>>>>>>>>        // Recreates the window
74407>>>>>>>>>        If (Window_Handle(Self)) Begin
74409>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74409>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74410>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74411>>>>>>>>>        End
74411>>>>>>>>>>
74411>>>>>>>>>    End_Procedure
74412>>>>>>>>>    
74412>>>>>>>>>    Procedure DoUpdateWindow
74414>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74414>>>>>>>>>        Handle hWnd
74414>>>>>>>>>        
74414>>>>>>>>>        Get Window_Handle to hWnd
74415>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74418>>>>>>>>>    End_Procedure
74419>>>>>>>>>    
74419>>>>>>>>>    Procedure Page Integer iState
74421>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74422>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74423>>>>>>>>>        Forward Send Page iState
74425>>>>>>>>>    End_Procedure
74426>>>>>>>>>    
74426>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74428>>>>>>>>>        Integer x y eButton
74428>>>>>>>>>        
74428>>>>>>>>>        Move (Hi(lParam))  to y
74429>>>>>>>>>        Move (Low(lParam)) to x
74430>>>>>>>>>        
74430>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74431>>>>>>>>>    End_Procedure
74432>>>>>>>>>    
74432>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74434>>>>>>>>>        Integer x y eButton
74434>>>>>>>>>        
74434>>>>>>>>>        Move (Hi(lParam))  to y
74435>>>>>>>>>        Move (Low(lParam)) to x
74436>>>>>>>>>        
74436>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74440>>>>>>>>>        Integer x y eButton
74440>>>>>>>>>        
74440>>>>>>>>>        Move (Hi(lParam))  to y
74441>>>>>>>>>        Move (Low(lParam)) to x
74442>>>>>>>>>        
74442>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74443>>>>>>>>>    End_Procedure
74444>>>>>>>>>    
74444>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74446>>>>>>>>>        Integer x y eButton fKeys
74446>>>>>>>>>        
74446>>>>>>>>>        Move (Hi(lParam))  to y
74447>>>>>>>>>        Move (Low(lParam)) to x
74448>>>>>>>>>        
74448>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74449>>>>>>>>>    End_Procedure
74450>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74452>>>>>>>>>        Integer x y eButton
74452>>>>>>>>>        
74452>>>>>>>>>        Move (Hi(lParam))  to y
74453>>>>>>>>>        Move (Low(lParam)) to x
74454>>>>>>>>>        
74454>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74455>>>>>>>>>    End_Procedure
74456>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74458>>>>>>>>>        Integer x y eButton
74458>>>>>>>>>        
74458>>>>>>>>>        Move (Hi(lParam))  to y
74459>>>>>>>>>        Move (Low(lParam)) to x
74460>>>>>>>>>        
74460>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74461>>>>>>>>>    End_Procedure
74462>>>>>>>>>    
74462>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74464>>>>>>>>>        Integer x y eButton
74464>>>>>>>>>        
74464>>>>>>>>>        Move (Hi(lParam))  to y
74465>>>>>>>>>        Move (Low(lParam)) to x
74466>>>>>>>>>        
74466>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74467>>>>>>>>>    End_Procedure
74468>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74470>>>>>>>>>        Integer x y eButton
74470>>>>>>>>>        
74470>>>>>>>>>        Move (Hi(lParam))  to y
74471>>>>>>>>>        Move (Low(lParam)) to x
74472>>>>>>>>>        
74472>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74473>>>>>>>>>    End_Procedure
74474>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74476>>>>>>>>>        Integer x y eButton
74476>>>>>>>>>        
74476>>>>>>>>>        Move (Hi(lParam))  to y
74477>>>>>>>>>        Move (Low(lParam)) to x
74478>>>>>>>>>        
74478>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74479>>>>>>>>>    End_Procedure
74480>>>>>>>>>    
74480>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74482>>>>>>>>>        Integer x y eButton
74482>>>>>>>>>        
74482>>>>>>>>>        Move (Hi(lParam))  to y
74483>>>>>>>>>        Move (Low(lParam)) to x
74484>>>>>>>>>        
74484>>>>>>>>>        Send OnMouseMove x y wParam
74485>>>>>>>>>    End_Procedure
74486>>>>>>>>>    
74486>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74488>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74488>>>>>>>>>        //String sButton
74488>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74488>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74488>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74488>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74488>>>>>>>>>        
74488>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74488>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74488>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74488>>>>>>>>>    End_Procedure
74489>>>>>>>>>    
74489>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74491>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74491>>>>>>>>>        //String sButton
74491>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74491>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74491>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74491>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74491>>>>>>>>>        
74491>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74491>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74491>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74491>>>>>>>>>    End_Procedure
74492>>>>>>>>>    
74492>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74494>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74494>>>>>>>>>        //String sButton
74494>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74494>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74494>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74494>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74494>>>>>>>>>        
74494>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74494>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74494>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74494>>>>>>>>>    End_Procedure
74495>>>>>>>>>    
74495>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74497>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74497>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74497>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74497>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74497>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74497>>>>>>>>>        
74497>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74497>>>>>>>>>    End_Procedure
74498>>>>>>>>>    
74498>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74500>>>>>>>>>        Handle hWnd
74500>>>>>>>>>        
74500>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74502>>>>>>>>>            Set private_pbEnabled to bEnabled
74503>>>>>>>>>            Get Window_Handle to hWnd
74504>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74507>>>>>>>>>        End
74507>>>>>>>>>>
74507>>>>>>>>>    End_Procedure
74508>>>>>>>>>    Function pbEnabled Returns Boolean
74510>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74511>>>>>>>>>    End_Function
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74514>>>>>>>>>        Handle  hWnd
74514>>>>>>>>>        Integer iVoid
74514>>>>>>>>>        
74514>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74516>>>>>>>>>            Set private_pbVisible to bVisible
74517>>>>>>>>>            Get Window_Handle to hWnd
74518>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74521>>>>>>>>>        End
74521>>>>>>>>>>
74521>>>>>>>>>    End_Procedure
74522>>>>>>>>>    Function pbVisible Returns Boolean
74524>>>>>>>>>        Function_Return (private_pbVisible(Self))
74525>>>>>>>>>    End_Function
74526>>>>>>>>>    
74526>>>>>>>>>End_Class
74527>>>>>>>Use CommCtrl.pkg
74527>>>>>>>
74527>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74527>>>>>>>Class cProgressBar is a cWinControl
74528>>>>>>>    
74528>>>>>>>    Procedure Construct_Object
74530>>>>>>>        Forward Send Construct_Object
74532>>>>>>>        Property Integer private_piMinimum
74533>>>>>>>        Property Integer private_piMaximum   100
74534>>>>>>>        Property Integer private_piAdvanceBy 10
74535>>>>>>>        Property Integer private_piPosition
74536>>>>>>>        Property Integer private_pbVertical  False
74537>>>>>>>        Property Integer private_pbSmooth    False
74538>>>>>>>        Property Integer private_piBackColor clDefault
74539>>>>>>>        Property Integer private_piBarColor  clDefault
74540>>>>>>>        
74540>>>>>>>        Send Define_ToolTip_Support_Mixin
74541>>>>>>>        
74541>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74542>>>>>>>        Set Focus_Mode to NonFocusable
74543>>>>>>>        Set Skip_State to True
74544>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74545>>>>>>>    End_Procedure
74546>>>>>>>    
74546>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74547>>>>>>>    
74547>>>>>>>    Procedure Set piMinimum Integer iMin
74549>>>>>>>        Integer iMax
74549>>>>>>>        
74549>>>>>>>        Set private_piMinimum to iMin
74550>>>>>>>        Get private_piMaximum to iMax
74551>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74552>>>>>>>    End_Procedure
74553>>>>>>>    Function piMinimum Returns Integer
74555>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74558>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74560>>>>>>>    End_Function
74561>>>>>>>    
74561>>>>>>>    Procedure Set piMaximum Integer iMax
74563>>>>>>>        Integer iMin
74563>>>>>>>        
74563>>>>>>>        Set private_piMaximum to iMax
74564>>>>>>>        Get private_piMinimum to iMin
74565>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74566>>>>>>>    End_Procedure
74567>>>>>>>    Function piMaximum Returns Integer
74569>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74572>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74574>>>>>>>    End_Function
74575>>>>>>>    
74575>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74577>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74578>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74579>>>>>>>    End_Procedure
74580>>>>>>>    Function piAdvanceBy Returns Integer
74582>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74583>>>>>>>    End_Function
74584>>>>>>>    
74584>>>>>>>    Procedure Set piPosition Integer iPos
74586>>>>>>>        Set private_piPosition to iPos
74587>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74588>>>>>>>    End_Procedure
74589>>>>>>>    
74589>>>>>>>    Function piPosition Returns Integer
74591>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74594>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74596>>>>>>>    End_Function
74597>>>>>>>    
74597>>>>>>>    Procedure Set pbVertical Boolean bVertical
74599>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74601>>>>>>>            Set private_pbVertical to bVertical
74602>>>>>>>            Send DoRecreateWindow
74603>>>>>>>        End
74603>>>>>>>>
74603>>>>>>>    End_Procedure
74604>>>>>>>    
74604>>>>>>>    Function pbVertical Returns Boolean
74606>>>>>>>        Function_Return (private_pbVertical(Self))
74607>>>>>>>    End_Function
74608>>>>>>>    
74608>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74610>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74612>>>>>>>            Set private_pbSmooth to bSmooth
74613>>>>>>>            Send DoRecreateWindow
74614>>>>>>>        End
74614>>>>>>>>
74614>>>>>>>    End_Procedure
74615>>>>>>>    Function pbSmooth Returns Boolean
74617>>>>>>>        Function_Return (private_pbSmooth(Self))
74618>>>>>>>    End_Function
74619>>>>>>>    
74619>>>>>>>    Procedure Set piBackColor Integer rgbColor
74621>>>>>>>        Set private_piBackColor to rgbColor
74622>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74623>>>>>>>    End_Procedure
74624>>>>>>>    Function piBackColor Returns Integer
74626>>>>>>>        Function_Return (private_piBackColor(Self))
74627>>>>>>>    End_Function
74628>>>>>>>    
74628>>>>>>>    Procedure Set piBarColor Integer rgbColor
74630>>>>>>>        Set private_piBarColor to rgbColor
74631>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74632>>>>>>>    End_Procedure
74633>>>>>>>    Function piBarColor Returns Integer
74635>>>>>>>        Function_Return (private_piBarColor(Self))
74636>>>>>>>    End_Function
74637>>>>>>>    
74637>>>>>>>    Procedure DoAdvance
74639>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74640>>>>>>>    End_Procedure
74641>>>>>>>    
74641>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74643>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74644>>>>>>>    End_Procedure
74645>>>>>>>    
74645>>>>>>>    Procedure private_DoInitWindow
74647>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74648>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74649>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74650>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74651>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74652>>>>>>>        Set piPosition  to (private_piPosition(Self))
74653>>>>>>>    End_Procedure
74654>>>>>>>    
74654>>>>>>>    Procedure Page_Object Integer iState
74656>>>>>>>        Handle hWnd
74656>>>>>>>        
74656>>>>>>>        Get Window_Handle to hWnd
74657>>>>>>>        If (hWnd=0 and iState) Begin
74659>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74660>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74661>>>>>>>            Forward Send Page_Object True
74663>>>>>>>        End
74663>>>>>>>>
74663>>>>>>>        Else ;            Forward Send Page_Object iState
74666>>>>>>>        
74666>>>>>>>        // Handle tooltip support....
74666>>>>>>>        If (iState = 0) Begin
74668>>>>>>>            Send RequestDeleteToolTip
74669>>>>>>>        End
74669>>>>>>>>
74669>>>>>>>        Else Begin
74670>>>>>>>            Send RequestAddToolTip
74671>>>>>>>        End
74671>>>>>>>>
74671>>>>>>>    End_Procedure
74672>>>>>>>    
74672>>>>>>>    Procedure Page Integer iState
74674>>>>>>>        Forward Send Page iState
74676>>>>>>>        If (iState =1);            Send private_DoInitWindow
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74680>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74680>>>>>>>    // is implemented in a mixin class.
74680>>>>>>>    Procedure RequestAddToolTip
74682>>>>>>>        Send AddToolTip
74683>>>>>>>    End_Procedure
74684>>>>>>>    
74684>>>>>>>    
74684>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74684>>>>>>>    Procedure RequestDeleteToolTip
74686>>>>>>>        Send DeleteToolTip
74687>>>>>>>    End_Procedure
74688>>>>>>>End_Class
74689>>>>>Use Windows.pkg
74689>>>>>Use DUFLanguageConstants.inc
74689>>>>>Use Statpnl.pkg
74689>>>>>
74689>>>>>
74689>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74689>>>>>
74689>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74689>>>>>
74689>>>>>Object Status_Panel is a cProcessStatusPanel
74691>>>>>    Set Size to 152 222
74692>>>>>    Set Border_Style to Border_Dialog
74693>>>>>    Set Icon to "Default.ico"
74694>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74695>>>>>
74695>>>>>    Property Boolean Cancel_Button_Visible_State True
74697>>>>>
74697>>>>>    Procedure Activate
74700>>>>>        Integer iSizeBefore
74700>>>>>        Get GuiSize to iSizeBefore
74701>>>>>        Forward Send Activate
74703>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74704>>>>>    End_Procedure
74705>>>>>
74705>>>>>    Procedure End_Construct_Object
74708>>>>>        Forward Send End_Construct_Object
74710>>>>>        Set Label of oTitleTxt      to ""
74711>>>>>        Set Label of oTableNameTxt  to ""
74712>>>>>        Set Label of oMessageTxt    to ""
74713>>>>>        Set Label of oActionTxt     to ""
74714>>>>>    End_Procedure
74715>>>>>
74715>>>>>    Object oTitleTxt is a TextBox
74717>>>>>        Set Location to 5 21
74718>>>>>        Set Size to 8 179
74719>>>>>        Set Auto_Size_State to False
74720>>>>>        Set Justification_Mode  to jMode_Center
74721>>>>>        Set Label to "This is the Title Text"
74722>>>>>    End_Object
74723>>>>>
74723>>>>>    Object oTableNameTxt is a TextBox
74725>>>>>        Set Size to 19 204
74726>>>>>        Set Location to 18 9
74727>>>>>        Set Auto_Size_State to False
74728>>>>>        Set Justification_Mode to JMode_Left
74729>>>>>        Set Label to "This is the TableName Text"
74730>>>>>    End_Object
74731>>>>>
74731>>>>>    Object oMessageTxt is a TextBox
74733>>>>>        Set Location to 39 9
74734>>>>>        Set Size to 19 204
74735>>>>>        Set Auto_Size_State to False
74736>>>>>        Set Justification_Mode to JMode_Left
74737>>>>>        Set Label to "This is the Message text"
74738>>>>>    End_Object
74739>>>>>
74739>>>>>    Object oActionTxt is a TextBox
74741>>>>>        Set Size to 16 204
74742>>>>>        Set Location to 60 9
74743>>>>>        Set Auto_Size_State to False
74744>>>>>        Set Justification_Mode to JMode_Left
74745>>>>>        Set Label to "This is the Action Text"
74746>>>>>    End_Object
74747>>>>>
74747>>>>>    Object oStopButton is a Button
74749>>>>>        Set Location to 123 82
74750>>>>>        Set Label to C_$Cancel
74751>>>>>
74751>>>>>        Procedure OnClick 
74754>>>>>            Integer iRetval
74754>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74755>>>>>            If (iRetval = MBR_Yes) Begin
74757>>>>>                Send Exit_Application
74758>>>>>            End
74758>>>>>>
74758>>>>>        End_Procedure
74759>>>>>
74759>>>>>    End_Object
74760>>>>>
74760>>>>>    Object oPercentage_tb is a TextBox
74762>>>>>        Set Location to 74 196
74763>>>>>        Set Size to 10 25
74764>>>>>//        Set Label to "% Done"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oCopyRight is a TextBox
74767>>>>>        Set Location to 140 21
74768>>>>>        Set Size to 9 197
74769>>>>>        Set FontPointHeight to 8
74770>>>>>        Set Auto_Size_State to False
74771>>>>>        Set Justification_Mode  to jMode_Center
74772>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
74773>>>>>    End_Object
74774>>>>>
74774>>>>>    Object oProgressBar is a cProgressBar
74776>>>>>        Set Size to 10 179
74777>>>>>        Set Location to 83 22
74778>>>>>        Set pbVisible to True // default
74779>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74780>>>>>    End_Object
74781>>>>>
74781>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74784>>>>>        Set pbVisible of ghoProgressBar to bVisible
74785>>>>>    End_Procedure
74786>>>>>
74786>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74789>>>>>        Boolean bVisible
74789>>>>>        Get pbVisible of ghoProgressBar to bVisible
74790>>>>>        Function_Return (bVisible)
74791>>>>>    End_Function
74792>>>>>
74792>>>>>    Object oProgressBarOverall is a cProgressBar
74794>>>>>        Set Size to 10 179
74795>>>>>        Set Location to 107 22
74796>>>>>        Set pbVisible to True // default
74797>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74798>>>>>    End_Object
74799>>>>>
74799>>>>>    Object oOverallProgress_tb is a TextBox
74801>>>>>        Set Size to 10 65
74802>>>>>        Set Location to 95 24
74803>>>>>        Set Label to "Overall Progress"
74804>>>>>    End_Object
74805>>>>>
74805>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74808>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74809>>>>>    End_Procedure
74810>>>>>
74810>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74813>>>>>        Boolean bVisible
74813>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74814>>>>>        Function_Return (bVisible)
74815>>>>>    End_Function
74816>>>>>
74816>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74816>>>>>    // objects defined within this instance of the status panel.
74816>>>>>
74816>>>>>    // note: all of the messages that change text should be forwarded
74816>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74816>>>>>
74816>>>>>    Procedure Set Message_Text String sText
74819>>>>>        Set Label of oMessageTxt to sText
74820>>>>>        Forward Set Message_Text to sText
74822>>>>>    End_Procedure
74823>>>>>
74823>>>>>    Function Message_Text Returns String
74826>>>>>        Function_Return (Label(oMessageTxt))
74827>>>>>    End_Function
74828>>>>>
74828>>>>>    Procedure Set Action_Text String sText
74831>>>>>        Set Label of oActionTxt to sText
74832>>>>>        Forward Set Action_Text to sText
74834>>>>>    End_Procedure
74835>>>>>
74835>>>>>    Function Action_Text Returns String
74838>>>>>        Function_Return (Label(oActionTxt))
74839>>>>>    End_Function
74840>>>>>
74840>>>>>    Procedure Set Button_Text String sText
74843>>>>>        Set Label of oStopButton to sText
74844>>>>>        Forward Set Button_Text to sText
74846>>>>>    End_Procedure
74847>>>>>
74847>>>>>    Function Button_Text Returns String
74850>>>>>        Function_Return (Label(oStopButton))
74851>>>>>    End_Function
74852>>>>>
74852>>>>>    Procedure Set Title_Text String sText
74855>>>>>        Set Label of oTitleTxt to sText
74856>>>>>        Forward Set Title_Text to sText
74858>>>>>    End_Procedure
74859>>>>>
74859>>>>>    Function Title_Text Returns String
74862>>>>>        Function_Return (Label(oTitleTxt))
74863>>>>>    End_Function
74864>>>>>
74864>>>>>    Procedure Set TableName_Text String sText
74867>>>>>        Set Label of oTableNameTxt to sText
74868>>>>>    End_Procedure
74869>>>>>
74869>>>>>    Function TableName_Text Returns String
74872>>>>>        Function_Return (Label(oTableNameTxt))
74873>>>>>    End_Function
74874>>>>>
74874>>>>>    Procedure Set License_Text String sText
74877>>>>>//        Set Label of oLicense_txt to sText
74877>>>>>    End_Procedure
74878>>>>>
74878>>>>>    // gets called when status panel is activated passing whether a button
74878>>>>>    // should appear
74878>>>>>    Procedure EnableCancelButton Boolean bEnable
74881>>>>>        Boolean bVisible
74881>>>>>        Get Cancel_Button_Visible_State to bVisible
74882>>>>>        If (bEnable = False) Begin
74884>>>>>            Set Visible_State of oStopButton to bVisible
74885>>>>>        End
74885>>>>>>
74885>>>>>        Set Enabled_State of oStopButton to bEnable
74886>>>>>    End_Procedure
74887>>>>>
74887>>>>>    Procedure Reset_StatusPanel
74890>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74891>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74892>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74893>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74894>>>>>    End_Procedure
74895>>>>>
74895>>>>>//    Object oProgressBar is a cProgressBar
74895>>>>>//        Move Self to ghoProgressBar
74895>>>>>//        Set Location to 1 25
74895>>>>>//        Set Size to 9 173
74895>>>>>//        Set piMinimum        to 0
74895>>>>>//        Set piMaximum        to 2000
74895>>>>>//        Set piAdvanceBy      to 100
74895>>>>>//        Set pbSmooth to True
74895>>>>>//
74895>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74895>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74895>>>>>//        // color will show correctly.
74895>>>>>//        Procedure Page Integer iPageObject
74895>>>>>//            Handle hWin
74895>>>>>//            Forward Send Page iPageObject
74895>>>>>//            If (ghoSkinFramework <> 0) Begin
74895>>>>>//                Get Window_Handle to hWin
74895>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74895>>>>>//            End
74895>>>>>//        End_Procedure
74895>>>>>//    End_Object
74895>>>>>
74895>>>>>End_Object
74896>>>>>
74896>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74896>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74896>>>>>//
74896>>>>>Use VdfBase.pkg
74896>>>>>Use cApplication.pkg
74896>>>>>Use seq_chnl.pkg
74896>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fh.pkg)
74896>>>>>>>// This code is part of VDF GUIdance
74896>>>>>>>// Visit us @ http://www.vdf-guidance.com
74896>>>>>>>// e-Mail us @ info@vdf-guidance.com
74896>>>>>>>// VDF GUIdance is a mutual project of
74896>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74896>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74896>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74896>>>>>>>//
74896>>>>>>>//
74896>>>>>>>// *** Windows 32bit file handling wrapper class ***
74896>>>>>>>//
74896>>>>>>>
74896>>>>>>>
74896>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74896>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\cvFileDialogs.pkg)
74896>>>>>>>>>//***************************************************************************
74896>>>>>>>>>//*
74896>>>>>>>>>//* Class:        cvSaveAsDialog
74896>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74896>>>>>>>>>//*
74896>>>>>>>>>//***************************************************************************
74896>>>>>>>>>
74896>>>>>>>>>Use File_dlg.pkg
74896>>>>>>>>>
74896>>>>>>>>>// *WvA: 13-01-1999 Created
74896>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74896>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74896>>>>>>>>>// file_name.
74896>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74897>>>>>>>>>
74897>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74899>>>>>>>>>        Forward Send Construct_Object iImage_Id
74901>>>>>>>>>        Set HideReadOnly_State to True
74902>>>>>>>>>    End_Procedure
74903>>>>>>>>>
74903>>>>>>>>>    Function SelectedFileName Returns String
74905>>>>>>>>>        String sFileName
74905>>>>>>>>>        Move "" to sFileName
74906>>>>>>>>>        If (Show_Dialog(Self)) Begin
74908>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74909>>>>>>>>>        End
74909>>>>>>>>>>
74909>>>>>>>>>        Function_Return sFileName
74910>>>>>>>>>    End_Function
74911>>>>>>>>>End_Class
74912>>>>>>>>>
74912>>>>>>>>>// *WvA: 13-01-1999 Created
74912>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74912>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74912>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74912>>>>>>>>>//                   file-open dialog
74912>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74914>>>>>>>>>    String sSelectedFile
74914>>>>>>>>>    Integer hoOpenFileDialog
74914>>>>>>>>>
74914>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74916>>>>>>>>>
74916>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74917>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74918>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74919>>>>>>>>>
74919>>>>>>>>>        Move Self       to hoOpenFileDialog
74920>>>>>>>>>    End_Object
74921>>>>>>>>>
74921>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74922>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74923>>>>>>>>>    Function_Return sSelectedFile
74924>>>>>>>>>End_Function
74925>>>>>>>>>
74925>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74926>>>>>>>>>
74926>>>>>>>>>    Procedure Construct_Object
74928>>>>>>>>>        Forward Send Construct_Object
74930>>>>>>>>>        Set HideReadOnly_State to True
74931>>>>>>>>>    End_Procedure
74932>>>>>>>>>
74932>>>>>>>>>    Function SelectedFileName Returns String
74934>>>>>>>>>        String sFileName
74934>>>>>>>>>        Move "" to sFileName
74935>>>>>>>>>        If (Show_Dialog(Self)) Begin
74937>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74938>>>>>>>>>        End
74938>>>>>>>>>>
74938>>>>>>>>>        Function_Return sFileName
74939>>>>>>>>>    End_Function
74940>>>>>>>>>
74940>>>>>>>>>End_Class
74941>>>>>>>>>
74941>>>>>>>>>// Added optional default filename as suggested by Nils
74941>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74943>>>>>>>>>    String sSelectedFile
74943>>>>>>>>>    Integer hoDialog
74943>>>>>>>>>
74943>>>>>>>>>    Move "" to sSelectedFile
74944>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74945>>>>>>>>>    If (hoDialog) Begin
74947>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74947>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74948>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74949>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74950>>>>>>>>>        If (Num_Arguments = 4) Begin
74952>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74953>>>>>>>>>        End
74953>>>>>>>>>>
74953>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74954>>>>>>>>>        Send Destroy of hoDialog
74955>>>>>>>>>    End
74955>>>>>>>>>>
74955>>>>>>>>>    Function_Return sSelectedFile
74956>>>>>>>>>End_Function
74957>>>>>>>Use Seq_chnl.pkg
74957>>>>>>>
74957>>>>>>>Use windows.pkg
74957>>>>>>>Use Dll.pkg
74957>>>>>>>
74957>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.pkg)
74957>>>>>>>>>// This code is part of VDF GUIdance
74957>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74957>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74957>>>>>>>>>// VDF GUIdance is a mutual project of
74957>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74957>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74957>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74957>>>>>>>>>//
74957>>>>>>>>>//
74957>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74957>>>>>>>>>// Unicode variant
74957>>>>>>>>>
74957>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.h)
74957>>>>>>>>>>>//TH-Header
74957>>>>>>>>>>>//*****************************************************************************************
74957>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74957>>>>>>>>>>>// All rights reserved.
74957>>>>>>>>>>>//
74957>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74957>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74957>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74957>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74957>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74957>>>>>>>>>>>//
74957>>>>>>>>>>>// Contents:
74957>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74957>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74957>>>>>>>>>>>//*****************************************************************************************
74957>>>>>>>>>>>//TH-RevisionStart
74957>>>>>>>>>>>//TH-RevisionEnd
74957>>>>>>>>>>>
74957>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74957>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74957>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74957>>>>>>>>>>>
74957>>>>>>>>>>>
74957>>>>>>>>>>>Define vMax_Path     For |CI260
74957>>>>>>>>>>>Define vMinChar      For |CI$80
74957>>>>>>>>>>>Define vMaxChar      For |CI$7F
74957>>>>>>>>>>>Define vMinShort     For |CI$8000
74957>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74957>>>>>>>>>>>Define vMinLong      For |CI$80000000
74957>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74957>>>>>>>>>>>Define vMaxByte      For |CI$FF
74957>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74957>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74957>>>>>>>>>>>
74957>>>>>>>>>>>
74957>>>>>>>>>>>
74957>>>>>>>>>>>// For FindFirstFile
74957>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74957>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74957>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74957>>>>>>>>>>>
74957>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74957>>>>>>>>>>>// the API-call ShellExecute is used.
74957>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74957>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74957>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74957>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74957>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74957>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74957>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74957>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74957>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74957>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74957>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74957>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74957>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74957>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74957>>>>>>>>>>>
74957>>>>>>>>>>>
74957>>>>>>>>>>>// C-Structure
74957>>>>>>>>>>>//typedef struct _browseinfo {
74957>>>>>>>>>>>//    HWND hwndOwner;
74957>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74957>>>>>>>>>>>//    LPSTR pszDisplayName;
74957>>>>>>>>>>>//    LPCSTR lpszTitle;
74957>>>>>>>>>>>//    UINT ulFlags;
74957>>>>>>>>>>>//    BFFCALLBACK lpfn;
74957>>>>>>>>>>>//    LPARAM lParam;
74957>>>>>>>>>>>//    int iImage;
74957>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74957>>>>>>>>>>>
74957>>>>>>>>>>>//declare C structure struct_browseinfo
74957>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74957>>>>>>>>>>>Struct tvBrowseInfo
74957>>>>>>>>>>>  Handle    hWndOwner
74957>>>>>>>>>>>  Pointer   pIDLRoot
74957>>>>>>>>>>>  Pointer   pszDisplayName
74957>>>>>>>>>>>  Pointer   lpszTitle
74957>>>>>>>>>>>  DWord     ulFlags
74957>>>>>>>>>>>  Pointer   lpfnCallback
74957>>>>>>>>>>>  LongPtr   lParam
74957>>>>>>>>>>>  DWord     iImage
74957>>>>>>>>>>>End_Struct // tvBrowseInfo
74957>>>>>>>>>>>
74957>>>>>>>>>>>// Browsing for directory.
74957>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74957>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74957>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74957>>>>>>>>>>>                                            // The callback function can set the status text by
74957>>>>>>>>>>>                                            // sending messages to the dialog box.
74957>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74957>>>>>>>>>>>
74957>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74957>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74957>>>>>>>>>>>
74957>>>>>>>>>>>// message from browser
74957>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74957>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74957>>>>>>>>>>>
74957>>>>>>>>>>>// messages to browser
74957>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74957>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74957>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74957>>>>>>>>>>>
74957>>>>>>>>>>>
74957>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74958>>>>>>>>>>>
74958>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74959>>>>>>>>>>>
74959>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74960>>>>>>>>>>>
74960>>>>>>>>>>>
74960>>>>>>>>>>>
74960>>>>>>>>>>>
74960>>>>>>>>>>>Struct tvSecurity_attributes
74960>>>>>>>>>>>  DWord   nLength
74960>>>>>>>>>>>  Pointer lpDescriptor
74960>>>>>>>>>>>  Integer bInheritHandle
74960>>>>>>>>>>>End_Struct // tvSecurity_attributes
74960>>>>>>>>>>>
74960>>>>>>>>>>>//nLength:
74960>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74960>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74960>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74960>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74960>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74960>>>>>>>>>>>//
74960>>>>>>>>>>>//lpSecurityDescriptor:
74960>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74960>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74960>>>>>>>>>>>// descriptor of the calling process.
74960>>>>>>>>>>>//
74960>>>>>>>>>>>//bInheritHandle:
74960>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74960>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74960>>>>>>>>>>>
74960>>>>>>>>>>>
74960>>>>>>>>>>>// BOOL CreateDirectory(
74960>>>>>>>>>>>//    LPCTSTR lpPathName,
74960>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74960>>>>>>>>>>>//   );
74960>>>>>>>>>>>//
74960>>>>>>>>>>>// lpPathName
74960>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74960>>>>>>>>>>>//  to be created.
74960>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74960>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74960>>>>>>>>>>>// lpSecurityAttributes
74960>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74960>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74960>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74960>>>>>>>>>>>// Returns:
74960>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74960>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74960>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
74961>>>>>>>>>>>
74961>>>>>>>>>>>
74961>>>>>>>>>>>// lpPathName
74961>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74961>>>>>>>>>>>//  to be removed.
74961>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74961>>>>>>>>>>>// Returns:
74961>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74961>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74961>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
74962>>>>>>>>>>>
74962>>>>>>>>>>>
74962>>>>>>>>>>>
74962>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74962>>>>>>>>>>>// executable file or a document file.
74962>>>>>>>>>>>//
74962>>>>>>>>>>>// Operation can be one of the following:
74962>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74962>>>>>>>>>>>//            The file can be an executable file or a document file.
74962>>>>>>>>>>>//            The file can be a folder to open.
74962>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74962>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74962>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74962>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74962>>>>>>>>>>>//
74962>>>>>>>>>>>// Return Values:
74962>>>>>>>>>>>//
74962>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74962>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74962>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74962>>>>>>>>>>>//
74962>>>>>>>>>>>// The following table lists these error values:
74962>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74962>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74962>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74962>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74962>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74962>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74962>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74962>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74962>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74962>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
74962>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74962>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
74962>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
74962>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74962>>>>>>>>>>>
74962>>>>>>>>>>>
74962>>>>>>>>>>>
74962>>>>>>>>>>>// Code to open the program that is associated with the selected file.
74962>>>>>>>>>>>//
74962>>>>>>>>>>>// External function call used in Procedure DoStartDocument
74962>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
74963>>>>>>>>>>>
74963>>>>>>>>>>>
74963>>>>>>>>>>>
74963>>>>>>>>>>>
74963>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
74963>>>>>>>>>>>Define vFO_COPY                For |CI$0002
74963>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
74963>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
74963>>>>>>>>>>>
74963>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74963>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74963>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74963>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74963>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74963>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74963>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74963>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74963>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74963>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74963>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74963>>>>>>>>>>>
74963>>>>>>>>>>>Struct tvShFileOpStruct
74963>>>>>>>>>>>  Handle   hWnd
74963>>>>>>>>>>>  UInteger wFunc
74963>>>>>>>>>>>  Pointer  pFrom
74963>>>>>>>>>>>  Pointer  pTo
74963>>>>>>>>>>>  Short    fFlags
74963>>>>>>>>>>>  Integer  fAnyOperationsAborted
74963>>>>>>>>>>>  Pointer  hNameMappings
74963>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74963>>>>>>>>>>>End_Struct // tvShFileOpStruct
74963>>>>>>>>>>>
74963>>>>>>>>>>>// hwnd
74963>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74963>>>>>>>>>>>
74963>>>>>>>>>>>// wFunc
74963>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74963>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74963>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74963>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74963>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74963>>>>>>>>>>>
74963>>>>>>>>>>>// pFrom
74963>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74963>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74963>>>>>>>>>>>
74963>>>>>>>>>>>// pTo
74963>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74963>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74963>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74963>>>>>>>>>>>//   double null-terminated.
74963>>>>>>>>>>>
74963>>>>>>>>>>>// fAnyOperationsAborted
74963>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74963>>>>>>>>>>>//   were completed or FALSE otherwise.
74963>>>>>>>>>>>
74963>>>>>>>>>>>
74963>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74963>>>>>>>>>>>// This can be a file or a folder.
74963>>>>>>>>>>>// With thanks to Andrew S Kaplan
74963>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
74964>>>>>>>>>>>
74964>>>>>>>>>>>
74964>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74964>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74965>>>>>>>>>>>
74965>>>>>>>>>>>
74965>>>>>>>>>>>
74965>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74965>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74965>>>>>>>>>>>//   Pointer lpPathName ;
74965>>>>>>>>>>>//   Pointer lpPrefixString ;
74965>>>>>>>>>>>//   Integer uUnique ;
74965>>>>>>>>>>>//   Pointer lpTempFileName ;
74965>>>>>>>>>>>//   Returns Integer
74965>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74965>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
74966>>>>>>>>>>>
74966>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74967>>>>>>>>>>>
74967>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
74968>>>>>>>>>>>
74968>>>>>>>>>>>// from:
74968>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74968>>>>>>>>>>>//
74968>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74968>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74968>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74968>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74968>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74968>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74968>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74968>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74968>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74968>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74968>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74968>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74968>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74968>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74968>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74968>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74968>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74968>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74968>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74968>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74968>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74968>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74968>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74968>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74968>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74968>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74968>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74968>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74968>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74968>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74968>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74968>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74968>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74968>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74968>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74968>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74968>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74968>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74968>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74968>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74968>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74968>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74968>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74968>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74968>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74968>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74968>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74968>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74968>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74968>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74968>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74968>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74968>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74968>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74968>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74968>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74968>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74968>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74968>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74968>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74968>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74968>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74968>>>>>>>>>>>
74968>>>>>>>>>>>
74968>>>>>>>>>>>//HRESULT SHGetFolderPath(
74968>>>>>>>>>>>//    HWND hwndOwner,
74968>>>>>>>>>>>//    int nFolder,
74968>>>>>>>>>>>//    HANDLE hToken,
74968>>>>>>>>>>>//    DWORD dwFlags,
74968>>>>>>>>>>>//    LPTSTR pszPath
74968>>>>>>>>>>>//);
74968>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74968>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74968>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74968>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74968>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74968>>>>>>>>>>>//
74968>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74969>>>>>>>>>>>
74969>>>>>>>>>>>
74969>>>>>>>>>>>
74969>>>>>>>>>>>Struct tvWin32FindData
74969>>>>>>>>>>> Dword            dwFileAttributes
74969>>>>>>>>>>> Dword            ftCreationLowDateTime
74969>>>>>>>>>>> Dword            ftCreationHighDateTime
74969>>>>>>>>>>> dword            ftLastAccessLowDateTime
74969>>>>>>>>>>> Dword            ftLastAccessHighDateTime
74969>>>>>>>>>>> Dword            ftLastWriteLowDateTime
74969>>>>>>>>>>> Dword            ftLastWriteHighDateTime
74969>>>>>>>>>>> Dword            nFileSizeHigh
74969>>>>>>>>>>> Dword            nFileSizeLow
74969>>>>>>>>>>> Dword            dwReserved0
74969>>>>>>>>>>> Dword            dwReserved1
74969>>>>>>>>>>> Short[vMax_Path] cFileName
74969>>>>>>>>>>> Short[14]        cAlternateFileName
74969>>>>>>>>>>>End_Struct
74969>>>>>>>>>>>
74969>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74969>>>>>>>>>>>// lpFileName      : address of name of file to search for
74969>>>>>>>>>>>// lpFindFileData  : address of returned information
74969>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
74970>>>>>>>>>>>
74970>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74970>>>>>>>>>>>// hFindFile       : handle of search
74970>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74970>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74971>>>>>>>>>>>
74971>>>>>>>>>>>
74971>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74971>>>>>>>>>>>//  hFindFile      : file search handle
74971>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74972>>>>>>>>>>>
74972>>>>>>>>>>>
74972>>>>>>>>>>>
74972>>>>>>>>>>>Struct tvFileTime
74972>>>>>>>>>>>  DWord dwLowDateTime
74972>>>>>>>>>>>  DWord dwHighDateTime
74972>>>>>>>>>>>End_Struct
74972>>>>>>>>>>>
74972>>>>>>>>>>>
74972>>>>>>>>>>>Struct tvSystemTime
74972>>>>>>>>>>>  UShort wYear
74972>>>>>>>>>>>  UShort wMonth
74972>>>>>>>>>>>  UShort wDayOfWeek
74972>>>>>>>>>>>  UShort wDay
74972>>>>>>>>>>>  UShort wHour
74972>>>>>>>>>>>  UShort wMinute
74972>>>>>>>>>>>  UShort wSecond
74972>>>>>>>>>>>  UShort wMilliSeconds
74972>>>>>>>>>>>End_Struct
74972>>>>>>>>>>>
74972>>>>>>>>>>>
74972>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74972>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74972>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74972>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74973>>>>>>>>>>>
74973>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74973>>>>>>>>>>>// This function formats the time in a picture-string passed
74973>>>>>>>>>>>//
74973>>>>>>>>>>>// Picture      Meaning
74973>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74973>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74973>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74973>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74973>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74973>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74973>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74973>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74973>>>>>>>>>>>//    t         One character time marker string, such as A or P
74973>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74973>>>>>>>>>>>//
74973>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74973>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74973>>>>>>>>>>>
74973>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
74974>>>>>>>>>>>
74974>>>>>>>>>>>
74974>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74974>>>>>>>>>>>// This function formats the date in a picture-string passed
74974>>>>>>>>>>>//
74974>>>>>>>>>>>// Picture      Meaning
74974>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
74974>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
74974>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
74974>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
74974>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
74974>>>>>>>>>>>//              value associated with the specified locale.
74974>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
74974>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
74974>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
74974>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
74974>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
74974>>>>>>>>>>>//              associated with the specified locale.
74974>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
74974>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
74974>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
74974>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
74974>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
74974>>>>>>>>>>>//              does not have an associated era or period string.
74974>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
74974>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
74974>>>>>>>>>>>
74974>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
74975>>>>>>>>>>>
74975>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
74975>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
74975>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
74975>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
74975>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
74975>>>>>>>>>>>
74975>>>>>>>>>>>//  Date Flags for GetDateFormatW.
74975>>>>>>>>>>>//
74975>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
74975>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
74975>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
74975>>>>>>>>>>>
74975>>>>>>>>>>>
74975>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
74976>>>>>>>>>>>
74976>>>>>>>>>>>
74976>>>>>>>>>>>// **WvA: 20-02-2004
74976>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
74976>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
74976>>>>>>>>>>>// incorrectly into an unsigned integer.
74976>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
74976>>>>>>>>>>>// It does smell a bit fishy though
74976>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
74976>>>>>>>>>>>
74976>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
74976>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
74976>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
74976>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
74976>>>>>>>>>>>
74976>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
74976>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
74976>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
74976>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
74976>>>>>>>>>>>
74976>>>>>>>>>>>
74976>>>>>>>>>>> // Courtesy Of Steve Walter,
74976>>>>>>>>>>> // USA Software, Inc
74976>>>>>>>>>>> // Format a disk
74976>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
74976>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
74977>>>>>>>>>>>
74977>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
74977>>>>>>>>>>>
74977>>>>>>>>>>>// SHCreateDirectoryEx
74977>>>>>>>>>>>
74977>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
74977>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
74977>>>>>>>>>>>//
74977>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
74977>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
74977>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
74977>>>>>>>>>>>//
74977>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
74977>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
74977>>>>>>>>>>>//        ERROR_CANCELLED.
74977>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
74977>>>>>>>>>>>
74977>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
74977>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
74977>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
74977>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
74977>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
74977>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
74977>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
74977>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
74977>>>>>>>>>>>
74977>>>>>>>>>>>//        int SHCreateDirectoryEx(
74977>>>>>>>>>>>//            HWND hwnd,
74977>>>>>>>>>>>//            LPCTSTR pszPath,
74977>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
74977>>>>>>>>>>>//        );
74977>>>>>>>>>>>
74977>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
74978>>>>>>>>>>>
74978>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
74979>>>>>>>>>
74979>>>>>>>>>
74979>>>>>>>>>
74979>>>>>>>>>// Does the directory exist? - No = false, Yes = True
74979>>>>>>>>>// This also works with UNC path encoding and wildcards
74979>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
74981>>>>>>>>>    Boolean bFolderExists
74981>>>>>>>>>    Boolean bStop
74981>>>>>>>>>    String  sFolder sTmp
74981>>>>>>>>>    Integer iCh
74981>>>>>>>>>
74981>>>>>>>>>    If (sFolderName = "") Begin
74983>>>>>>>>>        Function_Return False
74984>>>>>>>>>    End
74984>>>>>>>>>>
74984>>>>>>>>>
74984>>>>>>>>>    Move True  to bFolderExists
74985>>>>>>>>>    Move False to bStop
74986>>>>>>>>>    Move "dir:" to sFolder
74987>>>>>>>>>    Append sFolder sFolderName
74988>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
74989>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
74991>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
74992>>>>>>>>>>
74992>>>>>>>>>        Function_Return False
74993>>>>>>>>>    End
74993>>>>>>>>>>
74993>>>>>>>>>    Direct_Input channel iCh sFolder
74995>>>>>>>>>    Repeat
74995>>>>>>>>>>
74995>>>>>>>>>        Readln channel iCh sTmp
74997>>>>>>>>>        Move (SeqEof) to bStop
74998>>>>>>>>>        If (Trim(sTmp)="") Begin
75000>>>>>>>>>            Move False to bFolderExists
75001>>>>>>>>>        End
75001>>>>>>>>>>
75001>>>>>>>>>        Else Begin
75002>>>>>>>>>            Move True to bFolderExists
75003>>>>>>>>>            Move True to bStop
75004>>>>>>>>>        End
75004>>>>>>>>>>
75004>>>>>>>>>    Until (bStop)
75006>>>>>>>>>    Close_Input channel iCh
75008>>>>>>>>>    Send Seq_Release_Channel iCh
75009>>>>>>>>>    Function_Return bFolderExists
75010>>>>>>>>>End_Function
75011>>>>>>>>>
75011>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75011>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75013>>>>>>>>>    String  sPath
75013>>>>>>>>>    WString sFolder sTitle
75013>>>>>>>>>    Pointer lpItemIdList
75013>>>>>>>>>    Integer iFolderSelected iRetval
75013>>>>>>>>>    tvBrowseInfo BrowseInfo
75013>>>>>>>>>    tvBrowseInfo BrowseInfo
75013>>>>>>>>>
75013>>>>>>>>>    Move "" to sPath
75014>>>>>>>>>    If (sDialogTitle<>"") Begin
75016>>>>>>>>>        Move sDialogTitle to sTitle
75017>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75017>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75017>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75017>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75017>>>>>>>>>        // selected it will always be valid.
75017>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75018>>>>>>>>>    End
75018>>>>>>>>>>
75018>>>>>>>>>
75018>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75019>>>>>>>>>
75019>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75019>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75019>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75020>>>>>>>>>
75020>>>>>>>>>    // null 128 chars into var (make space)
75020>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75021>>>>>>>>>
75021>>>>>>>>>    // select folder
75021>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75022>>>>>>>>>    // get selected folder name
75022>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75023>>>>>>>>>
75023>>>>>>>>>    // release memory resources that are used by the ItemIdList
75023>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75024>>>>>>>>>
75024>>>>>>>>>    If (iFolderSelected<>0) Begin
75026>>>>>>>>>        Move (CString(sFolder)) to sPath
75027>>>>>>>>>    End
75027>>>>>>>>>>
75027>>>>>>>>>    Function_Return  sPath
75028>>>>>>>>>End_Function
75029>>>>>>>>>
75029>>>>>>>>>// returns 0 if the folder is created.
75029>>>>>>>>>//         1 if the API-call returned an error.
75029>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75031>>>>>>>>>    Integer  iRetval bFolderCreated
75031>>>>>>>>>    WString  sFolder
75031>>>>>>>>>    tvSecurity_attributes SA
75031>>>>>>>>>    tvSecurity_attributes SA
75031>>>>>>>>>
75031>>>>>>>>>    Move False to bFolderCreated
75032>>>>>>>>>    If (sNewFolder <> "") Begin
75034>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75035>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75036>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75037>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75038>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75039>>>>>>>>>    End
75039>>>>>>>>>>
75039>>>>>>>>>
75039>>>>>>>>>    If (bFolderCreated=false) Begin
75041>>>>>>>>>        Move 1 to iRetVal
75042>>>>>>>>>    End
75042>>>>>>>>>>
75042>>>>>>>>>    Function_Return iRetVal
75043>>>>>>>>>End_Function
75044>>>>>>>>>
75044>>>>>>>>>// **WvA: 03-02-2002 Function created.
75044>>>>>>>>>// With this function one can remove a directory.
75044>>>>>>>>>// returns 0 if the folder is removed.
75044>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75044>>>>>>>>>//         2 if the folder did not exist
75044>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75044>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75046>>>>>>>>>    Boolean bRemoved
75046>>>>>>>>>    WString sPath
75046>>>>>>>>>    Integer iRetval
75046>>>>>>>>>
75046>>>>>>>>>    Move 0     to iRetVal
75047>>>>>>>>>    Move False to bRemoved
75048>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75049>>>>>>>>>    If (sFolder="") Begin
75051>>>>>>>>>        Move 3 to iRetVal
75052>>>>>>>>>    End
75052>>>>>>>>>>
75052>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75054>>>>>>>>>        Move 2 to iRetVal
75055>>>>>>>>>    End
75055>>>>>>>>>>
75055>>>>>>>>>    If (iRetVal=0) Begin
75057>>>>>>>>>        // null MAX_PATH chars into var (make space)
75057>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75058>>>>>>>>>        //
75058>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75059>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75060>>>>>>>>>    End
75060>>>>>>>>>>
75060>>>>>>>>>
75060>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75062>>>>>>>>>        Move 1 to iRetVal
75063>>>>>>>>>    End
75063>>>>>>>>>>
75063>>>>>>>>>    Function_Return iRetVal
75064>>>>>>>>>End_Function
75065>>>>>>>>>
75065>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75065>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75065>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75065>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75067>>>>>>>>>    Handle  hInstance hWnd
75067>>>>>>>>>    // remove any leading/trailing spaces in the string
75067>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75068>>>>>>>>>    Move (Trim(sPath))     to sPath
75069>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75069>>>>>>>>>    Append sOperation   (Character(0))
75070>>>>>>>>>    Append sDocument    (Character(0))
75071>>>>>>>>>    Append sParameters  (Character(0))
75072>>>>>>>>>    Append sPath        (Character(0))
75073>>>>>>>>>
75073>>>>>>>>>    Get Window_Handle to hWnd
75074>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75075>>>>>>>>>    If (hInstance <= 32) Begin
75077>>>>>>>>>        Send vDDE_Error_Handler hInstance
75078>>>>>>>>>    End
75078>>>>>>>>>>
75078>>>>>>>>>End_Procedure
75079>>>>>>>>>
75079>>>>>>>>>Class cShellFileOperations is a Array
75080>>>>>>>>>
75080>>>>>>>>>    Procedure Construct_Object
75082>>>>>>>>>        Forward Send Construct_Object
75084>>>>>>>>>        Property Integer piDeleteFlags        0
75085>>>>>>>>>        Property Integer piCopyFlags          0
75086>>>>>>>>>        Property Integer piMoveFlags          0
75087>>>>>>>>>        Property Integer piRenameFlags        0
75088>>>>>>>>>
75088>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75089>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75090>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75091>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75092>>>>>>>>>    End_Procedure
75093>>>>>>>>>
75093>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75093>>>>>>>>>    // files supplied.
75093>>>>>>>>>    //
75093>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75095>>>>>>>>>        Integer  iRetVal
75095>>>>>>>>>        Integer  iUserAbort
75095>>>>>>>>>        WString  wsSource wsDestination
75095>>>>>>>>>        tvShFileOpStruct FOS
75095>>>>>>>>>        tvShFileOpStruct FOS
75095>>>>>>>>>
75095>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75096>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75097>>>>>>>>>
75097>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75099>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75100>>>>>>>>>        End
75100>>>>>>>>>>
75100>>>>>>>>>
75100>>>>>>>>>        Move eOperation            to FOS.wFunc
75101>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75102>>>>>>>>>        Move iFlags                to FOS.fFlags
75103>>>>>>>>>
75103>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75104>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75105>>>>>>>>>        If (iUserAbort <> 0) Begin
75107>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75108>>>>>>>>>        End
75108>>>>>>>>>>
75108>>>>>>>>>        Function_Return (iRetVal)
75109>>>>>>>>>    End_Function
75110>>>>>>>>>
75110>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75112>>>>>>>>>        Integer  iRetVal
75112>>>>>>>>>        Integer  iFlags
75112>>>>>>>>>
75112>>>>>>>>>        Get piDeleteFlags to iFlags
75113>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75114>>>>>>>>>        Function_Return iRetVal
75115>>>>>>>>>    End_Function
75116>>>>>>>>>
75116>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75118>>>>>>>>>        Integer  iRetVal
75118>>>>>>>>>        Integer  iFlags
75118>>>>>>>>>
75118>>>>>>>>>        Get piCopyFlags to iFlags
75119>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75120>>>>>>>>>        Function_Return iRetVal
75121>>>>>>>>>    End_Function
75122>>>>>>>>>
75122>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75124>>>>>>>>>        Integer  iRetVal
75124>>>>>>>>>        Integer  iFlags
75124>>>>>>>>>
75124>>>>>>>>>        Get piMoveFlags to iFlags
75125>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75126>>>>>>>>>        Function_Return iRetVal
75127>>>>>>>>>    End_Function
75128>>>>>>>>>
75128>>>>>>>>>    // Rename a file or folder
75128>>>>>>>>>    // Returns a nonzero value if the operation failed.
75128>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75130>>>>>>>>>        Integer  iRetVal
75130>>>>>>>>>        Integer  iFlags
75130>>>>>>>>>
75130>>>>>>>>>        Get piRenameFlags to iFlags
75131>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75132>>>>>>>>>        Function_Return iRetVal
75133>>>>>>>>>    End_Function
75134>>>>>>>>>
75134>>>>>>>>>
75134>>>>>>>>>    //Example:
75134>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75134>>>>>>>>>    //                                          mode.
75134>>>>>>>>>
75134>>>>>>>>>End_Class
75135>>>>>>>>>
75135>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75137>>>>>>>>>End_Object
75138>>>>>>>>>
75138>>>>>>>>>// Restore to the old way of working with the shell file operations.
75138>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75138>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75138>>>>>>>>>Procedure vWin32fhCompatibilityMode
75140>>>>>>>>>    Integer hoSFO
75140>>>>>>>>>    Integer iFlags
75140>>>>>>>>>
75140>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75141>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75142>>>>>>>>>
75142>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75143>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75144>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75145>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75146>>>>>>>>>End_Procedure
75147>>>>>>>>>
75147>>>>>>>>>// Delete a file or folder
75147>>>>>>>>>// Returns a nonzero value if the operation failed.
75147>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75149>>>>>>>>>    Integer  iRetVal
75149>>>>>>>>>
75149>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75150>>>>>>>>>    Function_Return iRetVal
75151>>>>>>>>>End_Function
75152>>>>>>>>>
75152>>>>>>>>>// Copy a file or folder
75152>>>>>>>>>// Returns a nonzero value if the operation failed.
75152>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75154>>>>>>>>>    Integer  iRetVal
75154>>>>>>>>>
75154>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75155>>>>>>>>>    Function_Return iRetVal
75156>>>>>>>>>End_Function
75157>>>>>>>>>
75157>>>>>>>>>// Move a file or folder
75157>>>>>>>>>// Returns a nonzero value if the operation failed.
75157>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75159>>>>>>>>>    Integer  iRetVal
75159>>>>>>>>>
75159>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75160>>>>>>>>>    Function_Return iRetVal
75161>>>>>>>>>End_Function
75162>>>>>>>>>
75162>>>>>>>>>// Rename a file or folder
75162>>>>>>>>>// Returns a nonzero value if the operation failed.
75162>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75164>>>>>>>>>    Integer  iRetVal
75164>>>>>>>>>
75164>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75165>>>>>>>>>    Function_Return iRetVal
75166>>>>>>>>>End_Function
75167>>>>>>>>>
75167>>>>>>>>>Function vGetWindowsDirectory Returns String
75169>>>>>>>>>    WString wDirectory
75169>>>>>>>>>    Integer iRetVal
75169>>>>>>>>>
75169>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75170>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75171>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75173>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75174>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75175>>>>>>>>>    End
75175>>>>>>>>>>
75175>>>>>>>>>    Function_Return (CString(wDirectory))
75176>>>>>>>>>End_Function
75177>>>>>>>>>
75177>>>>>>>>>Function vGetTempPath Returns String
75179>>>>>>>>>    Integer iRetVal
75179>>>>>>>>>    WString wTempPath
75179>>>>>>>>>
75179>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75180>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75181>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75183>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75184>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75185>>>>>>>>>    End
75185>>>>>>>>>>
75185>>>>>>>>>    Function_Return (CString(wTempPath))
75186>>>>>>>>>End_Function
75187>>>>>>>>>
75187>>>>>>>>>// Courtesy of Marco Kuipers
75187>>>>>>>>>Function vMakeTempFile Returns String
75189>>>>>>>>>    Integer iRetval
75189>>>>>>>>>    String  sTempPath
75189>>>>>>>>>    String  sTempFileName
75189>>>>>>>>>    String  sPrefixString
75189>>>>>>>>>    WString wsTempFileName
75189>>>>>>>>>
75189>>>>>>>>>    Get vGetTempPath to sTempPath
75190>>>>>>>>>    If (sTempPath = "") Begin
75192>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75193>>>>>>>>>        If (sTempPath<>"") Begin
75195>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75196>>>>>>>>>        End
75196>>>>>>>>>>
75196>>>>>>>>>    End
75196>>>>>>>>>>
75196>>>>>>>>>
75196>>>>>>>>>    If (sTempPath = "") Begin
75198>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75198>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75198>>>>>>>>>        Get_Current_Directory to sTempPath
75199>>>>>>>>>    End
75199>>>>>>>>>>
75199>>>>>>>>>
75199>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75200>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75202>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75203>>>>>>>>>>
75203>>>>>>>>>    End
75203>>>>>>>>>>
75203>>>>>>>>>
75203>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75204>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75205>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75206>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75208>>>>>>>>>    //Get ShowLastError to iRetval
75208>>>>>>>>>        Move "" to sTempFileName
75209>>>>>>>>>    End
75209>>>>>>>>>>
75209>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75210>>>>>>>>>    Function_Return sTempFileName
75211>>>>>>>>>End_Function
75212>>>>>>>>>
75212>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75212>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75212>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75212>>>>>>>>>// does not take care of that.
75212>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75214>>>>>>>>>    Integer iRetVal
75214>>>>>>>>>    String  sTempFileName
75214>>>>>>>>>    WString wTempFileName
75214>>>>>>>>>
75214>>>>>>>>>    Move (sPath+Character(0))   to sPath
75215>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75216>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75217>>>>>>>>>
75217>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75218>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75219>>>>>>>>>    Function_Return sTempFileName
75220>>>>>>>>>End_Function
75221>>>>>>>>>
75221>>>>>>>>>//
75221>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75221>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75221>>>>>>>>>//
75221>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75223>>>>>>>>>    Integer iVoid
75223>>>>>>>>>    Handle  hWnd
75223>>>>>>>>>    String  sFolder
75223>>>>>>>>>    WString wFolder
75223>>>>>>>>>
75223>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75224>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75225>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75226>>>>>>>>>    Move (CString(wFolder)) to sFolder
75227>>>>>>>>>    Function_Return sFolder
75228>>>>>>>>>End_Function
75229>>>>>>>>>
75229>>>>>>>>>// Courtesy Of Vincent Oorsprong
75229>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75231>>>>>>>>>    String  sFileDateTime
75231>>>>>>>>>    WString wFormattedTime wFormattedDate
75231>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75231>>>>>>>>>    tvFileTime   FileTime
75231>>>>>>>>>    tvFileTime   FileTime
75231>>>>>>>>>    tvSystemTime SystemTime
75231>>>>>>>>>    tvSystemTime SystemTime
75231>>>>>>>>>
75231>>>>>>>>>    Move "" to sFileDateTime
75232>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75233>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75234>>>>>>>>>
75234>>>>>>>>>    Move 0 to SystemTime.wYear
75235>>>>>>>>>
75235>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75236>>>>>>>>>    If (iSuccess = 1) Begin
75238>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75239>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75240>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75241>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75242>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75243>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75244>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75245>>>>>>>>>    End
75245>>>>>>>>>>
75245>>>>>>>>>    Function_Return sFileDateTime
75246>>>>>>>>>End_Function
75247>>>>>>>>>
75247>>>>>>>>>// **WvA:
75247>>>>>>>>>// A windows replacement for the standard function FileExists.
75247>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75247>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75247>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75247>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75247>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75249>>>>>>>>>    String  sDirSep
75249>>>>>>>>>    Handle  hFindFile
75249>>>>>>>>>    Integer iVoid
75249>>>>>>>>>    tvWin32FindData FindData
75249>>>>>>>>>    tvWin32FindData FindData
75249>>>>>>>>>
75249>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75250>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75251>>>>>>>>>
75251>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75253>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75253>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75254>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75258>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75259>>>>>>>>>        Loop
75260>>>>>>>>>>
75260>>>>>>>>>
75260>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75261>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75262>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75263>>>>>>>>>    End
75263>>>>>>>>>>
75263>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75264>>>>>>>>>End_Function
75265>>>>>>>>>
75265>>>>>>>>>
75265>>>>>>>>>//
75265>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75265>>>>>>>>>// Returns -1 if folder doesn't exist.
75265>>>>>>>>>// The files "." and ".." are not counted.
75265>>>>>>>>>//
75265>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75267>>>>>>>>>    Boolean bFound
75267>>>>>>>>>    Handle  hFindFile
75267>>>>>>>>>    Integer iCount  iVoid
75267>>>>>>>>>    Integer iSuccess
75267>>>>>>>>>    String  sFileName
75267>>>>>>>>>    tvWin32FindData FindData
75267>>>>>>>>>    tvWin32FindData FindData
75267>>>>>>>>>
75267>>>>>>>>>    Move -1 to iCount
75268>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75269>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75270>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75271>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75272>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75273>>>>>>>>>    If (bFound) Begin
75275>>>>>>>>>        Move 0 to iCount
75276>>>>>>>>>    End
75276>>>>>>>>>>
75276>>>>>>>>>    While (bFound)
75280>>>>>>>>>        Increment iCount
75281>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75282>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75284>>>>>>>>>            Decrement iCount
75285>>>>>>>>>        End
75285>>>>>>>>>>
75285>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75286>>>>>>>>>        Move (iSuccess<>0) to bFound
75287>>>>>>>>>    Loop
75288>>>>>>>>>>
75288>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75289>>>>>>>>>    Function_Return iCount
75290>>>>>>>>>End_Function
75291>>>>>>>>>
75291>>>>>>>>>// Create the folder, including intermediate directories.
75291>>>>>>>>>// Don't panic if the folder already exists.
75291>>>>>>>>>// Michael Mullan June 2009.
75291>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75293>>>>>>>>>    String  sFolder
75293>>>>>>>>>    Integer iRetval iFolderCreated
75293>>>>>>>>>    tvSecurity_attributes SA
75293>>>>>>>>>    tvSecurity_attributes SA
75293>>>>>>>>>
75293>>>>>>>>>    Move 0 to iFolderCreated
75294>>>>>>>>>
75294>>>>>>>>>    // null MAX_PATH chars into var (make space)
75294>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75295>>>>>>>>>    If (sNewFolder <> "") Begin
75297>>>>>>>>>
75297>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75298>>>>>>>>>        Move  0  to SA.lpDescriptor
75299>>>>>>>>>        Move  1  to SA.bInheritHandle
75300>>>>>>>>>
75300>>>>>>>>>        //
75300>>>>>>>>>        Move (sNewFolder+"") to sFolder
75301>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75302>>>>>>>>>    End
75302>>>>>>>>>>
75302>>>>>>>>>
75302>>>>>>>>>    If (iFolderCreated <> 0) Begin
75304>>>>>>>>>        Move 1 to iRetVal
75305>>>>>>>>>        Case Begin
75305>>>>>>>>>            Case (iFolderCreated = 161)
75307>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75308>>>>>>>>>>
75308>>>>>>>>>                Case Break
75309>>>>>>>>>            Case (iFolderCreated = 206)
75312>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75313>>>>>>>>>>
75313>>>>>>>>>                Case Break
75314>>>>>>>>>            Case (iFolderCreated = 3)
75317>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75318>>>>>>>>>>
75318>>>>>>>>>                Case Break
75319>>>>>>>>>            Case (iFolderCreated = 80)
75322>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75323>>>>>>>>>                Case Break
75324>>>>>>>>>            Case (iFolderCreated = 183)
75327>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75328>>>>>>>>>                Case Break
75329>>>>>>>>>            Case (iFolderCreated = 1223)
75332>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75333>>>>>>>>>>
75333>>>>>>>>>                Case Break
75334>>>>>>>>>            Case Else
75334>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75335>>>>>>>>>>
75335>>>>>>>>>        Case End
75335>>>>>>>>>    End
75335>>>>>>>>>>
75335>>>>>>>>>    Function_Return iRetVal
75336>>>>>>>>>End_Function
75337>>>>>>>>>
75337>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75339>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75339>>>>>>>>>    Integer iFileSize iVoid
75339>>>>>>>>>    Handle  hFindFile
75339>>>>>>>>>    tvWin32FindData FindData
75339>>>>>>>>>    tvWin32FindData FindData
75339>>>>>>>>>
75339>>>>>>>>>    Move (sFileName+"") to sFileName
75340>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75341>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75342>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75344>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75345>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75346>>>>>>>>>    End
75346>>>>>>>>>>
75346>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75347>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75348>>>>>>>>>
75348>>>>>>>>>    Function_Return iFileSize
75349>>>>>>>>>End_Function
75350>>>>>>>>>
75350>>>>>>>>>//
75350>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75350>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75350>>>>>>>>>//
75350>>>>>>>>>//=============================================================================
75350>>>>>>>>>// Verifies that a path is a valid directory.
75350>>>>>>>>>//
75350>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75350>>>>>>>>>//
75350>>>>>>>>>// Parameters:
75350>>>>>>>>>//      sPath - Address of the path to verify.
75350>>>>>>>>>//=============================================================================
75350>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75352>>>>>>>>>    Integer iResult
75352>>>>>>>>>    Boolean bRetVal
75352>>>>>>>>>
75352>>>>>>>>>    Move false to bRetVal
75353>>>>>>>>>    Move (sPath - Character (0)) to sPath
75354>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75355>>>>>>>>>    If (iResult<>0) Begin
75357>>>>>>>>>        Move True to bRetVal
75358>>>>>>>>>    End
75358>>>>>>>>>>
75358>>>>>>>>>
75358>>>>>>>>>    Function_Return bRetVal
75359>>>>>>>>>End_Function
75360>>>>>>>>>
75360>>>>>>>
75360>>>>>>>//
75360>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75360>>>>>>>// If sStopChar has no occurences in the string an empty string is
75360>>>>>>>// returned.
75360>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75362>>>>>>>    String  sRetVal
75362>>>>>>>    String  sChar
75362>>>>>>>    Integer iLength
75362>>>>>>>    Integer iPos
75362>>>>>>>    Boolean bStopChar
75362>>>>>>>    Move "" to sRetval
75363>>>>>>>    Move (Length(sFrom)) to iLength
75364>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75366>>>>>>>        Move iLength   to iPos
75367>>>>>>>        Move (False)   to bStopChar
75368>>>>>>>        While Not bStopChar
75372>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75373>>>>>>>            Decrement iPos
75374>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75376>>>>>>>                Move (True) to bStopChar
75377>>>>>>>            End
75377>>>>>>>>
75377>>>>>>>            Else Begin
75378>>>>>>>                Move (sChar+sRetVal) to sRetVal
75379>>>>>>>            End
75379>>>>>>>>
75379>>>>>>>        Loop
75380>>>>>>>>
75380>>>>>>>    End
75380>>>>>>>>
75380>>>>>>>    Function_Return sRetVal
75381>>>>>>>End_Function
75382>>>>>>>
75382>>>>>>>// Pre:  sFileName contains the complete path of the file.
75382>>>>>>>// Post: returns the complete path of the file.
75382>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75382>>>>>>>Function ParseFolderName Global String sFileName Returns String
75384>>>>>>>    String sFile
75384>>>>>>>    String sFolderName
75384>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75384>>>>>>>
75384>>>>>>>    Move "" to sFolderName
75385>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75386>>>>>>>    If sDirSep In sFileName Begin
75388>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75389>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75390>>>>>>>    End
75390>>>>>>>>
75390>>>>>>>    Else If ":" In sFileName Begin
75393>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75394>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75395>>>>>>>    End
75395>>>>>>>>
75395>>>>>>>    Function_Return sFolderName
75396>>>>>>>End_Function
75397>>>>>>>
75397>>>>>>>// Pre:  sFileName contains the complete path of the file.
75397>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75397>>>>>>>Function ParseFileName Global String sFileName Returns String
75399>>>>>>>    String sFolderName
75399>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75399>>>>>>>
75399>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75400>>>>>>>    Get ParseFolderName sFileName to sFolderName
75401>>>>>>>    If (sFolderName <> "") Begin
75403>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75404>>>>>>>    End
75404>>>>>>>>
75404>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75405>>>>>>>    Function_Return sFilename
75406>>>>>>>End_Function
75407>>>>>>>
75407>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75407>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75407>>>>>>>//       return "bak" as the extension and not "gif"
75407>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75407>>>>>>>//       such as "html" or "java"
75407>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75409>>>>>>>    String  sFileExtension
75409>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75410>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75411>>>>>>>    Function_Return sFileExtension
75412>>>>>>>End_Function
75413>>>>>>>
75413>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75413>>>>>>>
75413>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75415>>>>>>>    String sMessage
75415>>>>>>>    Case Begin
75415>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75417>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75418>>>>>>>            Case Break
75419>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75422>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75423>>>>>>>            Case Break
75424>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75427>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75428>>>>>>>            Case Break
75429>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75432>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75433>>>>>>>            Case Break
75434>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75437>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75438>>>>>>>            Case Break
75439>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75442>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75443>>>>>>>            Case Break
75444>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75447>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75448>>>>>>>            Case Break
75449>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75452>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75453>>>>>>>            Case Break
75454>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75457>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75458>>>>>>>            Case Break
75459>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75462>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75463>>>>>>>            Case Break
75464>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75467>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75468>>>>>>>            Case Break
75469>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75472>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75473>>>>>>>            Case Break
75474>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75477>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75478>>>>>>>            Case Break
75479>>>>>>>        Case Else
75479>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75480>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75481>>>>>>>            Case Break
75482>>>>>>>    Case End
75482>>>>>>>    Function_Return sMessage
75483>>>>>>>End_Function
75484>>>>>>>
75484>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75486>>>>>>>    String sMessage
75486>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75487>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75488>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75489>>>>>>>End_Procedure
75490>>>>>>>
75490>>>>>>>
75490>>>>>>>// This function informs the user that he entered a yet unknown folder and
75490>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75490>>>>>>>// Choice: "Yes" - this creates the folder
75490>>>>>>>//                 if successful, the function returns false
75490>>>>>>>//                 else it will be true.
75490>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75490>>>>>>>//                 For example: to stop a save
75490>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75490>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75490>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75492>>>>>>>    Integer bIsNotValid
75492>>>>>>>    Integer iUsers_Choice
75492>>>>>>>    String  sMessage
75492>>>>>>>
75492>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75494>>>>>>>        Move "The folder '" to sMessage
75495>>>>>>>        Append sMessage sFolderName
75496>>>>>>>        Append sMessage "' does not yet exist,\n"
75497>>>>>>>        Append sMessage "Do you want to create it now?"
75498>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75499>>>>>>>        Case Begin
75499>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75501>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75502>>>>>>>                If bIsNotValid Begin
75504>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75505>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75507>>>>>>>                    Send Info_Box sMessage "Info"
75508>>>>>>>                End
75508>>>>>>>>
75508>>>>>>>                Case Break
75509>>>>>>>            Case (iUsers_Choice = MBR_No)
75512>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75513>>>>>>>                Case Break
75514>>>>>>>        Case End
75514>>>>>>>    End
75514>>>>>>>>
75514>>>>>>>    Function_Return bIsNotValid
75515>>>>>>>End_Function
75516>>>>>>>
75516>>>>>>>// **WvA
75516>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75516>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75516>>>>>>>// The folder may contain a drive letter or UNC encoding.
75516>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75518>>>>>>>    String sDirSep
75518>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75519>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75520>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75522>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75523>>>>>>>    End
75523>>>>>>>>
75523>>>>>>>    Function_Return sFolderName
75524>>>>>>>End_Function
75525>>>>>>>
75525>>>>>>>//
75525>>>>>>>// Gets the parent path of the currently supplied path
75525>>>>>>>// Returns "" when we are at the root folder.
75525>>>>>>>//
75525>>>>>>>Function vParentPath Global String sPath Returns String
75527>>>>>>>    String sStrip sDirSep
75527>>>>>>>
75527>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75528>>>>>>>    Move (Trim(sPath)) to sPath
75529>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75531>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75532>>>>>>>    End
75532>>>>>>>>
75532>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75534>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75535>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75536>>>>>>>    End
75536>>>>>>>>
75536>>>>>>>    Else Begin
75537>>>>>>>        Move "" to sPath
75538>>>>>>>    End
75538>>>>>>>>
75538>>>>>>>    Function_Return sPath
75539>>>>>>>End_Function
75540>>>>>Use DUFLanguageConstants.inc
75540>>>>>
75540>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75540>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75540>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75540>>>>>
75540>>>>>Struct tDUFIntFile
75540>>>>>    Integer iID
75540>>>>>    String sIntFileName
75540>>>>>    String sIntLineText
75540>>>>>End_Struct
75540>>>>>
75540>>>>>Struct tDbVersionInfo
75540>>>>>    Number nVersionNumber
75540>>>>>    Handle hObject
75540>>>>>End_Struct
75540>>>>>
75540>>>>>Struct tDbUpdateError
75540>>>>>    Number nUpdateVersion
75540>>>>>    Integer iError
75540>>>>>    String  sOrgErrorText
75540>>>>>    String  sErrorText
75540>>>>>    Integer iErrorLine
75540>>>>>    Boolean bError  
75540>>>>>    Handle  hTable 
75540>>>>>    String  sTableRootName
75540>>>>>    Integer iField
75540>>>>>    Boolean bShortFormat
75540>>>>>End_Struct
75540>>>>>
75540>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75540>>>>>//  DF_FILE_IS_MASTER if master
75540>>>>>//  DF_FILE_IS_ALIAS if alias
75540>>>>>Struct tDbUpdateHandlerMasterAlias
75540>>>>>    Handle hTable
75540>>>>>    Integer iMode
75540>>>>>End_Struct
75540>>>>>
75540>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75540>>>>>Enumeration_List
75540>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75540>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75540>>>>>End_Enumeration_List
75540>>>>>
75540>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75540>>>>>
75540>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75540>>>>>// communicate with the object from anywhere in a program.
75540>>>>>    Global_Variable Handle ghoDbUpdateHandler
75540>>>>>    Move 0 to ghoDbUpdateHandler
75541>>>>>
75541>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75541>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75541>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75541>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75541>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75541>>>>>//    Declare_Datafile DbVersion
75541>>>>>//#ENDIF
75541>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75541>>>>>//****************************************************************************
75541>>>>>// $Module type: Class
75541>>>>>// $Module name: cDbUpdateLogFile
75541>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75541>>>>>// Web-site    : http://www.rdctools.com
75541>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75541>>>>>//
75541>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75541>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75541>>>>>//               that this class is to change; each developer can decide if the errors instead
75541>>>>>//               should be saved to a database table, or something entirely different.
75541>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75541>>>>>//
75541>>>>>// $Rev History:
75541>>>>>//    2016-10-05  Module header created
75541>>>>>//****************************************************************************
75541>>>>>Use UI
75541>>>>>Use vWin32fh.pkg
75541>>>>>
75541>>>>>
75541>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75541>>>>>
75541>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75541>>>>>
75541>>>>>Class cDbUpdateLogFile is a cObject
75542>>>>>
75542>>>>>    Procedure Construct_Object
75544>>>>>        Forward Send Construct_Object
75546>>>>>
75546>>>>>        // Error handling:
75546>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75547>>>>>        Property Integer piChannel -1
75548>>>>>
75548>>>>>        // This property is set by the cDbUpdateHandler object,
75548>>>>>        // when the update process starts.
75548>>>>>        Property DateTime pdtUpdateStart
75549>>>>>
75549>>>>>        // Gets set to False if the log contains data
75549>>>>>        Property Boolean pbEmptyLogFile True
75550>>>>>
75550>>>>>        // Gets set to True after the error log header text
75550>>>>>        // has been written.
75550>>>>>        Property Boolean pbHeaderWritten False
75551>>>>>
75551>>>>>        // If all activities should be logged- not just errors.
75551>>>>>        Property Boolean pbVerboseState False
75552>>>>>
75552>>>>>        // File name for the error log where all errors
75552>>>>>        // after a run is written to (appended).
75552>>>>>        // It is saved in the Data folder.
75552>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75553>>>>>        // If this property is set to "" in object code, the
75553>>>>>        // "shell" command parameter will be used to let Windows decide
75553>>>>>        // with which program to open the logfile.
75553>>>>>        Property String psEditorProgram ""
75554>>>>>
75554>>>>>        Property Boolean pbUseDataTableLog False
75555>>>>>
75555>>>>>        // If true an error will be written to file immediately when
75555>>>>>        // it occurs. This can be handy if a large update generates a lots
75555>>>>>        // of errors and the application crasches before finished, thus
75555>>>>>        // the errors will not be written.
75555>>>>>        Property Boolean pbQuickWrite True
75556>>>>>    End_Procedure
75557>>>>>
75557>>>>>    Procedure End_Construct_Object
75559>>>>>        Forward Send End_Construct_Object
75561>>>>>
75561>>>>>    End_Procedure
75562>>>>>
75562>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75564>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75564>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75566>>>>>        Boolean bShortFormat
75566>>>>>        Integer iSize
75566>>>>>        Handle hCurrentTable
75566>>>>>        Integer iCurrentField           
75566>>>>>        String sOrgErrorText sTableRootName
75566>>>>>        
75566>>>>>        Move False to bShortFormat
75567>>>>>        If (num_arguments > 5) Begin
75569>>>>>            Move bShortFormatIn to bShortFormat
75570>>>>>        End
75570>>>>>>
75570>>>>>        // Only do once.
75570>>>>>        If (pbHeaderWritten(Self) = False) Begin
75572>>>>>            Send WriteHeaderData
75573>>>>>            Set pbHeaderWritten to True
75574>>>>>        End
75574>>>>>>
75574>>>>>
75574>>>>>        Get Private.phCurrentTable to hCurrentTable  
75575>>>>>        Get Private.piCurrentField to iCurrentField  
75576>>>>>        If (iError > 0) Begin
75578>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75581>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75582>>>>>        End
75582>>>>>>
75582>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75583>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75584>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75585>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75586>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75587>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75588>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75589>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75590>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75591>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75592>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75593>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75594>>>>>
75594>>>>>        If (bError = False) Begin
75596>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75597>>>>>        End
75597>>>>>>
75597>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75598>>>>>
75598>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75600>>>>>            If (pbQuickWrite(Self) = True) Begin
75602>>>>>                Send OnWriteRow_DataTable
75603>>>>>                // If we are writing error for error flush the
75603>>>>>                // error array when latest error has been written.
75603>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75604>>>>>            End
75604>>>>>>
75604>>>>>            Procedure_Return
75605>>>>>        End
75605>>>>>>
75605>>>>>        Else Begin
75606>>>>>            If (pbQuickWrite(Self) = True) Begin
75608>>>>>                Send WriteErrorLog
75609>>>>>                // Flush the error log array
75609>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75610>>>>>            End
75610>>>>>>
75610>>>>>        End
75610>>>>>>
75610>>>>>    End_Procedure   
75611>>>>>    
75611>>>>>    Function FetchErrorDescription Integer iError Returns String
75613>>>>>        String sErrorText         
75613>>>>>        Move "" to sErrorText
75614>>>>>        If (iError > 0) Begin
75616>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75617>>>>>        End
75617>>>>>>
75617>>>>>        Function_Return sErrorText
75618>>>>>    End_Function
75619>>>>>
75619>>>>>    // Hook procedure for writing header text prior starting the update work to
75619>>>>>    // a database table. This does nothing by default.
75619>>>>>    // Don't forget to Open your "error log table" first (!) as all
75619>>>>>    // tables have been closed at this stage. Put anything
75619>>>>>    // you want to indicate that the update process is just started.
75619>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75621>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75623>>>>>    End_Procedure
75624>>>>>
75624>>>>>    Procedure OnWriteRow_DataTable
75626>>>>>        tDbUpdateError[] DbUpdateErrorArray
75626>>>>>        tDbUpdateError[] DbUpdateErrorArray
75627>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75628>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75630>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75632>>>>>        End
75632>>>>>>
75632>>>>>    End_Procedure
75633>>>>>
75633>>>>>    Function psLogTextFileWithPath Returns String
75635>>>>>        String sPath sFileName sFullFileName
75635>>>>>        
75635>>>>>        Get psDataPathFirstPart to sPath
75636>>>>>        Get psLogTextFile to sFileName
75637>>>>>        Move (sPath + sFileName) to sFullFileName
75638>>>>>        Function_Return sFullFileName
75639>>>>>    End_Function                     
75640>>>>>    
75640>>>>>    Procedure WriteHeaderData
75642>>>>>        String sFileName
75642>>>>>        Integer iCh iSize
75642>>>>>        Boolean bQuickWrite
75642>>>>>        DateTime dtUpdateStart
75642>>>>>
75642>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75643>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75645>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75646>>>>>            Procedure_Return
75647>>>>>        End
75647>>>>>>
75647>>>>>
75647>>>>>        Get piChannel to iCh
75648>>>>>        If (iCh < 0) Begin
75650>>>>>            Get Seq_New_Channel to iCh
75651>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75653>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75654>>>>>>
75654>>>>>                Procedure_Return
75655>>>>>            End
75655>>>>>>
75655>>>>>            Set piChannel to iCh
75656>>>>>        End
75656>>>>>>
75656>>>>>
75656>>>>>        Get psLogTextFileWithPath to sFileName
75657>>>>>        Get vWin32_APIFileSize sFileName to iSize
75658>>>>>        Get pbQuickWrite to bQuickWrite
75659>>>>>        
75659>>>>>        If (bQuickWrite = True) Begin
75661>>>>>            Append_Output channel iCh sFileName
75663>>>>>                If (bQuickWrite = True) Begin
75665>>>>>                    If (iSize = 0) Begin
75667>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75670>>>>>                        Set pbEmptyLogFile to False
75671>>>>>                    End
75671>>>>>>
75671>>>>>                    Writeln channel iCh
75673>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75676>>>>>                End
75676>>>>>>
75676>>>>>            Close_Output channel iCh
75678>>>>>        End
75678>>>>>>
75678>>>>>    End_Procedure
75679>>>>>
75679>>>>>    // Returns the first datapath found in the psDataPath property.
75679>>>>>    // The returned path always ends with a "\"
75679>>>>>    Function psDataPathFirstPart Returns String
75681>>>>>        String sDataPath
75681>>>>>        Integer iCount
75681>>>>>
75681>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75682>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75683>>>>>        If (iCount > 1) Begin
75685>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75686>>>>>        End
75686>>>>>>
75686>>>>>        If (sDataPath <> "") Begin
75688>>>>>            Get vFolderFormat sDataPath to sDataPath
75689>>>>>        End
75689>>>>>>
75689>>>>>
75689>>>>>        Function_Return sDataPath
75690>>>>>    End_Function
75691>>>>>
75691>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75691>>>>>    Procedure WriteErrorLog
75693>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75693>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75694>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75694>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75694>>>>>        Boolean bUseDataTable bQuickWrite
75694>>>>>        DateTime dtUpdateStart dtUpdateEnd
75694>>>>>        TimeSpan tsElapsed
75694>>>>>        Number nVersion                                  
75694>>>>>        Handle hTable
75694>>>>>
75694>>>>>        If (pbHeaderWritten(Self) = False) Begin
75696>>>>>            Send WriteHeaderData
75697>>>>>            Set pbHeaderWritten to True
75698>>>>>        End
75698>>>>>>
75698>>>>>
75698>>>>>        Get pbUseDataTableLog to bUseDataTable
75699>>>>>        If (bUseDataTable = True) Begin
75701>>>>>            Send OnWriteRow_DataTable
75702>>>>>            Procedure_Return
75703>>>>>        End
75703>>>>>>
75703>>>>>
75703>>>>>        Get piChannel to iCh
75704>>>>>        If (iCh < 0) Begin
75706>>>>>            Get Seq_New_Channel to iCh
75707>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75709>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75710>>>>>>
75710>>>>>                Procedure_Return
75711>>>>>            End
75711>>>>>>
75711>>>>>            Set piChannel to iCh
75712>>>>>        End
75712>>>>>>
75712>>>>>
75712>>>>>        Get psLogTextFileWithPath to sFileName
75713>>>>>
75713>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75714>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75715>>>>>        Decrement iSize
75716>>>>>
75716>>>>>        Get pdtUpdateStart to dtUpdateStart
75717>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75719>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75720>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75721>>>>>        End
75721>>>>>>
75721>>>>>        Get pbQuickWrite to bQuickWrite
75722>>>>>
75722>>>>>        Append_Output channel iCh sFileName
75724>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75726>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75729>>>>>        End
75729>>>>>>
75729>>>>>        Else If (bQuickWrite = False) Begin
75732>>>>>            Writeln channel iCh
75734>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75737>>>>>        End   
75737>>>>>>
75737>>>>>        If (iSize >= 0) Begin
75739>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75741>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75744>>>>>            End
75744>>>>>>
75744>>>>>        End
75744>>>>>>
75744>>>>>
75744>>>>>        For iCount from 0 to iSize  
75750>>>>>>
75750>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75751>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75752>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75753>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75754>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75755>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75756>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75757>>>>>            
75757>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75758>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75760>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75761>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75762>>>>>            End
75762>>>>>>
75762>>>>>            Else Begin
75763>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75764>>>>>                Move (sVersion + "   " + sErrorText) to sText
75765>>>>>            End
75765>>>>>>
75765>>>>>            Writeln channel iCh sText
75768>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75770>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75771>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75772>>>>>                Writeln channel iCh sOrgErrorText
75775>>>>>            End
75775>>>>>>
75775>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75777>>>>>                Writeln channel iCh
75779>>>>>            End
75779>>>>>>
75779>>>>>        Loop
75780>>>>>>
75780>>>>>        Close_Output channel iCh
75782>>>>>
75782>>>>>        Send Seq_Release_Channel iCh
75783>>>>>        Set piChannel to -1
75784>>>>>
75784>>>>>    End_Procedure
75785>>>>>
75785>>>>>    // The character to pad is optional. If nothing, spaces are used.
75785>>>>>    // Example:
75785>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75785>>>>>    //  or:
75785>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75785>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75785>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75787>>>>>        String sChar
75787>>>>>
75787>>>>>        If (Num_Arguments >= 3) Begin
75789>>>>>            Move sOptChar to sChar
75790>>>>>        End
75790>>>>>>
75790>>>>>        Else Begin
75791>>>>>            Move " " to sChar
75792>>>>>        End
75792>>>>>>
75792>>>>>
75792>>>>>        While (Length(sString) < iLength)
75796>>>>>            Move (sChar + sString) to sString
75797>>>>>        Loop
75798>>>>>>
75798>>>>>
75798>>>>>        Function_Return sString
75799>>>>>    End_Function
75800>>>>>
75800>>>>>    Procedure ShowErrorLog
75802>>>>>        String sPath sFileName sEditorProgram
75802>>>>>        Boolean bExists
75802>>>>>
75802>>>>>        Get psLogTextFileWithPath to sFileName
75803>>>>>        Get vFilePathExists sFileName to bExists
75804>>>>>        If (bExists = True) Begin
75806>>>>>            Get psEditorProgram to sEditorProgram
75807>>>>>            If (sEditorProgram <> "") Begin
75809>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75810>>>>>            End
75810>>>>>>
75810>>>>>            Else Begin
75811>>>>>                Runprogram Shell Background sFileName
75812>>>>>            End
75812>>>>>>
75812>>>>>        End
75812>>>>>>
75812>>>>>        Else Begin
75813>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75814>>>>>        End
75814>>>>>>
75814>>>>>    End_Procedure
75815>>>>>
75815>>>>>End_Class
75816>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75816>>>>>//****************************************************************************
75816>>>>>// $Module type: Class
75816>>>>>// $Module name: cDbUpdateVersion
75816>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75816>>>>>// Web-site    : http://www.rdctools.com
75816>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75816>>>>>//
75816>>>>>// Description : Child class to cDbUpdateHandler.
75816>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75816>>>>>//               Set the pnVersionNumber to a version number.
75816>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75816>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75816>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75816>>>>>//
75816>>>>>// $Rev History:
75816>>>>>//    2016-09-27  Module header created
75816>>>>>//****************************************************************************
75816>>>>>Use UI
75816>>>>>Use DUFLanguageConstants.inc
75816>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75816>>>>>>>//****************************************************************************
75816>>>>>>>// $Module type: Class
75816>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75816>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75816>>>>>>>// Web-site    : http://www.rdctools.com
75816>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75816>>>>>>>//
75816>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75816>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75816>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75816>>>>>>>//               with the help of Sql-scripts.
75816>>>>>>>//
75816>>>>>>>// $Rev History:
75816>>>>>>>//    2014-09-05  Module header created
75816>>>>>>>//
75816>>>>>>>//****************************************************************************
75816>>>>>>>//
75816>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75816>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75816>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75816>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75816>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75816>>>>>>>//
75816>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75816>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75816>>>>>>>
75816>>>>>>>
75816>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75816>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
75816>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75816>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75816>>>>>>>//
75816>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75816>>>>>>>>>//****************************************************************************
75816>>>>>>>>>// $Module type: Class
75816>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75816>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75816>>>>>>>>>// Web-site    : http://www.rdctools.com
75816>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75816>>>>>>>>>//
75816>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75816>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75816>>>>>>>>>//
75816>>>>>>>>>// $Rev History:
75816>>>>>>>>>//    2023-11-06  Module header created
75816>>>>>>>>>//
75816>>>>>>>>>//****************************************************************************
75816>>>>>>>>>Use cApplication.pkg
75816>>>>>>>>>Use seq_chnl.pkg
75816>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75816>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75816>>>>>>>>>Use Dfcursor.pkg
75816>>>>>>>>>Use DUFStatusPanel.pkg
75816>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75816>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75816>>>>>>>>>>>//
75816>>>>>>>>>>>// We need to create a mixin class for the library.
75816>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75816>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75816>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75816>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75816>>>>>>>>>>>//
75816>>>>>>>>>>>Use VdfBase.pkg
75816>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
75816>>>>>>>>>>>>>Use Unicode.Pkg
75816>>>>>>>>>>>>>
75816>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75817>>>>>>>>>>>>>
75817>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75818>>>>>>>>>>>>>
75818>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75819>>>>>>>>>>>>>
75819>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75820>>>>>>>>>>>>>
75820>>>>>>>>>>>>>
75820>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75820>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75822>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75822>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75822>>>>>>>>>>>>>    String sUUID
75822>>>>>>>>>>>>>    
75822>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75823>>>>>>>>>>>>>    
75823>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75824>>>>>>>>>>>>>    
75824>>>>>>>>>>>>>    If (iRetval = 0) Begin
75826>>>>>>>>>>>>>        Move 0 to pUUIDStr
75827>>>>>>>>>>>>>        
75827>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75828>>>>>>>>>>>>>        If (iRetval = 0) Begin
75830>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75831>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75832>>>>>>>>>>>>>            
75832>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75833>>>>>>>>>>>>>        End
75833>>>>>>>>>>>>>>
75833>>>>>>>>>>>>>    End
75833>>>>>>>>>>>>>>
75833>>>>>>>>>>>>>    
75833>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75834>>>>>>>>>>>>>    
75834>>>>>>>>>>>>>    Function_Return sUUID
75835>>>>>>>>>>>>>End_Function
75836>>>>>>>>>>>>>
75836>>>>>>>>>>>>>
75836>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75836>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75838>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75838>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75838>>>>>>>>>>>>>    String sUUID
75838>>>>>>>>>>>>>    
75838>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75839>>>>>>>>>>>>>    
75839>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75840>>>>>>>>>>>>>    
75840>>>>>>>>>>>>>    If (iRetval = 0) Begin
75842>>>>>>>>>>>>>        Move 0 to pUUIDStr
75843>>>>>>>>>>>>>        
75843>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75844>>>>>>>>>>>>>        If (iRetval = 0) Begin
75846>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75847>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75848>>>>>>>>>>>>>            
75848>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75849>>>>>>>>>>>>>        End
75849>>>>>>>>>>>>>>
75849>>>>>>>>>>>>>    End
75849>>>>>>>>>>>>>>
75849>>>>>>>>>>>>>    
75849>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75850>>>>>>>>>>>>>    
75850>>>>>>>>>>>>>    Function_Return sUUID
75851>>>>>>>>>>>>>End_Function
75852>>>>>>>>>>>Use cli.pkg
75852>>>>>>>>>>>Use sql.pkg
75852>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
75852>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75852>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75852>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>Use Cli.pkg
75852>>>>>>>>>>>>>Use SQL.pkg
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>//   Driver Indentification
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>//   Error number constants
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>// SQL Server spcific types.
75852>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75852>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75852>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75852>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>// SQL Server spcific types.
75852>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75852>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75852>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75852>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75852>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75852>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75852>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75852>>>>>>>>>>>>>//
75852>>>>>>>>>>>>>//     Setup a constraint for a file.
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>
75852>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75853>>>>>>>>>>>>>    
75853>>>>>>>>>>>>>    Procedure Construct_Object
75855>>>>>>>>>>>>>        Forward Send Construct_Object
75857>>>>>>>>>>>>>        
75857>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75858>>>>>>>>>>>>>    End_Procedure
75859>>>>>>>>>>>>>    
75859>>>>>>>>>>>>>    
75859>>>>>>>>>>>>>    
75859>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75859>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75861>>>>>>>>>>>>>        String  sItem
75861>>>>>>>>>>>>>        Integer iStart
75861>>>>>>>>>>>>>        Integer iEnd
75861>>>>>>>>>>>>>        
75861>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75864>>>>>>>>>>>>>        
75864>>>>>>>>>>>>>        Send Delete_Data to hoStore
75865>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75866>>>>>>>>>>>>>        While (iStart > 0)
75870>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75871>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75874>>>>>>>>>>>>>            Else Begin
75875>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75876>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75877>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75880>>>>>>>>>>>>>                
75880>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75883>>>>>>>>>>>>>                
75883>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75886>>>>>>>>>>>>>            End
75886>>>>>>>>>>>>>>
75886>>>>>>>>>>>>>        Loop
75887>>>>>>>>>>>>>>
75887>>>>>>>>>>>>>        
75887>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75888>>>>>>>>>>>>>    End_Procedure
75889>>>>>>>>>>>>>    
75889>>>>>>>>>>>>>    
75889>>>>>>>>>>>>>    
75889>>>>>>>>>>>>>    //   Call the driver's browse connect function
75889>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75891>>>>>>>>>>>>>        String  sDriver
75891>>>>>>>>>>>>>        String  sOutConnStr
75891>>>>>>>>>>>>>        Integer iArg
75891>>>>>>>>>>>>>        Integer iRetval
75891>>>>>>>>>>>>>        
75891>>>>>>>>>>>>>        Get psDriverID to sDriver
75892>>>>>>>>>>>>>        If (sDriver <> "") Begin
75894>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75895>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75900>>>>>>>>>>>>>        End
75900>>>>>>>>>>>>>>
75900>>>>>>>>>>>>>        
75900>>>>>>>>>>>>>        Function_Return sOutConnStr
75901>>>>>>>>>>>>>    End_Function// BrowseConnect
75902>>>>>>>>>>>>>    
75902>>>>>>>>>>>>>    
75902>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75904>>>>>>>>>>>>>        String  sDriver
75904>>>>>>>>>>>>>        String  sOutConnStr
75904>>>>>>>>>>>>>        Integer iArg
75904>>>>>>>>>>>>>        Integer iRetval
75904>>>>>>>>>>>>>        
75904>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75905>>>>>>>>>>>>>        
75905>>>>>>>>>>>>>        Get psDriverID to sDriver
75906>>>>>>>>>>>>>        If (sDriver <> "") Begin
75908>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75909>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75914>>>>>>>>>>>>>        End
75914>>>>>>>>>>>>>>
75914>>>>>>>>>>>>>        
75914>>>>>>>>>>>>>        Function_Return sOutConnStr
75915>>>>>>>>>>>>>    End_Function// BrowseConnect
75916>>>>>>>>>>>>>    
75916>>>>>>>>>>>>>    
75916>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75918>>>>>>>>>>>>>        
75918>>>>>>>>>>>>>        String  sServerList
75918>>>>>>>>>>>>>        Integer iNumServers
75918>>>>>>>>>>>>>        Integer iDriver
75918>>>>>>>>>>>>>        Integer iClientVersion
75918>>>>>>>>>>>>>        String  sDriver
75918>>>>>>>>>>>>>        
75918>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75919>>>>>>>>>>>>>        
75919>>>>>>>>>>>>>        If (iDriver) Begin
75921>>>>>>>>>>>>>            
75921>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75924>>>>>>>>>>>>>            
75924>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75925>>>>>>>>>>>>>            
75925>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75926>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75928>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75929>>>>>>>>>>>>>            End
75929>>>>>>>>>>>>>>
75929>>>>>>>>>>>>>            Else Begin
75930>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75931>>>>>>>>>>>>>            End
75931>>>>>>>>>>>>>>
75931>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75932>>>>>>>>>>>>>        End
75932>>>>>>>>>>>>>>
75932>>>>>>>>>>>>>        
75932>>>>>>>>>>>>>        Function_Return iNumServers
75933>>>>>>>>>>>>>        
75933>>>>>>>>>>>>>    End_Function
75934>>>>>>>>>>>>>    
75934>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75934>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75934>>>>>>>>>>>>>    //   This may take a long time.
75934>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75934>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75936>>>>>>>>>>>>>        
75936>>>>>>>>>>>>>        Integer iNumServers
75936>>>>>>>>>>>>>        Integer iNetworkLocal
75936>>>>>>>>>>>>>        
75936>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75937>>>>>>>>>>>>>        
75937>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75938>>>>>>>>>>>>>        
75938>>>>>>>>>>>>>        Function_Return iNumServers
75939>>>>>>>>>>>>>        
75939>>>>>>>>>>>>>    End_Function
75940>>>>>>>>>>>>>    
75940>>>>>>>>>>>>>    
75940>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75940>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75940>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75940>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75942>>>>>>>>>>>>>        
75942>>>>>>>>>>>>>        Integer iNumServers
75942>>>>>>>>>>>>>        Integer iNetworkLocal
75942>>>>>>>>>>>>>        
75942>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75943>>>>>>>>>>>>>        
75943>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75944>>>>>>>>>>>>>        
75944>>>>>>>>>>>>>        Function_Return iNumServers
75945>>>>>>>>>>>>>        
75945>>>>>>>>>>>>>    End_Function
75946>>>>>>>>>>>>>    
75946>>>>>>>>>>>>>    
75946>>>>>>>>>>>>>    
75946>>>>>>>>>>>>>    //   Enumerate database in a given server.
75946>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75948>>>>>>>>>>>>>        Integer hoSQL
75948>>>>>>>>>>>>>        String  sConnect
75948>>>>>>>>>>>>>        String  sDatabase
75948>>>>>>>>>>>>>        Integer hdbc
75948>>>>>>>>>>>>>        Integer hstmt
75948>>>>>>>>>>>>>        Integer iFetchResult
75948>>>>>>>>>>>>>        
75948>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75951>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75954>>>>>>>>>>>>>        
75954>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75957>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75959>>>>>>>>>>>>>        
75959>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75961>>>>>>>>>>>>>            Move Current_Object to hoSQL
75962>>>>>>>>>>>>>        End_Object
75963>>>>>>>>>>>>>        
75963>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
75965>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75966>>>>>>>>>>>>>            If (hdbc <> 0) Begin
75968>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
75969>>>>>>>>>>>>>                If (hstmt <> 0) Begin
75971>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75971>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75971>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75971>>>>>>>>>>>>>                    //   stay the same.
75971>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75972>>>>>>>>>>>>>                    Send SQLCall to hstmt
75973>>>>>>>>>>>>>                    Repeat
75973>>>>>>>>>>>>>>
75973>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75974>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
75976>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75977>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75978>>>>>>>>>>>>>                        End
75978>>>>>>>>>>>>>>
75978>>>>>>>>>>>>>                    Until (iFetchResult = 0)
75980>>>>>>>>>>>>>                    
75980>>>>>>>>>>>>>                    Send SQLClose to hstmt
75981>>>>>>>>>>>>>                End
75981>>>>>>>>>>>>>>
75981>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
75982>>>>>>>>>>>>>            End
75982>>>>>>>>>>>>>>
75982>>>>>>>>>>>>>        End
75982>>>>>>>>>>>>>>
75982>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
75983>>>>>>>>>>>>>        
75983>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
75984>>>>>>>>>>>>>    End_Function
75985>>>>>>>>>>>>>    
75985>>>>>>>>>>>>>    
75985>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75987>>>>>>>>>>>>>        
75987>>>>>>>>>>>>>        String  sSqlServerClientVersionName
75987>>>>>>>>>>>>>        
75987>>>>>>>>>>>>>        
75987>>>>>>>>>>>>>        Case Begin
75987>>>>>>>>>>>>>
75987>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
75989>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
75990>>>>>>>>>>>>>                Case Break
75991>>>>>>>>>>>>>            
75991>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75994>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75995>>>>>>>>>>>>>                Case Break
75996>>>>>>>>>>>>>                
75996>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75999>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76000>>>>>>>>>>>>>                Case Break
76001>>>>>>>>>>>>>            
76001>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76004>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76005>>>>>>>>>>>>>                Case Break
76006>>>>>>>>>>>>>            
76006>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76009>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76010>>>>>>>>>>>>>                Case Break
76011>>>>>>>>>>>>>            
76011>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76014>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76015>>>>>>>>>>>>>                Case Break
76016>>>>>>>>>>>>>            
76016>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76019>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76020>>>>>>>>>>>>>                Case Break
76021>>>>>>>>>>>>>            
76021>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76024>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76025>>>>>>>>>>>>>                Case Break
76026>>>>>>>>>>>>>            
76026>>>>>>>>>>>>>            Case Else
76026>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76027>>>>>>>>>>>>>                
76027>>>>>>>>>>>>>        Case End
76027>>>>>>>>>>>>>        
76027>>>>>>>>>>>>>        
76027>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76028>>>>>>>>>>>>>        
76028>>>>>>>>>>>>>    End_Function
76029>>>>>>>>>>>>>
76029>>>>>>>>>>>>>
76029>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76031>>>>>>>>>>>>>        
76031>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76031>>>>>>>>>>>>>        
76031>>>>>>>>>>>>>        Case Begin
76031>>>>>>>>>>>>>
76031>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76033>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76034>>>>>>>>>>>>>                Case Break
76035>>>>>>>>>>>>>
76035>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76038>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76039>>>>>>>>>>>>>                Case Break
76040>>>>>>>>>>>>>                
76040>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76043>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76044>>>>>>>>>>>>>                Case Break
76045>>>>>>>>>>>>>            
76045>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76048>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76049>>>>>>>>>>>>>                Case Break
76050>>>>>>>>>>>>>            
76050>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76053>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76054>>>>>>>>>>>>>                Case Break
76055>>>>>>>>>>>>>            
76055>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76058>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76059>>>>>>>>>>>>>                Case Break
76060>>>>>>>>>>>>>            
76060>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76063>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76064>>>>>>>>>>>>>                Case Break
76065>>>>>>>>>>>>>            
76065>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76068>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76069>>>>>>>>>>>>>                Case Break
76070>>>>>>>>>>>>>            
76070>>>>>>>>>>>>>            Case Else
76070>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76071>>>>>>>>>>>>>                
76071>>>>>>>>>>>>>        Case End
76071>>>>>>>>>>>>>        
76071>>>>>>>>>>>>>        
76071>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76072>>>>>>>>>>>>>        
76072>>>>>>>>>>>>>    End_Function
76073>>>>>>>>>>>>>    
76073>>>>>>>>>>>>>    
76073>>>>>>>>>>>>>End_Class
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\db2_drv.pkg)
76074>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76074>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76074>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76074>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>Use Cli.pkg
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// Driver attributes
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// Driver Indentification
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// Error number constants
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// Call driver function identifiers
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// DB2 specific data types
76074>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76074>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76074>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76074>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76074>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76074>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76074>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76074>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// Extra DB2 commands
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76074>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76075>>>>>>>>>>>>>    
76075>>>>>>>>>>>>>    Procedure Construct_Object
76077>>>>>>>>>>>>>        Forward Send Construct_Object
76079>>>>>>>>>>>>>        
76079>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76080>>>>>>>>>>>>>    End_Procedure
76081>>>>>>>>>>>>>    
76081>>>>>>>>>>>>>    
76081>>>>>>>>>>>>>    
76081>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76081>>>>>>>>>>>>>    Procedure SeedDataSources
76083>>>>>>>>>>>>>        String  sDriver
76083>>>>>>>>>>>>>        String  sVoid
76083>>>>>>>>>>>>>        Integer iRetval
76083>>>>>>>>>>>>>        
76083>>>>>>>>>>>>>        Get psDriverID to sDriver
76084>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76091>>>>>>>>>>>>>    End_Procedure
76092>>>>>>>>>>>>>    
76092>>>>>>>>>>>>>    
76092>>>>>>>>>>>>>    
76092>>>>>>>>>>>>>    // Call the driver's data sources function
76092>>>>>>>>>>>>>    Function DataSources Returns String
76094>>>>>>>>>>>>>        String  sDriver
76094>>>>>>>>>>>>>        String  sDataSource
76094>>>>>>>>>>>>>        String  sDescription
76094>>>>>>>>>>>>>        Integer iLength
76094>>>>>>>>>>>>>        Integer iRetval
76094>>>>>>>>>>>>>        
76094>>>>>>>>>>>>>        Get psDriverID to sDriver
76095>>>>>>>>>>>>>        If (sDriver <> "") Begin
76097>>>>>>>>>>>>>            Move 8192 to iLength
76098>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76099>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76100>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76105>>>>>>>>>>>>>        End
76105>>>>>>>>>>>>>>
76105>>>>>>>>>>>>>        
76105>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76108>>>>>>>>>>>>>        Else ;            Function_Return ""
76110>>>>>>>>>>>>>    End_Function
76111>>>>>>>>>>>>>    
76111>>>>>>>>>>>>>End_Class
76112>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\odbc_drv.pkg)
76112>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76112>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76112>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76112>>>>>>>>>>>>>
76112>>>>>>>>>>>>>Use Cli.pkg
76112>>>>>>>>>>>>>
76112>>>>>>>>>>>>>// Driver Indentification
76112>>>>>>>>>>>>>
76112>>>>>>>>>>>>>// Error number constants
76112>>>>>>>>>>>>>
76112>>>>>>>>>>>>>// Call driver function identifiers
76112>>>>>>>>>>>>>
76112>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76113>>>>>>>>>>>>>    
76113>>>>>>>>>>>>>    Procedure Construct_Object
76115>>>>>>>>>>>>>        Forward Send Construct_Object
76117>>>>>>>>>>>>>        
76117>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76118>>>>>>>>>>>>>    End_Procedure
76119>>>>>>>>>>>>>    
76119>>>>>>>>>>>>>    
76119>>>>>>>>>>>>>    
76119>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76119>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76121>>>>>>>>>>>>>        String  sDriver
76121>>>>>>>>>>>>>        String  sVoid
76121>>>>>>>>>>>>>        Integer iRetval
76121>>>>>>>>>>>>>        
76121>>>>>>>>>>>>>        Get psDriverID to sDriver
76122>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76129>>>>>>>>>>>>>    End_Procedure
76130>>>>>>>>>>>>>    
76130>>>>>>>>>>>>>    
76130>>>>>>>>>>>>>    // Call the driver's data sources function
76130>>>>>>>>>>>>>    Function DataSources Returns String
76132>>>>>>>>>>>>>        String  sDriver
76132>>>>>>>>>>>>>        String  sDataSource
76132>>>>>>>>>>>>>        String  sDescription
76132>>>>>>>>>>>>>        Integer iLength
76132>>>>>>>>>>>>>        Integer iRetval
76132>>>>>>>>>>>>>        
76132>>>>>>>>>>>>>        Get psDriverID to sDriver
76133>>>>>>>>>>>>>        If (sDriver <> "") Begin
76135>>>>>>>>>>>>>            Move 8192 to iLength
76136>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76137>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76138>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76143>>>>>>>>>>>>>        End
76143>>>>>>>>>>>>>>
76143>>>>>>>>>>>>>        
76143>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76146>>>>>>>>>>>>>        Else ;            Function_Return ""
76148>>>>>>>>>>>>>    End_Function
76149>>>>>>>>>>>>>    
76149>>>>>>>>>>>>>End_Class
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
76150>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76150>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76150>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76150>>>>>>>>>>>>>Use Ui
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Driver Indentification
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>// Driver attributes
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Call_Driver functions ID's
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to create all vars which may be needed
76150>>>>>>>>>>>>>// in other commands.
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76150>>>>>>>>>>>>>// File must have been opened.
76150>>>>>>>>>>>>>// Filenumber needs to be passed.
76150>>>>>>>>>>>>>// To clear set the owner to "".
76150>>>>>>>>>>>>>// Examples:
76150>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76150>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76150>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76150>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76150>>>>>>>>>>>>>// To clear:
76150>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76150>>>>>>>>>>>>>// options.
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to parse for Callback
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76150>>>>>>>>>>>>>// File must have been opened.
76150>>>>>>>>>>>>>// Filenumber needs to be passed.
76150>>>>>>>>>>>>>// Examples:
76150>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76150>>>>>>>>>>>>>// which will be tries when opening files.
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76150>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76150>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76150>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to change the transaction type.
76150>>>>>>>>>>>>>// Valid types are:
76150>>>>>>>>>>>>>//     DFBTRTT_NONE
76150>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76150>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to get the current transaction type.
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to set explicit_locking
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to get explicit locking
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76150>>>>>>>>>>>>>//
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76150>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76150>>>>>>>>>>>>>
76150>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76151>>>>>>>>>>>>>    
76151>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76153>>>>>>>>>>>>>        Forward Send Construct_object iImage
76155>>>>>>>>>>>>>        
76155>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76156>>>>>>>>>>>>>    End_Procedure
76157>>>>>>>>>>>>>    
76157>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76157>>>>>>>>>>>>>    //
76157>>>>>>>>>>>>>    
76157>>>>>>>>>>>>>    Function CKRevision Returns String
76159>>>>>>>>>>>>>        String  sDriverID
76159>>>>>>>>>>>>>        String  sRevision
76159>>>>>>>>>>>>>        String  sVoid
76159>>>>>>>>>>>>>        Integer iRetval
76159>>>>>>>>>>>>>        
76159>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76159>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76159>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76159>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76160>>>>>>>>>>>>>        Get psDriverID to sDriverID
76161>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76162>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76167>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76168>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76170>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76170>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76171>>>>>>>>>>>>>        End
76171>>>>>>>>>>>>>>
76171>>>>>>>>>>>>>        Function_Return sRevision
76172>>>>>>>>>>>>>    End_Function
76173>>>>>>>>>>>>>    
76173>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76175>>>>>>>>>>>>>        String  sDriverID
76175>>>>>>>>>>>>>        String  sVoid1
76175>>>>>>>>>>>>>        String  sVoid2
76175>>>>>>>>>>>>>        Integer iRetval
76175>>>>>>>>>>>>>        
76175>>>>>>>>>>>>>        Get psDriverID to sDriverID
76176>>>>>>>>>>>>>        
76176>>>>>>>>>>>>>        Move 0 to iRetval
76177>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76177>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76177>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76177>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76178>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76183>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76184>>>>>>>>>>>>>        
76184>>>>>>>>>>>>>        Function_Return iRetval
76185>>>>>>>>>>>>>    End_Function
76186>>>>>>>>>>>>>    
76186>>>>>>>>>>>>>    
76186>>>>>>>>>>>>>    
76186>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76186>>>>>>>>>>>>>    //
76186>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76186>>>>>>>>>>>>>    //
76186>>>>>>>>>>>>>    
76186>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76188>>>>>>>>>>>>>        Integer iPartRev
76188>>>>>>>>>>>>>        Integer iCurrentPart
76188>>>>>>>>>>>>>        Integer iSeparatorPos
76188>>>>>>>>>>>>>        
76188>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76191>>>>>>>>>>>>>        
76191>>>>>>>>>>>>>        Move 0 to iCurrentPart
76192>>>>>>>>>>>>>        Repeat
76192>>>>>>>>>>>>>>
76192>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76193>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76195>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76196>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76197>>>>>>>>>>>>>                Increment iCurrentPart
76198>>>>>>>>>>>>>            End
76198>>>>>>>>>>>>>>
76198>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76201>>>>>>>>>>>>>                Move sRevision to iPartRev
76202>>>>>>>>>>>>>                Move "" to sRevision
76203>>>>>>>>>>>>>                Increment iCurrentPart
76204>>>>>>>>>>>>>            End
76204>>>>>>>>>>>>>>
76204>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76206>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76208>>>>>>>>>>>>>        
76208>>>>>>>>>>>>>        Function_Return iPartRev
76209>>>>>>>>>>>>>    End_Function
76210>>>>>>>>>>>>>    
76210>>>>>>>>>>>>>    
76210>>>>>>>>>>>>>    
76210>>>>>>>>>>>>>    //
76210>>>>>>>>>>>>>    //  Returns the major revision of the CK
76210>>>>>>>>>>>>>    //
76210>>>>>>>>>>>>>    
76210>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76212>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76213>>>>>>>>>>>>>    End_Function
76214>>>>>>>>>>>>>    
76214>>>>>>>>>>>>>    
76214>>>>>>>>>>>>>    
76214>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76214>>>>>>>>>>>>>    //
76214>>>>>>>>>>>>>    
76214>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76216>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76217>>>>>>>>>>>>>    End_Function
76218>>>>>>>>>>>>>    
76218>>>>>>>>>>>>>    
76218>>>>>>>>>>>>>    //  Returns the release revision of the CK
76218>>>>>>>>>>>>>    //
76218>>>>>>>>>>>>>    
76218>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76220>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76221>>>>>>>>>>>>>    End_Function
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    //  Returns the major revision of the CK
76222>>>>>>>>>>>>>    //
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76224>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76225>>>>>>>>>>>>>    End_Function
76226>>>>>>>>>>>>>    
76226>>>>>>>>>>>>>    
76226>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76226>>>>>>>>>>>>>    //
76226>>>>>>>>>>>>>    
76226>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76228>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76231>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76234>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76237>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76240>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76243>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76247>>>>>>>>>>>>>            End
76247>>>>>>>>>>>>>>
76247>>>>>>>>>>>>>        End
76247>>>>>>>>>>>>>>
76247>>>>>>>>>>>>>        
76247>>>>>>>>>>>>>        Function_Return (False)
76248>>>>>>>>>>>>>    End_Function
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76249>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76249>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76249>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76249>>>>>>>>>>>>>    //   in the following format:
76249>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76249>>>>>>>>>>>>>    //   possible values for <type>:
76249>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76249>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76249>>>>>>>>>>>>>    //       C for client cache engine
76249>>>>>>>>>>>>>    //       D for DOS workstation
76249>>>>>>>>>>>>>    //       N for client Requester
76249>>>>>>>>>>>>>    //       S for NetWare server
76249>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76249>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    //   example:
76249>>>>>>>>>>>>>    //       8.50.T
76249>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76249>>>>>>>>>>>>>    //   32-bits Windows server.
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76249>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76249>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    //  Returns the version information of the
76249>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76251>>>>>>>>>>>>>        
76251>>>>>>>>>>>>>        String  sDriverID
76251>>>>>>>>>>>>>        String  sVersion
76251>>>>>>>>>>>>>        String  sVoid
76251>>>>>>>>>>>>>        Integer iRetval
76251>>>>>>>>>>>>>        
76251>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76251>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76251>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76251>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76252>>>>>>>>>>>>>        Get psDriverID to sDriverID
76253>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76254>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76259>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76260>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76262>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76262>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76263>>>>>>>>>>>>>        End
76263>>>>>>>>>>>>>>
76263>>>>>>>>>>>>>        Function_Return sVersion
76264>>>>>>>>>>>>>    End_Function
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76267>>>>>>>>>>>>>        
76267>>>>>>>>>>>>>        String  sDriverID
76267>>>>>>>>>>>>>        String  sVersion
76267>>>>>>>>>>>>>        String  sVoid
76267>>>>>>>>>>>>>        Integer iRetval
76267>>>>>>>>>>>>>        
76267>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76267>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76267>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76267>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76268>>>>>>>>>>>>>        Get psDriverID to sDriverID
76269>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76270>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76275>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76276>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76278>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76278>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76279>>>>>>>>>>>>>        End
76279>>>>>>>>>>>>>>
76279>>>>>>>>>>>>>        Function_Return sVersion
76280>>>>>>>>>>>>>    End_Function
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    //  Returns the version information of the
76281>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76283>>>>>>>>>>>>>        
76283>>>>>>>>>>>>>        String  sDriverID
76283>>>>>>>>>>>>>        String  sVersion
76283>>>>>>>>>>>>>        String  sVoid
76283>>>>>>>>>>>>>        Integer iRetval
76283>>>>>>>>>>>>>        
76283>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76283>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76283>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76283>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76284>>>>>>>>>>>>>        Get psDriverID to sDriverID
76285>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76286>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76291>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76292>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76294>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76294>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76295>>>>>>>>>>>>>        End
76295>>>>>>>>>>>>>>
76295>>>>>>>>>>>>>        Function_Return sVersion
76296>>>>>>>>>>>>>    End_Function
76297>>>>>>>>>>>>>    
76297>>>>>>>>>>>>>End_Class
76298>>>>>>>>>>>>>
76298>>>>>>>>>>>>>
76298>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76298>>>>>>>>>>>>>//****************************************************************************
76298>>>>>>>>>>>>>// $Module type: Include file
76298>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76298>>>>>>>>>>>>>//
76298>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76298>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76298>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76298>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76298>>>>>>>>>>>>>//
76298>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76298>>>>>>>>>>>>>//
76298>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76298>>>>>>>>>>>>>//
76298>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76298>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76298>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76298>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76298>>>>>>>>>>>>>// in the help folder for more details.
76298>>>>>>>>>>>>>//
76298>>>>>>>>>>>>>Use Winkern.pkg
76298>>>>>>>>>>>>>Use cIniFile.pkg
76298>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCryptographerEx.pkg)
76298>>>>>>>>>>>>>>>Use VdfBase.pkg
76298>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 23.0\Pkg\CryptographerConstants.pkg)
76298>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76298>>>>>>>>>>>>>>>>>// Algorithm classes
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76298>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Algorithm types
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76298>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Generic sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// RSA sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// DSS sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// DES sub_ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76298>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76298>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76298>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76298>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76298>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76298>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76298>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76298>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76298>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// RC2 sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76298>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76298>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Hash sub ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76298>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76298>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76298>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76298>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76298>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76298>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// secure channel sub ids
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76298>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76298>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76298>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76298>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76298>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76298>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76298>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76298>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76298>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76298>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76298>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76298>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76298>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76298>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76298>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76298>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76298>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76298>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76298>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76298>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76298>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76298>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76298>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76298>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76298>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76298>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76298>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76298>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76298>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76298>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76298>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76298>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76298>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76298>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76298>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76298>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76298>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76298>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76298>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76298>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76298>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76298>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76298>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76298>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76298>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76298>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76298>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Providers
76298>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76298>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76298>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76298>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76298>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76298>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76298>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76298>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76298>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76298>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76298>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76298>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76298>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76298>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76298>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76298>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76298>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76298>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76298>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76298>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76298>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76298>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76298>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76298>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76298>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Provider types
76298>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76298>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76298>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76298>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76298>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76298>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76298>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76298>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76298>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76298>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76298>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76298>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76298>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76298>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76298>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76298>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76298>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76298>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// KP_MODE
76298>>>>>>>>>>>>>>>>>// KP_MODE
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76298>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76298>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76298>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76298>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76298>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76298>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76298>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76298>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76298>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76298>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76298>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76298>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76298>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76298>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76298>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76298>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76298>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76298>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76298>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76298>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76298>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76298>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76298>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76298>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76298>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76298>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76298>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76298>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76298>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76298>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76298>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76298>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76298>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76298>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76298>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76298>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76298>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76298>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76298>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76298>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76298>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76298>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76298>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76298>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76298>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76298>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76298>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// key BLOB types
76298>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76298>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76298>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76298>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76298>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76298>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76298>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76298>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// KP_PADDING
76298>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76298>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76298>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76298>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76298>>>>>>>>>>>>>>>>>    UChar    bType
76298>>>>>>>>>>>>>>>>>    UChar    bVersion
76298>>>>>>>>>>>>>>>>>    UShort   reserved
76298>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76298>>>>>>>>>>>>>>>>>End_Struct
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76298>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76298>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76298>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76298>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76298>>>>>>>>>>>>>>>>>End_Struct
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76298>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76298>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76298>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76298>>>>>>>>>>>>>>>>>    DWord cbInnerString
76298>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76298>>>>>>>>>>>>>>>>>    DWord cbOuterString
76298>>>>>>>>>>>>>>>>>End_Struct
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76298>>>>>>>>>>>>>>>>>    UChar   bType
76298>>>>>>>>>>>>>>>>>    UChar   bVersion
76298>>>>>>>>>>>>>>>>>    Short   reserved
76298>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76298>>>>>>>>>>>>>>>>>End_Struct
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>Struct CryptoBlob
76298>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76298>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76298>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76298>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76298>>>>>>>>>>>>>>>>>End_Struct
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>
76298>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76298>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76299>>>>>>>>>>>>>>>>>
76299>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76299>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76301>>>>>>>>>>>>>>>>>    
76301>>>>>>>>>>>>>>>>>    Boolean bResult
76301>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76301>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76301>>>>>>>>>>>>>>>>>
76301>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76302>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76303>>>>>>>>>>>>>>>>>    
76303>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76304>>>>>>>>>>>>>>>>>
76304>>>>>>>>>>>>>>>>>    Function_Return bResult
76305>>>>>>>>>>>>>>>>>End_Function
76306>>>>>>>>>>>>>>>>>
76306>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76307>>>>>>>>>>>>>>>>>
76307>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76308>>>>>>>>>>>>>>>>>
76308>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76309>>>>>>>>>>>>>>>>>
76309>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76310>>>>>>>>>>>>>>>>>
76310>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76311>>>>>>>>>>>>>>>>>
76311>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76312>>>>>>>>>>>>>>>>>
76312>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76313>>>>>>>>>>>>>>>>>
76313>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76314>>>>>>>>>>>>>>>>>
76314>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76315>>>>>>>>>>>>>>>>>    
76315>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76316>>>>>>>>>>>>>>>>>
76316>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76317>>>>>>>>>>>>>>>>>
76317>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76318>>>>>>>>>>>>>>>>>
76318>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76319>>>>>>>>>>>>>>>>>    
76319>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76320>>>>>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76321>>>>>>>>>>>>>>>>>    
76321>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76322>>>>>>>>>>>>>>>
76322>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76323>>>>>>>>>>>>>>>    
76323>>>>>>>>>>>>>>>    Procedure Construct_Object
76325>>>>>>>>>>>>>>>        Forward Send Construct_Object
76327>>>>>>>>>>>>>>>        
76327>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76328>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76329>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76330>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76331>>>>>>>>>>>>>>>        
76331>>>>>>>>>>>>>>>        // Private properties
76331>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76332>>>>>>>>>>>>>>>        
76332>>>>>>>>>>>>>>>        // Block cipher properties
76332>>>>>>>>>>>>>>>        Property UChar[]    paKey
76333>>>>>>>>>>>>>>>        Property UChar[]    paIV
76334>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76335>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76336>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76337>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76338>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76339>>>>>>>>>>>>>>>    End_Procedure
76340>>>>>>>>>>>>>>>    
76340>>>>>>>>>>>>>>>    
76340>>>>>>>>>>>>>>>    // Acquire key container handle
76340>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76342>>>>>>>>>>>>>>>        Integer iProvider
76342>>>>>>>>>>>>>>>        WString wProvider
76342>>>>>>>>>>>>>>>        Handle hProv
76342>>>>>>>>>>>>>>>        Boolean bOk
76342>>>>>>>>>>>>>>>        Pointer pProv
76342>>>>>>>>>>>>>>>        
76342>>>>>>>>>>>>>>>        Move 0 to hProv
76343>>>>>>>>>>>>>>>        Get piProvider to iProvider
76344>>>>>>>>>>>>>>>        Get psProvider to wProvider
76345>>>>>>>>>>>>>>>        
76345>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76345>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76347>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76348>>>>>>>>>>>>>>>        End
76348>>>>>>>>>>>>>>>>
76348>>>>>>>>>>>>>>>        Else Begin
76349>>>>>>>>>>>>>>>            Move 0 to pProv
76350>>>>>>>>>>>>>>>        End
76350>>>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>>>        
76350>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76350>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76351>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76353>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76354>>>>>>>>>>>>>>>        End
76354>>>>>>>>>>>>>>>>
76354>>>>>>>>>>>>>>>        
76354>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76356>>>>>>>>>>>>>>>            // Fallback to original
76356>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76357>>>>>>>>>>>>>>>            
76357>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76359>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76360>>>>>>>>>>>>>>>            End
76360>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>        End
76360>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76361>>>>>>>>>>>>>>>        
76361>>>>>>>>>>>>>>>        Function_Return hProv
76362>>>>>>>>>>>>>>>    End_Function
76363>>>>>>>>>>>>>>>    
76363>>>>>>>>>>>>>>>    // Releases key container handle
76363>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76365>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76366>>>>>>>>>>>>>>>    End_Function
76367>>>>>>>>>>>>>>>    
76367>>>>>>>>>>>>>>>    // Creates hash object
76367>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76369>>>>>>>>>>>>>>>        Integer iAlgorithm
76369>>>>>>>>>>>>>>>        Handle hHash
76369>>>>>>>>>>>>>>>        Boolean bOk
76369>>>>>>>>>>>>>>>        
76369>>>>>>>>>>>>>>>        Move 0 to hHash
76370>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76371>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76372>>>>>>>>>>>>>>>        
76372>>>>>>>>>>>>>>>        Function_Return hHash
76373>>>>>>>>>>>>>>>    End_Function
76374>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>    // Destroys the hash object
76374>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76376>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76377>>>>>>>>>>>>>>>    End_Function
76378>>>>>>>>>>>>>>>    
76378>>>>>>>>>>>>>>>    // Adds data to hash object
76378>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76380>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76381>>>>>>>>>>>>>>>    End_Function
76382>>>>>>>>>>>>>>>    
76382>>>>>>>>>>>>>>>    // Generates session key
76382>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76384>>>>>>>>>>>>>>>        Integer iAlgorithm
76384>>>>>>>>>>>>>>>        Handle hKey
76384>>>>>>>>>>>>>>>        Boolean bOk
76384>>>>>>>>>>>>>>>        
76384>>>>>>>>>>>>>>>        Move 0 to hKey
76385>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76386>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76387>>>>>>>>>>>>>>>        
76387>>>>>>>>>>>>>>>        Function_Return hKey
76388>>>>>>>>>>>>>>>    End_Function
76389>>>>>>>>>>>>>>>    
76389>>>>>>>>>>>>>>>    // Imports a plain text key
76389>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76391>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76391>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76391>>>>>>>>>>>>>>>        Boolean   bSuccess
76391>>>>>>>>>>>>>>>        Handle    hKey
76391>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76391>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76392>>>>>>>>>>>>>>>        Integer iVoid
76392>>>>>>>>>>>>>>>        
76392>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76393>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76394>>>>>>>>>>>>>>>        
76394>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76395>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76396>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76397>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76398>>>>>>>>>>>>>>>        
76398>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76399>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76400>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76401>>>>>>>>>>>>>>>        
76401>>>>>>>>>>>>>>>        Move 0 to hKey
76402>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76403>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76405>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76406>>>>>>>>>>>>>>>        End
76406>>>>>>>>>>>>>>>>
76406>>>>>>>>>>>>>>>        
76406>>>>>>>>>>>>>>>        Function_Return hKey
76407>>>>>>>>>>>>>>>    End_Function
76408>>>>>>>>>>>>>>>    
76408>>>>>>>>>>>>>>>    // Destroys the key
76408>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76410>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76411>>>>>>>>>>>>>>>    End_Function
76412>>>>>>>>>>>>>>>    
76412>>>>>>>>>>>>>>>    // Retrieves key data
76412>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76414>>>>>>>>>>>>>>>        Integer iBuffer iLen
76414>>>>>>>>>>>>>>>        Boolean bOk
76414>>>>>>>>>>>>>>>        
76414>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76415>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76416>>>>>>>>>>>>>>>        Function_Return iBuffer
76417>>>>>>>>>>>>>>>    End_Function
76418>>>>>>>>>>>>>>>    
76418>>>>>>>>>>>>>>>    // Retrieves a hash value
76418>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76420>>>>>>>>>>>>>>>        UChar[] ucHash
76421>>>>>>>>>>>>>>>        Integer liResult
76421>>>>>>>>>>>>>>>        DWord   dwDataLen
76421>>>>>>>>>>>>>>>        
76421>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76422>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76423>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76426>>>>>>>>>>>>>>>        
76426>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76427>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76428>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76431>>>>>>>>>>>>>>>        
76431>>>>>>>>>>>>>>>        Function_Return ucHash
76432>>>>>>>>>>>>>>>    End_Function
76433>>>>>>>>>>>>>>>
76433>>>>>>>>>>>>>>>    // Encrypts data
76433>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76435>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76435>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76435>>>>>>>>>>>>>>>        Boolean bOk
76435>>>>>>>>>>>>>>>        
76435>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76436>>>>>>>>>>>>>>>        If (hProv) Begin
76438>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76439>>>>>>>>>>>>>>>            If (hHash) Begin
76441>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76442>>>>>>>>>>>>>>>                If (bOk) Begin
76444>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76445>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76446>>>>>>>>>>>>>>>                End
76446>>>>>>>>>>>>>>>>
76446>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76447>>>>>>>>>>>>>>>            End
76447>>>>>>>>>>>>>>>>
76447>>>>>>>>>>>>>>>            
76447>>>>>>>>>>>>>>>            If (hKey) Begin
76449>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76449>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76450>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76451>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76452>>>>>>>>>>>>>>>                
76452>>>>>>>>>>>>>>>                //  Reserve space in string
76452>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76454>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76455>>>>>>>>>>>>>>>                End
76455>>>>>>>>>>>>>>>>
76455>>>>>>>>>>>>>>>                
76455>>>>>>>>>>>>>>>                //  Call to really decrypt
76455>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76456>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76456>>>>>>>>>>>>>>>                //Move "" to sData
76456>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76456>>>>>>>>>>>>>>>                //End
76456>>>>>>>>>>>>>>>                
76456>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76457>>>>>>>>>>>>>>>            End 
76457>>>>>>>>>>>>>>>>
76457>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76458>>>>>>>>>>>>>>>        End 
76458>>>>>>>>>>>>>>>>
76458>>>>>>>>>>>>>>>        Function_Return ucData
76459>>>>>>>>>>>>>>>    End_Function
76460>>>>>>>>>>>>>>>    
76460>>>>>>>>>>>>>>>    // Decrypts data
76460>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76462>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76462>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76462>>>>>>>>>>>>>>>        Boolean bOk
76462>>>>>>>>>>>>>>>        
76462>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76463>>>>>>>>>>>>>>>        If (hProv) Begin
76465>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76466>>>>>>>>>>>>>>>            If (hHash) Begin
76468>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76469>>>>>>>>>>>>>>>                If (bOk) Begin
76471>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76472>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76473>>>>>>>>>>>>>>>                End
76473>>>>>>>>>>>>>>>>
76473>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76474>>>>>>>>>>>>>>>            End
76474>>>>>>>>>>>>>>>>
76474>>>>>>>>>>>>>>>            
76474>>>>>>>>>>>>>>>            If (hKey) Begin
76476>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76477>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76478>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76478>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76480>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76481>>>>>>>>>>>>>>>                End
76481>>>>>>>>>>>>>>>>
76481>>>>>>>>>>>>>>>                
76481>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76482>>>>>>>>>>>>>>>            End
76482>>>>>>>>>>>>>>>>
76482>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76483>>>>>>>>>>>>>>>        End
76483>>>>>>>>>>>>>>>>
76483>>>>>>>>>>>>>>>        Function_Return ucData
76484>>>>>>>>>>>>>>>    End_Function
76485>>>>>>>>>>>>>>>    
76485>>>>>>>>>>>>>>>    // Creates a key
76485>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76487>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76487>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76487>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76487>>>>>>>>>>>>>>>        Boolean bOk
76487>>>>>>>>>>>>>>>        Handle hKey
76487>>>>>>>>>>>>>>>        UChar[] aKey
76488>>>>>>>>>>>>>>>
76488>>>>>>>>>>>>>>>        Get paKey to aKey
76489>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76490>>>>>>>>>>>>>>>        Get piKeyType to iType
76491>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76492>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76493>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76494>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76495>>>>>>>>>>>>>>>        
76495>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76496>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76502>>>>>>>>>>>>>>>>
76502>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76503>>>>>>>>>>>>>>>        Loop
76504>>>>>>>>>>>>>>>>
76504>>>>>>>>>>>>>>>        
76504>>>>>>>>>>>>>>>        Move 0 to hKey
76505>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76506>>>>>>>>>>>>>>>        Function_Return hKey
76507>>>>>>>>>>>>>>>    End_Function
76508>>>>>>>>>>>>>>>    
76508>>>>>>>>>>>>>>>    // Sets the key parameters
76508>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76510>>>>>>>>>>>>>>>        Integer iPadding iMode
76510>>>>>>>>>>>>>>>        Boolean bOk
76510>>>>>>>>>>>>>>>        UChar[] aIV
76511>>>>>>>>>>>>>>>        
76511>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76511>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76511>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76511>>>>>>>>>>>>>>>        //Loop
76511>>>>>>>>>>>>>>>
76511>>>>>>>>>>>>>>>        // Set initialization vector
76511>>>>>>>>>>>>>>>        Get paIV to aIV
76512>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76513>>>>>>>>>>>>>>>        If (bOk) Begin
76515>>>>>>>>>>>>>>>            // Set padding
76515>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76516>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76517>>>>>>>>>>>>>>>            If (bOk) Begin
76519>>>>>>>>>>>>>>>                // Set move
76519>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76520>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76521>>>>>>>>>>>>>>>            End
76521>>>>>>>>>>>>>>>>
76521>>>>>>>>>>>>>>>        End
76521>>>>>>>>>>>>>>>>
76521>>>>>>>>>>>>>>>        Function_Return bOk        
76522>>>>>>>>>>>>>>>    End_Function
76523>>>>>>>>>>>>>>>    
76523>>>>>>>>>>>>>>>    // Encrypts using block cipher
76523>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76525>>>>>>>>>>>>>>>        Handle hProv hKey
76525>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76525>>>>>>>>>>>>>>>        Boolean bOk
76525>>>>>>>>>>>>>>>        
76525>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76526>>>>>>>>>>>>>>>        If (hProv) Begin
76528>>>>>>>>>>>>>>>            // Create key
76528>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76529>>>>>>>>>>>>>>>            If (hKey) Begin
76531>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76532>>>>>>>>>>>>>>>                If (bOk) Begin
76534>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76534>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76535>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76536>>>>>>>>>>>>>>>                    
76536>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76537>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76538>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76539>>>>>>>>>>>>>>>                End
76539>>>>>>>>>>>>>>>>
76539>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76540>>>>>>>>>>>>>>>            End
76540>>>>>>>>>>>>>>>>
76540>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76541>>>>>>>>>>>>>>>        End
76541>>>>>>>>>>>>>>>>
76541>>>>>>>>>>>>>>>        Function_Return ucData
76542>>>>>>>>>>>>>>>    End_Function
76543>>>>>>>>>>>>>>>    
76543>>>>>>>>>>>>>>>    // Decrypts using block cipher
76543>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76545>>>>>>>>>>>>>>>        Handle hProv hKey
76545>>>>>>>>>>>>>>>        Integer iLen
76545>>>>>>>>>>>>>>>        Boolean bOk
76545>>>>>>>>>>>>>>>        
76545>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76546>>>>>>>>>>>>>>>        If (hProv) Begin
76548>>>>>>>>>>>>>>>            // Create key
76548>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76549>>>>>>>>>>>>>>>            If (hKey) Begin
76551>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76552>>>>>>>>>>>>>>>                If (bOk) Begin
76554>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76555>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76556>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76557>>>>>>>>>>>>>>>                End
76557>>>>>>>>>>>>>>>>
76557>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76558>>>>>>>>>>>>>>>            End
76558>>>>>>>>>>>>>>>>
76558>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76559>>>>>>>>>>>>>>>        End
76559>>>>>>>>>>>>>>>>
76559>>>>>>>>>>>>>>>        Function_Return ucData
76560>>>>>>>>>>>>>>>    End_Function
76561>>>>>>>>>>>>>>>    
76561>>>>>>>>>>>>>>>    
76561>>>>>>>>>>>>>>>    //  Generates random data.
76561>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76563>>>>>>>>>>>>>>>        Handle hProv
76563>>>>>>>>>>>>>>>        UChar[] uaResult
76564>>>>>>>>>>>>>>>        Boolean bRes
76564>>>>>>>>>>>>>>>        
76564>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76565>>>>>>>>>>>>>>>        
76565>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76566>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76567>>>>>>>>>>>>>>>        
76567>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76568>>>>>>>>>>>>>>>        
76568>>>>>>>>>>>>>>>        Function_Return uaResult
76569>>>>>>>>>>>>>>>    End_Function
76570>>>>>>>>>>>>>>>    
76570>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76570>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76572>>>>>>>>>>>>>>>        String sResult
76572>>>>>>>>>>>>>>>        UChar[] ucData
76573>>>>>>>>>>>>>>>        Pointer pBase64
76573>>>>>>>>>>>>>>>        Integer iVoid
76573>>>>>>>>>>>>>>>        
76573>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76574>>>>>>>>>>>>>>>        
76574>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76575>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76576>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76577>>>>>>>>>>>>>>>        
76577>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76578>>>>>>>>>>>>>>>    End_Function
76579>>>>>>>>>>>>>>>    
76579>>>>>>>>>>>>>>>End_Class
76580>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76580>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76580>>>>>>>>>>>>>>>//>
76580>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76580>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76580>>>>>>>>>>>>>>>//>
76580>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76580>>>>>>>>>>>>>>>//> strings.
76580>>>>>>>>>>>>>>>//>
76580>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76580>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76580>>>>>>>>>>>>>>>//>
76580>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76580>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76580>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76580>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76580>>>>>>>>>>>>>>>
76580>>>>>>>>>>>>>>>Use VdfBase.pkg
76580>>>>>>>>>>>>>>>
76580>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76580>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76581>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76582>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76583>>>>>>>>>>>>>>>
76583>>>>>>>>>>>>>>>// Structure
76583>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76583>>>>>>>>>>>>>>>    Pointer pData
76583>>>>>>>>>>>>>>>    Integer iLength
76583>>>>>>>>>>>>>>>End_Struct 
76583>>>>>>>>>>>>>>>
76583>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76583>>>>>>>>>>>>>>>
76583>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76585>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76586>>>>>>>>>>>>>>>
76586>>>>>>>>>>>>>>>
76586>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76589>>>>>>>>>>>>>>>        Address pBase64
76589>>>>>>>>>>>>>>>        String sResult
76589>>>>>>>>>>>>>>>        Integer iVoid
76589>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76590>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76591>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76592>>>>>>>>>>>>>>>        Function_Return sResult
76593>>>>>>>>>>>>>>>    End_Function
76594>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76597>>>>>>>>>>>>>>>        Address pBinary
76597>>>>>>>>>>>>>>>        String sBinary
76597>>>>>>>>>>>>>>>        Integer iVoid iLen
76597>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76598>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76599>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76600>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76601>>>>>>>>>>>>>>>        Function_Return sBinary
76602>>>>>>>>>>>>>>>    End_Function
76603>>>>>>>>>>>>>>>
76603>>>>>>>>>>>>>>>End_Object
76604>>>>>>>>>>>>>Use MSSqldrv.pkg
76604>>>>>>>>>>>>>Use db2_drv.pkg
76604>>>>>>>>>>>>>Use odbc_drv.pkg
76604>>>>>>>>>>>>>Use DFBtrDrv.pkg
76604>>>>>>>>>>>>>Use vWin32fh.pkg
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76604>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76604>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76604>>>>>>>>>>>>>// Note: If a new type is added to the list,
76604>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76604>>>>>>>>>>>>>//       so that it is filled with all SQL
76604>>>>>>>>>>>>>//       keywords for that new type.
76604>>>>>>>>>>>>>Enum_List  
76604>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76604>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76604>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76604>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76604>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76604>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76604>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76604>>>>>>>>>>>>>End_Enum_List
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76604>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76604>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76604>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76604>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76604>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76604>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76604>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76604>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76604>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// SQLConnection.ini constants:
76604>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76604>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76604>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76604>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// DF 19 ini-file settings:
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76604>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76604>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76604>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76604>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76604>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76604>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76604>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76604>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76604>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76604>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// Database Update Framework extended settings:
76604>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76604>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76604>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76604>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76604>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76604>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76604>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76604>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>Struct tSQLConnection
76604>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76604>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76604>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76604>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76604>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76604>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76604>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76604>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76604>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76604>>>>>>>>>>>>>    String sPassword                // 10. Password
76604>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76604>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76604>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76604>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76604>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76604>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76604>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76604>>>>>>>>>>>>>End_Struct
76604>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76604>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76604>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76604>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76604>>>>>>>>>>>>>
76604>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76604>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSQLScriptArray
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76605>>>>>>>>>>>>>    Integer iOrgArgumentSize
76605>>>>>>>>>>>>>    String[] sSQLScriptArray
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSqlErrorArray
76605>>>>>>>>>>>>>    String[]  sSqlErrorArray
76605>>>>>>>>>>>>>    String[]  sSqlStatementArray
76605>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSqlColumnNew
76605>>>>>>>>>>>>>    String  sBaseColumnName
76605>>>>>>>>>>>>>    String  sBaseTableName
76605>>>>>>>>>>>>>    String  sLabel
76605>>>>>>>>>>>>>    Integer iSqlType
76605>>>>>>>>>>>>>    Integer iSize
76605>>>>>>>>>>>>>    Integer iPrecision
76605>>>>>>>>>>>>>    Integer iDFType
76605>>>>>>>>>>>>>    Integer iDFNativeType
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tColumnType
76605>>>>>>>>>>>>>    String  sSQLType
76605>>>>>>>>>>>>>    Integer iSQLType
76605>>>>>>>>>>>>>    Boolean bCanEditSize
76605>>>>>>>>>>>>>    Integer iDefaultSize
76605>>>>>>>>>>>>>    Integer iMinSize
76605>>>>>>>>>>>>>    Number  nMaxSize
76605>>>>>>>>>>>>>    String  sDataFlexType
76605>>>>>>>>>>>>>    Integer iDataFlexType
76605>>>>>>>>>>>>>    Boolean bNativeDataType
76605>>>>>>>>>>>>>    String  sPrecision
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76605>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76605>>>>>>>>>>>>>// keywords.
76605>>>>>>>>>>>>>Struct tSQLKeyWords
76605>>>>>>>>>>>>>    Integer iSQLWord
76605>>>>>>>>>>>>>    Integer iSQLDbType
76605>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSQLRelation
76605>>>>>>>>>>>>>    Integer iFileNumber
76605>>>>>>>>>>>>>    Integer iFieldNumber
76605>>>>>>>>>>>>>    String  sFileName
76605>>>>>>>>>>>>>    String  sFieldName
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSQLLoggedInUser
76605>>>>>>>>>>>>>    String sUser
76605>>>>>>>>>>>>>    String sProgram
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76605>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76605>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76605>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76605>>>>>>>>>>>>>// Note: If a new type is added to the list,
76605>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76605>>>>>>>>>>>>>//       so that it is filled with all SQL
76605>>>>>>>>>>>>>//       keywords for that new type.
76605>>>>>>>>>>>>>Enum_List
76605>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76605>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76605>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76605>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76605>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76605>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76605>>>>>>>>>>>>>End_Enum_List
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76605>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76605>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76605>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76605>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76605>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76605>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76605>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76605>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76605>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76605>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76605>>>>>>>>>>>>>Enum_List
76605>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76605>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76605>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76605>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76605>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76605>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76605>>>>>>>>>>>>>End_Enum_List
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76605>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76605>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// These are not defined pre DF 18:
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSQLIntTableInfo
76605>>>>>>>>>>>>>    String sDriverName
76605>>>>>>>>>>>>>    String sServerName
76605>>>>>>>>>>>>>    String sDatabaseName
76605>>>>>>>>>>>>>    String sSchemaName
76605>>>>>>>>>>>>>    Boolean bRecnumTable
76605>>>>>>>>>>>>>    Integer iPrimaryIndex
76605>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76605>>>>>>>>>>>>>    String sTableCharacterFormat
76605>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76605>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76605>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76605>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76605>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76605>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76605>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76605>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76605>>>>>>>>>>>>>    String sFileIndexTablespace
76605>>>>>>>>>>>>>    String sFileLongTablespace
76605>>>>>>>>>>>>>    String sTableTablespace
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76605>>>>>>>>>>>>>    Integer iFieldNumber
76605>>>>>>>>>>>>>    Integer iFieldIndex
76605>>>>>>>>>>>>>    Integer iFieldRelatedFile
76605>>>>>>>>>>>>>    Integer iFieldRelatedField
76605>>>>>>>>>>>>>    Integer iIndexNumber
76605>>>>>>>>>>>>>    Integer iIndexNumberSegments
76605>>>>>>>>>>>>>    Integer iIndexSegmentField1
76605>>>>>>>>>>>>>    Integer iIndexSegmentField2
76605>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76605>>>>>>>>>>>>>    String  sIndexName
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIColumn
76605>>>>>>>>>>>>>    Integer iFieldNumber
76605>>>>>>>>>>>>>    String  sFieldName
76605>>>>>>>>>>>>>    Integer iType
76605>>>>>>>>>>>>>    String  sType
76605>>>>>>>>>>>>>    Integer iLength
76605>>>>>>>>>>>>>    Integer iPrecision
76605>>>>>>>>>>>>>    Integer iOptions
76605>>>>>>>>>>>>>    Boolean bIsSQLType
76605>>>>>>>>>>>>>    Boolean bAllowNULL
76605>>>>>>>>>>>>>    String  sDefaultValue
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIColumnCompare
76605>>>>>>>>>>>>>    Integer iFieldNumber
76605>>>>>>>>>>>>>    // FROM database:
76605>>>>>>>>>>>>>    Boolean bExistsFrom
76605>>>>>>>>>>>>>    String  sFieldNameFrom
76605>>>>>>>>>>>>>    Integer iTypeFrom
76605>>>>>>>>>>>>>    String  sTypeFrom
76605>>>>>>>>>>>>>    Integer iLengthFrom
76605>>>>>>>>>>>>>    Integer iPrecisionFrom
76605>>>>>>>>>>>>>    Integer iOptionsFrom
76605>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76605>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76605>>>>>>>>>>>>>    String  sDefaultValueFrom
76605>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76605>>>>>>>>>>>>>    Boolean bCancelFrom
76605>>>>>>>>>>>>>    Boolean bErrorFrom
76605>>>>>>>>>>>>>    // TO database:
76605>>>>>>>>>>>>>    Boolean bExistsTo
76605>>>>>>>>>>>>>    Integer iFieldNumberTo
76605>>>>>>>>>>>>>    String  sFieldNameTo
76605>>>>>>>>>>>>>    Integer iTypeTo
76605>>>>>>>>>>>>>    String  sTypeTo
76605>>>>>>>>>>>>>    Integer iLengthTo
76605>>>>>>>>>>>>>    Integer iPrecisionTo
76605>>>>>>>>>>>>>    Integer iOptionsTo
76605>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76605>>>>>>>>>>>>>    Boolean bAllowNULLTo
76605>>>>>>>>>>>>>    String  sDefaultValueTo
76605>>>>>>>>>>>>>    Boolean bShouldChangeTo
76605>>>>>>>>>>>>>    Boolean bCancelTo
76605>>>>>>>>>>>>>    Boolean bErrorTo
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIRelation
76605>>>>>>>>>>>>>    Handle  hTableFrom
76605>>>>>>>>>>>>>    Integer iColumnFrom
76605>>>>>>>>>>>>>    Handle  hTableTo
76605>>>>>>>>>>>>>    Integer iColumnTo
76605>>>>>>>>>>>>>    String  sLogicalNameFrom
76605>>>>>>>>>>>>>    String  sLogicalNameTo
76605>>>>>>>>>>>>>    String  sFieldNameFrom
76605>>>>>>>>>>>>>    String  sFieldNameTo
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIRelationCompare
76605>>>>>>>>>>>>>    // Common:
76605>>>>>>>>>>>>>    Handle  hTableFrom
76605>>>>>>>>>>>>>    Integer iColumnFrom
76605>>>>>>>>>>>>>    Handle  hTableTo
76605>>>>>>>>>>>>>    Integer iColumnTo
76605>>>>>>>>>>>>>    // FROM database:
76605>>>>>>>>>>>>>    Boolean bExistsFrom
76605>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76605>>>>>>>>>>>>>    String  sLogicalNameTo_From
76605>>>>>>>>>>>>>    String  sFieldNameFrom_From
76605>>>>>>>>>>>>>    String  sFieldNameTo_From
76605>>>>>>>>>>>>>    Boolean bShouldChange_From
76605>>>>>>>>>>>>>    Boolean bCancel_From
76605>>>>>>>>>>>>>    Boolean bError_From
76605>>>>>>>>>>>>>    // TO database:
76605>>>>>>>>>>>>>    Boolean bExistsTo
76605>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76605>>>>>>>>>>>>>    String  sLogicalNameTo_To
76605>>>>>>>>>>>>>    String  sFieldNameFrom_To
76605>>>>>>>>>>>>>    String  sFieldNameTo_To
76605>>>>>>>>>>>>>    Boolean bShouldChange_To
76605>>>>>>>>>>>>>    Boolean bCancel_To
76605>>>>>>>>>>>>>    Boolean bError_To
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIIndexSegment
76605>>>>>>>>>>>>>    Integer iFieldNumber
76605>>>>>>>>>>>>>    String  sFieldName
76605>>>>>>>>>>>>>    Boolean bUppercase
76605>>>>>>>>>>>>>    Boolean bAscending
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIIndex
76605>>>>>>>>>>>>>    Integer iIndexNumber
76605>>>>>>>>>>>>>    Integer iPrimaryIndex
76605>>>>>>>>>>>>>    String  sSQLIndexName
76605>>>>>>>>>>>>>    Integer iSQLIndexType
76605>>>>>>>>>>>>>    Boolean bIsSQLClustered
76605>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPIIndexCompare
76605>>>>>>>>>>>>>    // Common:
76605>>>>>>>>>>>>>    Integer iIndexNumber
76605>>>>>>>>>>>>>    // FROM database:
76605>>>>>>>>>>>>>    Boolean bExistsFrom
76605>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76605>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76605>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76605>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76605>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76605>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76605>>>>>>>>>>>>>    Boolean bCancelFrom
76605>>>>>>>>>>>>>    Boolean bErrorFrom
76605>>>>>>>>>>>>>    // TO database:
76605>>>>>>>>>>>>>    Boolean bExistsTo
76605>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76605>>>>>>>>>>>>>    String  sSQLIndexNameTo
76605>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76605>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76605>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76605>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76605>>>>>>>>>>>>>    Boolean bShouldChangeTo
76605>>>>>>>>>>>>>    Boolean bCancelTo
76605>>>>>>>>>>>>>    Boolean bErrorTo
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPITableNameInfo
76605>>>>>>>>>>>>>    Integer iTableNumber
76605>>>>>>>>>>>>>    String  sRootName
76605>>>>>>>>>>>>>    String  sLogicalName
76605>>>>>>>>>>>>>    String  sDisplayName
76605>>>>>>>>>>>>>    String  sDriverID
76605>>>>>>>>>>>>>    Boolean bIsAlias
76605>>>>>>>>>>>>>    Boolean bIsSQL
76605>>>>>>>>>>>>>    Boolean bIsSystemFile
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76605>>>>>>>>>>>>>    Integer iTableNumber
76605>>>>>>>>>>>>>    // FROM
76605>>>>>>>>>>>>>    Boolean bExistsFrom
76605>>>>>>>>>>>>>    String  sRootNameFrom
76605>>>>>>>>>>>>>    String  sLogicalNameFrom
76605>>>>>>>>>>>>>    String  sDisplayNameFrom
76605>>>>>>>>>>>>>    String  sDriverIDFrom
76605>>>>>>>>>>>>>    Boolean bIsAliasFrom
76605>>>>>>>>>>>>>    Boolean bIsSQLFrom
76605>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76605>>>>>>>>>>>>>    // TO database:
76605>>>>>>>>>>>>>    Boolean bExistsTo
76605>>>>>>>>>>>>>    String  sRootNameTo
76605>>>>>>>>>>>>>    String  sLogicalNameTo
76605>>>>>>>>>>>>>    String  sDisplayNameTo
76605>>>>>>>>>>>>>    String  sDriverIDTo
76605>>>>>>>>>>>>>    Boolean bIsAliasTo
76605>>>>>>>>>>>>>    Boolean bIsSQLTo
76605>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPITable
76605>>>>>>>>>>>>>    Handle hTable
76605>>>>>>>>>>>>>    Boolean bFromTable
76605>>>>>>>>>>>>>    Boolean bToTable
76605>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76605>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76605>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76605>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76605>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76605>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76605>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76605>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76605>>>>>>>>>>>>>    Boolean bShouldChange
76605>>>>>>>>>>>>>    Boolean bCancel
76605>>>>>>>>>>>>>    Boolean bError
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPITableCompare
76605>>>>>>>>>>>>>    Handle hTable
76605>>>>>>>>>>>>>    // FROM database:
76605>>>>>>>>>>>>>    Boolean bExistsFrom
76605>>>>>>>>>>>>>    // TO database:
76605>>>>>>>>>>>>>    Boolean bExistsTo
76605>>>>>>>>>>>>>    // Both:
76605>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76605>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76605>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76605>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76605>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76605>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76605>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76605>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76605>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76605>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76605>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Struct tAPITableBooleans
76605>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76605>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76605>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76605>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76605>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76605>>>>>>>>>>>>>End_Struct
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76605>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76605>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76605>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76605>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76605>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76605>>>>>>>>>>>>>Enum_List
76605>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76605>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76605>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76605>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76605>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76605>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76605>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76605>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76605>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76605>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76605>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76605>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76605>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76605>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76605>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76605>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76605>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76605>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76605>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76605>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76605>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76605>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76605>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76605>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76605>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76605>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76605>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76605>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76605>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76605>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76605>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76605>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76605>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76605>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76605>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76605>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76605>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76605>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76605>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76605>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76605>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76605>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76605>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76605>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76605>>>>>>>>>>>>>End_Enum_List
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>>>
76605>>>>>>>>>>>
76605>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76606>>>>>>>>>>>
76606>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76608>>>>>>>>>>>        Handle hoSQLManagerMT
76608>>>>>>>>>>>
76608>>>>>>>>>>>        Property String private.psUseDatabase ""
76609>>>>>>>>>>>
76609>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76609>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76610>>>>>>>>>>>        Property Integer private.piCurrentField 0
76611>>>>>>>>>>>
76611>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76612>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76613>>>>>>>>>>>
76613>>>>>>>>>>>        Property Handle phoSQLManagerMT
76614>>>>>>>>>>>
76614>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76615>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76616>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76617>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76618>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76619>>>>>>>>>>>
76619>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76620>>>>>>>>>>>
76620>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76621>>>>>>>>>>>        Property String[] paSQLFetchResults
76622>>>>>>>>>>>
76622>>>>>>>>>>>        // Error handling
76622>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76623>>>>>>>>>>>        Property Boolean pbSqlError False
76624>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76625>>>>>>>>>>>        Property Boolean pbProcessingError False
76626>>>>>>>>>>>
76626>>>>>>>>>>>        // Statistics on query
76626>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76627>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76628>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76629>>>>>>>>>>>        Property Integer piColumns 0
76630>>>>>>>>>>>        Property Integer piRows 0
76631>>>>>>>>>>>        Property Integer piRowType 0
76632>>>>>>>>>>>        Property String[] paQueryMessages
76633>>>>>>>>>>>        Property String psSQLStatementString
76634>>>>>>>>>>>
76634>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76635>>>>>>>>>>>
76635>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76636>>>>>>>>>>>
76636>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76636>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76636>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76636>>>>>>>>>>>        Property Integer piChunkMax 500
76637>>>>>>>>>>>
76637>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76637>>>>>>>>>>>        Send SetupSQLKeywordArray
76638>>>>>>>>>>>    End_Procedure
76639>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76639>>>>>>>>>>>>
76639>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76641>>>>>>>>>>>>    Integer iStart iEnd
76641>>>>>>>>>>>>    String sRetval
76641>>>>>>>>>>>>
76641>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76642>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76643>>>>>>>>>>>>    If (iStart = 0) Begin
76645>>>>>>>>>>>>        Function_Return ""
76646>>>>>>>>>>>>    End
76646>>>>>>>>>>>>>
76646>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76647>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76648>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76650>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76651>>>>>>>>>>>>    End
76651>>>>>>>>>>>>>
76651>>>>>>>>>>>>    Else Begin
76652>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76653>>>>>>>>>>>>    End
76653>>>>>>>>>>>>>
76653>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76655>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76656>>>>>>>>>>>>        Decrement iEnd
76657>>>>>>>>>>>>    End
76657>>>>>>>>>>>>>
76657>>>>>>>>>>>>    If (iEnd <> 0) Begin
76659>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76660>>>>>>>>>>>>    End
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76661>>>>>>>>>>>>
76661>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76662>>>>>>>>>>>>End_Function
76663>>>>>>>>>>>>
76663>>>>>>>>>>>>
76663>>>>>>>>>>>
76663>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76663>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76665>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76667>>>>>>>>>>>            Function_Return (EQ)
76668>>>>>>>>>>>        End
76668>>>>>>>>>>>>
76668>>>>>>>>>>>        Function_Return (GT)
76669>>>>>>>>>>>    End_Function
76670>>>>>>>>>>>
76670>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76670>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76672>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76675>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76678>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76681>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76684>>>>>>>>>>>
76684>>>>>>>>>>>        Function_Return (EQ)
76685>>>>>>>>>>>    End_Function
76686>>>>>>>>>>>
76686>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76688>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76688>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76689>>>>>>>>>>>        Integer iSize
76689>>>>>>>>>>>
76689>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76690>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76691>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76692>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76693>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76694>>>>>>>>>>>
76694>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76695>>>>>>>>>>>    End_Procedure
76696>>>>>>>>>>>
76696>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76696>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76696>>>>>>>>>>>    // have slightly different wording.
76696>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76696>>>>>>>>>>>    // needs to be done for every keyword group below.
76696>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76698>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76698>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76700>>>>>>>>>>>
76700>>>>>>>>>>>        // This should only be called once; but in case it is
76700>>>>>>>>>>>        // we delete the array first.
76700>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76701>>>>>>>>>>>
76701>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76701>>>>>>>>>>>        //
76701>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76702>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76703>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76704>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76705>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76706>>>>>>>>>>>
76706>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76707>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76708>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76709>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76710>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76711>>>>>>>>>>>
76711>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76712>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76713>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76714>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76715>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76716>>>>>>>>>>>
76716>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76717>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76718>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76719>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76720>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76721>>>>>>>>>>>
76721>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76722>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76723>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76724>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76725>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76726>>>>>>>>>>>
76726>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76727>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76728>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76729>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76730>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76731>>>>>>>>>>>
76731>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76732>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76733>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76734>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76735>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76736>>>>>>>>>>>
76736>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76737>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76738>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76739>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76740>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76741>>>>>>>>>>>
76741>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76742>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76743>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76744>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76745>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76746>>>>>>>>>>>
76746>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76747>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76748>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76749>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76750>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76751>>>>>>>>>>>
76751>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76752>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76753>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76754>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76755>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76756>>>>>>>>>>>
76756>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76757>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76758>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76759>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76760>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76761>>>>>>>>>>>
76761>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76762>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76763>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76764>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76765>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76766>>>>>>>>>>>
76766>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76767>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76768>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76769>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76770>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76771>>>>>>>>>>>
76771>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76772>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76773>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76774>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76775>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76776>>>>>>>>>>>
76776>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76777>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76778>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76779>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76780>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76781>>>>>>>>>>>
76781>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76782>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76783>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76784>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76785>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76786>>>>>>>>>>>
76786>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76787>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76788>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76789>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76790>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76791>>>>>>>>>>>
76791>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76792>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76793>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76794>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76795>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76796>>>>>>>>>>>
76796>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76797>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76798>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76799>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76800>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76801>>>>>>>>>>>
76801>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76802>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76803>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76804>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76805>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76806>>>>>>>>>>>
76806>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76807>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76808>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76809>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76810>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76811>>>>>>>>>>>
76811>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76812>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76813>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76814>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76815>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76816>>>>>>>>>>>
76816>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76817>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76818>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76819>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76820>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76821>>>>>>>>>>>
76821>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76822>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76824>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76825>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76826>>>>>>>>>>>
76826>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76827>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76828>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76829>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76830>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76831>>>>>>>>>>>
76831>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76832>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76833>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76834>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76835>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76836>>>>>>>>>>>
76836>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76837>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76838>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76839>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76840>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76841>>>>>>>>>>>
76841>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76842>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76844>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76845>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76846>>>>>>>>>>>
76846>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76847>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76848>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76849>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76850>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76851>>>>>>>>>>>
76851>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76852>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76853>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76854>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76855>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76856>>>>>>>>>>>
76856>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76857>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76858>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76859>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76860>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76861>>>>>>>>>>>
76861>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76862>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76863>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76864>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76865>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76866>>>>>>>>>>>
76866>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76867>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76868>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76869>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76870>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76871>>>>>>>>>>>
76871>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76872>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76873>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76876>>>>>>>>>>>
76876>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76877>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76878>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76879>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76880>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76881>>>>>>>>>>>
76881>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76882>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76883>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76884>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76885>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76886>>>>>>>>>>>
76886>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76887>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76888>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76889>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76890>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76891>>>>>>>>>>>
76891>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76892>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76893>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76894>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76895>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76896>>>>>>>>>>>
76896>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76897>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76898>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76899>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76900>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76901>>>>>>>>>>>
76901>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76902>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76903>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76904>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76905>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76906>>>>>>>>>>>
76906>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76907>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76908>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76909>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76910>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76911>>>>>>>>>>>
76911>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76912>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76913>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76914>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76915>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76916>>>>>>>>>>>
76916>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76917>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76918>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76919>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76920>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76921>>>>>>>>>>>
76921>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76921>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76922>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76923>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76924>>>>>>>>>>>
76924>>>>>>>>>>>    End_Procedure
76925>>>>>>>>>>>
76925>>>>>>>>>>>End_Class
76926>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76926>>>>>>>>>>>//****************************************************************************
76926>>>>>>>>>>>// $Module type: Class
76926>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76926>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76926>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76926>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76926>>>>>>>>>>>//
76926>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76926>>>>>>>>>>>//
76926>>>>>>>>>>>// $Rev History:
76926>>>>>>>>>>>//    2015-08-11  Module header created
76926>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76926>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76926>>>>>>>>>>>//                Added better error handling.
76926>>>>>>>>>>>//                Added a decompose message for the connection string.
76926>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76926>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76926>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76926>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76926>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76926>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76926>>>>>>>>>>>//****************************************************************************
76926>>>>>>>>>>>Use cli.pkg
76926>>>>>>>>>>>Use MSSqldrv.pkg
76926>>>>>>>>>>>Use db2_drv.pkg
76926>>>>>>>>>>>Use odbc_drv.pkg
76926>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76926>>>>>>>>>>>>>//****************************************************************************
76926>>>>>>>>>>>>>// $Module type: Class
76926>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76926>>>>>>>>>>>>>//
76926>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76926>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76926>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76926>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76926>>>>>>>>>>>>>//
76926>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76926>>>>>>>>>>>>>//
76926>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76926>>>>>>>>>>>>>//               properties of that object.
76926>>>>>>>>>>>>>//
76926>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76926>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76926>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76926>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76926>>>>>>>>>>>>>// in the help folder for more details.
76926>>>>>>>>>>>>>//
76926>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76926>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76926>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76926>>>>>>>>>>>>>>>
76926>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76927>>>>>>>>>>>>>>>    Procedure Construct_Object
76929>>>>>>>>>>>>>>>        Forward Send Construct_Object
76931>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76932>>>>>>>>>>>>>>>    End_Procedure
76933>>>>>>>>>>>>>>>
76933>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76935>>>>>>>>>>>>>>>        String sRetval
76935>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76937>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76938>>>>>>>>>>>>>>>        End                                        
76938>>>>>>>>>>>>>>>>
76938>>>>>>>>>>>>>>>        Else Begin
76939>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76940>>>>>>>>>>>>>>>        End
76940>>>>>>>>>>>>>>>>
76940>>>>>>>>>>>>>>>            
76940>>>>>>>>>>>>>>>        Function_Return sRetval
76941>>>>>>>>>>>>>>>    End_Function
76942>>>>>>>>>>>>>>>
76942>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76944>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76944>>>>>>>>>>>>>>>
76944>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76945>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76946>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76947>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76949>>>>>>>>>>>>>>>            Move "" to sDatabase
76950>>>>>>>>>>>>>>>        End
76950>>>>>>>>>>>>>>>>
76950>>>>>>>>>>>>>>>        
76950>>>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
76950>>>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
76950>>>>>>>>>>>>>>>//            Function_Return sConnect
76950>>>>>>>>>>>>>>>//        End
76950>>>>>>>>>>>>>>>
76950>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
76952>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76953>>>>>>>>>>>>>>>        End
76953>>>>>>>>>>>>>>>>
76953>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
76955>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76956>>>>>>>>>>>>>>>        End
76956>>>>>>>>>>>>>>>>
76956>>>>>>>>>>>>>>>        Else Begin
76957>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76958>>>>>>>>>>>>>>>        End
76958>>>>>>>>>>>>>>>>
76958>>>>>>>>>>>>>>>        Function_Return sConnect
76959>>>>>>>>>>>>>>>    End_Function
76960>>>>>>>>>>>>>>>
76960>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76962>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
76962>>>>>>>>>>>>>>>        String sDriverID
76962>>>>>>>>>>>>>>>
76962>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76963>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76965>>>>>>>>>>>>>>>            Function_Return True
76966>>>>>>>>>>>>>>>        End
76966>>>>>>>>>>>>>>>>
76966>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76967>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
76969>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
76970>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
76972>>>>>>>>>>>>>>>        End
76972>>>>>>>>>>>>>>>>
76972>>>>>>>>>>>>>>>        Else Begin
76973>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
76975>>>>>>>>>>>>>>>        End
76975>>>>>>>>>>>>>>>>
76975>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
76976>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76977>>>>>>>>>>>>>>>    End_Function
76978>>>>>>>>>>>>>>>End_Class
76979>>>>>>>>>>>>>>>
76979>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
76980>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76982>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
76983>>>>>>>>>>>>>>>    End_Function
76984>>>>>>>>>>>>>>>End_Class
76985>>>>>>>>>>>>>>>
76985>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
76986>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76988>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
76988>>>>>>>>>>>>>>>        String sDriverID
76988>>>>>>>>>>>>>>>
76988>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76989>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
76990>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76992>>>>>>>>>>>>>>>            Function_Return True
76993>>>>>>>>>>>>>>>        End
76993>>>>>>>>>>>>>>>>
76993>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76994>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
76996>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
76998>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
76999>>>>>>>>>>>>>>>            End
76999>>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77002>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77003>>>>>>>>>>>>>>>            End
77003>>>>>>>>>>>>>>>>
77003>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77005>>>>>>>>>>>>>>>        End
77005>>>>>>>>>>>>>>>>
77005>>>>>>>>>>>>>>>        Else Begin
77006>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77008>>>>>>>>>>>>>>>        End
77008>>>>>>>>>>>>>>>>
77008>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77009>>>>>>>>>>>>>>>
77009>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77010>>>>>>>>>>>>>>>    End_Function
77011>>>>>>>>>>>>>>>End_Class
77012>>>>>>>>>>>>>>>
77012>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77013>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77015>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77015>>>>>>>>>>>>>>>        String sDriverID
77015>>>>>>>>>>>>>>>
77015>>>>>>>>>>>>>>>        Move False to Err
77016>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77017>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77019>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77020>>>>>>>>>>>>>>>        End
77020>>>>>>>>>>>>>>>>
77020>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77022>>>>>>>>>>>>>>>
77022>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77023>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77024>>>>>>>>>>>>>>>    End_Function
77025>>>>>>>>>>>>>>>End_Class
77026>>>>>>>>>>>>>>>
77026>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77027>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77029>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77029>>>>>>>>>>>>>>>        String sDriverID
77029>>>>>>>>>>>>>>>
77029>>>>>>>>>>>>>>>        Move False to Err
77030>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77031>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77031>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77031>>>>>>>>>>>>>>>//        End
77031>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77033>>>>>>>>>>>>>>>
77033>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77034>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77035>>>>>>>>>>>>>>>    End_Function
77036>>>>>>>>>>>>>>>End_Class
77037>>>>>>>>>>>>>>>
77037>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77038>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77040>>>>>>>>>>>>>>>        Function_Return ""
77041>>>>>>>>>>>>>>>    End_Function
77042>>>>>>>>>>>>>>>End_Class
77043>>>>>>>>>>>>>>>
77043>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77044>>>>>>>>>>>>>>>    Procedure Construct_Object
77046>>>>>>>>>>>>>>>        Forward Send Construct_Object
77048>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77049>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77050>>>>>>>>>>>>>>>    End_Procedure
77051>>>>>>>>>>>>>>>
77051>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77053>>>>>>>>>>>>>>>        String sDriverID
77053>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77053>>>>>>>>>>>>>>>
77053>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77054>>>>>>>>>>>>>>>        Case Begin
77054>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77056>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77057>>>>>>>>>>>>>>>                Case Break
77058>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77061>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77062>>>>>>>>>>>>>>>                Case Break
77063>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77066>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77067>>>>>>>>>>>>>>>                Case Break               
77068>>>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
77068>>>>>>>>>>>>>>>            Case Else
77068>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77069>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77070>>>>>>>>>>>>>>>        Case End
77070>>>>>>>>>>>>>>>
77070>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77071>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77072>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77073>>>>>>>>>>>>>>>
77073>>>>>>>>>>>>>>>        Function_Return hoDriver
77074>>>>>>>>>>>>>>>    End_Function
77075>>>>>>>>>>>>>>>
77075>>>>>>>>>>>>>>>    Procedure DestroyDriver
77077>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77079>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77080>>>>>>>>>>>>>>>        End
77080>>>>>>>>>>>>>>>>
77080>>>>>>>>>>>>>>>    End_Procedure
77081>>>>>>>>>>>>>>>
77081>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77083>>>>>>>>>>>>>>>        String sConnect
77083>>>>>>>>>>>>>>>        Handle hoDriver
77083>>>>>>>>>>>>>>>
77083>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
77084>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77085>>>>>>>>>>>>>>>        Send DestroyDriver
77086>>>>>>>>>>>>>>>        Function_Return sConnect
77087>>>>>>>>>>>>>>>    End_Function
77088>>>>>>>>>>>>>>>
77088>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77090>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77090>>>>>>>>>>>>>>>        Handle hoDriver
77090>>>>>>>>>>>>>>>
77090>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
77091>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77092>>>>>>>>>>>>>>>        Send DestroyDriver
77093>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77094>>>>>>>>>>>>>>>    End_Function
77095>>>>>>>>>>>>>>>
77095>>>>>>>>>>>>>>>End_Class
77096>>>>>>>>>>>>>
77096>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cLoginEncryption.pkg)
77096>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77096>>>>>>>>>>>>>>>
77096>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77097>>>>>>>>>>>>>>>    
77097>>>>>>>>>>>>>>>    Procedure Construct_Object
77099>>>>>>>>>>>>>>>        Forward Send Construct_Object
77101>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77101>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77102>>>>>>>>>>>>>>>        
77102>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77104>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77105>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77106>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77107>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77108>>>>>>>>>>>>>>>        End_Object
77109>>>>>>>>>>>>>>>    End_Procedure
77110>>>>>>>>>>>>>>>    
77110>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77110>>>>>>>>>>>>>>>    // hidden mechanism desired.
77110>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77112>>>>>>>>>>>>>>>        String sPassword
77112>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77113>>>>>>>>>>>>>>>        Function_Return sPassword
77114>>>>>>>>>>>>>>>    End_Function
77115>>>>>>>>>>>>>>>    
77115>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77115>>>>>>>>>>>>>>>    //
77115>>>>>>>>>>>>>>>    // Params:
77115>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77115>>>>>>>>>>>>>>>    // Returns:
77115>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77115>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77117>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77117>>>>>>>>>>>>>>>        UChar[] ucBinary
77118>>>>>>>>>>>>>>>        Pointer pBase64
77118>>>>>>>>>>>>>>>        Integer iVoid
77118>>>>>>>>>>>>>>>        
77118>>>>>>>>>>>>>>>        //  Encrypt Key
77118>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77119>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77121>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77122>>>>>>>>>>>>>>>>
77122>>>>>>>>>>>>>>>        End
77122>>>>>>>>>>>>>>>>
77122>>>>>>>>>>>>>>>        
77122>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77123>>>>>>>>>>>>>>>        
77123>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77125>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77126>>>>>>>>>>>>>>>>
77126>>>>>>>>>>>>>>>            Function_Return ""
77127>>>>>>>>>>>>>>>        End
77127>>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>        
77127>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77127>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77128>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77129>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77130>>>>>>>>>>>>>>>        
77130>>>>>>>>>>>>>>>        Function_Return sBase64
77131>>>>>>>>>>>>>>>    End_Function
77132>>>>>>>>>>>>>>>    
77132>>>>>>>>>>>>>>>    
77132>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77132>>>>>>>>>>>>>>>    //
77132>>>>>>>>>>>>>>>    // Params:
77132>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77132>>>>>>>>>>>>>>>    // Returns:
77132>>>>>>>>>>>>>>>    //   Readable plain text password
77132>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77134>>>>>>>>>>>>>>>        String sEncryptPassword
77134>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77136>>>>>>>>>>>>>>>        Boolean bIsHex
77136>>>>>>>>>>>>>>>        Integer iLen iVoid
77136>>>>>>>>>>>>>>>        Pointer pBinary
77136>>>>>>>>>>>>>>>        
77136>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77138>>>>>>>>>>>>>>>            //  Decode from Base64
77138>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77139>>>>>>>>>>>>>>>            
77139>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77140>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77141>>>>>>>>>>>>>>>                        
77141>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77142>>>>>>>>>>>>>>>            
77142>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77142>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77143>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77144>>>>>>>>>>>>>>>        End
77144>>>>>>>>>>>>>>>>
77144>>>>>>>>>>>>>>>        
77144>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77145>>>>>>>>>>>>>>>    End_Function
77146>>>>>>>>>>>>>>>End_Class
77147>>>>>>>>>>>>>
77147>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77148>>>>>>>>>>>>>    Procedure Construct_Object
77150>>>>>>>>>>>>>        Forward Send Construct_Object
77152>>>>>>>>>>>>>
77152>>>>>>>>>>>>>        Property String Private_psIniFilePath
77153>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77154>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77155>>>>>>>>>>>>>
77155>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77156>>>>>>>>>>>>>
77156>>>>>>>>>>>>>        // *** You really want to change this value! ***
77156>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77156>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77157>>>>>>>>>>>>>
77157>>>>>>>>>>>>>    End_Procedure
77158>>>>>>>>>>>>>
77158>>>>>>>>>>>>>    Procedure End_Construct_Object
77160>>>>>>>>>>>>>        Forward Send End_Construct_Object
77162>>>>>>>>>>>>>    End_Procedure
77163>>>>>>>>>>>>>
77163>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77165>>>>>>>>>>>>>        String sIniFile
77165>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77166>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77167>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77168>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77169>>>>>>>>>>>>>    End_Procedure
77170>>>>>>>>>>>>>
77170>>>>>>>>>>>>>    Function psIniFilePath Returns String
77172>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77173>>>>>>>>>>>>>    End_Function
77174>>>>>>>>>>>>>
77174>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77176>>>>>>>>>>>>>        String sPath
77176>>>>>>>>>>>>>        Get psIniFilePath to sPath
77177>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77178>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77179>>>>>>>>>>>>>    End_Procedure
77180>>>>>>>>>>>>>
77180>>>>>>>>>>>>>    Function psIniFileName Returns String
77182>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77183>>>>>>>>>>>>>    End_Function
77184>>>>>>>>>>>>>
77184>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77184>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77184>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77184>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77186>>>>>>>>>>>>>        String sIniFile sPath
77186>>>>>>>>>>>>>
77186>>>>>>>>>>>>>        Get psIniFilePath to sPath
77187>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77188>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77189>>>>>>>>>>>>>        Set psFileName to sIniFile
77190>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77191>>>>>>>>>>>>>    End_Procedure
77192>>>>>>>>>>>>>
77192>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77192>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77192>>>>>>>>>>>>>    // Returns the value
77192>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77194>>>>>>>>>>>>>        String sValue sIniFile sPath
77194>>>>>>>>>>>>>
77194>>>>>>>>>>>>>        Get psIniFilePath to sPath
77195>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77196>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77197>>>>>>>>>>>>>        Set psFileName to sIniFile
77198>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77199>>>>>>>>>>>>>
77199>>>>>>>>>>>>>        Function_Return sValue
77200>>>>>>>>>>>>>    End_Function
77201>>>>>>>>>>>>>
77201>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77201>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77203>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77206>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77209>>>>>>>>>>>>>
77209>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77212>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77215>>>>>>>>>>>>>
77215>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77218>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77221>>>>>>>>>>>>>
77221>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77224>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77227>>>>>>>>>>>>>
77227>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77230>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77233>>>>>>>>>>>>>
77233>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77236>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77239>>>>>>>>>>>>>
77239>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77242>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77245>>>>>>>>>>>>>
77245>>>>>>>>>>>>>        Function_Return (EQ)
77246>>>>>>>>>>>>>    End_Function
77247>>>>>>>>>>>>>
77247>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77249>>>>>>>>>>>>>        Handle hoSections
77249>>>>>>>>>>>>>        Integer iItems
77249>>>>>>>>>>>>>
77249>>>>>>>>>>>>>        Send ReadSections hoSections
77250>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77251>>>>>>>>>>>>>        Function_Return iItems
77252>>>>>>>>>>>>>    End_Function
77253>>>>>>>>>>>>>
77253>>>>>>>>>>>>>    // The normal connection string looks something like this;
77253>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77253>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77253>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77253>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77253>>>>>>>>>>>>>//        String sSection
77253>>>>>>>>>>>>>//        Integer iCount
77253>>>>>>>>>>>>>//
77253>>>>>>>>>>>>>//        Move False to Err
77253>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77253>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77253>>>>>>>>>>>>>//        Increment iCount
77253>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77253>>>>>>>>>>>>>//
77253>>>>>>>>>>>>>//        Function_Return (Err = False)
77253>>>>>>>>>>>>>//    End_Function
77253>>>>>>>>>>>>>
77253>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77255>>>>>>>>>>>>>        Integer iCount
77255>>>>>>>>>>>>>        Boolean bExists
77255>>>>>>>>>>>>>        String sSection
77255>>>>>>>>>>>>>
77255>>>>>>>>>>>>>        Move False to Err
77256>>>>>>>>>>>>>        Move 1 to iCount
77257>>>>>>>>>>>>>        Get psIniSectionName to sSection
77258>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77259>>>>>>>>>>>>>        While (bExists = True)
77263>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77264>>>>>>>>>>>>>            Increment iCount
77265>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77266>>>>>>>>>>>>>        Loop
77267>>>>>>>>>>>>>>
77267>>>>>>>>>>>>>        Function_Return (Err = False)
77268>>>>>>>>>>>>>    End_Function
77269>>>>>>>>>>>>>
77269>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77271>>>>>>>>>>>>>        Integer iCount
77271>>>>>>>>>>>>>        String sSection
77271>>>>>>>>>>>>>        Boolean bExists
77271>>>>>>>>>>>>>
77271>>>>>>>>>>>>>        Move False to Err
77272>>>>>>>>>>>>>        Move 1 to iCount
77273>>>>>>>>>>>>>        Get psIniSectionName to sSection
77274>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77275>>>>>>>>>>>>>        While (bExists = True)
77279>>>>>>>>>>>>>            If (iCount = iItem) Begin
77281>>>>>>>>>>>>>                Send DeleteSection sSection
77282>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77282>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77283>>>>>>>>>>>>>            End
77283>>>>>>>>>>>>>>
77283>>>>>>>>>>>>>            Increment iCount
77284>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77285>>>>>>>>>>>>>        Loop
77286>>>>>>>>>>>>>>
77286>>>>>>>>>>>>>
77286>>>>>>>>>>>>>        Function_Return (Err = False)
77287>>>>>>>>>>>>>    End_Function
77288>>>>>>>>>>>>>
77288>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77288>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77288>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77290>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77290>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77291>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77291>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77291>>>>>>>>>>>>>        Integer iIndex
77291>>>>>>>>>>>>>
77291>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77292>>>>>>>>>>>>>        If (iIndex = -1) Begin
77294>>>>>>>>>>>>>            Move True to SQLConnection.bError
77295>>>>>>>>>>>>>            Function_Return SQLConnection
77296>>>>>>>>>>>>>        End
77296>>>>>>>>>>>>>>
77296>>>>>>>>>>>>>
77296>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77297>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77298>>>>>>>>>>>>>
77298>>>>>>>>>>>>>        Function_Return SQLConnection
77299>>>>>>>>>>>>>    End_Function
77300>>>>>>>>>>>>>
77300>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77300>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77302>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77302>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77303>>>>>>>>>>>>>        Integer iRetval iCount iSize
77303>>>>>>>>>>>>>        String sValue
77303>>>>>>>>>>>>>        Boolean bExists
77303>>>>>>>>>>>>>
77303>>>>>>>>>>>>>        Move -1 to iRetval
77304>>>>>>>>>>>>>
77304>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77305>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77306>>>>>>>>>>>>>        Decrement iSize
77307>>>>>>>>>>>>>        For iCount from 0 to iSize
77313>>>>>>>>>>>>>>
77313>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77314>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77315>>>>>>>>>>>>>            If (bExists) Begin
77317>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77318>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77319>>>>>>>>>>>>>            End
77319>>>>>>>>>>>>>>
77319>>>>>>>>>>>>>        Loop
77320>>>>>>>>>>>>>>
77320>>>>>>>>>>>>>
77320>>>>>>>>>>>>>        Function_Return iRetval
77321>>>>>>>>>>>>>    End_Function
77322>>>>>>>>>>>>>
77322>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77322>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77322>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77324>>>>>>>>>>>>>        Integer iCount iSize iItems
77324>>>>>>>>>>>>>        String sValue
77324>>>>>>>>>>>>>        Boolean bExists
77324>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77324>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77325>>>>>>>>>>>>>
77325>>>>>>>>>>>>>        Move 0 to iItems
77326>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77327>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77328>>>>>>>>>>>>>        Decrement iSize
77329>>>>>>>>>>>>>        For iCount from 0 to iSize
77335>>>>>>>>>>>>>>
77335>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77336>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77337>>>>>>>>>>>>>            If (bExists) Begin
77339>>>>>>>>>>>>>                Increment iItems
77340>>>>>>>>>>>>>            End
77340>>>>>>>>>>>>>>
77340>>>>>>>>>>>>>        Loop
77341>>>>>>>>>>>>>>
77341>>>>>>>>>>>>>
77341>>>>>>>>>>>>>        Function_Return (iItems > 1)
77342>>>>>>>>>>>>>    End_Function
77343>>>>>>>>>>>>>
77343>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77343>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77345>>>>>>>>>>>>>        Boolean bOK
77345>>>>>>>>>>>>>        Integer iSize iCount
77345>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77345>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77346>>>>>>>>>>>>>        tSQLConnection SQLConnection
77346>>>>>>>>>>>>>        tSQLConnection SQLConnection
77346>>>>>>>>>>>>>        String sConnectionString
77346>>>>>>>>>>>>>
77346>>>>>>>>>>>>>        Move False to Err
77347>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77348>>>>>>>>>>>>>
77348>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77349>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77350>>>>>>>>>>>>>        Decrement iSize
77351>>>>>>>>>>>>>        // Set all current connection to inactive.
77351>>>>>>>>>>>>>        For iCount from 0 to iSize
77357>>>>>>>>>>>>>>
77357>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77358>>>>>>>>>>>>>        Loop
77359>>>>>>>>>>>>>>
77359>>>>>>>>>>>>>
77359>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77360>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77361>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77362>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77363>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77364>>>>>>>>>>>>>
77364>>>>>>>>>>>>>        Function_Return (bOK = True)
77365>>>>>>>>>>>>>    End_Function
77366>>>>>>>>>>>>>
77366>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77366>>>>>>>>>>>>>    // Returns True if successful.
77366>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77368>>>>>>>>>>>>>        Boolean bOK
77368>>>>>>>>>>>>>        Integer iItem iSize iCount
77368>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77368>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77369>>>>>>>>>>>>>
77369>>>>>>>>>>>>>        Move False to Err
77370>>>>>>>>>>>>>        Move -1 to iItem
77371>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77372>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77373>>>>>>>>>>>>>        Decrement iSize
77374>>>>>>>>>>>>>        // Set all current connection to inactive.
77374>>>>>>>>>>>>>        For iCount from 0 to iSize
77380>>>>>>>>>>>>>>
77380>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77381>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77383>>>>>>>>>>>>>                Move iCount to iItem
77384>>>>>>>>>>>>>            End
77384>>>>>>>>>>>>>>
77384>>>>>>>>>>>>>        Loop
77385>>>>>>>>>>>>>>
77385>>>>>>>>>>>>>
77385>>>>>>>>>>>>>        If (iItem <> -1) Begin
77387>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77388>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77389>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77390>>>>>>>>>>>>>        End
77390>>>>>>>>>>>>>>
77390>>>>>>>>>>>>>
77390>>>>>>>>>>>>>        Function_Return (bOK = True)
77391>>>>>>>>>>>>>    End_Function
77392>>>>>>>>>>>>>
77392>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77394>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77394>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77395>>>>>>>>>>>>>        String sSection sValue
77395>>>>>>>>>>>>>        Integer iCount
77395>>>>>>>>>>>>>        Boolean bExists
77395>>>>>>>>>>>>>
77395>>>>>>>>>>>>>        Get psIniSectionName to sSection
77396>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77397>>>>>>>>>>>>>        If (bExists = False) Begin
77399>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77400>>>>>>>>>>>>>        End
77400>>>>>>>>>>>>>>
77400>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77401>>>>>>>>>>>>>        If (bExists = True) Begin
77403>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77404>>>>>>>>>>>>>>
77404>>>>>>>>>>>>>        End
77404>>>>>>>>>>>>>>
77404>>>>>>>>>>>>>
77404>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77405>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77406>>>>>>>>>>>>>
77406>>>>>>>>>>>>>        While (bExists = True)                 
77410>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77410>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77410>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77410>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77410>>>>>>>>>>>>>
77410>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77411>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77412>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77413>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77414>>>>>>>>>>>>>
77414>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77414>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77415>>>>>>>>>>>>>            If (sValue = "99") Begin
77417>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77418>>>>>>>>>>>>>            End
77418>>>>>>>>>>>>>>
77418>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77419>>>>>>>>>>>>>
77419>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77420>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77421>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77423>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77424>>>>>>>>>>>>>            End
77424>>>>>>>>>>>>>>
77424>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77426>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77427>>>>>>>>>>>>>            End
77427>>>>>>>>>>>>>>
77427>>>>>>>>>>>>>
77427>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77428>>>>>>>>>>>>>
77428>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77429>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77430>>>>>>>>>>>>>
77430>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77431>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77432>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77434>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77435>>>>>>>>>>>>>            End
77435>>>>>>>>>>>>>>
77435>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77436>>>>>>>>>>>>>
77436>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77436>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77437>>>>>>>>>>>>>
77437>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77438>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77439>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77440>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77441>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77442>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77443>>>>>>>>>>>>>
77443>>>>>>>>>>>>>            Increment iCount
77444>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77445>>>>>>>>>>>>>        Loop
77446>>>>>>>>>>>>>>
77446>>>>>>>>>>>>>
77446>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77446>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77448>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77449>>>>>>>>>>>>>        End
77449>>>>>>>>>>>>>>
77449>>>>>>>>>>>>>
77449>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77450>>>>>>>>>>>>>    End_Function
77451>>>>>>>>>>>>>
77451>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77453>>>>>>>>>>>>>        Integer iCount iSize
77453>>>>>>>>>>>>>        Boolean bOK
77453>>>>>>>>>>>>>        String sSection sValue
77453>>>>>>>>>>>>>
77453>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77453>>>>>>>>>>>>>        Move 0 to iCount
77454>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77455>>>>>>>>>>>>>        If (bOK = False) Begin
77457>>>>>>>>>>>>>            Function_Return False
77458>>>>>>>>>>>>>        End
77458>>>>>>>>>>>>>>
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Move False to Err
77459>>>>>>>>>>>>>        Get psIniSectionName to sSection
77460>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77460>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77461>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77462>>>>>>>>>>>>>        Decrement iSize
77463>>>>>>>>>>>>>
77463>>>>>>>>>>>>>        For iCount from 0 to iSize
77469>>>>>>>>>>>>>>
77469>>>>>>>>>>>>>            // DF 19 compatible settings:
77469>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77470>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77471>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77472>>>>>>>>>>>>>            
77472>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77473>>>>>>>>>>>>>
77473>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77474>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77476>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77477>>>>>>>>>>>>>            End
77477>>>>>>>>>>>>>>
77477>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77478>>>>>>>>>>>>>
77478>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77480>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77481>>>>>>>>>>>>>            End
77481>>>>>>>>>>>>>>
77481>>>>>>>>>>>>>
77481>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77482>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77483>>>>>>>>>>>>>
77483>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77483>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77484>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77485>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77486>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77487>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77488>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77489>>>>>>>>>>>>>        Loop
77490>>>>>>>>>>>>>>
77490>>>>>>>>>>>>>
77490>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77491>>>>>>>>>>>>>    End_Function
77492>>>>>>>>>>>>>
77492>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77492>>>>>>>>>>>>>    //
77492>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77492>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77492>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77494>>>>>>>>>>>>>        String sRetval
77494>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77496>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77497>>>>>>>>>>>>>        End
77497>>>>>>>>>>>>>>
77497>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77499>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77500>>>>>>>>>>>>>        End
77500>>>>>>>>>>>>>>
77500>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77502>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77503>>>>>>>>>>>>>        End
77503>>>>>>>>>>>>>>
77503>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77505>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77506>>>>>>>>>>>>>        End
77506>>>>>>>>>>>>>>
77506>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77508>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77509>>>>>>>>>>>>>        End
77509>>>>>>>>>>>>>>
77509>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77511>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77512>>>>>>>>>>>>>        End
77512>>>>>>>>>>>>>>
77512>>>>>>>>>>>>>        Function_Return sRetval
77513>>>>>>>>>>>>>    End_Function
77514>>>>>>>>>>>>>
77514>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77514>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77514>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77516>>>>>>>>>>>>>        Integer iRetval
77516>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77518>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77519>>>>>>>>>>>>>        End
77519>>>>>>>>>>>>>>
77519>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77521>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77522>>>>>>>>>>>>>        End
77522>>>>>>>>>>>>>>
77522>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77524>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77525>>>>>>>>>>>>>        End
77525>>>>>>>>>>>>>>
77525>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77527>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77528>>>>>>>>>>>>>        End
77528>>>>>>>>>>>>>>
77528>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77530>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77531>>>>>>>>>>>>>        End
77531>>>>>>>>>>>>>>
77531>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77533>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77534>>>>>>>>>>>>>        End
77534>>>>>>>>>>>>>>
77534>>>>>>>>>>>>>        Function_Return iRetval
77535>>>>>>>>>>>>>    End_Function
77536>>>>>>>>>>>>>
77536>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77536>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77536>>>>>>>>>>>>>    // the SQL Connection program's grid.
77536>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77538>>>>>>>>>>>>>        String sRetval
77538>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77540>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77541>>>>>>>>>>>>>        End
77541>>>>>>>>>>>>>>
77541>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77543>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77544>>>>>>>>>>>>>        End
77544>>>>>>>>>>>>>>
77544>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77546>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77547>>>>>>>>>>>>>        End
77547>>>>>>>>>>>>>>
77547>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77549>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77550>>>>>>>>>>>>>        End
77550>>>>>>>>>>>>>>
77550>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77552>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77553>>>>>>>>>>>>>        End
77553>>>>>>>>>>>>>>
77553>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77555>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77556>>>>>>>>>>>>>        End
77556>>>>>>>>>>>>>>
77556>>>>>>>>>>>>>        Function_Return sRetval
77557>>>>>>>>>>>>>    End_Function
77558>>>>>>>>>>>>>
77558>>>>>>>>>>>>>    // Pass a driver id and the function will return
77558>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77558>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77558>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77560>>>>>>>>>>>>>        Integer iRetval
77560>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77562>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77563>>>>>>>>>>>>>        End
77563>>>>>>>>>>>>>>
77563>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77565>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77566>>>>>>>>>>>>>        End
77566>>>>>>>>>>>>>>
77566>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77568>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77569>>>>>>>>>>>>>        End
77569>>>>>>>>>>>>>>
77569>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77571>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77572>>>>>>>>>>>>>        End
77572>>>>>>>>>>>>>>
77572>>>>>>>>>>>>>        Function_Return iRetval
77573>>>>>>>>>>>>>    End_Function
77574>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77574>>>>>>>>>>>>>>
77574>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77576>>>>>>>>>>>>>>    Integer iStart iEnd
77576>>>>>>>>>>>>>>    String sRetval
77576>>>>>>>>>>>>>>
77576>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77577>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77578>>>>>>>>>>>>>>    If (iStart = 0) Begin
77580>>>>>>>>>>>>>>        Function_Return ""
77581>>>>>>>>>>>>>>    End
77581>>>>>>>>>>>>>>>
77581>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77582>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77583>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77585>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77586>>>>>>>>>>>>>>    End
77586>>>>>>>>>>>>>>>
77586>>>>>>>>>>>>>>    Else Begin
77587>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77588>>>>>>>>>>>>>>    End
77588>>>>>>>>>>>>>>>
77588>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77590>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77591>>>>>>>>>>>>>>        Decrement iEnd
77592>>>>>>>>>>>>>>    End
77592>>>>>>>>>>>>>>>
77592>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77594>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77595>>>>>>>>>>>>>>    End
77595>>>>>>>>>>>>>>>
77595>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77596>>>>>>>>>>>>>>
77596>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77597>>>>>>>>>>>>>>End_Function
77598>>>>>>>>>>>>>>
77598>>>>>>>>>>>>>>
77598>>>>>>>>>>>>>
77598>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77600>>>>>>>>>>>>>        String sConnect
77600>>>>>>>>>>>>>        Handle hoDriver
77600>>>>>>>>>>>>>
77600>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77601>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77602>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77603>>>>>>>>>>>>>        Send Destroy of hoDriver
77604>>>>>>>>>>>>>
77604>>>>>>>>>>>>>        Function_Return sConnect
77605>>>>>>>>>>>>>    End_Function
77606>>>>>>>>>>>>>
77606>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77606>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77608>>>>>>>>>>>>>        String sConnect
77608>>>>>>>>>>>>>
77608>>>>>>>>>>>>>        Case Begin
77608>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77610>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77611>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77613>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77614>>>>>>>>>>>>>                End
77614>>>>>>>>>>>>>>
77614>>>>>>>>>>>>>                Case Break
77615>>>>>>>>>>>>>
77615>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77618>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77620>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77621>>>>>>>>>>>>>                End
77621>>>>>>>>>>>>>>
77621>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77624>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77625>>>>>>>>>>>>>                End
77625>>>>>>>>>>>>>>
77625>>>>>>>>>>>>>
77625>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77627>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77628>>>>>>>>>>>>>                End
77628>>>>>>>>>>>>>>
77628>>>>>>>>>>>>>                Case Break
77629>>>>>>>>>>>>>
77629>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77632>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77633>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77635>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77636>>>>>>>>>>>>>                End
77636>>>>>>>>>>>>>>
77636>>>>>>>>>>>>>                Case Break
77637>>>>>>>>>>>>>
77637>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77640>>>>>>>>>>>>>                Break
77641>>>>>>>>>>>>>
77641>>>>>>>>>>>>>            Case Else
77641>>>>>>>>>>>>>                Move "" to sConnect
77642>>>>>>>>>>>>>        Case End
77642>>>>>>>>>>>>>
77642>>>>>>>>>>>>>        Function_Return sConnect
77643>>>>>>>>>>>>>    End_Function
77644>>>>>>>>>>>>>
77644>>>>>>>>>>>>>    // Use Base64
77644>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77646>>>>>>>>>>>>>        String sRetval
77646>>>>>>>>>>>>>        Handle hoLoginEncryption
77646>>>>>>>>>>>>>
77646>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77647>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77648>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77649>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77650>>>>>>>>>>>>>          
77650>>>>>>>>>>>>>        Function_Return sRetval
77651>>>>>>>>>>>>>    End_Function
77652>>>>>>>>>>>>>
77652>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77654>>>>>>>>>>>>>        String sRetval
77654>>>>>>>>>>>>>        Handle hoLoginEncryption
77654>>>>>>>>>>>>>
77654>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77655>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77656>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77657>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77658>>>>>>>>>>>>>
77658>>>>>>>>>>>>>        Function_Return sRetval
77659>>>>>>>>>>>>>    End_Function
77660>>>>>>>>>>>>>
77660>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77660>>>>>>>>>>>>>    Function ApplicationPath Returns String
77662>>>>>>>>>>>>>        String sApplicationFileName sPath
77662>>>>>>>>>>>>>        Integer iNumChars iRetval
77662>>>>>>>>>>>>>
77662>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77663>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77664>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77665>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77666>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77667>>>>>>>>>>>>>
77667>>>>>>>>>>>>>        Function_Return sPath
77668>>>>>>>>>>>>>    End_Function
77669>>>>>>>>>>>>>
77669>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77669>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77669>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77669>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77671>>>>>>>>>>>>>        Boolean bExists
77671>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77671>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77672>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77672>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77672>>>>>>>>>>>>>        
77672>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77673>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77674>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77675>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77676>>>>>>>>>>>>>        If (bExists = True) Begin
77678>>>>>>>>>>>>>            Function_Return sProgramsPath
77679>>>>>>>>>>>>>        End                      
77679>>>>>>>>>>>>>>
77679>>>>>>>>>>>>>    
77679>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77680>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77682>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77683>>>>>>>>>>>>>        End                                              
77683>>>>>>>>>>>>>>
77683>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77684>>>>>>>>>>>>>        
77684>>>>>>>>>>>>>        Move False to bExists
77685>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77686>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77687>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77688>>>>>>>>>>>>>        Decrement iSize       
77689>>>>>>>>>>>>>        
77689>>>>>>>>>>>>>        For iCount from 0 to iSize
77695>>>>>>>>>>>>>>
77695>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77696>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77697>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77698>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77699>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77705>>>>>>>>>>>>>>
77705>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77706>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77707>>>>>>>>>>>>>                // Check if there are more than one path specified;
77707>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77708>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77710>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77711>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77717>>>>>>>>>>>>>>
77717>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77718>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77719>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77720>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77721>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77722>>>>>>>>>>>>>                        If (bExists = True) Begin
77724>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77725>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77726>>>>>>>>>>>>>                            Move iSize to iCount
77727>>>>>>>>>>>>>                        End                                                    
77727>>>>>>>>>>>>>>
77727>>>>>>>>>>>>>                    Loop
77728>>>>>>>>>>>>>>
77728>>>>>>>>>>>>>                End
77728>>>>>>>>>>>>>>
77728>>>>>>>>>>>>>                Else Begin
77729>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77730>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77731>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77732>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77733>>>>>>>>>>>>>                    If (bExists = True) Begin
77735>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77736>>>>>>>>>>>>>                        Move iSize to iCount
77737>>>>>>>>>>>>>                    End                                                    
77737>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>                End
77737>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>            Loop
77738>>>>>>>>>>>>>>
77738>>>>>>>>>>>>>            If (bExists = False) Begin
77740>>>>>>>>>>>>>                Move "" to sPath    
77741>>>>>>>>>>>>>            End
77741>>>>>>>>>>>>>>
77741>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77742>>>>>>>>>>>>>        Loop        
77743>>>>>>>>>>>>>>
77743>>>>>>>>>>>>>        Send Destroy of hoPaths
77744>>>>>>>>>>>>>        
77744>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77744>>>>>>>>>>>>>        If (sPath = "") Begin
77746>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77747>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77748>>>>>>>>>>>>>        End                  
77748>>>>>>>>>>>>>>
77748>>>>>>>>>>>>>        
77748>>>>>>>>>>>>>        Function_Return sPath    
77749>>>>>>>>>>>>>    End_Function
77750>>>>>>>>>>>>>    
77750>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77750>>>>>>>>>>>>>    // with one or more .ws file names.
77750>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77750>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77750>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77750>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77752>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77754>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77754>>>>>>>>>>>>>        Integer iCh iSize
77754>>>>>>>>>>>>>        Boolean bExists      
77754>>>>>>>>>>>>>        Handle hoIniFile 
77754>>>>>>>>>>>>>        
77754>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77755>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77756>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77758>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77759>>>>>>>>>>>>>        End                                              
77759>>>>>>>>>>>>>>
77759>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77760>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77761>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77762>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77763>>>>>>>>>>>>>        
77763>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77763>>>>>>>>>>>>>        // read the name of the .ws file name.
77763>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77764>>>>>>>>>>>>>        If (bExists = True) Begin
77766>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77767>>>>>>>>>>>>>            If (iCh < 0) Begin
77769>>>>>>>>>>>>>                Function_Return asSWSFiles
77770>>>>>>>>>>>>>            End                                 
77770>>>>>>>>>>>>>>
77770>>>>>>>>>>>>>            
77770>>>>>>>>>>>>>            Repeat
77770>>>>>>>>>>>>>>
77770>>>>>>>>>>>>>                Readln channel iCh sFile
77772>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77774>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77775>>>>>>>>>>>>>                End
77775>>>>>>>>>>>>>>
77775>>>>>>>>>>>>>            Until (SeqEof = True)
77777>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77778>>>>>>>>>>>>>            
77778>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77779>>>>>>>>>>>>>            If (iSize <> 0) Begin
77781>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77782>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77782>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77782>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77783>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77784>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77785>>>>>>>>>>>>>                If (sFile <> "") Begin
77787>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77788>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77789>>>>>>>>>>>>>                    File_Exist sFile bExists
77790>>>>>>>>>>>>>                    If (bExists = True) Begin
77792>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77793>>>>>>>>>>>>>                    End
77793>>>>>>>>>>>>>>
77793>>>>>>>>>>>>>                End
77793>>>>>>>>>>>>>>
77793>>>>>>>>>>>>>                Send Destroy of hoIniFile
77794>>>>>>>>>>>>>            End
77794>>>>>>>>>>>>>>
77794>>>>>>>>>>>>>        End
77794>>>>>>>>>>>>>>
77794>>>>>>>>>>>>>        
77794>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77794>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77796>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77797>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77798>>>>>>>>>>>>>            If (bExists = False) Begin
77800>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77801>>>>>>>>>>>>>            End
77801>>>>>>>>>>>>>>
77801>>>>>>>>>>>>>        
77801>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77802>>>>>>>>>>>>>            If (iCh < 0) Begin
77804>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77805>>>>>>>>>>>>>            End                                 
77805>>>>>>>>>>>>>>
77805>>>>>>>>>>>>>            
77805>>>>>>>>>>>>>            Repeat
77805>>>>>>>>>>>>>>
77805>>>>>>>>>>>>>                Readln channel iCh sFile
77807>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77809>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77810>>>>>>>>>>>>>                End
77810>>>>>>>>>>>>>>
77810>>>>>>>>>>>>>            Until (SeqEof = True)
77812>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77813>>>>>>>>>>>>>        End
77813>>>>>>>>>>>>>>
77813>>>>>>>>>>>>>        
77813>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77814>>>>>>>>>>>>>    End_Function
77815>>>>>>>>>>>>>
77815>>>>>>>>>>>>>End_Class
77816>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77816>>>>>>>>>>>Use vWin32fh.pkg
77816>>>>>>>>>>>
77816>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77816>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77816>>>>>>>>>>>
77816>>>>>>>>>>>// We're making references to this object handle so we need it defined
77816>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77816>>>>>>>>>>>
77816>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77816>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77817>>>>>>>>>>>
77817>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77818>>>>>>>>>>>
77818>>>>>>>>>>>    Procedure Construct_Object
77820>>>>>>>>>>>        Forward Send Construct_Object
77822>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77823>>>>>>>>>>>
77823>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77824>>>>>>>>>>>
77824>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77824>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77824>>>>>>>>>>>        // methods to this class.
77824>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77825>>>>>>>>>>>        Property Boolean pbToANSI          True
77826>>>>>>>>>>>        Property Boolean pbRecnum          True
77827>>>>>>>>>>>        Property Boolean pbCopyData        True
77828>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77829>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77830>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77831>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77832>>>>>>>>>>>
77832>>>>>>>>>>>        // Driver default value settings:
77832>>>>>>>>>>>        // Note: When the object is created the corresponding values
77832>>>>>>>>>>>        // from the driver .int files are read.
77832>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77832>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77833>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77834>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77835>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77836>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77837>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77838>>>>>>>>>>>
77838>>>>>>>>>>>        // Driver "nullability" settings:
77838>>>>>>>>>>>        // Note: When the object is created the corresponding values
77838>>>>>>>>>>>        // from the driver .int files are read.
77838>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77838>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77839>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77840>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77841>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77842>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77843>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77844>>>>>>>>>>>
77844>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77844>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
77844>>>>>>>>>>>        //     driver interfaces.
77844>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77844>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77844>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77845>>>>>>>>>>>
77845>>>>>>>>>>>    End_Procedure
77846>>>>>>>>>>>
77846>>>>>>>>>>>    Procedure End_Construct_Object
77848>>>>>>>>>>>        tSQLConnection SQLConnection
77848>>>>>>>>>>>        tSQLConnection SQLConnection
77848>>>>>>>>>>>
77848>>>>>>>>>>>        Forward Send End_Construct_Object
77850>>>>>>>>>>>
77850>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77850>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77851>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77852>>>>>>>>>>>    End_Procedure
77853>>>>>>>>>>>
77853>>>>>>>>>>>    // *** Properties ***
77853>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77853>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77853>>>>>>>>>>>    // merely here for conveniance.
77853>>>>>>>>>>>    //
77853>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77853>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77853>>>>>>>>>>>    // This struct property contains all the connection data.
77853>>>>>>>>>>>    //
77853>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77855>>>>>>>>>>>        Boolean bOK
77855>>>>>>>>>>>
77855>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77856>>>>>>>>>>>
77856>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
77856>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77858>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77858>>>>>>>>>>>            Procedure_Return
77859>>>>>>>>>>>        End
77859>>>>>>>>>>>>
77859>>>>>>>>>>>
77859>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77859>>>>>>>>>>>        // be logged in already and don't want to do it again.
77859>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77861>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
77861>>>>>>>>>>>            // driver interfaces about the change & make a new login.
77861>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
77862>>>>>>>>>>>            If (bOK = False) Begin
77864>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
77865>>>>>>>>>>>>
77865>>>>>>>>>>>            End
77865>>>>>>>>>>>>
77865>>>>>>>>>>>        End
77865>>>>>>>>>>>>
77865>>>>>>>>>>>
77865>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77865>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77866>>>>>>>>>>>
77866>>>>>>>>>>>    End_Procedure
77867>>>>>>>>>>>
77867>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77867>>>>>>>>>>>    // attempt to load the driver.
77867>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
77867>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77869>>>>>>>>>>>        Boolean bOK
77869>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77870>>>>>>>>>>>        Function_Return bOK
77871>>>>>>>>>>>    End_Function
77872>>>>>>>>>>>
77872>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77872>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
77874>>>>>>>>>>>        String sAttributeValue
77874>>>>>>>>>>>        Integer iDriverID
77874>>>>>>>>>>>        Boolean bNULL bSQLDriver
77874>>>>>>>>>>>
77874>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77875>>>>>>>>>>>        If (bSQLDriver = False) Begin
77877>>>>>>>>>>>            Procedure_Return
77878>>>>>>>>>>>        End                                      
77878>>>>>>>>>>>>
77878>>>>>>>>>>>        
77878>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
77879>>>>>>>>>>>
77879>>>>>>>>>>>        // Driver default values for various data types:
77879>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77882>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77883>>>>>>>>>>>
77883>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77886>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77887>>>>>>>>>>>
77887>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
77890>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
77891>>>>>>>>>>>
77891>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
77894>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
77895>>>>>>>>>>>
77895>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
77898>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
77899>>>>>>>>>>>
77899>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
77902>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
77903>>>>>>>>>>>
77903>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
77903>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
77906>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
77907>>>>>>>>>>>
77907>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
77910>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
77911>>>>>>>>>>>
77911>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
77914>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
77915>>>>>>>>>>>
77915>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
77918>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
77919>>>>>>>>>>>
77919>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
77922>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
77923>>>>>>>>>>>
77923>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
77926>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
77927>>>>>>>>>>>
77927>>>>>>>>>>>    End_Procedure
77928>>>>>>>>>>>
77928>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
77930>>>>>>>>>>>        Boolean bOK bIsDaw
77930>>>>>>>>>>>        String sConnectionString
77930>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
77930>>>>>>>>>>>        Integer iDriverID
77930>>>>>>>>>>>
77930>>>>>>>>>>>        Move False to bOK
77931>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
77932>>>>>>>>>>>
77932>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77933>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
77934>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
77935>>>>>>>>>>>        If (iDriverID = 0) Begin
77937>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
77938>>>>>>>>>>>            Function_Return False
77939>>>>>>>>>>>        End
77939>>>>>>>>>>>>
77939>>>>>>>>>>>
77939>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
77942>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77943>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
77944>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
77945>>>>>>>>>>>        Send Destroy   of hoDriver
77946>>>>>>>>>>>
77946>>>>>>>>>>>        Function_Return bOK
77947>>>>>>>>>>>    End_Function
77948>>>>>>>>>>>
77948>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
77950>>>>>>>>>>>        tSQLConnection SQLConnection
77950>>>>>>>>>>>        tSQLConnection SQLConnection
77950>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77951>>>>>>>>>>>        Function_Return SQLConnection
77952>>>>>>>>>>>    End_Function
77953>>>>>>>>>>>
77953>>>>>>>>>>>    Procedure Set psConnectionID String sValue
77955>>>>>>>>>>>        tSQLConnection SQLConnection
77955>>>>>>>>>>>        tSQLConnection SQLConnection
77955>>>>>>>>>>>
77955>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77956>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
77958>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
77959>>>>>>>>>>>        End
77959>>>>>>>>>>>>
77959>>>>>>>>>>>
77959>>>>>>>>>>>        // Else we might want to change the current connection ID
77959>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
77962>>>>>>>>>>>            Move False to Err
77963>>>>>>>>>>>            Logout SQLConnection.sDriverID
77964>>>>>>>>>>>            // This will also make a login to the new server.
77964>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
77965>>>>>>>>>>>        End
77965>>>>>>>>>>>>
77965>>>>>>>>>>>        Set pSQLConnection to SQLConnection
77966>>>>>>>>>>>    End_Procedure
77967>>>>>>>>>>>
77967>>>>>>>>>>>    Function psConnectionID Returns String
77969>>>>>>>>>>>        tSQLConnection SQLConnection
77969>>>>>>>>>>>        tSQLConnection SQLConnection
77969>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77970>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
77971>>>>>>>>>>>    End_Function
77972>>>>>>>>>>>
77972>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
77972>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
77972>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
77972>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
77972>>>>>>>>>>>    Procedure Set psDriverID String sValue
77974>>>>>>>>>>>        tSQLConnection SQLConnection
77974>>>>>>>>>>>        tSQLConnection SQLConnection
77974>>>>>>>>>>>        Get pSQLConnection to SQLConnection
77975>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
77976>>>>>>>>>>>        Set pSQLConnection to SQLConnection
77977>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
77979>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77980>>>>>>>>>>>        End
77980>>>>>>>>>>>>
77980>>>>>>>>>>>    End_Procedure
77981>>>>>>>>>>>
77981>>>>>>>>>>>    Function psDriverID Returns String
77983>>>>>>>>>>>        tSQLConnection SQLConnection
77983>>>>>>>>>>>        tSQLConnection SQLConnection
77983>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77984>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
77986>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
77987>>>>>>>>>>>        End
77987>>>>>>>>>>>>
77987>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
77988>>>>>>>>>>>    End_Function
77989>>>>>>>>>>>
77989>>>>>>>>>>>    Procedure Set psConnectionString String sValue
77991>>>>>>>>>>>        tSQLConnection SQLConnection
77991>>>>>>>>>>>        tSQLConnection SQLConnection
77991>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77992>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
77993>>>>>>>>>>>        Set pSQLConnection to SQLConnection
77994>>>>>>>>>>>    End_Procedure
77995>>>>>>>>>>>
77995>>>>>>>>>>>    Function psConnectionString Returns String
77997>>>>>>>>>>>        tSQLConnection SQLConnection
77997>>>>>>>>>>>        tSQLConnection SQLConnection
77997>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77998>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
77999>>>>>>>>>>>    End_Function
78000>>>>>>>>>>>
78000>>>>>>>>>>>    Procedure Set psServer String sValue
78002>>>>>>>>>>>        tSQLConnection SQLConnection
78002>>>>>>>>>>>        tSQLConnection SQLConnection
78002>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78003>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78004>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78005>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78006>>>>>>>>>>>    End_Procedure
78007>>>>>>>>>>>
78007>>>>>>>>>>>    Function psServer Returns String
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78010>>>>>>>>>>>        Function_Return SQLConnection.sServer
78011>>>>>>>>>>>    End_Function
78012>>>>>>>>>>>
78012>>>>>>>>>>>    Procedure Set psDatabase String sValue
78014>>>>>>>>>>>        tSQLConnection SQLConnection
78014>>>>>>>>>>>        tSQLConnection SQLConnection
78014>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78015>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78016>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78017>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78018>>>>>>>>>>>    End_Procedure
78019>>>>>>>>>>>
78019>>>>>>>>>>>    Function psDatabase Returns String
78021>>>>>>>>>>>        tSQLConnection SQLConnection
78021>>>>>>>>>>>        tSQLConnection SQLConnection
78021>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78022>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78023>>>>>>>>>>>    End_Function
78024>>>>>>>>>>>
78024>>>>>>>>>>>    Procedure Set psUserID String sValue
78026>>>>>>>>>>>        tSQLConnection SQLConnection
78026>>>>>>>>>>>        tSQLConnection SQLConnection
78026>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78027>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78028>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78029>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78030>>>>>>>>>>>    End_Procedure
78031>>>>>>>>>>>
78031>>>>>>>>>>>    Function psUserID Returns String
78033>>>>>>>>>>>        tSQLConnection SQLConnection
78033>>>>>>>>>>>        tSQLConnection SQLConnection
78033>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78034>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78035>>>>>>>>>>>    End_Function
78036>>>>>>>>>>>
78036>>>>>>>>>>>    // This is the uncrypted password
78036>>>>>>>>>>>    Procedure Set psPassword String sValue
78038>>>>>>>>>>>        tSQLConnection SQLConnection
78038>>>>>>>>>>>        tSQLConnection SQLConnection
78038>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78039>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78040>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78041>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78042>>>>>>>>>>>    End_Procedure
78043>>>>>>>>>>>
78043>>>>>>>>>>>    Function psPassword Returns String
78045>>>>>>>>>>>        tSQLConnection SQLConnection
78045>>>>>>>>>>>        tSQLConnection SQLConnection
78045>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78046>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78047>>>>>>>>>>>    End_Function
78048>>>>>>>>>>>
78048>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78050>>>>>>>>>>>        tSQLConnection SQLConnection
78050>>>>>>>>>>>        tSQLConnection SQLConnection
78050>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78051>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78052>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78053>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78054>>>>>>>>>>>    End_Procedure
78055>>>>>>>>>>>
78055>>>>>>>>>>>    Function pbTrusted Returns Boolean
78057>>>>>>>>>>>        tSQLConnection SQLConnection
78057>>>>>>>>>>>        tSQLConnection SQLConnection
78057>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78058>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78059>>>>>>>>>>>    End_Function
78060>>>>>>>>>>>
78060>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78060>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78060>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78060>>>>>>>>>>>    //     the central pSQLConnection "hub".
78060>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78062>>>>>>>>>>>        tSQLConnection SQLConnection
78062>>>>>>>>>>>        tSQLConnection SQLConnection
78062>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78063>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78064>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78065>>>>>>>>>>>    End_Procedure
78066>>>>>>>>>>>
78066>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78068>>>>>>>>>>>        tSQLConnection SQLConnection
78068>>>>>>>>>>>        tSQLConnection SQLConnection
78068>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78069>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78070>>>>>>>>>>>    End_Function
78071>>>>>>>>>>>
78071>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78073>>>>>>>>>>>        tSQLConnection SQLConnection
78073>>>>>>>>>>>        tSQLConnection SQLConnection
78073>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78074>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78075>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78076>>>>>>>>>>>    End_Procedure
78077>>>>>>>>>>>
78077>>>>>>>>>>>    Function piDbType Returns Integer
78079>>>>>>>>>>>        tSQLConnection SQLConnection
78079>>>>>>>>>>>        tSQLConnection SQLConnection
78079>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78080>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78081>>>>>>>>>>>    End_Function
78082>>>>>>>>>>>
78082>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78084>>>>>>>>>>>        tSQLConnection SQLConnection
78084>>>>>>>>>>>        tSQLConnection SQLConnection
78084>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78085>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78086>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78087>>>>>>>>>>>    End_Procedure
78088>>>>>>>>>>>
78088>>>>>>>>>>>    Function psBaseTableSpace Returns String
78090>>>>>>>>>>>        tSQLConnection SQLConnection
78090>>>>>>>>>>>        tSQLConnection SQLConnection
78090>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78091>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78092>>>>>>>>>>>    End_Function
78093>>>>>>>>>>>
78093>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78096>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78097>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78098>>>>>>>>>>>    End_Procedure
78099>>>>>>>>>>>
78099>>>>>>>>>>>    Function psIndexTableSpace Returns String
78101>>>>>>>>>>>        tSQLConnection SQLConnection
78101>>>>>>>>>>>        tSQLConnection SQLConnection
78101>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78102>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78103>>>>>>>>>>>    End_Function
78104>>>>>>>>>>>
78104>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78106>>>>>>>>>>>        tSQLConnection SQLConnection
78106>>>>>>>>>>>        tSQLConnection SQLConnection
78106>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78107>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78108>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78109>>>>>>>>>>>    End_Procedure
78110>>>>>>>>>>>
78110>>>>>>>>>>>    Function psLongTableSpace Returns String
78112>>>>>>>>>>>        tSQLConnection SQLConnection
78112>>>>>>>>>>>        tSQLConnection SQLConnection
78112>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78113>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78114>>>>>>>>>>>    End_Function
78115>>>>>>>>>>>
78115>>>>>>>>>>>    Procedure Set psSchema String sValue
78117>>>>>>>>>>>        tSQLConnection SQLConnection
78117>>>>>>>>>>>        tSQLConnection SQLConnection
78117>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78118>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78119>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78120>>>>>>>>>>>    End_Procedure
78121>>>>>>>>>>>
78121>>>>>>>>>>>    Function psSchema Returns String
78123>>>>>>>>>>>        tSQLConnection SQLConnection
78123>>>>>>>>>>>        tSQLConnection SQLConnection
78123>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78124>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78125>>>>>>>>>>>    End_Function
78126>>>>>>>>>>>
78126>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78128>>>>>>>>>>>        tSQLConnection SQLConnection
78128>>>>>>>>>>>        tSQLConnection SQLConnection
78128>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78129>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78130>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78131>>>>>>>>>>>    End_Procedure
78132>>>>>>>>>>>
78132>>>>>>>>>>>    Function pbEnabled Returns Boolean
78134>>>>>>>>>>>        tSQLConnection SQLConnection
78134>>>>>>>>>>>        tSQLConnection SQLConnection
78134>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78135>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78136>>>>>>>>>>>    End_Function
78137>>>>>>>>>>>
78137>>>>>>>>>>>
78137>>>>>>>>>>>    // ************************************
78137>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78139>>>>>>>>>>>        tSQLConnection SQLConnection
78139>>>>>>>>>>>        tSQLConnection SQLConnection
78139>>>>>>>>>>>
78139>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78139>>>>>>>>>>>        // deferr reading SQL connection values until later.
78139>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78141>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78141>>>>>>>>>>>            If (ghoConnection > 0) Begin
78143>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78144>>>>>>>>>>>            End
78144>>>>>>>>>>>>
78144>>>>>>>>>>>
78144>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78144>>>>>>>>>>>            // object is used.
78144>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78146>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78147>>>>>>>>>>>            End
78147>>>>>>>>>>>>
78147>>>>>>>>>>>        End
78147>>>>>>>>>>>>
78147>>>>>>>>>>>
78147>>>>>>>>>>>        Function_Return SQLConnection
78148>>>>>>>>>>>    End_Function
78149>>>>>>>>>>>
78149>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78149>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78151>>>>>>>>>>>        tConnection Connection
78151>>>>>>>>>>>        tConnection Connection
78151>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78151>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78151>>>>>>>>>>>        Integer iRetval iDbType
78151>>>>>>>>>>>        Boolean bOK bConnected
78151>>>>>>>>>>>        String sConnectionID
78151>>>>>>>>>>>
78151>>>>>>>>>>>            tConnection[] Connections
78151>>>>>>>>>>>            tConnection[] Connections
78152>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78152>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78152>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78152>>>>>>>>>>>            //   we then generate an error and abort the program...
78152>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78153>>>>>>>>>>>            If (bOK = False) Begin
78155>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78156>>>>>>>>>>>>
78156>>>>>>>>>>>                Abort
78157>>>>>>>>>>>>
78157>>>>>>>>>>>            End
78157>>>>>>>>>>>>
78157>>>>>>>>>>>            If (sConnectionID = "") Begin
78159>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78160>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78162>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78163>>>>>>>>>>>                End
78163>>>>>>>>>>>>
78163>>>>>>>>>>>            End
78163>>>>>>>>>>>>
78163>>>>>>>>>>>
78163>>>>>>>>>>>            Move 0 to iRetval
78164>>>>>>>>>>>            // DAW DF19 connection info:
78164>>>>>>>>>>>            // We first check that the connection is OK:
78164>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78165>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78165>>>>>>>>>>>            If (iRetval = -1) Begin
78167>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78168>>>>>>>>>>>            End
78168>>>>>>>>>>>>
78168>>>>>>>>>>>
78168>>>>>>>>>>>            If (sConnectionID <> "") Begin
78170>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78171>>>>>>>>>>>            End
78171>>>>>>>>>>>>
78171>>>>>>>>>>>            If (Connection.sId = "") Begin
78173>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78174>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78175>>>>>>>>>>>            End
78175>>>>>>>>>>>>
78175>>>>>>>>>>>
78175>>>>>>>>>>>            // DUF connection info struct property:
78175>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78176>>>>>>>>>>>
78176>>>>>>>>>>>            Move Connection.sId to sConnectionID
78177>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78178>>>>>>>>>>>
78178>>>>>>>>>>>            If (bConnected = False) Begin
78180>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78181>>>>>>>>>>>                If (iRetval <> 0) Begin
78183>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78184>>>>>>>>>>>                    Send Exit_Application
78185>>>>>>>>>>>                End
78185>>>>>>>>>>>>
78185>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78186>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78186>>>>>>>>>>>                // been changed in the DAW db login dialog.
78186>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78187>>>>>>>>>>>            End
78187>>>>>>>>>>>>
78187>>>>>>>>>>>
78187>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78188>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78189>>>>>>>>>>>
78189>>>>>>>>>>>            // Not used in DUF:
78189>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78189>>>>>>>>>>>
78189>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78190>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78191>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78192>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78193>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78194>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78195>>>>>>>>>>>
78195>>>>>>>>>>>            // Not used in DUF:
78195>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78195>>>>>>>>>>>
78195>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78195>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78195>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78197>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78198>>>>>>>>>>>            End
78198>>>>>>>>>>>>
78198>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78200>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78201>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78203>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78204>>>>>>>>>>>                End
78204>>>>>>>>>>>>
78204>>>>>>>>>>>            End
78204>>>>>>>>>>>>
78204>>>>>>>>>>>
78204>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78205>>>>>>>>>>>
78205>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78205>>>>>>>>>>>            // the value from the driver id:
78205>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78206>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78206>>>>>>>>>>>            Get piDbType                                     to iDbType
78207>>>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78209>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78210>>>>>>>>>>>            End
78210>>>>>>>>>>>>
78210>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78211>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78212>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78213>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78214>>>>>>>>>>>
78214>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78214>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78215>>>>>>>>>>>
78215>>>>>>>>>>>        Function_Return SQLConnection
78216>>>>>>>>>>>    End_Function
78217>>>>>>>>>>>
78217>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78217>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78217>>>>>>>>>>>    // connection id for a particular driver.
78217>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78217>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78217>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78217>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78217>>>>>>>>>>>    // connections of the DAW cConnect class.
78217>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78219>>>>>>>>>>>        tConnection[] ConnIdArray
78219>>>>>>>>>>>        tConnection[] ConnIdArray
78220>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78220>>>>>>>>>>>        Boolean bEnabled bFound
78220>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78220>>>>>>>>>>>
78220>>>>>>>>>>>        Move False to bFound
78221>>>>>>>>>>>        If (ghoConnection > 0) Begin
78223>>>>>>>>>>>
78223>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78223>>>>>>>>>>>            Get psDriverID to sDriverID
78224>>>>>>>>>>>
78224>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78225>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78225>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78226>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78227>>>>>>>>>>>            Decrement iSize
78228>>>>>>>>>>>            For iCount from 0 to iSize
78234>>>>>>>>>>>>
78234>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78235>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78236>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78237>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78237>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78237>>>>>>>>>>>                If (sConnectionID = "") Begin
78239>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78240>>>>>>>>>>>                End
78240>>>>>>>>>>>>
78240>>>>>>>>>>>                Else Begin
78241>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78243>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78244>>>>>>>>>>>                    End
78244>>>>>>>>>>>>
78244>>>>>>>>>>>                End
78244>>>>>>>>>>>>
78244>>>>>>>>>>>
78244>>>>>>>>>>>                If (bFound = True) Begin
78246>>>>>>>>>>>                    Increment iConnectionIDCounter
78247>>>>>>>>>>>                End
78247>>>>>>>>>>>>
78247>>>>>>>>>>>            Loop
78248>>>>>>>>>>>>
78248>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78249>>>>>>>>>>>            If (bFound = True) Begin
78251>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78252>>>>>>>>>>>            End
78252>>>>>>>>>>>>
78252>>>>>>>>>>>        End
78252>>>>>>>>>>>>
78252>>>>>>>>>>>
78252>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78252>>>>>>>>>>>        // but no DFConn.ini record has been created.
78252>>>>>>>>>>>        If (iSize = -1) Begin
78254>>>>>>>>>>>            Move True to bFound
78255>>>>>>>>>>>        End
78255>>>>>>>>>>>>
78255>>>>>>>>>>>
78255>>>>>>>>>>>        Function_Return bFound
78256>>>>>>>>>>>    End_Function
78257>>>>>>>>>>>
78257>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78257>>>>>>>>>>>    // create a connection to the server.
78257>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78259>>>>>>>>>>>        String sPath sFileName
78259>>>>>>>>>>>        Boolean bExists bActive
78259>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78259>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78260>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78260>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78260>>>>>>>>>>>        Handle hoIniFile
78260>>>>>>>>>>>        Integer iSize iCount iRetval
78260>>>>>>>>>>>
78260>>>>>>>>>>>        Get psIniFilePath to sPath
78261>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78262>>>>>>>>>>>        If (sPath = "") Begin
78264>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78265>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78266>>>>>>>>>>>        End
78266>>>>>>>>>>>>
78266>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78267>>>>>>>>>>>        Get psIniFileName to sFileName
78268>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78269>>>>>>>>>>>
78269>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78270>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78271>>>>>>>>>>>        If (iSize = 0) Begin
78273>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78273>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78273>>>>>>>>>>>            // in the cApplication object.
78273>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78274>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78276>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78277>>>>>>>>>>>            End
78277>>>>>>>>>>>>
78277>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78278>>>>>>>>>>>            Move 1 to iSize
78279>>>>>>>>>>>        End
78279>>>>>>>>>>>>
78279>>>>>>>>>>>
78279>>>>>>>>>>>        Move False to bActive
78280>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78280>>>>>>>>>>>        Decrement iSize
78281>>>>>>>>>>>        For iCount from 0 to iSize
78287>>>>>>>>>>>>
78287>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78288>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78290>>>>>>>>>>>                Move True to bActive
78291>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78292>>>>>>>>>>>            End
78292>>>>>>>>>>>>
78292>>>>>>>>>>>        Loop
78293>>>>>>>>>>>>
78293>>>>>>>>>>>
78293>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78293>>>>>>>>>>>        If (bActive = False) Begin
78295>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78296>>>>>>>>>>>        End
78296>>>>>>>>>>>>
78296>>>>>>>>>>>
78296>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78297>>>>>>>>>>>
78297>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78298>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78299>>>>>>>>>>>
78299>>>>>>>>>>>        Function_Return SQLConnection
78300>>>>>>>>>>>    End_Function
78301>>>>>>>>>>>
78301>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78303>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78304>>>>>>>>>>>    End_Procedure
78305>>>>>>>>>>>
78305>>>>>>>>>>>    Function psIniFilePath Returns String
78307>>>>>>>>>>>        String sRetval
78307>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78308>>>>>>>>>>>        Function_Return sRetval
78309>>>>>>>>>>>    End_Function
78310>>>>>>>>>>>
78310>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78312>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78313>>>>>>>>>>>    End_Procedure
78314>>>>>>>>>>>
78314>>>>>>>>>>>    Function psIniFileName Returns String
78316>>>>>>>>>>>        String sRetval
78316>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78317>>>>>>>>>>>        Function_Return sRetval
78318>>>>>>>>>>>    End_Function
78319>>>>>>>>>>>
78319>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78321>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78322>>>>>>>>>>>    End_Procedure
78323>>>>>>>>>>>
78323>>>>>>>>>>>    Function psIniSectionName Returns String
78325>>>>>>>>>>>        String sRetval
78325>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78326>>>>>>>>>>>        Function_Return sRetval
78327>>>>>>>>>>>    End_Function
78328>>>>>>>>>>>
78328>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78330>>>>>>>>>>>        Handle ho
78330>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78331>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78332>>>>>>>>>>>    End_Procedure
78333>>>>>>>>>>>
78333>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78335>>>>>>>>>>>        Handle ho
78335>>>>>>>>>>>        String sRetval
78335>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78336>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78337>>>>>>>>>>>        Function_Return sRetval
78338>>>>>>>>>>>    End_Function
78339>>>>>>>>>>>
78339>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78341>>>>>>>>>>>        Handle ho
78341>>>>>>>>>>>        Boolean bRetval
78341>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78342>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78343>>>>>>>>>>>        Function_Return bRetval
78344>>>>>>>>>>>    End_Function
78345>>>>>>>>>>>
78345>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78347>>>>>>>>>>>        Handle ho
78347>>>>>>>>>>>        Boolean bRetval
78347>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78348>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78349>>>>>>>>>>>        Function_Return bRetval
78350>>>>>>>>>>>    End_Function
78351>>>>>>>>>>>
78351>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78353>>>>>>>>>>>        Handle ho
78353>>>>>>>>>>>        String sRetval
78353>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78354>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78355>>>>>>>>>>>        Function_Return sRetval
78356>>>>>>>>>>>    End_Function
78357>>>>>>>>>>>
78357>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78359>>>>>>>>>>>        Handle ho
78359>>>>>>>>>>>        String sRetval
78359>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78360>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78361>>>>>>>>>>>        Function_Return sRetval
78362>>>>>>>>>>>    End_Function
78363>>>>>>>>>>>
78363>>>>>>>>>>>    // *** Main Connection Message ***
78363>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78365>>>>>>>>>>>        Handle hoDriver
78365>>>>>>>>>>>        String sConnectionString sError
78365>>>>>>>>>>>        Boolean bLoginSuccessful
78365>>>>>>>>>>>
78365>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78366>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78367>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78368>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78369>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78371>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78372>>>>>>>>>>>>
78372>>>>>>>>>>>            If (bExitProgram = True) Begin
78374>>>>>>>>>>>                Send Exit_Application
78375>>>>>>>>>>>            End
78375>>>>>>>>>>>>
78375>>>>>>>>>>>        End
78375>>>>>>>>>>>>
78375>>>>>>>>>>>        Send Destroy of hoDriver
78376>>>>>>>>>>>    End_Procedure
78377>>>>>>>>>>>
78377>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78379>>>>>>>>>>>        Integer iRetval
78379>>>>>>>>>>>        Handle hoCLI
78379>>>>>>>>>>>        String sDriverID
78379>>>>>>>>>>>
78379>>>>>>>>>>>        Get psDriverID to sDriverID
78380>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78381>>>>>>>>>>>        If (hoCLI <> 0) Begin
78383>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78384>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78385>>>>>>>>>>>            Send Destroy of hoCLI
78386>>>>>>>>>>>        End
78386>>>>>>>>>>>>
78386>>>>>>>>>>>
78386>>>>>>>>>>>        Function_Return iRetval
78387>>>>>>>>>>>    End_Function
78388>>>>>>>>>>>
78388>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78390>>>>>>>>>>>        tSQLConnection SQLConnection
78390>>>>>>>>>>>        tSQLConnection SQLConnection
78390>>>>>>>>>>>
78390>>>>>>>>>>>        Set psDriverID to sDriverID
78391>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78392>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78393>>>>>>>>>>>    End_Procedure
78394>>>>>>>>>>>
78394>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78394>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78394>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78394>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78394>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78394>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78394>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78394>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78396>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78396>>>>>>>>>>>        Handle hoCLI
78396>>>>>>>>>>>        String sID
78396>>>>>>>>>>>
78396>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78398>>>>>>>>>>>            Procedure_Return
78399>>>>>>>>>>>        End
78399>>>>>>>>>>>>
78399>>>>>>>>>>>
78399>>>>>>>>>>>        Move 0 to iResult
78400>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78401>>>>>>>>>>>        If (hoCLI <> 0) Begin
78403>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78404>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78405>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78408>>>>>>>>>>>            Decrement iNumConn
78409>>>>>>>>>>>            For iConn from 0 to iNumConn
78415>>>>>>>>>>>>
78415>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78418>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78420>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78421>>>>>>>>>>>                End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>            Loop
78422>>>>>>>>>>>>
78422>>>>>>>>>>>            Send Destroy of hoCLI
78423>>>>>>>>>>>        End
78423>>>>>>>>>>>>
78423>>>>>>>>>>>
78423>>>>>>>>>>>    End_Procedure
78424>>>>>>>>>>>
78424>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78426>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78426>>>>>>>>>>>        Handle hoCLI
78426>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78426>>>>>>>>>>>        tSQLConnection SQLConnection
78426>>>>>>>>>>>        tSQLConnection SQLConnection
78426>>>>>>>>>>>        Boolean bTrusted
78426>>>>>>>>>>>
78426>>>>>>>>>>>        Move 0 to iResult
78427>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78428>>>>>>>>>>>        If (hoCLI <> 0) Begin
78430>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78431>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78432>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78435>>>>>>>>>>>            Decrement iNumConn
78436>>>>>>>>>>>            For iConn from 0 to iNumConn
78442>>>>>>>>>>>>
78442>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78445>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78447>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78448>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78451>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78454>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78455>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78458>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78459>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78460>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78461>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78462>>>>>>>>>>>
78462>>>>>>>>>>>                    Case Begin
78462>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78464>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78465>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78466>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78467>>>>>>>>>>>                            Case Break
78468>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78471>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78472>>>>>>>>>>>                            Case Break
78473>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78476>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78477>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78479>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78480>>>>>>>>>>>                            End
78480>>>>>>>>>>>>
78480>>>>>>>>>>>                            Case Break
78481>>>>>>>>>>>                        Case Else
78481>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78482>>>>>>>>>>>>
78482>>>>>>>>>>>                            Case Break
78483>>>>>>>>>>>                    Case End
78483>>>>>>>>>>>                End
78483>>>>>>>>>>>>
78483>>>>>>>>>>>            Loop
78484>>>>>>>>>>>>
78484>>>>>>>>>>>            Send Destroy of hoCLI
78485>>>>>>>>>>>        End
78485>>>>>>>>>>>>
78485>>>>>>>>>>>
78485>>>>>>>>>>>        Function_Return SQLConnection
78486>>>>>>>>>>>    End_Function
78487>>>>>>>>>>>
78487>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78489>>>>>>>>>>>        String  sCurrentDriver
78489>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78489>>>>>>>>>>>
78489>>>>>>>>>>>        Move 0 to iDriver
78490>>>>>>>>>>>        Move 0 to iCount
78491>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78494>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78500>>>>>>>>>>>>
78500>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78503>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78505>>>>>>>>>>>                Function_Return iCount
78506>>>>>>>>>>>            End
78506>>>>>>>>>>>>
78506>>>>>>>>>>>        Loop
78507>>>>>>>>>>>>
78507>>>>>>>>>>>
78507>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78507>>>>>>>>>>>        If (iDriver = 0) Begin
78509>>>>>>>>>>>            Move 0 to LastErr
78510>>>>>>>>>>>            Load_Driver sDriverID
78511>>>>>>>>>>>            // If driver could not be loaded.
78511>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78513>>>>>>>>>>>                Move -1 to iCount
78514>>>>>>>>>>>            End
78514>>>>>>>>>>>>
78514>>>>>>>>>>>        End
78514>>>>>>>>>>>>
78514>>>>>>>>>>>        Function_Return iCount
78515>>>>>>>>>>>    End_Function
78516>>>>>>>>>>>
78516>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78516>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78518>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78518>>>>>>>>>>>        Boolean bTrusted bSilent
78518>>>>>>>>>>>        Integer iRetval
78518>>>>>>>>>>>
78518>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78519>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78520>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78521>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78522>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78523>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78524>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78525>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78526>>>>>>>>>>>
78526>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78527>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78527>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78528>>>>>>>>>>>    End_Procedure
78529>>>>>>>>>>>
78529>>>>>>>>>>>    // Called when the object is constructed.
78529>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78529>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78529>>>>>>>>>>>    // the database is needed.
78529>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78531>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78531>>>>>>>>>>>        Integer iDriver iRetval
78531>>>>>>>>>>>        Handle hoCLI
78531>>>>>>>>>>>        Boolean bOK bSilent
78531>>>>>>>>>>>
78531>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78532>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78533>>>>>>>>>>>        Get psConnectionString to sConnectionString
78534>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78534>>>>>>>>>>>        Get psDriverID to sDriverID
78535>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78536>>>>>>>>>>>        If (bOK = False) Begin
78538>>>>>>>>>>>            Function_Return False
78539>>>>>>>>>>>        End
78539>>>>>>>>>>>>
78539>>>>>>>>>>>
78539>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78540>>>>>>>>>>>        // If driver not loaded; load it.
78540>>>>>>>>>>>        If (iDriver = 0) Begin
78542>>>>>>>>>>>            Load_Driver sDriverID
78543>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78544>>>>>>>>>>>        End
78544>>>>>>>>>>>>
78544>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78544>>>>>>>>>>>        If (iDriver = 0) Begin
78546>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78547>>>>>>>>>>>>
78547>>>>>>>>>>>            Function_Return False
78548>>>>>>>>>>>        End           
78548>>>>>>>>>>>>
78548>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78551>>>>>>>>>>>        
78551>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78552>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78553>>>>>>>>>>>        // Delete the connection first; in case it exists
78553>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78554>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78555>>>>>>>>>>>        Send Destroy of hoCLI
78556>>>>>>>>>>>
78556>>>>>>>>>>>        Function_Return (iRetval = 0)
78557>>>>>>>>>>>    End_Function
78558>>>>>>>>>>>
78558>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78560>>>>>>>>>>>        Boolean bOK
78560>>>>>>>>>>>
78560>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78561>>>>>>>>>>>
78561>>>>>>>>>>>        If (bOK = False) Begin
78563>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78564>>>>>>>>>>>>
78564>>>>>>>>>>>            Function_Return False
78565>>>>>>>>>>>        End
78565>>>>>>>>>>>>
78565>>>>>>>>>>>
78565>>>>>>>>>>>        Function_Return True
78566>>>>>>>>>>>    End_Function
78567>>>>>>>>>>>
78567>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78569>>>>>>>>>>>        Boolean bOK
78569>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78570>>>>>>>>>>>        Function_Return bOK
78571>>>>>>>>>>>    End_Function
78572>>>>>>>>>>>
78572>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78574>>>>>>>>>>>        Handle hoIniFile
78574>>>>>>>>>>>        String sConnect
78574>>>>>>>>>>>
78574>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78575>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78576>>>>>>>>>>>
78576>>>>>>>>>>>        Function_Return sConnect
78577>>>>>>>>>>>    End_Function
78578>>>>>>>>>>>
78578>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78578>>>>>>>>>>>    // Pass a complete driver connection string
78578>>>>>>>>>>>    // Returns the following as a struct:
78578>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78578>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78578>>>>>>>>>>>    //
78578>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78580>>>>>>>>>>>        tSQLConnection SQLConnection
78580>>>>>>>>>>>        tSQLConnection SQLConnection
78580>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78580>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78580>>>>>>>>>>>        Integer iPos
78580>>>>>>>>>>>
78580>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78581>>>>>>>>>>>        If (bOK = False) Begin
78583>>>>>>>>>>>            Function_Return SQLConnection
78584>>>>>>>>>>>        End
78584>>>>>>>>>>>>
78584>>>>>>>>>>>
78584>>>>>>>>>>>        Move False to bTrusted
78585>>>>>>>>>>>        Move False to bSilent
78586>>>>>>>>>>>
78586>>>>>>>>>>>        Case Begin
78586>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78588>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78589>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78590>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78591>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78592>>>>>>>>>>>                If (bTrusted = False) Begin
78594>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78595>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78596>>>>>>>>>>>                End
78596>>>>>>>>>>>>
78596>>>>>>>>>>>                Case Break
78597>>>>>>>>>>>
78597>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78600>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78602>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78603>>>>>>>>>>>                End
78603>>>>>>>>>>>>
78603>>>>>>>>>>>                Else Begin
78604>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78605>>>>>>>>>>>                End
78605>>>>>>>>>>>>
78605>>>>>>>>>>>
78605>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78606>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78607>>>>>>>>>>>                If (bTrusted = False) Begin
78609>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78610>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78611>>>>>>>>>>>                End
78611>>>>>>>>>>>>
78611>>>>>>>>>>>                Case Break
78612>>>>>>>>>>>
78612>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78615>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78616>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78617>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78618>>>>>>>>>>>                Case Break
78619>>>>>>>>>>>
78619>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78622>>>>>>>>>>>                Break
78623>>>>>>>>>>>        Case End
78623>>>>>>>>>>>
78623>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78624>>>>>>>>>>>
78624>>>>>>>>>>>        // bSilent?
78624>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78625>>>>>>>>>>>        If (iPos = 0) Begin
78627>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78628>>>>>>>>>>>        End
78628>>>>>>>>>>>>
78628>>>>>>>>>>>        If (iPos = 0) Begin
78630>>>>>>>>>>>            Move "0"                                                            to sValue
78631>>>>>>>>>>>        End
78631>>>>>>>>>>>>
78631>>>>>>>>>>>        Else Begin
78632>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78633>>>>>>>>>>>        End
78633>>>>>>>>>>>>
78633>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78634>>>>>>>>>>>
78634>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78635>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78636>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78637>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78638>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78639>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78640>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78641>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78642>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78643>>>>>>>>>>>
78643>>>>>>>>>>>        Function_Return SQLConnection
78644>>>>>>>>>>>    End_Function
78645>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78645>>>>>>>>>>>>
78645>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78647>>>>>>>>>>>>    Integer iStart iEnd
78647>>>>>>>>>>>>    String sRetval
78647>>>>>>>>>>>>
78647>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78648>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78649>>>>>>>>>>>>    If (iStart = 0) Begin
78651>>>>>>>>>>>>        Function_Return ""
78652>>>>>>>>>>>>    End
78652>>>>>>>>>>>>>
78652>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78653>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78654>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78656>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78657>>>>>>>>>>>>    End
78657>>>>>>>>>>>>>
78657>>>>>>>>>>>>    Else Begin
78658>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78659>>>>>>>>>>>>    End
78659>>>>>>>>>>>>>
78659>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78661>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78662>>>>>>>>>>>>        Decrement iEnd
78663>>>>>>>>>>>>    End
78663>>>>>>>>>>>>>
78663>>>>>>>>>>>>    If (iEnd <> 0) Begin
78665>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78666>>>>>>>>>>>>    End
78666>>>>>>>>>>>>>
78666>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78667>>>>>>>>>>>>
78667>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78668>>>>>>>>>>>>End_Function
78669>>>>>>>>>>>>
78669>>>>>>>>>>>>
78669>>>>>>>>>>>
78669>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78669>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78671>>>>>>>>>>>        Handle ho
78671>>>>>>>>>>>        Integer iIndex
78671>>>>>>>>>>>        Boolean bRetval bOK
78671>>>>>>>>>>>        tSQLConnection SQLConnection
78671>>>>>>>>>>>        tSQLConnection SQLConnection
78671>>>>>>>>>>>
78671>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78672>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78673>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78674>>>>>>>>>>>        If (iIndex = -1) Begin
78676>>>>>>>>>>>            Function_Return False
78677>>>>>>>>>>>        End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>
78677>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78678>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78679>>>>>>>>>>>        If (ghoConnection > 0) Begin
78681>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78682>>>>>>>>>>>            If (iIndex <> -1) Begin
78684>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78685>>>>>>>>>>>            End
78685>>>>>>>>>>>>
78685>>>>>>>>>>>        End
78685>>>>>>>>>>>>
78685>>>>>>>>>>>
78685>>>>>>>>>>>        Function_Return bRetval
78686>>>>>>>>>>>    End_Function
78687>>>>>>>>>>>
78687>>>>>>>>>>>End_Class
78688>>>>>>>>>Use vWin32fh.pkg
78688>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\DfAbout.pkg)
78688>>>>>>>>>>>Use LanguageText.pkg
78688>>>>>>>>>>>Use Windows.pkg
78688>>>>>>>>>>>Use Dfclient.pkg
78688>>>>>>>>>>>Use DFbitmap.pkg
78688>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78688>>>>>>>>>>>Use cRichEdit.pkg
78688>>>>>>>>>>>Use cTextEdit.pkg
78688>>>>>>>>>>>Use cRichEdit.pkg
78688>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 23.0\Pkg\gFormatNumbers.pkg)
78688>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cFormatter.pkg)
78688>>>>>>>>>>>>>>>Use VDFBase.pkg
78688>>>>>>>>>>>>>>>
78688>>>>>>>>>>>>>>>Class cFormatter is an cObject
78689>>>>>>>>>>>>>>>    
78689>>>>>>>>>>>>>>>    Procedure Construct_object
78691>>>>>>>>>>>>>>>        Integer iCh
78691>>>>>>>>>>>>>>>        Forward Send construct_object
78693>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78694>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78695>>>>>>>>>>>>>>>        
78695>>>>>>>>>>>>>>>        Property String  psLeft
78696>>>>>>>>>>>>>>>        Property String  psright
78697>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78698>>>>>>>>>>>>>>>        Property Integer piPoints
78699>>>>>>>>>>>>>>>        
78699>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78700>>>>>>>>>>>>>>>        Property String  psCurPosright
78701>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78702>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78703>>>>>>>>>>>>>>>        
78703>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78704>>>>>>>>>>>>>>>        Property String  psCurNegright
78705>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78706>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78707>>>>>>>>>>>>>>>        
78707>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78708>>>>>>>>>>>>>>>        Property String  psNumPosright
78709>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78710>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78711>>>>>>>>>>>>>>>        
78711>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78712>>>>>>>>>>>>>>>        Property String  psNumNegright
78713>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78714>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78715>>>>>>>>>>>>>>>        
78715>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78716>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78717>>>>>>>>>>>>>>>        
78717>>>>>>>>>>>>>>>    End_Procedure
78718>>>>>>>>>>>>>>>    
78718>>>>>>>>>>>>>>>    // internal
78718>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78718>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78720>>>>>>>>>>>>>>>        
78720>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78720>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78720>>>>>>>>>>>>>>>        
78720>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78720>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78720>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78721>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78722>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78723>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78724>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78725>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78726>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78727>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78728>>>>>>>>>>>>>>>        
78728>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78729>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78732>>>>>>>>>>>>>>>        
78732>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78733>>>>>>>>>>>>>>>        
78733>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78734>>>>>>>>>>>>>>>        
78734>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78734>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78735>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78736>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78737>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78738>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78739>>>>>>>>>>>>>>>        
78739>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78741>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78742>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78744>>>>>>>>>>>>>>>                Move -2 to iDigits
78745>>>>>>>>>>>>>>>                Increment i
78746>>>>>>>>>>>>>>>            End
78746>>>>>>>>>>>>>>>>
78746>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78750>>>>>>>>>>>>>>>                Increment i
78751>>>>>>>>>>>>>>>            Loop
78752>>>>>>>>>>>>>>>>
78752>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78753>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78756>>>>>>>>>>>>>>>            //
78756>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78757>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78761>>>>>>>>>>>>>>>                Increment i
78762>>>>>>>>>>>>>>>            Loop
78763>>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78764>>>>>>>>>>>>>>>        End
78764>>>>>>>>>>>>>>>>
78764>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78765>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78766>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78767>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78769>>>>>>>>>>>>>>>                Move sFmt to sLeft
78770>>>>>>>>>>>>>>>                Move ""   to sRight
78771>>>>>>>>>>>>>>>            End
78771>>>>>>>>>>>>>>>>
78771>>>>>>>>>>>>>>>            Else Begin
78772>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78773>>>>>>>>>>>>>>>                Move 1 to i
78774>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78778>>>>>>>>>>>>>>>                    Increment i
78779>>>>>>>>>>>>>>>                Loop
78780>>>>>>>>>>>>>>>>
78780>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78781>>>>>>>>>>>>>>>            End
78781>>>>>>>>>>>>>>>>
78781>>>>>>>>>>>>>>>        End
78781>>>>>>>>>>>>>>>>
78781>>>>>>>>>>>>>>>        // set temporary format properties and exit
78781>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78782>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78783>>>>>>>>>>>>>>>        Set psRight        to sRight
78784>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78785>>>>>>>>>>>>>>>    End_Procedure
78786>>>>>>>>>>>>>>>    
78786>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78786>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78786>>>>>>>>>>>>>>>    //
78786>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78786>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78788>>>>>>>>>>>>>>>        String sPos sNeg
78788>>>>>>>>>>>>>>>        Integer iPos
78788>>>>>>>>>>>>>>>        
78788>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78789>>>>>>>>>>>>>>>        If iPos Begin
78791>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78792>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78793>>>>>>>>>>>>>>>        End
78793>>>>>>>>>>>>>>>>
78793>>>>>>>>>>>>>>>        Else Begin
78794>>>>>>>>>>>>>>>            Move sFmt         to sPos
78795>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78796>>>>>>>>>>>>>>>        End
78796>>>>>>>>>>>>>>>>
78796>>>>>>>>>>>>>>>        Send ParseFormat sPos
78797>>>>>>>>>>>>>>>        If bCurrency Begin
78799>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78800>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78801>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78802>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78803>>>>>>>>>>>>>>>        End
78803>>>>>>>>>>>>>>>>
78803>>>>>>>>>>>>>>>        Else Begin
78804>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78805>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78806>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78807>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78808>>>>>>>>>>>>>>>        End
78808>>>>>>>>>>>>>>>>
78808>>>>>>>>>>>>>>>        
78808>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78809>>>>>>>>>>>>>>>        If bCurrency Begin
78811>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78812>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78813>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78814>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78815>>>>>>>>>>>>>>>        End
78815>>>>>>>>>>>>>>>>
78815>>>>>>>>>>>>>>>        Else Begin
78816>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78817>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78818>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78819>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78820>>>>>>>>>>>>>>>        End
78820>>>>>>>>>>>>>>>>
78820>>>>>>>>>>>>>>>    End_Procedure
78821>>>>>>>>>>>>>>>    
78821>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78821>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78823>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78823>>>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78823>>>>>>>>>>>>>>>        
78823>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78826>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78827>>>>>>>>>>>>>>>        
78827>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78828>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78829>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78830>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78831>>>>>>>>>>>>>>>        // format for decimal separator
78831>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78834>>>>>>>>>>>>>>>        
78834>>>>>>>>>>>>>>>        // format for thousand sep.
78834>>>>>>>>>>>>>>>        If bSep Begin
78836>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78839>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78840>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78841>>>>>>>>>>>>>>>            While (iLen>3)
78845>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78846>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
78847>>>>>>>>>>>>>>>            Loop
78848>>>>>>>>>>>>>>>>
78848>>>>>>>>>>>>>>>        End
78848>>>>>>>>>>>>>>>>
78848>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78848>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78851>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78852>>>>>>>>>>>>>>>    End_Function
78853>>>>>>>>>>>>>>>    
78853>>>>>>>>>>>>>>>    // Public: Format for currency
78853>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78855>>>>>>>>>>>>>>>        String  sLeft sRight
78855>>>>>>>>>>>>>>>        Integer bSep
78855>>>>>>>>>>>>>>>        If (nNumber<0) Begin
78857>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78858>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
78859>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
78860>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78863>>>>>>>>>>>>>>>        End
78863>>>>>>>>>>>>>>>>
78863>>>>>>>>>>>>>>>        Else Begin
78864>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78865>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
78866>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
78867>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78870>>>>>>>>>>>>>>>        End
78870>>>>>>>>>>>>>>>>
78870>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78871>>>>>>>>>>>>>>>    End_Function
78872>>>>>>>>>>>>>>>    
78872>>>>>>>>>>>>>>>    // Public: Format for numeric
78872>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78874>>>>>>>>>>>>>>>        String  sLeft sRight
78874>>>>>>>>>>>>>>>        Integer bSep
78874>>>>>>>>>>>>>>>        If (nNumber<0) Begin
78876>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78877>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
78878>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
78879>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78882>>>>>>>>>>>>>>>        End
78882>>>>>>>>>>>>>>>>
78882>>>>>>>>>>>>>>>        Else Begin
78883>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78884>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
78885>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
78886>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
78889>>>>>>>>>>>>>>>        End
78889>>>>>>>>>>>>>>>>
78889>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78890>>>>>>>>>>>>>>>    End_Function
78891>>>>>>>>>>>>>>>    
78891>>>>>>>>>>>>>>>    
78891>>>>>>>>>>>>>>>    // Public: Format passing format string
78891>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
78893>>>>>>>>>>>>>>>        Integer iPos bIsNeg
78893>>>>>>>>>>>>>>>        String  sLeft sRight
78893>>>>>>>>>>>>>>>        Integer iPoints bSep
78893>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
78894>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78895>>>>>>>>>>>>>>>        Case Begin
78895>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
78898>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
78902>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
78906>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
78908>>>>>>>>>>>>>>>        Case End
78908>>>>>>>>>>>>>>>        Send ParseFormat sFmt
78909>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
78910>>>>>>>>>>>>>>>        Get psLeft         to sLeft
78911>>>>>>>>>>>>>>>        Get psRight        to sRight
78912>>>>>>>>>>>>>>>        Get piPoints       to iPoints
78913>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78914>>>>>>>>>>>>>>>    End_Function
78915>>>>>>>>>>>>>>>    
78915>>>>>>>>>>>>>>>End_Class
78916>>>>>>>>>>>>>
78916>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
78916>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
78917>>>>>>>>>>>>>
78917>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
78919>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
78920>>>>>>>>>>>>>End_Function
78921>>>>>>>>>>>>>
78921>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
78923>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
78924>>>>>>>>>>>>>End_Function
78925>>>>>>>>>>>>>
78925>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
78927>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
78928>>>>>>>>>>>>>End_Function
78929>>>>>>>>>>>>>
78929>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
78931>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
78932>>>>>>>>>>>>>End_Procedure
78933>>>>>>>>>>>>>
78933>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
78935>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
78936>>>>>>>>>>>>>End_Procedure
78937>>>>>>>>>>>>>
78937>>>>>>>>>>>>>
78937>>>>>>>>>>>Use tWinStructs.pkg
78937>>>>>>>>>>>
78937>>>>>>>>>>>Use cli.pkg
78937>>>>>>>>>>>Use DFBTRDRV.PKG
78937>>>>>>>>>>>Use MSSqldrv.pkg
78937>>>>>>>>>>>Use db2_drv.pkg
78937>>>>>>>>>>>Use odbc_drv.pkg
78937>>>>>>>>>>>Use seq_chnl.pkg
78937>>>>>>>>>>>
78937>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
78937>>>>>>>>>>>Register_Function Help_filename Returns String
78937>>>>>>>>>>>Register_Function GetHelpFile Returns String
78937>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
78937>>>>>>>>>>>
78937>>>>>>>>>>>// *** Constant Declarations: ***
78937>>>>>>>>>>>//
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>// System icon menu constants. If the upper left hand
78937>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
78937>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
78937>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
78937>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
78937>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
78937>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
78937>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
78937>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
78937>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
78937>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
78937>>>>>>>>>>>
78937>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
78937>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
78937>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
78937>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
78937>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
78937>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
78937>>>>>>>>>>>
78937>>>>>>>>>>>// *** Struct Declarations: ***
78937>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
78937>>>>>>>>>>>    DWord   cbSize
78937>>>>>>>>>>>    Integer fMask
78937>>>>>>>>>>>    Handle  hwnd
78937>>>>>>>>>>>    Pointer lpVerb
78937>>>>>>>>>>>    Pointer lpFile
78937>>>>>>>>>>>    Pointer lpParameters
78937>>>>>>>>>>>    Pointer lpDirectory
78937>>>>>>>>>>>    Integer nShow
78937>>>>>>>>>>>    Pointer hInstApp
78937>>>>>>>>>>>    Pointer lpIDList
78937>>>>>>>>>>>    Pointer lpClass
78937>>>>>>>>>>>    Handle  hkeyClass
78937>>>>>>>>>>>    DWord   dwHotKey
78937>>>>>>>>>>>    Handle  hIconMonitor // Union
78937>>>>>>>>>>>    //Handle  hMonitor     // Union
78937>>>>>>>>>>>    Handle  hProcess
78937>>>>>>>>>>>End_Struct
78937>>>>>>>>>>>
78937>>>>>>>>>>>
78937>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
78937>>>>>>>>>>>//Type MEMORYSTATUS
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
78937>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
78937>>>>>>>>>>>//End_Type
78937>>>>>>>>>>>
78937>>>>>>>>>>>// *** External Function calls: ***
78937>>>>>>>>>>>//
78937>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
78938>>>>>>>>>>>
78938>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
78939>>>>>>>>>>>
78939>>>>>>>>>>>// Do not call directly, use the wrapper function instead
78939>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
78940>>>>>>>>>>>
78940>>>>>>>>>>>    // Wrapper Function WNetGetUser
78940>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
78942>>>>>>>>>>>
78942>>>>>>>>>>>        DWord   dwResult
78942>>>>>>>>>>>        UWide   uwName uwUserName
78942>>>>>>>>>>>        UWide   uwName uwUserName
78942>>>>>>>>>>>
78942>>>>>>>>>>>        Send StringToWide lpName (&uwName)
78943>>>>>>>>>>>
78943>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
78944>>>>>>>>>>>
78944>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
78945>>>>>>>>>>>
78945>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
78946>>>>>>>>>>>
78946>>>>>>>>>>>        Function_Return dwResult
78947>>>>>>>>>>>    End_Function
78948>>>>>>>>>>>
78948>>>>>>>>>>>
78948>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
78949>>>>>>>>>>>
78949>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
78950>>>>>>>>>>>
78950>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
78951>>>>>>>>>>>
78951>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
78952>>>>>>>>>>>
78952>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
78953>>>>>>>>>>>
78953>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
78953>>>>>>>>>>>
78953>>>>>>>>>>>Function ComputerName Desktop Returns String
78955>>>>>>>>>>>    String sName
78955>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
78956>>>>>>>>>>>>
78956>>>>>>>>>>>    Function_Return sName
78957>>>>>>>>>>>End_Function
78958>>>>>>>>>>>
78958>>>>>>>>>>>Function Network_User_Name Desktop Returns String
78960>>>>>>>>>>>    WString wName
78960>>>>>>>>>>>    Integer iRetval iLength
78960>>>>>>>>>>>
78960>>>>>>>>>>>    Move 0 to iLength
78961>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
78962>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
78963>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
78964>>>>>>>>>>>
78964>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
78966>>>>>>>>>>>        Function_Return (CString (wName))
78967>>>>>>>>>>>    End
78967>>>>>>>>>>>>
78967>>>>>>>>>>>
78967>>>>>>>>>>>    Function_Return "User Unknown"
78968>>>>>>>>>>>End_Function
78969>>>>>>>>>>>
78969>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
78971>>>>>>>>>>>    String sClient sDriver sClientDriver
78971>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
78971>>>>>>>>>>>    Handle hoMsqlDrv
78971>>>>>>>>>>>
78971>>>>>>>>>>>    Move 0 to iDriver
78972>>>>>>>>>>>    Move "" to sClient
78973>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78976>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
78982>>>>>>>>>>>>
78982>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
78985>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
78987>>>>>>>>>>>            Move iCount to iDriver
78988>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
78989>>>>>>>>>>>        End
78989>>>>>>>>>>>>
78989>>>>>>>>>>>    Loop
78990>>>>>>>>>>>>
78990>>>>>>>>>>>
78990>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
78990>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
78992>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
78995>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
78996>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
78997>>>>>>>>>>>        Send Destroy of hoMsqlDrv
78998>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
78999>>>>>>>>>>>    End
78999>>>>>>>>>>>>
78999>>>>>>>>>>>
78999>>>>>>>>>>>    Function_Return sClient
79000>>>>>>>>>>>End_Function
79001>>>>>>>>>>>
79001>>>>>>>>>>>// *** Class Declarations: ***
79001>>>>>>>>>>>//
79001>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79002>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79004>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79005>>>>>>>>>>>    End_Procedure
79006>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79008>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79010>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79011>>>>>>>>>>>    End_Procedure
79012>>>>>>>>>>>End_Class
79013>>>>>>>>>>>
79013>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79014>>>>>>>>>>>    Procedure Construct_Object
79016>>>>>>>>>>>        Forward Send Construct_Object
79018>>>>>>>>>>>        Property Handle phoEditorHandle
79019>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79020>>>>>>>>>>>    End_Procedure
79021>>>>>>>>>>>
79021>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79023>>>>>>>>>>>        Handle hoEditor
79023>>>>>>>>>>>        Boolean bCanCopy
79023>>>>>>>>>>>        Address aEditorAddress
79023>>>>>>>>>>>
79023>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79024>>>>>>>>>>>        Send Select_All of hoEditor
79025>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79026>>>>>>>>>>>        If (bCanCopy = True) Begin
79028>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79029>>>>>>>>>>>            Send Copy   of hoEditor
79030>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79030>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79031>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79032>>>>>>>>>>>        End
79032>>>>>>>>>>>>
79032>>>>>>>>>>>    End_Procedure
79033>>>>>>>>>>>End_Class
79034>>>>>>>>>>>
79034>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79035>>>>>>>>>>>    Procedure Construct_Object
79037>>>>>>>>>>>        Forward Send Construct_Object
79039>>>>>>>>>>>
79039>>>>>>>>>>>        Set Size to 100 245
79040>>>>>>>>>>>        Set Location to 6 6
79041>>>>>>>>>>>        Set Border_Style to Border_None
79042>>>>>>>>>>>        Set Read_Only_State to True
79043>>>>>>>>>>>        Set pbWrap to True
79044>>>>>>>>>>>        Set peAnchors to anAll
79045>>>>>>>>>>>    End_Procedure
79046>>>>>>>>>>>
79046>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79046>>>>>>>>>>>
79046>>>>>>>>>>>    Procedure AppendTextLn String sText
79048>>>>>>>>>>>        String sWorkspaceWSFile
79048>>>>>>>>>>>
79048>>>>>>>>>>>        // Only works for English:
79048>>>>>>>>>>>        If (ghoApplication > 0) Begin
79050>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79052>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79053>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79054>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79055>>>>>>>>>>>            End
79055>>>>>>>>>>>>
79055>>>>>>>>>>>        End
79055>>>>>>>>>>>>
79055>>>>>>>>>>>        Send AppendText sText
79056>>>>>>>>>>>        Send AppendText (character(10))
79057>>>>>>>>>>>    End_Procedure
79058>>>>>>>>>>>
79058>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79058>>>>>>>>>>>    //    information box
79058>>>>>>>>>>>    Procedure Show_Current_Directory
79060>>>>>>>>>>>        String sDir
79060>>>>>>>>>>>
79060>>>>>>>>>>>        Get_Current_Directory To sDir
79061>>>>>>>>>>>
79061>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79062>>>>>>>>>>>    End_Procedure
79063>>>>>>>>>>>
79063>>>>>>>>>>>    Procedure Show_Windows_Directory
79065>>>>>>>>>>>        String sWindir
79065>>>>>>>>>>>
79065>>>>>>>>>>>        Get_Windows_Directory To sWindir
79066>>>>>>>>>>>
79066>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79067>>>>>>>>>>>    End_Procedure
79068>>>>>>>>>>>
79068>>>>>>>>>>>    Procedure Show_Current_User
79070>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79071>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79072>>>>>>>>>>>    End_Procedure
79073>>>>>>>>>>>
79073>>>>>>>>>>>    Procedure Show_Number_Format
79075>>>>>>>>>>>        Integer iFormat
79075>>>>>>>>>>>        String sFormatText
79075>>>>>>>>>>>
79075>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79078>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79079>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79080>>>>>>>>>>>
79080>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79083>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79084>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79085>>>>>>>>>>>    End_Procedure
79086>>>>>>>>>>>
79086>>>>>>>>>>>    Procedure Show_Filelist_Name
79088>>>>>>>>>>>        String sFilename
79088>>>>>>>>>>>
79088>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79091>>>>>>>>>>>
79091>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79092>>>>>>>>>>>    End_Procedure
79093>>>>>>>>>>>
79093>>>>>>>>>>>    Procedure Show_Lock_Delay
79095>>>>>>>>>>>        Integer iLockdelay
79095>>>>>>>>>>>
79095>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79098>>>>>>>>>>>
79098>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79099>>>>>>>>>>>    End_Procedure
79100>>>>>>>>>>>
79100>>>>>>>>>>>    Procedure Show_Lock_Timeout
79102>>>>>>>>>>>        Integer iLockTimeout
79102>>>>>>>>>>>
79102>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79105>>>>>>>>>>>
79105>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79106>>>>>>>>>>>    End_Procedure
79107>>>>>>>>>>>
79107>>>>>>>>>>>    Procedure Show_Screen_Size
79109>>>>>>>>>>>        Integer iYscreensize iXscreensize
79109>>>>>>>>>>>
79109>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79110>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79111>>>>>>>>>>>
79111>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79112>>>>>>>>>>>    End_Procedure
79113>>>>>>>>>>>
79113>>>>>>>>>>>    Procedure Show_Page_Size
79115>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79116>>>>>>>>>>>    End_procedure
79117>>>>>>>>>>>
79117>>>>>>>>>>>    Procedure Show_Date
79119>>>>>>>>>>>        Date dToday
79119>>>>>>>>>>>
79119>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79120>>>>>>>>>>>
79120>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79121>>>>>>>>>>>    End_procedure
79122>>>>>>>>>>>
79122>>>>>>>>>>>    Procedure Show_Date_Format
79124>>>>>>>>>>>        Integer iDateFormat
79124>>>>>>>>>>>        String sDateFormat
79124>>>>>>>>>>>
79124>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79127>>>>>>>>>>>        Case Begin
79127>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79129>>>>>>>>>>>                Move C_$USA To sDateFormat
79130>>>>>>>>>>>                Case Break
79131>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79134>>>>>>>>>>>                Move C_$European To sDateFormat
79135>>>>>>>>>>>                Case Break
79136>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79139>>>>>>>>>>>                Move C_$Military To sDateFormat
79140>>>>>>>>>>>                Case Break
79141>>>>>>>>>>>            Case Else
79141>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79142>>>>>>>>>>>                Case Break
79143>>>>>>>>>>>        Case End
79143>>>>>>>>>>>
79143>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79144>>>>>>>>>>>    End_Procedure
79145>>>>>>>>>>>
79145>>>>>>>>>>>    // 2013-08-14 NGS
79145>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79145>>>>>>>>>>>    Procedure Show_Systemresources
79147>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79147>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79147>>>>>>>>>>>        Integer iRetval
79147>>>>>>>>>>>        Number nValue
79147>>>>>>>>>>>        String sValue
79147>>>>>>>>>>>
79147>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79148>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79149>>>>>>>>>>>        If (iRetval = 0) Begin
79151>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79152>>>>>>>>>>>            Procedure_Return
79153>>>>>>>>>>>        End
79153>>>>>>>>>>>>
79153>>>>>>>>>>>
79153>>>>>>>>>>>        Send AppendTextLn ""
79154>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79155>>>>>>>>>>>
79155>>>>>>>>>>>        // Show memory in Gigabytes:
79155>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79156>>>>>>>>>>>        Move (Round(nValue)) to nValue
79157>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79158>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79159>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79160>>>>>>>>>>>
79160>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79160>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79161>>>>>>>>>>>        Move (Round(nValue)) to nValue
79162>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79163>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79164>>>>>>>>>>>
79164>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79164>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79165>>>>>>>>>>>        Move (Round(nValue)) to nValue
79166>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79167>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79168>>>>>>>>>>>
79168>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79168>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79169>>>>>>>>>>>        Move (Round(nValue)) to nValue
79170>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79171>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79172>>>>>>>>>>>
79172>>>>>>>>>>>        // Add an empty row after the memory information:
79172>>>>>>>>>>>        Send AppendTextLn ""
79173>>>>>>>>>>>    End_Procedure
79174>>>>>>>>>>>
79174>>>>>>>>>>>    Procedure Show_Registration
79176>>>>>>>>>>>        String sRegName
79176>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79176>>>>>>>>>>>
79176>>>>>>>>>>>        Registration sRegName iSN
79177>>>>>>>>>>>>
79177>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79178>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79179>>>>>>>>>>>
79179>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79180>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79181>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79182>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79183>>>>>>>>>>>    End_Procedure
79184>>>>>>>>>>>
79184>>>>>>>>>>>    //****************************************************************************
79184>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79184>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79184>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79184>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79184>>>>>>>>>>>    // information To be displayed
79184>>>>>>>>>>>    //****************************************************************************
79184>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79184>>>>>>>>>>>
79184>>>>>>>>>>>    Procedure Show_ServicePack
79186>>>>>>>>>>>        String sKey sVersion sDataFlex
79186>>>>>>>>>>>        Handle hoRegistry
79186>>>>>>>>>>>        Boolean bExists bOpened
79186>>>>>>>>>>>
79186>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79187>>>>>>>>>>>
79187>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79188>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79189>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79190>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79191>>>>>>>>>>>
79191>>>>>>>>>>>        If (bExists) Begin
79193>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79194>>>>>>>>>>>        End
79194>>>>>>>>>>>>
79194>>>>>>>>>>>        Else Begin
79195>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79196>>>>>>>>>>>        End
79196>>>>>>>>>>>>
79196>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79197>>>>>>>>>>>        If (bExists) Begin
79199>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79200>>>>>>>>>>>            If (bOpened) Begin
79202>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79203>>>>>>>>>>>                If (bExists) Begin
79205>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79206>>>>>>>>>>>                End
79206>>>>>>>>>>>>
79206>>>>>>>>>>>                Send CloseKey of hoRegistry
79207>>>>>>>>>>>            End
79207>>>>>>>>>>>>
79207>>>>>>>>>>>        End
79207>>>>>>>>>>>>
79207>>>>>>>>>>>        Send Destroy of hoRegistry
79208>>>>>>>>>>>
79208>>>>>>>>>>>        If (sVersion <> "") Begin
79210>>>>>>>>>>>           Send AppendTextLn sVersion
79211>>>>>>>>>>>           Send AppendTextLn ""
79212>>>>>>>>>>>        End
79212>>>>>>>>>>>>
79212>>>>>>>>>>>    End_Procedure
79213>>>>>>>>>>>
79213>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79215>>>>>>>>>>>        Integer hoWorkspace
79215>>>>>>>>>>>
79215>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79217>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79218>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79220>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79221>>>>>>>>>>>            End
79221>>>>>>>>>>>>
79221>>>>>>>>>>>        End
79221>>>>>>>>>>>>
79221>>>>>>>>>>>    End_Procedure
79222>>>>>>>>>>>
79222>>>>>>>>>>>    //****************************************************************************
79222>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79222>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79222>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79222>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79222>>>>>>>>>>>    // the information To be displayed
79222>>>>>>>>>>>    //****************************************************************************
79222>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79222>>>>>>>>>>>
79222>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79224>>>>>>>>>>>        If (ghoConnection > 0) Begin
79226>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79227>>>>>>>>>>>            Send AppendTextLn ""
79228>>>>>>>>>>>        End
79228>>>>>>>>>>>>
79228>>>>>>>>>>>    End_Procedure
79229>>>>>>>>>>>
79229>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79231>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79232>>>>>>>>>>>    End_Function
79233>>>>>>>>>>>
79233>>>>>>>>>>>    Procedure Show_Versions
79235>>>>>>>>>>>        Integer iVersion iRevision iBuild
79235>>>>>>>>>>>
79235>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79237>>>>>>>>>>>
79237>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79238>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79239>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79240>>>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79241>>>>>>>>>>>    End_Procedure
79242>>>>>>>>>>>
79242>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79244>>>>>>>>>>>        Boolean bOK
79244>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79245>>>>>>>>>>>        Function_Return bOK
79246>>>>>>>>>>>    End_Function
79247>>>>>>>>>>>
79247>>>>>>>>>>>    //***
79247>>>>>>>>>>>    //*** BW
79247>>>>>>>>>>>    //*** Procedure: Show_Drivers
79247>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79247>>>>>>>>>>>    //***
79247>>>>>>>>>>>
79247>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79247>>>>>>>>>>>//    #Warning -3
79247>>>>>>>>>>>//#ENDIF
79247>>>>>>>>>>>    Procedure Show_Drivers
79249>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79249>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79249>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79249>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79249>>>>>>>>>>>
79249>>>>>>>>>>>        Move False to bStudioLicense
79250>>>>>>>>>>>
79250>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79251>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79252>>>>>>>>>>>
79252>>>>>>>>>>>        // For testing purposes:
79252>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79252>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79252>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79252>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79252>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79252>>>>>>>>>>>//
79252>>>>>>>>>>>        Move False to Err
79253>>>>>>>>>>>
79253>>>>>>>>>>>        // Loop through all loaded drivers.
79253>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79256>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79258>>>>>>>>>>>            Send AppendTextLn ""
79259>>>>>>>>>>>        End
79259>>>>>>>>>>>>
79259>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79265>>>>>>>>>>>>
79265>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79266>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79269>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79270>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79271>>>>>>>>>>>
79271>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79273>>>>>>>>>>>
79273>>>>>>>>>>>                // Pervasive/Btrieve database
79273>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79275>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79276>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79277>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79279>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79280>>>>>>>>>>>                    End
79280>>>>>>>>>>>>
79280>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79281>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79283>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79284>>>>>>>>>>>                    End
79284>>>>>>>>>>>>
79284>>>>>>>>>>>                End
79284>>>>>>>>>>>>
79284>>>>>>>>>>>
79284>>>>>>>>>>>                Else Begin
79285>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79286>>>>>>>>>>>                    Move 0 to iNumServers
79287>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79289>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79292>>>>>>>>>>>                    End
79292>>>>>>>>>>>>
79292>>>>>>>>>>>
79292>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79294>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79296>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79297>>>>>>>>>>>                        End
79297>>>>>>>>>>>>
79297>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79298>>>>>>>>>>>                    End
79298>>>>>>>>>>>>
79298>>>>>>>>>>>
79298>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79298>>>>>>>>>>>                    // Studio licens is in use and there is no
79298>>>>>>>>>>>                    // number of max users defined because the driver is
79298>>>>>>>>>>>                    // relying on the info from the VDF license.
79298>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79300>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79301>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79302>>>>>>>>>>>                    End
79302>>>>>>>>>>>>
79302>>>>>>>>>>>                End
79302>>>>>>>>>>>>
79302>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79303>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79305>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79306>>>>>>>>>>>                End
79306>>>>>>>>>>>>
79306>>>>>>>>>>>                If (iNumServers <> 0) Begin
79308>>>>>>>>>>>                    For iCount from 1 to iNumServers
79314>>>>>>>>>>>>
79314>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79317>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79319>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79320>>>>>>>>>>>                        End
79320>>>>>>>>>>>>
79320>>>>>>>>>>>                    Loop
79321>>>>>>>>>>>>
79321>>>>>>>>>>>                End
79321>>>>>>>>>>>>
79321>>>>>>>>>>>            End
79321>>>>>>>>>>>>
79321>>>>>>>>>>>        Loop
79322>>>>>>>>>>>>
79322>>>>>>>>>>>
79322>>>>>>>>>>>        Send AppendTextLn ""
79323>>>>>>>>>>>        If (bStudioLicense = False) Begin
79325>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79326>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79327>>>>>>>>>>>        End
79327>>>>>>>>>>>>
79327>>>>>>>>>>>        Else Begin
79328>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79329>>>>>>>>>>>        End
79329>>>>>>>>>>>>
79329>>>>>>>>>>>        Send Destroy of hoCLIHandler
79330>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79331>>>>>>>>>>>    End_Procedure
79332>>>>>>>>>>>
79332>>>>>>>>>>>    Procedure Show_HelpFile
79334>>>>>>>>>>>        String sHelpFile
79334>>>>>>>>>>>        Integer eHelpType
79334>>>>>>>>>>>
79334>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79336>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79337>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79339>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79340>>>>>>>>>>>            End
79340>>>>>>>>>>>>
79340>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79343>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79344>>>>>>>>>>>            End
79344>>>>>>>>>>>>
79344>>>>>>>>>>>            Else Begin
79345>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79346>>>>>>>>>>>            End
79346>>>>>>>>>>>>
79346>>>>>>>>>>>
79346>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79347>>>>>>>>>>>        End
79347>>>>>>>>>>>>
79347>>>>>>>>>>>    End_Procedure
79348>>>>>>>>>>>
79348>>>>>>>>>>>    Procedure Show_EnterAsTab
79350>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79350>>>>>>>>>>>        String sText
79350>>>>>>>>>>>
79350>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79352>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79353>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79355>>>>>>>>>>>                Move "True" To sText
79356>>>>>>>>>>>            End
79356>>>>>>>>>>>>
79356>>>>>>>>>>>            Else Begin
79357>>>>>>>>>>>                Move "False" To sText
79358>>>>>>>>>>>            End
79358>>>>>>>>>>>>
79358>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79359>>>>>>>>>>>        End
79359>>>>>>>>>>>>
79359>>>>>>>>>>>    End_Procedure
79360>>>>>>>>>>>
79360>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79360>>>>>>>>>>>    //    found systeminformation
79360>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79362>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79364>>>>>>>>>>>
79364>>>>>>>>>>>        Send Delete_Data
79365>>>>>>>>>>>
79365>>>>>>>>>>>        Set Changed_State To False
79366>>>>>>>>>>>        Set Read_Only_State To True
79367>>>>>>>>>>>
79367>>>>>>>>>>>        Send Show_Registration
79368>>>>>>>>>>>        Send Show_Drivers
79369>>>>>>>>>>>        Send Show_ServicePack
79370>>>>>>>>>>>        Send Show_Versions
79371>>>>>>>>>>>        Send AppendTextLn ""
79372>>>>>>>>>>>
79372>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79374>>>>>>>>>>>            Send Show_WorkSpaceInformation
79375>>>>>>>>>>>            Send Show_HelpFile
79376>>>>>>>>>>>            Send AppendTextLn ""
79377>>>>>>>>>>>        End
79377>>>>>>>>>>>>
79377>>>>>>>>>>>        Else Begin
79378>>>>>>>>>>>            Send AppendTextLn ""
79379>>>>>>>>>>>        End
79379>>>>>>>>>>>>
79379>>>>>>>>>>>
79379>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79381>>>>>>>>>>>            Send Show_ConnectionIdInformation
79382>>>>>>>>>>>        End
79382>>>>>>>>>>>>
79382>>>>>>>>>>>
79382>>>>>>>>>>>        Send Show_Current_User
79383>>>>>>>>>>>        Send Show_Windows_Directory
79384>>>>>>>>>>>        Send Show_Current_Directory
79385>>>>>>>>>>>
79385>>>>>>>>>>>        // This is already shown in the workspace details,
79385>>>>>>>>>>>        // unless no workspace object is present:
79385>>>>>>>>>>>        If (ghoApplication = 0) Begin
79387>>>>>>>>>>>            Send Show_Filelist_Name
79388>>>>>>>>>>>        End
79388>>>>>>>>>>>>
79388>>>>>>>>>>>
79388>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79390>>>>>>>>>>>            Send AppendTextLn ""
79391>>>>>>>>>>>            Send Show_EnterAsTab
79392>>>>>>>>>>>        End
79392>>>>>>>>>>>>
79392>>>>>>>>>>>
79392>>>>>>>>>>>        Send Show_Screen_Size
79393>>>>>>>>>>>        Send Show_Page_Size
79394>>>>>>>>>>>        Send Show_Number_Format
79395>>>>>>>>>>>        Send Show_Date_Format
79396>>>>>>>>>>>        Send Show_Lock_Delay
79397>>>>>>>>>>>        Send Show_Lock_Timeout
79398>>>>>>>>>>>        Send Show_Date
79399>>>>>>>>>>>        Send Show_Systemresources
79400>>>>>>>>>>>        Send Beginning_of_Data
79401>>>>>>>>>>>
79401>>>>>>>>>>>        Set Icon to 'default.ico'
79402>>>>>>>>>>>    End_Procedure
79403>>>>>>>>>>>End_Class
79404>>>>>>>>>>>
79404>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79405>>>>>>>>>>>    Procedure Construct_Object
79407>>>>>>>>>>>        Forward Send Construct_Object
79409>>>>>>>>>>>
79409>>>>>>>>>>>        Set Label to C_$SystemInformation
79410>>>>>>>>>>>        Set Size to 140 267
79411>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79412>>>>>>>>>>>        Set Border_Style to Border_Thick
79413>>>>>>>>>>>        Set Sysmenu_Icon to False
79414>>>>>>>>>>>
79414>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79414>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79415>>>>>>>>>>>
79415>>>>>>>>>>>        // 2014-09-14 NGS
79415>>>>>>>>>>>        // Added a container object around the cTexteditor
79415>>>>>>>>>>>        // object to get a border around the text.
79415>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79417>>>>>>>>>>>            Set Location to 2 4
79418>>>>>>>>>>>            Set Size to 110 255
79419>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79420>>>>>>>>>>>            Set Color to clWhite
79421>>>>>>>>>>>            Set peAnchors to anAll
79422>>>>>>>>>>>
79422>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79424>>>>>>>>>>>            End_Object
79425>>>>>>>>>>>
79425>>>>>>>>>>>        End_Object
79426>>>>>>>>>>>
79426>>>>>>>>>>>        Object oCloseButton is a Button
79428>>>>>>>>>>>            Set Label to C_$Close
79429>>>>>>>>>>>            Set Location to 120 210
79430>>>>>>>>>>>            CompilerWarnings Off
79430>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79431>>>>>>>>>>>            CompilerWarnings On
79431>>>>>>>>>>>            Set Default_State To True
79432>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79432>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79432>>>>>>>>>>>            // for that situation.
79432>>>>>>>>>>>            Set peAnchors to anBottomRight
79433>>>>>>>>>>>        End_Object
79434>>>>>>>>>>>
79434>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79436>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79437>>>>>>>>>>>            Set Size to 14 50
79438>>>>>>>>>>>            Set Location to 120 158
79439>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79439>>>>>>>>>>>            // we might as well prepare the object for it.
79439>>>>>>>>>>>            Set peAnchors to anBottomRight
79440>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79441>>>>>>>>>>>        End_Object
79442>>>>>>>>>>>
79442>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79443>>>>>>>>>>>    End_Procedure
79444>>>>>>>>>>>
79444>>>>>>>>>>>    Procedure Page Integer iPageObject
79446>>>>>>>>>>>        Handle hMenu
79446>>>>>>>>>>>        Integer iPrevState
79446>>>>>>>>>>>
79446>>>>>>>>>>>        Forward Send Page iPageObject
79448>>>>>>>>>>>
79448>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79448>>>>>>>>>>>        //
79448>>>>>>>>>>>    End_Procedure
79449>>>>>>>>>>>
79449>>>>>>>>>>>End_Class
79450>>>>>>>>>>>
79450>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79451>>>>>>>>>>>    Procedure Construct_Object
79453>>>>>>>>>>>        Forward Send Construct_Object
79455>>>>>>>>>>>
79455>>>>>>>>>>>        Property String psContentText
79456>>>>>>>>>>>
79456>>>>>>>>>>>        Set Size to 77 153
79457>>>>>>>>>>>        Set Location to 8 60
79458>>>>>>>>>>>        Set Read_Only_State to True
79459>>>>>>>>>>>        Set Skip_State to True
79460>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79460>>>>>>>>>>>        // or 1/20 of a printer's point.
79460>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79461>>>>>>>>>>>        Set Border_Style  to Border_None
79462>>>>>>>>>>>    End_Procedure
79463>>>>>>>>>>>
79463>>>>>>>>>>>    // Adds a line of text to the edit object
79463>>>>>>>>>>>    Procedure Add_Line String sText
79465>>>>>>>>>>>        String sContentText
79465>>>>>>>>>>>        Get psContentText to sContentText
79466>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79467>>>>>>>>>>>        Set psContentText to sContentText
79468>>>>>>>>>>>    End_Procedure
79469>>>>>>>>>>>
79469>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79469>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79469>>>>>>>>>>>    // because the object isn't paged yet when we add these
79469>>>>>>>>>>>    // values and the COM edit object needs to be paged
79469>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79469>>>>>>>>>>>    Procedure Add_LineLn String sText
79471>>>>>>>>>>>        String sContentText sCR
79471>>>>>>>>>>>
79471>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79472>>>>>>>>>>>        Get psContentText to sContentText
79473>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79474>>>>>>>>>>>        Set psContentText to sContentText
79475>>>>>>>>>>>    End_Procedure
79476>>>>>>>>>>>
79476>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79478>>>>>>>>>>>        String sLinkText
79478>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79479>>>>>>>>>>>        Send Show_HomePage sLinkText
79480>>>>>>>>>>>    End_Procedure
79481>>>>>>>>>>>
79481>>>>>>>>>>>    Procedure Page Integer iPageObject
79483>>>>>>>>>>>        String sContentText
79483>>>>>>>>>>>
79483>>>>>>>>>>>        Forward Send Page iPageObject
79485>>>>>>>>>>>        Get psContentText to sContentText
79486>>>>>>>>>>>        Send AppendText sContentText
79487>>>>>>>>>>>        send Beginning_of_Data
79488>>>>>>>>>>>    End_Procedure
79489>>>>>>>>>>>
79489>>>>>>>>>>>End_Class
79490>>>>>>>>>>>
79490>>>>>>>>>>>Class AboutDialog is a ModalPanel
79491>>>>>>>>>>>    Procedure Construct_Object
79493>>>>>>>>>>>
79493>>>>>>>>>>>        Forward Send Construct_Object
79495>>>>>>>>>>>
79495>>>>>>>>>>>        Set Label to C_$About
79496>>>>>>>>>>>        Set Size to 118 230
79497>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79498>>>>>>>>>>>        Set Border_Style to Border_Thick
79499>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79500>>>>>>>>>>>
79500>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79502>>>>>>>>>>>        End_Object
79503>>>>>>>>>>>
79503>>>>>>>>>>>        Object oBox is a Container3d
79505>>>>>>>>>>>            Set Border_Style to Border_Normal
79506>>>>>>>>>>>            Set Size to 90 220
79507>>>>>>>>>>>            Set Location to 4 5
79508>>>>>>>>>>>            Set Color to clWhite
79509>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79509>>>>>>>>>>>            // we might as well prepare the object for it.
79509>>>>>>>>>>>            Set peAnchors to anAll
79510>>>>>>>>>>>
79510>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79512>>>>>>>>>>>                Set Border_Style To Border_None
79513>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79514>>>>>>>>>>>                Set Color to clWhite
79515>>>>>>>>>>>                Set Size to 45 50
79516>>>>>>>>>>>                Set Location to 0 3
79517>>>>>>>>>>>            End_Object
79518>>>>>>>>>>>
79518>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79520>>>>>>>>>>>                Set Border_Style to Border_None
79521>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79522>>>>>>>>>>>                Set Color to clWhite
79523>>>>>>>>>>>                Set Size to 30 55
79524>>>>>>>>>>>                Set Location to 50 3
79525>>>>>>>>>>>            End_Object
79526>>>>>>>>>>>
79526>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79528>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79528>>>>>>>>>>>                // we might as well prepare the object for it.
79528>>>>>>>>>>>                Set peAnchors to anAll
79529>>>>>>>>>>>            End_Object
79530>>>>>>>>>>>
79530>>>>>>>>>>>            // These objects are here for backwards compatability only.
79530>>>>>>>>>>>            // They are not used.
79530>>>>>>>>>>>            Object oProductName is a TextBox
79532>>>>>>>>>>>                Set Label To C_$ProductName
79533>>>>>>>>>>>                Set Size To 10 45
79534>>>>>>>>>>>                Set Location To 8 53
79535>>>>>>>>>>>                Set Visible_State to False
79536>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79537>>>>>>>>>>>            End_Object
79538>>>>>>>>>>>
79538>>>>>>>>>>>            Object oVersion is a TextBox
79540>>>>>>>>>>>                Set Label To C_$Version
79541>>>>>>>>>>>                Set Size To 10 25
79542>>>>>>>>>>>                Set Location To 21 53
79543>>>>>>>>>>>                Set Visible_State to False
79544>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79545>>>>>>>>>>>            End_Object
79546>>>>>>>>>>>
79546>>>>>>>>>>>            Object oCopyright is a TextBox
79548>>>>>>>>>>>                Set Label To C_$Copyright
79549>>>>>>>>>>>                Set Size To 10 31
79550>>>>>>>>>>>                Set Location To 34 53
79551>>>>>>>>>>>                Set Visible_State to False
79552>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79553>>>>>>>>>>>            End_Object
79554>>>>>>>>>>>
79554>>>>>>>>>>>            Object oAuthor is a TextBox
79556>>>>>>>>>>>                Set Label To C_$Author
79557>>>>>>>>>>>                Set Size To 10 22
79558>>>>>>>>>>>                Set Location To 46 53
79559>>>>>>>>>>>                Set Visible_State to False
79560>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79561>>>>>>>>>>>            End_Object
79562>>>>>>>>>>>
79562>>>>>>>>>>>        End_Object
79563>>>>>>>>>>>
79563>>>>>>>>>>>        Object oOKButton is a Button
79565>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79566>>>>>>>>>>>            Set Location to 98 176
79567>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79567>>>>>>>>>>>            // we might as well prepare the object for it.
79567>>>>>>>>>>>            Set peAnchors to anBottomRight
79568>>>>>>>>>>>        End_Object
79569>>>>>>>>>>>
79569>>>>>>>>>>>        Object oSysInfoButton is a Button
79571>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79572>>>>>>>>>>>            Set Location to 98 123
79573>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79573>>>>>>>>>>>            // we might as well prepare the object for it.
79573>>>>>>>>>>>            Set peAnchors to anBottomRight
79574>>>>>>>>>>>        End_Object
79575>>>>>>>>>>>
79575>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79577>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79578>>>>>>>>>>>            Set Size to 14 50
79579>>>>>>>>>>>            Set Location to 98 70
79580>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79580>>>>>>>>>>>            // we might as well prepare the object for it.
79580>>>>>>>>>>>            Set peAnchors to anBottomRight
79581>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79582>>>>>>>>>>>        End_Object
79583>>>>>>>>>>>
79583>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79584>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79585>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79586>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79586>>>>>>>>>>>    End_Procedure
79587>>>>>>>>>>>
79587>>>>>>>>>>>    Procedure Page Integer iPageObject
79589>>>>>>>>>>>        Handle hMenu
79589>>>>>>>>>>>        Integer iPrevState
79589>>>>>>>>>>>
79589>>>>>>>>>>>        Forward Send Page iPageObject
79591>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79591>>>>>>>>>>>        Set Icon to "Default.ico"
79592>>>>>>>>>>>
79592>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79592>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79593>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79594>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79594>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79594>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79595>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79596>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79597>>>>>>>>>>>        // The "Close" menu command may be good to have.
79597>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79597>>>>>>>>>>>    End_Procedure
79598>>>>>>>>>>>
79598>>>>>>>>>>>    Procedure Set ProductName String sText
79600>>>>>>>>>>>        Set Value of oProductName to sText
79601>>>>>>>>>>>    End_Procedure
79602>>>>>>>>>>>
79602>>>>>>>>>>>    Procedure Set Copyright String sText
79604>>>>>>>>>>>        Set Value of oCopyright to sText
79605>>>>>>>>>>>    End_Procedure
79606>>>>>>>>>>>
79606>>>>>>>>>>>    Procedure Set Author String sText
79608>>>>>>>>>>>        Set Value of oAuthor to sText
79609>>>>>>>>>>>    End_Procedure
79610>>>>>>>>>>>
79610>>>>>>>>>>>    Procedure Set Version String sVersion
79612>>>>>>>>>>>        Handle hoVersionInfo
79612>>>>>>>>>>>        Boolean bIncluded
79612>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
79612>>>>>>>>>>>//        Date dCompileDate
79612>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79612>>>>>>>>>>>
79612>>>>>>>>>>>        If (sVersion = "") Begin
79614>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79614>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79614>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79616>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79617>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79619>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79620>>>>>>>>>>>                    If (bIncluded) Begin
79622>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79623>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79624>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79625>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79626>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79627>>>>>>>>>>>                    End
79627>>>>>>>>>>>>
79627>>>>>>>>>>>                End
79627>>>>>>>>>>>>
79627>>>>>>>>>>>            End
79627>>>>>>>>>>>>
79627>>>>>>>>>>>        End
79627>>>>>>>>>>>>
79627>>>>>>>>>>>
79627>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79627>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79628>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79630>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79631>>>>>>>>>>>        End
79631>>>>>>>>>>>>
79631>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
79631>>>>>>>>>>>//        If (sVersion <> "") Begin
79631>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79631>>>>>>>>>>>//        End
79631>>>>>>>>>>>
79631>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79632>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79634>>>>>>>>>>>            If (sCertInfo <> "") Begin
79636>>>>>>>>>>>                Send Add_LineLn sCertInfo
79637>>>>>>>>>>>            End
79637>>>>>>>>>>>>
79637>>>>>>>>>>>            Else Begin
79638>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79639>>>>>>>>>>>            End
79639>>>>>>>>>>>>
79639>>>>>>>>>>>        End
79639>>>>>>>>>>>>
79639>>>>>>>>>>>    End_Procedure
79640>>>>>>>>>>>
79640>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79642>>>>>>>>>>>        Boolean bIsDate
79642>>>>>>>>>>>        String sGoodCharacters sChar
79642>>>>>>>>>>>        Integer iCount iLength
79642>>>>>>>>>>>
79642>>>>>>>>>>>        Move True to bIsDate
79643>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79644>>>>>>>>>>>        Move (Length(sDate)) to iLength
79645>>>>>>>>>>>        For iCount from 1 to iLength
79651>>>>>>>>>>>>
79651>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79652>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79653>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79654>>>>>>>>>>>            If (bIsDate = False) Begin
79656>>>>>>>>>>>                Move iLength to iCount
79657>>>>>>>>>>>            End
79657>>>>>>>>>>>>
79657>>>>>>>>>>>        Loop
79658>>>>>>>>>>>>
79658>>>>>>>>>>>        Function_Return bIsDate
79659>>>>>>>>>>>    End_Function
79660>>>>>>>>>>>
79660>>>>>>>>>>>    Function GetCompileDate Returns Date
79662>>>>>>>>>>>        Date dCompileDate
79662>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79662>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79662>>>>>>>>>>>        Boolean bIsValid   
79662>>>>>>>>>>>        
79662>>>>>>>>>>>        Move 0 to dCompileDate
79663>>>>>>>>>>>        // Get full path to the current running executable
79663>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79664>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79665>>>>>>>>>>>
79665>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79665>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79666>>>>>>>>>>>
79666>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79668>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79669>>>>>>>>>>>        If (iPos > 0) Begin
79671>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79671>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79672>>>>>>>>>>>
79672>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79672>>>>>>>>>>>            // change the format and then move the string to the date variable.
79672>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79675>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79678>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79679>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79681>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79682>>>>>>>>>>>            End
79682>>>>>>>>>>>>
79682>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79683>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79684>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79687>>>>>>>>>>>        End
79687>>>>>>>>>>>>
79687>>>>>>>>>>>        Else Begin
79688>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79689>>>>>>>>>>>>
79689>>>>>>>>>>>        End
79689>>>>>>>>>>>>
79689>>>>>>>>>>>
79689>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79690>>>>>>>>>>>
79690>>>>>>>>>>>        Function_Return dCompileDate
79691>>>>>>>>>>>    End_Function
79692>>>>>>>>>>>
79692>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79692>>>>>>>>>>>    // (the passed program), has been finished
79692>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79692>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79694>>>>>>>>>>>        Handle hProcess
79694>>>>>>>>>>>        Integer iVoid
79694>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79694>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79694>>>>>>>>>>>
79694>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79695>>>>>>>>>>>
79695>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79696>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79697>>>>>>>>>>>
79697>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79698>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79699>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79699>>>>>>>>>>>        Move 0                       to sInfo.nShow
79700>>>>>>>>>>>
79700>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79701>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79702>>>>>>>>>>>        If (hProcess) Begin
79704>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79705>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79706>>>>>>>>>>>        End
79706>>>>>>>>>>>>
79706>>>>>>>>>>>    End_Procedure
79707>>>>>>>>>>>
79707>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79709>>>>>>>>>>>        String sDirSep
79709>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79710>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79711>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79713>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79714>>>>>>>>>>>        End
79714>>>>>>>>>>>>
79714>>>>>>>>>>>        Function_Return sPath
79715>>>>>>>>>>>    End_Function
79716>>>>>>>>>>>
79716>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79716>>>>>>>>>>>    // or there is a problem with the certificate.
79716>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79716>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79716>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79718>>>>>>>>>>>        Boolean bExists
79718>>>>>>>>>>>        String sPath sProgram sParams sRetval
79718>>>>>>>>>>>        Integer iCh
79718>>>>>>>>>>>
79718>>>>>>>>>>>        Move "" to sRetval
79719>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79720>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79721>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79722>>>>>>>>>>>        If (bExists = False) Begin
79724>>>>>>>>>>>            Function_Return "-1"
79725>>>>>>>>>>>        End
79725>>>>>>>>>>>>
79725>>>>>>>>>>>
79725>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79726>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79727>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79728>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79729>>>>>>>>>>>        Get Seq_New_Channel to iCh
79730>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79732>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79735>>>>>>>>>>>        Close_Output channel iCh
79737>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79737>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79738>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79740>>>>>>>>>>>            Readln channel iCh sRetval
79742>>>>>>>>>>>            Readln channel iCh sRetval
79744>>>>>>>>>>>            Readln channel iCh sRetval
79746>>>>>>>>>>>            Readln channel iCh sRetval
79748>>>>>>>>>>>        Close_Input channel iCh
79750>>>>>>>>>>>        Send Seq_Release_Channel iCh
79751>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79753>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79754>>>>>>>>>>>        End
79754>>>>>>>>>>>>
79754>>>>>>>>>>>        Else Begin
79755>>>>>>>>>>>            Move "" to sRetval
79756>>>>>>>>>>>        End
79756>>>>>>>>>>>>
79756>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79756>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79757>>>>>>>>>>>>
79757>>>>>>>>>>>        Function_Return sRetval
79758>>>>>>>>>>>    End_Function
79759>>>>>>>>>>>
79759>>>>>>>>>>>    Procedure Add_LineLn String sValue
79761>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79762>>>>>>>>>>>    End_Procedure
79763>>>>>>>>>>>
79763>>>>>>>>>>>    Procedure Add_Line String sValue
79765>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79766>>>>>>>>>>>    End_Procedure
79767>>>>>>>>>>>
79767>>>>>>>>>>>    Procedure Set Logo string sLogo
79769>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79769>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79770>>>>>>>>>>>    End_Procedure
79771>>>>>>>>>>>
79771>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79773>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79774>>>>>>>>>>>    End_Procedure
79775>>>>>>>>>>>
79775>>>>>>>>>>>    Procedure Show_Sysinfo
79777>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79778>>>>>>>>>>>    End_Procedure
79779>>>>>>>>>>>
79779>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79781>>>>>>>>>>>        Handle hWnd
79781>>>>>>>>>>>        Get Window_Handle to hWnd
79782>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79783>>>>>>>>>>>    End_Procedure
79784>>>>>>>>>>>
79784>>>>>>>>>>>End_Class
79785>>>>>>>>>
79785>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79787>>>>>>>>>    End_Function
79788>>>>>>>>>
79788>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79789>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79790>>>>>>>>>>
79790>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79792>>>>>>>>>>    Integer iStart iEnd
79792>>>>>>>>>>    String sRetval
79792>>>>>>>>>>
79792>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79793>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79794>>>>>>>>>>    If (iStart = 0) Begin
79796>>>>>>>>>>        Function_Return ""
79797>>>>>>>>>>    End
79797>>>>>>>>>>>
79797>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79798>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79799>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79801>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79802>>>>>>>>>>    End
79802>>>>>>>>>>>
79802>>>>>>>>>>    Else Begin
79803>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79804>>>>>>>>>>    End
79804>>>>>>>>>>>
79804>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79806>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79807>>>>>>>>>>        Decrement iEnd
79808>>>>>>>>>>    End
79808>>>>>>>>>>>
79808>>>>>>>>>>    If (iEnd <> 0) Begin
79810>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79811>>>>>>>>>>    End
79811>>>>>>>>>>>
79811>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79812>>>>>>>>>>
79812>>>>>>>>>>    Function_Return (Trim(sRetval))
79813>>>>>>>>>>End_Function
79814>>>>>>>>>>
79814>>>>>>>>>>
79814>>>>>>>>>    
79814>>>>>>>>>    Procedure Construct_Object
79816>>>>>>>>>        Handle ho
79816>>>>>>>>>        Forward Send Construct_Object
79818>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79819>>>>>>>>>        
79819>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79820>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79821>>>>>>>>>
79821>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79821>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79821>>>>>>>>>        // etc settings.
79821>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79823>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79824>>>>>>>>>            Set phoSQLConnectionHandler to ho
79825>>>>>>>>>        End
79825>>>>>>>>>>
79825>>>>>>>>>
79825>>>>>>>>>    End_Procedure
79826>>>>>>>>>
79826>>>>>>>>>    Procedure End_Construct_Object
79828>>>>>>>>>        Forward Send End_Construct_Object
79830>>>>>>>>>
79830>>>>>>>>>    End_Procedure
79831>>>>>>>>>
79831>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79831>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79831>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79831>>>>>>>>>    // Good read about which collation to select:
79831>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79831>>>>>>>>>    Procedure Set psCollation String sCollation
79833>>>>>>>>>        Set private.psCollation to sCollation
79834>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79836>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
79837>>>>>>>>>        End
79837>>>>>>>>>>
79837>>>>>>>>>    End_Procedure
79838>>>>>>>>>
79838>>>>>>>>>    Function psCollation Returns String
79840>>>>>>>>>        String sCollation
79840>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
79842>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
79843>>>>>>>>>        End   
79843>>>>>>>>>>
79843>>>>>>>>>        Else Begin
79844>>>>>>>>>            Get private.psCollation to sCollation
79845>>>>>>>>>        End
79845>>>>>>>>>>
79845>>>>>>>>>        Function_Return sCollation
79846>>>>>>>>>    End_Function
79847>>>>>>>>>
79847>>>>>>>>>    // Array sorting helper functions:
79847>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
79849>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
79851>>>>>>>>>            Function_Return (EQ)
79852>>>>>>>>>        End
79852>>>>>>>>>>
79852>>>>>>>>>
79852>>>>>>>>>        Function_Return (GT)
79853>>>>>>>>>    End_Function
79854>>>>>>>>>
79854>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
79856>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
79859>>>>>>>>>
79859>>>>>>>>>        Function_Return (GT)
79860>>>>>>>>>    End_Function
79861>>>>>>>>>
79861>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
79861>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
79861>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
79863>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
79863>>>>>>>>>        Handle hTable
79863>>>>>>>>>        Boolean bIsSame
79863>>>>>>>>>
79863>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
79864>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
79865>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
79868>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
79869>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
79872>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
79875>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
79876>>>>>>>>>
79876>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
79878>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
79879>>>>>>>>>        End
79879>>>>>>>>>>
79879>>>>>>>>>        Else Begin
79880>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
79881>>>>>>>>>        End
79881>>>>>>>>>>
79881>>>>>>>>>
79881>>>>>>>>>        Function_Return bIsSame
79882>>>>>>>>>    End_Function
79883>>>>>>>>>
79883>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
79885>>>>>>>>>        Integer iRetval
79885>>>>>>>>>        Move 1 to iRetval
79886>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
79888>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
79889>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
79890>>>>>>>>>        End
79890>>>>>>>>>>
79890>>>>>>>>>        Function_Return (iRetval = 0)
79891>>>>>>>>>    End_Function
79892>>>>>>>>>
79892>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
79894>>>>>>>>>        String sDirSep
79894>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79895>>>>>>>>>        Move (Trim(sPath)) to sPath
79896>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79898>>>>>>>>>            Move (sPath + sDirSep) to sPath
79899>>>>>>>>>        End
79899>>>>>>>>>>
79899>>>>>>>>>        Function_Return sPath
79900>>>>>>>>>    End_Function
79901>>>>>>>>>
79901>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
79903>>>>>>>>>        Integer i iCols iItem
79903>>>>>>>>>        tSqlColumnNew[] aQueryColumns
79903>>>>>>>>>        tSqlColumnNew[] aQueryColumns
79904>>>>>>>>>
79904>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
79905>>>>>>>>>        For i from 1 to iCols
79911>>>>>>>>>>
79911>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
79912>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
79913>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
79914>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
79915>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
79916>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
79917>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
79918>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
79919>>>>>>>>>        Loop
79920>>>>>>>>>>
79920>>>>>>>>>        Set piColumns to iCols
79921>>>>>>>>>        Set paQueryColumns to aQueryColumns
79922>>>>>>>>>    End_Procedure
79923>>>>>>>>>
79923>>>>>>>>>    // *** Property Messages ***
79923>>>>>>>>>    //
79923>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
79923>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
79923>>>>>>>>>    //
79923>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
79925>>>>>>>>>        tSQLConnection SQLConnection
79925>>>>>>>>>        tSQLConnection SQLConnection
79925>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79927>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79927>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79928>>>>>>>>>>
79928>>>>>>>>>            Function_Return
79929>>>>>>>>>        End
79929>>>>>>>>>>
79929>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
79930>>>>>>>>>        Function_Return SQLConnection
79931>>>>>>>>>    End_Function
79932>>>>>>>>>
79932>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
79932>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
79934>>>>>>>>>        Function_Return False
79935>>>>>>>>>    End_Function
79936>>>>>>>>>
79936>>>>>>>>>    Procedure Set psServer String sValue
79938>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79940>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
79940>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79941>>>>>>>>>>
79941>>>>>>>>>            Procedure_Return
79942>>>>>>>>>        End
79942>>>>>>>>>>
79942>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
79943>>>>>>>>>    End_Procedure
79944>>>>>>>>>
79944>>>>>>>>>    Function psServer Returns String
79946>>>>>>>>>        String sValue
79946>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79948>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79949>>>>>>>>>>
79949>>>>>>>>>            Function_Return
79950>>>>>>>>>        End
79950>>>>>>>>>>
79950>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
79951>>>>>>>>>        Function_Return sValue
79952>>>>>>>>>    End_Function
79953>>>>>>>>>
79953>>>>>>>>>    Procedure Set psDatabase String sValue
79955>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79957>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79958>>>>>>>>>>
79958>>>>>>>>>            Procedure_Return
79959>>>>>>>>>        End
79959>>>>>>>>>>
79959>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
79960>>>>>>>>>    End_Procedure
79961>>>>>>>>>
79961>>>>>>>>>    Function psDatabase Returns String
79963>>>>>>>>>        String sValue
79963>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79965>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79966>>>>>>>>>>
79966>>>>>>>>>            Function_Return
79967>>>>>>>>>        End
79967>>>>>>>>>>
79967>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
79968>>>>>>>>>        Function_Return sValue
79969>>>>>>>>>    End_Function
79970>>>>>>>>>
79970>>>>>>>>>    Procedure Set psUserID String sValue
79972>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79974>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79975>>>>>>>>>>
79975>>>>>>>>>            Procedure_Return
79976>>>>>>>>>        End
79976>>>>>>>>>>
79976>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
79977>>>>>>>>>    End_Procedure
79978>>>>>>>>>
79978>>>>>>>>>    Function psUserID Returns String
79980>>>>>>>>>        String sValue
79980>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79982>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79983>>>>>>>>>>
79983>>>>>>>>>            Function_Return
79984>>>>>>>>>        End
79984>>>>>>>>>>
79984>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
79985>>>>>>>>>        Function_Return sValue
79986>>>>>>>>>    End_Function
79987>>>>>>>>>
79987>>>>>>>>>    Procedure Set psPassword String sValue
79989>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79991>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
79992>>>>>>>>>>
79992>>>>>>>>>            Procedure_Return
79993>>>>>>>>>        End
79993>>>>>>>>>>
79993>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
79994>>>>>>>>>    End_Procedure
79995>>>>>>>>>
79995>>>>>>>>>    Function psPassword Returns String
79997>>>>>>>>>        String sValue
79997>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79999>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80000>>>>>>>>>>
80000>>>>>>>>>            Function_Return
80001>>>>>>>>>        End
80001>>>>>>>>>>
80001>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80002>>>>>>>>>        Function_Return sValue
80003>>>>>>>>>    End_Function
80004>>>>>>>>>
80004>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80006>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80008>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80009>>>>>>>>>>
80009>>>>>>>>>            Procedure_Return
80010>>>>>>>>>        End
80010>>>>>>>>>>
80010>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80011>>>>>>>>>    End_Procedure
80012>>>>>>>>>
80012>>>>>>>>>    Function pbTrusted Returns Boolean
80014>>>>>>>>>        Boolean bValue
80014>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80016>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80017>>>>>>>>>>
80017>>>>>>>>>            Function_Return
80018>>>>>>>>>        End
80018>>>>>>>>>>
80018>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80019>>>>>>>>>        Function_Return bValue
80020>>>>>>>>>    End_Function
80021>>>>>>>>>
80021>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80023>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80025>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80026>>>>>>>>>>
80026>>>>>>>>>            Procedure_Return
80027>>>>>>>>>        End
80027>>>>>>>>>>
80027>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80028>>>>>>>>>    End_Procedure
80029>>>>>>>>>
80029>>>>>>>>>    Function pbSilentLogin Returns Boolean
80031>>>>>>>>>        Boolean bValue
80031>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80033>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80034>>>>>>>>>>
80034>>>>>>>>>            Function_Return
80035>>>>>>>>>        End
80035>>>>>>>>>>
80035>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80036>>>>>>>>>        Function_Return bValue
80037>>>>>>>>>    End_Function
80038>>>>>>>>>
80038>>>>>>>>>    Procedure Set psConnectionID String sValue
80040>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80042>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80043>>>>>>>>>>
80043>>>>>>>>>            Procedure_Return
80044>>>>>>>>>        End
80044>>>>>>>>>>
80044>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80045>>>>>>>>>    End_Procedure
80046>>>>>>>>>
80046>>>>>>>>>    Function psConnectionID Returns String
80048>>>>>>>>>        String sValue
80048>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80050>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80051>>>>>>>>>>
80051>>>>>>>>>            Function_Return
80052>>>>>>>>>        End
80052>>>>>>>>>>
80052>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80053>>>>>>>>>        Function_Return sValue
80054>>>>>>>>>    End_Function
80055>>>>>>>>>
80055>>>>>>>>>    Procedure Set psConnectionString String sValue
80057>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80059>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80060>>>>>>>>>>
80060>>>>>>>>>            Procedure_Return
80061>>>>>>>>>        End
80061>>>>>>>>>>
80061>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80062>>>>>>>>>    End_Procedure
80063>>>>>>>>>
80063>>>>>>>>>    Function psConnectionString Returns String
80065>>>>>>>>>        String sValue
80065>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80067>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80068>>>>>>>>>>
80068>>>>>>>>>            Function_Return
80069>>>>>>>>>        End
80069>>>>>>>>>>
80069>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80070>>>>>>>>>        Function_Return sValue
80071>>>>>>>>>    End_Function
80072>>>>>>>>>
80072>>>>>>>>>    // The normal connection string looks something like this;
80072>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80072>>>>>>>>>    // ...and the full connection string looks like this;
80072>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80072>>>>>>>>>    Function psFullConnectionString Returns String
80074>>>>>>>>>        String sConnectionID sConnectionString
80074>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80076>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80077>>>>>>>>>>
80077>>>>>>>>>            Function_Return
80078>>>>>>>>>        End
80078>>>>>>>>>>
80078>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80079>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80080>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80081>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80082>>>>>>>>>    End_Function
80083>>>>>>>>>
80083>>>>>>>>>    Function piConnectionOptions Returns Integer
80085>>>>>>>>>        Integer iValue
80085>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80087>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80088>>>>>>>>>>
80088>>>>>>>>>            Function_Return
80089>>>>>>>>>        End
80089>>>>>>>>>>
80089>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80090>>>>>>>>>        Function_Return iValue
80091>>>>>>>>>    End_Function
80092>>>>>>>>>
80092>>>>>>>>>    Procedure Set psSchema String sValue
80094>>>>>>>>>        tSQLConnection SQLConnection
80094>>>>>>>>>        tSQLConnection SQLConnection
80094>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80096>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80097>>>>>>>>>>
80097>>>>>>>>>            Procedure_Return
80098>>>>>>>>>        End
80098>>>>>>>>>>
80098>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80099>>>>>>>>>    End_Procedure
80100>>>>>>>>>
80100>>>>>>>>>    Function psSchema Returns String
80102>>>>>>>>>        String sRetval
80102>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80104>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80105>>>>>>>>>>
80105>>>>>>>>>            Function_Return
80106>>>>>>>>>        End
80106>>>>>>>>>>
80106>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80107>>>>>>>>>        Function_Return sRetval
80108>>>>>>>>>    End_Function
80109>>>>>>>>>
80109>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80111>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80113>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80114>>>>>>>>>>
80114>>>>>>>>>            Procedure_Return
80115>>>>>>>>>        End
80115>>>>>>>>>>
80115>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80116>>>>>>>>>    End_Procedure
80117>>>>>>>>>
80117>>>>>>>>>    Function psBaseTableSpace Returns String
80119>>>>>>>>>        String sRetval
80119>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80121>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80122>>>>>>>>>>
80122>>>>>>>>>            Function_Return
80123>>>>>>>>>        End
80123>>>>>>>>>>
80123>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80124>>>>>>>>>        Function_Return sRetval
80125>>>>>>>>>    End_Function
80126>>>>>>>>>
80126>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80128>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80130>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80131>>>>>>>>>>
80131>>>>>>>>>            Procedure_Return
80132>>>>>>>>>        End
80132>>>>>>>>>>
80132>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80133>>>>>>>>>    End_Procedure
80134>>>>>>>>>
80134>>>>>>>>>    Function psLongTableSpace Returns String
80136>>>>>>>>>        String sRetval
80136>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80138>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80139>>>>>>>>>>
80139>>>>>>>>>            Function_Return
80140>>>>>>>>>        End
80140>>>>>>>>>>
80140>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80141>>>>>>>>>        Function_Return sRetval
80142>>>>>>>>>    End_Function
80143>>>>>>>>>
80143>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80145>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80147>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80148>>>>>>>>>>
80148>>>>>>>>>            Procedure_Return
80149>>>>>>>>>        End
80149>>>>>>>>>>
80149>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80150>>>>>>>>>    End_Procedure
80151>>>>>>>>>
80151>>>>>>>>>    Function psIndexTableSpace Returns String
80153>>>>>>>>>        String sRetval
80153>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80155>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80156>>>>>>>>>>
80156>>>>>>>>>            Function_Return
80157>>>>>>>>>        End
80157>>>>>>>>>>
80157>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80158>>>>>>>>>        Function_Return sRetval
80159>>>>>>>>>    End_Function
80160>>>>>>>>>
80160>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80162>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80164>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80165>>>>>>>>>>
80165>>>>>>>>>            Procedure_Return
80166>>>>>>>>>        End
80166>>>>>>>>>>
80166>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80167>>>>>>>>>    End_Procedure
80168>>>>>>>>>
80168>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80170>>>>>>>>>        Boolean bState
80170>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80172>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80173>>>>>>>>>>
80173>>>>>>>>>            Function_Return
80174>>>>>>>>>        End
80174>>>>>>>>>>
80174>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80175>>>>>>>>>        Function_Return bState
80176>>>>>>>>>    End_Function
80177>>>>>>>>>
80177>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80179>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80181>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80182>>>>>>>>>>
80182>>>>>>>>>            Procedure_Return
80183>>>>>>>>>        End
80183>>>>>>>>>>
80183>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80184>>>>>>>>>    End_Procedure
80185>>>>>>>>>
80185>>>>>>>>>    Function pbToANSI Returns Boolean
80187>>>>>>>>>        Boolean bState
80187>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80189>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80190>>>>>>>>>>
80190>>>>>>>>>            Function_Return
80191>>>>>>>>>        End
80191>>>>>>>>>>
80191>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80192>>>>>>>>>        Function_Return bState
80193>>>>>>>>>    End_Function
80194>>>>>>>>>
80194>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80196>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80198>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80199>>>>>>>>>>
80199>>>>>>>>>            Procedure_Return
80200>>>>>>>>>        End
80200>>>>>>>>>>
80200>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80201>>>>>>>>>    End_Procedure
80202>>>>>>>>>
80202>>>>>>>>>    Function pbRecnum Returns Boolean
80204>>>>>>>>>        Boolean bState
80204>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80206>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80207>>>>>>>>>>
80207>>>>>>>>>            Function_Return
80208>>>>>>>>>        End
80208>>>>>>>>>>
80208>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80209>>>>>>>>>        Function_Return bState
80210>>>>>>>>>    End_Function
80211>>>>>>>>>
80211>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80213>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80215>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80216>>>>>>>>>>
80216>>>>>>>>>            Procedure_Return
80217>>>>>>>>>        End
80217>>>>>>>>>>
80217>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80218>>>>>>>>>    End_Procedure
80219>>>>>>>>>
80219>>>>>>>>>    Function pbCopyData Returns Boolean
80221>>>>>>>>>        Boolean bState
80221>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80223>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80224>>>>>>>>>>
80224>>>>>>>>>            Function_Return
80225>>>>>>>>>        End
80225>>>>>>>>>>
80225>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80226>>>>>>>>>        Function_Return bState
80227>>>>>>>>>    End_Function
80228>>>>>>>>>
80228>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80230>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80232>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80233>>>>>>>>>>
80233>>>>>>>>>            Procedure_Return
80234>>>>>>>>>        End
80234>>>>>>>>>>
80234>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80235>>>>>>>>>    End_Procedure
80236>>>>>>>>>
80236>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80238>>>>>>>>>        Boolean bState
80238>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80240>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80241>>>>>>>>>>
80241>>>>>>>>>            Function_Return
80242>>>>>>>>>        End
80242>>>>>>>>>>
80242>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80243>>>>>>>>>        Function_Return bState
80244>>>>>>>>>    End_Function
80245>>>>>>>>>
80245>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80247>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80249>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80250>>>>>>>>>>
80250>>>>>>>>>            Procedure_Return
80251>>>>>>>>>        End
80251>>>>>>>>>>
80251>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80252>>>>>>>>>    End_Procedure
80253>>>>>>>>>
80253>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80255>>>>>>>>>        Boolean bState
80255>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80257>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80258>>>>>>>>>>
80258>>>>>>>>>            Function_Return
80259>>>>>>>>>        End
80259>>>>>>>>>>
80259>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80260>>>>>>>>>        Function_Return bState
80261>>>>>>>>>    End_Function
80262>>>>>>>>>
80262>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80264>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80266>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80267>>>>>>>>>>
80267>>>>>>>>>            Procedure_Return
80268>>>>>>>>>        End
80268>>>>>>>>>>
80268>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80269>>>>>>>>>    End_Procedure
80270>>>>>>>>>
80270>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80272>>>>>>>>>        Boolean bState
80272>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80274>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80275>>>>>>>>>>
80275>>>>>>>>>            Function_Return
80276>>>>>>>>>        End
80276>>>>>>>>>>
80276>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80277>>>>>>>>>        Function_Return bState
80278>>>>>>>>>    End_Function
80279>>>>>>>>>
80279>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80281>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80283>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80284>>>>>>>>>>
80284>>>>>>>>>            Procedure_Return
80285>>>>>>>>>        End
80285>>>>>>>>>>
80285>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80286>>>>>>>>>    End_Procedure
80287>>>>>>>>>
80287>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80289>>>>>>>>>        Boolean bState
80289>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80291>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80292>>>>>>>>>>
80292>>>>>>>>>            Function_Return
80293>>>>>>>>>        End
80293>>>>>>>>>>
80293>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80294>>>>>>>>>        Function_Return bState
80295>>>>>>>>>    End_Function
80296>>>>>>>>>
80296>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80298>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80300>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80301>>>>>>>>>>
80301>>>>>>>>>            Procedure_Return
80302>>>>>>>>>        End
80302>>>>>>>>>>
80302>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80303>>>>>>>>>    End_Procedure
80304>>>>>>>>>
80304>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80306>>>>>>>>>        String sRetval
80306>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80308>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80309>>>>>>>>>>
80309>>>>>>>>>            Function_Return
80310>>>>>>>>>        End
80310>>>>>>>>>>
80310>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80311>>>>>>>>>        Function_Return sRetval
80312>>>>>>>>>    End_Function
80313>>>>>>>>>
80313>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80315>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80317>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80318>>>>>>>>>>
80318>>>>>>>>>            Procedure_Return
80319>>>>>>>>>        End
80319>>>>>>>>>>
80319>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80320>>>>>>>>>    End_Procedure
80321>>>>>>>>>
80321>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80323>>>>>>>>>        String sRetval
80323>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80325>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80326>>>>>>>>>>
80326>>>>>>>>>            Function_Return
80327>>>>>>>>>        End
80327>>>>>>>>>>
80327>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80328>>>>>>>>>        Function_Return sRetval
80329>>>>>>>>>    End_Function
80330>>>>>>>>>
80330>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80332>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80334>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80335>>>>>>>>>>
80335>>>>>>>>>            Procedure_Return
80336>>>>>>>>>        End
80336>>>>>>>>>>
80336>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80337>>>>>>>>>    End_Procedure
80338>>>>>>>>>
80338>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80340>>>>>>>>>        String sRetval
80340>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80342>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80343>>>>>>>>>>
80343>>>>>>>>>            Function_Return
80344>>>>>>>>>        End
80344>>>>>>>>>>
80344>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80345>>>>>>>>>        Function_Return sRetval
80346>>>>>>>>>    End_Function
80347>>>>>>>>>
80347>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80349>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80351>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80352>>>>>>>>>>
80352>>>>>>>>>            Procedure_Return
80353>>>>>>>>>        End
80353>>>>>>>>>>
80353>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80354>>>>>>>>>    End_Procedure
80355>>>>>>>>>
80355>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80357>>>>>>>>>        String sRetval
80357>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80359>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80360>>>>>>>>>>
80360>>>>>>>>>            Function_Return
80361>>>>>>>>>        End
80361>>>>>>>>>>
80361>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80362>>>>>>>>>        Function_Return sRetval
80363>>>>>>>>>    End_Function
80364>>>>>>>>>
80364>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80366>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80368>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80369>>>>>>>>>>
80369>>>>>>>>>            Procedure_Return
80370>>>>>>>>>        End
80370>>>>>>>>>>
80370>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80371>>>>>>>>>    End_Procedure
80372>>>>>>>>>
80372>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80374>>>>>>>>>        String sRetval
80374>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80376>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80377>>>>>>>>>>
80377>>>>>>>>>            Function_Return
80378>>>>>>>>>        End
80378>>>>>>>>>>
80378>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80379>>>>>>>>>        Function_Return sRetval
80380>>>>>>>>>    End_Function
80381>>>>>>>>>
80381>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80383>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80385>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80386>>>>>>>>>>
80386>>>>>>>>>            Procedure_Return
80387>>>>>>>>>        End
80387>>>>>>>>>>
80387>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80388>>>>>>>>>    End_Procedure
80389>>>>>>>>>
80389>>>>>>>>>    Function psDriverDefaultValueText Returns String
80391>>>>>>>>>        String sRetval
80391>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80393>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80394>>>>>>>>>>
80394>>>>>>>>>            Function_Return
80395>>>>>>>>>        End
80395>>>>>>>>>>
80395>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80396>>>>>>>>>        Function_Return sRetval
80397>>>>>>>>>    End_Function
80398>>>>>>>>>
80398>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80400>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80402>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80403>>>>>>>>>>
80403>>>>>>>>>            Procedure_Return
80404>>>>>>>>>        End
80404>>>>>>>>>>
80404>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80405>>>>>>>>>    End_Procedure
80406>>>>>>>>>
80406>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80408>>>>>>>>>        Boolean bState
80408>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80410>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80411>>>>>>>>>>
80411>>>>>>>>>            Function_Return
80412>>>>>>>>>        End
80412>>>>>>>>>>
80412>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80413>>>>>>>>>        Function_Return bState
80414>>>>>>>>>    End_Function
80415>>>>>>>>>
80415>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80417>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80419>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80420>>>>>>>>>>
80420>>>>>>>>>            Procedure_Return
80421>>>>>>>>>        End
80421>>>>>>>>>>
80421>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80422>>>>>>>>>    End_Procedure
80423>>>>>>>>>
80423>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80425>>>>>>>>>        Boolean bState
80425>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80427>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80428>>>>>>>>>>
80428>>>>>>>>>            Function_Return
80429>>>>>>>>>        End
80429>>>>>>>>>>
80429>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80430>>>>>>>>>        Function_Return bState
80431>>>>>>>>>    End_Function
80432>>>>>>>>>
80432>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80434>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80436>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80437>>>>>>>>>>
80437>>>>>>>>>            Procedure_Return
80438>>>>>>>>>        End
80438>>>>>>>>>>
80438>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80439>>>>>>>>>    End_Procedure
80440>>>>>>>>>
80440>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80442>>>>>>>>>        Boolean bState
80442>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80444>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80445>>>>>>>>>>
80445>>>>>>>>>            Function_Return
80446>>>>>>>>>        End
80446>>>>>>>>>>
80446>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80447>>>>>>>>>        Function_Return bState
80448>>>>>>>>>    End_Function
80449>>>>>>>>>
80449>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80451>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80453>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80454>>>>>>>>>>
80454>>>>>>>>>            Procedure_Return
80455>>>>>>>>>        End
80455>>>>>>>>>>
80455>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80456>>>>>>>>>    End_Procedure
80457>>>>>>>>>
80457>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80459>>>>>>>>>        Boolean bState
80459>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80461>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80462>>>>>>>>>>
80462>>>>>>>>>            Function_Return
80463>>>>>>>>>        End
80463>>>>>>>>>>
80463>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80464>>>>>>>>>        Function_Return bState
80465>>>>>>>>>    End_Function
80466>>>>>>>>>
80466>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80468>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80470>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80471>>>>>>>>>>
80471>>>>>>>>>            Procedure_Return
80472>>>>>>>>>        End
80472>>>>>>>>>>
80472>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80473>>>>>>>>>    End_Procedure
80474>>>>>>>>>
80474>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80476>>>>>>>>>        Boolean bState
80476>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80478>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80479>>>>>>>>>>
80479>>>>>>>>>            Function_Return
80480>>>>>>>>>        End
80480>>>>>>>>>>
80480>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80481>>>>>>>>>        Function_Return bState
80482>>>>>>>>>    End_Function
80483>>>>>>>>>
80483>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80485>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80487>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80488>>>>>>>>>>
80488>>>>>>>>>            Procedure_Return
80489>>>>>>>>>        End
80489>>>>>>>>>>
80489>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80490>>>>>>>>>    End_Procedure
80491>>>>>>>>>
80491>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80493>>>>>>>>>        Boolean bState
80493>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80495>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80496>>>>>>>>>>
80496>>>>>>>>>            Function_Return
80497>>>>>>>>>        End
80497>>>>>>>>>>
80497>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80498>>>>>>>>>        Function_Return bState
80499>>>>>>>>>    End_Function
80500>>>>>>>>>
80500>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80500>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80500>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80500>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80500>>>>>>>>>    Procedure Set psDriverID String sValue
80502>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80503>>>>>>>>>        Delegate Set psDriverID to sValue
80505>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80506>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80507>>>>>>>>>    End_Procedure
80508>>>>>>>>>
80508>>>>>>>>>    Function psDriverID Returns String
80510>>>>>>>>>        String sDriverID
80510>>>>>>>>>
80510>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80511>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80511>>>>>>>>>        Delegate Get psDriverID to sDriverID
80513>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80514>>>>>>>>>        Move False to Err
80515>>>>>>>>>
80515>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80515>>>>>>>>>        // probably used as "utilites" from a special made program and
80515>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80515>>>>>>>>>        If (sDriverID = "") Begin
80517>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80518>>>>>>>>>        End
80518>>>>>>>>>>
80518>>>>>>>>>        Function_Return sDriverID
80519>>>>>>>>>    End_Function
80520>>>>>>>>>
80520>>>>>>>>>    Procedure Set piDbType Integer iValue
80522>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80523>>>>>>>>>        Delegate Set piDbType to iValue
80525>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80526>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80527>>>>>>>>>    End_Procedure
80528>>>>>>>>>
80528>>>>>>>>>    Function piDbType Returns Integer
80530>>>>>>>>>        Integer iRetval
80530>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80531>>>>>>>>>        Function_Return iRetval
80532>>>>>>>>>    End_Function
80533>>>>>>>>>
80533>>>>>>>>>    // Returns the index for the passed sTableName
80533>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80533>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80535>>>>>>>>>        Integer iIndex iSize iCount
80535>>>>>>>>>        String[] sTablesArray
80536>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80536>>>>>>>>>
80536>>>>>>>>>        Move -1 to iIndex
80537>>>>>>>>>        Get psConnectionString to sConnectionString
80538>>>>>>>>>        Get psDatabase to sDatabase
80539>>>>>>>>>        Get psSchema   to sSchema
80540>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80541>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80542>>>>>>>>>        Decrement iSize
80543>>>>>>>>>        For iCount from 0 to iSize
80549>>>>>>>>>>
80549>>>>>>>>>            Move sTablesArray[iCount] to sVal
80550>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80552>>>>>>>>>                Move iCount to iIndex // We found it!
80553>>>>>>>>>                Move iSize to iCount  // End the loop
80554>>>>>>>>>            End
80554>>>>>>>>>>
80554>>>>>>>>>        Loop
80555>>>>>>>>>>
80555>>>>>>>>>
80555>>>>>>>>>        Function_Return iIndex
80556>>>>>>>>>    End_Function
80557>>>>>>>>>
80557>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80557>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80559>>>>>>>>>        String[] sReturnArray
80560>>>>>>>>>        Boolean bOK
80560>>>>>>>>>
80560>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80561>>>>>>>>>        If (bOK = False) Begin
80563>>>>>>>>>            Function_Return sReturnArray
80564>>>>>>>>>        End
80564>>>>>>>>>>
80564>>>>>>>>>
80564>>>>>>>>>        Case Begin
80564>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80566>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80567>>>>>>>>>                Case Break
80568>>>>>>>>>
80568>>>>>>>>>            Case Else
80568>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80569>>>>>>>>>>
80569>>>>>>>>>                Case Break
80570>>>>>>>>>        Case End
80570>>>>>>>>>
80570>>>>>>>>>        Function_Return sReturnArray
80571>>>>>>>>>    End_Function
80572>>>>>>>>>
80572>>>>>>>>>    // Returns a string array with all tables for the current database.
80572>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80574>>>>>>>>>        String[] sReturnArray sArray
80576>>>>>>>>>        String sConnectionString sSelect
80576>>>>>>>>>        Integer iSize iCount iDbType
80576>>>>>>>>>        Boolean bOK
80576>>>>>>>>>
80576>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80578>>>>>>>>>            Function_Return sArray
80579>>>>>>>>>        End
80579>>>>>>>>>>
80579>>>>>>>>>
80579>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80580>>>>>>>>>        If (bOK = False) Begin
80582>>>>>>>>>            Function_Return sReturnArray
80583>>>>>>>>>        End
80583>>>>>>>>>>
80583>>>>>>>>>        If (sSchema = "") Begin
80585>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80586>>>>>>>>>        End
80586>>>>>>>>>>
80586>>>>>>>>>
80586>>>>>>>>>        Get psConnectionString to sConnectionString
80587>>>>>>>>>
80587>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80587>>>>>>>>>        // the dbType.
80587>>>>>>>>>        Get piDbType to iDbType
80588>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80590>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80592>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80593>>>>>>>>>            End
80593>>>>>>>>>>
80593>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80595>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80596>>>>>>>>>            End
80596>>>>>>>>>>
80596>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80598>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80599>>>>>>>>>            End
80599>>>>>>>>>>
80599>>>>>>>>>        End
80599>>>>>>>>>>
80599>>>>>>>>>
80599>>>>>>>>>        Case Begin
80599>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80601>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80602>>>>>>>>>                Case Break
80603>>>>>>>>>
80603>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80606>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80607>>>>>>>>>                Case Break
80608>>>>>>>>>
80608>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80611>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80612>>>>>>>>>                Case Break
80613>>>>>>>>>
80613>>>>>>>>>            Case Else
80613>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80614>>>>>>>>>>
80614>>>>>>>>>                Case Break
80615>>>>>>>>>        Case End
80615>>>>>>>>>
80615>>>>>>>>>        Function_Return sReturnArray
80616>>>>>>>>>    End_Function
80617>>>>>>>>>
80617>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80617>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80619>>>>>>>>>        String[] sReturnArray
80620>>>>>>>>>        Boolean bOK
80620>>>>>>>>>
80620>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80621>>>>>>>>>        If (bOK = False) Begin
80623>>>>>>>>>            Function_Return sReturnArray
80624>>>>>>>>>        End
80624>>>>>>>>>>
80624>>>>>>>>>
80624>>>>>>>>>        Case Begin
80624>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80626>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80627>>>>>>>>>                Case Break
80628>>>>>>>>>
80628>>>>>>>>>            Case Else
80628>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80629>>>>>>>>>>
80629>>>>>>>>>                Case Break
80630>>>>>>>>>        Case End
80630>>>>>>>>>
80630>>>>>>>>>        Function_Return sReturnArray
80631>>>>>>>>>    End_Function
80632>>>>>>>>>
80632>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80632>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80634>>>>>>>>>        String[] sReturnArray
80635>>>>>>>>>        String sConnectionString sSelect sSchema
80635>>>>>>>>>        Boolean bOK
80635>>>>>>>>>        Integer iDbType
80635>>>>>>>>>
80635>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80636>>>>>>>>>        If (bOK = False) Begin
80638>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80639>>>>>>>>>>
80639>>>>>>>>>            Function_Return sReturnArray
80640>>>>>>>>>        End
80640>>>>>>>>>>
80640>>>>>>>>>
80640>>>>>>>>>        Get psConnectionString to sConnectionString
80641>>>>>>>>>        Get psSchema to sSchema
80642>>>>>>>>>
80642>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80642>>>>>>>>>        // the dbType.
80642>>>>>>>>>        Get piDbType to iDbType
80643>>>>>>>>>
80643>>>>>>>>>        Case Begin
80643>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80645>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80647>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80648>>>>>>>>>                End
80648>>>>>>>>>>
80648>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80650>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80651>>>>>>>>>                End
80651>>>>>>>>>>
80651>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80653>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80654>>>>>>>>>                End
80654>>>>>>>>>>
80654>>>>>>>>>
80654>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80655>>>>>>>>>                Case Break
80656>>>>>>>>>
80656>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80659>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80660>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80661>>>>>>>>>                Case Break
80662>>>>>>>>>
80662>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80665>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80666>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80667>>>>>>>>>                Case Break
80668>>>>>>>>>
80668>>>>>>>>>            Case Else
80668>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80669>>>>>>>>>>
80669>>>>>>>>>                Case Break
80670>>>>>>>>>        Case End
80670>>>>>>>>>
80670>>>>>>>>>        Function_Return sReturnArray
80671>>>>>>>>>    End_Function
80672>>>>>>>>>
80672>>>>>>>>>
80672>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80672>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80674>>>>>>>>>        String[] sReturnArray sReturnArray2
80676>>>>>>>>>        String sConnectionString sSelect sSchema
80676>>>>>>>>>        Boolean bOK
80676>>>>>>>>>        Integer iCount iSize
80676>>>>>>>>>
80676>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80677>>>>>>>>>        If (bOK = False) Begin
80679>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80680>>>>>>>>>>
80680>>>>>>>>>            Function_Return sReturnArray
80681>>>>>>>>>        End
80681>>>>>>>>>>
80681>>>>>>>>>
80681>>>>>>>>>        Get psConnectionString to sConnectionString
80682>>>>>>>>>        Get psSchema to sSchema
80683>>>>>>>>>
80683>>>>>>>>>        Case Begin
80683>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80685>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80686>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80687>>>>>>>>>                Case Break
80688>>>>>>>>>
80688>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80691>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80692>>>>>>>>>>
80692>>>>>>>>>//                Move () to sSelect
80692>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80692>>>>>>>>>                Case Break
80693>>>>>>>>>
80693>>>>>>>>>            Case Else
80693>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80694>>>>>>>>>>
80694>>>>>>>>>                Case Break
80695>>>>>>>>>        Case End
80695>>>>>>>>>
80695>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80696>>>>>>>>>        Decrement iSize
80697>>>>>>>>>        For iCount from 0 to iSize
80703>>>>>>>>>>
80703>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80705>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80706>>>>>>>>>            End
80706>>>>>>>>>>
80706>>>>>>>>>        Loop
80707>>>>>>>>>>
80707>>>>>>>>>
80707>>>>>>>>>        Function_Return sReturnArray2
80708>>>>>>>>>    End_Function
80709>>>>>>>>>
80709>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80709>>>>>>>>>    // The format of the array is "TableName.FieldName"
80709>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80711>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80713>>>>>>>>>        tSQLRelation[] sRelationsArray
80713>>>>>>>>>        tSQLRelation[] sRelationsArray
80714>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80714>>>>>>>>>        Boolean bOK
80714>>>>>>>>>        Integer iCount iSize iLength
80714>>>>>>>>>
80714>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80715>>>>>>>>>        If (bOK = False) Begin
80717>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80718>>>>>>>>>>
80718>>>>>>>>>            Function_Return sRelationsArray
80719>>>>>>>>>        End
80719>>>>>>>>>>
80719>>>>>>>>>
80719>>>>>>>>>        Get psConnectionString to sConnectionString
80720>>>>>>>>>        Get psSchema to sSchema
80721>>>>>>>>>
80721>>>>>>>>>        Case Begin
80721>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80723>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80724>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80725>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80726>>>>>>>>>                Case Break
80727>>>>>>>>>
80727>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80730>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80731>>>>>>>>>>
80731>>>>>>>>>//                Move () to sSelect
80731>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80731>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80731>>>>>>>>>                Case Break
80732>>>>>>>>>
80732>>>>>>>>>            Case Else
80732>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80733>>>>>>>>>>
80733>>>>>>>>>                Case Break
80734>>>>>>>>>        Case End
80734>>>>>>>>>
80734>>>>>>>>>        Move (Length(sTableName)) to iLength
80735>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80736>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80737>>>>>>>>>        Decrement iSize
80738>>>>>>>>>        For iCount from 0 to iSize
80744>>>>>>>>>>
80744>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80746>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80747>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80748>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80749>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80750>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80751>>>>>>>>>            End
80751>>>>>>>>>>
80751>>>>>>>>>        Loop
80752>>>>>>>>>>
80752>>>>>>>>>
80752>>>>>>>>>        Function_Return sRelationsArray
80753>>>>>>>>>    End_Function
80754>>>>>>>>>
80754>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80756>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80756>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80757>>>>>>>>>        String[] sUsers sPrograms
80759>>>>>>>>>        String sSelect
80759>>>>>>>>>        Integer iSize iCount
80759>>>>>>>>>
80759>>>>>>>>>        Case Begin
80759>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80761>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80762>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80763>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80764>>>>>>>>>                Case Break
80765>>>>>>>>>            Case Else
80765>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80766>>>>>>>>>>
80766>>>>>>>>>        Case End
80766>>>>>>>>>
80766>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80767>>>>>>>>>        Decrement iSize
80768>>>>>>>>>        For iCount from 0 to iSize
80774>>>>>>>>>>
80774>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80775>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80776>>>>>>>>>        Loop
80777>>>>>>>>>>
80777>>>>>>>>>
80777>>>>>>>>>        Function_Return SQLLoggedInUser
80778>>>>>>>>>    End_Function
80779>>>>>>>>>
80779>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80779>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80779>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80781>>>>>>>>>        String[] sFilesData
80782>>>>>>>>>        Boolean bExists
80782>>>>>>>>>        Integer iCh
80782>>>>>>>>>        String sFileName sExt
80782>>>>>>>>>
80782>>>>>>>>>        Get vFolderExists sDataPath to bExists
80783>>>>>>>>>        If (bExists = True) Begin
80785>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80786>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80787>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80788>>>>>>>>>            Direct_Input channel iCh sDataPath
80790>>>>>>>>>                Repeat
80790>>>>>>>>>>
80790>>>>>>>>>                    Readln channel iCh sFileName
80792>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80793>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80795>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80797>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80798>>>>>>>>>                        End
80798>>>>>>>>>>
80798>>>>>>>>>                    End
80798>>>>>>>>>>
80798>>>>>>>>>                Until (SeqEof = True)
80800>>>>>>>>>            Close_Input channel iCh
80802>>>>>>>>>            Send Seq_Release_Channel iCh
80803>>>>>>>>>        End
80803>>>>>>>>>>
80803>>>>>>>>>        Function_Return sFilesData
80804>>>>>>>>>    End_Function
80805>>>>>>>>>
80805>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80805>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80807>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80807>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80807>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80807>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80807>>>>>>>>>        tSQLConnection SQLConnection
80807>>>>>>>>>        tSQLConnection SQLConnection
80807>>>>>>>>>        String[] asCollations
80808>>>>>>>>>        
80808>>>>>>>>>        If (sDriverID = "") Begin
80810>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80811>>>>>>>>>>
80811>>>>>>>>>            Function_Return asCollations
80812>>>>>>>>>        End
80812>>>>>>>>>>
80812>>>>>>>>>
80812>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80812>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80814>>>>>>>>>            Function_Return asCollations
80815>>>>>>>>>        End                 
80815>>>>>>>>>>
80815>>>>>>>>>
80815>>>>>>>>>        Get phoSQLManager to hoSQLManager
80816>>>>>>>>>        Get psConnectionID     to sConnectionID
80817>>>>>>>>>        Get psConnectionString to sConnectionString
80818>>>>>>>>>        Move 0 to LastErr
80819>>>>>>>>>
80819>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80820>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80821>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80822>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80824>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80825>>>>>>>>>>
80825>>>>>>>>>            Function_Return asCollations
80826>>>>>>>>>        End
80826>>>>>>>>>>
80826>>>>>>>>>
80826>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80827>>>>>>>>>
80827>>>>>>>>>        If (hStmt = 0) Begin
80829>>>>>>>>>            Send SqlDisconnect of hoSQLManager
80830>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80831>>>>>>>>>>
80831>>>>>>>>>            Function_Return asCollations
80832>>>>>>>>>        End
80832>>>>>>>>>>
80832>>>>>>>>>
80832>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80833>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80834>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80835>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80836>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80837>>>>>>>>>
80837>>>>>>>>>        // MS-SQL Syntax:  
80837>>>>>>>>>        // SELECT name, description
80837>>>>>>>>>        //   from sys.fn_helpcollations();
80837>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80838>>>>>>>>>
80838>>>>>>>>>        Move 1 to iColumn
80839>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
80840>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80841>>>>>>>>>        Repeat
80841>>>>>>>>>>
80841>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
80842>>>>>>>>>            If (iFetchResult <> 0) Begin
80844>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
80845>>>>>>>>>                If (sValue <> sPrevious) Begin         
80847>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
80847>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
80847>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
80848>>>>>>>>>                    If (iPos <> 1) Begin
80850>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
80851>>>>>>>>>                    End
80851>>>>>>>>>>
80851>>>>>>>>>                End
80851>>>>>>>>>>
80851>>>>>>>>>                Move sValue to sPrevious
80852>>>>>>>>>            End
80852>>>>>>>>>>
80852>>>>>>>>>        Until (iFetchResult = 0)
80854>>>>>>>>>        Send SQLClose of hStmt
80855>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
80856>>>>>>>>>
80856>>>>>>>>>        Function_Return asCollations
80857>>>>>>>>>    End_Function
80858>>>>>>>>>
80858>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
80858>>>>>>>>>    // for DAW drivers.
80858>>>>>>>>>    // Returns: A string array.
80858>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
80860>>>>>>>>>        String[] sReturnArray
80861>>>>>>>>>        String sValue sPrevious
80861>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
80861>>>>>>>>>        Integer iFetchResult iRows
80861>>>>>>>>>        tSQLConnection SQLConnection
80861>>>>>>>>>        tSQLConnection SQLConnection
80861>>>>>>>>>
80861>>>>>>>>>        Get phoSQLManager to hoSQLHandler
80862>>>>>>>>>
80862>>>>>>>>>        If (hoSQLHandler <> 0) Begin
80864>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80865>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
80866>>>>>>>>>
80866>>>>>>>>>            If (hoSQLConnect <> 0) Begin
80868>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
80869>>>>>>>>>                If (hstmt <> 0) Begin
80871>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
80872>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
80873>>>>>>>>>                    Repeat
80873>>>>>>>>>>
80873>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
80874>>>>>>>>>                        If (iFetchResult <> 0) Begin
80876>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
80877>>>>>>>>>                            If (sValue <> sPrevious) Begin
80879>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
80880>>>>>>>>>                            End
80880>>>>>>>>>>
80880>>>>>>>>>                            Move sValue to sPrevious
80881>>>>>>>>>                        End
80881>>>>>>>>>>
80881>>>>>>>>>                    Until (iFetchResult = 0)
80883>>>>>>>>>                    Send SQLClose of hstmt
80884>>>>>>>>>                End
80884>>>>>>>>>>
80884>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
80885>>>>>>>>>            End
80885>>>>>>>>>>
80885>>>>>>>>>        End
80885>>>>>>>>>>
80885>>>>>>>>>
80885>>>>>>>>>        Function_Return sReturnArray
80886>>>>>>>>>    End_Function
80887>>>>>>>>>
80887>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
80889>>>>>>>>>        String[] sReturnArray
80890>>>>>>>>>        String sDataSource
80890>>>>>>>>>        Handle hoSQLHandler
80890>>>>>>>>>        Integer iItem
80890>>>>>>>>>
80890>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
80891>>>>>>>>>        Send SeedDataSources of hoSQLHandler
80892>>>>>>>>>
80892>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80893>>>>>>>>>
80893>>>>>>>>>        Repeat
80893>>>>>>>>>>
80893>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
80894>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
80895>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
80896>>>>>>>>>            Increment iItem
80897>>>>>>>>>        Until (sDataSource = "")
80899>>>>>>>>>
80899>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80900>>>>>>>>>
80900>>>>>>>>>        Function_Return sReturnArray
80901>>>>>>>>>    End_Function
80902>>>>>>>>>
80902>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
80904>>>>>>>>>        String[] sReturnArray
80905>>>>>>>>>        String sDataSource
80905>>>>>>>>>        Handle hoSQLHandler
80905>>>>>>>>>        Integer iItem
80905>>>>>>>>>
80905>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
80906>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80907>>>>>>>>>
80907>>>>>>>>>        Send SeedDataSources of hoSQLHandler
80908>>>>>>>>>
80908>>>>>>>>>        Repeat
80908>>>>>>>>>>
80908>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
80909>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
80911>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
80912>>>>>>>>>                Increment iItem
80913>>>>>>>>>            End
80913>>>>>>>>>>
80913>>>>>>>>>        Until (sDataSource = "")
80915>>>>>>>>>
80915>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80916>>>>>>>>>
80916>>>>>>>>>        Function_Return sReturnArray
80917>>>>>>>>>    End_Function
80918>>>>>>>>>
80918>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
80920>>>>>>>>>        String[] sDataSources
80921>>>>>>>>>        tSQLConnection SQLConnection
80921>>>>>>>>>        tSQLConnection SQLConnection
80921>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
80921>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
80922>>>>>>>>>        Integer iDataSources iCount iItem
80922>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
80922>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
80922>>>>>>>>>        Boolean bExists bKeyOpened
80922>>>>>>>>>
80922>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80923>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
80924>>>>>>>>>        Move SQLConnection.sServer           to sServer
80925>>>>>>>>>
80925>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
80925>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
80927>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
80928>>>>>>>>>            Set psFileName of hoIniFile to sServer
80929>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
80930>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
80931>>>>>>>>>            Send Destroy of hoIniFile
80932>>>>>>>>>        End
80932>>>>>>>>>>
80932>>>>>>>>>
80932>>>>>>>>>        // DSN - read DATABASE name from the registry
80932>>>>>>>>>        Else Begin
80933>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
80934>>>>>>>>>
80934>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
80934>>>>>>>>>            // most probably place the info is kept that we're after.
80934>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
80935>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80936>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
80937>>>>>>>>>            If (bExists = True) Begin
80939>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
80940>>>>>>>>>            End
80940>>>>>>>>>>
80940>>>>>>>>>            Else Begin
80941>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80942>>>>>>>>>            End
80942>>>>>>>>>>
80942>>>>>>>>>
80942>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
80943>>>>>>>>>            If (bExists) Begin
80945>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80946>>>>>>>>>                If (bKeyOpened) Begin
80948>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80949>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80950>>>>>>>>>                    If (iDataSources > 0) Begin
80952>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80953>>>>>>>>>                        Decrement iDataSources
80954>>>>>>>>>                        for iCount from 0 to iDataSources
80960>>>>>>>>>>
80960>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
80961>>>>>>>>>                        Loop
80962>>>>>>>>>>
80962>>>>>>>>>                        Move 0 to iItem
80963>>>>>>>>>                        for iCount from 0 to iDataSources
80969>>>>>>>>>>
80969>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
80970>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
80971>>>>>>>>>                            If (bKeyOpened = True) Begin
80973>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
80974>>>>>>>>>                                If (bExists = True) Begin
80976>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
80977>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
80978>>>>>>>>>                                    Increment iItem
80979>>>>>>>>>                                End
80979>>>>>>>>>>
80979>>>>>>>>>                            End
80979>>>>>>>>>>
80979>>>>>>>>>                        Loop
80980>>>>>>>>>>
80980>>>>>>>>>                    End
80980>>>>>>>>>>
80980>>>>>>>>>                    Send CloseKey of hoRegistry
80981>>>>>>>>>                    Send Destroy of hoODBCDataSources
80982>>>>>>>>>                End
80982>>>>>>>>>>
80982>>>>>>>>>            End
80982>>>>>>>>>>
80982>>>>>>>>>
80982>>>>>>>>>            // We then check the "User DNS" area in the registry.
80982>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
80983>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
80984>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
80985>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
80986>>>>>>>>>
80986>>>>>>>>>            If (bExists) Begin
80988>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
80989>>>>>>>>>                If (bKeyOpened) Begin
80991>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
80992>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
80993>>>>>>>>>                    If (iDataSources > 0) Begin
80995>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
80996>>>>>>>>>                        Decrement iDataSources
80997>>>>>>>>>                        for iCount from 0 to iDataSources
81003>>>>>>>>>>
81003>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81004>>>>>>>>>                        Loop
81005>>>>>>>>>>
81005>>>>>>>>>                        for iCount from 0 to iDataSources
81011>>>>>>>>>>
81011>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81012>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81013>>>>>>>>>                            If (bKeyOpened = True) Begin
81015>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81016>>>>>>>>>                                If (bExists = True) Begin
81018>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81019>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81020>>>>>>>>>                                    Increment iItem
81021>>>>>>>>>                                End
81021>>>>>>>>>>
81021>>>>>>>>>                            End
81021>>>>>>>>>>
81021>>>>>>>>>                        Loop
81022>>>>>>>>>>
81022>>>>>>>>>                    End
81022>>>>>>>>>>
81022>>>>>>>>>                    Send CloseKey of hoRegistry
81023>>>>>>>>>                    Send Destroy of hoODBCDataSources
81024>>>>>>>>>                End
81024>>>>>>>>>>
81024>>>>>>>>>            End
81024>>>>>>>>>>
81024>>>>>>>>>
81024>>>>>>>>>            Send Destroy of hoRegistry
81025>>>>>>>>>        End
81025>>>>>>>>>>
81025>>>>>>>>>
81025>>>>>>>>>        Function_Return sReturnArray
81026>>>>>>>>>    End_Function
81027>>>>>>>>>
81027>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81027>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81027>>>>>>>>>    // insert it for scriplets to come after the first one.
81027>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81029>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81029>>>>>>>>>        Integer iStart iEnd iDbType
81029>>>>>>>>>        Boolean bOK
81029>>>>>>>>>
81029>>>>>>>>>        Get piDbType to iDbType
81030>>>>>>>>>        Get psDriverID to sDriverID
81031>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81032>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81033>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81034>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81035>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81036>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81038>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81039>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81040>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81041>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81042>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81043>>>>>>>>>        End
81043>>>>>>>>>>
81043>>>>>>>>>        Else Begin
81044>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81045>>>>>>>>>
81045>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81045>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81047>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81048>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81049>>>>>>>>>            End
81049>>>>>>>>>>
81049>>>>>>>>>
81049>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81049>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81049>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81049>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81052>>>>>>>>>                // Make sure we only have one space between statements/words.
81052>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81053>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81054>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81055>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81056>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81057>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81059>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81060>>>>>>>>>                End
81060>>>>>>>>>>
81060>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81061>>>>>>>>>                // Remove data view as it already exists!
81061>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81062>>>>>>>>>            End
81062>>>>>>>>>>
81062>>>>>>>>>        End
81062>>>>>>>>>>
81062>>>>>>>>>
81062>>>>>>>>>        Function_Return sStmt
81063>>>>>>>>>    End_Function
81064>>>>>>>>>
81064>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81064>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81066>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81066>>>>>>>>>        Integer iRetval
81066>>>>>>>>>        Boolean bOK
81066>>>>>>>>>
81066>>>>>>>>>        Get psDriverID to sDriverID
81067>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81068>>>>>>>>>
81068>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81069>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81070>>>>>>>>>        Set psSQLStatementString to sSQLString
81071>>>>>>>>>
81071>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81071>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81071>>>>>>>>>        Move False to Err
81072>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81073>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81074>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81075>>>>>>>>>        Move 0 to LastErr
81076>>>>>>>>>
81076>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81076>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81077>>>>>>>>>
81077>>>>>>>>>        Function_Return (Err = False)
81078>>>>>>>>>    End_Function
81079>>>>>>>>>
81079>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81079>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81081>>>>>>>>>        String sRetval
81081>>>>>>>>>        Integer iDbType iIndex
81081>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81081>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81082>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81082>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81082>>>>>>>>>
81082>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81082>>>>>>>>>        Move "" to sRetval
81083>>>>>>>>>        Get piDbType to iDbType
81084>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81085>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81086>>>>>>>>>
81086>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81087>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81088>>>>>>>>>        If (iIndex >= 0) Begin
81090>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81091>>>>>>>>>        End
81091>>>>>>>>>>
81091>>>>>>>>>
81091>>>>>>>>>        Function_Return sRetval
81092>>>>>>>>>    End_Function
81093>>>>>>>>>
81093>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81093>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81095>>>>>>>>>        String[] sSQLScriptArray
81096>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81096>>>>>>>>>        Integer iSize iCount
81096>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81096>>>>>>>>>
81096>>>>>>>>>        Move False to bCommentStart
81097>>>>>>>>>        Move False to bCommentEnd
81098>>>>>>>>>        Move False to bDashComment
81099>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81100>>>>>>>>>        Move "*/"  to sCommentEnd
81101>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81102>>>>>>>>>
81102>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81103>>>>>>>>>        Decrement iSize
81104>>>>>>>>>        Move "" to sText
81105>>>>>>>>>
81105>>>>>>>>>        for iCount from 0 to iSize
81111>>>>>>>>>>
81111>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81112>>>>>>>>>            Move (Trim(sLine)) to sTmp
81113>>>>>>>>>            If (sTmp <> "") Begin
81115>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81116>>>>>>>>>                If (bCommentStart = False) Begin
81118>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81119>>>>>>>>>                    If (bCommentStart = False) Begin
81121>>>>>>>>>                    End
81121>>>>>>>>>>
81121>>>>>>>>>                End
81121>>>>>>>>>>
81121>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81122>>>>>>>>>                If (bCommentEnd = True) Begin
81124>>>>>>>>>                    Move False to bCommentStart
81125>>>>>>>>>                End
81125>>>>>>>>>>
81125>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81127>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81128>>>>>>>>>                End
81128>>>>>>>>>>
81128>>>>>>>>>            End
81128>>>>>>>>>>
81128>>>>>>>>>        Loop
81129>>>>>>>>>>
81129>>>>>>>>>
81129>>>>>>>>>        // Update the retval struct array:
81129>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81130>>>>>>>>>        Function_Return SqlScriptArray
81131>>>>>>>>>    End_Function
81132>>>>>>>>>
81132>>>>>>>>>    // Helper function that builds a string like;
81132>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81132>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81134>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81134>>>>>>>>>
81134>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81135>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81136>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81137>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81138>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81139>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81140>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81141>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81142>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81143>>>>>>>>>        Function_Return sRetval
81144>>>>>>>>>    End_Function
81145>>>>>>>>>
81145>>>>>>>>>    // Helper function to create a SQL statement like;
81145>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81145>>>>>>>>>    // Used for checking if an index exists.
81145>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81147>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81147>>>>>>>>>
81147>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81148>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81149>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81150>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81151>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81152>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81153>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81154>>>>>>>>>
81154>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81155>>>>>>>>>
81155>>>>>>>>>        Function_Return sRetval
81156>>>>>>>>>    End_Function
81157>>>>>>>>>
81157>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81157>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81157>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81159>>>>>>>>>        String sRetval
81159>>>>>>>>>        If (iLength <> 0) Begin
81161>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81162>>>>>>>>>            If (iDecimals <> 0) Begin
81164>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81165>>>>>>>>>            End
81165>>>>>>>>>>
81165>>>>>>>>>            Move (sRetval + ")") to sRetval
81166>>>>>>>>>        End
81166>>>>>>>>>>
81166>>>>>>>>>        Function_Return sRetval
81167>>>>>>>>>    End_Function
81168>>>>>>>>>
81168>>>>>>>>>    // Checks that the passed sDriverID is defined.
81168>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81168>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81170>>>>>>>>>        Boolean bOK
81170>>>>>>>>>        Integer iDriver
81170>>>>>>>>>
81170>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81172>>>>>>>>>            Function_Return False
81173>>>>>>>>>        End
81173>>>>>>>>>>
81173>>>>>>>>>
81173>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81174>>>>>>>>>
81174>>>>>>>>>        If (bOK = False) Begin
81176>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81177>>>>>>>>>>
81177>>>>>>>>>            Function_Return False
81178>>>>>>>>>        End
81178>>>>>>>>>>
81178>>>>>>>>>
81178>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81179>>>>>>>>>        If (iDriver = 0) Begin
81181>>>>>>>>>            Load_Driver sDriverID
81182>>>>>>>>>        End
81182>>>>>>>>>>
81182>>>>>>>>>
81182>>>>>>>>>        Function_Return True
81183>>>>>>>>>    End_Function
81184>>>>>>>>>
81184>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81184>>>>>>>>>    // This is only of concern for certain SQL data types.
81184>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81186>>>>>>>>>        Integer iLength
81186>>>>>>>>>        Boolean bOK bCheckTypeLength
81186>>>>>>>>>
81186>>>>>>>>>        If (num_arguments > 1) Begin
81188>>>>>>>>>            Move iLen to iLength
81189>>>>>>>>>        End
81189>>>>>>>>>>
81189>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81190>>>>>>>>>
81190>>>>>>>>>        If (bCheckTypeLength = True) Begin
81192>>>>>>>>>            Move (iLength > 0) to bOK
81193>>>>>>>>>        End
81193>>>>>>>>>>
81193>>>>>>>>>
81193>>>>>>>>>        Function_Return (bOK = True)
81194>>>>>>>>>    End_Function
81195>>>>>>>>>
81195>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81197>>>>>>>>>        String sVal sSchema sDriverID
81197>>>>>>>>>        Integer iDbType
81197>>>>>>>>>
81197>>>>>>>>>        If (Trim(sTableName) = "") Begin
81199>>>>>>>>>            Function_Return ""
81200>>>>>>>>>        End
81200>>>>>>>>>>
81200>>>>>>>>>
81200>>>>>>>>>        Get psDriverID to sDriverID
81201>>>>>>>>>        Get piDbType   to iDbType
81202>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81204>>>>>>>>>            Get psUserID to sSchema
81205>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81205>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81206>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81207>>>>>>>>>            Function_Return sTableName
81208>>>>>>>>>        End
81208>>>>>>>>>>
81208>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81210>>>>>>>>>            Get psDatabase to sVal
81211>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81212>>>>>>>>>            Function_Return sTableName
81213>>>>>>>>>        End
81213>>>>>>>>>>
81213>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81215>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81216>>>>>>>>>            Function_Return sTableName
81217>>>>>>>>>        End
81217>>>>>>>>>>
81217>>>>>>>>>
81217>>>>>>>>>        Get psSchema to sSchema
81218>>>>>>>>>        If (sSchema = "") Begin
81220>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81221>>>>>>>>>        End
81221>>>>>>>>>>
81221>>>>>>>>>
81221>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81222>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81224>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81226>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81227>>>>>>>>>            End
81227>>>>>>>>>>
81227>>>>>>>>>            Else Begin
81228>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81229>>>>>>>>>            End
81229>>>>>>>>>>
81229>>>>>>>>>        End
81229>>>>>>>>>>
81229>>>>>>>>>
81229>>>>>>>>>        Function_Return sTableName
81230>>>>>>>>>    End_Function
81231>>>>>>>>>
81231>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81231>>>>>>>>>    // the passed sFieldName has the correct spelling.
81231>>>>>>>>>    // Used with Embedded SQL statement calls.
81231>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81231>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81233>>>>>>>>>        String sRetval sValue sDriverID
81233>>>>>>>>>        String[] sColumnNamesArray
81234>>>>>>>>>        Integer iCount iColumns
81234>>>>>>>>>
81234>>>>>>>>>        Move "" to sRetval
81235>>>>>>>>>        Get psDriverID to sDriverID
81236>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81237>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81238>>>>>>>>>        Decrement iColumns
81239>>>>>>>>>
81239>>>>>>>>>        For iCount from 0 to iColumns
81245>>>>>>>>>>
81245>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81246>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81248>>>>>>>>>                Move sValue to sRetval
81249>>>>>>>>>                Move iColumns to iCount // We're done.
81250>>>>>>>>>            End
81250>>>>>>>>>>
81250>>>>>>>>>        Loop
81251>>>>>>>>>>
81251>>>>>>>>>
81251>>>>>>>>>        Function_Return sRetval
81252>>>>>>>>>    End_Function
81253>>>>>>>>>
81253>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81255>>>>>>>>>        String[] sReturnArray
81256>>>>>>>>>        Handle hoSQLHandler
81256>>>>>>>>>        Integer iCount iSize iItem
81256>>>>>>>>>        String sServer
81256>>>>>>>>>        tSQLConnection SQLConnection
81256>>>>>>>>>        tSQLConnection SQLConnection
81256>>>>>>>>>
81256>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81257>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81258>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81259>>>>>>>>>
81259>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81260>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81261>>>>>>>>>        Decrement iSize
81262>>>>>>>>>
81262>>>>>>>>>        For iCount from 0 to iSize
81268>>>>>>>>>>
81268>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81269>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81270>>>>>>>>>            Increment iItem
81271>>>>>>>>>        Loop
81272>>>>>>>>>>
81272>>>>>>>>>
81272>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81273>>>>>>>>>
81273>>>>>>>>>        Function_Return sReturnArray
81274>>>>>>>>>    End_Function
81275>>>>>>>>>
81275>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81277>>>>>>>>>        String[] sReturnArray
81278>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81278>>>>>>>>>        Handle hoSQLHandler
81278>>>>>>>>>        Integer iCount iSize iItem iPos
81278>>>>>>>>>        Boolean bOK
81278>>>>>>>>>        tSQLConnection SQLConnection
81278>>>>>>>>>        tSQLConnection SQLConnection
81278>>>>>>>>>
81278>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81279>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81281>>>>>>>>>            Function_Return sReturnArray
81282>>>>>>>>>        End
81282>>>>>>>>>>
81282>>>>>>>>>
81282>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81283>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81284>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81285>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81286>>>>>>>>>
81286>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81287>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81288>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81289>>>>>>>>>
81289>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81290>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81291>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81291>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81291>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81291>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81291>>>>>>>>>//                If (iPos > 0) Begin
81291>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81291>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81291>>>>>>>>>//                End
81291>>>>>>>>>//            End
81291>>>>>>>>>//        End
81291>>>>>>>>>
81291>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81292>>>>>>>>>        Move False to Err
81293>>>>>>>>>        Move 0 to iItem
81294>>>>>>>>>
81294>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81294>>>>>>>>>        For iCount from 1 to iSize
81300>>>>>>>>>>
81300>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81301>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81302>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81303>>>>>>>>>            If (sSchema = "") Begin
81305>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81306>>>>>>>>>            End
81306>>>>>>>>>>
81306>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81307>>>>>>>>>            Move (Trim(sTable)) to sTable
81308>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81310>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81311>>>>>>>>>            End
81311>>>>>>>>>>
81311>>>>>>>>>            Else Begin
81312>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81313>>>>>>>>>            End
81313>>>>>>>>>>
81313>>>>>>>>>            If (bOK = True) Begin
81315>>>>>>>>>                Move sTable to sReturnArray[iItem]
81316>>>>>>>>>                Increment iItem
81317>>>>>>>>>            End
81317>>>>>>>>>>
81317>>>>>>>>>        Loop
81318>>>>>>>>>>
81318>>>>>>>>>
81318>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81319>>>>>>>>>
81319>>>>>>>>>        Function_Return sReturnArray
81320>>>>>>>>>    End_Function
81321>>>>>>>>>
81321>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81323>>>>>>>>>        String[] sReturnArray
81324>>>>>>>>>        String sValue
81324>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81324>>>>>>>>>        Integer iRetval iCols iFetchResult
81324>>>>>>>>>        tSQLConnection SQLConnection
81324>>>>>>>>>        tSQLConnection SQLConnection
81324>>>>>>>>>
81324>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81325>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81326>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81327>>>>>>>>>
81327>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81329>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81330>>>>>>>>>            If (hStmt <> 0) Begin
81332>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81333>>>>>>>>>                If (sArgument <> "") Begin
81335>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81336>>>>>>>>>                End
81336>>>>>>>>>>
81336>>>>>>>>>
81336>>>>>>>>>                Send SqlCall             of hStmt
81337>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81338>>>>>>>>>                If (iRetval = 0) Begin
81340>>>>>>>>>                    Repeat
81340>>>>>>>>>>
81340>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81341>>>>>>>>>                        If (iCols > 0) Begin
81343>>>>>>>>>                            Repeat
81343>>>>>>>>>>
81343>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81344>>>>>>>>>                                If (iFetchResult <> 0) Begin
81346>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81347>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81348>>>>>>>>>                                End
81348>>>>>>>>>>
81348>>>>>>>>>                            Until (iFetchResult = 0)
81350>>>>>>>>>                        End
81350>>>>>>>>>>
81350>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81351>>>>>>>>>                    Until (iRetval = 0)
81353>>>>>>>>>                    Send SqlClose of hStmt
81354>>>>>>>>>                End
81354>>>>>>>>>>
81354>>>>>>>>>            End
81354>>>>>>>>>>
81354>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81355>>>>>>>>>        End
81355>>>>>>>>>>
81355>>>>>>>>>        Function_Return sReturnArray
81356>>>>>>>>>    End_Function
81357>>>>>>>>>
81357>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81359>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81359>>>>>>>>>        Boolean bOpened bOK
81359>>>>>>>>>
81359>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81359>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81359>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81359>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81359>>>>>>>>>        // proper .int files for the two tables.
81359>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81361>>>>>>>>>            Function_Return True
81362>>>>>>>>>        End
81362>>>>>>>>>>
81362>>>>>>>>>
81362>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81365>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81366>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81367>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81368>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81369>>>>>>>>>
81369>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81369>>>>>>>>>        Sleep 1
81370>>>>>>>>>
81370>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81373>>>>>>>>>        If (bOpened = False) Begin
81375>>>>>>>>>            Open hTable
81377>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81380>>>>>>>>>        End
81380>>>>>>>>>>
81380>>>>>>>>>        If (bOpened = False) Begin
81382>>>>>>>>>            Function_Return False
81383>>>>>>>>>        End
81383>>>>>>>>>>
81383>>>>>>>>>
81383>>>>>>>>>        Get psDriverID to sDriverID
81384>>>>>>>>>
81384>>>>>>>>>        Move False to Err
81385>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81388>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81389>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81389>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81389>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81390>>>>>>>>>
81390>>>>>>>>>        Move False to Err
81391>>>>>>>>>
81391>>>>>>>>>        If (hTable > 0) Begin
81393>>>>>>>>>            Structure_Start hTable
81394>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81397>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81400>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81402>>>>>>>>>        End
81402>>>>>>>>>>
81402>>>>>>>>>        Else Begin
81403>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81406>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81409>>>>>>>>>        End
81409>>>>>>>>>>
81409>>>>>>>>>        Function_Return (Err = False)
81410>>>>>>>>>    End_Function
81411>>>>>>>>>
81411>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81411>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81413>>>>>>>>>        Handle hTable
81413>>>>>>>>>        String sConnectionID
81413>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81413>>>>>>>>>
81413>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81414>>>>>>>>>        If (bSameTableNames = True) Begin
81416>>>>>>>>>            Function_Return True
81417>>>>>>>>>        End
81417>>>>>>>>>>
81417>>>>>>>>>
81417>>>>>>>>>        Move True to bOK
81418>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81419>>>>>>>>>        Set Private.phCurrentTable              to hTable
81420>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81423>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81426>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81429>>>>>>>>>
81429>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81431>>>>>>>>>            Get psConnectionID to sConnectionID
81432>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81433>>>>>>>>>            If (bTableExists = True) Begin
81435>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81436>>>>>>>>>            End
81436>>>>>>>>>>
81436>>>>>>>>>            Else Begin
81437>>>>>>>>>                Get pbToANSI to bANSI
81438>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81439>>>>>>>>>            End
81439>>>>>>>>>>
81439>>>>>>>>>        End
81439>>>>>>>>>>
81439>>>>>>>>>
81439>>>>>>>>>        Function_Return bOK
81440>>>>>>>>>    End_Function
81441>>>>>>>>>
81441>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81441>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81441>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81443>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81443>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81443>>>>>>>>>        String[] sIndexArray
81444>>>>>>>>>        Integer iCount iCh iSize
81444>>>>>>>>>
81444>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81445>>>>>>>>>        Get psConnectionString to sConnectionString
81446>>>>>>>>>
81446>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81447>>>>>>>>>        If (bANSI = False) Begin
81449>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81450>>>>>>>>>        End
81450>>>>>>>>>>
81450>>>>>>>>>
81450>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81451>>>>>>>>>        Get vFolderExists sDataPath to bOK
81452>>>>>>>>>        If (bOK = False) Begin
81454>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81455>>>>>>>>>>
81455>>>>>>>>>            Function_Return False
81456>>>>>>>>>        End
81456>>>>>>>>>>
81456>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81457>>>>>>>>>
81457>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81460>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81463>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81464>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81465>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81466>>>>>>>>>
81466>>>>>>>>>        Get psSchema hTable to sSchemaName
81467>>>>>>>>>        If (sSchemaName = "") Begin
81469>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81470>>>>>>>>>        End
81470>>>>>>>>>>
81470>>>>>>>>>
81470>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81470>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81471>>>>>>>>>        If (bExists = True) Begin
81473>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81474>>>>>>>>>        End
81474>>>>>>>>>>
81474>>>>>>>>>
81474>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81475>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81476>>>>>>>>>
81476>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81477>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81482>>>>>>>>>            If (bUseConnectionID = True) Begin
81484>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81491>>>>>>>>>            End
81491>>>>>>>>>>
81491>>>>>>>>>            Else Begin
81492>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81499>>>>>>>>>            End
81499>>>>>>>>>>
81499>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81504>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81509>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81509>>>>>>>>>            If (bSysFile = True) Begin
81511>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81516>>>>>>>>>            End
81516>>>>>>>>>>
81516>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81521>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81526>>>>>>>>>            If (bSysFile = True) Begin
81528>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81533>>>>>>>>>            End
81533>>>>>>>>>>
81533>>>>>>>>>
81533>>>>>>>>>            If (bSysFile = False) Begin
81535>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81536>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81537>>>>>>>>>                If (iSize > 0) Begin
81539>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81542>>>>>>>>>                    Writeln channel iCh // Just an empty line
81544>>>>>>>>>                End
81544>>>>>>>>>>
81544>>>>>>>>>                Decrement iSize
81545>>>>>>>>>                for iCount from 0 to iSize
81551>>>>>>>>>>
81551>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81554>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81557>>>>>>>>>                    Writeln channel iCh
81559>>>>>>>>>                Loop
81560>>>>>>>>>>
81560>>>>>>>>>            End
81560>>>>>>>>>>
81560>>>>>>>>>        Send Seq_Close_Channel iCh
81561>>>>>>>>>
81561>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81561>>>>>>>>>        Sleep 1
81562>>>>>>>>>
81562>>>>>>>>>        Function_Return (bOK = True)
81563>>>>>>>>>    End_Function
81564>>>>>>>>>
81564>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81566>>>>>>>>>        String sDataPath sDriverID
81566>>>>>>>>>        Boolean bOK
81566>>>>>>>>>        Integer iPos
81566>>>>>>>>>
81566>>>>>>>>>        If (sTableName contains ".") Begin
81568>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81569>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81570>>>>>>>>>        End
81570>>>>>>>>>>
81570>>>>>>>>>
81570>>>>>>>>>        Get psDriverID to sDriverID
81571>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81572>>>>>>>>>        // First delete the cache file:
81572>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81573>>>>>>>>>
81573>>>>>>>>>        Function_Return bOK
81574>>>>>>>>>    End_Function
81575>>>>>>>>>
81575>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81575>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81575>>>>>>>>>    // if it is an SQL table
81575>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81577>>>>>>>>>        Boolean bExists bIsSQLTable
81577>>>>>>>>>        String sDataPath sRootName
81577>>>>>>>>>
81577>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81578>>>>>>>>>        If (bExists = False) Begin
81580>>>>>>>>>            Function_Return False
81581>>>>>>>>>        End
81581>>>>>>>>>>
81581>>>>>>>>>
81581>>>>>>>>>        Move False to bIsSQLTable
81582>>>>>>>>>        If (hTable > 0) Begin
81584>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81587>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81588>>>>>>>>>        End
81588>>>>>>>>>>
81588>>>>>>>>>        If (bIsSQLTable = True) Begin
81590>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81591>>>>>>>>>            Function_Return bExists
81592>>>>>>>>>        End
81592>>>>>>>>>>
81592>>>>>>>>>        Else Begin
81593>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81594>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81595>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81596>>>>>>>>>        End
81596>>>>>>>>>>
81596>>>>>>>>>
81596>>>>>>>>>        Function_Return bExists
81597>>>>>>>>>    End_Function
81598>>>>>>>>>
81598>>>>>>>>>    // Pass a table handle
81598>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81598>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81600>>>>>>>>>        Handle hTable
81600>>>>>>>>>        Boolean bFound
81600>>>>>>>>>
81600>>>>>>>>>        Move False to bFound
81601>>>>>>>>>        Move 0 to hTable
81602>>>>>>>>>        Repeat
81602>>>>>>>>>>
81602>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81605>>>>>>>>>            If (hTable > 0) Begin
81607>>>>>>>>>                If (hTable = hCheckTable) Begin
81609>>>>>>>>>                    Move True to bFound
81610>>>>>>>>>                End
81610>>>>>>>>>>
81610>>>>>>>>>            End
81610>>>>>>>>>>
81610>>>>>>>>>            If (bFound = True) ;                Break
81613>>>>>>>>>        Until (hTable = 0)
81615>>>>>>>>>
81615>>>>>>>>>        Function_Return (bFound = True)
81616>>>>>>>>>    End_Function
81617>>>>>>>>>
81617>>>>>>>>>    // DataFlex Embedded Database Data Types:
81617>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81617>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81619>>>>>>>>>        tColumnType[] ColumnType
81619>>>>>>>>>        tColumnType[] ColumnType
81620>>>>>>>>>        Integer i
81620>>>>>>>>>
81620>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81621>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81622>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81623>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81624>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81625>>>>>>>>>        Increment i
81626>>>>>>>>>
81626>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81627>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81628>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81629>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81630>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81631>>>>>>>>>        Increment i
81632>>>>>>>>>
81632>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81633>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81634>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81635>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81636>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81637>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81638>>>>>>>>>        Increment i
81639>>>>>>>>>
81639>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81640>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81641>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81642>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81643>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81644>>>>>>>>>        Increment i
81645>>>>>>>>>
81645>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81646>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81647>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81648>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81649>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81650>>>>>>>>>        Increment i
81651>>>>>>>>>
81651>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81652>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81653>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81654>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81655>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81656>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81657>>>>>>>>>        Increment i
81658>>>>>>>>>
81658>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81659>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81660>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81661>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81662>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81663>>>>>>>>>
81663>>>>>>>>>        Function_Return ColumnType
81664>>>>>>>>>    End_Function
81665>>>>>>>>>
81665>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81667>>>>>>>>>        tColumnType[] aColumnType
81667>>>>>>>>>        tColumnType[] aColumnType
81668>>>>>>>>>        Integer i
81668>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81668>>>>>>>>>>// Generated By The Database Update Framework
81668>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81668>>>>>>>>>>// Driver COLUMN DATA TYPES
81668>>>>>>>>>>//
81668>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
81668>>>>>>>>>>
81668>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81669>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81670>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81671>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81672>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81673>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81674>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81675>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81676>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81677>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81678>>>>>>>>>>            Increment i
81679>>>>>>>>>>
81679>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81680>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81681>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81682>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81683>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81684>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81685>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81686>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81687>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81688>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81689>>>>>>>>>>            Increment i
81690>>>>>>>>>>
81690>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81691>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81692>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81693>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81694>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81695>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81696>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81697>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81698>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81699>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81700>>>>>>>>>>            Increment i
81701>>>>>>>>>>
81701>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81702>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81703>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81704>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81705>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81706>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81707>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81708>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81709>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81710>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81711>>>>>>>>>>            Increment i
81712>>>>>>>>>>
81712>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81713>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81714>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81715>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81716>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81717>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81718>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81719>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81720>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81721>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81722>>>>>>>>>>            Increment i
81723>>>>>>>>>>
81723>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81724>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81725>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81726>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81727>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81728>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81729>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81730>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81731>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81732>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81733>>>>>>>>>>            Increment i
81734>>>>>>>>>>
81734>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81735>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81736>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81737>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81738>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81739>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81740>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
81741>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81742>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81743>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81744>>>>>>>>>>            Increment i
81745>>>>>>>>>>
81745>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
81746>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
81747>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81748>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81749>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
81750>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
81751>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
81752>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81753>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81754>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
81755>>>>>>>>>>            Increment i
81756>>>>>>>>>>
81756>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
81757>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
81758>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81759>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81760>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81761>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81762>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81763>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81764>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81765>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81766>>>>>>>>>>            Increment i
81767>>>>>>>>>>
81767>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
81768>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
81769>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81770>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81771>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81772>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81773>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81774>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
81775>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
81776>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81777>>>>>>>>>>            Increment i
81778>>>>>>>>>>
81778>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
81779>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
81780>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81781>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81782>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81783>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81784>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81785>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81786>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81787>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81788>>>>>>>>>>            Increment i
81789>>>>>>>>>>
81789>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
81790>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
81791>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81792>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81793>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81794>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81795>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
81796>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81797>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81798>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
81799>>>>>>>>>>            Increment i
81800>>>>>>>>>>
81800>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
81801>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
81802>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81803>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81804>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81805>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81806>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81807>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81808>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81809>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81810>>>>>>>>>>            Increment i
81811>>>>>>>>>>
81811>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
81812>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
81813>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81814>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81815>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81816>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81817>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81818>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81819>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81820>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81821>>>>>>>>>>            Increment i
81822>>>>>>>>>>
81822>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
81823>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
81824>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81825>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81826>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81827>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81828>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81829>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81830>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81831>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81832>>>>>>>>>>            Increment i
81833>>>>>>>>>>
81833>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
81834>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
81835>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81836>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81837>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81838>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81839>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81840>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
81841>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
81842>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
81843>>>>>>>>>>            Increment i
81844>>>>>>>>>>
81844>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
81845>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
81846>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81847>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81848>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81849>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81850>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
81851>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81852>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81853>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
81854>>>>>>>>>>            Increment i
81855>>>>>>>>>>
81855>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
81856>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
81857>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81858>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81859>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81860>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81861>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81862>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81863>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81864>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81865>>>>>>>>>>            Increment i
81866>>>>>>>>>>
81866>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
81867>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
81868>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81869>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81870>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81871>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81872>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81873>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81874>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81875>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81876>>>>>>>>>>            Increment i
81877>>>>>>>>>>
81877>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
81878>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
81879>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81880>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81881>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81882>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81883>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81884>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81885>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81886>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81887>>>>>>>>>>            Increment i
81888>>>>>>>>>>
81888>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
81889>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
81890>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81891>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81892>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
81893>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81894>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
81895>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81896>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81897>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
81898>>>>>>>>>>            Increment i
81899>>>>>>>>>>
81899>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
81900>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
81901>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81902>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81903>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81904>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81905>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81906>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81907>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81908>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81909>>>>>>>>>>            Increment i
81910>>>>>>>>>>
81910>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
81911>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
81912>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81913>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81914>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81915>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81916>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81917>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81918>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81919>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81920>>>>>>>>>>            Increment i
81921>>>>>>>>>>
81921>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
81922>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
81923>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81924>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81925>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
81926>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
81927>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
81928>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81929>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81930>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
81931>>>>>>>>>>            Increment i
81932>>>>>>>>>>
81932>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
81933>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
81934>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81935>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81936>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
81937>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81938>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
81939>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81940>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81941>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
81942>>>>>>>>>>            Increment i
81943>>>>>>>>>>
81943>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
81944>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
81945>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81946>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81947>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81948>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81949>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81950>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81951>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81952>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81953>>>>>>>>>>            Increment i
81954>>>>>>>>>>
81954>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
81955>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
81956>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81957>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81958>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
81959>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81960>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81961>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81962>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81963>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81964>>>>>>>>>>            Increment i
81965>>>>>>>>>>
81965>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
81966>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
81967>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81968>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81969>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81970>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81971>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81972>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81973>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81974>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81975>>>>>>>>>>            Increment i
81976>>>>>>>>>>
81976>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
81977>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
81978>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81979>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81980>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81981>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81982>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81983>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81984>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81985>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81986>>>>>>>>>>            Increment i
81987>>>>>>>>>>
81987>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
81988>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
81989>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81990>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81991>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
81992>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81993>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
81994>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81995>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81996>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
81997>>>>>>>>>>            Increment i
81998>>>>>>>>>>
81998>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
81999>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82000>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82001>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82002>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82003>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82004>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82005>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82006>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82007>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82008>>>>>>>>>>            Increment i
82009>>>>>>>>>>
82009>>>>>>>>>>
82009>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82009>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82009>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82009>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82009>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82009>>>>>>>>>//        Increment i
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>//
82009>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82009>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82009>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82009>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82009>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82009>>>>>>>>>
82009>>>>>>>>>        Function_Return aColumnType
82010>>>>>>>>>    End_Function
82011>>>>>>>>>
82011>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82011>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82011>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82013>>>>>>>>>        tColumnType[] aColumnType
82013>>>>>>>>>        tColumnType[] aColumnType
82014>>>>>>>>>        Integer i
82014>>>>>>>>>
82014>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82016>>>>>>>>>>// Generated By The Database Update Framework
82016>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82016>>>>>>>>>>// Driver COLUMN DATA TYPES
82016>>>>>>>>>>//
82016>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82016>>>>>>>>>>
82016>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82017>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82018>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82019>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82020>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82021>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82022>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82023>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82024>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82025>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82026>>>>>>>>>>            Increment i
82027>>>>>>>>>>
82027>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82028>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82029>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82030>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82031>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82032>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82033>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82034>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82035>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82036>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82037>>>>>>>>>>            Increment i
82038>>>>>>>>>>
82038>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82039>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82040>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82041>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82042>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82043>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82044>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82045>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82046>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82047>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82048>>>>>>>>>>            Increment i
82049>>>>>>>>>>
82049>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82050>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82051>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82052>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82053>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82054>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82055>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82056>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82057>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82058>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82059>>>>>>>>>>            Increment i
82060>>>>>>>>>>
82060>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82061>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82062>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82063>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82064>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82065>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82066>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82067>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82068>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82069>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82070>>>>>>>>>>            Increment i
82071>>>>>>>>>>
82071>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82072>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82073>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82074>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82075>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82076>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82077>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82078>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82079>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82080>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82081>>>>>>>>>>            Increment i
82082>>>>>>>>>>
82082>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82083>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82084>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82085>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82086>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82087>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82088>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82089>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82090>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82091>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82092>>>>>>>>>>            Increment i
82093>>>>>>>>>>
82093>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82094>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82095>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82096>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82097>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82098>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82099>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82100>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82101>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82102>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82103>>>>>>>>>>            Increment i
82104>>>>>>>>>>
82104>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82105>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82106>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82107>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82108>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82109>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82110>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82111>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82112>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82113>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82114>>>>>>>>>>            Increment i
82115>>>>>>>>>>
82115>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82116>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82117>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82118>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82119>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82120>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82121>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82122>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82123>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82124>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82125>>>>>>>>>>            Increment i
82126>>>>>>>>>>
82126>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82127>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82128>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82129>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82130>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82131>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82132>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82133>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82134>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82135>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82136>>>>>>>>>>            Increment i
82137>>>>>>>>>>
82137>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82138>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82139>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82140>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82141>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82142>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82143>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82144>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82145>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82146>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82147>>>>>>>>>>            Increment i
82148>>>>>>>>>>
82148>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82149>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82150>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82151>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82152>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82153>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82154>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82155>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82156>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82157>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82158>>>>>>>>>>            Increment i
82159>>>>>>>>>>
82159>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82160>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82161>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82162>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82163>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82164>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82165>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82166>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82167>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82168>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82169>>>>>>>>>>            Increment i
82170>>>>>>>>>>
82170>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82171>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82172>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82173>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82174>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82175>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82176>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82177>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82178>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82179>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82180>>>>>>>>>>            Increment i
82181>>>>>>>>>>
82181>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82182>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82183>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82184>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82185>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82186>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82187>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82188>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82189>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82190>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82191>>>>>>>>>>            Increment i
82192>>>>>>>>>>
82192>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82193>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82194>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82195>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82196>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82197>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82198>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82199>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82200>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82201>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82202>>>>>>>>>>            Increment i
82203>>>>>>>>>>
82203>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82204>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82205>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82206>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82207>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82208>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82209>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82210>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82211>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82212>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82213>>>>>>>>>>            Increment i
82214>>>>>>>>>>
82214>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82215>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82216>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82217>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82218>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82219>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82220>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82221>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82222>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82223>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82224>>>>>>>>>>            Increment i
82225>>>>>>>>>>
82225>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82226>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82227>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82228>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82229>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82230>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82231>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82232>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82233>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82234>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82235>>>>>>>>>>            Increment i
82236>>>>>>>>>>
82236>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82237>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82238>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82239>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82240>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82241>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82242>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82243>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82244>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82245>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82246>>>>>>>>>>            Increment i
82247>>>>>>>>>>
82247>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82248>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82249>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82250>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82251>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82252>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82253>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82254>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82255>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82256>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82257>>>>>>>>>>            Increment i
82258>>>>>>>>>>
82258>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82259>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82260>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82261>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82262>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82263>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82264>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82265>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82266>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82267>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82268>>>>>>>>>>            Increment i
82269>>>>>>>>>>
82269>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82270>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82271>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82272>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82273>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82274>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82275>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82276>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82277>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82278>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82279>>>>>>>>>>            Increment i
82280>>>>>>>>>>
82280>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82281>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82282>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82283>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82284>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82285>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82286>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82287>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82288>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82289>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82290>>>>>>>>>>            Increment i
82291>>>>>>>>>>
82291>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82292>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82293>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82294>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82295>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82296>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82297>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82298>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82299>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82300>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82301>>>>>>>>>>            Increment i
82302>>>>>>>>>>
82302>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82303>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82304>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82305>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82306>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82307>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82308>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82309>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82310>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82311>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82312>>>>>>>>>>            Increment i
82313>>>>>>>>>>
82313>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82314>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82315>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82316>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82317>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82318>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82319>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82320>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82321>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82322>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82323>>>>>>>>>>            Increment i
82324>>>>>>>>>>
82324>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82325>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82326>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82327>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82328>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82329>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82330>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82331>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82332>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82333>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82334>>>>>>>>>>            Increment i
82335>>>>>>>>>>
82335>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82336>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82337>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82338>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82339>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82340>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82341>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82342>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82343>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82344>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82345>>>>>>>>>>            Increment i
82346>>>>>>>>>>
82346>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82347>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82348>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82349>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82350>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82351>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82352>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82353>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82354>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82355>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82356>>>>>>>>>>            Increment i
82357>>>>>>>>>>
82357>>>>>>>>>>
82357>>>>>>>>>
82357>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>//
82357>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82357>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82357>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82357>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82357>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82357>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82357>>>>>>>>>//            Increment i
82357>>>>>>>>>
82357>>>>>>>>>        End
82357>>>>>>>>>>
82357>>>>>>>>>
82357>>>>>>>>>        Function_Return aColumnType
82358>>>>>>>>>    End_Function
82359>>>>>>>>>
82359>>>>>>>>>    // MySQL Data Types
82359>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82361>>>>>>>>>        tColumnType[] aColumnType
82361>>>>>>>>>        tColumnType[] aColumnType
82362>>>>>>>>>        Integer i
82362>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82362>>>>>>>>>>// Generated By The Database Update Framework
82362>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82362>>>>>>>>>>// Driver COLUMN DATA TYPES
82362>>>>>>>>>>//
82362>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82362>>>>>>>>>>
82362>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82363>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82364>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82365>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82366>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82367>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82368>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82369>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82370>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82371>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82372>>>>>>>>>>            Increment i
82373>>>>>>>>>>
82373>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82374>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82375>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82376>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82377>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82378>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82379>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82380>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82381>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82382>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82383>>>>>>>>>>            Increment i
82384>>>>>>>>>>
82384>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82385>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82386>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82387>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82388>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82389>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82390>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82391>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82392>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82393>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82394>>>>>>>>>>            Increment i
82395>>>>>>>>>>
82395>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82396>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82397>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82398>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82399>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82400>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82401>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82402>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82403>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82404>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82405>>>>>>>>>>            Increment i
82406>>>>>>>>>>
82406>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82407>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82408>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82409>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82410>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82411>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82412>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82413>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82414>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82415>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82416>>>>>>>>>>            Increment i
82417>>>>>>>>>>
82417>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82418>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82419>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82420>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82421>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82422>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82423>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82424>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82425>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82426>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82427>>>>>>>>>>            Increment i
82428>>>>>>>>>>
82428>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82429>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82430>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82431>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82432>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82433>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82434>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82435>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82436>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82437>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82438>>>>>>>>>>            Increment i
82439>>>>>>>>>>
82439>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82440>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82441>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82442>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82443>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82444>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82445>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82446>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82447>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82448>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82449>>>>>>>>>>            Increment i
82450>>>>>>>>>>
82450>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82451>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82452>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82453>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82454>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82455>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82456>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82457>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82458>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82459>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82460>>>>>>>>>>            Increment i
82461>>>>>>>>>>
82461>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82462>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82463>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82464>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82465>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82466>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82467>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82468>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82469>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82470>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82471>>>>>>>>>>            Increment i
82472>>>>>>>>>>
82472>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82473>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82474>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82475>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82476>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82477>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82478>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82479>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82480>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82481>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82482>>>>>>>>>>            Increment i
82483>>>>>>>>>>
82483>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82484>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82485>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82486>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82487>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82488>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82489>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82490>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82491>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82492>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82493>>>>>>>>>>            Increment i
82494>>>>>>>>>>
82494>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82495>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82496>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82497>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82498>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82499>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82500>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82501>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82502>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82503>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82504>>>>>>>>>>            Increment i
82505>>>>>>>>>>
82505>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82506>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82507>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82508>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82509>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82510>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82511>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82512>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82513>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82514>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82515>>>>>>>>>>            Increment i
82516>>>>>>>>>>
82516>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82517>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82518>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82519>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82520>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82521>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82522>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82523>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82524>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82525>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82526>>>>>>>>>>            Increment i
82527>>>>>>>>>>
82527>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82528>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82529>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82531>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82532>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82533>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82534>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82535>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82536>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82537>>>>>>>>>>            Increment i
82538>>>>>>>>>>
82538>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82539>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82540>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82542>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82543>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82544>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82545>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82546>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82547>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82548>>>>>>>>>>            Increment i
82549>>>>>>>>>>
82549>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82550>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82551>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82552>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82553>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82554>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82555>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82556>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82557>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82558>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82559>>>>>>>>>>            Increment i
82560>>>>>>>>>>
82560>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82561>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82562>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82563>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82564>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82565>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82566>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82567>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82568>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82569>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82570>>>>>>>>>>            Increment i
82571>>>>>>>>>>
82571>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82572>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82573>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82574>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82575>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82576>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82577>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82578>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82579>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82580>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82581>>>>>>>>>>            Increment i
82582>>>>>>>>>>
82582>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82583>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82584>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82585>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82586>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82587>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82588>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82589>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82590>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82591>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82592>>>>>>>>>>            Increment i
82593>>>>>>>>>>
82593>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82594>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82595>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82596>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82597>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82598>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82599>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82600>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82601>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82602>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82603>>>>>>>>>>            Increment i
82604>>>>>>>>>>
82604>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82605>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82606>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82608>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82609>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82610>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82611>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82612>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82613>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82614>>>>>>>>>>            Increment i
82615>>>>>>>>>>
82615>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82616>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82617>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82618>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82619>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82620>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82621>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82622>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82623>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82624>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82625>>>>>>>>>>            Increment i
82626>>>>>>>>>>
82626>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82627>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82628>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82629>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82630>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82631>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82632>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82633>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82634>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82635>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82636>>>>>>>>>>            Increment i
82637>>>>>>>>>>
82637>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82638>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82639>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82640>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82641>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82642>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82643>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82644>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82645>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82646>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82647>>>>>>>>>>            Increment i
82648>>>>>>>>>>
82648>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82649>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82650>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82651>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82652>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82653>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82654>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82655>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82656>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82657>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82658>>>>>>>>>>            Increment i
82659>>>>>>>>>>
82659>>>>>>>>>>
82659>>>>>>>>>
82659>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>//
82659>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82659>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82659>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82659>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82659>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82659>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82659>>>>>>>>>//        Increment i
82659>>>>>>>>>
82659>>>>>>>>>        Function_Return aColumnType
82660>>>>>>>>>    End_Function
82661>>>>>>>>>
82661>>>>>>>>>    // Oracle Data Types
82661>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82663>>>>>>>>>        tColumnType[] aColumnType
82663>>>>>>>>>        tColumnType[] aColumnType
82664>>>>>>>>>        Integer i
82664>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82664>>>>>>>>>>// Generated By The Database Update Framework
82664>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82664>>>>>>>>>>// Driver COLUMN DATA TYPES
82664>>>>>>>>>>//
82664>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82664>>>>>>>>>>
82664>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82665>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82666>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82667>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82668>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82669>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82670>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82671>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82672>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82673>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82674>>>>>>>>>>            Increment i
82675>>>>>>>>>>
82675>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82676>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82677>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82678>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82679>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82680>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82681>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82682>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82683>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82684>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82685>>>>>>>>>>            Increment i
82686>>>>>>>>>>
82686>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82687>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82688>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82689>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82690>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82691>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82692>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82693>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82694>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82695>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82696>>>>>>>>>>            Increment i
82697>>>>>>>>>>
82697>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82698>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82699>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82700>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82701>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82702>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82703>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82704>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82705>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82706>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82707>>>>>>>>>>            Increment i
82708>>>>>>>>>>
82708>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82709>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82710>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82711>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82712>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82713>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82714>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82715>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82716>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82717>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82718>>>>>>>>>>            Increment i
82719>>>>>>>>>>
82719>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82720>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82721>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82722>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82723>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82724>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82725>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82726>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82727>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82728>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82729>>>>>>>>>>            Increment i
82730>>>>>>>>>>
82730>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82731>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82732>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82734>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82735>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82736>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82737>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82738>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82739>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82740>>>>>>>>>>            Increment i
82741>>>>>>>>>>
82741>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
82742>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
82743>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82744>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82745>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82746>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82747>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82748>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82749>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82750>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82751>>>>>>>>>>            Increment i
82752>>>>>>>>>>
82752>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
82753>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82754>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82755>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82756>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82757>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82758>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82759>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82760>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82761>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82762>>>>>>>>>>            Increment i
82763>>>>>>>>>>
82763>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
82764>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
82765>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82766>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82767>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82768>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82769>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82770>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82771>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82772>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82773>>>>>>>>>>            Increment i
82774>>>>>>>>>>
82774>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82775>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
82776>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82777>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82778>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82779>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82780>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82781>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82782>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82783>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82784>>>>>>>>>>            Increment i
82785>>>>>>>>>>
82785>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
82786>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
82787>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82788>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82789>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82790>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82791>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82792>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82793>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82794>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82795>>>>>>>>>>            Increment i
82796>>>>>>>>>>
82796>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
82797>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82798>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82799>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82800>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82801>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82802>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82803>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82804>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82805>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82806>>>>>>>>>>            Increment i
82807>>>>>>>>>>
82807>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
82808>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
82809>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82810>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82811>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82812>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82813>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82814>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82815>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82816>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82817>>>>>>>>>>            Increment i
82818>>>>>>>>>>
82818>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
82819>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82820>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82821>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82822>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82823>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82824>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82825>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82826>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82827>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82828>>>>>>>>>>            Increment i
82829>>>>>>>>>>
82829>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82830>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
82831>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82833>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82834>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82835>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82836>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82837>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82838>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82839>>>>>>>>>>            Increment i
82840>>>>>>>>>>
82840>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
82841>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
82842>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82843>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82844>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82845>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82846>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82847>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82848>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82849>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82850>>>>>>>>>>            Increment i
82851>>>>>>>>>>
82851>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
82852>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
82853>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82854>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82855>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82856>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82857>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82858>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82859>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82860>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82861>>>>>>>>>>            Increment i
82862>>>>>>>>>>
82862>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
82863>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82864>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82866>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82867>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82868>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82869>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82870>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82871>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82872>>>>>>>>>>            Increment i
82873>>>>>>>>>>
82873>>>>>>>>>>
82873>>>>>>>>>
82873>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
82873>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
82873>>>>>>>>>//        Increment i
82873>>>>>>>>>//
82873>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
82873>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82873>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82873>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82873>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82873>>>>>>>>>
82873>>>>>>>>>        Function_Return aColumnType
82874>>>>>>>>>    End_Function
82875>>>>>>>>>
82875>>>>>>>>>    // PostgreSQL Data Types
82875>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
82877>>>>>>>>>        tColumnType[] aColumnType
82877>>>>>>>>>        tColumnType[] aColumnType
82878>>>>>>>>>        Integer i
82878>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
82878>>>>>>>>>>// Generated By The Database Update Framework
82878>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
82878>>>>>>>>>>// Driver COLUMN DATA TYPES
82878>>>>>>>>>>//
82878>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
82878>>>>>>>>>>
82878>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82879>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
82880>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82881>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82882>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82883>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82884>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82885>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82886>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82887>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82888>>>>>>>>>>            Increment i
82889>>>>>>>>>>
82889>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82890>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
82891>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82892>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82893>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82894>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82895>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82896>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82897>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82898>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82899>>>>>>>>>>            Increment i
82900>>>>>>>>>>
82900>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
82901>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82902>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82903>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82904>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82905>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82906>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82907>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82908>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82909>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82910>>>>>>>>>>            Increment i
82911>>>>>>>>>>
82911>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
82912>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
82913>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82914>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82915>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82916>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82917>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82918>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82919>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82920>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82921>>>>>>>>>>            Increment i
82922>>>>>>>>>>
82922>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82923>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
82924>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82925>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82926>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82927>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82928>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82929>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82930>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82931>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82932>>>>>>>>>>            Increment i
82933>>>>>>>>>>
82933>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
82934>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
82935>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82936>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82937>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82938>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82939>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82940>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82941>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82942>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82943>>>>>>>>>>            Increment i
82944>>>>>>>>>>
82944>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82945>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
82946>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82947>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82948>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82949>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82950>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82951>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82952>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82953>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82954>>>>>>>>>>            Increment i
82955>>>>>>>>>>
82955>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82956>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
82957>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82958>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82959>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82960>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82961>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82962>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82963>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82964>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82965>>>>>>>>>>            Increment i
82966>>>>>>>>>>
82966>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82967>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
82968>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82969>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82970>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
82971>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82972>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82973>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82974>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82975>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82976>>>>>>>>>>            Increment i
82977>>>>>>>>>>
82977>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82978>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
82979>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82980>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82981>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
82982>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82983>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
82984>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82985>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82986>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
82987>>>>>>>>>>            Increment i
82988>>>>>>>>>>
82988>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82989>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
82990>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82991>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82992>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82993>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82994>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82995>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82996>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82997>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82998>>>>>>>>>>            Increment i
82999>>>>>>>>>>
82999>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83000>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83001>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83002>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83003>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83004>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83005>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83006>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83007>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83008>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83009>>>>>>>>>>            Increment i
83010>>>>>>>>>>
83010>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83011>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83012>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83013>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83014>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83015>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83016>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83017>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83018>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83019>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83020>>>>>>>>>>            Increment i
83021>>>>>>>>>>
83021>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83022>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83023>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83024>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83025>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83026>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83027>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83028>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83029>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83030>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83031>>>>>>>>>>            Increment i
83032>>>>>>>>>>
83032>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83033>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83034>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83036>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83037>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83038>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83039>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83040>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83041>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83042>>>>>>>>>>            Increment i
83043>>>>>>>>>>
83043>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83044>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83045>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83047>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83048>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83049>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83050>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83051>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83052>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83053>>>>>>>>>>            Increment i
83054>>>>>>>>>>
83054>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83055>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83056>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83058>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83059>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83060>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83061>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83062>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83063>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83064>>>>>>>>>>            Increment i
83065>>>>>>>>>>
83065>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83066>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83067>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83068>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83069>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83070>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83071>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83072>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83073>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83074>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83075>>>>>>>>>>            Increment i
83076>>>>>>>>>>
83076>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83077>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83078>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83079>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83080>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83081>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83082>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83083>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83084>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83085>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83086>>>>>>>>>>            Increment i
83087>>>>>>>>>>
83087>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83088>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83089>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83090>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83091>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83092>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83093>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83094>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83095>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83096>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83097>>>>>>>>>>            Increment i
83098>>>>>>>>>>
83098>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83099>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83100>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83101>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83102>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83103>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83104>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83105>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83106>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83107>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83108>>>>>>>>>>            Increment i
83109>>>>>>>>>>
83109>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83110>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83111>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83112>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83113>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83114>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83115>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83116>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83117>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83118>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83119>>>>>>>>>>            Increment i
83120>>>>>>>>>>
83120>>>>>>>>>>
83120>>>>>>>>>
83120>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83120>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83120>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83120>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>//
83120>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83120>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83120>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83120>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83120>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83120>>>>>>>>>//        Increment i
83120>>>>>>>>>
83120>>>>>>>>>        Function_Return aColumnType
83121>>>>>>>>>    End_Function
83122>>>>>>>>>
83122>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83122>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83124>>>>>>>>>        Integer iValue iSize iCount iStart
83124>>>>>>>>>        tColumnType[] ColumnTypeArray
83124>>>>>>>>>        tColumnType[] ColumnTypeArray
83125>>>>>>>>>        tColumnType RetvalType
83125>>>>>>>>>        tColumnType RetvalType
83125>>>>>>>>>        String sValue
83125>>>>>>>>>        Boolean bFrameworkDataFlexType
83125>>>>>>>>>
83125>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83126>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83127>>>>>>>>>
83127>>>>>>>>>        Move 0 to iStart
83128>>>>>>>>>        Move (Uppercase(sType)) to sType
83129>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83130>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83132>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83133>>>>>>>>>            Function_Return RetvalType
83134>>>>>>>>>        End
83134>>>>>>>>>>
83134>>>>>>>>>
83134>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83135>>>>>>>>>
83135>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83136>>>>>>>>>        Decrement iSize
83137>>>>>>>>>
83137>>>>>>>>>        For iCount from iStart to iSize
83143>>>>>>>>>>
83143>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
83144>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
83145>>>>>>>>>            If (bIntegerInputType = True) Begin
83147>>>>>>>>>                If (iValue = iType) Begin
83149>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83150>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83151>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83152>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83153>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83154>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83155>>>>>>>>>                    Move iSize to iCount // We're done!
83156>>>>>>>>>                End
83156>>>>>>>>>>
83156>>>>>>>>>            End
83156>>>>>>>>>>
83156>>>>>>>>>            Else Begin
83157>>>>>>>>>                Move (Uppercase(sValue)) to sValue
83158>>>>>>>>>                If (sValue = sType) Begin
83160>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
83161>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
83162>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83163>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83164>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83165>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83166>>>>>>>>>                    Move iSize to iCount // We're done!
83167>>>>>>>>>                End
83167>>>>>>>>>>
83167>>>>>>>>>            End
83167>>>>>>>>>>
83167>>>>>>>>>        Loop
83168>>>>>>>>>>
83168>>>>>>>>>
83168>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
83168>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
83168>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
83170>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83171>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
83172>>>>>>>>>            Decrement iSize
83173>>>>>>>>>
83173>>>>>>>>>            For iCount from iStart to iSize
83179>>>>>>>>>>
83179>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
83180>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
83181>>>>>>>>>                If (iValue = iType) Begin
83183>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83184>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83185>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83186>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83187>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83188>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83189>>>>>>>>>                    Move iSize to iCount // We're done!
83190>>>>>>>>>                End
83190>>>>>>>>>>
83190>>>>>>>>>            Loop
83191>>>>>>>>>>
83191>>>>>>>>>        End
83191>>>>>>>>>>
83191>>>>>>>>>
83191>>>>>>>>>        Function_Return RetvalType
83192>>>>>>>>>    End_Function
83193>>>>>>>>>
83193>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83193>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83195>>>>>>>>>        tColumnType[] ColumnType
83195>>>>>>>>>        tColumnType[] ColumnType
83196>>>>>>>>>
83196>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83196>>>>>>>>>        // the dbType.
83196>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83198>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83200>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83201>>>>>>>>>            End
83201>>>>>>>>>>
83201>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83203>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83204>>>>>>>>>            End
83204>>>>>>>>>>
83204>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83206>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83207>>>>>>>>>            End
83207>>>>>>>>>>
83207>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83209>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83210>>>>>>>>>            End
83210>>>>>>>>>>
83210>>>>>>>>>        End
83210>>>>>>>>>>
83210>>>>>>>>>
83210>>>>>>>>>        Case Begin
83210>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83212>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83213>>>>>>>>>                Case Break
83214>>>>>>>>>
83214>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83217>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83218>>>>>>>>>                Case Break
83219>>>>>>>>>
83219>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83222>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83223>>>>>>>>>                Case Break
83224>>>>>>>>>        Case End
83224>>>>>>>>>
83224>>>>>>>>>        Function_Return ColumnType
83225>>>>>>>>>    End_Function
83226>>>>>>>>>
83226>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83226>>>>>>>>>    // are mapped to a DUF data type.
83226>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83228>>>>>>>>>        tColumnType ColumnType
83228>>>>>>>>>        tColumnType ColumnType
83228>>>>>>>>>        String sDataType
83228>>>>>>>>>        Integer iDriverID iCount
83228>>>>>>>>>
83228>>>>>>>>>        Move 0 to iCount
83229>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83230>>>>>>>>>
83230>>>>>>>>>        Case Begin
83230>>>>>>>>>            // DF_ASCII
83230>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83232>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83234>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83237>>>>>>>>>                End
83237>>>>>>>>>>
83237>>>>>>>>>                Else Begin
83238>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83241>>>>>>>>>                End
83241>>>>>>>>>>
83241>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83242>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83243>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83244>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83245>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83246>>>>>>>>>                Case Break
83247>>>>>>>>>
83247>>>>>>>>>            // DF_BINARY
83247>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83250>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83252>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83255>>>>>>>>>                End
83255>>>>>>>>>>
83255>>>>>>>>>                Else Begin
83256>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83259>>>>>>>>>                End
83259>>>>>>>>>>
83259>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83260>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83261>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83262>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83263>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83264>>>>>>>>>                Case Break
83265>>>>>>>>>
83265>>>>>>>>>            // DF_DATE
83265>>>>>>>>>            Case (iType = DF_DATE_DUF)
83268>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83270>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83273>>>>>>>>>                End
83273>>>>>>>>>>
83273>>>>>>>>>                Else Begin
83274>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83277>>>>>>>>>                End
83277>>>>>>>>>>
83277>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83278>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83279>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83280>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83281>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83282>>>>>>>>>                Case Break
83283>>>>>>>>>
83283>>>>>>>>>            // DF_DATETIME
83283>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83286>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83288>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83291>>>>>>>>>                End
83291>>>>>>>>>>
83291>>>>>>>>>                Else Begin
83292>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83295>>>>>>>>>                End
83295>>>>>>>>>>
83295>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83296>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83297>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83298>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83299>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83300>>>>>>>>>                Case Break
83301>>>>>>>>>
83301>>>>>>>>>            // DF_NUMERIC
83301>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83301>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83301>>>>>>>>>            // we make them here all "Numeric"...
83301>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83301>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83301>>>>>>>>>            // End
83301>>>>>>>>>            // Else Begin
83301>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83301>>>>>>>>>            // End
83301>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83301>>>>>>>>>            Case (iType = DF_BCD_DUF)
83304>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83305>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83306>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83307>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83308>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83309>>>>>>>>>                Case Break
83310>>>>>>>>>
83310>>>>>>>>>            // DF_TEXT
83310>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83313>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83315>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83318>>>>>>>>>                End
83318>>>>>>>>>>
83318>>>>>>>>>                Else Begin
83319>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83322>>>>>>>>>                End
83322>>>>>>>>>>
83322>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83323>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83324>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83325>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83326>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83327>>>>>>>>>                Case Break
83328>>>>>>>>>
83328>>>>>>>>>            Case Else
83328>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83329>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83330>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83331>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83332>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83333>>>>>>>>>
83333>>>>>>>>>        Case End
83333>>>>>>>>>
83333>>>>>>>>>        Function_Return ColumnType
83334>>>>>>>>>    End_Function
83335>>>>>>>>>
83335>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83337>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83339>>>>>>>>>        Handle hTable
83339>>>>>>>>>        Integer iIndex
83339>>>>>>>>>        String sTableName
83339>>>>>>>>>        Boolean bFlexErrs
83339>>>>>>>>>
83339>>>>>>>>>        // a) Get the exception table array the developer has specified
83339>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83340>>>>>>>>>
83340>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83340>>>>>>>>>        Repeat
83340>>>>>>>>>>
83340>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83343>>>>>>>>>            If (hTable <> 0) Begin
83345>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83348>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83349>>>>>>>>>                If (bFlexErrs = False) Begin
83351>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83353>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83354>>>>>>>>>                        If (iIndex = -1) Begin
83356>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83357>>>>>>>>>                        End
83357>>>>>>>>>>
83357>>>>>>>>>                    End
83357>>>>>>>>>>
83357>>>>>>>>>                End
83357>>>>>>>>>>
83357>>>>>>>>>            End
83357>>>>>>>>>>
83357>>>>>>>>>        Until (hTable = 0)
83359>>>>>>>>>
83359>>>>>>>>>        Move 0 to hTable
83360>>>>>>>>>
83360>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83360>>>>>>>>>        Repeat
83360>>>>>>>>>>
83360>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83363>>>>>>>>>            If (hTable > 0) Begin
83365>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83368>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83369>>>>>>>>>                If (bFlexErrs = False) Begin
83371>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83372>>>>>>>>>                    If (iIndex = -1) Begin
83374>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83375>>>>>>>>>                    End
83375>>>>>>>>>>
83375>>>>>>>>>                End
83375>>>>>>>>>>
83375>>>>>>>>>            End
83375>>>>>>>>>>
83375>>>>>>>>>        Until (hTable = 0)
83377>>>>>>>>>
83377>>>>>>>>>        Function_Return iTablesArray
83378>>>>>>>>>    End_Function
83379>>>>>>>>>
83379>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83381>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83383>>>>>>>>>        Handle hTable
83383>>>>>>>>>        Integer iIndex
83383>>>>>>>>>        String sTableName
83383>>>>>>>>>        Boolean bFlexErrs
83383>>>>>>>>>
83383>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83384>>>>>>>>>        Move 0 to hTable
83385>>>>>>>>>
83385>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83385>>>>>>>>>        Repeat
83385>>>>>>>>>>
83385>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83388>>>>>>>>>            If (hTable > 0) Begin
83390>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83393>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83394>>>>>>>>>                If (bFlexErrs = False) Begin
83396>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83397>>>>>>>>>                    If (iIndex = -1) Begin
83399>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83400>>>>>>>>>                    End
83400>>>>>>>>>>
83400>>>>>>>>>                End
83400>>>>>>>>>>
83400>>>>>>>>>            End
83400>>>>>>>>>>
83400>>>>>>>>>        Until (hTable = 0)
83402>>>>>>>>>
83402>>>>>>>>>        Function_Return iTablesArray
83403>>>>>>>>>    End_Function
83404>>>>>>>>>
83404>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83406>>>>>>>>>        tAPIColumn NewAPIColumn
83406>>>>>>>>>        tAPIColumn NewAPIColumn
83406>>>>>>>>>
83406>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83407>>>>>>>>>        Move iType      to NewAPIColumn.iType
83408>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83409>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83410>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83411>>>>>>>>>
83411>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83412>>>>>>>>>
83412>>>>>>>>>        Function_Return aCurrent
83413>>>>>>>>>    End_Function
83414>>>>>>>>>
83414>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83416>>>>>>>>>        String sRetval sFieldName
83416>>>>>>>>>        Integer iCount iSize
83416>>>>>>>>>
83416>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83417>>>>>>>>>        Decrement iSize
83418>>>>>>>>>        For iCount from 0 to iSize
83424>>>>>>>>>>
83424>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83425>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83426>>>>>>>>>        Loop
83427>>>>>>>>>>
83427>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83428>>>>>>>>>
83428>>>>>>>>>        Function_Return sRetval
83429>>>>>>>>>    End_Function
83430>>>>>>>>>
83430>>>>>>>>>    // *** Miscellaneous other functions ***
83430>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83430>>>>>>>>>    //
83430>>>>>>>>>
83430>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83430>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83432>>>>>>>>>        Integer iPerc
83432>>>>>>>>>        Number nReady nTotal
83432>>>>>>>>>
83432>>>>>>>>>        Send DoAdvance of ghoProgressBar
83433>>>>>>>>>
83433>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83435>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83436>>>>>>>>>        End
83436>>>>>>>>>>
83436>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83438>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83439>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83440>>>>>>>>>        End
83440>>>>>>>>>>
83440>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83442>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83443>>>>>>>>>        End
83443>>>>>>>>>>
83443>>>>>>>>>
83443>>>>>>>>>        Case Begin
83443>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83445>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83446>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83447>>>>>>>>>                Case Break
83448>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83451>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83452>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83453>>>>>>>>>                Case Break
83454>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83457>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83458>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83459>>>>>>>>>                Case Break
83460>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83463>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83464>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83465>>>>>>>>>                Case Break
83466>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83469>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83470>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83471>>>>>>>>>                Case Break
83472>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83475>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83476>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83477>>>>>>>>>                Case Break
83478>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83481>>>>>>>>>                Send None
83482>>>>>>>>>                Case Break
83483>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83486>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83487>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83488>>>>>>>>>                Case Break
83489>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83492>>>>>>>>>                //*** Interpret numbers
83492>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83493>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83494>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83495>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83496>>>>>>>>>                Case Break
83497>>>>>>>>>            Case Else
83497>>>>>>>>>                Set Message_Text to ""
83498>>>>>>>>>                Set Action_Text  to ""
83499>>>>>>>>>        Case End
83499>>>>>>>>>
83499>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83500>>>>>>>>>        Function_Return False
83501>>>>>>>>>    End_Function
83502>>>>>>>>>
83502>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83502>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83504>>>>>>>>>        Function_Return False
83505>>>>>>>>>    End_Function
83506>>>>>>>>>
83506>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83506>>>>>>>>>    //
83506>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83506>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83506>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83506>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83506>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83506>>>>>>>>>    //   ALTER TABLE MyTable
83506>>>>>>>>>    //       REBUILD
83506>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83508>>>>>>>>>        Boolean bOK
83508>>>>>>>>>
83508>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83510>>>>>>>>>            Function_Return False
83511>>>>>>>>>        End
83511>>>>>>>>>>
83511>>>>>>>>>
83511>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83511>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83512>>>>>>>>>
83512>>>>>>>>>        Function_Return (bOK = True)
83513>>>>>>>>>    End_Function
83514>>>>>>>>>
83514>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83514>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83514>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83514>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83514>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83514>>>>>>>>>    //   ALTER TABLE MyTable
83514>>>>>>>>>    //       REBUILD
83514>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83516>>>>>>>>>        tSQLScriptArray SQLScriptArray
83516>>>>>>>>>        tSQLScriptArray SQLScriptArray
83516>>>>>>>>>        String sDriverID
83516>>>>>>>>>        Boolean bOK
83516>>>>>>>>>        Integer iSize iCount
83516>>>>>>>>>
83516>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83518>>>>>>>>>            Function_Return False
83519>>>>>>>>>        End
83519>>>>>>>>>>
83519>>>>>>>>>
83519>>>>>>>>>        Get psDriverID to sDriverID
83520>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83521>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83523>>>>>>>>>            Function_Return False
83524>>>>>>>>>        End
83524>>>>>>>>>>
83524>>>>>>>>>
83524>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83525>>>>>>>>>        Decrement iSize
83526>>>>>>>>>
83526>>>>>>>>>        For iCount from 0 to iSize
83532>>>>>>>>>>
83532>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83534>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83535>>>>>>>>>            End
83535>>>>>>>>>>
83535>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83537>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83538>>>>>>>>>            End
83538>>>>>>>>>>
83538>>>>>>>>>        Loop
83539>>>>>>>>>>
83539>>>>>>>>>
83539>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83540>>>>>>>>>
83540>>>>>>>>>        Function_Return (bOK = True)
83541>>>>>>>>>    End_Function
83542>>>>>>>>>
83542>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83542>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83542>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83542>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83544>>>>>>>>>        Integer iChannel iArgumentSize iCount
83544>>>>>>>>>        Number nByteCount
83544>>>>>>>>>        String sSQLScript
83544>>>>>>>>>        tSQLScriptArray SqlScriptArray
83544>>>>>>>>>        tSQLScriptArray SqlScriptArray
83544>>>>>>>>>        UChar[] uCharData
83545>>>>>>>>>
83545>>>>>>>>>        Move False to Err
83546>>>>>>>>>        Get Seq_New_Channel to iChannel
83547>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83549>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83550>>>>>>>>>>
83550>>>>>>>>>            Move True to SqlScriptArray.bError
83551>>>>>>>>>            Function_Return SqlScriptArray
83552>>>>>>>>>        End
83552>>>>>>>>>>
83552>>>>>>>>>
83552>>>>>>>>>        // First decide the size of the script
83552>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83554>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83556>>>>>>>>>        Close_Input channel iChannel
83558>>>>>>>>>
83558>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83559>>>>>>>>>        If (nByteCount  < 1) Begin
83561>>>>>>>>>            Send Seq_Release_Channel iChannel
83562>>>>>>>>>            Move True to SqlScriptArray.bError
83563>>>>>>>>>            Function_Return SqlScriptArray
83564>>>>>>>>>        End
83564>>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>        // If necessary change the string argument_size
83564>>>>>>>>>        // Read the script file from memory line-by-line
83564>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83566>>>>>>>>>            Move 0 to iCount
83567>>>>>>>>>            Repeat
83567>>>>>>>>>>
83567>>>>>>>>>                Readln channel iChannel sSQLScript
83569>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83570>>>>>>>>>                Increment iCount
83571>>>>>>>>>            Until (SeqEof = True)
83573>>>>>>>>>        Close_Input channel iChannel
83575>>>>>>>>>        Send Seq_Release_Channel iChannel
83576>>>>>>>>>
83576>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83576>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83577>>>>>>>>>
83577>>>>>>>>>        Function_Return SqlScriptArray
83578>>>>>>>>>    End_Function
83579>>>>>>>>>
83579>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83581>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83581>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83581>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83581>>>>>>>>>        String[] sMsg aSQLQueryMessages
83583>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83583>>>>>>>>>        TimeSpan tsQuery
83583>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83583>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83583>>>>>>>>>        tSQLConnection SQLConnection
83583>>>>>>>>>        tSQLConnection SQLConnection
83583>>>>>>>>>        Boolean bShowProgress
83583>>>>>>>>>
83583>>>>>>>>>        If (num_arguments > 4) Begin
83585>>>>>>>>>            Move bShowProgr to bShowProgress
83586>>>>>>>>>        End
83586>>>>>>>>>>
83586>>>>>>>>>        Get phoSQLManager to hoSql
83587>>>>>>>>>
83587>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83588>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83588>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83588>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83588>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83588>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83588>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83588>>>>>>>>>        Get piChunkMax to iChunkMax
83589>>>>>>>>>        Move 0 to iChunkCounter
83590>>>>>>>>>        Move "" to sStmt
83591>>>>>>>>>
83591>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83592>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83593>>>>>>>>>
83593>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83594>>>>>>>>>
83594>>>>>>>>>        Get phoSQLManager  to hoSQL
83595>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83597>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83599>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83600>>>>>>>>>                If (iPos > 0) Begin
83602>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83603>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83604>>>>>>>>>                End
83604>>>>>>>>>>
83604>>>>>>>>>            End
83604>>>>>>>>>>
83604>>>>>>>>>        End
83604>>>>>>>>>>
83604>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83605>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83606>>>>>>>>>
83606>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83608>>>>>>>>>            Move False to Err
83609>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83610>>>>>>>>>            If (hoStmt <> 0) Begin
83612>>>>>>>>>
83612>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83612>>>>>>>>>                If (bCreateScriptFile = True) Begin
83614>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83615>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83616>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83617>>>>>>>>>                    Get Seq_New_Channel to iOut
83618>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83620>>>>>>>>>                        Direct_Output channel iOut sExportFile
83622>>>>>>>>>                    End
83622>>>>>>>>>>
83622>>>>>>>>>                End
83622>>>>>>>>>>
83622>>>>>>>>>
83622>>>>>>>>>                // Record starting date/time stamp
83622>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83623>>>>>>>>>                // Turn on error handling if enabled
83623>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83625>>>>>>>>>                    Set pbSqlError to False
83626>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83627>>>>>>>>>                    Move Error_Object_Id to hoError
83628>>>>>>>>>                    Move Self to Error_Object_Id
83629>>>>>>>>>                End
83629>>>>>>>>>>
83629>>>>>>>>>
83629>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83630>>>>>>>>>                Decrement iRows
83631>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83633>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83634>>>>>>>>>                End
83634>>>>>>>>>>
83634>>>>>>>>>
83634>>>>>>>>>                for iCount from 0 to iRows
83640>>>>>>>>>>
83640>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83641>>>>>>>>>
83641>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83643>>>>>>>>>                        If (sSQLVal <> "") Begin
83645>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83646>>>>>>>>>                        End
83646>>>>>>>>>>
83646>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83647>>>>>>>>>                    End
83647>>>>>>>>>>
83647>>>>>>>>>
83647>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83647>>>>>>>>>                    // or if at the very end of the script.
83647>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83649>>>>>>>>>
83649>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83649>>>>>>>>>                        // instead of all in one go.
83649>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83650>>>>>>>>>
83650>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83652>>>>>>>>>                            Write channel iOut sStmt
83654>>>>>>>>>                        End
83654>>>>>>>>>>
83654>>>>>>>>>                        Move "" to sStmt
83655>>>>>>>>>                        Move 0 to iChunkCounter
83656>>>>>>>>>                    End
83656>>>>>>>>>>
83656>>>>>>>>>                    Increment iChunkCounter
83657>>>>>>>>>                Loop
83658>>>>>>>>>>
83658>>>>>>>>>
83658>>>>>>>>>                Repeat
83658>>>>>>>>>>
83658>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83660>>>>>>>>>                        Move hoError to Error_Object_Id
83661>>>>>>>>>                    End
83661>>>>>>>>>>
83661>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83662>>>>>>>>>
83662>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83663>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83664>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83665>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83666>>>>>>>>>                    Set piRows    to iRows
83667>>>>>>>>>                    Set piRowType to iRowType
83668>>>>>>>>>
83668>>>>>>>>>                    If (iMsgs <> 0) Begin
83670>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83672>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83673>>>>>>>>>                        End
83673>>>>>>>>>>
83673>>>>>>>>>                        for i from 1 to iMsgs
83679>>>>>>>>>>
83679>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83680>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83681>>>>>>>>>                            If (bShowProgress = True) Begin
83683>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83685>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83686>>>>>>>>>                                End
83686>>>>>>>>>>
83686>>>>>>>>>                                Else Begin
83687>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83689>>>>>>>>>                                End
83689>>>>>>>>>>
83689>>>>>>>>>                            End
83689>>>>>>>>>>
83689>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83690>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83691>>>>>>>>>                        Loop
83692>>>>>>>>>>
83692>>>>>>>>>
83692>>>>>>>>>
83692>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83694>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83695>>>>>>>>>                        End
83695>>>>>>>>>>
83695>>>>>>>>>                        Set paQueryMessages to sMsg
83696>>>>>>>>>                    End
83696>>>>>>>>>>
83696>>>>>>>>>
83696>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83697>>>>>>>>>                Until (iNextSet = 0)
83699>>>>>>>>>
83699>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83700>>>>>>>>>            End
83700>>>>>>>>>>
83700>>>>>>>>>
83700>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83701>>>>>>>>>            Set ptsQueryExec to tsQuery
83702>>>>>>>>>            Send SqlClose of hoStmt
83703>>>>>>>>>
83703>>>>>>>>>            If (bCreateScriptFile = True) Begin
83705>>>>>>>>>                Close_Output channel iOut
83707>>>>>>>>>                Send Seq_Release_Channel iOut
83708>>>>>>>>>            End
83708>>>>>>>>>>
83708>>>>>>>>>        End
83708>>>>>>>>>>
83708>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83709>>>>>>>>>
83709>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83710>>>>>>>>>    End_Function
83711>>>>>>>>>
83711>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83713>>>>>>>>>        tSQLScriptArray SQLScriptArray
83713>>>>>>>>>        tSQLScriptArray SQLScriptArray
83713>>>>>>>>>        String sDriverID sCollation
83713>>>>>>>>>        Boolean bOK
83713>>>>>>>>>        Integer iSize iCount
83713>>>>>>>>>
83713>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83715>>>>>>>>>            Function_Return False
83716>>>>>>>>>        End
83716>>>>>>>>>>
83716>>>>>>>>>
83716>>>>>>>>>        Get psDriverID  to sDriverID
83717>>>>>>>>>        Get psCollation to sCollation
83718>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83719>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83721>>>>>>>>>            Function_Return False
83722>>>>>>>>>        End
83722>>>>>>>>>>
83722>>>>>>>>>
83722>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83723>>>>>>>>>        Decrement iSize
83724>>>>>>>>>
83724>>>>>>>>>        For iCount from 0 to iSize
83730>>>>>>>>>>
83730>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83732>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83733>>>>>>>>>            End
83733>>>>>>>>>>
83733>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83735>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83736>>>>>>>>>            End
83736>>>>>>>>>>
83736>>>>>>>>>        Loop
83737>>>>>>>>>>
83737>>>>>>>>>
83737>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83738>>>>>>>>>
83738>>>>>>>>>        Function_Return (bOK = True)
83739>>>>>>>>>    End_Function
83740>>>>>>>>>
83740>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83742>>>>>>>>>        tSQLScriptArray SQLScriptArray
83742>>>>>>>>>        tSQLScriptArray SQLScriptArray
83742>>>>>>>>>        String sDriverID sCollation
83742>>>>>>>>>        Boolean bOK
83742>>>>>>>>>        Integer iSize iCount
83742>>>>>>>>>
83742>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83744>>>>>>>>>            Function_Return False
83745>>>>>>>>>        End
83745>>>>>>>>>>
83745>>>>>>>>>
83745>>>>>>>>>        Get psDriverID  to sDriverID
83746>>>>>>>>>        Get psCollation to sCollation
83747>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83748>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83750>>>>>>>>>            Function_Return False
83751>>>>>>>>>        End
83751>>>>>>>>>>
83751>>>>>>>>>
83751>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83752>>>>>>>>>        Decrement iSize
83753>>>>>>>>>
83753>>>>>>>>>        For iCount from 0 to iSize
83759>>>>>>>>>>
83759>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83761>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83762>>>>>>>>>            End
83762>>>>>>>>>>
83762>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83764>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83765>>>>>>>>>            End
83765>>>>>>>>>>
83765>>>>>>>>>        Loop
83766>>>>>>>>>>
83766>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
83766>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83767>>>>>>>>>
83767>>>>>>>>>        Function_Return (bOK = True)
83768>>>>>>>>>    End_Function
83769>>>>>>>>>
83769>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
83771>>>>>>>>>        Integer iMax iPos
83771>>>>>>>>>        String sName
83771>>>>>>>>>
83771>>>>>>>>>        Move (Lowercase(sField)) to sField
83772>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
83775>>>>>>>>>        For iPos from 0 to iMax
83781>>>>>>>>>>
83781>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
83784>>>>>>>>>            Move (Lowercase(sName)) to sName
83785>>>>>>>>>            If (sName = sField) Begin
83787>>>>>>>>>                Function_Return iPos
83788>>>>>>>>>            End
83788>>>>>>>>>>
83788>>>>>>>>>        Loop
83789>>>>>>>>>>
83789>>>>>>>>>        Function_Return -1
83790>>>>>>>>>    End_Function
83791>>>>>>>>>
83791>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
83791>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
83791>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
83791>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
83791>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
83793>>>>>>>>>        String sID sConnString
83793>>>>>>>>>        Integer iDriver iNumConn iCount
83793>>>>>>>>>        Handle hoCLI
83793>>>>>>>>>        Boolean bOK
83793>>>>>>>>>
83793>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83794>>>>>>>>>        If (bOK = False) Begin
83796>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
83797>>>>>>>>>>
83797>>>>>>>>>            Function_Return False
83798>>>>>>>>>        End
83798>>>>>>>>>>
83798>>>>>>>>>
83798>>>>>>>>>        Move False to bOK
83799>>>>>>>>>        Get phoCLIHandler to hoCLI
83800>>>>>>>>>        If (hoCLI <> 0) Begin
83802>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83803>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
83804>>>>>>>>>
83804>>>>>>>>>            // If driver not loaded; load it.
83804>>>>>>>>>            If (iDriver = 0) Begin
83806>>>>>>>>>                Load_Driver sDriverID
83807>>>>>>>>>                Get DriverIndex sDriverID to iDriver
83808>>>>>>>>>            End
83808>>>>>>>>>>
83808>>>>>>>>>            If (iDriver <> 0) Begin
83810>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83813>>>>>>>>>                Decrement iNumConn
83814>>>>>>>>>                For iCount from 0 to iNumConn
83820>>>>>>>>>>
83820>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
83823>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
83826>>>>>>>>>                    If (sID = sConnectionID) Begin
83828>>>>>>>>>                        Move True to bOK
83829>>>>>>>>>                    End
83829>>>>>>>>>>
83829>>>>>>>>>                Loop
83830>>>>>>>>>>
83830>>>>>>>>>            End
83830>>>>>>>>>>
83830>>>>>>>>>        End
83830>>>>>>>>>>
83830>>>>>>>>>
83830>>>>>>>>>        Function_Return bOK
83831>>>>>>>>>    End_Function
83832>>>>>>>>>
83832>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83834>>>>>>>>>        Boolean bOK
83834>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
83835>>>>>>>>>        Function_Return bOK
83836>>>>>>>>>    End_Function
83837>>>>>>>>>
83837>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
83839>>>>>>>>>        Integer iDriverIndex
83839>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
83840>>>>>>>>>        Function_Return (iDriverIndex <> 0)
83841>>>>>>>>>    End_Function
83842>>>>>>>>>
83842>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83842>>>>>>>>>    // attempt to load the driver.
83842>>>>>>>>>    // Returns true if the passed driver is SQL based.
83842>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83844>>>>>>>>>        Boolean bOK
83844>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83845>>>>>>>>>        Function_Return bOK
83846>>>>>>>>>    End_Function
83847>>>>>>>>>
83847>>>>>>>>>    // *** Error Handler ***
83847>>>>>>>>>    //
83847>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
83847>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
83847>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
83849>>>>>>>>>        Integer iSize iErrorMode
83849>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83849>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83849>>>>>>>>>
83849>>>>>>>>>        If (pbProcessingError(Self)) Begin
83851>>>>>>>>>            Procedure_Return
83852>>>>>>>>>        End
83852>>>>>>>>>>
83852>>>>>>>>>
83852>>>>>>>>>        Get Error_Report_Mode to iErrorMode
83853>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
83855>>>>>>>>>            Procedure_Return
83856>>>>>>>>>        End
83856>>>>>>>>>>
83856>>>>>>>>>
83856>>>>>>>>>        Set pbProcessingError to True
83857>>>>>>>>>        Set pbSqlError to True
83858>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
83859>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
83860>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
83861>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
83862>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
83863>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
83864>>>>>>>>>        Set pbProcessingError to False
83865>>>>>>>>>    End_Procedure
83866>>>>>>>>>
83866>>>>>>>>>    // *** Miscellanous Helper Functions ***
83866>>>>>>>>>    //
83866>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
83866>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
83866>>>>>>>>>    Function _TableNameOnly String sName Returns String
83868>>>>>>>>>        String sPath sExt
83868>>>>>>>>>
83868>>>>>>>>>        Get ParseFolderName sName to sPath
83869>>>>>>>>>        If (sPath <> "") Begin
83871>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
83872>>>>>>>>>        End
83872>>>>>>>>>>
83872>>>>>>>>>        Get ParseFileExtension sName to sExt
83873>>>>>>>>>        If (sExt <> "") Begin
83875>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
83876>>>>>>>>>        End
83876>>>>>>>>>>
83876>>>>>>>>>
83876>>>>>>>>>        Function_Return sName
83877>>>>>>>>>    End_Function
83878>>>>>>>>>
83878>>>>>>>>>    // Removes any prefix to a table name.
83878>>>>>>>>>    // Example mssqldrv:mytable returns mytable
83878>>>>>>>>>    //         dbo.mytable returns mytable
83878>>>>>>>>>    Function _TableNoPrefix String sName Returns String
83880>>>>>>>>>        Integer iPos
83880>>>>>>>>>
83880>>>>>>>>>        Move (Pos(":", sName)) to iPos
83881>>>>>>>>>        If (iPos <> 0) Begin
83883>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83884>>>>>>>>>        End
83884>>>>>>>>>>
83884>>>>>>>>>        Move (Pos(".", sName)) to iPos
83885>>>>>>>>>        If (iPos <> 0) Begin
83887>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
83888>>>>>>>>>        End
83888>>>>>>>>>>
83888>>>>>>>>>
83888>>>>>>>>>        Function_Return sName
83889>>>>>>>>>    End_Function
83890>>>>>>>>>
83890>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
83890>>>>>>>>>    // The returned path always ends with a "\"
83890>>>>>>>>>    Function psDataPathFirstPart Returns String
83892>>>>>>>>>        String sDataPath
83892>>>>>>>>>        Integer iCount
83892>>>>>>>>>
83892>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
83893>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
83894>>>>>>>>>        If (iCount > 1) Begin
83896>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
83897>>>>>>>>>        End
83897>>>>>>>>>>
83897>>>>>>>>>        If (sDataPath <> "") Begin
83899>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
83900>>>>>>>>>        End
83900>>>>>>>>>>
83900>>>>>>>>>
83900>>>>>>>>>        Function_Return sDataPath
83901>>>>>>>>>    End_Function
83902>>>>>>>>>
83902>>>>>>>>>    Function psLogTextFileWithPath Returns String
83904>>>>>>>>>        String sFileName
83904>>>>>>>>>        Handle hoLogFile
83904>>>>>>>>>        Get phoLogFile to hoLogFile
83905>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
83906>>>>>>>>>        Function_Return sFileName
83907>>>>>>>>>    End_Function
83908>>>>>>>>>
83908>>>>>>>>>    Function phoLogFile Returns Handle
83910>>>>>>>>>        Handle hoLogFile   
83910>>>>>>>>>        Boolean bErr
83910>>>>>>>>>        
83910>>>>>>>>>        Move Err to bErr
83911>>>>>>>>>        Move 0 to hoLogFile
83912>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
83913>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
83914>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
83916>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
83917>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83918>>>>>>>>>        Move bErr to Err
83919>>>>>>>>>        
83919>>>>>>>>>        Function_Return hoLogFile
83920>>>>>>>>>    End_Function
83921>>>>>>>>>
83921>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
83923>>>>>>>>>        Number nCurrentVersionUpdate
83923>>>>>>>>>
83923>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83924>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83926>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83927>>>>>>>>>
83927>>>>>>>>>        Function_Return nCurrentVersionUpdate
83928>>>>>>>>>    End_Function
83929>>>>>>>>>
83929>>>>>>>>>    Procedure LogError String sText Boolean bError
83931>>>>>>>>>        Handle hoLogFile
83931>>>>>>>>>        Number nCurrentVersionUpdate
83931>>>>>>>>>
83931>>>>>>>>>        Get phoLogFile to hoLogFile
83932>>>>>>>>>        If (hoLogFile = 0) Begin
83934>>>>>>>>>            Procedure_Return
83935>>>>>>>>>        End
83935>>>>>>>>>>
83935>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
83936>>>>>>>>>
83936>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83937>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
83938>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83939>>>>>>>>>    End_Procedure
83940>>>>>>>>>
83940>>>>>>>>>    Function pbContinueOnError Returns Boolean
83942>>>>>>>>>        Boolean bContinueOnError
83942>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
83944>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
83945>>>>>>>>>        End
83945>>>>>>>>>>
83945>>>>>>>>>        Function_Return bContinueOnError
83946>>>>>>>>>    End_Function
83947>>>>>>>>>
83947>>>>>>>>>
83947>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
83949>>>>>>>>>        Integer iChIn iChOut // iCount
83949>>>>>>>>>        Boolean bExists
83949>>>>>>>>>        String sExistingColumn
83949>>>>>>>>>
83949>>>>>>>>>        Move False to bExists
83950>>>>>>>>>        Get Seq_New_Channel to iChIn
83951>>>>>>>>>        Get Seq_New_Channel to iChOut
83952>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83954>>>>>>>>>            Function_Return True
83955>>>>>>>>>        End
83955>>>>>>>>>>
83955>>>>>>>>>
83955>>>>>>>>>        Move False to Err
83956>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
83956>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
83958>>>>>>>>>        While (not(SeqEof))
83962>>>>>>>>>            Readln channel iChIn sExistingColumn
83964>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
83966>>>>>>>>>                Move True to bExists
83967>>>>>>>>>            End
83967>>>>>>>>>>
83967>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
83969>>>>>>>>>                Move True to SeqEof
83970>>>>>>>>>            End
83970>>>>>>>>>>
83970>>>>>>>>>        Loop
83971>>>>>>>>>>
83971>>>>>>>>>        Close_Input channel iChIn
83973>>>>>>>>>        Send Seq_Release_Channel iChIn
83974>>>>>>>>>
83974>>>>>>>>>        If (bExists = False) Begin
83976>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
83978>>>>>>>>>            Writeln channel iChOut sColumnName
83981>>>>>>>>>            Close_Output channel iChOut
83983>>>>>>>>>            Send Seq_Release_Channel iChOut
83984>>>>>>>>>        End
83984>>>>>>>>>>
83984>>>>>>>>>
83984>>>>>>>>>        Function_Return (Err = False)
83985>>>>>>>>>    End_Function
83986>>>>>>>>>
83986>>>>>>>>>    // Changes source code files.
83986>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
83986>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
83986>>>>>>>>>    // to use a Connection ID.
83986>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
83986>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
83986>>>>>>>>>    // Returns True if no errors occured.
83986>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
83988>>>>>>>>>        Integer iCh iRow iItems iCount
83988>>>>>>>>>        String sValue sRow
83988>>>>>>>>>        String[] sFileArray
83989>>>>>>>>>        Boolean bExists bIsActive
83989>>>>>>>>>
83989>>>>>>>>>        Move False to Err
83990>>>>>>>>>        Move 0 to iRow
83991>>>>>>>>>
83991>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
83993>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
83994>>>>>>>>>        End
83994>>>>>>>>>>
83994>>>>>>>>>
83994>>>>>>>>>        Get vFilePathExists sFileName to bExists
83995>>>>>>>>>        If (bExists = False) Begin
83997>>>>>>>>>            If (bShowResult = True) Begin
83999>>>>>>>>>                If (bIsActive = True) Begin
84001>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84002>>>>>>>>>                End
84002>>>>>>>>>>
84002>>>>>>>>>                Else Begin
84003>>>>>>>>>                    Showln "File does not exist: " sFileName
84006>>>>>>>>>                End
84006>>>>>>>>>>
84006>>>>>>>>>            End
84006>>>>>>>>>>
84006>>>>>>>>>            Function_Return False
84007>>>>>>>>>        End
84007>>>>>>>>>>
84007>>>>>>>>>
84007>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84008>>>>>>>>>        If (iCh < 1) Begin
84010>>>>>>>>>            Function_Return False
84011>>>>>>>>>        End
84011>>>>>>>>>>
84011>>>>>>>>>
84011>>>>>>>>>        If (bShowResult = True) Begin
84013>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84015>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84016>>>>>>>>>                If (bIsActive = True) Begin
84018>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84019>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84020>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84021>>>>>>>>>                End
84021>>>>>>>>>>
84021>>>>>>>>>            End
84021>>>>>>>>>>
84021>>>>>>>>>            Else Begin
84022>>>>>>>>>                Showln ""
84024>>>>>>>>>                Showln "sFileName = " sFileName
84027>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84032>>>>>>>>>            End
84032>>>>>>>>>>
84032>>>>>>>>>        End
84032>>>>>>>>>>
84032>>>>>>>>>
84032>>>>>>>>>        While (not(SeqEof))
84036>>>>>>>>>            Readln channel iCh sRow
84038>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84040>>>>>>>>>//                If (bShowResult = True) Begin
84040>>>>>>>>>//                    If (bIsActive = True) Begin
84040>>>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
84040>>>>>>>>>//                    End
84040>>>>>>>>>//                    Else Begin
84040>>>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
84040>>>>>>>>>//                    End
84040>>>>>>>>>//                End
84040>>>>>>>>>                // Change the whole line to the new connection id:
84040>>>>>>>>>                Move sChangeTo to sRow
84041>>>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
84041>>>>>>>>>            End
84041>>>>>>>>>>
84041>>>>>>>>>            Move sRow to sFileArray[iRow]
84042>>>>>>>>>            Increment iRow
84043>>>>>>>>>        Loop
84044>>>>>>>>>>
84044>>>>>>>>>        Send Seq_Close_Channel iCh
84045>>>>>>>>>
84045>>>>>>>>>        Sleep 1 // Wait for Windows to close the file
84046>>>>>>>>>
84046>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84047>>>>>>>>>        If (iCh < 1) Begin
84049>>>>>>>>>            Function_Return False
84050>>>>>>>>>        End
84050>>>>>>>>>>
84050>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84051>>>>>>>>>        Decrement iItems
84052>>>>>>>>>
84052>>>>>>>>>        for iCount from 0 to iItems
84058>>>>>>>>>>
84058>>>>>>>>>            Move sFileArray[iCount] to sValue
84059>>>>>>>>>            Writeln channel iCh sValue
84062>>>>>>>>>        Loop
84063>>>>>>>>>>
84063>>>>>>>>>        Send Seq_Close_Channel iCh
84064>>>>>>>>>
84064>>>>>>>>>        Function_Return (Err = False)
84065>>>>>>>>>    End_Function
84066>>>>>>>>>
84066>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84066>>>>>>>>>    // and opens it in "notepad.exe".
84066>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84066>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84066>>>>>>>>>    Procedure _UtilShowErrorList
84068>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84068>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84068>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84068>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84068>>>>>>>>>
84068>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84069>>>>>>>>>        Get vFolderFormat sPath to sPath
84070>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84071>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84072>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84073>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84074>>>>>>>>>            If (iRows > 0) Begin
84076>>>>>>>>>                Decrement iRows
84077>>>>>>>>>                for iCount from 0 to iRows
84083>>>>>>>>>>
84083>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84084>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84085>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84086>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84092>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84096>>>>>>>>>                Loop
84097>>>>>>>>>>
84097>>>>>>>>>            End
84097>>>>>>>>>>
84097>>>>>>>>>        Send Seq_Close_Channel iCh
84098>>>>>>>>>
84098>>>>>>>>>        If (iRows > 0) Begin
84100>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84101>>>>>>>>>        End
84101>>>>>>>>>>
84101>>>>>>>>>    End_Procedure
84102>>>>>>>>>
84102>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84102>>>>>>>>>    // and the table needs to exist as an SQL table.
84102>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84104>>>>>>>>>        String sRootName sDriverID
84104>>>>>>>>>        Boolean bIsSQL
84104>>>>>>>>>
84104>>>>>>>>>        Move False to bIsSQL
84105>>>>>>>>>        If (hTable > 0) Begin
84107>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84110>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84111>>>>>>>>>            If (bIsSQL = True) Begin
84113>>>>>>>>>                Get psDriverID to sDriverID
84114>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84115>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84116>>>>>>>>>            End
84116>>>>>>>>>>
84116>>>>>>>>>        End
84116>>>>>>>>>>
84116>>>>>>>>>
84116>>>>>>>>>        Function_Return bIsSQL
84117>>>>>>>>>    End_Function
84118>>>>>>>>>
84118>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84120>>>>>>>>>        Boolean bIsSQL
84120>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84121>>>>>>>>>        Function_Return bIsSQL
84122>>>>>>>>>    End_Function
84123>>>>>>>>>
84123>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84123>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84125>>>>>>>>>        String sDatabase sSchema sVal
84125>>>>>>>>>        Boolean bExists
84125>>>>>>>>>        String[] sTablesArray
84126>>>>>>>>>        Integer iSize iCount
84126>>>>>>>>>
84126>>>>>>>>>        Move False to bExists
84127>>>>>>>>>        Get psDatabase to sDatabase
84128>>>>>>>>>        Get psSchema   to sSchema
84129>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84130>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
84131>>>>>>>>>        Decrement iSize
84132>>>>>>>>>        for iCount from 0 to iSize
84138>>>>>>>>>>
84138>>>>>>>>>            Move sTablesArray[iCount] to sVal
84139>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
84141>>>>>>>>>                Move True to bExists
84142>>>>>>>>>                Move iSize to iCount // We're done!
84143>>>>>>>>>            End
84143>>>>>>>>>>
84143>>>>>>>>>        Loop
84144>>>>>>>>>>
84144>>>>>>>>>
84144>>>>>>>>>        Function_Return bExists
84145>>>>>>>>>    End_Function
84146>>>>>>>>>
84146>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84146>>>>>>>>>    // that the embedded .dat file exists on disk.
84146>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84148>>>>>>>>>        Boolean bExists bIsEmbedded
84148>>>>>>>>>        String sDataPath sRootName
84148>>>>>>>>>
84148>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84149>>>>>>>>>        If (bExists = False) Begin
84151>>>>>>>>>            Function_Return False
84152>>>>>>>>>        End
84152>>>>>>>>>>
84152>>>>>>>>>
84152>>>>>>>>>        Move False to bIsEmbedded
84153>>>>>>>>>        If (hTable > 0) Begin
84155>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84158>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84159>>>>>>>>>        End
84159>>>>>>>>>>
84159>>>>>>>>>        If (bIsEmbedded = True) Begin
84161>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84162>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84163>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84164>>>>>>>>>        End
84164>>>>>>>>>>
84164>>>>>>>>>
84164>>>>>>>>>        Function_Return bIsEmbedded
84165>>>>>>>>>    End_Function
84166>>>>>>>>>
84166>>>>>>>>>End_Class
84167>>>>>>>
84167>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84168>>>>>>>
84168>>>>>>>    Procedure Construct_Object
84170>>>>>>>        Forward Send Construct_Object
84172>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84173>>>>>>>    End_Procedure
84174>>>>>>>
84174>>>>>>>    Procedure End_Construct_Object
84176>>>>>>>        Forward Send End_Construct_Object
84178>>>>>>>    End_Procedure
84179>>>>>>>
84179>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84179>>>>>>>    //
84179>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84179>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84181>>>>>>>        Function_Return False
84182>>>>>>>    End_Function
84183>>>>>>>
84183>>>>>>>    // Function for creating a new *Database*.
84183>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84183>>>>>>>    // Returns True if successful.
84183>>>>>>>    // ToDo: Currently only works for MS-SQL...
84183>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84185>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84185>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84185>>>>>>>        Handle hConnection hStmt hoSQLManager
84185>>>>>>>        Integer iFetchResult iDbType
84185>>>>>>>        Boolean bOK bExists
84185>>>>>>>
84185>>>>>>>        Get piDbType to iDbType
84186>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84188>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84189>>>>>>>>
84189>>>>>>>            Function_Return False
84190>>>>>>>        End
84190>>>>>>>>
84190>>>>>>>
84190>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84191>>>>>>>        If (bExists = True) Begin
84193>>>>>>>            Function_Return True
84194>>>>>>>        End
84194>>>>>>>>
84194>>>>>>>
84194>>>>>>>        Get phoSQLManager to hoSQLManager
84195>>>>>>>
84195>>>>>>>        Get psConnectionID     to sConnectionID
84196>>>>>>>        Get psConnectionString to sConnectionString
84197>>>>>>>        Move 0 to LastErr
84198>>>>>>>
84198>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84200>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84200>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84200>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84200>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84200>>>>>>>//                If (iPos > 0) Begin
84200>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84200>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84200>>>>>>>//                End
84200>>>>>>>//            End
84200>>>>>>>        End
84200>>>>>>>>
84200>>>>>>>
84200>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84201>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84202>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84203>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84205>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84206>>>>>>>>
84206>>>>>>>            Function_Return False
84207>>>>>>>        End
84207>>>>>>>>
84207>>>>>>>
84207>>>>>>>        Get SqlOpen of hConnection to hStmt
84208>>>>>>>
84208>>>>>>>        If (hStmt = 0) Begin
84210>>>>>>>            Send SqlDisconnect of hoSQLManager
84211>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84212>>>>>>>>
84212>>>>>>>            Function_Return False
84213>>>>>>>        End
84213>>>>>>>>
84213>>>>>>>
84213>>>>>>>        Get psCollation to sCollation
84214>>>>>>>
84214>>>>>>>        Case Begin
84214>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84216>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84217>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84218>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84219>>>>>>>
84219>>>>>>>                // Check if database exists
84219>>>>>>>                Send SqlExecDirect of hStmt sSQL
84220>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84221>>>>>>>                Send SqlClose of hStmt
84222>>>>>>>                Send SqlDisconnect of hConnection
84223>>>>>>>                // If database already exists we're out of here!
84223>>>>>>>                // Note that we return True as this is not an error.
84223>>>>>>>                If (iFetchResult > 0) Begin
84225>>>>>>>                    Function_Return True
84226>>>>>>>                End
84226>>>>>>>>
84226>>>>>>>                // Database doesn't exist, create it.
84226>>>>>>>                If (iFetchResult = 0) Begin
84228>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84229>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84230>>>>>>>                    If (sCollation <> "") Begin
84232>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84233>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84234>>>>>>>                    End
84234>>>>>>>>
84234>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84235>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84236>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84238>>>>>>>                        Function_Return False
84239>>>>>>>                    End
84239>>>>>>>>
84239>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84239>>>>>>>                    Sleep 1
84240>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84241>>>>>>>                End
84241>>>>>>>>
84241>>>>>>>                Case Break
84242>>>>>>>
84242>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84245>>>>>>>                // ToDo: How should this be set/checked?
84245>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84245>>>>>>>//                    Set psCollation to "utf8"
84245>>>>>>>//                End
84245>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84245>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84246>>>>>>>                Case Break
84247>>>>>>>
84247>>>>>>>            Case Else
84247>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84248>>>>>>>>
84248>>>>>>>        Case End
84248>>>>>>>
84248>>>>>>>        If (Err = False) Begin
84250>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84251>>>>>>>        End
84251>>>>>>>>
84251>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84251>>>>>>>        // the one we just created.
84251>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84253>>>>>>>            Set psDatabase to sDatabase
84254>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84254>>>>>>>            If (bPermanantly = True) Begin
84256>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84258>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84259>>>>>>>                End
84259>>>>>>>>
84259>>>>>>>            End
84259>>>>>>>>
84259>>>>>>>        End
84259>>>>>>>>
84259>>>>>>>
84259>>>>>>>        Function_Return (Err = False)
84260>>>>>>>    End_Function
84261>>>>>>>
84261>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84261>>>>>>>    // will be used.
84261>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84263>>>>>>>        Boolean bOK bExists bShowProgress bErr
84263>>>>>>>        String sStatement sDriverID
84263>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84263>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84263>>>>>>>        Integer iDbType
84263>>>>>>>
84263>>>>>>>        If (sDatabase = "") Begin
84265>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84266>>>>>>>>
84266>>>>>>>            Function_Return False
84267>>>>>>>        End
84267>>>>>>>>
84267>>>>>>>        If (sBackupName = "") Begin
84269>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84270>>>>>>>>
84270>>>>>>>            Function_Return False
84271>>>>>>>        End
84271>>>>>>>>
84271>>>>>>>
84271>>>>>>>        // Create backup-folder if it doesn't exist
84271>>>>>>>        Get vFolderExists sPath to bExists
84272>>>>>>>        If (bExists = False) Begin
84274>>>>>>>            Get vCreateDirectory sPath to bErr
84275>>>>>>>            If (bErr = True) Begin
84277>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84278>>>>>>>>
84278>>>>>>>                Function_Return False
84279>>>>>>>            End
84279>>>>>>>>
84279>>>>>>>        End
84279>>>>>>>>
84279>>>>>>>        // Make sure the path ends with a back-slash
84279>>>>>>>        If (sPath <> "") Begin
84281>>>>>>>            Get vFolderFormat sPath to sPath
84282>>>>>>>        End
84282>>>>>>>>
84282>>>>>>>
84282>>>>>>>        Get psDriverID to sDriverID
84283>>>>>>>        Get piDbType   to iDbType
84284>>>>>>>        If (num_arguments > 3) Begin
84286>>>>>>>            Move bShowProg to bShowProgress
84287>>>>>>>        End
84287>>>>>>>>
84287>>>>>>>
84287>>>>>>>        Case Begin
84287>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84289>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84289>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84289>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84290>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84291>>>>>>>
84291>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84292>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84293>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84294>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84295>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84296>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84297>>>>>>>                Case Break
84298>>>>>>>            Case Else
84298>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84299>>>>>>>        Case End
84299>>>>>>>
84299>>>>>>>        Function_Return bOK
84300>>>>>>>    End_Function
84301>>>>>>>
84301>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84303>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84303>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84303>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84303>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84303>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84303>>>>>>>        tSQLConnection SQLConnection
84303>>>>>>>        tSQLConnection SQLConnection
84303>>>>>>>
84303>>>>>>>        If (sDatabase = "") Begin
84305>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84306>>>>>>>>
84306>>>>>>>            Function_Return ""
84307>>>>>>>        End
84307>>>>>>>>
84307>>>>>>>
84307>>>>>>>        Move "" to sRetval
84308>>>>>>>        Get psDriverID to sDriverID
84309>>>>>>>        Get piDbType   to iDbType
84310>>>>>>>
84310>>>>>>>        Case Begin
84310>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84312>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84312>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84313>>>>>>>
84313>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84314>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84315>>>>>>>                Get phoSQLManager to hoSQLHandler
84316>>>>>>>
84316>>>>>>>                If (hoSQLHandler <> 0) Begin
84318>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84319>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84320>>>>>>>
84320>>>>>>>                    If (hoSQLConnect <> 0) Begin
84322>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84323>>>>>>>                        If (hstmt <> 0) Begin
84325>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84326>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84327>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84328>>>>>>>                            If (iFetchResult <> 0) Begin
84330>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84331>>>>>>>                            End
84331>>>>>>>>
84331>>>>>>>                            Send SQLClose of hstmt
84332>>>>>>>                        End
84332>>>>>>>>
84332>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84333>>>>>>>                    End
84333>>>>>>>>
84333>>>>>>>                End
84333>>>>>>>>
84333>>>>>>>                Case Break
84334>>>>>>>            Case Else
84334>>>>>>>                If (bSilent = False) Begin
84336>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84337>>>>>>>                End
84337>>>>>>>>
84337>>>>>>>        Case End
84337>>>>>>>
84337>>>>>>>        Function_Return sRetval
84338>>>>>>>    End_Function
84339>>>>>>>
84339>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84341>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84341>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84341>>>>>>>        Handle hConnection hStmt hoSQLManager
84341>>>>>>>        Integer iDbType // iFetchResult
84341>>>>>>>
84341>>>>>>>        If (sDatabase = "") Begin
84343>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84344>>>>>>>>
84344>>>>>>>            Function_Return False
84345>>>>>>>        End
84345>>>>>>>>
84345>>>>>>>
84345>>>>>>>        If (sSQLCollation = "") Begin
84347>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84348>>>>>>>>
84348>>>>>>>            Function_Return False
84349>>>>>>>        End
84349>>>>>>>>
84349>>>>>>>
84349>>>>>>>        Get psDriverID to sDriverID
84350>>>>>>>        Get piDbType   to iDbType
84351>>>>>>>
84351>>>>>>>        Get phoSQLManager to hoSQLManager
84352>>>>>>>        Get psConnectionID     to sConnectionID
84353>>>>>>>        Get psConnectionString to sConnectionString
84354>>>>>>>        Move 0 to LastErr
84355>>>>>>>
84355>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84356>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84357>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84358>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84360>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84361>>>>>>>>
84361>>>>>>>            Function_Return False
84362>>>>>>>        End
84362>>>>>>>>
84362>>>>>>>
84362>>>>>>>        Get SqlOpen of hConnection to hStmt
84363>>>>>>>
84363>>>>>>>        If (hStmt = 0) Begin
84365>>>>>>>            Send SqlDisconnect of hoSQLManager
84366>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84367>>>>>>>>
84367>>>>>>>            Function_Return False
84368>>>>>>>        End
84368>>>>>>>>
84368>>>>>>>
84368>>>>>>>        // Check if collation already exists
84368>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84369>>>>>>>        // If the current collate is the same as the new; do nothing.
84369>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84371>>>>>>>            Function_Return True
84372>>>>>>>        End
84372>>>>>>>>
84372>>>>>>>
84372>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84373>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84374>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84375>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84376>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84377>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84378>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84379>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84380>>>>>>>
84380>>>>>>>        // MS-SQL Syntax:
84380>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84380>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84380>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84380>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84381>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84382>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84383>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84383>>>>>>>
84383>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84384>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84385>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84386>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84388>>>>>>>           Function_Return False
84389>>>>>>>        End
84389>>>>>>>>
84389>>>>>>>
84389>>>>>>>        Function_Return (Err = False)
84390>>>>>>>    End_Function
84391>>>>>>>
84391>>>>>>>
84391>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84391>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84393>>>>>>>        Function_Return False
84394>>>>>>>    End_Function
84395>>>>>>>
84395>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84395>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84395>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84395>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84395>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84395>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84397>>>>>>>        Handle hToTable
84397>>>>>>>        Boolean bOK bExists bOpened bCopyData
84397>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84397>>>>>>>        tSQLConnection SQLConnection
84397>>>>>>>        tSQLConnection SQLConnection
84397>>>>>>>        Integer iPos iMaxRecords
84397>>>>>>>
84397>>>>>>>        Get psDriverID to sDriverID
84398>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84399>>>>>>>        If (bExists = False) Begin
84401>>>>>>>            Function_Return False
84402>>>>>>>        End
84402>>>>>>>>
84402>>>>>>>
84402>>>>>>>        If (num_arguments > 1) Begin
84404>>>>>>>            Move bCpyDat to bCopyData
84405>>>>>>>        End
84405>>>>>>>>
84405>>>>>>>        Else Begin
84406>>>>>>>            Move False to bCopyData
84407>>>>>>>        End
84407>>>>>>>>
84407>>>>>>>
84407>>>>>>>        Open hTable
84409>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84412>>>>>>>        If (bOpened = False) Begin
84414>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84415>>>>>>>>
84415>>>>>>>            Function_Return False
84416>>>>>>>        End
84416>>>>>>>>
84416>>>>>>>        Move 0 to hToTable
84417>>>>>>>
84417>>>>>>>        Move 16711679 to iMaxRecords
84418>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84421>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84422>>>>>>>        If (iPos > 0) Begin
84424>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84425>>>>>>>        End
84425>>>>>>>>
84425>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84428>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84429>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84430>>>>>>>
84430>>>>>>>        If (ghoProgressBar <> 0) Begin
84432>>>>>>>            Send DoAdvance of ghoProgressBar
84433>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84434>>>>>>>        End
84434>>>>>>>>
84434>>>>>>>
84434>>>>>>>        Move False to Err
84435>>>>>>>
84435>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84436>>>>>>>            Structure_Copy hTable to hToTable
84437>>>>>>>
84437>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84440>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84443>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84446>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84449>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84452>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84453>>>>>>>
84453>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84455>>>>>>>
84455>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84456>>>>>>>        Move (not(Err)) to bOK
84457>>>>>>>        If (bOK = True and bCopyData = True) Begin
84459>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84460>>>>>>>        End
84460>>>>>>>>
84460>>>>>>>
84460>>>>>>>        // This must be after copying data...
84460>>>>>>>        If (Err = False) Begin
84462>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84465>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84468>>>>>>>        End
84468>>>>>>>>
84468>>>>>>>        Move (not(Err)) to bOK
84469>>>>>>>
84469>>>>>>>        Function_Return (bOK = True)
84470>>>>>>>    End_Function
84471>>>>>>>
84471>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84471>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84471>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84473>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84473>>>>>>>        Integer iDbType
84473>>>>>>>        Boolean bExists
84473>>>>>>>
84473>>>>>>>        Get psDriverID to sDriverID
84474>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84475>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84476>>>>>>>        If (bExists = True) Begin
84478>>>>>>>            Function_Return False
84479>>>>>>>        End
84479>>>>>>>>
84479>>>>>>>
84479>>>>>>>        Get psDataPathFirstPart to sPath
84480>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84481>>>>>>>
84481>>>>>>>        Get piDbType to iDbType
84482>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84483>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84484>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84485>>>>>>>
84485>>>>>>>        Move False to Err
84486>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84487>>>>>>>
84487>>>>>>>        Function_Return (Err = False)
84488>>>>>>>    End_Function
84489>>>>>>>
84489>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84489>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84489>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84491>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84491>>>>>>>        Integer iDbType
84491>>>>>>>        Boolean bExists
84491>>>>>>>
84491>>>>>>>        Get psDriverID to sDriverID
84492>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84493>>>>>>>        If (bExists = True) Begin
84495>>>>>>>            Function_Return False
84496>>>>>>>        End
84496>>>>>>>>
84496>>>>>>>
84496>>>>>>>        Get psDataPathFirstPart to sPath
84497>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84498>>>>>>>        If (bExists = True) Begin
84500>>>>>>>            // ToDo: What should we do if an .int file already exists?
84500>>>>>>>        End
84500>>>>>>>>
84500>>>>>>>
84500>>>>>>>        Get piDbType to iDbType
84501>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84502>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84503>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84504>>>>>>>
84504>>>>>>>        Move False to Err
84505>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84506>>>>>>>
84506>>>>>>>        Function_Return (Err = False)
84507>>>>>>>    End_Function
84508>>>>>>>    
84508>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
84508>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
84508>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84510>>>>>>>        Boolean bOK                                                            
84510>>>>>>>        String sStatement
84510>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84511>>>>>>>        Function_Return bOK
84512>>>>>>>    End_Function
84513>>>>>>>    
84513>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84513>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84513>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84513>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
84515>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84515>>>>>>>        Integer iRetval iDbType
84515>>>>>>>        Boolean bExists bOK
84515>>>>>>>
84515>>>>>>>        Get psDriverID to sDriverID
84516>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84517>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84518>>>>>>>        If (bExists = False) Begin
84520>>>>>>>            Function_Return False
84521>>>>>>>        End
84521>>>>>>>>
84521>>>>>>>
84521>>>>>>>        Get psDataPathFirstPart to sPath
84522>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84523>>>>>>>
84523>>>>>>>        Get piDbType to iDbType
84524>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84525>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84526>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84527>>>>>>>
84527>>>>>>>        Move False to Err
84528>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84529>>>>>>>
84529>>>>>>>        // We also need to remove the cache-file since the table has been changed
84529>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84530>>>>>>>
84530>>>>>>>        Function_Return (Err = False)
84531>>>>>>>    End_Function
84532>>>>>>>
84532>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84532>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84534>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84534>>>>>>>        Integer iRetval iDbType
84534>>>>>>>        Boolean bOK
84534>>>>>>>
84534>>>>>>>        Get psDriverID to sDriverID
84535>>>>>>>        Get psDataPathFirstPart to sPath
84536>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84537>>>>>>>
84537>>>>>>>        Get piDbType to iDbType
84538>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84539>>>>>>>        Get psSchema to sSchema
84540>>>>>>>        If (sSchema = "") Begin
84542>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84543>>>>>>>        End
84543>>>>>>>>
84543>>>>>>>        Move (Uppercase(sTableName)) to sVal
84544>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84546>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84547>>>>>>>        End
84547>>>>>>>>
84547>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84548>>>>>>>
84548>>>>>>>        Move False to Err
84549>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84550>>>>>>>
84550>>>>>>>        // We also need to remove the cache-file since the table has been changed
84550>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84551>>>>>>>
84551>>>>>>>        Function_Return (Err = False)
84552>>>>>>>    End_Function
84553>>>>>>>
84553>>>>>>>    // *** Sql View Messages ***
84553>>>>>>>
84553>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84555>>>>>>>        Boolean bOK
84555>>>>>>>        Integer iDbType
84555>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84555>>>>>>>
84555>>>>>>>        Get psDriverID to sDriverID
84556>>>>>>>        Get piDbType   to iDbType
84557>>>>>>>
84557>>>>>>>        Case Begin
84557>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84559>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84560>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84561>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84562>>>>>>>            Break
84563>>>>>>>
84563>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84566>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84567>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84568>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84569>>>>>>>            Break
84570>>>>>>>
84570>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84573>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84574>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84575>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84576>>>>>>>            Break
84577>>>>>>>
84577>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84580>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84581>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84582>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84583>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84584>>>>>>>            Break
84585>>>>>>>
84585>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84588>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84589>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84590>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84591>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84592>>>>>>>            Break
84593>>>>>>>        Case End
84593>>>>>>>
84593>>>>>>>        Move False to Err
84594>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84595>>>>>>>        Move (Err = False) to bOK
84596>>>>>>>
84596>>>>>>>        Function_Return bOK
84597>>>>>>>    End_Function
84598>>>>>>>
84598>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84598>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84600>>>>>>>        Function_Return False
84601>>>>>>>    End_Function
84602>>>>>>>
84602>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84602>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84604>>>>>>>        Integer iLength iDecimals
84604>>>>>>>        String sColumnValue
84604>>>>>>>        String sTableName sDriverID
84604>>>>>>>        Boolean bOK bInitializeValue
84604>>>>>>>
84604>>>>>>>        Get psDriverID to sDriverID
84605>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84606>>>>>>>        If (bOK = False) Begin
84608>>>>>>>            Function_Return False
84609>>>>>>>        End
84609>>>>>>>>
84609>>>>>>>
84609>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84610>>>>>>>        If (sTableName = "") Begin
84612>>>>>>>            Function_Return False
84613>>>>>>>        End
84613>>>>>>>>
84613>>>>>>>
84613>>>>>>>        If (num_arguments > 3) Begin
84615>>>>>>>            Move iLen     to iLength
84616>>>>>>>            Move iDec     to iDecimals
84617>>>>>>>            Move bInitVal to bInitializeValue
84618>>>>>>>            Move sColVal  to sColumnValue
84619>>>>>>>        End
84619>>>>>>>>
84619>>>>>>>
84619>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84620>>>>>>>
84620>>>>>>>        Function_Return (bOK = True)
84621>>>>>>>    End_Function
84622>>>>>>>
84622>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84622>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84624>>>>>>>        Integer iDbType iLength iDecimals iDriver
84624>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84624>>>>>>>        String sDriverID sNotNull
84624>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84624>>>>>>>        Handle hTable
84624>>>>>>>
84624>>>>>>>        Get psDriverID to sDriverID
84625>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84626>>>>>>>        If (bOK = False) Begin
84628>>>>>>>            Function_Return True
84629>>>>>>>        End
84629>>>>>>>>
84629>>>>>>>
84629>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84630>>>>>>>        If (hTable = 0) Begin
84632>>>>>>>            Get NextFreeFilelistSlot to hTable
84633>>>>>>>        End
84633>>>>>>>>
84633>>>>>>>
84633>>>>>>>        Get piDbType to iDbType
84634>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84634>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84635>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84637>>>>>>>            Function_Return True
84638>>>>>>>        End
84638>>>>>>>>
84638>>>>>>>
84638>>>>>>>        Get DriverIndex sDriverID to iDriver
84639>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84642>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84645>>>>>>>
84645>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84646>>>>>>>        If (num_arguments > 3) Begin
84648>>>>>>>            Move iLen     to iLength
84649>>>>>>>            Move iDec     to iDecimals
84650>>>>>>>            Move bInitVal to bInitializeValue
84651>>>>>>>            Move sColVal  to sColumnValue
84652>>>>>>>        End
84652>>>>>>>>
84652>>>>>>>
84652>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84653>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84654>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84655>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84656>>>>>>>
84656>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84657>>>>>>>        If (bFixed = False) Begin
84659>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84660>>>>>>>        End
84660>>>>>>>>
84660>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84661>>>>>>>
84661>>>>>>>        Move False to Err
84662>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84663>>>>>>>
84663>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84665>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84666>>>>>>>        End
84666>>>>>>>>
84666>>>>>>>
84666>>>>>>>        If (Err = False) Begin
84668>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84669>>>>>>>        End
84669>>>>>>>>
84669>>>>>>>
84669>>>>>>>        Move (not(Err)) to bRetval
84670>>>>>>>
84670>>>>>>>        // We also need to remove the cache-file since the table has been changed
84670>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84671>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84674>>>>>>>
84674>>>>>>>        Function_Return bRetval
84675>>>>>>>    End_Function
84676>>>>>>>
84676>>>>>>>    // To update all current rows for a table column with a common value.
84676>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84678>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84678>>>>>>>        Boolean bRetval bSQLDriver
84678>>>>>>>        Integer iCurrErr iDbType
84678>>>>>>>
84678>>>>>>>        Move False to bRetval
84679>>>>>>>        Get piDbType to iDbType
84680>>>>>>>        Get psDriverID to sDriverID
84681>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84682>>>>>>>        If (bSQLDriver = False) Begin
84684>>>>>>>            Function_Return bRetval
84685>>>>>>>        End
84685>>>>>>>>
84685>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84686>>>>>>>
84686>>>>>>>        Move Err to iCurrErr
84687>>>>>>>        Move False to Err
84688>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84689>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84690>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84691>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84691>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
84693>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84694>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84695>>>>>>>        End
84695>>>>>>>>
84695>>>>>>>        Else Begin
84696>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84697>>>>>>>        End
84697>>>>>>>>
84697>>>>>>>
84697>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84698>>>>>>>        Move (Err = False) to bRetval
84699>>>>>>>        Move iCurrErr to Err
84700>>>>>>>
84700>>>>>>>        Function_Return bRetval
84701>>>>>>>    End_Function
84702>>>>>>>
84702>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84702>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84702>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84704>>>>>>>        String sDriverID sTableName
84704>>>>>>>        Boolean bOK
84704>>>>>>>
84704>>>>>>>        Get psDriverID to sDriverID
84705>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84706>>>>>>>        If (bOK = False) Begin
84708>>>>>>>            Function_Return False
84709>>>>>>>        End
84709>>>>>>>>
84709>>>>>>>
84709>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84710>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84711>>>>>>>
84711>>>>>>>        Function_Return (Err = False)
84712>>>>>>>    End_Function
84713>>>>>>>
84713>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84713>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84713>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84713>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84715>>>>>>>        Integer iDbType iLength iDecimals
84715>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84715>>>>>>>        Boolean bExists bOK bFixed
84715>>>>>>>        Handle hTable
84715>>>>>>>
84715>>>>>>>        Get psDriverID to sDriverID
84716>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84717>>>>>>>        If (bOK = False) Begin
84719>>>>>>>            Function_Return False
84720>>>>>>>        End
84720>>>>>>>>
84720>>>>>>>
84720>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84721>>>>>>>        If (hTable = 0) Begin
84723>>>>>>>            Get NextFreeFilelistSlot to hTable
84724>>>>>>>        End
84724>>>>>>>>
84724>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84725>>>>>>>        If (bExists = False) Begin
84727>>>>>>>            Function_Return False
84728>>>>>>>        End
84728>>>>>>>>
84728>>>>>>>
84728>>>>>>>        If (num_arguments > 3) Begin
84730>>>>>>>            Move iLen to iLength
84731>>>>>>>        End
84731>>>>>>>>
84731>>>>>>>        If (num_arguments > 4) Begin
84733>>>>>>>            Move iDec to iDecimals
84734>>>>>>>        End
84734>>>>>>>>
84734>>>>>>>
84734>>>>>>>        Get piDbType to iDbType
84735>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84736>>>>>>>
84736>>>>>>>        Move False to Err
84737>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84738>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84739>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84740>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84741>>>>>>>
84741>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84742>>>>>>>        If (bFixed = False) Begin
84744>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84745>>>>>>>        End
84745>>>>>>>>
84745>>>>>>>
84745>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84746>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84747>>>>>>>
84747>>>>>>>        // We also need to remove the cache-file since the table has been changed
84747>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84748>>>>>>>
84748>>>>>>>        Function_Return (Err = False)
84749>>>>>>>    End_Function
84750>>>>>>>
84750>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84752>>>>>>>        Boolean bOK bErr bIsSQLDriver
84752>>>>>>>        String sDriverID
84752>>>>>>>        Integer iDataType
84752>>>>>>>
84752>>>>>>>        Get psDriverID to sDriverID
84753>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84754>>>>>>>        If (bIsSQLDriver = False) Begin
84756>>>>>>>            Function_Return False
84757>>>>>>>        End
84757>>>>>>>>
84757>>>>>>>
84757>>>>>>>        Move Err to bErr
84758>>>>>>>        Move False to bErr
84759>>>>>>>
84759>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84759>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84759>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84760>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
84763>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
84765>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
84766>>>>>>>        End
84766>>>>>>>>
84766>>>>>>>
84766>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84769>>>>>>>        Move (not(Err)) to bOK
84770>>>>>>>        Move bErr to Err
84771>>>>>>>
84771>>>>>>>        Function_Return bOK
84772>>>>>>>    End_Function
84773>>>>>>>
84773>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84775>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84775>>>>>>>        String sDriverID
84775>>>>>>>
84775>>>>>>>        Get psDriverID to sDriverID
84776>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84777>>>>>>>        If (bIsSQLDriver = False) Begin
84779>>>>>>>            Function_Return False
84780>>>>>>>        End
84780>>>>>>>>
84780>>>>>>>
84780>>>>>>>        Move Err to bErr
84781>>>>>>>        Move False to bErr
84782>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84785>>>>>>>        If (bNullable = bCurrentState) Begin
84787>>>>>>>            Function_Return True
84788>>>>>>>        End
84788>>>>>>>>
84788>>>>>>>
84788>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84791>>>>>>>        If (bOpen = False) Begin
84793>>>>>>>            Get AutoConnectionIDLogin to bOK
84794>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84795>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84796>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84797>>>>>>>            Open hTable
84799>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84800>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84801>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84802>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84805>>>>>>>        End
84805>>>>>>>>
84805>>>>>>>        If (bOpen = True) Begin
84807>>>>>>>            Structure_Start hTable sDriverID
84808>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84811>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84812>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84814>>>>>>>            Set Action_Text of ghoStatusPanel to ""
84815>>>>>>>        End
84815>>>>>>>>
84815>>>>>>>
84815>>>>>>>        Move (not(Err)) to bOK
84816>>>>>>>        Move bErr to Err
84817>>>>>>>
84817>>>>>>>        Function_Return bOK
84818>>>>>>>    End_Function
84819>>>>>>>
84819>>>>>>>    // Drop column by its table handle
84819>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84821>>>>>>>        String sDriverID sTableName
84821>>>>>>>        Boolean bOK
84821>>>>>>>
84821>>>>>>>        Get psDriverID to sDriverID
84822>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84823>>>>>>>        If (bOK = False) Begin
84825>>>>>>>            Function_Return False
84826>>>>>>>        End
84826>>>>>>>>
84826>>>>>>>
84826>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84827>>>>>>>        If (sTableName = "") Begin
84829>>>>>>>            Function_Return False
84830>>>>>>>        End
84830>>>>>>>>
84830>>>>>>>
84830>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84831>>>>>>>
84831>>>>>>>        Function_Return (bOK = True)
84832>>>>>>>    End_Function
84833>>>>>>>
84833>>>>>>>    // Drop column by its table name as a string.
84833>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84835>>>>>>>        Integer iDbType iDriver
84835>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
84835>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84835>>>>>>>        Handle hTable
84835>>>>>>>
84835>>>>>>>        Get psDriverID to sDriverID
84836>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84837>>>>>>>        If (bOK = False) Begin
84839>>>>>>>            Function_Return False
84840>>>>>>>        End
84840>>>>>>>>
84840>>>>>>>
84840>>>>>>>        Get DriverIndex sDriverID to iDriver
84841>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84844>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84847>>>>>>>
84847>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84848>>>>>>>        If (hTable <> 0) Begin
84850>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84851>>>>>>>            If (bExists = False) Begin
84853>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84856>>>>>>>                Function_Return False
84857>>>>>>>            End
84857>>>>>>>>
84857>>>>>>>        End
84857>>>>>>>>
84857>>>>>>>
84857>>>>>>>        Get piDbType to iDbType
84858>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84860>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84861>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
84862>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84865>>>>>>>            Function_Return bOK
84866>>>>>>>        End
84866>>>>>>>>
84866>>>>>>>
84866>>>>>>>        Move False to Err
84867>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84868>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84869>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84870>>>>>>>
84870>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84871>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84872>>>>>>>        Move (not(Err)) to bRetval
84873>>>>>>>
84873>>>>>>>        // We also need to remove the cache-file since the table has been changed
84873>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84874>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84877>>>>>>>
84877>>>>>>>        Function_Return bRetval
84878>>>>>>>    End_Function
84879>>>>>>>
84879>>>>>>>    // Rename a field/column by table handle (filelist number)
84879>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84881>>>>>>>        String sDriverID sTableName
84881>>>>>>>        Boolean bOK
84881>>>>>>>
84881>>>>>>>        Get psDriverID to sDriverID
84882>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84883>>>>>>>        If (bOK = False) Begin
84885>>>>>>>            Function_Return False
84886>>>>>>>        End
84886>>>>>>>>
84886>>>>>>>
84886>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84887>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84888>>>>>>>
84888>>>>>>>        Function_Return (Err = False)
84889>>>>>>>    End_Function
84890>>>>>>>
84890>>>>>>>    // Rename a field/column by table name.
84890>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84892>>>>>>>        Integer iDbType iDataType
84892>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84892>>>>>>>        Boolean bOK bRetval
84892>>>>>>>        Handle hTable
84892>>>>>>>
84892>>>>>>>        Move sTableName to sOrgTableName
84893>>>>>>>        Get psDriverID to sDriverID
84894>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84895>>>>>>>        If (bOK = False) Begin
84897>>>>>>>            Function_Return False
84898>>>>>>>        End
84898>>>>>>>>
84898>>>>>>>
84898>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84899>>>>>>>        If (sVal = "") Begin
84901>>>>>>>            Function_Return False
84902>>>>>>>        End
84902>>>>>>>>
84902>>>>>>>
84902>>>>>>>        Get piDbType to iDbType
84903>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84904>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
84905>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84906>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84907>>>>>>>
84907>>>>>>>        Case Begin
84907>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
84909>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84910>>>>>>>                Case Break
84911>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84911>>>>>>>            Case (iDbType = EN_dbTypeOracle)
84914>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84915>>>>>>>                Case Break
84916>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84916>>>>>>>            Case (iDbType = EN_dbTypeDB2)
84919>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84920>>>>>>>                Case Break
84921>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84921>>>>>>>            Case (iDbType = EN_dbTypePostgre)
84924>>>>>>>                Move sOrgTableName to sTableName
84925>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84926>>>>>>>                Case Break
84927>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
84930>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84930>>>>>>>                Move sOrgTableName to sTableName
84931>>>>>>>                Get psDatabase to sDatabase
84932>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
84933>>>>>>>                If (hTable = 0) Begin
84935>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84936>>>>>>>                    If (bOK = False) Begin
84938>>>>>>>                        Function_Return False
84939>>>>>>>                    End
84939>>>>>>>>
84939>>>>>>>                    Get NextFreeFilelistSlot to hTable
84940>>>>>>>                End
84940>>>>>>>>
84940>>>>>>>                Else Begin
84941>>>>>>>                    Open hTable
84943>>>>>>>                End
84943>>>>>>>>
84943>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84944>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84945>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84946>>>>>>>                Case Break
84947>>>>>>>            Case Else
84947>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84948>>>>>>>        Case End
84948>>>>>>>
84948>>>>>>>        Move False to Err
84949>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84950>>>>>>>        Move (Err = False) to bRetval
84951>>>>>>>        // We also need to remove the cache-file since the table has been changed
84951>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84952>>>>>>>
84952>>>>>>>        Function_Return bRetval
84953>>>>>>>    End_Function
84954>>>>>>>
84954>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84956>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
84956>>>>>>>        Integer iNumCols iCount iDataType
84956>>>>>>>        String sValue
84956>>>>>>>
84956>>>>>>>        Get phoSQLManager to hoSQLHandler
84957>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84958>>>>>>>        If (hSQLConnect <> 0) Begin
84960>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
84961>>>>>>>            If (hStmt <> 0) Begin
84963>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84964>>>>>>>
84964>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84965>>>>>>>                For iCount from 1 to iNumCols
84971>>>>>>>>
84971>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84972>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84974>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84975>>>>>>>                        Move iNumCols to iCount // We're out of here
84976>>>>>>>                    End
84976>>>>>>>>
84976>>>>>>>                Loop
84977>>>>>>>>
84977>>>>>>>
84977>>>>>>>                Send SQLClose of hStmt
84978>>>>>>>            End
84978>>>>>>>>
84978>>>>>>>            Send SQLDisconnect of hSQLConnect
84979>>>>>>>        End
84979>>>>>>>>
84979>>>>>>>
84979>>>>>>>        Function_Return iDataType
84980>>>>>>>    End_Function
84981>>>>>>>
84981>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84981>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
84983>>>>>>>        Function_Return False
84984>>>>>>>    End_Function
84985>>>>>>>
84985>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
84987>>>>>>>        String sMessage // sConnectionString
84987>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
84987>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
84987>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
84990>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
84990>>>>>>>        TimeSpan tsQuery tsFetch
84990>>>>>>>        tSqlErrorArray aSqlErrorArray
84990>>>>>>>        tSqlErrorArray aSqlErrorArray
84990>>>>>>>        Boolean bOK bShowProgress
84990>>>>>>>        tSQLConnection SQLConnection
84990>>>>>>>        tSQLConnection SQLConnection
84990>>>>>>>
84990>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84991>>>>>>>        If (bOK = False) Begin
84993>>>>>>>            Procedure_Return
84994>>>>>>>        End
84994>>>>>>>>
84994>>>>>>>
84994>>>>>>>        If (num_arguments > 2) Begin
84996>>>>>>>            Move bShowProgr to bShowProgress
84997>>>>>>>        End
84997>>>>>>>>
84997>>>>>>>
84997>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84998>>>>>>>        Get phoSQLManager to hoSqlHandler
84999>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85000>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85001>>>>>>>
85001>>>>>>>        If (hoSQLConnect <> 0) Begin
85003>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85004>>>>>>>            If (hoStmt <> 0) Begin
85006>>>>>>>                // record starting date/time stamp
85006>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85007>>>>>>>                // turn on error handling if enabled
85007>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85009>>>>>>>                    Set pbSqlError to False
85010>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85011>>>>>>>                    Move Error_Object_Id to hoError
85012>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85014>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85015>>>>>>>                    End
85015>>>>>>>>
85015>>>>>>>                    Else Begin
85016>>>>>>>                        Move Self to Error_Object_Id
85017>>>>>>>                    End
85017>>>>>>>>
85017>>>>>>>                End
85017>>>>>>>>
85017>>>>>>>
85017>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85017>>>>>>>                Set psSQLStatementString to sStmt
85018>>>>>>>                Send Cursor_Wait of Cursor_Control
85019>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85020>>>>>>>                Send Cursor_Ready of Cursor_Control
85021>>>>>>>
85021>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85023>>>>>>>                    Move hoError to Error_Object_Id
85024>>>>>>>                End
85024>>>>>>>>
85024>>>>>>>
85024>>>>>>>                Move 0 to iMsgs
85025>>>>>>>                Move Err to iErr
85026>>>>>>>                Move LastErr to iLastErr
85027>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85028>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85029>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85030>>>>>>>                Send _SqlColumnInfo hoStmt
85031>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85032>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85033>>>>>>>                Repeat
85033>>>>>>>>
85033>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85034>>>>>>>                    If (iFetchResult <> 0) Begin
85036>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85037>>>>>>>                    End
85037>>>>>>>>
85037>>>>>>>                Until (iFetchResult = 0)
85039>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85040>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85041>>>>>>>                Move iErr to Err
85042>>>>>>>                Move iLastErr to LastErr
85043>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85044>>>>>>>
85044>>>>>>>                Set piRows    to iRows
85045>>>>>>>                Set piRowType to iRowType
85046>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85047>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85048>>>>>>>
85048>>>>>>>                If (iMsgs <> 0) Begin
85050>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85052>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85053>>>>>>>                    End
85053>>>>>>>>
85053>>>>>>>                    For i from 1 to iMsgs
85059>>>>>>>>
85059>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85060>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85061>>>>>>>                        If (bShowProgress = True) Begin
85063>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85065>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85066>>>>>>>                            End
85066>>>>>>>>
85066>>>>>>>                            Else Begin
85067>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85069>>>>>>>                            End
85069>>>>>>>>
85069>>>>>>>                        End
85069>>>>>>>>
85069>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85070>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85071>>>>>>>                    Loop
85072>>>>>>>>
85072>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85074>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85075>>>>>>>                    End
85075>>>>>>>>
85075>>>>>>>                    Set paQueryMessages to sMsg
85076>>>>>>>                End
85076>>>>>>>>
85076>>>>>>>                Else Begin
85077>>>>>>>                    If (bShowProgress = True) Begin
85079>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85080>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85082>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85083>>>>>>>                            Decrement iMsgs
85084>>>>>>>                            For i from 0 to iMsgs
85090>>>>>>>>
85090>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85093>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85096>>>>>>>                            Loop
85097>>>>>>>>
85097>>>>>>>                        End
85097>>>>>>>>
85097>>>>>>>                    End
85097>>>>>>>>
85097>>>>>>>                End
85097>>>>>>>>
85097>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85098>>>>>>>            End
85098>>>>>>>>
85098>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85099>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85100>>>>>>>            Set ptsQueryExec to tsQuery
85101>>>>>>>            Set ptsFetchResults to tsFetch
85102>>>>>>>            Send SqlClose of hoStmt
85103>>>>>>>        End
85103>>>>>>>>
85103>>>>>>>
85103>>>>>>>        Send SqlDisconnect of hoSQLConnect
85104>>>>>>>    End_Procedure
85105>>>>>>>
85105>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85105>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85105>>>>>>>    // Returns False if no error occured.
85105>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85107>>>>>>>        Boolean bOK bShowProgress
85107>>>>>>>        tSQLScriptArray SQLScriptArray
85107>>>>>>>        tSQLScriptArray SQLScriptArray
85107>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85107>>>>>>>        TimeSpan tsTotalTime
85107>>>>>>>
85107>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85108>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85109>>>>>>>        If (SQLScriptArray.bError = True) Begin
85111>>>>>>>            Function_Return False
85112>>>>>>>        End
85112>>>>>>>>
85112>>>>>>>
85112>>>>>>>        If (num_arguments > 3) Begin
85114>>>>>>>            Move bShowProgr to bShowProgress
85115>>>>>>>        End
85115>>>>>>>>
85115>>>>>>>
85115>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85116>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85117>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85118>>>>>>>
85118>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85119>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85120>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85121>>>>>>>
85121>>>>>>>        Function_Return bOK
85122>>>>>>>    End_Function
85123>>>>>>>
85123>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85123>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85125>>>>>>>        Function_Return False
85126>>>>>>>    End_Function
85127>>>>>>>
85127>>>>>>>    // Does three things with auxilirary files;
85127>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85127>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85127>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85127>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85129>>>>>>>        String sDataPath sDDSrcPath sDriverID
85129>>>>>>>        Boolean bOK bExists
85129>>>>>>>        Integer iCount iCh iPos
85129>>>>>>>
85129>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85129>>>>>>>        If (sTableName contains ".") Begin
85131>>>>>>>            Move (Pos(".", sTableName)) to iPos
85132>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85133>>>>>>>        End
85133>>>>>>>>
85133>>>>>>>
85133>>>>>>>        Get psDriverID to sDriverID
85134>>>>>>>        Get psDataPathFirstPart to sDataPath
85135>>>>>>>        Get vFolderExists sDataPath to bOK
85136>>>>>>>        If (bOK = False) Begin
85138>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85139>>>>>>>>
85139>>>>>>>            Function_Return False
85140>>>>>>>        End
85140>>>>>>>>
85140>>>>>>>
85140>>>>>>>        // First delete the cache file:
85140>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85141>>>>>>>
85141>>>>>>>        Get Seq_New_Channel to iCh
85142>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85144>>>>>>>            Function_Return False
85145>>>>>>>        End
85145>>>>>>>>
85145>>>>>>>
85145>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85146>>>>>>>        If (bExists = False) Begin
85148>>>>>>>            Function_Return False
85149>>>>>>>        End
85149>>>>>>>>
85149>>>>>>>
85149>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85150>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85150>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85151>>>>>>>
85151>>>>>>>        // If in development environment; output new .fd file:
85151>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85152>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85153>>>>>>>        If (iCount > 1) Begin
85155>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85156>>>>>>>        End
85156>>>>>>>>
85156>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85157>>>>>>>        If (bExists = True) Begin
85159>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85160>>>>>>>            Move False to Err
85161>>>>>>>            Get AutoConnectionIDLogin to bOK
85162>>>>>>>            If (hTable <> 0) Begin
85164>>>>>>>                Open hTable
85166>>>>>>>            End
85166>>>>>>>>
85166>>>>>>>            Else Begin
85167>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85168>>>>>>>            End
85168>>>>>>>>
85168>>>>>>>
85168>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85171>>>>>>>            If (bOK = True) Begin
85173>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85175>>>>>>>            End
85175>>>>>>>>
85175>>>>>>>            If (Err = True) Begin
85177>>>>>>>                Move False to bOK
85178>>>>>>>            End
85178>>>>>>>>
85178>>>>>>>        End
85178>>>>>>>>
85178>>>>>>>
85178>>>>>>>        Function_Return (bOK = True)
85179>>>>>>>    End_Function
85180>>>>>>>
85180>>>>>>>    // Message for changing .int files to use connection ID's
85180>>>>>>>    //
85180>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85180>>>>>>>    // OR changes an existing connection id to a new id.
85180>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85180>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85180>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85182>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85182>>>>>>>        String[] sFilesData
85183>>>>>>>        Boolean bOK bCancel
85183>>>>>>>        Integer iSize iCount
85183>>>>>>>
85183>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85184>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85185>>>>>>>        If (iSize = 0) Begin
85187>>>>>>>            If (ghoStatusPanel <> 0) Begin
85189>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85191>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85192>>>>>>>                End
85192>>>>>>>>
85192>>>>>>>            End
85192>>>>>>>>
85192>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85193>>>>>>>            Procedure_Return
85194>>>>>>>        End
85194>>>>>>>>
85194>>>>>>>
85194>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85195>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85196>>>>>>>        Decrement iSize
85197>>>>>>>        For iCount from 0 to iSize
85203>>>>>>>>
85203>>>>>>>            Move sFilesData[iCount] to sFileName
85204>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85204>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85205>>>>>>>            If (ghoStatusPanel <> 0) Begin
85207>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85209>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85210>>>>>>>                    If (bCancel = True) Begin
85212>>>>>>>                        Send Deactivate of ghoStatusPanel
85213>>>>>>>                        Procedure_Return
85214>>>>>>>                    End
85214>>>>>>>>
85214>>>>>>>                End
85214>>>>>>>>
85214>>>>>>>            End
85214>>>>>>>>
85214>>>>>>>        Loop
85215>>>>>>>>
85215>>>>>>>
85215>>>>>>>        Get psDriverID to sDriverID
85216>>>>>>>
85216>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85216>>>>>>>        Move "" to sFileName
85217>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85219>>>>>>>            Move "MSSQLDrv.int" to sFileName
85220>>>>>>>        End
85220>>>>>>>>
85220>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85222>>>>>>>            Move "DB2_Drv.int" to sFileName
85223>>>>>>>        End
85223>>>>>>>>
85223>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85225>>>>>>>            Move "ODBC_Drv.int" to sFileName
85226>>>>>>>        End
85226>>>>>>>>
85226>>>>>>>        If (sFileName <> "") Begin
85228>>>>>>>            Move "" to sDriverFile
85229>>>>>>>            Get_File_Path sFileName to sDriverFile
85230>>>>>>>            If (sDriverFile <> "") Begin
85232>>>>>>>                Get psConnectionString to sConnectionString
85233>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85234>>>>>>>            End
85234>>>>>>>>
85234>>>>>>>        End
85234>>>>>>>>
85234>>>>>>>    End_Procedure
85235>>>>>>>
85235>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85235>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85237>>>>>>>        String[] sDatabaseArray
85238>>>>>>>        String sVal sServer sDriverID
85238>>>>>>>        Integer iCount iSize iPos
85238>>>>>>>        Boolean bExists
85238>>>>>>>        tSQLConnection SQLConnection
85238>>>>>>>        tSQLConnection SQLConnection
85238>>>>>>>
85238>>>>>>>        Move False to bExists
85239>>>>>>>        Get psDriverID to sDriverID
85240>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85240>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85242>>>>>>>            Function_Return bExists
85243>>>>>>>        End
85243>>>>>>>>
85243>>>>>>>
85243>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85244>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85246>>>>>>>            Function_Return False
85247>>>>>>>        End
85247>>>>>>>>
85247>>>>>>>
85247>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85248>>>>>>>        Move SQLConnection.sServer to sServer
85249>>>>>>>
85249>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85249>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85251>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85252>>>>>>>        End
85252>>>>>>>>
85252>>>>>>>        Else If (sServer contains "/") Begin
85255>>>>>>>            Move (Pos("/", sServer)) to iPos
85256>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85257>>>>>>>        End
85257>>>>>>>>
85257>>>>>>>
85257>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85258>>>>>>>        Decrement iSize
85259>>>>>>>        For iCount from 0 to iSize
85265>>>>>>>>
85265>>>>>>>            Move sDatabaseArray[iCount] to sVal
85266>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85268>>>>>>>                Move True to bExists
85269>>>>>>>                If (bExists = True) Begin
85271>>>>>>>                    Move iSize to iCount // We're done.
85272>>>>>>>                End
85272>>>>>>>>
85272>>>>>>>            End
85272>>>>>>>>
85272>>>>>>>        Loop
85273>>>>>>>>
85273>>>>>>>
85273>>>>>>>        Function_Return bExists
85274>>>>>>>    End_Function
85275>>>>>>>
85275>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85275>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85277>>>>>>>        String sDatabase sSchema sTableName sVal
85277>>>>>>>        Boolean bExists
85277>>>>>>>        String[] sTablesArray
85278>>>>>>>        Integer iSize iCount
85278>>>>>>>
85278>>>>>>>        Move False to bExists
85279>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85280>>>>>>>        Get psDatabase to sDatabase
85281>>>>>>>        Get psSchema   to sSchema
85282>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85283>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85284>>>>>>>        Decrement iSize
85285>>>>>>>        For iCount from 0 to iSize
85291>>>>>>>>
85291>>>>>>>            Move sTablesArray[iCount] to sVal
85292>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85294>>>>>>>                Move True to bExists
85295>>>>>>>                Move iSize to iCount // We're done!
85296>>>>>>>            End
85296>>>>>>>>
85296>>>>>>>        Loop
85297>>>>>>>>
85297>>>>>>>
85297>>>>>>>        Function_Return bExists
85298>>>>>>>    End_Function
85299>>>>>>>
85299>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85301>>>>>>>        String sVal sTableSpelledCorrectly
85301>>>>>>>        Boolean bExists
85301>>>>>>>        String[] sTablesArray
85302>>>>>>>        Integer iSize iCount
85302>>>>>>>
85302>>>>>>>        Move False to bExists
85303>>>>>>>        Move sTableName to sTableSpelledCorrectly
85304>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85305>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85306>>>>>>>        Decrement iSize
85307>>>>>>>        For iCount from 0 to iSize
85313>>>>>>>>
85313>>>>>>>            Move sTablesArray[iCount] to sVal
85314>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85316>>>>>>>                Move sVal to sTableSpelledCorrectly
85317>>>>>>>                Move iSize to iCount // We're done!
85318>>>>>>>            End
85318>>>>>>>>
85318>>>>>>>        Loop
85319>>>>>>>>
85319>>>>>>>
85319>>>>>>>        Function_Return sTableSpelledCorrectly
85320>>>>>>>    End_Function
85321>>>>>>>
85321>>>>>>>    // ToDo: This index name function needs to be finished...
85321>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85323>>>>>>>        String sSchema sTableName sDriverID
85323>>>>>>>        Boolean bExists
85323>>>>>>>
85323>>>>>>>        Get psDriverID to sDriverID
85324>>>>>>>        Get psSchema to sSchema
85325>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85326>>>>>>>
85326>>>>>>>        Function_Return bExists
85327>>>>>>>    End_Function
85328>>>>>>>
85328>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85328>>>>>>>    // Returns True if it does
85328>>>>>>>    // Sample:
85328>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85328>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85330>>>>>>>        Integer iNumColumns iColumn
85330>>>>>>>        String sColumn sDriverID
85330>>>>>>>        String[] sColumnsArray
85331>>>>>>>        Boolean bExists bOK
85331>>>>>>>
85331>>>>>>>        Move False to bExists
85332>>>>>>>        Get AutoConnectionIDLogin to bOK
85333>>>>>>>        Get psDriverID to sDriverID
85334>>>>>>>
85334>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85335>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85336>>>>>>>        Decrement iNumColumns
85337>>>>>>>        For iColumn from 0 to iNumColumns
85343>>>>>>>>
85343>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85344>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85346>>>>>>>                Move True to bExists
85347>>>>>>>                Move iNumColumns to iColumn // We're out of here
85348>>>>>>>            End
85348>>>>>>>>
85348>>>>>>>        Loop
85349>>>>>>>>
85349>>>>>>>
85349>>>>>>>        Function_Return bExists
85350>>>>>>>    End_Function
85351>>>>>>>
85351>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85353>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85353>>>>>>>        Boolean bOpened bOK
85353>>>>>>>        String sColumnName sNativeTypeName
85353>>>>>>>
85353>>>>>>>        Get AutoConnectionIDLogin to bOK
85354>>>>>>>        Get OpenTableExclusive hTable to bOK
85355>>>>>>>        If (bOK = False) Begin
85357>>>>>>>            Function_Return False
85358>>>>>>>        End
85358>>>>>>>>
85358>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85361>>>>>>>        If (bOpened = False) Begin
85363>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85364>>>>>>>>
85364>>>>>>>            Function_Return False
85365>>>>>>>        End
85365>>>>>>>>
85365>>>>>>>
85365>>>>>>>        Move False to Err
85366>>>>>>>
85366>>>>>>>        Structure_Start hTable
85367>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85370>>>>>>>
85370>>>>>>>            For iColumn from 1 to iNumColumns
85376>>>>>>>>
85376>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85379>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85382>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85385>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85388>>>>>>>
85388>>>>>>>                Case Begin
85388>>>>>>>                    Case (iDFType = DF_DATE)
85390>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85392>>>>>>>                            // Convert datetime to date
85392>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85395>>>>>>>                        End
85395>>>>>>>>
85395>>>>>>>                        Case Break
85396>>>>>>>                    Case (iDFType = DF_DATETIME)
85399>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85401>>>>>>>                            // Convert datetime to datetime2
85401>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85404>>>>>>>                        End
85404>>>>>>>>
85404>>>>>>>                        Case Break
85405>>>>>>>                    Case (iDFType = DF_ASCII)
85408>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85410>>>>>>>                            // Convert char to varchar
85410>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85413>>>>>>>                        End
85413>>>>>>>>
85413>>>>>>>                        Case Break
85414>>>>>>>                    Case (iDFType = DF_TEXT)
85417>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85419>>>>>>>                            // Convert text to varchar(max)
85419>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85422>>>>>>>                        End
85422>>>>>>>>
85422>>>>>>>                        Case Break
85423>>>>>>>                    Case (iDFType = DF_BINARY)
85426>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85428>>>>>>>                            // Convert image to varbinary(max)
85428>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85431>>>>>>>                        End
85431>>>>>>>>
85431>>>>>>>                        Case Break
85432>>>>>>>                Case End
85432>>>>>>>            Loop
85433>>>>>>>>
85433>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85434>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85436>>>>>>>
85436>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85437>>>>>>>        Function_Return (Err = False)
85438>>>>>>>    End_Function
85439>>>>>>>
85439>>>>>>>
85439>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85439>>>>>>>    // the DbUpdateVersion database revision in.
85439>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85439>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85439>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85441>>>>>>>        Boolean bOK bOpened
85441>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85441>>>>>>>
85441>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85444>>>>>>>        Get _TableNameOnly sTableName to sTableName
85445>>>>>>>        If (sTableName = "") Begin
85447>>>>>>>            Function_Return False
85448>>>>>>>        End
85448>>>>>>>>
85448>>>>>>>
85448>>>>>>>        // This just creates the table and a "dummy" column.
85448>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85449>>>>>>>        If (bOK = False) Begin
85451>>>>>>>            Function_Return False
85452>>>>>>>        End
85452>>>>>>>>
85452>>>>>>>
85452>>>>>>>        Close hTable
85453>>>>>>>        Move False to Err
85454>>>>>>>
85454>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85455>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85456>>>>>>>        Move "Decimal" to sDataType
85457>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85458>>>>>>>
85458>>>>>>>        // Adds the "sColumnName" passed to the function
85458>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85459>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85460>>>>>>>
85460>>>>>>>        // Now we can delete the dummy column:
85460>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85461>>>>>>>
85461>>>>>>>        // Finally, we attach to the newly created table.
85461>>>>>>>        If (Err = False) Begin
85463>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85464>>>>>>>        End
85464>>>>>>>>
85464>>>>>>>        Open hTable
85466>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85469>>>>>>>
85469>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85470>>>>>>>    End_Function
85471>>>>>>>
85471>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85471>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85471>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85471>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85471>>>>>>>    // column types.
85471>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85473>>>>>>>        Handle hDatabase
85473>>>>>>>        Integer iDriver iServers iCount
85473>>>>>>>        String sValue
85473>>>>>>>
85473>>>>>>>        If (sServer = "") Begin
85475>>>>>>>            Function_Return 0
85476>>>>>>>        End
85476>>>>>>>>
85476>>>>>>>
85476>>>>>>>        Get DriverIndex sDriverID to iDriver
85477>>>>>>>        If (iDriver = 0) Begin
85479>>>>>>>            Function_Return 0
85480>>>>>>>        End
85480>>>>>>>>
85480>>>>>>>
85480>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85483>>>>>>>        For iCount from 1 to iServers
85489>>>>>>>>
85489>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85492>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85494>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85497>>>>>>>            End
85497>>>>>>>>
85497>>>>>>>        Loop
85498>>>>>>>>
85498>>>>>>>
85498>>>>>>>        Function_Return hDatabase
85499>>>>>>>    End_Function
85500>>>>>>>
85500>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85500>>>>>>>//        String sRootName
85500>>>>>>>//        Boolean bOK
85500>>>>>>>//
85500>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85500>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85500>>>>>>>//
85500>>>>>>>//        Function_Return bOK
85500>>>>>>>//    End_Function
85500>>>>>>>
85500>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85500>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85500>>>>>>>//        Integer iDbType
85500>>>>>>>//        Boolean bOK
85500>>>>>>>//
85500>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85500>>>>>>>//        If (bOK = True) Begin
85500>>>>>>>//            Function_Return False
85500>>>>>>>//        End
85500>>>>>>>//
85500>>>>>>>//        Get psDriverID to sDriverID
85500>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85500>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85500>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85500>>>>>>>//
85500>>>>>>>//        Get psDriverID to sDriverID
85500>>>>>>>//        Get piDbType   to iDbType
85500>>>>>>>//        Get psSchema   to sSchema
85500>>>>>>>//        If (sSchema = "") Begin
85500>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85500>>>>>>>//        End
85500>>>>>>>//
85500>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85500>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85500>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85500>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85500>>>>>>>//            End
85500>>>>>>>//            Else Begin
85500>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85500>>>>>>>//            End
85500>>>>>>>//        End
85500>>>>>>>//
85500>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85500>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85500>>>>>>>//
85500>>>>>>>//        Function_Return True
85500>>>>>>>//    End_Function
85500>>>>>>>
85500>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85500>>>>>>>    // from the passed filelist.
85500>>>>>>>    // Returns the number of tables affected.
85500>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85502>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85502>>>>>>>        Integer iRetval
85502>>>>>>>        Handle hTable
85502>>>>>>>
85502>>>>>>>        // We first save the current filelist as the passed filelist name
85502>>>>>>>        // may come from another workspace, to restore it when we're ready.
85502>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85505>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85508>>>>>>>        Move 0 to hTable
85509>>>>>>>        Move 0 to iRetval
85510>>>>>>>
85510>>>>>>>        Repeat
85510>>>>>>>>
85510>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85513>>>>>>>            If (hTable <> 0) Begin
85515>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85518>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85521>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85524>>>>>>>                Move (Uppercase(sRootName)) to sVal
85525>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85527>>>>>>>                    // Prefixes:
85527>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85528>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85529>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85530>>>>>>>                    // Suffixes:
85530>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85531>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85532>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85533>>>>>>>
85533>>>>>>>                    // Change Filelist entry:
85533>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85536>>>>>>>
85536>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85537>>>>>>>                    If (sVal contains "dbo.") Begin
85539>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85540>>>>>>>
85540>>>>>>>                        // Change Filelist entry:
85540>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85543>>>>>>>                    End
85543>>>>>>>>
85543>>>>>>>                    Increment iRetval
85544>>>>>>>                End
85544>>>>>>>>
85544>>>>>>>            End
85544>>>>>>>>
85544>>>>>>>        Until (hTable = 0)
85546>>>>>>>
85546>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85549>>>>>>>
85549>>>>>>>        Function_Return iRetval
85550>>>>>>>    End_Function
85551>>>>>>>
85551>>>>>>>    // To open all Sql based tables in Filelist.cfg
85551>>>>>>>    Procedure SqlUtilOpenAllTables
85553>>>>>>>        Handle hTable
85553>>>>>>>        String sRoot sDriverID
85553>>>>>>>        Boolean bOK
85553>>>>>>>
85553>>>>>>>        Move 0 to hTable
85554>>>>>>>        Move "" to sDriverID
85555>>>>>>>        Get AutoConnectionIDLogin to bOK
85556>>>>>>>
85556>>>>>>>        Repeat
85556>>>>>>>>
85556>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85559>>>>>>>            If (hTable > 0) Begin
85561>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85564>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85566>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85569>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85571>>>>>>>                        Open hTable
85573>>>>>>>                    End
85573>>>>>>>>
85573>>>>>>>                End
85573>>>>>>>>
85573>>>>>>>            End
85573>>>>>>>>
85573>>>>>>>
85573>>>>>>>        Until (hTable = 0)
85575>>>>>>>    End_Procedure
85576>>>>>>>
85576>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85576>>>>>>>//        String sRetval sDriverID
85576>>>>>>>//        String sTableName
85576>>>>>>>//        Integer iDbType iIndex
85576>>>>>>>//        Boolean bOK
85576>>>>>>>//
85576>>>>>>>//        Get psDriverID to sDriverID
85576>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85576>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85576>>>>>>>//            Function_Return ""
85576>>>>>>>//        End
85576>>>>>>>//
85576>>>>>>>//        Move False to Err
85576>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85576>>>>>>>//        Get piDbType to iDbType
85576>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85576>>>>>>>//        If (iIndex = -1) Begin
85576>>>>>>>//            Function_Return ""
85576>>>>>>>//        End
85576>>>>>>>//
85576>>>>>>>//        Function_Return sRetval
85576>>>>>>>//    End_Function
85576>>>>>>>
85576>>>>>>>    // Checks if the passed Table;
85576>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
85576>>>>>>>    // 2) It has an .int file.
85576>>>>>>>    // If both is True it should already be connected to SQL
85576>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85578>>>>>>>        Boolean bExists bRootName
85578>>>>>>>        String sRootName sDataPath
85578>>>>>>>
85578>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85581>>>>>>>        Move (sRootName contains sDriverID) to bRootName
85582>>>>>>>
85582>>>>>>>        Get psDataPathFirstPart to sDataPath
85583>>>>>>>        Get vFolderExists sDataPath to bExists
85584>>>>>>>        If (bExists = False) Begin
85586>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85586>>>>>>>            Function_Return False
85587>>>>>>>        End
85587>>>>>>>>
85587>>>>>>>
85587>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85588>>>>>>>        Get _TableNameOnly sRootName to sRootName
85589>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85590>>>>>>>
85590>>>>>>>        Function_Return (bRootName = True and bExists = True)
85591>>>>>>>    End_Function
85592>>>>>>>
85592>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85594>>>>>>>        Boolean bViewTableType bOpen bOK
85594>>>>>>>        Integer iTableCount iNumTables
85594>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85594>>>>>>>        Handle hoCliHandler
85594>>>>>>>        tSQLConnection SQLConnection
85594>>>>>>>        tSQLConnection SQLConnection
85594>>>>>>>
85594>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85597>>>>>>>        If (bOpen = False) Begin
85599>>>>>>>            Get AutoConnectionIDLogin to bOK
85600>>>>>>>            Open hTable
85602>>>>>>>        End
85602>>>>>>>>
85602>>>>>>>
85602>>>>>>>        Get pSQLConnection to SQLConnection
85603>>>>>>>        Get phoCLIHandler to hoCliHandler
85604>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
85605>>>>>>>
85605>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85608>>>>>>>        Get _TableNameOnly sTableName to sTableName
85609>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85612>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85613>>>>>>>
85613>>>>>>>        For iTableCount from 1 to iNumTables
85619>>>>>>>>
85619>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85620>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85621>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85623>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
85624>>>>>>>                Move iNumTables to iTableCount // We're done.
85625>>>>>>>            End
85625>>>>>>>>
85625>>>>>>>        Loop
85626>>>>>>>>
85626>>>>>>>
85626>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
85627>>>>>>>        If (bOpen = False) Begin
85629>>>>>>>            Close hTable
85630>>>>>>>        End
85630>>>>>>>>
85630>>>>>>>
85630>>>>>>>        Function_Return bViewTableType
85631>>>>>>>    End_Function
85632>>>>>>>
85632>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85632>>>>>>>    //
85632>>>>>>>    // SQL utility function that returns a database type (string) constant
85632>>>>>>>    // corresponding to the passed iDbType.
85632>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85634>>>>>>>        String sRetval
85634>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85635>>>>>>>        Function_Return sRetval
85636>>>>>>>    End_Function
85637>>>>>>>
85637>>>>>>>    // SQL utility function that returns a database type constant (integer)
85637>>>>>>>    // corresponding to the passed sDbType string constant.
85637>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85639>>>>>>>        Integer iRetval
85639>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85640>>>>>>>        Function_Return iRetval
85641>>>>>>>    End_Function
85642>>>>>>>
85642>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85642>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85642>>>>>>>    // the SQL Connection program's grid.
85642>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85644>>>>>>>        String sRetval
85644>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85645>>>>>>>        Function_Return sRetval
85646>>>>>>>    End_Function
85647>>>>>>>
85647>>>>>>>    // Pass a driver name as a string and the function will return
85647>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85647>>>>>>>    // quite work and always returns "MS SQL Server"
85647>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85649>>>>>>>        Integer iRetval
85649>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85650>>>>>>>        Function_Return iRetval
85651>>>>>>>    End_Function
85652>>>>>>>
85652>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85652>>>>>>>    // that "fits" in the max allowed length for table names.
85652>>>>>>>    // Max number of characters allowed for table names;
85652>>>>>>>    // IBM DB2      = 128
85652>>>>>>>    // MS-SQL       = 128
85652>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85652>>>>>>>    // MySQL        = 64
85652>>>>>>>    // PostgreSQL   = 64
85652>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85654>>>>>>>        String sGUIDName
85654>>>>>>>        Integer iDbType iLength
85654>>>>>>>
85654>>>>>>>        Get piDbType to iDbType
85655>>>>>>>        Move (RandomHexUUID()) to sGUIDName
85656>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85657>>>>>>>        Move (Length(sGUIDName)) to iLength
85658>>>>>>>
85658>>>>>>>        Case Begin
85658>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85660>>>>>>>            If (iLength > 128) Begin
85662>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85663>>>>>>>            End
85663>>>>>>>>
85663>>>>>>>            Case Break
85664>>>>>>>
85664>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85667>>>>>>>            If (iLength > 128) Begin
85669>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85670>>>>>>>            End
85670>>>>>>>>
85670>>>>>>>            Case Break
85671>>>>>>>
85671>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85674>>>>>>>            If (iLength > 128) Begin
85676>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85677>>>>>>>            End
85677>>>>>>>>
85677>>>>>>>            Case Break
85678>>>>>>>
85678>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85681>>>>>>>            If (iLength > 64) Begin
85683>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85684>>>>>>>            End
85684>>>>>>>>
85684>>>>>>>            Case Break
85685>>>>>>>
85685>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85688>>>>>>>            If (iLength > 64) Begin
85690>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85691>>>>>>>            End
85691>>>>>>>>
85691>>>>>>>        Case End
85691>>>>>>>
85691>>>>>>>        Function_Return sGUIDName
85692>>>>>>>    End_Function
85693>>>>>>>
85693>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85693>>>>>>>    // Pass the memory resource file reference and the filename to be created,
85693>>>>>>>    // including full path.
85693>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85695>>>>>>>        String sText
85695>>>>>>>        Integer iCh iSize iArgSize
85695>>>>>>>
85695>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85696>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85697>>>>>>>        Get_Channel_Size iCh to iSize
85698>>>>>>>        Read_Block channel iCh sText iSize
85700>>>>>>>        Send Seq_Close_Channel iCh
85701>>>>>>>
85701>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
85702>>>>>>>            Write channel iCh sText
85704>>>>>>>        Send Seq_Close_Channel iCh
85705>>>>>>>
85705>>>>>>>        // Wait for file to be written to disk.
85705>>>>>>>        Sleep 2
85706>>>>>>>    End_Procedure
85707>>>>>>>
85707>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85709>>>>>>>        String sNotNull sRetval sDefaultValue
85709>>>>>>>        Boolean bOK
85709>>>>>>>
85709>>>>>>>        Get IsSQLDriver sDriverID to bOK
85710>>>>>>>        If (bOK = False) Begin
85712>>>>>>>            Function_Return ""
85713>>>>>>>        End
85713>>>>>>>>
85713>>>>>>>
85713>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85714>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85715>>>>>>>
85715>>>>>>>        Case Begin
85715>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85717>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85718>>>>>>>                Case Break
85719>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85722>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85723>>>>>>>                Case Break
85724>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85727>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85728>>>>>>>                Case Break
85729>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85732>>>>>>>                Move (String(sNotNull))                                     to sRetval
85733>>>>>>>                Case Break
85734>>>>>>>
85734>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85734>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
85734>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85737>>>>>>>                Move  ""                                                    to sRetval
85738>>>>>>>                Case Break
85739>>>>>>>
85739>>>>>>>            Case Else
85739>>>>>>>                Move  ""                                                    to sRetval
85740>>>>>>>        Case End
85740>>>>>>>
85740>>>>>>>        Function_Return sRetval
85741>>>>>>>    End_Function
85742>>>>>>>
85742>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85742>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
85744>>>>>>>        Function_Return False
85745>>>>>>>    End_Function
85746>>>>>>>
85746>>>>>>>    // Enumerate SQL Servers.
85746>>>>>>>    // Pass a driver id. Returns a string array.
85746>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85746>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85746>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85748>>>>>>>        String[] sReturnArray
85749>>>>>>>        Handle hoSQLHandler
85749>>>>>>>        String sServer
85749>>>>>>>        Integer iCount iNumItems iDataSourceType
85749>>>>>>>
85749>>>>>>>        If (num_arguments > 1) Begin
85751>>>>>>>            Move iDatSrcType to iDataSourceType
85752>>>>>>>        End
85752>>>>>>>>
85752>>>>>>>
85752>>>>>>>        Case Begin
85752>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85754>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
85755>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
85756>>>>>>>                For iCount from 0 to (iNumItems - 1)
85762>>>>>>>>
85762>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
85763>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85764>>>>>>>                Loop
85765>>>>>>>>
85765>>>>>>>                Case Break
85766>>>>>>>
85766>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85769>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
85770>>>>>>>                Send SeedDataSources of hoSQLHandler
85771>>>>>>>                Move 0 to iCount
85772>>>>>>>                Repeat
85772>>>>>>>>
85772>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85773>>>>>>>                    If (sServer <> "") Begin
85775>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
85776>>>>>>>                        Move sServer to sReturnArray[iCount]
85777>>>>>>>                    End
85777>>>>>>>>
85777>>>>>>>                    Increment iCount
85778>>>>>>>                Until (sServer = "")
85780>>>>>>>                Case Break
85781>>>>>>>
85781>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85784>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
85785>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85786>>>>>>>                Move 0 to iCount
85787>>>>>>>                Repeat
85787>>>>>>>>
85787>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85788>>>>>>>                    If (sServer <> "") Begin
85790>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
85791>>>>>>>                        Move sServer to sReturnArray[iCount]
85792>>>>>>>                    End
85792>>>>>>>>
85792>>>>>>>                    Increment iCount
85793>>>>>>>                Until (sServer = "")
85795>>>>>>>                Case Break
85796>>>>>>>
85796>>>>>>>            Case Else
85796>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85797>>>>>>>>
85797>>>>>>>        Case End
85797>>>>>>>
85797>>>>>>>        Function_Return sReturnArray
85798>>>>>>>    End_Function
85799>>>>>>>
85799>>>>>>>    // Returns all databases as a string array for the passed driver id.
85799>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85801>>>>>>>        String[] sReturnArray
85802>>>>>>>        String sServer sVal
85802>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85802>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
85803>>>>>>>        tSQLConnection SQLConnection
85803>>>>>>>        tSQLConnection SQLConnection
85803>>>>>>>        Boolean bOK
85803>>>>>>>        Integer iCount iSize
85803>>>>>>>
85803>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85804>>>>>>>        If (bOK = False) Begin
85806>>>>>>>            Function_Return sReturnArray
85807>>>>>>>        End
85807>>>>>>>>
85807>>>>>>>
85807>>>>>>>        Case Begin
85807>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85809>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85810>>>>>>>                Case Break
85811>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85814>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85815>>>>>>>                Case Break
85816>>>>>>>
85816>>>>>>>            // This is needed to be able to check if a database exists or not.
85816>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85819>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
85820>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
85822>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
85824>>>>>>>                        // If a FILEDSN: (can only be one database name)
85824>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
85825>>>>>>>                    End
85825>>>>>>>>
85825>>>>>>>                    Else Begin
85826>>>>>>>                        // Else the DSN's were read from the registry.
85826>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85827>>>>>>>                        Move SQLConnection.sServer to sServer
85828>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
85829>>>>>>>                        Decrement iSize
85830>>>>>>>                        for iCount from 0 to iSize
85836>>>>>>>>
85836>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
85837>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
85839>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
85840>>>>>>>                                Move iSize to iCount // We're done.
85841>>>>>>>                            End
85841>>>>>>>>
85841>>>>>>>                        Loop
85842>>>>>>>>
85842>>>>>>>                    End
85842>>>>>>>>
85842>>>>>>>                End
85842>>>>>>>>
85842>>>>>>>                Case Break
85843>>>>>>>
85843>>>>>>>            Case Else
85843>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85843>>>>>>>        Case End
85843>>>>>>>
85843>>>>>>>        Function_Return sReturnArray
85844>>>>>>>    End_Function
85845>>>>>>>
85845>>>>>>>    
85845>>>>>>>    // *** Database API Functions: ***
85845>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85845>>>>>>>    // make changes/updates to the database.
85845>>>>>>>
85845>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85845>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85847>>>>>>>        Function_Return False
85848>>>>>>>    End_Function
85849>>>>>>>
85849>>>>>>>    // This might not do what you think - Here's what it does:
85849>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85849>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85849>>>>>>>    // to the SQL table.
85849>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85849>>>>>>>    // already exists in SQL.
85849>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85849>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85849>>>>>>>    // restructuring an existing table.
85849>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85851>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
85851>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85851>>>>>>>        Handle hToTable
85851>>>>>>>
85851>>>>>>>        Move True to bUseConnectionID
85852>>>>>>>        If (num_arguments > 1) Begin
85854>>>>>>>            Move bUseConnID to bUseConnectionID
85855>>>>>>>        End
85855>>>>>>>>
85855>>>>>>>
85855>>>>>>>        Get psDriverID to sDriverID
85856>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85856>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85857>>>>>>>        If (bExists = False) Begin
85859>>>>>>>            Function_Return False
85860>>>>>>>        End
85860>>>>>>>>
85860>>>>>>>
85860>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
85861>>>>>>>
85861>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85862>>>>>>>        If (bOK = False) Begin
85864>>>>>>>            Function_Return False
85865>>>>>>>        End
85865>>>>>>>>
85865>>>>>>>
85865>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
85865>>>>>>>        // we do nothing
85865>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85866>>>>>>>        If (bExists = True) Begin
85868>>>>>>>            Function_Return False
85869>>>>>>>        End
85869>>>>>>>>
85869>>>>>>>
85869>>>>>>>        Get psConnectionID     to sConnectionID
85870>>>>>>>        Get psConnectionString to sConnectionString
85871>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85873>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85874>>>>>>>>
85874>>>>>>>            Function_Return False
85875>>>>>>>        End
85875>>>>>>>>
85875>>>>>>>
85875>>>>>>>        Set Private.phCurrentTable to hTable
85876>>>>>>>        Get psSchema to sSchema
85877>>>>>>>        If (sSchema = "") Begin
85879>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85880>>>>>>>        End
85880>>>>>>>>
85880>>>>>>>
85880>>>>>>>        // If we should use a connection id we need to check it exists;
85880>>>>>>>        // else we create it before attempting creating the table
85880>>>>>>>        If (bUseConnectionID = True) Begin
85882>>>>>>>            Get AutoConnectionIDLogin to bOK
85883>>>>>>>            If (bOk = False) Begin
85885>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85886>>>>>>>>
85886>>>>>>>                Function_Return False
85887>>>>>>>            End
85887>>>>>>>>
85887>>>>>>>        End
85887>>>>>>>>
85887>>>>>>>
85887>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85890>>>>>>>        Get _TableNameOnly sRootName to sRootName
85891>>>>>>>        If (sRootName = "") Begin
85893>>>>>>>            Function_Return False
85894>>>>>>>        End
85894>>>>>>>>
85894>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
85895>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85898>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85901>>>>>>>
85901>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
85901>>>>>>>        //
85901>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
85901>>>>>>>        // because then the table should not be visible to users.
85901>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
85901>>>>>>>//        If (iPos <> 1) Begin
85901>>>>>>>//            If (sDisplayName contains ".") Begin
85901>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
85901>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
85901>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
85901>>>>>>>//            End
85901>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
85901>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85901>>>>>>>//            End
85901>>>>>>>//        End
85901>>>>>>>
85901>>>>>>>        If (bIsAlias = False) Begin
85903>>>>>>>            Get OpenTableExclusive hTable to bOpened
85904>>>>>>>            If (bOpened = False) Begin
85906>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
85907>>>>>>>>
85907>>>>>>>                Function_Return False
85908>>>>>>>            End
85908>>>>>>>>
85908>>>>>>>        End
85908>>>>>>>>
85908>>>>>>>
85908>>>>>>>        If (ghoProgressBar <> 0) Begin
85910>>>>>>>            Send DoAdvance of ghoProgressBar
85911>>>>>>>            Set Message_Text of ghoStatusPanel to ""
85912>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
85913>>>>>>>        End
85913>>>>>>>>
85913>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
85913>>>>>>>        Move hTable to hToTable
85914>>>>>>>        Move False to Err
85915>>>>>>>
85915>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
85915>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
85915>>>>>>>        // a proper and updated .int file.
85915>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
85918>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
85919>>>>>>>
85919>>>>>>>        If (bIsAlias = False) Begin
85921>>>>>>>            Structure_Start hToTable sDriverID
85922>>>>>>>                Set Private.phCurrentTable to hTable
85923>>>>>>>                If (bUseConnectionID = True) Begin
85925>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85928>>>>>>>                End
85928>>>>>>>>
85928>>>>>>>                Else Begin
85929>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
85932>>>>>>>                End
85932>>>>>>>>
85932>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
85935>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
85935>>>>>>>                Move False to Err
85936>>>>>>>                Move 0 to LastErr
85937>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85938>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85940>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85941>>>>>>>        End
85941>>>>>>>>
85941>>>>>>>
85941>>>>>>>        Move (not(Err)) to bOK
85942>>>>>>>        If (bOK = True) Begin
85944>>>>>>>            // The attributes set above will always trigger an error
85944>>>>>>>            // We also adjust the Filelist entries
85944>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
85947>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85950>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85953>>>>>>>
85953>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
85953>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
85954>>>>>>>        End
85954>>>>>>>>
85954>>>>>>>
85954>>>>>>>        Function_Return (bOK = True)
85955>>>>>>>    End_Function
85956>>>>>>>
85956>>>>>>>    // Sample usage:
85956>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
85956>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
85956>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
85958>>>>>>>        Boolean bOK bIsSQLTable
85958>>>>>>>
85958>>>>>>>        Get AutoConnectionIDLogin to bOK
85959>>>>>>>        Move False to Err
85960>>>>>>>        Get OpenTableExclusive hTable to bOK
85961>>>>>>>        If (bOK = False) Begin
85963>>>>>>>            Function_Return False
85964>>>>>>>        End
85964>>>>>>>>
85964>>>>>>>
85964>>>>>>>        // ToDo: Add to all table change functions!
85964>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
85965>>>>>>>            If (bIsSQLTable = True) Begin
85967>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85970>>>>>>>            End
85970>>>>>>>>
85970>>>>>>>
85970>>>>>>>        Set Private.phCurrentTable to hTable
85971>>>>>>>        Structure_Start hTable
85972>>>>>>>            Set_Attribute iAttribute of hTable to iValue
85975>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85976>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85978>>>>>>>
85978>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85979>>>>>>>        Function_Return (Err = False)
85980>>>>>>>    End_Function
85981>>>>>>>
85981>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
85983>>>>>>>        Boolean bOK
85983>>>>>>>        
85983>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
85984>>>>>>>        If (bOK = True) Begin
85986>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
85987>>>>>>>        End
85987>>>>>>>>
85987>>>>>>>        
85987>>>>>>>        Function_Return (bOK = True)
85988>>>>>>>    End_Function
85989>>>>>>>    
85989>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
85989>>>>>>>    // or to change the filelist slot names.
85989>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
85991>>>>>>>        String sFileListName
85991>>>>>>>        
85991>>>>>>>        Move False to Err
85992>>>>>>>
85992>>>>>>>        If (ghoProgressBar <> 0) Begin
85994>>>>>>>            Send DoAdvance of ghoProgressBar
85995>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
85996>>>>>>>        End
85996>>>>>>>>
85996>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
85996>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
85998>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86001>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86004>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86007>>>>>>>            Function_Return (Err = False) // And we're done.
86008>>>>>>>        End
86008>>>>>>>>
86008>>>>>>>
86008>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86010>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86010>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86011>>>>>>>        End
86011>>>>>>>>
86011>>>>>>>//        Else Begin
86011>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86011>>>>>>>//        End
86011>>>>>>>//
86011>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86011>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86011>>>>>>>
86011>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86014>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86017>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86020>>>>>>>        
86020>>>>>>>        Function_Return (Err = False)
86021>>>>>>>    End_Function
86022>>>>>>>
86022>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86024>>>>>>>        Boolean bOK
86024>>>>>>>
86024>>>>>>>        Get AutoConnectionIDLogin to bOK
86025>>>>>>>        Move False to Err
86026>>>>>>>        Get OpenTableExclusive hTable to bOK
86027>>>>>>>        If (bOK = False) Begin
86029>>>>>>>            Function_Return False
86030>>>>>>>        End
86030>>>>>>>>
86030>>>>>>>
86030>>>>>>>        Set Private.phCurrentTable to hTable
86031>>>>>>>        Structure_Start hTable
86032>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86035>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86036>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86038>>>>>>>
86038>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86039>>>>>>>        Function_Return (Err = False)
86040>>>>>>>    End_Function
86041>>>>>>>
86041>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86043>>>>>>>        Boolean bOK bIsSQLTable
86043>>>>>>>
86043>>>>>>>        Move False to Err
86044>>>>>>>        Get AutoConnectionIDLogin to bOK
86045>>>>>>>        Open hToTable
86047>>>>>>>        Get OpenTableExclusive hTable to bOK
86048>>>>>>>        If (bOK = False) Begin
86050>>>>>>>            Function_Return False
86051>>>>>>>        End
86051>>>>>>>>
86051>>>>>>>
86051>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86052>>>>>>>            If (bIsSQLTable = True) Begin
86054>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86057>>>>>>>            End
86057>>>>>>>>
86057>>>>>>>
86057>>>>>>>        Set Private.phCurrentTable to hTable
86058>>>>>>>        Structure_Start hTable
86059>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86062>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86065>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86066>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86068>>>>>>>
86068>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86069>>>>>>>        Function_Return (Err = False)
86070>>>>>>>    End_Function
86071>>>>>>>
86071>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86073>>>>>>>        Integer[] aTableConvertExceptions
86074>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86075>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86076>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86077>>>>>>>    End_Procedure
86078>>>>>>>
86078>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86080>>>>>>>        Integer[] aTableDateCorrectionExceptions
86081>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86082>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86083>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86084>>>>>>>    End_Procedure
86085>>>>>>>
86085>>>>>>>    Procedure ApiTableConvertALLToSql
86087>>>>>>>        Integer[] iTablesArray
86088>>>>>>>        Integer iSize iCount
86088>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86088>>>>>>>        String sDriverID
86088>>>>>>>
86088>>>>>>>        Get psDriverID to sDriverID
86089>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86090>>>>>>>        Get pbToANSI          to bToANSI
86091>>>>>>>        Get pbRecnum          to bRecnum
86092>>>>>>>        Get pbCopyData        to bCopyData
86093>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86095>>>>>>>            Get pbContinueOnError to bContinueOnError
86096>>>>>>>        End
86096>>>>>>>>
86096>>>>>>>
86096>>>>>>>        Get _AllTablesToConvert to iTablesArray
86097>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86098>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86099>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86100>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86101>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86102>>>>>>>
86102>>>>>>>        Decrement iSize
86103>>>>>>>        For iCount from 0 to iSize
86109>>>>>>>>
86109>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86110>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86111>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86111>>>>>>>            // if there was an error converting one table...
86111>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86111>>>>>>>        Loop
86112>>>>>>>>
86112>>>>>>>
86112>>>>>>>    End_Procedure
86113>>>>>>>
86113>>>>>>>    Procedure ApiTableAttachALLToSql
86115>>>>>>>        Integer[] iTablesArray
86116>>>>>>>        Integer iSize iCount
86116>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86116>>>>>>>        String sDriverID
86116>>>>>>>
86116>>>>>>>        Get psDriverID to sDriverID
86117>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86118>>>>>>>        Get pbToANSI          to bToANSI
86119>>>>>>>        Get pbRecnum          to bRecnum
86120>>>>>>>        Get pbCopyData        to bCopyData
86121>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86123>>>>>>>            Get pbContinueOnError to bContinueOnError
86124>>>>>>>        End
86124>>>>>>>>
86124>>>>>>>
86124>>>>>>>        Get _AllTablesToConvert to iTablesArray
86125>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86126>>>>>>>        Decrement iSize
86127>>>>>>>        For iCount from 0 to iSize
86133>>>>>>>>
86133>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86134>>>>>>>        Loop
86135>>>>>>>>
86135>>>>>>>
86135>>>>>>>    End_Procedure
86136>>>>>>>
86136>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86138>>>>>>>        Handle hToTable hoLogFile
86138>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86138>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86138>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86138>>>>>>>        tSQLConnection SQLConnection
86138>>>>>>>        tSQLConnection SQLConnection
86138>>>>>>>
86138>>>>>>>        Get _UtilTableExists hTable to bExists
86139>>>>>>>        If (bExists = False) Begin
86141>>>>>>>            Set Private.phCurrentTable to hTable
86142>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86143>>>>>>>>
86143>>>>>>>            Function_Return False
86144>>>>>>>        End
86144>>>>>>>>
86144>>>>>>>
86144>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86145>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86145>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86145>>>>>>>        If (bIsAlias = True) Begin
86147>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86150>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86152>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86155>>>>>>>                Get psConnectionID to sConnectionID
86156>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86157>>>>>>>            End
86157>>>>>>>>
86157>>>>>>>            Function_Return True
86158>>>>>>>        End
86158>>>>>>>>
86158>>>>>>>
86158>>>>>>>        Set Private.phCurrentTable to hTable
86159>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86162>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86165>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86168>>>>>>>
86168>>>>>>>        If (ghoProgressBar <> 0) Begin
86170>>>>>>>            Send DoAdvance of ghoProgressBar
86171>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86172>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86173>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86174>>>>>>>        End
86174>>>>>>>>
86174>>>>>>>
86174>>>>>>>        // Marco Kuipers suggestion;
86174>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86174>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86174>>>>>>>        // SQL table.
86174>>>>>>>        Get _UtilTableIsSql hTable to bOK
86175>>>>>>>        If (bOK = False) Begin
86177>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86178>>>>>>>            If (bExists = True) Begin
86180>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86180>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86180>>>>>>>                Get phoLogFile to hoLogFile
86181>>>>>>>                If (hoLogFile <> 0) Begin          
86183>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86184>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86184>>>>>>>                    Send LogError sWarning False
86185>>>>>>>                End
86185>>>>>>>>
86185>>>>>>>                Else Begin
86186>>>>>>>                    Error DFERR_PROGRAM sWarning
86187>>>>>>>>
86187>>>>>>>                End                                                       
86187>>>>>>>>
86187>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86188>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86189>>>>>>>            End
86189>>>>>>>>
86189>>>>>>>        End
86189>>>>>>>>
86189>>>>>>>
86189>>>>>>>        // Does the rootname contain a driver?
86189>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86191>>>>>>>            // Does the table already exist as an SQL table?
86191>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86192>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86192>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86192>>>>>>>            If (bExists = False) Begin
86194>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86195>>>>>>>            End
86195>>>>>>>>
86195>>>>>>>            If (bExists = True) Begin
86197>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86198>>>>>>>                Function_Return False
86199>>>>>>>            End
86199>>>>>>>>
86199>>>>>>>        End
86199>>>>>>>>
86199>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86200>>>>>>>
86200>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86201>>>>>>>        If (bUseConnectionID = True) Begin
86203>>>>>>>            Move False to bUseConnectionID
86204>>>>>>>        End
86204>>>>>>>>
86204>>>>>>>
86204>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86205>>>>>>>        Move SQLConnection.sSchema           to sSchema
86206>>>>>>>        If (sSchema = "") Begin
86208>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86209>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86210>>>>>>>        End
86210>>>>>>>>
86210>>>>>>>
86210>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86211>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86212>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86213>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86215>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86216>>>>>>>>
86216>>>>>>>            Function_Return False
86217>>>>>>>        End
86217>>>>>>>>
86217>>>>>>>
86217>>>>>>>        Get AutoConnectionIDLogin to bOK
86218>>>>>>>        Open hTable
86220>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86223>>>>>>>        If (bOpened = False) Begin
86225>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86226>>>>>>>>
86226>>>>>>>            Function_Return False
86227>>>>>>>        End
86227>>>>>>>>
86227>>>>>>>
86227>>>>>>>        If (ghoProgressBar <> 0) Begin
86229>>>>>>>            Send DoAdvance of ghoProgressBar
86230>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86231>>>>>>>        End
86231>>>>>>>>
86231>>>>>>>
86231>>>>>>>        Move 0 to hToTable
86232>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86233>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86234>>>>>>>
86234>>>>>>>        Case Begin
86234>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86236>>>>>>>                Case Break
86237>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86240>>>>>>>                Case Break
86241>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86244>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86245>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86246>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86247>>>>>>>                Case Break
86248>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86251>>>>>>>                Case Break
86252>>>>>>>            Case Else
86252>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86253>>>>>>>>
86253>>>>>>>                Case Break
86254>>>>>>>        Case End
86254>>>>>>>
86254>>>>>>>        Move False to Err
86255>>>>>>>
86255>>>>>>>        Structure_Start hToTable sDriverID
86256>>>>>>>            Structure_Copy hTable to hToTable
86257>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86260>>>>>>>
86260>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86262>>>>>>>                If (bUseConnectionID = True) Begin
86264>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86267>>>>>>>                End
86267>>>>>>>>
86267>>>>>>>                Else Begin
86268>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86271>>>>>>>                End
86271>>>>>>>>
86271>>>>>>>
86271>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86274>>>>>>>
86274>>>>>>>                If (sSchema <> "") Begin
86276>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86279>>>>>>>                End
86279>>>>>>>>
86279>>>>>>>
86279>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86281>>>>>>>                    If (sLongTableSpace <> "") Begin
86283>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86286>>>>>>>                    End
86286>>>>>>>>
86286>>>>>>>                    If (sBaseTableSpace <> "") Begin
86288>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86291>>>>>>>                    End
86291>>>>>>>>
86291>>>>>>>                    If (sIndexTableSpace <> "") Begin
86293>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86296>>>>>>>                    End
86296>>>>>>>>
86296>>>>>>>                End
86296>>>>>>>>
86296>>>>>>>            End
86296>>>>>>>>
86296>>>>>>>
86296>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86297>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86299>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86300>>>>>>>
86300>>>>>>>        Move (not(Err)) to bOK
86301>>>>>>>
86301>>>>>>>        If (bOK = True and bCopyData = True) Begin
86303>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86304>>>>>>>
86304>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86306>>>>>>>                Get pbContinueOnError to bContinueOnError
86307>>>>>>>            End
86307>>>>>>>>
86307>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86307>>>>>>>            // rename it by adding a GUID to the end of the table name
86307>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86307>>>>>>>            // different rules how long a table name can be.
86307>>>>>>>            // The new table will probably contain data but something went
86307>>>>>>>            // wrong while converting the data from embedded to SQL.
86307>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86309>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86310>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86311>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86312>>>>>>>>
86312>>>>>>>            End
86312>>>>>>>>
86312>>>>>>>        End
86312>>>>>>>>
86312>>>>>>>
86312>>>>>>>        // This must be after copying data...
86312>>>>>>>        If (Err = False) Begin
86314>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86317>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86317>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86317>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86317>>>>>>>            //                // The max length for the display_name is 31 characters...
86317>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86317>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86317>>>>>>>            //                End
86317>>>>>>>            //            End
86317>>>>>>>        End
86317>>>>>>>>
86317>>>>>>>
86317>>>>>>>        Close hTable
86318>>>>>>>        Move (not(Err)) to bOK
86319>>>>>>>        Function_Return bOK
86320>>>>>>>    End_Function
86321>>>>>>>
86321>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86321>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86321>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86321>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86323>>>>>>>        Boolean bOpened bOK
86323>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86323>>>>>>>        String sErrorFile sEmpty sPath
86323>>>>>>>
86323>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86326>>>>>>>        Get AutoConnectionIDLogin to bOK
86327>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86329>>>>>>>            Send IncreaseSortBufferSize
86330>>>>>>>//            Send SetAllIndexesToBatch hToTable
86330>>>>>>>        End
86330>>>>>>>>
86330>>>>>>>
86330>>>>>>>        Move False to Err
86331>>>>>>>        Open sPhysicalName as hToTable
86333>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86336>>>>>>>        If (bOpened = False) Begin
86338>>>>>>>            Function_Return False
86339>>>>>>>        End
86339>>>>>>>>
86339>>>>>>>
86339>>>>>>>        If (ghoStatusPanel <> 0) Begin
86341>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86342>>>>>>>            Set piMinimum of ghoProgressBar to 0
86343>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86344>>>>>>>        End
86344>>>>>>>>
86344>>>>>>>
86344>>>>>>>        Move "" to sEmpty
86345>>>>>>>        Move False to Err
86346>>>>>>>        Move True to bOK
86347>>>>>>>        Set Private.phCurrentTable to hToTable
86348>>>>>>>
86348>>>>>>>        // No need to get the record identifier
86348>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86351>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86354>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86356>>>>>>>            // Remove all indices to speed up copying of data:
86356>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86361>>>>>>>            If (iRetval <> 0) Begin       
86363>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86364>>>>>>>>
86364>>>>>>>                Close hToTable
86365>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86368>>>>>>>                Function_Return False
86369>>>>>>>            End
86369>>>>>>>>
86369>>>>>>>        End
86369>>>>>>>>
86369>>>>>>>
86369>>>>>>>        Move (sRootName + ".err") to sErrorFile
86370>>>>>>>        Move 0 to iIndex
86371>>>>>>>        Move False to Err
86372>>>>>>>
86372>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86374>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86377>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86382>>>>>>>            If (iRetval <> 0) Begin
86384>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86385>>>>>>>>
86385>>>>>>>                Close hToTable
86386>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86389>>>>>>>                Function_Return False
86390>>>>>>>            End
86390>>>>>>>>
86390>>>>>>>        End
86390>>>>>>>>
86390>>>>>>>        Else Begin
86391>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86394>>>>>>>        End
86394>>>>>>>>
86394>>>>>>>
86394>>>>>>>        If (Err = False) Begin
86396>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86397>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86398>>>>>>>        End
86398>>>>>>>>
86398>>>>>>>
86398>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86400>>>>>>>            // Recreate indices:
86400>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86405>>>>>>>            If (iRetval <> 0) Begin
86407>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86408>>>>>>>>
86408>>>>>>>                Close hToTable
86409>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86412>>>>>>>                Function_Return False
86413>>>>>>>            End
86413>>>>>>>>
86413>>>>>>>        End
86413>>>>>>>>
86413>>>>>>>
86413>>>>>>>        Close hToTable
86414>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86417>>>>>>>
86417>>>>>>>        If (bOK = True) Begin
86419>>>>>>>            Move (not(Err)) to bOK
86420>>>>>>>        End
86420>>>>>>>>
86420>>>>>>>
86420>>>>>>>        If (ghoStatusPanel <> 0) Begin
86422>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86423>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86424>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86425>>>>>>>        End
86425>>>>>>>>
86425>>>>>>>
86425>>>>>>>        Function_Return (bOK = True)
86426>>>>>>>    End_Function
86427>>>>>>>
86427>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86427>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86427>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86429>>>>>>>        Handle hFile
86429>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86429>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86429>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86429>>>>>>>        tSQLConnection SQLConnection
86429>>>>>>>        tSQLConnection SQLConnection
86429>>>>>>>        tAPIColumn[] aColumns
86429>>>>>>>        tAPIColumn[] aColumns
86430>>>>>>>        tColumnType ColumnType
86430>>>>>>>        tColumnType ColumnType
86430>>>>>>>
86430>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86430>>>>>>>        Get _UtilTableExists hTable to bOk
86431>>>>>>>        If (bOk = True) Begin
86433>>>>>>>            Function_Return False
86434>>>>>>>        End
86434>>>>>>>>
86434>>>>>>>
86434>>>>>>>        Set Private.phCurrentTable to hTable
86435>>>>>>>        Move sLogicalName to sTableName
86436>>>>>>>        If (ghoProgressBar <> 0) Begin
86438>>>>>>>            Send DoAdvance of ghoProgressBar
86439>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86440>>>>>>>        End
86440>>>>>>>>
86440>>>>>>>
86440>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86441>>>>>>>        Get psDriverID to sDriverID
86442>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86443>>>>>>>        Get piDbType to iDbType
86444>>>>>>>
86444>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86444>>>>>>>        Move False to bDeleteDummy
86445>>>>>>>        If (Num_Arguments = 8) Begin
86447>>>>>>>            Move aColumnIn to aColumns
86448>>>>>>>        End
86448>>>>>>>>
86448>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86450>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86451>>>>>>>            Move ColumnType.iSQLType to iDataType
86452>>>>>>>            If (bRecnum = False) Begin
86454>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86455>>>>>>>            End
86455>>>>>>>>
86455>>>>>>>            Else Begin
86456>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86457>>>>>>>            End
86457>>>>>>>>
86457>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86458>>>>>>>            Move True to bDeleteDummy
86459>>>>>>>        End
86459>>>>>>>>
86459>>>>>>>
86459>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86459>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86459>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86459>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86459>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86461>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86462>>>>>>>            Decrement iSize
86463>>>>>>>            for iCount from 0 to iSize
86469>>>>>>>>
86469>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86471>>>>>>>                    Move False to bRecnum
86472>>>>>>>                    Move iSize to iCount
86473>>>>>>>                End
86473>>>>>>>>
86473>>>>>>>            Loop
86474>>>>>>>>
86474>>>>>>>        End
86474>>>>>>>>
86474>>>>>>>
86474>>>>>>>        // If this is a SQL based driver we also check if the table exists
86474>>>>>>>        // in the SQL back end; in case we do nothing.
86474>>>>>>>        If (bSqlDriver = True) Begin
86476>>>>>>>            // Get all connection properties
86476>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86477>>>>>>>            Move SQLConnection.sSchema to sSchema
86478>>>>>>>            If (sSchema = "") Begin
86480>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86481>>>>>>>            End
86481>>>>>>>>
86481>>>>>>>
86481>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86482>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86482>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86482>>>>>>>            If (bExists = False) Begin
86484>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86485>>>>>>>            End
86485>>>>>>>>
86485>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86485>>>>>>>            // we will just add it to Filelist.cfg
86485>>>>>>>            If (bExists = True) Begin
86487>>>>>>>                If (bExistsInFilelist = False) Begin
86489>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86491>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86492>>>>>>>                    End
86492>>>>>>>>
86492>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86495>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86498>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86501>>>>>>>                    Move False to bSysFile
86502>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86503>>>>>>>                End
86503>>>>>>>>
86503>>>>>>>                Function_Return False
86504>>>>>>>            End
86504>>>>>>>>
86504>>>>>>>        End
86504>>>>>>>>
86504>>>>>>>
86504>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86505>>>>>>>        If (num_arguments > 6) Begin
86507>>>>>>>            If (bANSI = False) Begin
86509>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86510>>>>>>>            End
86510>>>>>>>>
86510>>>>>>>        End
86510>>>>>>>>
86510>>>>>>>
86510>>>>>>>        Move False to Err
86511>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86513>>>>>>>            Move sRootName to sPhysicalFile
86514>>>>>>>        End
86514>>>>>>>>
86514>>>>>>>
86514>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86516>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86517>>>>>>>
86517>>>>>>>            // If DAW driver and we should use a connection id we need to
86517>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86517>>>>>>>            If (bUseConnectionID = True) Begin
86519>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86520>>>>>>>                If (bExists = False) Begin
86522>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86523>>>>>>>                    If (bOk = False) Begin
86525>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86526>>>>>>>>
86526>>>>>>>                        Function_Return False
86527>>>>>>>                    End
86527>>>>>>>>
86527>>>>>>>                End
86527>>>>>>>>
86527>>>>>>>            End
86527>>>>>>>>
86527>>>>>>>
86527>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86529>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86530>>>>>>>            End
86530>>>>>>>>
86530>>>>>>>            Else Begin
86531>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86532>>>>>>>            End
86532>>>>>>>>
86532>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86533>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86533>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86533>>>>>>>//            End
86533>>>>>>>        End
86533>>>>>>>>
86533>>>>>>>        Move False to Err
86534>>>>>>>        Move 0 to hFile
86535>>>>>>>
86535>>>>>>>        Structure_Start hFile sDriverID
86536>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86538>>>>>>>                If (bUseConnectionID = True) Begin
86540>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86543>>>>>>>                End
86543>>>>>>>>
86543>>>>>>>                Else Begin
86544>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86547>>>>>>>                End
86547>>>>>>>>
86547>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86550>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86553>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86556>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86559>>>>>>>
86559>>>>>>>                If (sSchema <> "") Begin
86561>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86564>>>>>>>                End
86564>>>>>>>>
86564>>>>>>>
86564>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86566>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86568>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86571>>>>>>>                    End
86571>>>>>>>>
86571>>>>>>>                End
86571>>>>>>>>
86571>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86573>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86575>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86578>>>>>>>                    End
86578>>>>>>>>
86578>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86580>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86583>>>>>>>                    End
86583>>>>>>>>
86583>>>>>>>                End
86583>>>>>>>>
86583>>>>>>>            End
86583>>>>>>>>
86583>>>>>>>
86583>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86586>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86587>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86588>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86590>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86591>>>>>>>
86591>>>>>>>        Move (not(Err)) to bOK
86592>>>>>>>        If (bOk = True) Begin
86594>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86596>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86597>>>>>>>            End
86597>>>>>>>>
86597>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86600>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86603>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86606>>>>>>>
86606>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86606>>>>>>>            If (bDeleteDummy) Begin
86608>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86609>>>>>>>            End
86609>>>>>>>>
86609>>>>>>>        End
86609>>>>>>>>
86609>>>>>>>
86609>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86610>>>>>>>        Close hTable
86611>>>>>>>        Function_Return (bOK = True)
86612>>>>>>>    End_Function
86613>>>>>>>
86613>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86615>>>>>>>        Move False to Err
86616>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86619>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86622>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86625>>>>>>>
86625>>>>>>>        Function_Return (Err = False)
86626>>>>>>>    End_Function
86627>>>>>>>
86627>>>>>>>    // ToDo: Needs to be revised
86627>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86629>>>>>>>        Handle hTable
86629>>>>>>>        String sDEFName sDataPath
86629>>>>>>>        Boolean bExists
86629>>>>>>>
86629>>>>>>>        // Do nothing if MSSQL Driver.
86629>>>>>>>//        Get IsMSSQLDriver to bExists
86629>>>>>>>//        If (bExists = True) Begin
86629>>>>>>>//            Procedure_Return
86629>>>>>>>//        End
86629>>>>>>>
86629>>>>>>>        Get psDataPathFirstPart to sDataPath
86630>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86631>>>>>>>        If (bExists = True) Begin
86633>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86633>>>>>>>            // still be missing from the filelist and needs to be added.
86633>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86634>>>>>>>            If (bExists = True) Begin
86636>>>>>>>                Procedure_Return
86637>>>>>>>            End
86637>>>>>>>>
86637>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86637>>>>>>>            Else Begin
86638>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86641>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86644>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86647>>>>>>>                Procedure_Return
86648>>>>>>>            End
86648>>>>>>>>
86648>>>>>>>        End
86648>>>>>>>>
86648>>>>>>>
86648>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86649>>>>>>>        Move 0 to hTable
86650>>>>>>>        Move False to Err
86651>>>>>>>
86651>>>>>>>        Structure_Start hTable DATAFLEX_ID
86652>>>>>>>            Load_Def sDEFName Onto hTable
86653>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86656>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86657>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86659>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86660>>>>>>>
86660>>>>>>>        Move iFilelistSlot to hTable
86661>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86664>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86667>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86670>>>>>>>
86670>>>>>>>    End_Procedure
86671>>>>>>>
86671>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86673>>>>>>>        Boolean bTmp bErr bOK
86673>>>>>>>        String sTableName sDisplayName sFileName
86673>>>>>>>
86673>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86673>>>>>>>        Move Err to bTmp
86674>>>>>>>        Move False to Err
86675>>>>>>>
86675>>>>>>>        Get AutoConnectionIDLogin to bOK
86676>>>>>>>        // First get the info for the current filelist slot:
86676>>>>>>>        Open iFromFileSlot
86678>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86681>>>>>>>        If (bOK = True) Begin
86683>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86686>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86689>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86692>>>>>>>
86692>>>>>>>            //...then move it.
86692>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86695>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86698>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86701>>>>>>>
86701>>>>>>>            //...and finally remove the old filelist values.
86701>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86704>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86707>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86710>>>>>>>        End
86710>>>>>>>>
86710>>>>>>>        Close iFromFileSlot
86711>>>>>>>
86711>>>>>>>        Move Err to bErr
86712>>>>>>>        Move bTmp to Err
86713>>>>>>>        Function_Return (bErr = False)
86714>>>>>>>    End_Function
86715>>>>>>>
86715>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86717>>>>>>>        Handle hTable
86717>>>>>>>        Boolean bOK
86717>>>>>>>        String sDriverID
86717>>>>>>>
86717>>>>>>>        Get _UtilTableExists hTableFrom to bOK
86718>>>>>>>        If (bOK = False) Begin
86720>>>>>>>            Set Private.phCurrentTable to hTableFrom
86721>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86722>>>>>>>>
86722>>>>>>>            Function_Return False
86723>>>>>>>        End
86723>>>>>>>>
86723>>>>>>>
86723>>>>>>>        Get _UtilTableExists hTableTo to bOK
86724>>>>>>>        If (bOK = False) Begin
86726>>>>>>>            Set Private.phCurrentTable to hTableTo
86727>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86728>>>>>>>>
86728>>>>>>>            Function_Return False
86729>>>>>>>        End
86729>>>>>>>>
86729>>>>>>>
86729>>>>>>>        Get AutoConnectionIDLogin to bOK
86730>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86731>>>>>>>        If (bOK = False) Begin
86733>>>>>>>            Function_Return False
86734>>>>>>>        End
86734>>>>>>>>
86734>>>>>>>
86734>>>>>>>        Move False to Err
86735>>>>>>>        Open hTableTo
86737>>>>>>>
86737>>>>>>>        Move hTableFrom to hTable
86738>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86741>>>>>>>        Set Private.phCurrentTable to hTable
86742>>>>>>>
86742>>>>>>>        Structure_Start hTable sDriverID
86743>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86746>>>>>>>            If (iColumnTo <> 0) Begin
86748>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86751>>>>>>>            End
86751>>>>>>>>
86751>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86752>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86754>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86755>>>>>>>
86755>>>>>>>        If (hTableTo > 0) Begin
86757>>>>>>>            Close hTableTo
86758>>>>>>>        End
86758>>>>>>>>
86758>>>>>>>
86758>>>>>>>        Function_Return (Err = False)
86759>>>>>>>    End_Function
86760>>>>>>>
86760>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86760>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
86762>>>>>>>        String sTableName sDriverID
86762>>>>>>>        Boolean bOk
86762>>>>>>>        String sDataPath
86762>>>>>>>
86762>>>>>>>        Get AutoConnectionIDLogin to bOK
86763>>>>>>>        Move False to Err
86764>>>>>>>        Get psDriverID to sDriverID
86765>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86766>>>>>>>        If (sTableName = "") Begin
86768>>>>>>>            Function_Return False
86769>>>>>>>        End
86769>>>>>>>>
86769>>>>>>>
86769>>>>>>>        Set Private.phCurrentTable to hTable
86770>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86771>>>>>>>        Delete_db sTableName
86772>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86773>>>>>>>
86773>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86775>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86775>>>>>>>            Get psDataPathFirstPart to sDataPath
86776>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86777>>>>>>>        End
86777>>>>>>>>
86777>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86777>>>>>>>        If (hTable <> 0) Begin
86779>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86782>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86785>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86788>>>>>>>        End
86788>>>>>>>>
86788>>>>>>>
86788>>>>>>>        Close hTable
86789>>>>>>>        Function_Return (hTable <> 0)
86790>>>>>>>    End_Function
86791>>>>>>>
86791>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86793>>>>>>>        Handle hTable
86793>>>>>>>        Boolean bOK
86793>>>>>>>
86793>>>>>>>        Get AutoConnectionIDLogin to bOK
86794>>>>>>>        Move False to Err
86795>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
86797>>>>>>>        Move hTableFrom to hTable
86798>>>>>>>
86798>>>>>>>        Structure_Start hTable
86799>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86802>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86803>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86805>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86806>>>>>>>
86806>>>>>>>        Close hTableFrom
86807>>>>>>>        Function_Return (Err = False)
86808>>>>>>>    End_Function
86809>>>>>>>
86809>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86811>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86811>>>>>>>        Boolean bOK bExists bOpened
86811>>>>>>>        tAPITableNameInfo APITableNameInfo
86811>>>>>>>        tAPITableNameInfo APITableNameInfo
86811>>>>>>>
86811>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86814>>>>>>>        If (bOpened = False) Begin
86816>>>>>>>            Get OpenTableExclusive hTable to bOpened
86817>>>>>>>            If (bOpened = False) Begin
86819>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86820>>>>>>>                Function_Return False
86821>>>>>>>            End
86821>>>>>>>>
86821>>>>>>>        End
86821>>>>>>>>
86821>>>>>>>
86821>>>>>>>        Set Private.phCurrentTable to hTable
86822>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
86823>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
86824>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86825>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86826>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86827>>>>>>>        If (bExists = True) Begin
86829>>>>>>>            Function_Return True
86830>>>>>>>        End
86830>>>>>>>>
86830>>>>>>>
86830>>>>>>>        Set Private.phCurrentTable to hTable
86831>>>>>>>        Move False to Err
86832>>>>>>>        Get psDataPathFirstPart to sDataPath
86833>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86836>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86839>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86842>>>>>>>
86842>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86845>>>>>>>        Close hTable
86846>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86848>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86849>>>>>>>            If (bExists = True) Begin
86851>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86853>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86856>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86856>>>>>>>                    // might report "File in use..." and the deletion will fail.
86856>>>>>>>                    Sleep 2
86857>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86858>>>>>>>                End
86858>>>>>>>>
86858>>>>>>>            End
86858>>>>>>>>
86858>>>>>>>        End
86858>>>>>>>>
86858>>>>>>>
86858>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86860>>>>>>>            If (not(sPhysicalName contains ".")) Begin
86862>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86863>>>>>>>            End
86863>>>>>>>>
86863>>>>>>>
86863>>>>>>>            // Change the table name in the .int file to the new table new:
86863>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86864>>>>>>>            If (bOK = False) Begin
86866>>>>>>>                Function_Return False
86867>>>>>>>            End
86867>>>>>>>>
86867>>>>>>>
86867>>>>>>>            // Change table name at the SQL side:
86867>>>>>>>            Get psSchema to sSchema
86868>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86869>>>>>>>
86869>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86870>>>>>>>            // Remove cache file and Rename the physical file names:
86870>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86871>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86872>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86873>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86874>>>>>>>
86874>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86874>>>>>>>//            If (not(sDisplayName contains ".")) Begin
86874>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86874>>>>>>>//            End
86874>>>>>>>        End
86874>>>>>>>>
86874>>>>>>>
86874>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86877>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86880>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86883>>>>>>>
86883>>>>>>>        Function_Return (Err = False)
86884>>>>>>>    End_Function
86885>>>>>>>
86885>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86887>>>>>>>        Move False to Err
86888>>>>>>>        Set Private.phCurrentTable to hTable
86889>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86892>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86895>>>>>>>
86895>>>>>>>        Function_Return (Err = False)
86896>>>>>>>    End_Function
86897>>>>>>>
86897>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
86897>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
86899>>>>>>>        Handle hTable
86899>>>>>>>        String sTableName
86899>>>>>>>        String sDriverIDFrom sDriverIDTo
86899>>>>>>>        Integer iDbType
86899>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto
86899>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
86899>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
86899>>>>>>>        tSQLConnection SQLConnection
86899>>>>>>>        tSQLConnection SQLConnection
86899>>>>>>>        tAPITable      APITableFrom APITableTo
86899>>>>>>>        tAPITable      APITableFrom APITableTo
86899>>>>>>>        tColumnType    ColumnType
86899>>>>>>>        tColumnType    ColumnType
86899>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86899>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86900>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86900>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86901>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86901>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86902>>>>>>>
86902>>>>>>>        // We don't allow changes to the framework's DbVersion table.
86902>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
86904>>>>>>>            Function_Return False
86905>>>>>>>        End
86905>>>>>>>>
86905>>>>>>>
86905>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
86906>>>>>>>        Get piDbType                            to iDbType
86907>>>>>>>        Get pbRecnum                            to bRecnum
86908>>>>>>>        Get pbToANSI                            to bToANSI
86909>>>>>>>        Get pbCopyData                          to bCopyData
86910>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
86911>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
86912>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
86913>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
86914>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
86915>>>>>>>
86915>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86916>>>>>>>        Set Private.phCurrentTable              to hTable
86917>>>>>>>        Get _UtilTableExists  hTable             to bTableExists
86918>>>>>>>
86918>>>>>>>        If (ghoProgressBar <> 0) Begin
86920>>>>>>>            Send DoAdvance of ghoProgressBar
86921>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86922>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86923>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86924>>>>>>>        End
86924>>>>>>>>
86924>>>>>>>
86924>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
86925>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
86926>>>>>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
86927>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
86928>>>>>>>        Move True                               to APITableFrom.bFromTable
86929>>>>>>>        Move hTable                             to APITableFrom.hTable
86930>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
86931>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
86932>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
86933>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
86934>>>>>>>
86934>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86936>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86937>>>>>>>            If (bOk = True) Begin
86939>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
86940>>>>>>>                Function_Return bOk
86941>>>>>>>            End 
86941>>>>>>>>
86941>>>>>>>        End
86941>>>>>>>>
86941>>>>>>>
86941>>>>>>>        If (bTableExists = True) Begin
86943>>>>>>>            If (bIsSQLTableTo = True) Begin
86945>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
86946>>>>>>>            End
86946>>>>>>>>
86946>>>>>>>
86946>>>>>>>            Get OpenTableExclusive hTable to bOpened
86947>>>>>>>            If (bOpened = False) Begin
86949>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86950>>>>>>>                Function_Return False
86951>>>>>>>            End
86951>>>>>>>>
86951>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
86952>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
86953>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
86954>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
86955>>>>>>>        End
86955>>>>>>>>
86955>>>>>>>
86955>>>>>>>        Move False to Err
86956>>>>>>>        Case Begin
86956>>>>>>>            // Alias table:
86956>>>>>>>            Case (bIsAliasFrom = True)
86958>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86959>>>>>>>                Case Break
86960>>>>>>>
86960>>>>>>>            // New Table:
86960>>>>>>>            Case (bTableExists = False)
86963>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
86964>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
86964>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
86966>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
86967>>>>>>>                End                                                                 
86967>>>>>>>>
86967>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86968>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
86969>>>>>>>                Case Break
86970>>>>>>>
86970>>>>>>>            // Update table:
86970>>>>>>>            Case (bTableExists = True)
86973>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
86974>>>>>>>                If (bIsSame = True) Begin
86976>>>>>>>                    Case Break
86977>>>>>>>                End
86977>>>>>>>>
86977>>>>>>>                If (bFilelistError = True) Begin
86979>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
86980>>>>>>>                    If (bOk = False) Begin
86982>>>>>>>                        Case Break
86983>>>>>>>                    End
86983>>>>>>>>
86983>>>>>>>                End
86983>>>>>>>>
86983>>>>>>>
86983>>>>>>>                If (ghoProgressBar <> 0) Begin
86985>>>>>>>                    Send DoAdvance of ghoProgressBar
86986>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86987>>>>>>>                End
86987>>>>>>>>
86987>>>>>>>
86987>>>>>>>                // Columns:
86987>>>>>>>                Move True to bOk
86988>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86989>>>>>>>                If (bIsSame = False) Begin
86991>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
86992>>>>>>>                End
86992>>>>>>>>
86992>>>>>>>                If (bOk = False) Begin
86994>>>>>>>                    Case Break
86995>>>>>>>                End
86995>>>>>>>>
86995>>>>>>>
86995>>>>>>>                // Indexes:
86995>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86996>>>>>>>                If (bIsSame = False) Begin
86998>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86999>>>>>>>                End
86999>>>>>>>>
86999>>>>>>>
86999>>>>>>>                // Relations:
86999>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87000>>>>>>>                If (bIsSame = False) Begin
87002>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87003>>>>>>>                    If (bOk = False) Begin
87005>>>>>>>                        Case Break
87006>>>>>>>                    End
87006>>>>>>>>
87006>>>>>>>                End
87006>>>>>>>>
87006>>>>>>>
87006>>>>>>>                Case Break
87007>>>>>>>
87007>>>>>>>            Case Else
87007>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87008>>>>>>>>
87008>>>>>>>                Move False to bOk
87009>>>>>>>        Case End
87009>>>>>>>        
87009>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87009>>>>>>>        // or convert an embedded table to SQL
87009>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87011>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87012>>>>>>>            If (bOk = False) Begin
87014>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87015>>>>>>>            End
87015>>>>>>>>
87015>>>>>>>        End
87015>>>>>>>>
87015>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87018>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
87019>>>>>>>        End
87019>>>>>>>>
87019>>>>>>>        
87019>>>>>>>        // Filelist Names:
87019>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87020>>>>>>>        Close hTable
87021>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87022>>>>>>>
87022>>>>>>>        Function_Return (bOK = True)
87023>>>>>>>    End_Function
87024>>>>>>>
87024>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87024>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87026>>>>>>>        Function_Return False
87027>>>>>>>    End_Function
87028>>>>>>>
87028>>>>>>>    // Adds a column name to the passed table number.
87028>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87030>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87030>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87030>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87030>>>>>>>
87030>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87031>>>>>>>        If (bExists = True) Begin
87033>>>>>>>            Function_Return False
87034>>>>>>>        End
87034>>>>>>>>
87034>>>>>>>
87034>>>>>>>        Move False to Err
87035>>>>>>>        If (num_arguments > 4) Begin
87037>>>>>>>            Move iPrec to iPrecision
87038>>>>>>>        End
87038>>>>>>>>
87038>>>>>>>        If (num_arguments > 6) Begin
87040>>>>>>>            Move bInitVal to bInitializeValue
87041>>>>>>>            Move sColVal  to sColumnValue
87042>>>>>>>        End
87042>>>>>>>>
87042>>>>>>>        If (iType < -1490) Begin
87044>>>>>>>            Move (iType + 1500) to iType
87045>>>>>>>        End
87045>>>>>>>>
87045>>>>>>>
87045>>>>>>>        Move hTable to iFile
87046>>>>>>>        Get psDriverID to sDriverID
87047>>>>>>>        Get AutoConnectionIDLogin to bOK
87048>>>>>>>        Move False to Err
87049>>>>>>>        Move LastErr to iLastErr
87050>>>>>>>        Get OpenTableExclusive iFile to bOK
87051>>>>>>>        Set Private.phCurrentTable to hTable
87052>>>>>>>
87052>>>>>>>        Structure_Start iFile sDriverID
87053>>>>>>>            Move 0 to iColumn
87054>>>>>>>            Set Private.piCurrentField to iColumn
87055>>>>>>>            Create_Field hTable At iColumn
87056>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87059>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87062>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87065>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87068>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87069>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87071>>>>>>>
87071>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87072>>>>>>>
87072>>>>>>>        // If in development environment; create .fd file:
87072>>>>>>>        Open hTable
87074>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87075>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87076>>>>>>>        If (iCount > 1) Begin
87078>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87079>>>>>>>        End
87079>>>>>>>>
87079>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87080>>>>>>>        If (bExists = True) Begin
87082>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87083>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87086>>>>>>>            Get _TableNameOnly sTableName to sTableName
87087>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87089>>>>>>>        End
87089>>>>>>>>
87089>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87091>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87092>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87093>>>>>>>            If (iCount > 1) Begin
87095>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87096>>>>>>>            End
87096>>>>>>>>
87096>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87097>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87097>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87097>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87097>>>>>>>        End
87097>>>>>>>>
87097>>>>>>>        // Check for a default value
87097>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87099>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87100>>>>>>>        End
87100>>>>>>>>
87100>>>>>>>        Close hTable
87101>>>>>>>
87101>>>>>>>        Function_Return (Err = False)
87102>>>>>>>    End_Function
87103>>>>>>>
87103>>>>>>>    // Adds a column name to the passed table number.
87103>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87105>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87105>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87105>>>>>>>        String sDdSrcPath sTableName
87105>>>>>>>
87105>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87106>>>>>>>        Move False to Err
87107>>>>>>>        If (bExists = True) Begin
87109>>>>>>>            Function_Return False
87110>>>>>>>        End
87110>>>>>>>>
87110>>>>>>>        If (num_arguments > 4) Begin
87112>>>>>>>            Move iPrec to iPrecision
87113>>>>>>>        End
87113>>>>>>>>
87113>>>>>>>        If (iType < -1490) Begin
87115>>>>>>>            Move (iType + 1500) to iType
87116>>>>>>>        End
87116>>>>>>>>
87116>>>>>>>
87116>>>>>>>        Get AutoConnectionIDLogin to bOK
87117>>>>>>>        Move False to Err
87118>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87119>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87119>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87119>>>>>>>        Get piDbType to iDbType
87120>>>>>>>        If (bIsSQLTypeTo = False) Begin
87122>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87123>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87125>>>>>>>                Move DF_DATE to iType
87126>>>>>>>            End
87126>>>>>>>>
87126>>>>>>>        End
87126>>>>>>>>
87126>>>>>>>
87126>>>>>>>        // Structure_start will change the value of hTable...
87126>>>>>>>        Move hTable to iFile
87127>>>>>>>        Get OpenTableExclusive iFile to bOK
87128>>>>>>>        If (bOK = False) Begin
87130>>>>>>>            Function_Return False
87131>>>>>>>        End
87131>>>>>>>>
87131>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87134>>>>>>>
87134>>>>>>>        // If the passed column number is higher than the current number of fields
87134>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87134>>>>>>>        // a new field to the end:
87134>>>>>>>        If (iColumn > iNumberOfFields) Begin
87136>>>>>>>            Move 0 to iColumn
87137>>>>>>>        End
87137>>>>>>>>
87137>>>>>>>
87137>>>>>>>        Set Private.phCurrentTable to hTable
87138>>>>>>>        Set Private.piCurrentField to iColumn
87139>>>>>>>
87139>>>>>>>        Structure_Start iFile
87140>>>>>>>            Create_Field iFile At iColumn
87141>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87144>>>>>>>            If (bIsSQLTypeTo = False) Begin
87146>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87149>>>>>>>            End
87149>>>>>>>>
87149>>>>>>>            Else Begin
87150>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87153>>>>>>>            End
87153>>>>>>>>
87153>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87154>>>>>>>            If (bIsDateType = False) Begin
87156>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87159>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87162>>>>>>>            End
87162>>>>>>>>
87162>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87163>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87165>>>>>>>
87165>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87166>>>>>>>        // If in development environment; create .fd file:
87166>>>>>>>        Open hTable
87168>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87169>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87170>>>>>>>        If (iCount > 1) Begin
87172>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87173>>>>>>>        End
87173>>>>>>>>
87173>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87174>>>>>>>        If (bExists = True) Begin
87176>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87177>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87180>>>>>>>            Get _TableNameOnly sTableName to sTableName
87181>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87183>>>>>>>        End
87183>>>>>>>>
87183>>>>>>>
87183>>>>>>>        // Check for a default value
87183>>>>>>>        Close hTable
87184>>>>>>>
87184>>>>>>>        Function_Return (Err = False)
87185>>>>>>>    End_Function
87186>>>>>>>
87186>>>>>>>    // To update all records for a table column with a fixed value.
87186>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87188>>>>>>>        Integer iRecs iCurrErr iField iRecord
87188>>>>>>>        Boolean bRetval bOpen
87188>>>>>>>
87188>>>>>>>        Move 0 to iRecs
87189>>>>>>>        Move False to bRetval
87190>>>>>>>        Move Err to iCurrErr
87191>>>>>>>        Move False to Err
87192>>>>>>>
87192>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87195>>>>>>>        If (bOpen = False) Begin
87197>>>>>>>            Open hTable
87199>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87202>>>>>>>            If (bOpen = False) Begin
87204>>>>>>>                Function_Return bRetval
87205>>>>>>>            End
87205>>>>>>>>
87205>>>>>>>        End
87205>>>>>>>>
87205>>>>>>>
87205>>>>>>>        Field_Map hTable sFieldName to iField
87207>>>>>>>        If (iField <> 0) Begin
87209>>>>>>>            Set Private.phCurrentTable to hTable
87210>>>>>>>            Set Private.piCurrentField to iField
87211>>>>>>>            Clear hTable
87212>>>>>>>            Repeat
87212>>>>>>>>
87212>>>>>>>                Vfind hTable 0 GT
87214>>>>>>>                If (Found) Begin
87216>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87218>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87221>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87222>>>>>>>                    End
87222>>>>>>>>
87222>>>>>>>                    Reread hTable
87226>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87229>>>>>>>                        SaveRecord hTable
87230>>>>>>>                    Unlock
87231>>>>>>>>
87231>>>>>>>                End
87231>>>>>>>>
87231>>>>>>>           Until (not(Found))
87233>>>>>>>        End
87233>>>>>>>>
87233>>>>>>>
87233>>>>>>>        Move (Err = False) to bRetval
87234>>>>>>>        Move iCurrErr to Err
87235>>>>>>>
87235>>>>>>>        Function_Return bRetval
87236>>>>>>>    End_Function
87237>>>>>>>
87237>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87237>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87239>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87239>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87239>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87239>>>>>>>
87239>>>>>>>        Get psDriverID to sDriverID
87240>>>>>>>        Get piDbType to iDbType
87241>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87242>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87243>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87244>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87245>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87247>>>>>>>            Move True to bIsSqlTable
87248>>>>>>>        End
87248>>>>>>>>
87248>>>>>>>        Move False to bIsOpen
87249>>>>>>>        If (hTable > 0) Begin
87251>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87254>>>>>>>        End
87254>>>>>>>>
87254>>>>>>>        If (bIsOpen = True) Begin
87256>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87259>>>>>>>        End
87259>>>>>>>>
87259>>>>>>>        Else Begin
87260>>>>>>>            Get pbRecnum to bRecnumTable
87261>>>>>>>        End
87261>>>>>>>>
87261>>>>>>>
87261>>>>>>>        Move False to Err
87262>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87263>>>>>>>        Decrement iSize
87264>>>>>>>        for iCount from 0 to iSize
87270>>>>>>>>
87270>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87271>>>>>>>            If (hTable > 0) Begin
87273>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87274>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87275>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87278>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87279>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87280>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87281>>>>>>>            End
87281>>>>>>>>
87281>>>>>>>            Else Begin
87282>>>>>>>                Move False to bFieldExists
87283>>>>>>>            End
87283>>>>>>>>
87283>>>>>>>
87283>>>>>>>            If (bFieldExists = False) Begin
87285>>>>>>>                Move 0 to iColumn
87286>>>>>>>                Create_Field hTable At iColumn
87287>>>>>>>            End
87287>>>>>>>>
87287>>>>>>>            Else Begin
87288>>>>>>>                Move iCount to iColumn
87289>>>>>>>            End
87289>>>>>>>>
87289>>>>>>>
87289>>>>>>>            Set Private.piCurrentField to iColumn
87290>>>>>>>
87290>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87291>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87294>>>>>>>
87294>>>>>>>            Move aColumns[iCount].iType to iType
87295>>>>>>>            Move (not(iType < -1490)) to bNativeType
87296>>>>>>>            If (iType < -1490) Begin
87298>>>>>>>                Move (iType + 1500) to iType
87299>>>>>>>            End
87299>>>>>>>>
87299>>>>>>>
87299>>>>>>>            If (bIsSqlTable = True) Begin
87301>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87303>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87304>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87307>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87310>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87313>>>>>>>
87313>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87314>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87316>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87317>>>>>>>                    End
87317>>>>>>>>
87317>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87320>>>>>>>
87320>>>>>>>                End
87320>>>>>>>>
87320>>>>>>>                Else Begin
87321>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87324>>>>>>>                End
87324>>>>>>>>
87324>>>>>>>            End
87324>>>>>>>>
87324>>>>>>>            Else Begin
87325>>>>>>>                If (bCreating = False) Begin
87327>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87328>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87330>>>>>>>                        Move DF_DATE to iType
87331>>>>>>>                    End
87331>>>>>>>>
87331>>>>>>>                End
87331>>>>>>>>
87331>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87334>>>>>>>            End
87334>>>>>>>>
87334>>>>>>>
87334>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87335>>>>>>>            If (bIsDateType = False) Begin
87337>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87340>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87343>>>>>>>            End
87343>>>>>>>>
87343>>>>>>>
87343>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87345>>>>>>>                Move 0 to iIndex
87346>>>>>>>                Create_Index hTable at iIndex
87347>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87350>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87353>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87356>>>>>>>
87356>>>>>>>                // If we have an identity table - we must create a primary_key table.
87356>>>>>>>                If (bIsSqlTable = True) Begin
87358>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87361>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87364>>>>>>>                End
87364>>>>>>>>
87364>>>>>>>            End
87364>>>>>>>>
87364>>>>>>>        Loop
87365>>>>>>>>
87365>>>>>>>
87365>>>>>>>        Function_Return (Err = False)
87366>>>>>>>    End_Function
87367>>>>>>>
87367>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87367>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87369>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87369>>>>>>>        Boolean bOK bIsSqlTable
87369>>>>>>>        String sFieldNameTo
87369>>>>>>>
87369>>>>>>>        If (num_arguments > 4) Begin
87371>>>>>>>            Move iPrec to iPrecFrom
87372>>>>>>>        End
87372>>>>>>>>
87372>>>>>>>        If (iTypeFrom < -1490) Begin
87374>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87375>>>>>>>        End
87375>>>>>>>>
87375>>>>>>>
87375>>>>>>>        Get AutoConnectionIDLogin to bOK
87376>>>>>>>        Move False to Err
87377>>>>>>>        Get OpenTableExclusive hTable to bOK
87378>>>>>>>        If (bOK = False) Begin
87380>>>>>>>            Function_Return False
87381>>>>>>>        End
87381>>>>>>>>
87381>>>>>>>
87381>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87382>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87383>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87385>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87386>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87387>>>>>>>        If (Err = True) Begin
87389>>>>>>>            Function_Return False
87390>>>>>>>        End
87390>>>>>>>>
87390>>>>>>>
87390>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87393>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87394>>>>>>>        If (bIsSqlTable = False) Begin
87396>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87399>>>>>>>        End
87399>>>>>>>>
87399>>>>>>>        Else Begin
87400>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87403>>>>>>>        End
87403>>>>>>>>
87403>>>>>>>        // Let the driver decide the other values;
87403>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87406>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87409>>>>>>>
87409>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87411>>>>>>>            Function_Return False
87412>>>>>>>        End
87412>>>>>>>>
87412>>>>>>>
87412>>>>>>>        Set Private.phCurrentTable to hTable
87413>>>>>>>        Set Private.piCurrentField to iColumn
87414>>>>>>>
87414>>>>>>>        Structure_Start hTable
87415>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87418>>>>>>>//            If (bIsSqlTable = False) Begin
87418>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87421>>>>>>>//            End
87421>>>>>>>//            Else Begin
87421>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87421>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87421>>>>>>>//            End
87421>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87424>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87427>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87428>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87430>>>>>>>
87430>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87431>>>>>>>        Function_Return (Err = False)
87432>>>>>>>    End_Function
87433>>>>>>>
87433>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87433>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87435>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87435>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87435>>>>>>>        String sFieldNameTo sDriverIDTo
87435>>>>>>>        tColumnType ColumnType
87435>>>>>>>        tColumnType ColumnType
87435>>>>>>>
87435>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87436>>>>>>>        Get piDbType to iDbType
87437>>>>>>>        If (num_arguments > 4) Begin
87439>>>>>>>            Move iPrec to iPrecFrom
87440>>>>>>>            Move iOpt  to iOptionFrom
87441>>>>>>>        End
87441>>>>>>>>
87441>>>>>>>        If (iTypeFrom < -1490) Begin
87443>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87444>>>>>>>        End
87444>>>>>>>>
87444>>>>>>>
87444>>>>>>>        Get AutoConnectionIDLogin to bOK
87445>>>>>>>        Move False to Err
87446>>>>>>>        Close hTable
87447>>>>>>>        Get OpenTableExclusive hTable to bOK
87448>>>>>>>        If (bOK = False) Begin
87450>>>>>>>            Function_Return False
87451>>>>>>>        End
87451>>>>>>>>
87451>>>>>>>
87451>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87454>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87457>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87458>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87460>>>>>>>            Move DF_DATE to iDataFlexType
87461>>>>>>>        End
87461>>>>>>>>
87461>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87464>>>>>>>
87464>>>>>>>        If (bIsSQLTableTo = True) Begin
87466>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87469>>>>>>>        End
87469>>>>>>>>
87469>>>>>>>        Else Begin
87470>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87473>>>>>>>        End
87473>>>>>>>>
87473>>>>>>>
87473>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87476>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87479>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87482>>>>>>>
87482>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87482>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87482>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87484>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87485>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87487>>>>>>>                Move DF_DATE to iTypeTo  
87488>>>>>>>            End
87488>>>>>>>>
87488>>>>>>>        End
87488>>>>>>>>
87488>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87491>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87492>>>>>>>        End
87492>>>>>>>>
87492>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87493>>>>>>>
87493>>>>>>>        If (bCompareDate_DateTime = False) Begin
87495>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87496>>>>>>>            If (bSkip = True) Begin
87498>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87500>>>>>>>                    Function_Return True
87501>>>>>>>                End
87501>>>>>>>>
87501>>>>>>>            End
87501>>>>>>>>
87501>>>>>>>        End
87501>>>>>>>>
87501>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87504>>>>>>>            Function_Return True
87505>>>>>>>        End
87505>>>>>>>>
87505>>>>>>>
87505>>>>>>>        Set Private.phCurrentTable to hTable
87506>>>>>>>        Set Private.piCurrentField to iColumn
87507>>>>>>>
87507>>>>>>>        Structure_Start hTable
87508>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87510>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87513>>>>>>>            End
87513>>>>>>>>
87513>>>>>>>
87513>>>>>>>            If (bIsSameDataType = False) Begin
87515>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87518>>>>>>>                If (bIsSQLTableTo = True) Begin
87520>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87523>>>>>>>                End
87523>>>>>>>>
87523>>>>>>>            End
87523>>>>>>>>
87523>>>>>>>
87523>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87525>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87528>>>>>>>            End
87528>>>>>>>>
87528>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87530>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87533>>>>>>>            End
87533>>>>>>>>
87533>>>>>>>
87533>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87535>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87535>>>>>>>                If (bRecnumTable = True) Begin
87537>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87540>>>>>>>                End
87540>>>>>>>>
87540>>>>>>>
87540>>>>>>>                // We might need to create an index here.
87540>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87540>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87540>>>>>>>                // index update checking logic.
87540>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87543>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87545>>>>>>>                    Create_Index hTable At iIndex
87546>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87549>>>>>>>                End
87549>>>>>>>>
87549>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87552>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87555>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87558>>>>>>>                If (bIsSQLTableTo = True) Begin
87560>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87563>>>>>>>                End
87563>>>>>>>>
87563>>>>>>>            End
87563>>>>>>>>
87563>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87564>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87566>>>>>>>
87566>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87567>>>>>>>        Function_Return (Err = False)
87568>>>>>>>    End_Function
87569>>>>>>>
87569>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87571>>>>>>>        Boolean bOK
87571>>>>>>>
87571>>>>>>>        Get AutoConnectionIDLogin to bOK
87572>>>>>>>        Move False to Err
87573>>>>>>>        Get OpenTableExclusive hTable to bOK
87574>>>>>>>        If (bOK = False) Begin
87576>>>>>>>            Function_Return False
87577>>>>>>>        End
87577>>>>>>>>
87577>>>>>>>
87577>>>>>>>        Structure_Start hTable
87578>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87581>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87582>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87584>>>>>>>
87584>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87585>>>>>>>        Function_Return (Err = False)
87586>>>>>>>    End_Function
87587>>>>>>>
87587>>>>>>>    // To move an existing field to another position in a table.
87587>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87589>>>>>>>        String sColumn sDriverID
87589>>>>>>>        Integer iType
87589>>>>>>>        Boolean bOK bIsDate
87589>>>>>>>
87589>>>>>>>        Close hTable
87590>>>>>>>        Get AutoConnectionIDLogin to bOK
87591>>>>>>>        Get OpenTableExclusive hTable to bOK
87592>>>>>>>        If (bOK = False) Begin
87594>>>>>>>            Function_Return False
87595>>>>>>>        End
87595>>>>>>>>
87595>>>>>>>
87595>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87598>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87600>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87601>>>>>>>>
87601>>>>>>>            Function_Return False
87602>>>>>>>        End
87602>>>>>>>>
87602>>>>>>>
87602>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87605>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87608>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87609>>>>>>>
87609>>>>>>>        Set Private.phCurrentTable to hTable
87610>>>>>>>        Set Private.piCurrentField to iOld
87611>>>>>>>
87611>>>>>>>//        If (bIsDate = False) Begin
87611>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87611>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87611>>>>>>>//        End
87611>>>>>>>//        Else Begin
87611>>>>>>>//            Move 6 to iLength
87611>>>>>>>//            Move 0 to iPrecision
87611>>>>>>>//        End
87611>>>>>>>
87611>>>>>>>        Move False to Err
87612>>>>>>>
87612>>>>>>>        Structure_Start hTable
87613>>>>>>>            Delete_Field hTable iOld
87614>>>>>>>            Create_Field hTable At iNew
87615>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87618>>>>>>>
87618>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87621>>>>>>>            If (bIsSQLType = False) Begin
87623>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87626>>>>>>>            End
87626>>>>>>>>
87626>>>>>>>            Else Begin
87627>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87630>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87630>>>>>>>            End
87630>>>>>>>>
87630>>>>>>>
87630>>>>>>>            If (bIsDate = False) Begin
87632>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87635>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87638>>>>>>>            End
87638>>>>>>>>
87638>>>>>>>
87638>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87639>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87641>>>>>>>
87641>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87642>>>>>>>        Function_Return (Err = False)
87643>>>>>>>    End_Function
87644>>>>>>>
87644>>>>>>>    // Deletes a column name for the passed table number (and column number).
87644>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87646>>>>>>>        Integer iColumn
87646>>>>>>>        Boolean bOK
87646>>>>>>>
87646>>>>>>>        Get AutoConnectionIDLogin to bOK
87647>>>>>>>        Move False to Err
87648>>>>>>>        Close hTable
87649>>>>>>>        Get OpenTableExclusive hTable to bOK
87650>>>>>>>        If (bOK = False) Begin
87652>>>>>>>            Function_Return False
87653>>>>>>>        End
87653>>>>>>>>
87653>>>>>>>
87653>>>>>>>        If (not(Err)) Begin
87655>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87656>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87657>>>>>>>            Field_Map hTable sFieldName to iColumn
87659>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87660>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87661>>>>>>>            If (iColumn = 0) Begin
87663>>>>>>>                Move 0 to LastErr
87664>>>>>>>                Function_Return False
87665>>>>>>>            End
87665>>>>>>>>
87665>>>>>>>            Move False to Err
87666>>>>>>>
87666>>>>>>>            Set Private.phCurrentTable to hTable
87667>>>>>>>            Set Private.piCurrentField to iColumn
87668>>>>>>>
87668>>>>>>>            Structure_Start hTable
87669>>>>>>>                Delete_Field hTable iColumn
87670>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87671>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87673>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87674>>>>>>>        End
87674>>>>>>>>
87674>>>>>>>        Else Begin
87675>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87676>>>>>>>>
87676>>>>>>>        End
87676>>>>>>>>
87676>>>>>>>
87676>>>>>>>        Function_Return (Err = False)
87677>>>>>>>    End_Function
87678>>>>>>>
87678>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87678>>>>>>>    // Returns True if no errors occured.
87678>>>>>>>    // Sample usage:
87678>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87678>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87680>>>>>>>        Integer iField
87680>>>>>>>        Boolean bOK bExists bIsOpen
87680>>>>>>>
87680>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87681>>>>>>>        If (bExists = True) Begin
87683>>>>>>>            Function_Return False
87684>>>>>>>        End
87684>>>>>>>>
87684>>>>>>>
87684>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87684>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87684>>>>>>>        Close hTable
87685>>>>>>>        Open hTable
87687>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87690>>>>>>>        If (bIsOpen = False) Begin
87692>>>>>>>            Function_Return False
87693>>>>>>>        End
87693>>>>>>>>
87693>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87694>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87695>>>>>>>        Field_Map hTable sOldFieldName to iField
87697>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87698>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87699>>>>>>>
87699>>>>>>>        Get AutoConnectionIDLogin to bOK
87700>>>>>>>        Get OpenTableExclusive hTable to bOK
87701>>>>>>>        If (bOK = False) Begin
87703>>>>>>>            Function_Return False
87704>>>>>>>        End
87704>>>>>>>>
87704>>>>>>>
87704>>>>>>>        Move False to Err
87705>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87706>>>>>>>        Set Private.phCurrentTable to hTable
87707>>>>>>>        Set Private.piCurrentField to iField
87708>>>>>>>
87708>>>>>>>        If (iField > 0) Begin
87710>>>>>>>            Structure_Start hTable
87711>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87714>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87715>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87717>>>>>>>        End
87717>>>>>>>>
87717>>>>>>>        Else Begin
87718>>>>>>>            Move 0 to LastErr
87719>>>>>>>            Move False to Err
87720>>>>>>>        End
87720>>>>>>>>
87720>>>>>>>
87720>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87721>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87722>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87723>>>>>>>
87723>>>>>>>        Function_Return (Err = False)
87724>>>>>>>    End_Function
87725>>>>>>>
87725>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87727>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87727>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87728>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87728>>>>>>>        Boolean bRenameField
87728>>>>>>>
87728>>>>>>>        Open hTable
87730>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87731>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87732>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87733>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87736>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87737>>>>>>>        Decrement iSize
87738>>>>>>>        for iCount from 0 to iSize
87744>>>>>>>>
87744>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87746>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87747>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87748>>>>>>>
87748>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87750>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87752>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87753>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87754>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87756>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87757>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87758>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87759>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87760>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87761>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87762>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87763>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87764>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87765>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87766>>>>>>>                        Increment iItem
87767>>>>>>>                    End
87767>>>>>>>>
87767>>>>>>>                End
87767>>>>>>>>
87767>>>>>>>            End
87767>>>>>>>>
87767>>>>>>>        Loop
87768>>>>>>>>
87768>>>>>>>
87768>>>>>>>        Move False to Err
87769>>>>>>>        Move 0 to LastErr
87770>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87771>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87772>>>>>>>        Function_Return aAPIColumnsToInsert
87773>>>>>>>    End_Function
87774>>>>>>>
87774>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87776>>>>>>>        Integer iSize iCount
87776>>>>>>>        Boolean bOK
87776>>>>>>>        tAPIColumn[] aColumnsTo
87776>>>>>>>        tAPIColumn[] aColumnsTo
87777>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87777>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87778>>>>>>>
87778>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87779>>>>>>>        If (iSize = 0) Begin
87781>>>>>>>            Function_Return True
87782>>>>>>>        End
87782>>>>>>>>
87782>>>>>>>
87782>>>>>>>        Move False to Err
87783>>>>>>>        Decrement iSize
87784>>>>>>>        for iCount from 0 to iSize
87790>>>>>>>>
87790>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87791>>>>>>>        Loop
87792>>>>>>>>
87792>>>>>>>
87792>>>>>>>        Function_Return bOK
87793>>>>>>>    End_Function
87794>>>>>>>
87794>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
87794>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87796>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87796>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87797>>>>>>>        Integer iSize iCount iItem iShouldMove
87797>>>>>>>
87797>>>>>>>        Move 0 to iItem
87798>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87799>>>>>>>        Decrement iSize
87800>>>>>>>        for iCount from 0 to iSize
87806>>>>>>>>
87806>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87808>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87809>>>>>>>                If (iShouldMove <> -1) Begin
87811>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87812>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87813>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87814>>>>>>>                    Increment iItem
87815>>>>>>>                End
87815>>>>>>>>
87815>>>>>>>            End
87815>>>>>>>>
87815>>>>>>>        Loop
87816>>>>>>>>
87816>>>>>>>
87816>>>>>>>        Move False to Err
87817>>>>>>>        Move 0 to LastErr
87818>>>>>>>        Function_Return aAPIColumnsToMove
87819>>>>>>>    End_Function
87820>>>>>>>
87820>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87822>>>>>>>        Integer iSize iCount
87822>>>>>>>        Boolean bOK
87822>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87822>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87823>>>>>>>
87823>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87824>>>>>>>        If (iSize = 0) Begin
87826>>>>>>>            Function_Return True
87827>>>>>>>        End
87827>>>>>>>>
87827>>>>>>>
87827>>>>>>>        Move False to Err
87828>>>>>>>        Decrement iSize
87829>>>>>>>        for iCount from 0 to iSize
87835>>>>>>>>
87835>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87836>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87837>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87839>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87840>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87841>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87842>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87843>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87845>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87846>>>>>>>                    Decrement iSize
87847>>>>>>>                    Move 0 to iCount
87848>>>>>>>                End
87848>>>>>>>>
87848>>>>>>>            End
87848>>>>>>>>
87848>>>>>>>        Loop
87849>>>>>>>>
87849>>>>>>>
87849>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87850>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87851>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87853>>>>>>>            Move 0 to LastErr
87854>>>>>>>        End
87854>>>>>>>>
87854>>>>>>>        Function_Return bOK
87855>>>>>>>    End_Function
87856>>>>>>>
87856>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87856>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87856>>>>>>>    // - The "FROM" field name is <> "TO" field name
87856>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87856>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87856>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87858>>>>>>>        Boolean bShouldRename
87858>>>>>>>        String sFieldNameFrom sFieldNameTo
87858>>>>>>>
87858>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87859>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87860>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87862>>>>>>>            Function_Return False
87863>>>>>>>        End
87863>>>>>>>>
87863>>>>>>>
87863>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87864>>>>>>>//        If (bShouldRename = False) Begin
87864>>>>>>>//            Function_Return False
87864>>>>>>>//        End
87864>>>>>>>//
87864>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87864>>>>>>>//            Function_Return True
87864>>>>>>>//        End
87864>>>>>>>
87864>>>>>>>        Function_Return bShouldRename
87865>>>>>>>    End_Function
87866>>>>>>>
87866>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87866>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
87866>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87868>>>>>>>        Integer iCount iSize iRetval
87868>>>>>>>        String sFieldNameFrom
87868>>>>>>>
87868>>>>>>>        Move -1 to iRetval
87869>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87871>>>>>>>            Function_Return iRetval
87872>>>>>>>        End
87872>>>>>>>>
87872>>>>>>>
87872>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87873>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87874>>>>>>>        Decrement iSize
87875>>>>>>>        for iCount from 0 to iSize
87881>>>>>>>>
87881>>>>>>>            // We're only interested in fields other than the passed field/column number:
87881>>>>>>>            If (iCount <> iColumn) Begin
87883>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87885>>>>>>>                    Move (iCount + 1) to iRetval
87886>>>>>>>                End
87886>>>>>>>>
87886>>>>>>>            End
87886>>>>>>>>
87886>>>>>>>        Loop
87887>>>>>>>>
87887>>>>>>>
87887>>>>>>>        Move 0 to LastErr
87888>>>>>>>        Function_Return iRetval
87889>>>>>>>    End_Function
87890>>>>>>>
87890>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87892>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
87892>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
87893>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
87893>>>>>>>        Boolean bRenameField
87893>>>>>>>
87893>>>>>>>        Open hTable
87895>>>>>>>        Move 0 to iItem
87896>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87897>>>>>>>        Decrement iSize
87898>>>>>>>        for iCount from 0 to iSize
87904>>>>>>>>
87904>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87906>>>>>>>                // Check if the field exists in another position (other field number)
87906>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87907>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
87908>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
87910>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
87911>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
87912>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
87913>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
87914>>>>>>>                    Increment iItem
87915>>>>>>>                End
87915>>>>>>>>
87915>>>>>>>            End
87915>>>>>>>>
87915>>>>>>>        Loop
87916>>>>>>>>
87916>>>>>>>
87916>>>>>>>        Move False to Err
87917>>>>>>>        Move 0 to LastErr
87918>>>>>>>        Function_Return aAPIColumnsToRename
87919>>>>>>>    End_Function
87920>>>>>>>
87920>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
87922>>>>>>>        Integer iSize iCount
87922>>>>>>>        Boolean bOK
87922>>>>>>>        tAPIColumn[] aColumnsTo
87922>>>>>>>        tAPIColumn[] aColumnsTo
87923>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87923>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87924>>>>>>>
87924>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
87925>>>>>>>        If (iSize = 0) Begin
87927>>>>>>>            Function_Return True
87928>>>>>>>        End
87928>>>>>>>>
87928>>>>>>>
87928>>>>>>>        Move False to Err
87929>>>>>>>        Decrement iSize
87930>>>>>>>        For iCount from 0 to iSize
87936>>>>>>>>
87936>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87937>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
87938>>>>>>>        Loop
87939>>>>>>>>
87939>>>>>>>
87939>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87940>>>>>>>        Function_Return bOK
87941>>>>>>>    End_Function
87942>>>>>>>
87942>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
87944>>>>>>>        Boolean bDateType
87944>>>>>>>
87944>>>>>>>        If (bIsSQLTableTo = True) Begin
87946>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
87947>>>>>>>        End
87947>>>>>>>>
87947>>>>>>>        Else Begin
87948>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
87949>>>>>>>        End
87949>>>>>>>>
87949>>>>>>>
87949>>>>>>>        Function_Return bDateType
87950>>>>>>>    End_Function
87951>>>>>>>
87951>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
87953>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
87953>>>>>>>        Integer iCount2 iColumn2
87953>>>>>>>        Handle hFile
87953>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
87953>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
87953>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
87953>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87953>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
87958>>>>>>>        tColumnType ColumnType
87958>>>>>>>        tColumnType ColumnType
87958>>>>>>>
87958>>>>>>>        Move False to Err
87959>>>>>>>        Close hTable
87960>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
87961>>>>>>>        If (bIsOpen = False) Begin
87963>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
87964>>>>>>>>
87964>>>>>>>            Function_Return False
87965>>>>>>>        End 
87965>>>>>>>>
87965>>>>>>>        
87965>>>>>>>        Get piDbType to iDbType
87966>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87969>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
87970>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
87971>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
87974>>>>>>>
87974>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87975>>>>>>>
87975>>>>>>>        // Before we start to change the table we need to do three things;
87975>>>>>>>        // 1) Insert any new fields
87975>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
87976>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
87978>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
87979>>>>>>>            If (bOK = False) Begin
87981>>>>>>>                Function_Return False
87982>>>>>>>            End
87982>>>>>>>>
87982>>>>>>>            // Update info with changes made.
87982>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87983>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87984>>>>>>>        End
87984>>>>>>>>
87984>>>>>>>
87984>>>>>>>        // 2) Move fields with same names
87984>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
87985>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
87987>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
87988>>>>>>>            If (bOK = False) Begin
87990>>>>>>>                Function_Return False
87991>>>>>>>            End
87991>>>>>>>>
87991>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
87992>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87993>>>>>>>        End
87993>>>>>>>>
87993>>>>>>>        
87993>>>>>>>        // 3) Rename fields
87993>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
87994>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
87996>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
87997>>>>>>>            If (bOK = False) Begin
87999>>>>>>>                Function_Return False
88000>>>>>>>            End
88000>>>>>>>>
88000>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88001>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88002>>>>>>>        End
88002>>>>>>>>
88002>>>>>>>
88002>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88002>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88002>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88002>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88002>>>>>>>//            If (bOK = False) Begin
88002>>>>>>>//                Function_Return False
88002>>>>>>>//            End
88002>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88002>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88002>>>>>>>//        End
88002>>>>>>>
88002>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88002>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88004>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88005>>>>>>>            If (bIsSame = True) Begin
88007>>>>>>>                Function_Return True
88008>>>>>>>            End
88008>>>>>>>>
88008>>>>>>>        End
88008>>>>>>>>
88008>>>>>>>
88008>>>>>>>        // We can now continue to make standard field changes:
88008>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88009>>>>>>>        Set Private.phCurrentTable to hTable
88010>>>>>>>        Move hTable to hFile
88011>>>>>>>        Structure_Start hFile sDriverIDTo
88012>>>>>>>
88012>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88013>>>>>>>            Decrement iColumns
88014>>>>>>>            for iCount from 0 to iColumns
88020>>>>>>>>
88020>>>>>>>                Send DoAdvance of ghoProgressBar
88021>>>>>>>
88021>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88022>>>>>>>                Set Private.piCurrentField                  to iColumn
88023>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88024>>>>>>>                If (bIsSame = False) Begin
88026>>>>>>>
88026>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88027>>>>>>>                    If (bFieldExistsFrom = True) Begin
88029>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88030>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88031>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88032>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88033>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88034>>>>>>>
88034>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88035>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88036>>>>>>>                        If (iTypeFrom < -1490) Begin
88038>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88039>>>>>>>                        End
88039>>>>>>>>
88039>>>>>>>
88039>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88039>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88039>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88041>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88042>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88044>>>>>>>                                Move DF_DATE to iTypeFrom
88045>>>>>>>                            End
88045>>>>>>>>
88045>>>>>>>                        End
88045>>>>>>>>
88045>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88048>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88049>>>>>>>                        End
88049>>>>>>>>
88049>>>>>>>
88049>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88050>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88051>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88052>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88053>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88054>>>>>>>
88054>>>>>>>                        Move False to bSkipTypeChange
88055>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88057>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88058>>>>>>>                        End
88058>>>>>>>>
88058>>>>>>>
88058>>>>>>>                        If (bFieldExistsTo = False) Begin
88060>>>>>>>                            Move 0 to iColumn
88061>>>>>>>                            Create_Field hFile At iColumn
88062>>>>>>>                            Set Private.piCurrentField to iColumn
88063>>>>>>>                        End
88063>>>>>>>>
88063>>>>>>>
88063>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88065>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88068>>>>>>>                        End
88068>>>>>>>>
88068>>>>>>>
88068>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88070>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88073>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88074>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88076>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88077>>>>>>>                            End
88077>>>>>>>>
88077>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88080>>>>>>>                        End
88080>>>>>>>>
88080>>>>>>>
88080>>>>>>>                        If (bSkipTypeChange = False) Begin
88082>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88084>>>>>>>                                If (bIsSQLTableTo = True) Begin
88086>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88089>>>>>>>                                End
88089>>>>>>>>
88089>>>>>>>                                Else Begin                                                   
88090>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88092>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88093>>>>>>>                                    End
88093>>>>>>>>
88093>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88096>>>>>>>                                End
88096>>>>>>>>
88096>>>>>>>                            End
88096>>>>>>>>
88096>>>>>>>                        End
88096>>>>>>>>
88096>>>>>>>
88096>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88097>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88097>>>>>>>                        If (bIsDateType = False) Begin
88099>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88101>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88104>>>>>>>                            End
88104>>>>>>>>
88104>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88106>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88109>>>>>>>                            End
88109>>>>>>>>
88109>>>>>>>                        End
88109>>>>>>>>
88109>>>>>>>
88109>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88111>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88111>>>>>>>                            If (bRecnumTable = True) Begin
88113>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88116>>>>>>>                            End
88116>>>>>>>>
88116>>>>>>>
88116>>>>>>>                            // We might need to create an index here.
88116>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88116>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88116>>>>>>>                            // index update checking logic.
88116>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88119>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88121>>>>>>>                                Create_Index hFile at iIndex
88122>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88125>>>>>>>                            End
88125>>>>>>>>
88125>>>>>>>
88125>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88128>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88131>>>>>>>                                // Note: The order here is crucial!
88131>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88134>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88137>>>>>>>                        End
88137>>>>>>>>
88137>>>>>>>                    End
88137>>>>>>>>
88137>>>>>>>                    Else Begin
88138>>>>>>>                        Delete_Field hFile iColumn
88139>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88140>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88141>>>>>>>                        Decrement iCount2
88142>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88142>>>>>>>                        // starting with the array number we just deleted the field for.
88142>>>>>>>                        for iColumn2 from iCount to iCount2
88148>>>>>>>>
88148>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88149>>>>>>>                        Loop
88150>>>>>>>>
88150>>>>>>>                        Decrement iCount
88151>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88152>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88153>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88155>>>>>>>                            Move iColumns to iCount 
88156>>>>>>>                        End
88156>>>>>>>>
88156>>>>>>>                    End
88156>>>>>>>>
88156>>>>>>>                End
88156>>>>>>>>
88156>>>>>>>            Loop
88157>>>>>>>>
88157>>>>>>>
88157>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88158>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88160>>>>>>>
88160>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88161>>>>>>>        Function_Return (Err = False)
88162>>>>>>>    End_Function
88163>>>>>>>
88163>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88163>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88165>>>>>>>        Function_Return False
88166>>>>>>>    End_Function
88167>>>>>>>
88167>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88167>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88167>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88167>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88169>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88169>>>>>>>        String sDriverID
88169>>>>>>>        Boolean bOK bExists bIsSQLTable
88169>>>>>>>
88169>>>>>>>        Get AutoConnectionIDLogin to bOK
88170>>>>>>>        Get OpenTableExclusive hTable to bOK
88171>>>>>>>        If (bOK = False) Begin
88173>>>>>>>            Function_Return False
88174>>>>>>>        End
88174>>>>>>>>
88174>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88177>>>>>>>
88177>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88178>>>>>>>            If (bIsSQLTable = True) Begin
88180>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88183>>>>>>>            End
88183>>>>>>>>
88183>>>>>>>
88183>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88186>>>>>>>        Move (iIndexSegments > 0) to bExists
88187>>>>>>>        If (bExists = True) Begin
88189>>>>>>>            Function_Return True
88190>>>>>>>        End
88190>>>>>>>>
88190>>>>>>>
88190>>>>>>>        Move -1 to iSegment1
88191>>>>>>>        Move -1 to iSegment2
88192>>>>>>>        Move -1 to iSegment3
88193>>>>>>>        Move -1 to iSegment4
88194>>>>>>>        Move -1 to iSegment5
88195>>>>>>>        Move -1 to iSegment6
88196>>>>>>>        Move -1 to iSegment7
88197>>>>>>>        Move -1 to iSegment8
88198>>>>>>>        Move -1 to iSegment9
88199>>>>>>>        Move -1 to iSegment10
88200>>>>>>>
88200>>>>>>>        If (num_arguments > 3) Begin
88202>>>>>>>            Move iSgmnt1 to iSegment1
88203>>>>>>>        End
88203>>>>>>>>
88203>>>>>>>        If (num_arguments > 4) Begin
88205>>>>>>>            Move iSgmnt2 to iSegment2
88206>>>>>>>        End
88206>>>>>>>>
88206>>>>>>>        If (num_arguments > 5) Begin
88208>>>>>>>            Move iSgmnt3 to iSegment3
88209>>>>>>>        End
88209>>>>>>>>
88209>>>>>>>        If (num_arguments > 6) Begin
88211>>>>>>>            Move iSgmnt4 to iSegment4
88212>>>>>>>        End
88212>>>>>>>>
88212>>>>>>>        If (num_arguments > 7) Begin
88214>>>>>>>            Move iSgmnt5 to iSegment5
88215>>>>>>>        End
88215>>>>>>>>
88215>>>>>>>        If (num_arguments > 8) Begin
88217>>>>>>>            Move iSgmnt6 to iSegment6
88218>>>>>>>        End
88218>>>>>>>>
88218>>>>>>>        If (num_arguments > 9) Begin
88220>>>>>>>            Move iSgmnt7 to iSegment7
88221>>>>>>>        End
88221>>>>>>>>
88221>>>>>>>        If (num_arguments > 10) Begin
88223>>>>>>>            Move iSgmnt8 to iSegment8
88224>>>>>>>        End
88224>>>>>>>>
88224>>>>>>>        If (num_arguments > 11) Begin
88226>>>>>>>            Move iSgmnt9 to iSegment9
88227>>>>>>>        End
88227>>>>>>>>
88227>>>>>>>        If (num_arguments > 12) Begin
88229>>>>>>>            Move iSgmnt10 to iSegment10
88230>>>>>>>        End
88230>>>>>>>>
88230>>>>>>>
88230>>>>>>>        Move False to Err
88231>>>>>>>        Move hTable to iTableNo
88232>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88233>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88234>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88235>>>>>>>
88235>>>>>>>        // We start by deleting the index, if it exists.
88235>>>>>>>        If (bExists = True) Begin
88237>>>>>>>            Structure_Start hTable sDriverID
88238>>>>>>>                Delete_Index iTableNo iIndex
88239>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88240>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88242>>>>>>>        End
88242>>>>>>>>
88242>>>>>>>
88242>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88243>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88244>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88245>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88246>>>>>>>        Move False to Err
88247>>>>>>>        Move 0 to LastErr
88248>>>>>>>
88248>>>>>>>        // Need to re-open if index deleted.
88248>>>>>>>        Move iTableNo to hTable
88249>>>>>>>        Get OpenTableExclusive hTable to bOK
88250>>>>>>>        If (bOK = False) Begin
88252>>>>>>>            Function_Return False
88253>>>>>>>        End
88253>>>>>>>>
88253>>>>>>>
88253>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88254>>>>>>>        Structure_Start hTable sDriverID
88255>>>>>>>            Create_Index hTable At iIndex
88256>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88259>>>>>>>
88259>>>>>>>            If (iSgmnt1 <> -1) Begin
88261>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88264>>>>>>>            End
88264>>>>>>>>
88264>>>>>>>            If (iSegment2 <> -1) Begin
88266>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88269>>>>>>>            End
88269>>>>>>>>
88269>>>>>>>            If (iSegment3 <> -1) Begin
88271>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88274>>>>>>>            End
88274>>>>>>>>
88274>>>>>>>            If (iSegment4 <> -1) Begin
88276>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88279>>>>>>>            End
88279>>>>>>>>
88279>>>>>>>            If (iSegment5 <> -1) Begin
88281>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88284>>>>>>>            End
88284>>>>>>>>
88284>>>>>>>            If (iSegment6 <> -1) Begin
88286>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88289>>>>>>>            End
88289>>>>>>>>
88289>>>>>>>            If (iSegment7 <> -1) Begin
88291>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88294>>>>>>>            End
88294>>>>>>>>
88294>>>>>>>            If (iSegment8 <> -1) Begin
88296>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88299>>>>>>>            End
88299>>>>>>>>
88299>>>>>>>            If (iSegment9 <> -1) Begin
88301>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88304>>>>>>>            End
88304>>>>>>>>
88304>>>>>>>            If (iSegment10 <> -1) Begin
88306>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88309>>>>>>>            End
88309>>>>>>>>
88309>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88310>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88312>>>>>>>
88312>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88313>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88314>>>>>>>
88314>>>>>>>        Function_Return (Err = False)
88315>>>>>>>    End_Function
88316>>>>>>>
88316>>>>>>>    // Example:
88316>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88316>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88316>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88318>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88318>>>>>>>        String sDriverID
88318>>>>>>>        Boolean bOK bIsSQLTable
88318>>>>>>>
88318>>>>>>>        Get AutoConnectionIDLogin to bOK
88319>>>>>>>
88319>>>>>>>        Move False to Err
88320>>>>>>>        Move hTable to iTableNo
88321>>>>>>>        Get OpenTableExclusive hTable to bOK
88322>>>>>>>        If (bOK = False) Begin
88324>>>>>>>            Function_Return False
88325>>>>>>>        End
88325>>>>>>>>
88325>>>>>>>
88325>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88328>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88329>>>>>>>            If (bIsSQLTable = True) Begin
88331>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88334>>>>>>>            End
88334>>>>>>>>
88334>>>>>>>
88334>>>>>>>        // We start by deleting the index
88334>>>>>>>        Structure_Start hTable sDriverID
88335>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88336>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88337>>>>>>>            Delete_Index iTableNo iIndex
88338>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88339>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88340>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88342>>>>>>>
88342>>>>>>>        Move False to Err
88343>>>>>>>        Move iTableNo to hTable
88344>>>>>>>        Get OpenTableExclusive hTable to bOK
88345>>>>>>>        If (bOK = False) Begin
88347>>>>>>>            Function_Return False
88348>>>>>>>        End
88348>>>>>>>>
88348>>>>>>>
88348>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88349>>>>>>>        Structure_Start hTable sDriverID
88350>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88351>>>>>>>
88351>>>>>>>            Create_Index hTable at iIndex
88352>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88355>>>>>>>
88355>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88361>>>>>>>>
88361>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88364>>>>>>>            Loop
88365>>>>>>>>
88365>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88367>>>>>>>
88367>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88368>>>>>>>
88368>>>>>>>        Function_Return (Err = False)
88369>>>>>>>    End_Function
88370>>>>>>>
88370>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88372>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88372>>>>>>>        String sDriverID sSQLIndexName
88372>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88372>>>>>>>
88372>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88373>>>>>>>        If (iSegmentsFrom = 0) Begin
88375>>>>>>>            Function_Return False
88376>>>>>>>        End
88376>>>>>>>>
88376>>>>>>>
88376>>>>>>>        Get AutoConnectionIDLogin to bOK
88377>>>>>>>        Move False to Err
88378>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88379>>>>>>>        If (bIsOpen = False) Begin
88381>>>>>>>            Function_Return False
88382>>>>>>>        End
88382>>>>>>>>
88382>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88385>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88386>>>>>>>            If (bIsSQLTable = True) Begin
88388>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88391>>>>>>>            End
88391>>>>>>>>
88391>>>>>>>
88391>>>>>>>        Move 0     to iSegmentsTo
88392>>>>>>>        Move 0     to iSQLIndexType
88393>>>>>>>        Move ""    to sSQLIndexName
88394>>>>>>>        Move False to bIsSQLTemporaryIndex
88395>>>>>>>        Move False to bIsSQLPrimaryKey
88396>>>>>>>        Move False to bIsSQLClustered
88397>>>>>>>
88397>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88398>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88401>>>>>>>        Move (iSegmentsTo > 0) to bExists
88402>>>>>>>        If (bExists = True) Begin
88404>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88406>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88409>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88412>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88413>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88416>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88419>>>>>>>            End
88419>>>>>>>>
88419>>>>>>>        End
88419>>>>>>>>
88419>>>>>>>
88419>>>>>>>        Move hTable to iTableNo
88420>>>>>>>        Move False to Err
88421>>>>>>>        Move 0 to LastErr
88422>>>>>>>
88422>>>>>>>        Structure_Start hTable sDriverID
88423>>>>>>>            If (bExists = True) Begin
88425>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88426>>>>>>>            End
88426>>>>>>>>
88426>>>>>>>
88426>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88427>>>>>>>
88427>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88429>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88432>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88435>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88438>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88441>>>>>>>                End
88441>>>>>>>>
88441>>>>>>>
88441>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88444>>>>>>>
88444>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88450>>>>>>>>
88450>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88451>>>>>>>                If (iFieldFrom <> -1 ) Begin
88453>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88456>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88459>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88462>>>>>>>                End
88462>>>>>>>>
88462>>>>>>>            Loop
88463>>>>>>>>
88463>>>>>>>
88463>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88464>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88466>>>>>>>
88466>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88467>>>>>>>
88467>>>>>>>        Function_Return (Err = False)
88468>>>>>>>    End_Function
88469>>>>>>>
88469>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88469>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88469>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88471>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88471>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88471>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
88471>>>>>>>
88471>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88472>>>>>>>        
88472>>>>>>>        If (bIsSQLDriver = False) Begin
88474>>>>>>>            Function_Return False
88475>>>>>>>        End
88475>>>>>>>>
88475>>>>>>>
88475>>>>>>>        Move False to Err
88476>>>>>>>        Move hTable to iTableNo
88477>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88480>>>>>>>        for iCount from 0 to iLastIndex
88486>>>>>>>>
88486>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88489>>>>>>>            Move (iSegments > 0) to bExists
88490>>>>>>>            If (bExists = True) Begin
88492>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88495>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88497>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88498>>>>>>>                    Structure_Start iTableNo sDriverID
88499>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88502>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88504>>>>>>>                    Open hTable
88506>>>>>>>                End
88506>>>>>>>>
88506>>>>>>>            End
88506>>>>>>>>
88506>>>>>>>        Loop
88507>>>>>>>>
88507>>>>>>>
88507>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88510>>>>>>>        If (bIsOpen = False) Begin
88512>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88513>>>>>>>        End
88513>>>>>>>>
88513>>>>>>>        If (bIsOpen = False) Begin
88515>>>>>>>            Function_Return False
88516>>>>>>>        End
88516>>>>>>>>
88516>>>>>>>
88516>>>>>>>        Function_Return (Err = False)
88517>>>>>>>    End_Function
88518>>>>>>>
88518>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88518>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88518>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88520>>>>>>>        Integer iSize iCount
88520>>>>>>>        Integer iRetVal
88520>>>>>>>
88520>>>>>>>        Move 0 to iRetVal
88521>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88524>>>>>>>        If (iRetVal = 0) Begin
88526>>>>>>>            Function_Return 0
88527>>>>>>>        End
88527>>>>>>>>
88527>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88528>>>>>>>        Decrement iSize
88529>>>>>>>        for iCount from 0 to iSize
88535>>>>>>>>
88535>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88537>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88539>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88540>>>>>>>                End
88540>>>>>>>>
88540>>>>>>>            End
88540>>>>>>>>
88540>>>>>>>        Loop
88541>>>>>>>>
88541>>>>>>>
88541>>>>>>>        Function_Return iRetVal
88542>>>>>>>    End_Function
88543>>>>>>>
88543>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88545>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88545>>>>>>>        Boolean bIsSQLTable
88545>>>>>>>        
88545>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88546>>>>>>>            If (bIsSQLTable = True) Begin
88548>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88551>>>>>>>            End
88551>>>>>>>>
88551>>>>>>>
88551>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88554>>>>>>>        If (iSegment = iNumSegments) Begin
88556>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88556>>>>>>>        End
88556>>>>>>>>
88556>>>>>>>
88556>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88559>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88565>>>>>>>>
88565>>>>>>>                //*** Move index segment attributes
88565>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88568>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88571>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88574>>>>>>>
88574>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88577>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88580>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88583>>>>>>>            Loop
88584>>>>>>>>
88584>>>>>>>
88584>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88587>>>>>>>        End
88587>>>>>>>>
88587>>>>>>>
88587>>>>>>>        Function_Return (Err = False)
88588>>>>>>>    End_Function
88589>>>>>>>
88589>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88591>>>>>>>        Integer iCount iSize iIndex
88591>>>>>>>        String sDriverID
88591>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88591>>>>>>>
88591>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88592>>>>>>>        If (iSize = 0) Begin
88594>>>>>>>            Function_Return True
88595>>>>>>>        End
88595>>>>>>>>
88595>>>>>>>
88595>>>>>>>        Get AutoConnectionIDLogin to bOK
88596>>>>>>>        Move False to Err
88597>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88600>>>>>>>        If (bIsOpen = False) Begin
88602>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88603>>>>>>>            If (bIsOpen = False) Begin
88605>>>>>>>                Function_Return False
88606>>>>>>>            End
88606>>>>>>>>
88606>>>>>>>        End
88606>>>>>>>>
88606>>>>>>>
88606>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88609>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88610>>>>>>>            If (bIsSQLTable = True) Begin
88612>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88615>>>>>>>            End
88615>>>>>>>>
88615>>>>>>>
88615>>>>>>>        Move False to Err
88616>>>>>>>        Move 0 to LastErr
88617>>>>>>>        Decrement iSize
88618>>>>>>>
88618>>>>>>>        Structure_Start hTable sDriverID
88619>>>>>>>            for iCount from 0 to iSize
88625>>>>>>>>
88625>>>>>>>//                Move False to bIsSQLPrimaryKey
88625>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88625>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88625>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88625>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88625>>>>>>>//                #ENDIF
88625>>>>>>>                // We can't delete if this is a primary key index:
88625>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88625>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88626>>>>>>>                    Delete_Index hTable iIndex
88627>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88627>>>>>>>//                End
88627>>>>>>>            Loop
88628>>>>>>>>
88628>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88629>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88631>>>>>>>//        Move False to Err
88631>>>>>>>        Move 0 to LastErr
88632>>>>>>>
88632>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88633>>>>>>>        Function_Return (Err = False)
88634>>>>>>>    End_Function
88635>>>>>>>
88635>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88637>>>>>>>        Boolean bOK
88637>>>>>>>
88637>>>>>>>        Get AutoConnectionIDLogin to bOK
88638>>>>>>>        Move False to Err
88639>>>>>>>        Get OpenTableExclusive hTable to bOK
88640>>>>>>>        If (bOK = False) Begin
88642>>>>>>>            Function_Return False
88643>>>>>>>        End
88643>>>>>>>>
88643>>>>>>>        Structure_Start hTable
88644>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88647>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88648>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88650>>>>>>>
88650>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88651>>>>>>>        Function_Return (Err = False)
88652>>>>>>>    End_Function
88653>>>>>>>
88653>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88655>>>>>>>        Integer iCase
88655>>>>>>>        Boolean bOK
88655>>>>>>>
88655>>>>>>>        If (bUppercase = True) Begin
88657>>>>>>>            Move DF_CASE_IGNORED to iCase
88658>>>>>>>        End
88658>>>>>>>>
88658>>>>>>>        Else Begin
88659>>>>>>>            Move DF_CASE_USED to iCase
88660>>>>>>>        End
88660>>>>>>>>
88660>>>>>>>
88660>>>>>>>        Get AutoConnectionIDLogin to bOK
88661>>>>>>>        Move False to Err
88662>>>>>>>        Get OpenTableExclusive hTable to bOK
88663>>>>>>>        If (bOK = False) Begin
88665>>>>>>>            Function_Return False
88666>>>>>>>        End
88666>>>>>>>>
88666>>>>>>>        Structure_Start hTable
88667>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88670>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88671>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88673>>>>>>>
88673>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88674>>>>>>>        Function_Return (Err = False)
88675>>>>>>>    End_Function
88676>>>>>>>
88676>>>>>>>    // To delete an index
88676>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88678>>>>>>>        Integer iTableNo iNumSegments
88678>>>>>>>        String sDriverID
88678>>>>>>>        Boolean bOK bIsSQLTable
88678>>>>>>>
88678>>>>>>>        Get AutoConnectionIDLogin to bOK
88679>>>>>>>        Move False to Err
88680>>>>>>>        Move hTable to iTableNo
88681>>>>>>>        Get OpenTableExclusive hTable to bOK
88682>>>>>>>        If (bOK = False) Begin
88684>>>>>>>            Function_Return False
88685>>>>>>>        End
88685>>>>>>>>
88685>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88688>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88689>>>>>>>            If (bIsSQLTable = True) Begin
88691>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88694>>>>>>>            End
88694>>>>>>>>
88694>>>>>>>
88694>>>>>>>        // Check to see if the index exists or not...
88694>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88697>>>>>>>        If (iNumSegments = 0) Begin
88699>>>>>>>            Function_Return True // Then nothing to do.
88700>>>>>>>        End
88700>>>>>>>>
88700>>>>>>>
88700>>>>>>>        Structure_Start hTable sDriverID
88701>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88702>>>>>>>            Delete_Index iTableNo iIndex
88703>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88704>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88705>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88707>>>>>>>
88707>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88708>>>>>>>        Function_Return (Err = False)
88709>>>>>>>    End_Function
88710>>>>>>>
88710>>>>>>>    // Delete an Index Segment
88710>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88712>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88712>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88712>>>>>>>        Integer iIndexType
88712>>>>>>>        String sDriverID
88712>>>>>>>
88712>>>>>>>        Get AutoConnectionIDLogin to bOK
88713>>>>>>>        Move False to Err
88714>>>>>>>
88714>>>>>>>        Get OpenTableExclusive hTable to bOK
88715>>>>>>>        If (bOK = False) Begin
88717>>>>>>>            Function_Return False
88718>>>>>>>        End
88718>>>>>>>>
88718>>>>>>>
88718>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88719>>>>>>>            If (bIsSQLTable = True) Begin
88721>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88724>>>>>>>            End
88724>>>>>>>>
88724>>>>>>>
88724>>>>>>>        // Check to see if the index exists or not...
88724>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88727>>>>>>>        If (iNumSegments = 0) Begin
88729>>>>>>>            Function_Return False
88730>>>>>>>        End
88730>>>>>>>>
88730>>>>>>>
88730>>>>>>>        Move False to bIndexTemporary
88731>>>>>>>        Get psDriverID to sDriverID
88732>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88733>>>>>>>        If (bSQLDriver) Begin
88735>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88738>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88741>>>>>>>                Move True to bIndexTemporary
88742>>>>>>>        End
88742>>>>>>>>
88742>>>>>>>
88742>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88742>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88744>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88747>>>>>>>            If (iSegment = iNumSegments) Begin
88749>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88752>>>>>>>            End
88752>>>>>>>>
88752>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88755>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88761>>>>>>>>
88761>>>>>>>                    //*** Move index segment attributes
88761>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88764>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88767>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88770>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88773>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88776>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88779>>>>>>>                Loop
88780>>>>>>>>
88780>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88783>>>>>>>            End
88783>>>>>>>>
88783>>>>>>>        End
88783>>>>>>>>
88783>>>>>>>
88783>>>>>>>        Else Begin
88784>>>>>>>           Structure_Start hTable
88785>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88788>>>>>>>               If (iSegment = iNumSegments) Begin
88790>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88793>>>>>>>               End
88793>>>>>>>>
88793>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88796>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88802>>>>>>>>
88802>>>>>>>                       //*** Move index segment attributes
88802>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88805>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88808>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88811>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88814>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88817>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88820>>>>>>>                   Loop
88821>>>>>>>>
88821>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88824>>>>>>>               End
88824>>>>>>>>
88824>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88825>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88827>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88828>>>>>>>        End
88828>>>>>>>>
88828>>>>>>>
88828>>>>>>>        Function_Return (Err = False)
88829>>>>>>>    End_Function
88830>>>>>>>
88830>>>>>>>    // Add/Insert an Index Segment
88830>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88832>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88832>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88832>>>>>>>        Integer iIndexType
88832>>>>>>>        String sDriverId
88832>>>>>>>
88832>>>>>>>        Get AutoConnectionIDLogin to bOK
88833>>>>>>>        Move False to Err
88834>>>>>>>
88834>>>>>>>        Get OpenTableExclusive hTable to bOK
88835>>>>>>>        If (bOK = False) Begin
88837>>>>>>>            Function_Return False
88838>>>>>>>        End
88838>>>>>>>>
88838>>>>>>>
88838>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88839>>>>>>>            If (bIsSQLTable = True) Begin
88841>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88844>>>>>>>            End
88844>>>>>>>>
88844>>>>>>>
88844>>>>>>>        Move False to bIndexTemporary
88845>>>>>>>        // Check to see if the index exists or not...
88845>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88848>>>>>>>        If (iNumSegments = 0) Begin
88850>>>>>>>            Function_Return False
88851>>>>>>>        End
88851>>>>>>>>
88851>>>>>>>
88851>>>>>>>        Get psDriverID to sDriverID
88852>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88853>>>>>>>        If (bSQLDriver) Begin
88855>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88858>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88861>>>>>>>                Move True to bIndexTemporary
88862>>>>>>>        End
88862>>>>>>>>
88862>>>>>>>
88862>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88862>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88864>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88867>>>>>>>
88867>>>>>>>           If (iSegment > iNumSegments) Begin
88869>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88872>>>>>>>               Move (iNumSegments + 1) to iCurSegment
88873>>>>>>>           End
88873>>>>>>>>
88873>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88876>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88879>>>>>>>               Move iNumSegments to iCurSegment
88880>>>>>>>
88880>>>>>>>               While (iCurSegment > iSegment)
88884>>>>>>>                   //*** Move index segment attributes
88884>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88887>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
88890>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88893>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
88896>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
88899>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
88902>>>>>>>                   Decrement iCurSegment
88903>>>>>>>               Loop
88904>>>>>>>>
88904>>>>>>>
88904>>>>>>>               //*** Now set new segment attributes
88904>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88907>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88910>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88913>>>>>>>           End
88913>>>>>>>>
88913>>>>>>>        End
88913>>>>>>>>
88913>>>>>>>
88913>>>>>>>        Else Begin
88914>>>>>>>        Structure_Start hTable
88915>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88918>>>>>>>
88918>>>>>>>            If (iSegment > iNumSegments) Begin
88920>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88923>>>>>>>                Move (iNumSegments + 1) to iCurSegment
88924>>>>>>>            End
88924>>>>>>>>
88924>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88927>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88930>>>>>>>                Move iNumSegments to iCurSegment
88931>>>>>>>
88931>>>>>>>                While (iCurSegment > iSegment)
88935>>>>>>>                    //*** Move index segment attributes
88935>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
88938>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
88941>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88944>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88947>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88950>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88953>>>>>>>                    Decrement iCurSegment
88954>>>>>>>                Loop
88955>>>>>>>>
88955>>>>>>>
88955>>>>>>>                //*** Now set new segment attributes
88955>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
88958>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
88961>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
88964>>>>>>>            End
88964>>>>>>>>
88964>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88965>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88967>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88968>>>>>>>        End
88968>>>>>>>>
88968>>>>>>>
88968>>>>>>>        Function_Return (Err = False)
88969>>>>>>>    End_Function
88970>>>>>>>
88970>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88970>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
88972>>>>>>>        Function_Return False
88973>>>>>>>    End_Function  
88974>>>>>>>    
88974>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
88974>>>>>>>    // for an SQL conversion.
88974>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
88976>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
88976>>>>>>>        
88976>>>>>>>        Move True to bConvertTo30FormatbOK
88977>>>>>>>        Move True to bRepairAndReindexOK
88978>>>>>>>        Move True to bFixBogusDatesOK
88979>>>>>>>        Move True to bMoveMiscFilesToBackupOK
88980>>>>>>>        
88980>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
88982>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
88983>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
88984>>>>>>>        End                                                                                
88984>>>>>>>>
88984>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
88986>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
88987>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
88988>>>>>>>        End
88988>>>>>>>>
88988>>>>>>>        If (bConvertTo30Format = True) Begin
88990>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
88991>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
88992>>>>>>>        End                                                 
88992>>>>>>>>
88992>>>>>>>        If (bRepairAndReindex = True) Begin
88994>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
88995>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
88996>>>>>>>        End  
88996>>>>>>>>
88996>>>>>>>        If (bFixBogusDates = True) Begin
88998>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
88999>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89000>>>>>>>        End                                    
89000>>>>>>>>
89000>>>>>>>        
89000>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89001>>>>>>>    End_Function
89002>>>>>>>
89002>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89004>>>>>>>        Boolean bOK bFlexErrs bTemp
89004>>>>>>>        Handle hTable
89004>>>>>>>        String sTableName
89004>>>>>>>        Integer iCount iSize
89004>>>>>>>        
89004>>>>>>>        Move True to bOK
89005>>>>>>>        Move 0 to hTable    
89006>>>>>>>
89006>>>>>>>        Get UtilFilelistNoOfTables to iSize
89007>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89008>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89009>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89010>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89011>>>>>>>
89011>>>>>>>        Repeat
89011>>>>>>>>
89011>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89012>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89013>>>>>>>            Increment iCount
89014>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89017>>>>>>>            If (hTable > 0) Begin
89019>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89022>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89023>>>>>>>                If (bFlexErrs = False) Begin
89025>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89026>>>>>>>                    If (bTemp = False) Begin
89028>>>>>>>                        Move False to bOK
89029>>>>>>>                    End
89029>>>>>>>>
89029>>>>>>>                End
89029>>>>>>>>
89029>>>>>>>            End
89029>>>>>>>>
89029>>>>>>>        Until (hTable = 0)
89031>>>>>>>        
89031>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89032>>>>>>>        Function_Return bOK
89033>>>>>>>    End_Function
89034>>>>>>>    
89034>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89034>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89034>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89034>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89036>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89036>>>>>>>        String sRevision
89036>>>>>>>        
89036>>>>>>>        Get AutoConnectionIDLogin to bOK
89037>>>>>>>        If (bOK = False) Begin
89039>>>>>>>            Function_Return True
89040>>>>>>>        End
89040>>>>>>>>
89040>>>>>>>        Get OpenTableExclusive hTable to bOK
89041>>>>>>>        If (bOK = False) Begin
89043>>>>>>>            Function_Return True
89044>>>>>>>        End
89044>>>>>>>>
89044>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89045>>>>>>>        If (bIsEmbedded = False) Begin
89047>>>>>>>            Function_Return True
89048>>>>>>>        End                             
89048>>>>>>>>
89048>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89049>>>>>>>        If (bIsAlias = True) Begin
89051>>>>>>>            Function_Return True
89052>>>>>>>        End                     
89052>>>>>>>>
89052>>>>>>>        
89052>>>>>>>        Move False to Err
89053>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89056>>>>>>>        If (sRevision contains "2.3") Begin
89058>>>>>>>            Move False to Err
89059>>>>>>>            Set Private.phCurrentTable to hTable
89060>>>>>>>            Structure_Start hTable    
89061>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89064>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89065>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89067>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89068>>>>>>>        End
89068>>>>>>>>
89068>>>>>>>        
89068>>>>>>>        Function_Return (Err = False)
89069>>>>>>>    End_Function
89070>>>>>>>
89070>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89072>>>>>>>        Boolean bIgnore bExists bOK bResponse
89072>>>>>>>        Handle hTable   
89072>>>>>>>        String sTableName
89072>>>>>>>        
89072>>>>>>>        Move False to Err 
89073>>>>>>>        Move True to bOK
89074>>>>>>>        Move 0 to hTable
89075>>>>>>>        Repeat
89075>>>>>>>>
89075>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89078>>>>>>>            If (hTable > 0) Begin
89080>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89083>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89084>>>>>>>                If (bIgnore = False) Begin
89086>>>>>>>                    Get _UtilTableExists hTable to bExists
89087>>>>>>>                    If (bExists = False) Begin
89089>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89090>>>>>>>                        If (bResponse = False) Begin
89092>>>>>>>                            Move False to bOK
89093>>>>>>>                        End
89093>>>>>>>>
89093>>>>>>>                        
89093>>>>>>>                    End
89093>>>>>>>>
89093>>>>>>>                End
89093>>>>>>>>
89093>>>>>>>            End
89093>>>>>>>>
89093>>>>>>>        Until (hTable = 0)                     
89095>>>>>>>        
89095>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89096>>>>>>>        Function_Return bOK
89097>>>>>>>    End_Function
89098>>>>>>>    
89098>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89098>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89098>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89098>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89098>>>>>>>    //
89098>>>>>>>    // The root of the problem is the following:
89098>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89098>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89098>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89098>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89098>>>>>>>    // an SQL error will be thrown;
89098>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89098>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89100>>>>>>>        Boolean bOK bIsAlias bIsSQL
89100>>>>>>>        Integer iCount iSize iDateSize
89100>>>>>>>        Handle hTable
89100>>>>>>>        String sLogicalName
89100>>>>>>>        Integer[] aTablesToCheck aDateFields
89102>>>>>>>
89102>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89103>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89104>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89105>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89106>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89107>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89108>>>>>>>
89108>>>>>>>        Move True to bOK
89109>>>>>>>        Decrement iSize
89110>>>>>>>        for iCount from 0 to iSize
89116>>>>>>>>
89116>>>>>>>            Move aTablesToCheck[iCount] to hTable
89117>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89118>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89119>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89120>>>>>>>
89120>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89123>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89124>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89125>>>>>>>
89125>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89127>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89128>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89129>>>>>>>                If (iDateSize > 0) Begin
89131>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89132>>>>>>>                    Close hTable
89133>>>>>>>                End
89133>>>>>>>>
89133>>>>>>>            End
89133>>>>>>>>
89133>>>>>>>        Loop
89134>>>>>>>>
89134>>>>>>>
89134>>>>>>>        Close DF_ALL
89135>>>>>>>        Function_Return bOK
89136>>>>>>>    End_Function
89137>>>>>>>
89137>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89137>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89139>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89141>>>>>>>        Integer iSize iCount iType
89141>>>>>>>        Boolean bOpen bOK
89141>>>>>>>        
89141>>>>>>>        Get _UtilTableExists hTable to bOK
89142>>>>>>>        If (bOK = False) Begin
89144>>>>>>>            Set Private.phCurrentTable to hTable
89145>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89146>>>>>>>>
89146>>>>>>>            Function_Return aDateFieldsEmpty
89147>>>>>>>        End
89147>>>>>>>>
89147>>>>>>>        Set Private.phCurrentTable to hTable
89148>>>>>>>        Set Private.piCurrentField to 0
89149>>>>>>>
89149>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89149>>>>>>>        Open hTable
89151>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89154>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89154>>>>>>>        If (bOpen = False) Begin
89156>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
89156>>>>>>>            Function_Return aDateFieldsEmpty
89157>>>>>>>        End
89157>>>>>>>>
89157>>>>>>>
89157>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89160>>>>>>>        For iCount from 1 to iSize
89166>>>>>>>>
89166>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89169>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89171>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89172>>>>>>>            End
89172>>>>>>>>
89172>>>>>>>        Loop
89173>>>>>>>>
89173>>>>>>>
89173>>>>>>>        Function_Return aDateFields
89174>>>>>>>    End_Function
89175>>>>>>>
89175>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89175>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89175>>>>>>>    // and the record is saved
89175>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89175>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89175>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89177>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89177>>>>>>>        String sDriverID sDateMin
89177>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89177>>>>>>>        Date dDate dDateMin
89177>>>>>>>        Integer[] iaChangeField
89178>>>>>>>
89178>>>>>>>        Get _UtilTableExists hTable to bOK
89179>>>>>>>        // I believe we should just skip files not found and not report an error.
89179>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89179>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89179>>>>>>>        // Especially considering that this call is probably done at the very
89179>>>>>>>        // beginning of a DUF update.
89179>>>>>>>        If (bOK = False) Begin
89181>>>>>>>//            Set Private.phCurrentTable to hTable
89181>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89181>>>>>>>//            Function_Return False
89181>>>>>>>            Function_Return True
89182>>>>>>>        End
89182>>>>>>>>
89182>>>>>>>
89182>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89182>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89182>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89185>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89188>>>>>>>
89188>>>>>>>//        Send SetAllIndexesToBatch hTable True
89188>>>>>>>        Open hTable
89190>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89193>>>>>>>        If (bOpened = False) Begin
89195>>>>>>>            Function_Return False
89196>>>>>>>        End
89196>>>>>>>>
89196>>>>>>>        
89196>>>>>>>        Set Private.phCurrentTable to hTable
89197>>>>>>>        Move 0 to iRecord
89198>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89199>>>>>>>        Decrement iSize
89200>>>>>>>
89200>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89203>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89204>>>>>>>        If (iDriverIndex <> 0) Begin
89206>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89209>>>>>>>            If (sDateMin = "") Begin
89211>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89212>>>>>>>            End
89212>>>>>>>>
89212>>>>>>>            Else Begin
89213>>>>>>>                If (IsDate(sDateMin)) Begin
89215>>>>>>>                    Move sDateMin to dDateMin
89216>>>>>>>                End
89216>>>>>>>>
89216>>>>>>>                Else Begin
89217>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89218>>>>>>>                End
89218>>>>>>>>
89218>>>>>>>            End
89218>>>>>>>>
89218>>>>>>>        End
89218>>>>>>>>
89218>>>>>>>        Else Begin
89219>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89220>>>>>>>        End
89220>>>>>>>>
89220>>>>>>>
89220>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89223>>>>>>>        Set piPosition   of ghoProgressBar to 0
89224>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89225>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89226>>>>>>>        Move False to Err
89227>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89228>>>>>>>
89228>>>>>>>        Clear hTable
89229>>>>>>>        Repeat
89229>>>>>>>>
89229>>>>>>>            Vfind hTable 0 GT
89231>>>>>>>            Move Found to bFound
89232>>>>>>>            If (bFound = True) Begin
89234>>>>>>>                Move False to bSaveChanges
89235>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89236>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89237>>>>>>>                Decrement iSize
89238>>>>>>>                For iCount from 0 to iSize
89244>>>>>>>>
89244>>>>>>>                    Move aDateFields[iCount] to iField
89245>>>>>>>                    Get_Field_Value hTable iField to dDate
89248>>>>>>>                    If (bFixZeroDates = True) Begin
89250>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89251>>>>>>>                    End
89251>>>>>>>>
89251>>>>>>>                    Else Begin
89252>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89253>>>>>>>                    End
89253>>>>>>>>
89253>>>>>>>                    If (bChange = True) Begin
89255>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89256>>>>>>>                    End
89256>>>>>>>>
89256>>>>>>>                Loop
89257>>>>>>>>
89257>>>>>>>
89257>>>>>>>                // Only change Date fields that needs to be changed.
89257>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89259>>>>>>>                    Reread hTable
89263>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89264>>>>>>>                        Decrement iSize
89265>>>>>>>                        For iCount from 0 to iSize
89271>>>>>>>>
89271>>>>>>>                            Move iaChangeField[iCount] to iField
89272>>>>>>>                            Set Private.piCurrentField to iField
89273>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89276>>>>>>>                        Loop
89277>>>>>>>>
89277>>>>>>>                        Move False to Err
89278>>>>>>>                        SaveRecord hTable
89279>>>>>>>                    Unlock
89280>>>>>>>>
89280>>>>>>>                End
89280>>>>>>>>
89280>>>>>>>
89280>>>>>>>                Increment iRecord
89281>>>>>>>                // Increment the StatusPanel counter and check the
89281>>>>>>>                // cancel status every 100 records rather than every
89281>>>>>>>                // record, it's way faster.
89281>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89283>>>>>>>                    Send DoAdvance of ghoProgressBar
89284>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89285>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89286>>>>>>>                End
89286>>>>>>>>
89286>>>>>>>            End
89286>>>>>>>>
89286>>>>>>>        Until (bFound = False)
89288>>>>>>>
89288>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89291>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89293>>>>>>>            Send SetAllIndexesToBatch hTable False
89294>>>>>>>        End
89294>>>>>>>>
89294>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89295>>>>>>>
89295>>>>>>>        Function_Return (Err = False)
89296>>>>>>>    End_Function
89297>>>>>>>
89297>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89297>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89297>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89299>>>>>>>        Boolean bIsSame
89299>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89299>>>>>>>
89299>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89300>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89301>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89302>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89303>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89304>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89305>>>>>>>
89305>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89307>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89308>>>>>>>        End
89308>>>>>>>>
89308>>>>>>>        Else Begin
89309>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89310>>>>>>>        End
89310>>>>>>>>
89310>>>>>>>        If (bIsSame = False) Begin
89312>>>>>>>            Function_Return False
89313>>>>>>>        End
89313>>>>>>>>
89313>>>>>>>
89313>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89314>>>>>>>        If (bIsSame = False) Begin
89316>>>>>>>            Function_Return False
89317>>>>>>>        End
89317>>>>>>>>
89317>>>>>>>
89317>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89318>>>>>>>        If (bIsSame = False) Begin
89320>>>>>>>            Function_Return False
89321>>>>>>>        End
89321>>>>>>>>
89321>>>>>>>
89321>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89322>>>>>>>        If (bIsSame = False) Begin
89324>>>>>>>            Function_Return False
89325>>>>>>>        End
89325>>>>>>>>
89325>>>>>>>
89325>>>>>>>        Function_Return bIsSame
89326>>>>>>>    End_Function
89327>>>>>>>
89327>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89329>>>>>>>        Handle hTableFrom hTableTo
89329>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89329>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89329>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89329>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89329>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89330>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89330>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89331>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89331>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89332>>>>>>>
89332>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89333>>>>>>>        If (bIsSame = True) Begin
89335>>>>>>>            Function_Return True
89336>>>>>>>        End
89336>>>>>>>>
89336>>>>>>>
89336>>>>>>>        Move False to bFilelistError
89337>>>>>>>        Move True to bIsSame
89338>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89339>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89340>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89341>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89342>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89343>>>>>>>
89343>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89344>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89345>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89346>>>>>>>
89346>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89346>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89346>>>>>>>        If (bCodeGenerateMode = True) Begin
89348>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89348>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89350>>>>>>>                Function_Return False
89351>>>>>>>            End
89351>>>>>>>>
89351>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89352>>>>>>>            If (bIsSame = False) Begin
89354>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89355>>>>>>>                Move True to bFilelistError
89356>>>>>>>                Function_Return False
89357>>>>>>>            End
89357>>>>>>>>
89357>>>>>>>        End
89357>>>>>>>>
89357>>>>>>>
89357>>>>>>>        If (bCodeGenerateMode = False) Begin
89359>>>>>>>            // Then we want to create this table
89359>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89361>>>>>>>                Function_Return False
89362>>>>>>>            End
89362>>>>>>>>
89362>>>>>>>
89362>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89363>>>>>>>            If (bIsSame = False) Begin
89365>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89366>>>>>>>>
89366>>>>>>>                Move True to bFilelistError
89367>>>>>>>                Function_Return False
89368>>>>>>>            End
89368>>>>>>>>
89368>>>>>>>        End
89368>>>>>>>>
89368>>>>>>>
89368>>>>>>>        // Check columns:
89368>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89369>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89370>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89371>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89372>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89373>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89374>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89375>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89376>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89377>>>>>>>        If (bIsSame = False) Begin
89379>>>>>>>            Function_Return False
89380>>>>>>>        End
89380>>>>>>>>
89380>>>>>>>
89380>>>>>>>        // ...then check indexes:
89380>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89381>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89382>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89383>>>>>>>        If (bIsSame = False) Begin
89385>>>>>>>            Function_Return False
89386>>>>>>>        End
89386>>>>>>>>
89386>>>>>>>
89386>>>>>>>        // ...and finally relationships:
89386>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89387>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89388>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89389>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89390>>>>>>>
89390>>>>>>>        Function_Return (bIsSame = True)
89391>>>>>>>    End_Function
89392>>>>>>>
89392>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89392>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89394>>>>>>>        Handle hTable
89394>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89394>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89394>>>>>>>
89394>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89396>>>>>>>            Move True to bFilelistError
89397>>>>>>>            Function_Return False
89398>>>>>>>        End
89398>>>>>>>>
89398>>>>>>>
89398>>>>>>>        Move APITableCompare.hTable to hTable
89399>>>>>>>        Move True  to bIsSame
89400>>>>>>>        Move False to bFilelistError
89401>>>>>>>
89401>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89403>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89404>>>>>>>        End
89404>>>>>>>>
89404>>>>>>>        Else Begin
89405>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89406>>>>>>>        End
89406>>>>>>>>
89406>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89407>>>>>>>
89407>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89408>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89409>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89410>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89411>>>>>>>
89411>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89411>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89411>>>>>>>        If (bCodeGenerateMode = True) Begin
89413>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89413>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89415>>>>>>>                Function_Return False
89416>>>>>>>            End
89416>>>>>>>>
89416>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89417>>>>>>>            If (bIsSame = False) Begin
89419>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89420>>>>>>>                Move True to bFilelistError
89421>>>>>>>                Function_Return False
89422>>>>>>>            End
89422>>>>>>>>
89422>>>>>>>        End
89422>>>>>>>>
89422>>>>>>>
89422>>>>>>>        If (bCodeGenerateMode = False) Begin
89424>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89426>>>>>>>                // Then we might want to create this table
89426>>>>>>>                Function_Return False
89427>>>>>>>            End
89427>>>>>>>>
89427>>>>>>>
89427>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89428>>>>>>>            If (bIsSame = False) Begin
89430>>>>>>>                Function_Return False
89431>>>>>>>            End
89431>>>>>>>>
89431>>>>>>>
89431>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89432>>>>>>>            If (bIsSame = False) Begin
89434>>>>>>>                Function_Return False
89435>>>>>>>            End
89435>>>>>>>>
89435>>>>>>>
89435>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89436>>>>>>>            If (bIsSame = False) Begin
89438>>>>>>>                Function_Return False
89439>>>>>>>            End
89439>>>>>>>>
89439>>>>>>>
89439>>>>>>>            // Check table names et al.
89439>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89440>>>>>>>            If (bIsSame = False) Begin
89442>>>>>>>                Function_Return False
89443>>>>>>>            End
89443>>>>>>>>
89443>>>>>>>        End
89443>>>>>>>>
89443>>>>>>>
89443>>>>>>>        // Check Columns:
89443>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89444>>>>>>>        If (bIsSame = False) Begin
89446>>>>>>>            Function_Return False
89447>>>>>>>        End
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        // ...then check Indexes:
89447>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89448>>>>>>>        If (bIsSame = False) Begin
89450>>>>>>>            Function_Return False
89451>>>>>>>        End
89451>>>>>>>>
89451>>>>>>>
89451>>>>>>>        // ...and finally Relationships:
89451>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89452>>>>>>>
89452>>>>>>>        Function_Return (bIsSame = True)
89453>>>>>>>    End_Function
89454>>>>>>>
89454>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89454>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89454>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89454>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89454>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89456>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89456>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89456>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89456>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89458>>>>>>>        tAPIColumn[]    aApiColumns
89458>>>>>>>        tAPIColumn[]    aApiColumns
89459>>>>>>>        tAPIIndex[]     aApiIndexes
89459>>>>>>>        tAPIIndex[]     aApiIndexes
89460>>>>>>>        tAPIRelation[]  aApiRelations
89460>>>>>>>        tAPIRelation[]  aApiRelations
89461>>>>>>>        Handle hTable
89461>>>>>>>        Integer iCount
89461>>>>>>>        Boolean bUserCancel bOK
89461>>>>>>>        String sLogicalName sMessageText
89461>>>>>>>
89461>>>>>>>        Get AutoConnectionIDLogin to bOK
89462>>>>>>>        Move 0 to hTable
89463>>>>>>>        If (bFromTables = True) Begin
89465>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89466>>>>>>>            If (bCompareUtil = True) Begin
89468>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89469>>>>>>>            End
89469>>>>>>>>
89469>>>>>>>        End
89469>>>>>>>>
89469>>>>>>>        Else Begin
89470>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89471>>>>>>>            If (bCompareUtil = True) Begin
89473>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89474>>>>>>>            End
89474>>>>>>>>
89474>>>>>>>        End
89474>>>>>>>>
89474>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89475>>>>>>>
89475>>>>>>>        Get UtilFilelistNoOfTables to iCount
89476>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89477>>>>>>>        Move 0 to iCount
89478>>>>>>>
89478>>>>>>>        Repeat
89478>>>>>>>>
89478>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89481>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89483>>>>>>>
89483>>>>>>>                Open hTable
89485>>>>>>>                // ToDo: Needs to be revised
89485>>>>>>>                // For some reason tables may be reported as "unopened", while in
89485>>>>>>>                // fact the open was successful (!)
89485>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89485>>>>>>>//                If (bIsOpen = False) Begin
89485>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89485>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89485>>>>>>>//                    Function_Return aApiTablesEmpty
89485>>>>>>>//                End
89485>>>>>>>
89485>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89488>>>>>>>                Set piPosition of ghoProgressBar to iCount
89489>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89490>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89491>>>>>>>
89491>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89492>>>>>>>//                Close hTable DF_PERMANENT
89492>>>>>>>                Increment iCount
89493>>>>>>>            End
89493>>>>>>>>
89493>>>>>>>
89493>>>>>>>            If (bStatusPanel = True) Begin
89495>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89496>>>>>>>                If (bUserCancel = True) Begin
89498>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89499>>>>>>>                    Function_Return aApiTablesEmpty
89500>>>>>>>                End
89500>>>>>>>>
89500>>>>>>>            End
89500>>>>>>>>
89500>>>>>>>
89500>>>>>>>        Until (hTable = 0)
89502>>>>>>>
89502>>>>>>>        Function_Return aApiTables
89503>>>>>>>    End_Function
89504>>>>>>>
89504>>>>>>>    // Returns a 'single' table APITable struct.
89504>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89506>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89506>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89506>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89506>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89506>>>>>>>        tAPIColumn[]     aApiColumns
89506>>>>>>>        tAPIColumn[]     aApiColumns
89507>>>>>>>        tAPIIndex[]      aApiIndexes
89507>>>>>>>        tAPIIndex[]      aApiIndexes
89508>>>>>>>        tAPIRelation[]   aApiRelations
89508>>>>>>>        tAPIRelation[]   aApiRelations
89509>>>>>>>        Boolean bIsOpen
89509>>>>>>>
89509>>>>>>>        Open hTable
89511>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89514>>>>>>>        If (bIsOpen = False) Begin
89516>>>>>>>            Move True to ApiTableEmpty.bError
89517>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89518>>>>>>>            Function_Return ApiTableEmpty
89519>>>>>>>        End
89519>>>>>>>>
89519>>>>>>>
89519>>>>>>>        // Fill Table Name Info
89519>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89520>>>>>>>
89520>>>>>>>        // Fill columns
89520>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89521>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89523>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89525>>>>>>>                Move True to ApiTableEmpty.bError
89526>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89527>>>>>>>                Function_Return ApiTableEmpty
89528>>>>>>>            End
89528>>>>>>>>
89528>>>>>>>        End
89528>>>>>>>>
89528>>>>>>>
89528>>>>>>>        // Fill indexes
89528>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89529>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89531>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89533>>>>>>>                Move True to ApiTableEmpty.bError
89534>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89535>>>>>>>                Function_Return ApiTableEmpty
89536>>>>>>>            End
89536>>>>>>>>
89536>>>>>>>        End
89536>>>>>>>>
89536>>>>>>>
89536>>>>>>>        // Fill relationships
89536>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89537>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89539>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89541>>>>>>>                Move True to ApiTableEmpty.bError
89542>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89543>>>>>>>                Function_Return ApiTableEmpty
89544>>>>>>>            End
89544>>>>>>>>
89544>>>>>>>        End
89544>>>>>>>>
89544>>>>>>>
89544>>>>>>>        Move hTable             to ApiTable.hTable
89545>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89546>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89547>>>>>>>
89547>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89548>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89549>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89550>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89551>>>>>>>
89551>>>>>>>        Function_Return ApiTable
89552>>>>>>>    End_Function
89553>>>>>>>
89553>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89555>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89555>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89555>>>>>>>        Boolean bIsOpen
89555>>>>>>>
89555>>>>>>>        Open hTable
89557>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89560>>>>>>>        If (bIsOpen = False) Begin
89562>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89563>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89564>>>>>>>            Function_Return APITableNameInfoEmpty
89565>>>>>>>        End
89565>>>>>>>>
89565>>>>>>>
89565>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89566>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89569>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89572>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89575>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89578>>>>>>>
89578>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89579>>>>>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89580>>>>>>>
89580>>>>>>>        Function_Return APITableNameInfo
89581>>>>>>>    End_Function
89582>>>>>>>
89582>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89584>>>>>>>        Integer iSize iCount iItem
89584>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89584>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89584>>>>>>>
89584>>>>>>>        Move -1 to iItem
89585>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89586>>>>>>>        Decrement iSize
89587>>>>>>>        for iCount from 0 to iSize
89593>>>>>>>>
89593>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89594>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89596>>>>>>>                Move iCount to iItem
89597>>>>>>>                Move iSize  to iCount // We're done.
89598>>>>>>>            End
89598>>>>>>>>
89598>>>>>>>        Loop
89599>>>>>>>>
89599>>>>>>>
89599>>>>>>>        Function_Return iItem
89600>>>>>>>    End_Function
89601>>>>>>>
89601>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89603>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89606>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89609>>>>>>>
89609>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89612>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89615>>>>>>>
89615>>>>>>>        Function_Return (EQ)
89616>>>>>>>    End_Function
89617>>>>>>>
89617>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89619>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89619>>>>>>>        Handle hTable
89619>>>>>>>        tAPITable[] aAPITableFromAndTo
89619>>>>>>>        tAPITable[] aAPITableFromAndTo
89620>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89620>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89620>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89620>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89620>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89620>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89621>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89621>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89622>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89622>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89623>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89623>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89624>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89624>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89624>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89624>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89627>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89627>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89630>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89630>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89633>>>>>>>
89633>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89634>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89635>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89637>>>>>>>            Function_Return aAPITableCompare
89638>>>>>>>        End
89638>>>>>>>>
89638>>>>>>>
89638>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89639>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89640>>>>>>>
89640>>>>>>>        Move 0 to iItem
89641>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89642>>>>>>>        Decrement iSize
89643>>>>>>>        for iCount from 0 to iSize
89649>>>>>>>>
89649>>>>>>>
89649>>>>>>>            Move iCount to iItemFrom
89650>>>>>>>            Move iCount to iItemTo
89651>>>>>>>            Move APITableEmpty to APITableFrom
89652>>>>>>>            Move APITableEmpty to APITableTo
89653>>>>>>>
89653>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89655>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89656>>>>>>>            End
89656>>>>>>>>
89656>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89658>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89659>>>>>>>            End
89659>>>>>>>>
89659>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89661>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89662>>>>>>>                Move (iCount + 1) to iItemTo
89663>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89664>>>>>>>            End
89664>>>>>>>>
89664>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89666>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89667>>>>>>>                If (iItemTo <> -1) Begin
89669>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89670>>>>>>>                End
89670>>>>>>>>
89670>>>>>>>                Else Begin
89671>>>>>>>                    Move APITableEmpty to APITableTo
89672>>>>>>>                End
89672>>>>>>>>
89672>>>>>>>            End
89672>>>>>>>>
89672>>>>>>>
89672>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89673>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89674>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89675>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89676>>>>>>>
89676>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89677>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89678>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89679>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89680>>>>>>>
89680>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89681>>>>>>>
89681>>>>>>>            If (hTable > 0) Begin
89683>>>>>>>
89683>>>>>>>                // Table info:
89683>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89684>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89685>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89686>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89687>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89688>>>>>>>
89688>>>>>>>                // Column info:
89688>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89689>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89690>>>>>>>
89690>>>>>>>                // Index info:
89690>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89691>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89692>>>>>>>
89692>>>>>>>                // Relation info:
89692>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89693>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89694>>>>>>>
89694>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89695>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89696>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89697>>>>>>>                If (iItemTo > iItemFrom) Begin
89699>>>>>>>                    Increment iCount
89700>>>>>>>                End
89700>>>>>>>>
89700>>>>>>>                Increment iItem
89701>>>>>>>            End
89701>>>>>>>>
89701>>>>>>>
89701>>>>>>>        Loop
89702>>>>>>>>
89702>>>>>>>
89702>>>>>>>        Function_Return aAPITableCompare
89703>>>>>>>    End_Function
89704>>>>>>>
89704>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89706>>>>>>>        Integer iSize iCount iItem
89706>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89706>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89706>>>>>>>
89706>>>>>>>        Move -1 to iItem
89707>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89708>>>>>>>        Decrement iSize
89709>>>>>>>        For iCount from 0 to iSize
89715>>>>>>>>
89715>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89716>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89718>>>>>>>                Move iCount to iItem
89719>>>>>>>                Move iSize  to iCount // We're done.
89720>>>>>>>            End
89720>>>>>>>>
89720>>>>>>>        Loop
89721>>>>>>>>
89721>>>>>>>
89721>>>>>>>        Function_Return iItem
89722>>>>>>>    End_Function
89723>>>>>>>
89723>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89725>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89725>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89725>>>>>>>
89725>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89727>>>>>>>            Function_Return APITableNameInfoCompare
89728>>>>>>>        End
89728>>>>>>>>
89728>>>>>>>
89728>>>>>>>        // FROM database info:
89728>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89730>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89731>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89732>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89733>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89734>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89735>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89736>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89737>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89738>>>>>>>        End
89738>>>>>>>>
89738>>>>>>>
89738>>>>>>>        // TO database info:
89738>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89740>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89741>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89742>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89743>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89744>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89745>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89746>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89747>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89748>>>>>>>        End
89748>>>>>>>>
89748>>>>>>>
89748>>>>>>>        Function_Return APITableNameInfoCompare
89749>>>>>>>    End_Function
89750>>>>>>>
89750>>>>>>>    // Note:
89750>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89750>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89750>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89750>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89750>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89750>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
89752>>>>>>>        String sTableName
89752>>>>>>>        Boolean bOpen bExists bOK
89752>>>>>>>
89752>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
89753>>>>>>>        If (bExists = False) Begin
89755>>>>>>>            Function_Return ""
89756>>>>>>>        End
89756>>>>>>>>
89756>>>>>>>
89756>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89757>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89760>>>>>>>        If (bOpen = False) Begin
89762>>>>>>>            Get AutoConnectionIDLogin to bOK
89763>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89764>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89765>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89766>>>>>>>            Open hTable
89768>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89769>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89770>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89771>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89774>>>>>>>        End
89774>>>>>>>>
89774>>>>>>>        If (bOpen = True) Begin
89776>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89777>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89780>>>>>>>            // If blank it is an embedded table:
89780>>>>>>>            If (sTableName = "") Begin
89782>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89785>>>>>>>                Move 0 to LastErr
89786>>>>>>>                Move False to Err
89787>>>>>>>            End
89787>>>>>>>>
89787>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89788>>>>>>>        End
89788>>>>>>>>
89788>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89789>>>>>>>        Move 0 to LastErr
89790>>>>>>>
89790>>>>>>>        Function_Return sTableName
89791>>>>>>>    End_Function
89792>>>>>>>
89792>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89792>>>>>>>    // Returns 0 if unsuccessful.
89792>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89792>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89794>>>>>>>        String sValue sPrefixTableName sDriverID
89794>>>>>>>        Handle hTable hRetval
89794>>>>>>>
89794>>>>>>>        Get psDriverID to sDriverID
89795>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89797>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89798>>>>>>>        End
89798>>>>>>>>
89798>>>>>>>        Move 0 to hTable
89799>>>>>>>        Move 0 to hRetval
89800>>>>>>>        Repeat
89800>>>>>>>>
89800>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89803>>>>>>>            If (hTable <> 0) Begin
89805>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89808>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89810>>>>>>>                    Move hTable to hRetval
89811>>>>>>>                    Move 0 to hTable
89812>>>>>>>                End
89812>>>>>>>>
89812>>>>>>>            End
89812>>>>>>>>
89812>>>>>>>        Until (hTable = 0)
89814>>>>>>>
89814>>>>>>>        Function_Return hRetval
89815>>>>>>>    End_Function
89816>>>>>>>
89816>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89816>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89816>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89818>>>>>>>        Boolean bOK bExists
89818>>>>>>>        String sDataPath sBackupFolder
89818>>>>>>>
89818>>>>>>>        Close DF_ALL DF_PERMANENT
89819>>>>>>>        Send DoAdvance of ghoProgressBar
89820>>>>>>>
89820>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89821>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89822>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89823>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89824>>>>>>>
89824>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89825>>>>>>>        If (bExists = False) Begin
89827>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89828>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89829>>>>>>>            If (bExists = False) Begin
89831>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89832>>>>>>>>
89832>>>>>>>                Function_Return False
89833>>>>>>>            End
89833>>>>>>>>
89833>>>>>>>        End
89833>>>>>>>>
89833>>>>>>>
89833>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89834>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89835>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89836>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89837>>>>>>>        // We need to wait for Windows before we can copy files back
89837>>>>>>>        Sleep 2  
89838>>>>>>>        
89838>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
89838>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89839>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89840>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89841>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89842>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89843>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89844>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89844>>>>>>>        
89844>>>>>>>
89844>>>>>>>        Set Message_Text of ghoStatusPanel to ""
89845>>>>>>>        Function_Return True
89846>>>>>>>    End_Function
89847>>>>>>>    
89847>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89849>>>>>>>        Boolean bOK bRetval
89849>>>>>>>        Handle hTable
89849>>>>>>>        Integer iSize iCount
89849>>>>>>>        
89849>>>>>>>        Move True to bOK
89850>>>>>>>        Get UtilFilelistNoOfTables to iSize
89851>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89852>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89853>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89854>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89855>>>>>>>
89855>>>>>>>        Repeat
89855>>>>>>>>
89855>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89856>>>>>>>            Increment iCount
89857>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89860>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89862>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
89863>>>>>>>                If (bRetval = False) Begin
89865>>>>>>>                    Move False to bOK
89866>>>>>>>                End
89866>>>>>>>>
89866>>>>>>>            End
89866>>>>>>>>
89866>>>>>>>        Until (hTable = 0)
89868>>>>>>>                
89868>>>>>>>        Function_Return bOK
89869>>>>>>>    End_Function           
89870>>>>>>>    
89870>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89870>>>>>>>    // After the header has been repaired - also makes a re-index.  
89870>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89870>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89872>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89872>>>>>>>        Integer iRetval
89872>>>>>>>        String sRootName sFileName sDataPath
89872>>>>>>>        
89872>>>>>>>        Move False to Err
89873>>>>>>>        Move 0 to LastErr 
89874>>>>>>>        Move True to bOK
89875>>>>>>>        
89875>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89876>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89878>>>>>>>            Function_Return True
89879>>>>>>>        End
89879>>>>>>>>
89879>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
89880>>>>>>>        If (bIsAlias = True) Begin
89882>>>>>>>            Function_Return True
89883>>>>>>>        End
89883>>>>>>>>
89883>>>>>>>        
89883>>>>>>>        // Check for bad file and remove if exists
89883>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89886>>>>>>>        Set private.phCurrentTable to hTable  
89887>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89888>>>>>>>        
89888>>>>>>>        // This is important! Else it can happen that the table can't be opened,
89888>>>>>>>        // with a "4077 - File in use" error.
89888>>>>>>>        Close DF_ALL DF_PERMANENT    
89889>>>>>>>        Open hTable
89891>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89894>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89895>>>>>>>        If (bIsOpen = False) Begin
89897>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
89898>>>>>>>>
89898>>>>>>>            Function_Return False        
89899>>>>>>>        End
89899>>>>>>>>
89899>>>>>>>
89899>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
89900>>>>>>>        If (bBadExists = True) Begin
89902>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
89903>>>>>>>            Get vDeleteFile sFileName to iRetval
89904>>>>>>>        End
89904>>>>>>>>
89904>>>>>>>        
89904>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
89905>>>>>>>        
89905>>>>>>>        Move False to Err
89906>>>>>>>        // **** Repair and reindex the table. ****
89906>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
89907>>>>>>>
89907>>>>>>>        // Check for bad file: if it exists, something went wrong
89907>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89908>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89909>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
89910>>>>>>>        If (bBadExists = True) Begin
89912>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
89913>>>>>>>>
89913>>>>>>>            Move False to bOK
89914>>>>>>>        End
89914>>>>>>>>
89914>>>>>>>        Close hTable
89915>>>>>>>
89915>>>>>>>        Function_Return bOK
89916>>>>>>>    End_Function
89917>>>>>>>
89917>>>>>>>    // Repair and reindex the named DataFlex data-table.
89917>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
89917>>>>>>>    // so use with care (make sure you only pass embedded table names).
89917>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
89919>>>>>>>        String sMode
89919>>>>>>>        Integer iVoid
89919>>>>>>>
89919>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
89920>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
89921>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
89922>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
89927>>>>>>>        Set Message_Text of ghoStatusPanel to ""
89928>>>>>>>        Function_Return (iVoid = 0)
89929>>>>>>>    End_Function
89930>>>>>>>
89930>>>>>>>    // Returns _two_ arrays.
89930>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
89930>>>>>>>    // Also returns all files that are Alias files in a second array.
89930>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
89930>>>>>>>    //            the DoSetAllMasterAndAlias message.
89930>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
89932>>>>>>>        Integer[] iaFileIsAlias
89933>>>>>>>        Integer hTable iFileAlias iSize
89933>>>>>>>        Boolean bOpen
89933>>>>>>>
89933>>>>>>>        Move 0 to hTable
89934>>>>>>>        Repeat
89934>>>>>>>>
89934>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89937>>>>>>>            If (hTable <> 0) Begin
89939>>>>>>>                Open hTable
89941>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
89944>>>>>>>                If (bOpen = True) Begin
89946>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
89949>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
89951>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
89952>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
89953>>>>>>>                    End
89953>>>>>>>>
89953>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
89956>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
89957>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
89958>>>>>>>                    End
89958>>>>>>>>
89958>>>>>>>                End
89958>>>>>>>>
89958>>>>>>>            End
89958>>>>>>>>
89958>>>>>>>        Until (hTable = 0)
89960>>>>>>>
89960>>>>>>>        Function_Return iaFileIsAlias
89961>>>>>>>    End_Function  
89962>>>>>>>    
89962>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
89962>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
89964>>>>>>>        String sMode
89964>>>>>>>        Integer iRepairNeeded bIsOpen
89964>>>>>>>
89964>>>>>>>        Move "0" to sMode
89965>>>>>>>        Set private.phCurrentTable to hTable 
89966>>>>>>>        Close hTable
89967>>>>>>>        Open hTable
89969>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89972>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
89977>>>>>>>
89977>>>>>>>        Function_Return iRepairNeeded
89978>>>>>>>    End_Function
89979>>>>>>>
89979>>>>>>>    // Helper function
89979>>>>>>>    // Takes two params:
89979>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
89979>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
89979>>>>>>>    // Returns:
89979>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
89979>>>>>>>    //  DF_FILE_IS_MASTER if master
89979>>>>>>>    //  DF_FILE_IS_ALIAS if alias
89979>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
89981>>>>>>>        Integer i iSize
89981>>>>>>>
89981>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
89982>>>>>>>        Decrement iSize
89983>>>>>>>        for i from 0 to iSize
89989>>>>>>>>
89989>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
89991>>>>>>>                Function_Return DF_FILE_IS_MASTER
89992>>>>>>>            End
89992>>>>>>>>
89992>>>>>>>        Loop
89993>>>>>>>>
89993>>>>>>>
89993>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
89994>>>>>>>        Decrement iSize
89995>>>>>>>        for i from 0 to iSize
90001>>>>>>>>
90001>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90003>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90004>>>>>>>            End
90004>>>>>>>>
90004>>>>>>>        Loop
90005>>>>>>>>
90005>>>>>>>
90005>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90006>>>>>>>    End_Function
90007>>>>>>>
90007>>>>>>>    // Determine the available indexes of a table.
90007>>>>>>>    //
90007>>>>>>>    // Arguments:
90007>>>>>>>    //   Handle hTable - The number of the table
90007>>>>>>>    //
90007>>>>>>>    // Returns:
90007>>>>>>>    //   String - A string to be used with the sort command
90007>>>>>>>    //   to re-index all indexes of a table.
90007>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90009>>>>>>>        String  sSortString
90009>>>>>>>        Integer iLastIndex iNumSegments iCount
90009>>>>>>>
90009>>>>>>>        Move "" to sSortString
90010>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90013>>>>>>>
90013>>>>>>>        for iCount from 1 to iLastIndex
90019>>>>>>>>
90019>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90022>>>>>>>            If iNumSegments Begin
90024>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90027>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90028>>>>>>>            End
90028>>>>>>>>
90028>>>>>>>        Loop
90029>>>>>>>>
90029>>>>>>>
90029>>>>>>>        Function_Return sSortString
90030>>>>>>>    End_Function
90031>>>>>>>
90031>>>>>>>    
90031>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90031>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90033>>>>>>>        Function_Return False
90034>>>>>>>    End_Function
90035>>>>>>>
90035>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90035>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90037>>>>>>>        Boolean bIsSame
90037>>>>>>>        Integer iCount iColumns iColumn
90037>>>>>>>
90037>>>>>>>        Move True to bIsSame
90038>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90039>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90040>>>>>>>        Decrement iColumns
90041>>>>>>>
90041>>>>>>>        for iCount from 0 to iColumns
90047>>>>>>>>
90047>>>>>>>            Set piPosition of ghoProgressBar to iCount
90048>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90049>>>>>>>            If (bIsSame = False) Begin
90051>>>>>>>                Function_Return False
90052>>>>>>>            End
90052>>>>>>>>
90052>>>>>>>        Loop
90053>>>>>>>>
90053>>>>>>>
90053>>>>>>>        Function_Return (bIsSame = True)
90054>>>>>>>    End_Function
90055>>>>>>>
90055>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90055>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90057>>>>>>>        Integer iFromType iToType iDbType
90057>>>>>>>        tColumnType ColumnType
90057>>>>>>>        tColumnType ColumnType
90057>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90057>>>>>>>
90057>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90059>>>>>>>            Function_Return False
90060>>>>>>>        End
90060>>>>>>>>
90060>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90062>>>>>>>            Function_Return False
90063>>>>>>>        End
90063>>>>>>>>
90063>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90065>>>>>>>            Function_Return False
90066>>>>>>>        End                                                                
90066>>>>>>>>
90066>>>>>>>
90066>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90068>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90070>>>>>>>                Function_Return False
90071>>>>>>>            End
90071>>>>>>>>
90071>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90073>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90075>>>>>>>                    End
90075>>>>>>>>
90075>>>>>>>                Else Begin
90076>>>>>>>                    Function_Return False
90077>>>>>>>                End
90077>>>>>>>>
90077>>>>>>>            End
90077>>>>>>>>
90077>>>>>>>        End
90077>>>>>>>>
90077>>>>>>>
90077>>>>>>>        Get piDbType                       to iDbType
90078>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90079>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90080>>>>>>>
90080>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90080>>>>>>>        // data types between Embedded and SQL.
90080>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90082>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90083>>>>>>>        End
90083>>>>>>>>
90083>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90085>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90086>>>>>>>        End
90086>>>>>>>>
90086>>>>>>>
90086>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90087>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90088>>>>>>>
90088>>>>>>>        // Make Date and DateTime comparison?
90088>>>>>>>        If (bCompareDate_DataTime = True) Begin
90090>>>>>>>            If (iFromType <> iToType) Begin
90092>>>>>>>                Function_Return False
90093>>>>>>>            End
90093>>>>>>>>
90093>>>>>>>        End
90093>>>>>>>>
90093>>>>>>>
90093>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90093>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90095>>>>>>>            If (iFromType <> iToType) Begin
90097>>>>>>>                Function_Return False
90098>>>>>>>            End
90098>>>>>>>>
90098>>>>>>>        End
90098>>>>>>>>
90098>>>>>>>
90098>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90098>>>>>>>        If (bIsDateTypeFrom = False) Begin
90100>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90102>>>>>>>                Function_Return False
90103>>>>>>>            End
90103>>>>>>>>
90103>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90105>>>>>>>                Function_Return False
90106>>>>>>>            End
90106>>>>>>>>
90106>>>>>>>        End
90106>>>>>>>>
90106>>>>>>>
90106>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90108>>>>>>>            Function_Return False
90109>>>>>>>        End
90109>>>>>>>>
90109>>>>>>>
90109>>>>>>>        Function_Return True
90110>>>>>>>    End_Function
90111>>>>>>>
90111>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90113>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90113>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90113>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90113>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90115>>>>>>>        String sDriverID sRootName sLogicalName
90115>>>>>>>
90115>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90116>>>>>>>        Get piDbType to iDbType
90117>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90120>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90123>>>>>>>
90123>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90126>>>>>>>        If (bIsOpen = False) Begin
90128>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90129>>>>>>>            Open hTable
90131>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90132>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90135>>>>>>>            If (bIsOpen = False) Begin
90137>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90138>>>>>>>                Move True to APIColumnsEmpty[0].bError
90139>>>>>>>                Function_Return APIColumnsEmpty
90140>>>>>>>            End
90140>>>>>>>>
90140>>>>>>>        End
90140>>>>>>>>
90140>>>>>>>
90140>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90143>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90144>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90145>>>>>>>
90145>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90146>>>>>>>        If (bIsSqlTable = True) Begin
90148>>>>>>>            Get _UtilTableExists hTable to bExists
90149>>>>>>>            If (bExists = False) Begin
90151>>>>>>>                Move True to APIColumnsEmpty[0].bError
90152>>>>>>>                Function_Return APIColumnsEmpty
90153>>>>>>>            End
90153>>>>>>>>
90153>>>>>>>        End
90153>>>>>>>>
90153>>>>>>>
90153>>>>>>>        Move 0 to iCount
90154>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90157>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90158>>>>>>>
90158>>>>>>>        for iColumn from 1 to iNumColumns
90164>>>>>>>>
90164>>>>>>>            Move 0 to iOptions
90165>>>>>>>            Move False to bIdentityKey
90166>>>>>>>            Move False to Err
90167>>>>>>>            Move 0     to LastErr
90168>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90169>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90170>>>>>>>            If (bDawSqlDriver = True) Begin
90172>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90173>>>>>>>                If (bIsSqlTable = True) Begin
90175>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90178>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90179>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90182>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90185>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90188>>>>>>>                End
90188>>>>>>>>
90188>>>>>>>                Else Begin
90189>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90192>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90193>>>>>>>                End
90193>>>>>>>>
90193>>>>>>>
90193>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90193>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90196>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90197>>>>>>>                If (bExists = False) Begin
90199>>>>>>>                    Move 0 to APIColumns[iCount].iType
90200>>>>>>>                End
90200>>>>>>>>
90200>>>>>>>                If (bExists = True) Begin
90202>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90205>>>>>>>                End
90205>>>>>>>>
90205>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90206>>>>>>>                If (bIdentityKey = True) Begin
90208>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90209>>>>>>>                End
90209>>>>>>>>
90209>>>>>>>            End
90209>>>>>>>>
90209>>>>>>>            Else Begin
90210>>>>>>>                Move False to Err
90211>>>>>>>                Move 0     to LastErr
90212>>>>>>>                If (bIsSqlTable = True) Begin
90214>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90217>>>>>>>                End
90217>>>>>>>>
90217>>>>>>>                Else Begin
90218>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90221>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90222>>>>>>>                End
90222>>>>>>>>
90222>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90222>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90223>>>>>>>                If (bExists = False) Begin
90225>>>>>>>                    Move 0 to APIColumns[iCount].iType
90226>>>>>>>                End
90226>>>>>>>>
90226>>>>>>>            End
90226>>>>>>>>
90226>>>>>>>
90226>>>>>>>            If (bExists = True) Begin
90228>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90229>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90232>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90232>>>>>>>//                If (bIsSqlTable = True) Begin
90232>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90232>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90232>>>>>>>//                End
90232>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90235>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90238>>>>>>>
90238>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90238>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90238>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90240>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90243>>>>>>>                    If (iType = DF_OVERLAP) Begin
90245>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90246>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90247>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90248>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90249>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90250>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90251>>>>>>>                        Decrement iCount
90252>>>>>>>                    End
90252>>>>>>>>
90252>>>>>>>                End
90252>>>>>>>>
90252>>>>>>>            End
90252>>>>>>>>
90252>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90253>>>>>>>            If (bUserCancel = True) Begin
90255>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90256>>>>>>>                Function_Return APIColumnsEmpty
90257>>>>>>>            End
90257>>>>>>>>
90257>>>>>>>            Increment iCount
90258>>>>>>>        Loop
90259>>>>>>>>
90259>>>>>>>
90259>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90260>>>>>>>        Function_Return APIColumns
90261>>>>>>>    End_Function
90262>>>>>>>
90262>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90262>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90262>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90262>>>>>>>    // have "holes" in the series of index numbers.
90262>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90264>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90264>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90265>>>>>>>        tAPIColumnCompare   APIColumnCompare
90265>>>>>>>        tAPIColumnCompare   APIColumnCompare
90265>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90265>>>>>>>
90265>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90266>>>>>>>        Decrement iSizeFrom
90267>>>>>>>        for iCount from 0 to iSizeFrom
90273>>>>>>>>
90273>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90274>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90275>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90276>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90277>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90278>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90279>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90280>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90281>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90282>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90283>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90284>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90285>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90286>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90287>>>>>>>        Loop
90288>>>>>>>>
90288>>>>>>>
90288>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90289>>>>>>>        Decrement iSizeTo
90290>>>>>>>        for iCount from 0 to iSizeTo
90296>>>>>>>>
90296>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90297>>>>>>>            // Search if the field number already exists in the array; else add it.
90297>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90298>>>>>>>            If (iItem = -1) Begin
90300>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90301>>>>>>>            End
90301>>>>>>>>
90301>>>>>>>
90301>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90302>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90303>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90304>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90305>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90306>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90307>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90308>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90309>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90310>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90311>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90312>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90313>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90314>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90315>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90316>>>>>>>        Loop
90317>>>>>>>>
90317>>>>>>>
90317>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90318>>>>>>>
90318>>>>>>>        Function_Return aAPIColumnCompare
90319>>>>>>>    End_Function
90320>>>>>>>
90320>>>>>>>    // Checks if a field name exists in a table definition
90320>>>>>>>    // Returns True if it does
90320>>>>>>>    // Sample:
90320>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90320>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90322>>>>>>>        Integer iNumColumns iColumn
90322>>>>>>>        String sColumn
90322>>>>>>>        Boolean bExists bOK bOpen
90322>>>>>>>
90322>>>>>>>        Get AutoConnectionIDLogin to bOK
90323>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90324>>>>>>>        Open hTable
90326>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90327>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90330>>>>>>>        If (bOpen = False) Begin
90332>>>>>>>            Function_Return False
90333>>>>>>>        End
90333>>>>>>>>
90333>>>>>>>
90333>>>>>>>        Move False to bExists
90334>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90337>>>>>>>        for iColumn from 1 to iNumColumns
90343>>>>>>>>
90343>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90346>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90348>>>>>>>                Move iNumColumns to iColumn
90349>>>>>>>                Move True to bExists
90350>>>>>>>            End
90350>>>>>>>>
90350>>>>>>>        Loop
90351>>>>>>>>
90351>>>>>>>        Close hTable
90352>>>>>>>
90352>>>>>>>        Function_Return bExists
90353>>>>>>>    End_Function
90354>>>>>>>
90354>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90354>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90356>>>>>>>        Integer iNumColumns iColumn iRetval
90356>>>>>>>        String sColumn
90356>>>>>>>        Boolean bOK bOpen
90356>>>>>>>
90356>>>>>>>        Get AutoConnectionIDLogin to bOK
90357>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90358>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90359>>>>>>>        Open hTable
90361>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90362>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90365>>>>>>>        If (bOpen = False) Begin
90367>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90368>>>>>>>            Function_Return False
90369>>>>>>>        End
90369>>>>>>>>
90369>>>>>>>
90369>>>>>>>        Move 0 to iColumn
90370>>>>>>>        Move 0 to iRetval
90371>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90374>>>>>>>        for iColumn from 1 to iNumColumns
90380>>>>>>>>
90380>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90383>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90385>>>>>>>                Move iColumn to iRetval
90386>>>>>>>                Move iNumColumns to iColumn
90387>>>>>>>            End
90387>>>>>>>>
90387>>>>>>>        Loop
90388>>>>>>>>
90388>>>>>>>        Close hTable
90389>>>>>>>
90389>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90390>>>>>>>        Function_Return iRetval
90391>>>>>>>    End_Function
90392>>>>>>>
90392>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90392>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90392>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90394>>>>>>>        tColumnType RetvalType
90394>>>>>>>        tColumnType RetvalType
90394>>>>>>>
90394>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90395>>>>>>>        Function_Return RetvalType.iSQLType
90396>>>>>>>    End_Function
90397>>>>>>>
90397>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90397>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90397>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90399>>>>>>>        tColumnType RetvalType
90399>>>>>>>        tColumnType RetvalType
90399>>>>>>>
90399>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90400>>>>>>>        Function_Return RetvalType.sSQLType
90401>>>>>>>    End_Function
90402>>>>>>>
90402>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90404>>>>>>>        tColumnType RetvalType
90404>>>>>>>        tColumnType RetvalType
90404>>>>>>>
90404>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90405>>>>>>>        Function_Return RetvalType.sPrecision
90406>>>>>>>    End_Function
90407>>>>>>>
90407>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90409>>>>>>>        tColumnType RetvalType
90409>>>>>>>        tColumnType RetvalType
90409>>>>>>>
90409>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90410>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90410>>>>>>>        // if the column type length is _not_ fixed.
90410>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90411>>>>>>>    End_Function
90412>>>>>>>
90412>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90414>>>>>>>        tColumnType RetvalType
90414>>>>>>>        tColumnType RetvalType
90414>>>>>>>        String sValue
90414>>>>>>>        Integer iRetval iPos
90414>>>>>>>
90414>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90415>>>>>>>        Move RetvalType.sPrecision to sValue
90416>>>>>>>        Move (Pos(".", sValue)) to iPos
90417>>>>>>>        If (iPos <> 0) Begin
90419>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90420>>>>>>>        End
90420>>>>>>>>
90420>>>>>>>        Else Begin
90421>>>>>>>            Move sValue to iRetval
90422>>>>>>>        End
90422>>>>>>>>
90422>>>>>>>        Function_Return iRetval
90423>>>>>>>    End_Function
90424>>>>>>>
90424>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90426>>>>>>>        tColumnType RetvalType
90426>>>>>>>        tColumnType RetvalType
90426>>>>>>>        String sValue
90426>>>>>>>        Integer iRetval iPos
90426>>>>>>>
90426>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90427>>>>>>>        Move RetvalType.sPrecision to sValue
90428>>>>>>>        Move (Pos(".", sValue)) to iPos
90429>>>>>>>        If (iPos = 0) Begin
90431>>>>>>>            Function_Return 0
90432>>>>>>>        End
90432>>>>>>>>
90432>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90433>>>>>>>
90433>>>>>>>        Function_Return iRetval
90434>>>>>>>    End_Function
90435>>>>>>>
90435>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90435>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90437>>>>>>>        Function_Return False
90438>>>>>>>    End_Function
90439>>>>>>>
90439>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90439>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90441>>>>>>>        Boolean bIsSame
90441>>>>>>>        Integer iCount iSize
90441>>>>>>>
90441>>>>>>>        Move True to bIsSame
90442>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90443>>>>>>>        Decrement iSize
90444>>>>>>>        For iCount from 0 to iSize
90450>>>>>>>>
90450>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90451>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90452>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90453>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90454>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90455>>>>>>>            If (bIsSame = False) Begin
90457>>>>>>>                Function_Return False
90458>>>>>>>            End
90458>>>>>>>>
90458>>>>>>>        Loop
90459>>>>>>>>
90459>>>>>>>
90459>>>>>>>        Function_Return bIsSame
90460>>>>>>>    End_Function
90461>>>>>>>
90461>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90461>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90463>>>>>>>        Boolean bIsSame
90463>>>>>>>        Integer iSegment
90463>>>>>>>
90463>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90464>>>>>>>        If (bIsSame = False) Begin
90466>>>>>>>            Function_Return False
90467>>>>>>>        End
90467>>>>>>>>
90467>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90468>>>>>>>        If (bIsSame = False) Begin
90470>>>>>>>            Function_Return False
90471>>>>>>>        End
90471>>>>>>>>
90471>>>>>>>
90471>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90473>>>>>>>            // * We should probably not compare SQL index names?
90473>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90473>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90473>>>>>>>            //     Function_Return False
90473>>>>>>>            // End
90473>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90474>>>>>>>            If (bIsSame = False) Begin
90476>>>>>>>                Function_Return False
90477>>>>>>>            End
90477>>>>>>>>
90477>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90478>>>>>>>            If (bIsSame = False) Begin
90480>>>>>>>                Function_Return False
90481>>>>>>>            End
90481>>>>>>>>
90481>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90482>>>>>>>            If (bIsSame = False) Begin
90484>>>>>>>                Function_Return False
90485>>>>>>>            End
90485>>>>>>>>
90485>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90486>>>>>>>            If (bIsSame = False) Begin
90488>>>>>>>                Function_Return False
90489>>>>>>>            End
90489>>>>>>>>
90489>>>>>>>        End
90489>>>>>>>>
90489>>>>>>>
90489>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90490>>>>>>>        Move (iSegment = -1) to bIsSame
90491>>>>>>>
90491>>>>>>>        Function_Return (bIsSame = True)
90492>>>>>>>    End_Function
90493>>>>>>>
90493>>>>>>>    // Compares each segment for the passed index.
90493>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90493>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90495>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90495>>>>>>>        Boolean bIsSame
90495>>>>>>>
90495>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90496>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90497>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90498>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90499>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90500>>>>>>>
90500>>>>>>>        Decrement iNumSegments
90501>>>>>>>        for iSegment from 0 to iNumSegments
90507>>>>>>>>
90507>>>>>>>            Move False to bIsSame
90508>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90510>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90511>>>>>>>            End
90511>>>>>>>>
90511>>>>>>>            If (bIsSame = False) Begin
90513>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90514>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90515>>>>>>>                Function_Return iSegment
90516>>>>>>>            End
90516>>>>>>>>
90516>>>>>>>        Loop
90517>>>>>>>>
90517>>>>>>>
90517>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90518>>>>>>>        Function_Return -1 // This means bIsSame = True
90519>>>>>>>    End_Function
90520>>>>>>>
90520>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90522>>>>>>>        Boolean bIsSame
90522>>>>>>>
90522>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90523>>>>>>>        If (bIsSame = False) Begin
90525>>>>>>>            Function_Return False
90526>>>>>>>        End
90526>>>>>>>>
90526>>>>>>>        If (bCompareIndexUppercase = True) Begin
90528>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90529>>>>>>>            If (bIsSame = False) Begin
90531>>>>>>>                Function_Return False
90532>>>>>>>            End
90532>>>>>>>>
90532>>>>>>>        End
90532>>>>>>>>
90532>>>>>>>        If (bCompareIndexAscending = True) Begin
90534>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90535>>>>>>>            If (bIsSame = False) Begin
90537>>>>>>>                Function_Return False
90538>>>>>>>            End
90538>>>>>>>>
90538>>>>>>>        End
90538>>>>>>>>
90538>>>>>>>
90538>>>>>>>        Function_Return True
90539>>>>>>>    End_Function
90540>>>>>>>
90540>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90542>>>>>>>        Boolean bIsSame bOK
90542>>>>>>>        Integer iSize iSizeTo iCount
90542>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90542>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90543>>>>>>>
90543>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90544>>>>>>>        If (iSize = 0) Begin
90546>>>>>>>            Function_Return True
90547>>>>>>>        End
90547>>>>>>>>
90547>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90548>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90549>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90550>>>>>>>
90550>>>>>>>        for iCount from 0 to (iSize - 1)
90556>>>>>>>>
90556>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90557>>>>>>>            If (bIsSame = False) Begin
90559>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90560>>>>>>>            End
90560>>>>>>>>
90560>>>>>>>        Loop
90561>>>>>>>>
90561>>>>>>>
90561>>>>>>>        // We probably should delete other indexes if they exists.
90561>>>>>>>        for iCount from (iSize +1) to iSizeTo
90567>>>>>>>>
90567>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90568>>>>>>>        Loop
90569>>>>>>>>
90569>>>>>>>
90569>>>>>>>        Function_Return bOK
90570>>>>>>>    End_Function
90571>>>>>>>
90571>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90573>>>>>>>        tAPIIndex[] APIIndexes
90573>>>>>>>        tAPIIndex[] APIIndexes
90574>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90574>>>>>>>        String sDriverID
90574>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90574>>>>>>>
90574>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90575>>>>>>>        Get psDriverID to sDriverID
90576>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90577>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90578>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90581>>>>>>>        If (bIsOpen = False) Begin
90583>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90584>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90585>>>>>>>            Open hTable
90587>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90588>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90589>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90592>>>>>>>            If (bIsOpen = False) Begin
90594>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90595>>>>>>>                Move True to APIIndexes[0].bError
90596>>>>>>>                Function_Return APIIndexes
90597>>>>>>>            End
90597>>>>>>>>
90597>>>>>>>        End
90597>>>>>>>>
90597>>>>>>>
90597>>>>>>>        Move 0 to iCount
90598>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90601>>>>>>>        for iIndex from 1 to iIndexes
90607>>>>>>>>
90607>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90607>>>>>>>            // numbers doesn't not need to be consequitive:
90607>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90610>>>>>>>            If (iNumSegments > 0) Begin
90612>>>>>>>
90612>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90613>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90616>>>>>>>                If (bIsSQLTable = True) Begin
90618>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90621>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90624>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90627>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90630>>>>>>>                End
90630>>>>>>>>
90630>>>>>>>
90630>>>>>>>                Move 0 to iSegmentCount
90631>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90634>>>>>>>                For iSegment from 1 to iNumSegments
90640>>>>>>>>
90640>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90643>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90644>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90647>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90650>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90653>>>>>>>                    Increment iSegmentCount
90654>>>>>>>                Loop
90655>>>>>>>>
90655>>>>>>>                Increment iCount
90656>>>>>>>            End
90656>>>>>>>>
90656>>>>>>>        Loop
90657>>>>>>>>
90657>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90658>>>>>>>
90658>>>>>>>        Function_Return APIIndexes
90659>>>>>>>    End_Function
90660>>>>>>>
90660>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90660>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90660>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90660>>>>>>>    // have "holes" in the series of index numbers.
90660>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90662>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90662>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90663>>>>>>>        tAPIIndexCompare   APIIndexCompare
90663>>>>>>>        tAPIIndexCompare   APIIndexCompare
90663>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90663>>>>>>>
90663>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90664>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90665>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90667>>>>>>>            Function_Return aAPIIndexCompare
90668>>>>>>>        End
90668>>>>>>>>
90668>>>>>>>
90668>>>>>>>        Decrement iSizeFrom
90669>>>>>>>        for iCount from 0 to iSizeFrom
90675>>>>>>>>
90675>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90676>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90677>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90678>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90679>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90680>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90681>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90682>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90683>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90684>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90685>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90686>>>>>>>        Loop
90687>>>>>>>>
90687>>>>>>>
90687>>>>>>>        Decrement iSizeTo
90688>>>>>>>        for iCount from 0 to iSizeTo
90694>>>>>>>>
90694>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90695>>>>>>>            // Search if the Index number already exists in the array; else add it.
90695>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90696>>>>>>>            If (iItem = -1) Begin
90698>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90699>>>>>>>            End
90699>>>>>>>>
90699>>>>>>>
90699>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90700>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90701>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90702>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90703>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90704>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90705>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90706>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90707>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90708>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90709>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90710>>>>>>>        Loop
90711>>>>>>>>
90711>>>>>>>
90711>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90712>>>>>>>
90712>>>>>>>        Function_Return aAPIIndexCompare
90713>>>>>>>    End_Function
90714>>>>>>>
90714>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90714>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90716>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90716>>>>>>>        String sDriverID
90716>>>>>>>
90716>>>>>>>        Get psDriverID to sDriverID
90717>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90718>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90719>>>>>>>        If (bIsSqlTable = True) Begin
90721>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90722>>>>>>>        End
90722>>>>>>>>
90722>>>>>>>
90722>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90723>>>>>>>        If (bIsSame = False) Begin
90725>>>>>>>            Function_Return False
90726>>>>>>>        End
90726>>>>>>>>
90726>>>>>>>
90726>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90728>>>>>>>            // Don't think we should do this. Or should we?
90728>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90728>>>>>>>
90728>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90729>>>>>>>            If (bIsSame = False) Begin
90731>>>>>>>                Function_Return False
90732>>>>>>>            End
90732>>>>>>>>
90732>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90733>>>>>>>            If (bIsSame = False) Begin
90735>>>>>>>                Function_Return False
90736>>>>>>>            End
90736>>>>>>>>
90736>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90737>>>>>>>            If (bIsSame = False) Begin
90739>>>>>>>                Function_Return False
90740>>>>>>>            End
90740>>>>>>>>
90740>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90741>>>>>>>            If (bIsSame = False) Begin
90743>>>>>>>                Function_Return False
90744>>>>>>>            End
90744>>>>>>>>
90744>>>>>>>        End
90744>>>>>>>>
90744>>>>>>>
90744>>>>>>>        Function_Return bIsSame
90745>>>>>>>    End_Function
90746>>>>>>>
90746>>>>>>>    // DF_INDEX_SQL_TYPE values
90746>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90746>>>>>>>    // returns a string with the name.
90746>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90748>>>>>>>        String sRetval
90748>>>>>>>            Case Begin
90748>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
90750>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
90751>>>>>>>                    Case Break
90752>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
90755>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
90756>>>>>>>                    Case Break
90757>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
90760>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
90761>>>>>>>                    Case Break
90762>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
90765>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
90766>>>>>>>                    Case Break
90767>>>>>>>                Case Else
90767>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
90768>>>>>>>            Case End
90768>>>>>>>        Function_Return sRetval
90769>>>>>>>    End_Function
90770>>>>>>>
90770>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90770>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90772>>>>>>>        Function_Return False
90773>>>>>>>    End_Function
90774>>>>>>>
90774>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90774>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90776>>>>>>>        Boolean bIsSame
90776>>>>>>>        Integer iSize iCount
90776>>>>>>>
90776>>>>>>>        Move True to bIsSame
90777>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90778>>>>>>>        Decrement iSize
90779>>>>>>>        For iCount from 0 to iSize
90785>>>>>>>>
90785>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90786>>>>>>>            If (bIsSame = False) Begin
90788>>>>>>>                Function_Return False
90789>>>>>>>            End
90789>>>>>>>>
90789>>>>>>>        Loop
90790>>>>>>>>
90790>>>>>>>
90790>>>>>>>        Function_Return bIsSame
90791>>>>>>>    End_Function
90792>>>>>>>
90792>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90792>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90794>>>>>>>        Boolean bIsSame
90794>>>>>>>
90794>>>>>>>        Move True to bIsSame
90795>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90797>>>>>>>            Function_Return False
90798>>>>>>>        End
90798>>>>>>>>
90798>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90800>>>>>>>            Function_Return False
90801>>>>>>>        End
90801>>>>>>>>
90801>>>>>>>
90801>>>>>>>        // We could also compare field names, but I don't think that is necessary...
90801>>>>>>>
90801>>>>>>>        Function_Return bIsSame
90802>>>>>>>    End_Function
90803>>>>>>>
90803>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90803>>>>>>>    // already exists.
90803>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90805>>>>>>>        Boolean bOK
90805>>>>>>>        Integer iSizeTo iSize iCount iColumn
90805>>>>>>>        String sDriverID
90805>>>>>>>
90805>>>>>>>        Move True to bOK
90806>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90807>>>>>>>        If (iSizeTo > 0) Begin
90809>>>>>>>            Get AutoConnectionIDLogin to bOK
90810>>>>>>>            Move False to Err
90811>>>>>>>            Open hTable Mode DF_EXCLUSIVE
90813>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90816>>>>>>>            Decrement iSizeTo
90817>>>>>>>
90817>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90817>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90817>>>>>>>            Structure_Start hTable sDriverID
90818>>>>>>>                for iCount from 0 to iSizeTo
90824>>>>>>>>
90824>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90825>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90828>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90831>>>>>>>                Loop
90832>>>>>>>>
90832>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90833>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90835>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90836>>>>>>>        End
90836>>>>>>>>
90836>>>>>>>
90836>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90837>>>>>>>        Decrement iSize
90838>>>>>>>        for iCount from 0 to iSize
90844>>>>>>>>
90844>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90845>>>>>>>        Loop
90846>>>>>>>>
90846>>>>>>>
90846>>>>>>>        Function_Return bOK
90847>>>>>>>    End_Function
90848>>>>>>>
90848>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90850>>>>>>>        tAPIRelation[] APIRelations
90850>>>>>>>        tAPIRelation[] APIRelations
90851>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
90851>>>>>>>        Handle hParent
90851>>>>>>>        Boolean bIsOpen
90851>>>>>>>
90851>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90852>>>>>>>        Move 0 to iCount
90853>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90856>>>>>>>        If (bIsOpen = False) Begin
90858>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90859>>>>>>>            Open hTable
90861>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90862>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90865>>>>>>>            If (bIsOpen = False) Begin
90867>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90868>>>>>>>                Move True to APIRelations[0].bError
90869>>>>>>>                Function_Return APIRelations
90870>>>>>>>            End
90870>>>>>>>>
90870>>>>>>>        End
90870>>>>>>>>
90870>>>>>>>
90870>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90873>>>>>>>        For iColumn from 1 to iNumColumns
90879>>>>>>>>
90879>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90882>>>>>>>            If (hParent <> 0) Begin
90884>>>>>>>                Open hParent
90886>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
90887>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
90890>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
90891>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
90894>>>>>>>
90894>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
90895>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
90898>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
90901>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
90902>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
90905>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
90906>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
90907>>>>>>>                Move False                                              to APIRelations[iCount].bError
90908>>>>>>>                Close hParent
90909>>>>>>>                Increment iCount
90910>>>>>>>            End
90910>>>>>>>>
90910>>>>>>>        Loop
90911>>>>>>>>
90911>>>>>>>
90911>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90912>>>>>>>        Function_Return APIRelations
90913>>>>>>>    End_Function
90914>>>>>>>
90914>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90914>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
90914>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
90916>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
90916>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
90917>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90917>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90918>>>>>>>        tAPIRelationCompare   APIRelationCompare
90918>>>>>>>        tAPIRelationCompare   APIRelationCompare
90918>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90918>>>>>>>
90918>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
90919>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
90920>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90922>>>>>>>            Function_Return aAPIRelationCompare
90923>>>>>>>        End
90923>>>>>>>>
90923>>>>>>>
90923>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
90924>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
90925>>>>>>>
90925>>>>>>>        Decrement iSizeFrom
90926>>>>>>>        for iCount from 0 to iSizeFrom
90932>>>>>>>>
90932>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
90933>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
90934>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
90935>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
90936>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
90937>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
90938>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
90939>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
90940>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
90941>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
90942>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
90943>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
90944>>>>>>>        Loop
90945>>>>>>>>
90945>>>>>>>
90945>>>>>>>        Decrement iSizeTo
90946>>>>>>>        for iCount from 0 to iSizeTo
90952>>>>>>>>
90952>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
90953>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
90954>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
90955>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
90956>>>>>>>
90956>>>>>>>            // Search if the relation already exists in the array; else add it.
90956>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
90957>>>>>>>            If (iItem = -1) Begin
90959>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
90960>>>>>>>            End
90960>>>>>>>>
90960>>>>>>>
90960>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
90961>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
90962>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
90963>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
90964>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
90965>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
90966>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
90967>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
90968>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
90969>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
90970>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
90971>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
90972>>>>>>>        Loop
90973>>>>>>>>
90973>>>>>>>
90973>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
90974>>>>>>>
90974>>>>>>>        Function_Return aAPIRelationCompare
90975>>>>>>>    End_Function
90976>>>>>>>
90976>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90976>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
90978>>>>>>>        Function_Return False
90979>>>>>>>    End_Function
90980>>>>>>>
90980>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
90980>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
90980>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
90980>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
90982>>>>>>>        Boolean bFound
90982>>>>>>>
90982>>>>>>>        Move False to Err
90983>>>>>>>        Open CodeMast
90985>>>>>>>        Open CodeType
90987>>>>>>>
90987>>>>>>>        If (bCodeType = True) Begin
90989>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
90990>>>>>>>            Clear CodeType
90991>>>>>>>            Move sTypeValue to CODETYPE.Type
90992>>>>>>>            Find eq CODETYPE by 1
90993>>>>>>>>
90993>>>>>>>            Move Found to bFound
90994>>>>>>>            If (bFound = True) Begin
90996>>>>>>>                Reread CodeType
91000>>>>>>>            End
91000>>>>>>>>
91000>>>>>>>            Else Begin
91001>>>>>>>                Clear CodeType
91002>>>>>>>            End
91002>>>>>>>>
91002>>>>>>>
91002>>>>>>>            Move sTypeValue to CODETYPE.Type
91003>>>>>>>            Move sValue2    to CODETYPE.Description
91004>>>>>>>            Move sValue3    to CODETYPE.Comment
91005>>>>>>>            SaveRecord CODETYPE
91006>>>>>>>
91006>>>>>>>            If (bFound = True) Begin
91008>>>>>>>                Unlock
91009>>>>>>>>
91009>>>>>>>            End
91009>>>>>>>>
91009>>>>>>>        End
91009>>>>>>>>
91009>>>>>>>
91009>>>>>>>        If (bCodeType = False) Begin
91011>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91012>>>>>>>            Clear CODEMAST
91013>>>>>>>            Move sTypeValue to CODEMAST.Type
91014>>>>>>>            Move sValue2    to CODEMAST.Code
91015>>>>>>>            Find eq CODEMAST by 1
91016>>>>>>>>
91016>>>>>>>            Move Found to bFound
91017>>>>>>>            If (bFound = True) Begin
91019>>>>>>>                Reread CODEMAST
91023>>>>>>>            End
91023>>>>>>>>
91023>>>>>>>            Else Begin
91024>>>>>>>                Clear CODEMAST
91025>>>>>>>            End
91025>>>>>>>>
91025>>>>>>>
91025>>>>>>>            Move sTypeValue to CODEMAST.Type
91026>>>>>>>            Move sValue2    to CODEMAST.Code
91027>>>>>>>            Move sValue3    to CODEMAST.Description
91028>>>>>>>            SaveRecord CODEMAST
91029>>>>>>>
91029>>>>>>>            If (bFound = True) Begin
91031>>>>>>>                Unlock
91032>>>>>>>>
91032>>>>>>>            End
91032>>>>>>>>
91032>>>>>>>        End
91032>>>>>>>>
91032>>>>>>>
91032>>>>>>>        Close CodeMast
91033>>>>>>>        Close CodeType
91034>>>>>>>
91034>>>>>>>        Function_Return (Err = False)
91035>>>>>>>    End_Function
91036>>>>>>>
91036>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91036>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91036>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91038>>>>>>>        Boolean bFound
91038>>>>>>>
91038>>>>>>>        Move False to Err
91039>>>>>>>        Open CodeMast
91041>>>>>>>        Open CodeType
91043>>>>>>>
91043>>>>>>>        Clear CodeType
91044>>>>>>>        Move sFromValue to CODETYPE.Type
91045>>>>>>>        Find eq CODETYPE.Type
91046>>>>>>>>
91046>>>>>>>        If (Found = True) Begin
91048>>>>>>>            Reread CODETYPE
91052>>>>>>>                Move sToValue to CODETYPE.Type
91053>>>>>>>                SaveRecord CODETYPE
91054>>>>>>>            Unlock
91055>>>>>>>>
91055>>>>>>>        End
91055>>>>>>>>
91055>>>>>>>
91055>>>>>>>        Clear CODEMAST
91056>>>>>>>        Find gt CODEMAST by Recnum
91057>>>>>>>>
91057>>>>>>>        While (Found = True)
91061>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91062>>>>>>>            If (bFound = True) Begin
91064>>>>>>>                Reread CODEMAST
91068>>>>>>>                    Move sToValue to CODEMAST.Type
91069>>>>>>>                    SaveRecord CODEMAST
91070>>>>>>>                Unlock
91071>>>>>>>>
91071>>>>>>>            End
91071>>>>>>>>
91071>>>>>>>            Find gt CODEMAST by Recnum
91072>>>>>>>>
91072>>>>>>>        Loop
91073>>>>>>>>
91073>>>>>>>
91073>>>>>>>        Close CodeMast
91074>>>>>>>        Close CodeType
91075>>>>>>>
91075>>>>>>>        Function_Return (Err = False)
91076>>>>>>>    End_Function
91077>>>>>>>
91077>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91077>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91079>>>>>>>        Boolean bFound
91079>>>>>>>
91079>>>>>>>        Move False to Err
91080>>>>>>>        Open CodeMast
91082>>>>>>>
91082>>>>>>>        Clear CODEMAST
91083>>>>>>>        Move sTypeValue to CODEMAST.Type
91084>>>>>>>        Move sValue2    to CODEMAST.Code
91085>>>>>>>        Find eq CODEMAST.Code
91086>>>>>>>>
91086>>>>>>>        Move Found to bFound
91087>>>>>>>        If (bFound = True) Begin
91089>>>>>>>            Delete CODEMAST
91090>>>>>>>        End
91090>>>>>>>>
91090>>>>>>>
91090>>>>>>>        Close CodeMast
91091>>>>>>>
91091>>>>>>>        Function_Return (Err = False)
91092>>>>>>>    End_Function
91093>>>>>>>
91093>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91095>>>>>>>        Boolean bRecnum bToAnsi
91095>>>>>>>        Integer iCh
91095>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91095>>>>>>>
91095>>>>>>>        If (Trim(sDataPath) = "") Begin
91097>>>>>>>            Function_Return False
91098>>>>>>>        End
91098>>>>>>>>
91098>>>>>>>
91098>>>>>>>        Move False to Err
91099>>>>>>>        Get psDriverID     to sDriverID
91100>>>>>>>        Get psConnectionID to sConnectionID
91101>>>>>>>        Get psSchema       to sSchemaName
91102>>>>>>>        Get True           to bRecnum
91103>>>>>>>        Get pbToANSI       to bToAnsi
91104>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91105>>>>>>>        If (bToAnsi = False) Begin
91107>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91108>>>>>>>        End
91108>>>>>>>>
91108>>>>>>>
91108>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91109>>>>>>>        Move "CodeMast.int"         to sFileName
91110>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91111>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91114>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91117>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91120>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91123>>>>>>>            Writeln channel iCh ("")
91126>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91129>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91132>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91135>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91138>>>>>>>            Writeln channel iCh ("")
91141>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91144>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91147>>>>>>>            Writeln channel iCh ("")
91150>>>>>>>        Send Seq_Close_Channel iCh
91151>>>>>>>
91151>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91152>>>>>>>        Move "CodeType.int"         to sFileName
91153>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91154>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91157>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91160>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91163>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91166>>>>>>>            Writeln channel iCh ("")
91169>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91172>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91175>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91178>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91181>>>>>>>            Writeln channel iCh ("")
91184>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91187>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91190>>>>>>>            Writeln channel iCh ("")
91193>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91196>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91199>>>>>>>            Writeln channel iCh ("")
91202>>>>>>>        Send Seq_Close_Channel iCh
91203>>>>>>>
91203>>>>>>>        Function_Return (Err = False)
91204>>>>>>>    End_Function
91205>>>>>>>
91205>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91205>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91207>>>>>>>        Function_Return False
91208>>>>>>>    End_Function
91209>>>>>>>
91209>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91209>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91209>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91211>>>>>>>        Boolean bOK bExists
91211>>>>>>>        String sDataPath sBackupFolder
91211>>>>>>>
91211>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91212>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91213>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91214>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91215>>>>>>>
91215>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91216>>>>>>>        If (bExists = False) Begin
91218>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91219>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91220>>>>>>>            If (bExists = False) Begin
91222>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91223>>>>>>>>
91223>>>>>>>                Function_Return False
91224>>>>>>>            End
91224>>>>>>>>
91224>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91225>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91226>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91227>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91228>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91229>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91230>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91231>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91232>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91233>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91234>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91235>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91236>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91237>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91238>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91239>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91240>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91241>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91242>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91243>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91244>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91245>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91246>>>>>>>        End
91246>>>>>>>>
91246>>>>>>>
91246>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91247>>>>>>>        Function_Return True
91248>>>>>>>    End_Function
91249>>>>>>>    
91249>>>>>>>    // Check if the file exists in the Data folder,
91249>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91249>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91251>>>>>>>        String sPath
91251>>>>>>>        Boolean bExists
91251>>>>>>>
91251>>>>>>>        Get psDataPathFirstPart to sPath
91252>>>>>>>        Move (sPath + sFileName) to sFileName
91253>>>>>>>        Get vFilePathExists sFileName to bExists
91254>>>>>>>
91254>>>>>>>        If (bExists = False) Begin
91256>>>>>>>            // Read from memory & create file on disk.
91256>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91257>>>>>>>            Get vFilePathExists sFileName to bExists
91258>>>>>>>        End
91258>>>>>>>>
91258>>>>>>>        Function_Return bExists
91259>>>>>>>    End_Function
91260>>>>>>>
91260>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91262>>>>>>>        tColumnType RetvalType
91262>>>>>>>        tColumnType RetvalType
91262>>>>>>>        Integer iRetval
91262>>>>>>>
91262>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91263>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91264>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91266>>>>>>>            If (iLength <= 255) Begin
91268>>>>>>>                Move DF_ASCII to iRetval
91269>>>>>>>            End
91269>>>>>>>>
91269>>>>>>>        End
91269>>>>>>>>
91269>>>>>>>        Function_Return iRetval
91270>>>>>>>    End_Function
91271>>>>>>>
91271>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91273>>>>>>>        String sRetval
91273>>>>>>>
91273>>>>>>>        Case Begin
91273>>>>>>>            Case (iDataType = DF_ASCII)
91275>>>>>>>                Move "DF_ASCII" to sRetval
91276>>>>>>>                Case Break
91277>>>>>>>            Case (iDataType = DF_BCD)
91280>>>>>>>                Move "DF_BCD" to sRetval
91281>>>>>>>                Case Break
91282>>>>>>>            Case (iDataType = DF_BINARY)
91285>>>>>>>                Move "DF_BINARY" to sRetval
91286>>>>>>>                Case Break
91287>>>>>>>            Case (iDataType = DF_DATE)
91290>>>>>>>                Move "DF_DATE" to sRetval
91291>>>>>>>                Case Break
91292>>>>>>>            Case (iDataType = DF_DATETIME)
91295>>>>>>>                Move "DF_DATETIME" to sRetval
91296>>>>>>>                Case Break
91297>>>>>>>            Case (iDataType = DF_TEXT)
91300>>>>>>>                Move "DF_TEXT" to sRetval
91301>>>>>>>                Case Break
91302>>>>>>>            Case Else
91302>>>>>>>                Move "" to sRetval
91303>>>>>>>        Case End
91303>>>>>>>
91303>>>>>>>        Function_Return sRetval
91304>>>>>>>    End_Function
91305>>>>>>>
91305>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91305>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91307>>>>>>>        String sRetval sServer
91307>>>>>>>        tColumnType RetvalType
91307>>>>>>>        tColumnType RetvalType
91307>>>>>>>        Integer iDriver iDataFlexType
91307>>>>>>>        Handle hDatabase
91307>>>>>>>
91307>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91308>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91309>>>>>>>        Get DriverIndex sDriverID to iDriver
91310>>>>>>>        Get psServer to sServer
91311>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91312>>>>>>>        If (hDatabase = 0) Begin
91314>>>>>>>            Function_Return ""
91315>>>>>>>        End
91315>>>>>>>>
91315>>>>>>>
91315>>>>>>>        Case Begin
91315>>>>>>>            Case (iDataFlexType = DF_ASCII)
91317>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91320>>>>>>>                Case Break
91321>>>>>>>            Case (iDataFlexType = DF_BCD)
91324>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91327>>>>>>>                Case Break
91328>>>>>>>            Case (iDataFlexType = DF_BINARY)
91331>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91334>>>>>>>                Case Break
91335>>>>>>>            Case (iDataFlexType = DF_DATE)
91338>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91341>>>>>>>                Case Break
91342>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91345>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91348>>>>>>>                Case Break
91349>>>>>>>            Case (iDataFlexType = DF_TEXT)
91352>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91355>>>>>>>                Case Break
91356>>>>>>>            Case Else
91356>>>>>>>                Move "" to sRetval
91357>>>>>>>        Case End
91357>>>>>>>
91357>>>>>>>        Function_Return sRetval
91358>>>>>>>    End_Function
91359>>>>>>>
91359>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91361>>>>>>>        String sDriverID sServer
91361>>>>>>>        tColumnType RetvalType
91361>>>>>>>        tColumnType RetvalType
91361>>>>>>>        Integer iDbType iDriver
91361>>>>>>>        Handle hDatabase
91361>>>>>>>
91361>>>>>>>        Get psDriverID to sDriverID
91362>>>>>>>        Get piDbType   to iDbType
91363>>>>>>>        Get DriverIndex sDriverID to iDriver
91364>>>>>>>        Get psServer to sServer
91365>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91366>>>>>>>        If (hDatabase = 0) Begin
91368>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91369>>>>>>>>
91369>>>>>>>            Procedure_Return
91370>>>>>>>        End
91370>>>>>>>>
91370>>>>>>>
91370>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91373>>>>>>>
91373>>>>>>>    End_Procedure
91374>>>>>>>
91374>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91376>>>>>>>        String sDriverID sServer
91376>>>>>>>        tColumnType RetvalType
91376>>>>>>>        tColumnType RetvalType
91376>>>>>>>        Integer iDbType iDriver
91376>>>>>>>        Handle hDatabase
91376>>>>>>>
91376>>>>>>>        Get psDriverID to sDriverID
91377>>>>>>>        Get piDbType   to iDbType
91378>>>>>>>        Get DriverIndex sDriverID to iDriver
91379>>>>>>>        Get psServer to sServer
91380>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91381>>>>>>>        If (hDatabase = 0) Begin
91383>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91384>>>>>>>>
91384>>>>>>>            Procedure_Return
91385>>>>>>>        End
91385>>>>>>>>
91385>>>>>>>
91385>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91388>>>>>>>
91388>>>>>>>    End_Procedure
91389>>>>>>>
91389>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91389>>>>>>>    // are mapped to the standard DataFlex data types.
91389>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91389>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91391>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91391>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91393>>>>>>>        String sDataType
91393>>>>>>>        Integer iDataType iDriverID iCount
91393>>>>>>>        Boolean bSQLDriver
91393>>>>>>>
91393>>>>>>>        Move 0 to iCount
91394>>>>>>>        Get DriverIndex sDriverID to iDriverID
91395>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91396>>>>>>>        If (bSQLDriver = False) Begin
91398>>>>>>>            Function_Return EmptyArray
91399>>>>>>>        End
91399>>>>>>>>
91399>>>>>>>
91399>>>>>>>        // DF_ASCII
91399>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91401>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91404>>>>>>>        End
91404>>>>>>>>
91404>>>>>>>        Else Begin
91405>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91408>>>>>>>        End
91408>>>>>>>>
91408>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91409>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91410>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91411>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91412>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91413>>>>>>>        Increment iCount
91414>>>>>>>
91414>>>>>>>        // DF_BINARY
91414>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91416>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91419>>>>>>>        End
91419>>>>>>>>
91419>>>>>>>        Else Begin
91420>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91423>>>>>>>        End
91423>>>>>>>>
91423>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91424>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91425>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91426>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91427>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91428>>>>>>>        Increment iCount
91429>>>>>>>
91429>>>>>>>        // DF_DATE
91429>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91431>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91434>>>>>>>        End
91434>>>>>>>>
91434>>>>>>>        Else Begin
91435>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91438>>>>>>>        End
91438>>>>>>>>
91438>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91439>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91440>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91441>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91442>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91443>>>>>>>        Increment iCount
91444>>>>>>>
91444>>>>>>>        // DF_DATETIME
91444>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91446>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91449>>>>>>>        End
91449>>>>>>>>
91449>>>>>>>        Else Begin
91450>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91453>>>>>>>        End
91453>>>>>>>>
91453>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91454>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91455>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91456>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91457>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91458>>>>>>>        Increment iCount
91459>>>>>>>
91459>>>>>>>        // DF_NUMERIC
91459>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91459>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91459>>>>>>>        // we make them here all "Numeric"...
91459>>>>>>>        Case Begin
91459>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91461>>>>>>>                Move SQL_NUMERIC to iDataType
91462>>>>>>>                Move "numeric"   to sDataType
91463>>>>>>>                Case Break
91464>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91467>>>>>>>                Move SQL_NUMERIC to iDataType
91468>>>>>>>                Move "NUMERIC"   to sDataType
91469>>>>>>>                Case Break
91470>>>>>>>            Case Else
91470>>>>>>>                Move DF_BCD      to iDataType
91471>>>>>>>                Move "Numeric"   to sDataType
91472>>>>>>>        Case End
91472>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91473>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91474>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91475>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91476>>>>>>>        Increment iCount
91477>>>>>>>
91477>>>>>>>        // DF_TEXT
91477>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91479>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91482>>>>>>>        End
91482>>>>>>>>
91482>>>>>>>        Else Begin
91483>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91486>>>>>>>        End
91486>>>>>>>>
91486>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91487>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91488>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91489>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91490>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91491>>>>>>>
91491>>>>>>>        Function_Return ColumnTypeArray
91492>>>>>>>    End_Function
91493>>>>>>>
91493>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91495>>>>>>>        tColumnType[] ColumnTypeArray
91495>>>>>>>        tColumnType[] ColumnTypeArray
91496>>>>>>>        tColumnType   ColumnType
91496>>>>>>>        tColumnType   ColumnType
91496>>>>>>>        Integer iCount iSize
91496>>>>>>>
91496>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91497>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91498>>>>>>>        Decrement iSize
91499>>>>>>>
91499>>>>>>>        for iCount from 0 to iSize
91505>>>>>>>>
91505>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91507>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91508>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91509>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91510>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91511>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91512>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91513>>>>>>>                Move iSize to iCount
91514>>>>>>>            End
91514>>>>>>>>
91514>>>>>>>        Loop
91515>>>>>>>>
91515>>>>>>>
91515>>>>>>>        Function_Return ColumnType
91516>>>>>>>    End_Function
91517>>>>>>>
91517>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91517>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91517>>>>>>>    // but the Logical name is different.
91517>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91517>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91519>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91519>>>>>>>        Handle hInTable hMasterTable 
91519>>>>>>>        Boolean bIsAlias
91519>>>>>>>        
91519>>>>>>>        Move hTable to hInTable
91520>>>>>>>        Move False to bIsAlias
91521>>>>>>>        Move 0 to hMasterTable
91522>>>>>>>        
91522>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91525>>>>>>>        // Remove any prefix with a driver name.
91525>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91526>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91529>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91530>>>>>>>        
91530>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91530>>>>>>>        // so we can safely return a "False".
91530>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91532>>>>>>>            Function_Return False
91533>>>>>>>        End
91533>>>>>>>>
91533>>>>>>>        
91533>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91533>>>>>>>        // as the passed hTable root name.
91533>>>>>>>        // A master table always has the same root and logical name.
91533>>>>>>>        Move 0 to hTable
91534>>>>>>>        Repeat
91534>>>>>>>>
91534>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91537>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
91539>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91542>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91543>>>>>>>                // If we found another table with the same root and logical name
91543>>>>>>>                // we have found a master table.
91543>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91545>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91548>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91549>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91551>>>>>>>                        Move hTable to hMasterTable   
91552>>>>>>>                        Move 0 to hTable // To end the loop.
91553>>>>>>>                    End
91553>>>>>>>>
91553>>>>>>>                End
91553>>>>>>>>
91553>>>>>>>            End
91553>>>>>>>>
91553>>>>>>>        Until (hTable = 0)
91555>>>>>>>        
91555>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91557>>>>>>>            Move True to bIsAlias
91558>>>>>>>        End
91558>>>>>>>>
91558>>>>>>>        
91558>>>>>>>        Function_Return bIsAlias
91559>>>>>>>    End_Function
91560>>>>>>>
91560>>>>>>>    // To Open a table with any driver.
91560>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91560>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91560>>>>>>>    //
91560>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91560>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
91560>>>>>>>    // returns a True if successful (table could be opened).
91560>>>>>>>    //
91560>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91560>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91560>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91560>>>>>>>    // set properly we can open the table.
91560>>>>>>>    //
91560>>>>>>>    // DAW Driver Syntax:
91560>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91560>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91560>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91560>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91560>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91560>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91560>>>>>>>    //
91560>>>>>>>    // DAW Driver Sample:
91560>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91560>>>>>>>    //
91560>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91562>>>>>>>        String sTableNameOrg
91562>>>>>>>        Boolean bOpen bOK
91562>>>>>>>        tSQLConnection SQLConnection
91562>>>>>>>        tSQLConnection SQLConnection
91562>>>>>>>        
91562>>>>>>>        Move False to bOpen
91563>>>>>>>        Move sTableName to sTableNameOrg
91564>>>>>>>        If (hTable > 0) Begin
91566>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
91567>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91568>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91569>>>>>>>            Send Ignore_Error of Error_Object_Id 10
91570>>>>>>>            Open hTable Mode iMode
91572>>>>>>>            Send Trap_Error of Error_Object_Id 20529
91573>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91574>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91575>>>>>>>            Send Trap_Error of Error_Object_Id 10
91576>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91579>>>>>>>            If (bOpen = True) Begin
91581>>>>>>>                Function_Return True
91582>>>>>>>            End
91582>>>>>>>>
91582>>>>>>>        End
91582>>>>>>>>
91582>>>>>>>
91582>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91583>>>>>>>        If (hTable > 0) Begin
91585>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91588>>>>>>>        End
91588>>>>>>>>
91588>>>>>>>
91588>>>>>>>        Function_Return bOpen
91589>>>>>>>    End_Function
91590>>>>>>>
91590>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91592>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91592>>>>>>>        Boolean bOpen bOK
91592>>>>>>>        tSQLConnection SQLConnection
91592>>>>>>>        tSQLConnection SQLConnection
91592>>>>>>>
91592>>>>>>>        If (hTable < 1) Begin
91594>>>>>>>            Function_Return False
91595>>>>>>>        End
91595>>>>>>>>
91595>>>>>>>
91595>>>>>>>        Move sTableName to sTableNameOrg
91596>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91597>>>>>>>        Move SQLConnection.sDriverID to sDriverID
91598>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91599>>>>>>>        Move SQLConnection.sSchema to sSchema
91600>>>>>>>        If (sSchema = "") Begin
91602>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91603>>>>>>>        End
91603>>>>>>>>
91603>>>>>>>
91603>>>>>>>        // We need to remove the ".int" part of the table name because
91603>>>>>>>        // the table name after the "#" in the connection syntax below wants the
91603>>>>>>>        // "bare" table name without any extension.
91603>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91605>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
91607>>>>>>>                Get ParseFileExtension sTableName to sExt
91608>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91609>>>>>>>            End
91609>>>>>>>>
91609>>>>>>>            Else Begin
91610>>>>>>>                Move sTableName to sTableNameShort
91611>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
91612>>>>>>>            End
91612>>>>>>>>
91612>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91613>>>>>>>            Move sConnection to sTableName
91614>>>>>>>        End
91614>>>>>>>>
91614>>>>>>>
91614>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91615>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91616>>>>>>>        If (hTable = 0) Begin
91618>>>>>>>            Get NextFreeFilelistSlot to hTable
91619>>>>>>>        End
91619>>>>>>>>
91619>>>>>>>
91619>>>>>>>        Case Begin
91619>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91621>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91621>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91623>>>>>>>                    Close hTable
91624>>>>>>>                    Open sTableName as hTable
91626>>>>>>>                End
91626>>>>>>>>
91626>>>>>>>                Else Begin
91627>>>>>>>                    Get OpenTableExclusive hTable to bOK
91628>>>>>>>                    If (bOK = False) Begin
91630>>>>>>>                        Function_Return False
91631>>>>>>>                    End
91631>>>>>>>>
91631>>>>>>>                End
91631>>>>>>>>
91631>>>>>>>                Case Break
91632>>>>>>>
91632>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91635>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91635>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91637>>>>>>>                    Close hTable
91638>>>>>>>                    Open sTableName as hTable
91640>>>>>>>                End
91640>>>>>>>>
91640>>>>>>>                Else Begin
91641>>>>>>>                    Get OpenTableExclusive hTable to bOK
91642>>>>>>>                    If (bOK = False) Begin
91644>>>>>>>                        Function_Return False
91645>>>>>>>                    End
91645>>>>>>>>
91645>>>>>>>                End
91645>>>>>>>>
91645>>>>>>>                Case Break
91646>>>>>>>
91646>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91649>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91649>>>>>>>                If (iMode = DF_SHARE) Begin
91651>>>>>>>                    Close hTable
91652>>>>>>>                    Open sTableName as hTable
91654>>>>>>>                End
91654>>>>>>>>
91654>>>>>>>                Else Begin
91655>>>>>>>                    Get OpenTableExclusive hTable to bOK
91656>>>>>>>                    If (bOK = False) Begin
91658>>>>>>>                        Function_Return False
91659>>>>>>>                    End
91659>>>>>>>>
91659>>>>>>>                End
91659>>>>>>>>
91659>>>>>>>                Case Break
91660>>>>>>>
91660>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91663>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91665>>>>>>>                    Close hTable
91666>>>>>>>                    Open sTableName as hTable
91668>>>>>>>                End
91668>>>>>>>>
91668>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91671>>>>>>>                    Get OpenTableExclusive hTable to bOK
91672>>>>>>>                    If (bOK = False) Begin
91674>>>>>>>                        Function_Return False
91675>>>>>>>                    End
91675>>>>>>>>
91675>>>>>>>                End
91675>>>>>>>>
91675>>>>>>>                Else Begin
91676>>>>>>>                    Open hTable
91678>>>>>>>                End
91678>>>>>>>>
91678>>>>>>>                Case Break
91679>>>>>>>
91679>>>>>>>            Case Else
91679>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91680>>>>>>>>
91680>>>>>>>        Case End
91680>>>>>>>
91680>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91681>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91682>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91684>>>>>>>            Move False to Found
91685>>>>>>>        End
91685>>>>>>>>
91685>>>>>>>        // If open failed, the Err is set to true,
91685>>>>>>>        // but we don't want that because it could end our loop.
91685>>>>>>>        Move False to Err
91686>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91689>>>>>>>
91689>>>>>>>        Function_Return bOpen
91690>>>>>>>    End_Function
91691>>>>>>>
91691>>>>>>>    // Pass a table's logical name
91691>>>>>>>    // Returns True if the table exists in filelist.cfg.
91691>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91693>>>>>>>        Handle hTable
91693>>>>>>>        Boolean bFound
91693>>>>>>>        String sCompareTable
91693>>>>>>>
91693>>>>>>>        Move False to bFound
91694>>>>>>>        Move 0 to hTable
91695>>>>>>>        Repeat
91695>>>>>>>>
91695>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91698>>>>>>>            If (hTable > 0) Begin
91700>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91703>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91705>>>>>>>                    Move True to bFound
91706>>>>>>>                End
91706>>>>>>>>
91706>>>>>>>            End
91706>>>>>>>>
91706>>>>>>>            If (bFound = True) ;                Break
91709>>>>>>>        Until (hTable = 0)
91711>>>>>>>
91711>>>>>>>        Function_Return (bFound = True)
91712>>>>>>>    End_Function
91713>>>>>>>
91713>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91713>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91715>>>>>>>        Boolean bOK bExists
91715>>>>>>>        String sDriverID
91715>>>>>>>
91715>>>>>>>        Get _UtilTableExists hTable to bExists
91716>>>>>>>        If (bExists = False) Begin
91718>>>>>>>            Function_Return DATAFLEX_ID
91719>>>>>>>        End
91719>>>>>>>>
91719>>>>>>>        Get OpenTableExclusive hTable to bOK
91720>>>>>>>        If (bOK = False) Begin
91722>>>>>>>            Function_Return DATAFLEX_ID
91723>>>>>>>        End
91723>>>>>>>>
91723>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91726>>>>>>>        Function_Return sDriverID
91727>>>>>>>    End_Function
91728>>>>>>>
91728>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
91728>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
91730>>>>>>>        Handle hTable
91730>>>>>>>        Integer iRetval
91730>>>>>>>
91730>>>>>>>        Move 0 to hTable
91731>>>>>>>        Move 0 to iRetval
91732>>>>>>>
91732>>>>>>>        Repeat
91732>>>>>>>>
91732>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91735>>>>>>>            If (hTable > 0) Begin
91737>>>>>>>                Increment iRetval
91738>>>>>>>            End
91738>>>>>>>>
91738>>>>>>>        Until (hTable = 0)
91740>>>>>>>
91740>>>>>>>        Function_Return iRetval
91741>>>>>>>    End_Function
91742>>>>>>>
91742>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
91742>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
91744>>>>>>>        Handle hTable
91744>>>>>>>        String sRoot sDriverID
91744>>>>>>>        Boolean bIsSQLTable
91744>>>>>>>        Integer iPos
91744>>>>>>>
91744>>>>>>>        Move 0 to hTable
91745>>>>>>>        Move "" to sDriverID
91746>>>>>>>        Move False to bIsSQLTable
91747>>>>>>>
91747>>>>>>>        Repeat
91747>>>>>>>>
91747>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91750>>>>>>>            If (hTable > 0) Begin
91752>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
91755>>>>>>>                If (sRoot contains ":") Begin
91757>>>>>>>                    Move (Pos(":", sRoot)) to iPos
91758>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
91759>>>>>>>                End
91759>>>>>>>>
91759>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
91760>>>>>>>            End
91760>>>>>>>>
91760>>>>>>>
91760>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
91762>>>>>>>
91762>>>>>>>        Function_Return sDriverID
91763>>>>>>>    End_Function
91764>>>>>>>
91764>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
91766>>>>>>>        String sRootName
91766>>>>>>>        Boolean bIsSQL
91766>>>>>>>        Handle hTable
91766>>>>>>>
91766>>>>>>>        Move False to bIsSQL
91767>>>>>>>        Move 0 to hTable
91768>>>>>>>        Repeat
91768>>>>>>>>
91768>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91771>>>>>>>            If (hTable > 0) Begin
91773>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91776>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
91777>>>>>>>                If (bIsSQL = True) Begin
91779>>>>>>>                    Move 0 to hTable
91780>>>>>>>                End
91780>>>>>>>>
91780>>>>>>>            End
91780>>>>>>>>
91780>>>>>>>        Until (hTable = 0)
91782>>>>>>>
91782>>>>>>>        Function_Return (bIsSQL = False)
91783>>>>>>>    End_Function
91784>>>>>>>
91784>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91784>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
91786>>>>>>>        Function_Return False
91787>>>>>>>    End_Function
91788>>>>>>>
91788>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91790>>>>>>>        String  sRetval
91790>>>>>>>        String[] sOverlapFieldsArray
91791>>>>>>>        Integer iType iColumn iColumns
91791>>>>>>>        Boolean bOpen bOverlap
91791>>>>>>>
91791>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91794>>>>>>>        If (bOpen = False) Begin
91796>>>>>>>            Open hTable
91798>>>>>>>        End
91798>>>>>>>>
91798>>>>>>>
91798>>>>>>>        Move "" to sRetval
91799>>>>>>>
91799>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91802>>>>>>>
91802>>>>>>>        for iColumn from 0 to iColumns
91808>>>>>>>>
91808>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91811>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91813>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91816>>>>>>>                If (bOverlap) Begin
91818>>>>>>>                    If (sRetval <> "") Begin
91820>>>>>>>                        Append sRetval ","
91821>>>>>>>                    End
91821>>>>>>>>
91821>>>>>>>                    Append sRetval iColumn
91822>>>>>>>                End
91822>>>>>>>>
91822>>>>>>>            End
91822>>>>>>>>
91822>>>>>>>        Loop
91823>>>>>>>>
91823>>>>>>>
91823>>>>>>>        If (bOpen = False) Begin
91825>>>>>>>            Close hTable
91826>>>>>>>        End
91826>>>>>>>>
91826>>>>>>>
91826>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91827>>>>>>>
91827>>>>>>>        Function_Return sOverlapFieldsArray
91828>>>>>>>    End_Function
91829>>>>>>>
91829>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
91831>>>>>>>        Handle hoRegistry hoODBCDriverNames
91831>>>>>>>        Boolean bExists bKeyOpened
91831>>>>>>>        String sKey
91831>>>>>>>        String[] sDrivers
91832>>>>>>>        Integer iDriverNames iDriverName
91832>>>>>>>
91832>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91833>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91834>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
91835>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91836>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
91837>>>>>>>        If (bExists) Begin
91839>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91840>>>>>>>            If (bKeyOpened) Begin
91842>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91843>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91844>>>>>>>                If (iDriverNames > 0) Begin
91846>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91847>>>>>>>                    Decrement iDriverNames
91848>>>>>>>                    for iDriverName from 0 to iDriverNames
91854>>>>>>>>
91854>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91855>>>>>>>                    Loop
91856>>>>>>>>
91856>>>>>>>                End
91856>>>>>>>>
91856>>>>>>>                Send CloseKey of hoRegistry
91857>>>>>>>            End
91857>>>>>>>>
91857>>>>>>>        End
91857>>>>>>>>
91857>>>>>>>        Send Destroy of hoRegistry
91858>>>>>>>
91858>>>>>>>        Function_Return sDrivers
91859>>>>>>>    End_Function
91860>>>>>>>
91860>>>>>>>    Procedure IncreaseSortBufferSize
91862>>>>>>>        String sNull
91862>>>>>>>        Integer iSortBufferSize
91862>>>>>>>        Boolean bBufferSet
91862>>>>>>>
91862>>>>>>>        Move "" to sNull
91863>>>>>>>        Move (1024 * 128) to iSortBufferSize
91864>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91869>>>>>>>
91869>>>>>>>    End_Procedure
91870>>>>>>>
91870>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91872>>>>>>>        Integer iLastIndex iIndex iNumSegments
91872>>>>>>>        Boolean bOK
91872>>>>>>>        String sDriverID
91872>>>>>>>
91872>>>>>>>        If (hTable > 0) Begin
91874>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91875>>>>>>>            Close hTable
91876>>>>>>>            Get OpenTableExclusive hTable to bOK
91877>>>>>>>            If (bOK = False) Begin
91879>>>>>>>                Procedure_Return
91880>>>>>>>            End
91880>>>>>>>>
91880>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91883>>>>>>>            Structure_Start hTable sDriverID
91884>>>>>>>                for iIndex from 1 to iLastIndex
91890>>>>>>>>
91890>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91893>>>>>>>                    If (iNumSegments > 0) Begin
91895>>>>>>>                        If (bSetToBatch = True) Begin
91897>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
91900>>>>>>>                        End
91900>>>>>>>>
91900>>>>>>>                        Else Begin
91901>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
91904>>>>>>>                        End
91904>>>>>>>>
91904>>>>>>>                    End
91904>>>>>>>>
91904>>>>>>>                Loop
91905>>>>>>>>
91905>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91907>>>>>>>        End
91907>>>>>>>>
91907>>>>>>>    End_Procedure
91908>>>>>>>
91908>>>>>>>    Function NextFreeFilelistSlot Returns Handle
91910>>>>>>>        Handle hTable
91910>>>>>>>
91910>>>>>>>        Move 0 to hTable
91911>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
91914>>>>>>>
91914>>>>>>>        Function_Return hTable
91915>>>>>>>    End_Function
91916>>>>>>>
91916>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
91916>>>>>>>    Procedure DebugPrint String sStmt String sFileName
91918>>>>>>>        Integer iCh
91918>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
91919>>>>>>>            Write channel iCh sStmt
91921>>>>>>>        Send Seq_Close_Channel iCh
91922>>>>>>>    End_Procedure
91923>>>>>>>
91923>>>>>>>    // Returns the integer number for the passed Driver ID that is
91923>>>>>>>    // needed by some database API calls.
91923>>>>>>>    Function DriverIndex String sDriverID Returns Integer
91925>>>>>>>        String  sCurrentDriver
91925>>>>>>>        Integer iNumberOfDrivers iDriver iCount
91925>>>>>>>
91925>>>>>>>        Move 0 to iDriver
91926>>>>>>>
91926>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91929>>>>>>>        for iCount from 1 to iNumberOfDrivers
91935>>>>>>>>
91935>>>>>>>
91935>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
91938>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
91940>>>>>>>                Move iCount to iDriver
91941>>>>>>>            End
91941>>>>>>>>
91941>>>>>>>        Loop
91942>>>>>>>>
91942>>>>>>>
91942>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
91942>>>>>>>        If (iDriver = 0) Begin
91944>>>>>>>            Move False to Err
91945>>>>>>>            Load_Driver sDriverID
91946>>>>>>>            If (Err = False) Begin
91948>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
91951>>>>>>>            End
91951>>>>>>>>
91951>>>>>>>        End
91951>>>>>>>>
91951>>>>>>>
91951>>>>>>>        Function_Return iDriver
91952>>>>>>>    End_Function
91953>>>>>>>
91953>>>>>>>
91953>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
91955>>>>>>>        String  sSqlServerClientVersionName
91955>>>>>>>        
91955>>>>>>>        Case Begin
91955>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91957>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
91958>>>>>>>                Case Break
91959>>>>>>>                
91959>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
91962>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
91963>>>>>>>                Case Break
91964>>>>>>>            
91964>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
91967>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
91968>>>>>>>                Case Break
91969>>>>>>>            
91969>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
91972>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
91973>>>>>>>                Case Break
91974>>>>>>>            
91974>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
91977>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
91978>>>>>>>                Case Break
91979>>>>>>>            
91979>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
91982>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
91983>>>>>>>                Case Break
91984>>>>>>>            
91984>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
91987>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
91988>>>>>>>                Case Break
91989>>>>>>>            
91989>>>>>>>            Case Else
91989>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
91990>>>>>>>        Case End
91990>>>>>>>        
91990>>>>>>>        Function_Return sSqlServerClientVersionName
91991>>>>>>>    End_Function
91992>>>>>>>
91992>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
91994>>>>>>>        String  sSqlServerClientDriverName
91994>>>>>>>        
91994>>>>>>>        Case Begin
91994>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
91996>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
91997>>>>>>>                Case Break
91998>>>>>>>                
91998>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92001>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92002>>>>>>>                Case Break
92003>>>>>>>            
92003>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92006>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92007>>>>>>>                Case Break
92008>>>>>>>            
92008>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92011>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92012>>>>>>>                Case Break
92013>>>>>>>            
92013>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92016>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92017>>>>>>>                Case Break
92018>>>>>>>            
92018>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92021>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92022>>>>>>>                Case Break
92023>>>>>>>            
92023>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92026>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92027>>>>>>>                Case Break
92028>>>>>>>            
92028>>>>>>>            Case Else
92028>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92029>>>>>>>        Case End
92029>>>>>>>        
92029>>>>>>>        Function_Return sSqlServerClientDriverName
92030>>>>>>>    End_Function
92031>>>>>>>    
92031>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92033>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92033>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92033>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92033>>>>>>>        Boolean bOK
92033>>>>>>>        
92033>>>>>>>        Move "" to sRetval
92034>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92035>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92036>>>>>>>        Load_Driver MSSQLDRV_ID
92037>>>>>>>
92037>>>>>>>        // Loop through all loaded drivers.
92037>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92040>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92046>>>>>>>>
92046>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92049>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92051>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92052>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92055>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92056>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92057>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92058>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92059>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92061>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92062>>>>>>>                End                                
92062>>>>>>>>
92062>>>>>>>                Else Begin
92063>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92064>>>>>>>                End
92064>>>>>>>>
92064>>>>>>>            End
92064>>>>>>>>
92064>>>>>>>        Loop
92065>>>>>>>>
92065>>>>>>>        Send Destroy of hoCLIHandler  
92066>>>>>>>        Send Destroy of hoMSSQLHandler  
92067>>>>>>>        If (bShowErrorDialog = True) Begin
92069>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92070>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92072>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92073>>>>>>>                If (bExitProgram = True) Begin
92075>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92076>>>>>>>                End
92076>>>>>>>>
92076>>>>>>>                Send Stop_Box sRetval  
92077>>>>>>>                If (bExitProgram = True) Begin
92079>>>>>>>                    Send Exit_Application
92080>>>>>>>                End
92080>>>>>>>>
92080>>>>>>>            End
92080>>>>>>>>
92080>>>>>>>        End
92080>>>>>>>>
92080>>>>>>>        
92080>>>>>>>        Function_Return sRetval
92081>>>>>>>    End_Function  
92082>>>>>>>    
92082>>>>>>>    // Returns True if first "." separated string is greater than the second.
92082>>>>>>>    // It checks from left to right, one part of the string at a time.
92082>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92082>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92084>>>>>>>        String[] asVersion asSQLVersion          
92086>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92086>>>>>>>        
92086>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92087>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92088>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92089>>>>>>>        // Make sure the two arrays are of the same size:
92089>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92091>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92092>>>>>>>        End
92092>>>>>>>>
92092>>>>>>>        Decrement iSize
92093>>>>>>>        for iCount from 0 to iSize
92099>>>>>>>>
92099>>>>>>>            Move asVersion[iCount]    to iVersion
92100>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92101>>>>>>>            CompilerWarnings Off
92101>>>>>>>            If (iVersion > iSQLVersion) Break
92104>>>>>>>            CompilerWarnings On
92104>>>>>>>        Loop
92105>>>>>>>>
92105>>>>>>>        
92105>>>>>>>        Function_Return (iVersion > iSQLVersion)
92106>>>>>>>    End_Function
92107>>>>>>>
92107>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92107>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92107>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92107>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92109>>>>>>>        Integer iMode iErrorObject
92109>>>>>>>        Boolean bOpened
92109>>>>>>>        String sTableName 
92109>>>>>>>        Handle hoCurrentErrorHandler
92109>>>>>>>
92109>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92110>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92110>>>>>>>        // so we generate an error here:
92110>>>>>>>        If (IsDebuggerPresent()) Begin
92112>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92113>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92114>>>>>>>            If (iErrorObject <> 0) Begin
92116>>>>>>>                Move iErrorObject to Error_Object_Id
92117>>>>>>>            End
92117>>>>>>>>
92117>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92118>>>>>>>>
92118>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92119>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92120>>>>>>>            Function_Return False
92121>>>>>>>        End
92121>>>>>>>>
92121>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92124>>>>>>>        If (bOpened) Begin
92126>>>>>>>//            If (IsDebuggerPresent()) Begin
92126>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92126>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92126>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
92126>>>>>>>//                    Function_Return True
92126>>>>>>>//                End
92126>>>>>>>//            End
92126>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92129>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92131>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92132>>>>>>>                Function_Return True
92133>>>>>>>            End
92133>>>>>>>>
92133>>>>>>>            Close hTable
92134>>>>>>>        End
92134>>>>>>>>
92134>>>>>>>        Else Begin
92135>>>>>>>            Open hTable
92137>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92140>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92142>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92145>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92147>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92148>>>>>>>                    Function_Return True
92149>>>>>>>                End
92149>>>>>>>>
92149>>>>>>>            End
92149>>>>>>>>
92149>>>>>>>
92149>>>>>>>        End
92149>>>>>>>>
92149>>>>>>>
92149>>>>>>>        Close hTable
92150>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92152>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92155>>>>>>>
92155>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92156>>>>>>>        Function_Return bOpened
92157>>>>>>>    End_Function
92158>>>>>>>
92158>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92160>>>>>>>        String sConnectionID sConnectionString sDriverID
92160>>>>>>>        Boolean bExists bOK bSQLDriver
92160>>>>>>>        Handle hoCLI hoDriver
92160>>>>>>>        Integer iRetval
92160>>>>>>>        tSQLConnection SQLConnection
92160>>>>>>>        tSQLConnection SQLConnection
92160>>>>>>>
92160>>>>>>>        Get psDriverID to sDriverID
92161>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92162>>>>>>>        If (bSQLDriver = False) Begin
92164>>>>>>>            Function_Return True
92165>>>>>>>        End
92165>>>>>>>>
92165>>>>>>>
92165>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92166>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92167>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92168>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92169>>>>>>>
92169>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92170>>>>>>>        If (bExists = False) Begin
92172>>>>>>>            // We always start by deleting the current connection - if any - because the
92172>>>>>>>            // login details my have changed.
92172>>>>>>>            Get phoCLIHandler to hoCLI
92173>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92174>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92175>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92176>>>>>>>            If (bOk = False) Begin
92178>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92179>>>>>>>>
92179>>>>>>>                Function_Return False
92180>>>>>>>            End
92180>>>>>>>>
92180>>>>>>>            Move bOK to bExists
92181>>>>>>>        End
92181>>>>>>>>
92181>>>>>>>
92181>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92182>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92183>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92184>>>>>>>        Send Destroy of hoDriver
92185>>>>>>>
92185>>>>>>>        Function_Return (bExists = True)
92186>>>>>>>    End_Function
92187>>>>>>>
92187>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92187>>>>>>>    // Returns: False if nobody else is running
92187>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92187>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92187>>>>>>>    //      tables are not locked as DataFlex tables are.
92187>>>>>>>    Function IsDatabaseInUse Returns Boolean
92189>>>>>>>        Handle  hTable
92189>>>>>>>        String  sRootName
92189>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92189>>>>>>>        Integer iCount iTables
92189>>>>>>>
92189>>>>>>>        Move 0 to iTables
92190>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92191>>>>>>>        Get AutoConnectionIDLogin to bOK
92192>>>>>>>        Get UtilFilelistNoOfTables to iTables
92193>>>>>>>        Set piPosition   of ghoProgressBar to 0
92194>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92195>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92196>>>>>>>        Move 0 to hTable
92197>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92200>>>>>>>        Move False to bErr
92201>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92202>>>>>>>
92202>>>>>>>        Repeat
92202>>>>>>>>
92202>>>>>>>            Set piPosition of ghoProgressBar to iCount
92203>>>>>>>            Increment iCount
92204>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92207>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92208>>>>>>>
92208>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92208>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92209>>>>>>>            Move False to bOpen
92210>>>>>>>            Get _UtilTableExists hTable to bExists
92211>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92211>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92213>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92214>>>>>>>                Open hTable
92216>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92219>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92220>>>>>>>                If (bOpen = True) Begin
92222>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92222>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92223>>>>>>>                    If (bAlias = False) Begin
92225>>>>>>>                        Close hTable
92226>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92227>>>>>>>                        If (bOpen = False) Begin
92229>>>>>>>                            Move True to bErr
92230>>>>>>>                        End
92230>>>>>>>>
92230>>>>>>>                    End
92230>>>>>>>>
92230>>>>>>>                End
92230>>>>>>>>
92230>>>>>>>                Close hTable
92231>>>>>>>            End
92231>>>>>>>>
92231>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92234>>>>>>>            If (bErr = True ) ;                Break
92237>>>>>>>        Until (not(hTable))
92239>>>>>>>
92239>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92240>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92241>>>>>>>        Move False to Err
92242>>>>>>>
92242>>>>>>>        Function_Return bErr
92243>>>>>>>    End_Function
92244>>>>>>>
92244>>>>>>>End_Class
92245>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 23.0\Pkg\for_all.pkg)
92245>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92245>>>>>>>//
92245>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92245>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92245>>>>>>>// conjunction with constraint-clauses.
92245>>>>>>>//
92245>>>>>>>// SYNTAX:
92245>>>>>>>//
92245>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92245>>>>>>>//    <Constraints...>
92245>>>>>>>//    {DO}
92245>>>>>>>//      <loop body>
92245>>>>>>>//  End_For_All
92245>>>>>>>//
92245>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92245>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92245>>>>>>>//
92245>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92245>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92245>>>>>>>//   End_For_All
92245>>>>>>>//
92245>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92245>>>>>>>//
92245>>>>>>>//   For_All Customer BY Index.1
92245>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92245>>>>>>>//     DO
92245>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92245>>>>>>>//   End_For_All
92245>>>>>>>//
92245>>>>>>>// Constraint clauses are:
92245>>>>>>>//
92245>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92245>>>>>>>//   CONSTRAIN <File> AS <Expression>
92245>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92245>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92245>>>>>>>//
92245>>>>>>>// For example, to list all customers with a bad status whose names start
92245>>>>>>>// with "A" and which have not made a payment in thirty days:
92245>>>>>>>//
92245>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92245>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92245>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92245>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92245>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92245>>>>>>>//      DO
92245>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92245>>>>>>>//    End_For_All
92245>>>>>>>//
92245>>>>>>>
92245>>>>>>>
92245>>>>>>>//This command starts the loop process body when constraints are used;
92245>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92245>>>>>>>//command line, and not on a line by itself
92245>>>>>>>//
92245>>>>>>>
92245>>>>>>>//Ends a For_All loop
92245>>>>>>>//
92245>>>>>>>
92245>>>>>>>
92245>>>>>
92245>>>>>
92245>>>>>Class cDbUpdateVersion is a cObject
92246>>>>>
92246>>>>>    Procedure Construct_Object    
92248>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92248>>>>>        String[] aSQLQueryMessages
92249>>>>>        
92249>>>>>        Forward Send Construct_Object
92251>>>>>
92251>>>>>        // cDbUpdateHandler object event.
92251>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92253>>>>>        If (bOnCreateExecuted = False) Begin    
92255>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92257>>>>>            If (bUseCustomDbVersion = False) Begin
92259>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92261>>>>>            End
92261>>>>>>
92261>>>>>            Delegate Send CheckIntFilesIntegrity
92263>>>>>            Delegate Send OnCreate
92265>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92267>>>>>        End
92267>>>>>>
92267>>>>>
92267>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92267>>>>>        // event was triggered, thus an actual change of the database was made.
92267>>>>>        Property Boolean pbVersionUpdate False
92268>>>>>
92268>>>>>        // This property must be manually set within each cDbUpdateVersion object
92268>>>>>        // by the programmer, to a consecutive number.
92268>>>>>        Property Number pnVersionNumber
92269>>>>>
92269>>>>>        Property Boolean pbUseConnectionID True
92270>>>>>        Property Boolean private.pbToANSI   True
92271>>>>>        Property Boolean private.pbRecnum   True
92272>>>>>        Property Boolean private.pbCopyData True
92273>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92274>>>>>        Property Boolean private.pbCompareDate_DateTime False
92275>>>>>        Property Boolean private.pbCompareIndexAscending False
92276>>>>>        Property Boolean private.pbCompareIndexUppercase False
92277>>>>>        Property String private.psSchema
92278>>>>>        Property String private.psBaseTableSpace
92279>>>>>        Property String private.psLongTableSpace
92280>>>>>        Property String private.psIndexTableSpace
92281>>>>>
92281>>>>>        // Driver default value settings:
92281>>>>>        Property String private.psDriverDefaultValueASCII    ""
92282>>>>>        Property String private.psDriverDefaultValueBinary   ""
92283>>>>>        Property String private.psDriverDefaultValueDate     ""
92284>>>>>        Property String private.psDriverDefaultValueDateTime ""
92285>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92286>>>>>        Property String private.psDriverDefaultValueText     ""
92287>>>>>
92287>>>>>        // Driver "nullability" settings:
92287>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92288>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92289>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92290>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92291>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92292>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92293>>>>>
92293>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92293>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92293>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92293>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92293>>>>>        // We reset it here for each cDbUpdateVersion object
92293>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92295>>>>>    End_Procedure
92296>>>>>
92296>>>>>    // *** Main hook event message ***
92296>>>>>    // Place your database update logic here!
92296>>>>>    Procedure OnUpdate
92298>>>>>    End_Procedure
92299>>>>>
92299>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92299>>>>>    // imported to the cDbUpdateHandler container class which should be a
92299>>>>>    // parent object to this object. To have the Studio's Property Panel
92299>>>>>    // "behave" aka show these properties we need to duplicate them in this
92299>>>>>    // class and "relay" them to the parent object.
92299>>>>>    Procedure Set pbToANSI Boolean bState
92301>>>>>        Set private.pbToANSI  to bState
92302>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92303>>>>>        Delegate Set pbToANSI to bState
92305>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92306>>>>>    End_Procedure
92307>>>>>
92307>>>>>    Function pbToANSI Returns Boolean
92309>>>>>        Function_Return (private.pbToAnsi(Self))
92310>>>>>    End_Function
92311>>>>>
92311>>>>>    Procedure Set pbRecnum Boolean bState
92313>>>>>        Set private.pbRecnum  to bState
92314>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92315>>>>>        Delegate Set pbRecnum to bState
92317>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92318>>>>>    End_Procedure
92319>>>>>
92319>>>>>    Function pbRecnum Returns Boolean
92321>>>>>        Function_Return (private.pbRecnum(Self))
92322>>>>>    End_Function
92323>>>>>
92323>>>>>    Procedure Set pbCopyData Boolean bState
92325>>>>>        Set private.pbCopyData  to bState
92326>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92327>>>>>        Delegate Set pbCopyData to bState
92329>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92330>>>>>    End_Procedure
92331>>>>>
92331>>>>>    Function pbCopyData Returns Boolean
92333>>>>>        Function_Return (private.pbCopyData(Self))
92334>>>>>    End_Function
92335>>>>>
92335>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92335>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92337>>>>>        Set private.pbApiTableUpdateAuto  to bState
92338>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92339>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92340>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92341>>>>>    End_Procedure
92342>>>>>
92342>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92344>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92345>>>>>    End_Function
92346>>>>>
92346>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92348>>>>>        Set private.pbCompareDate_DateTime  to bState
92349>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92350>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92351>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92352>>>>>    End_Procedure
92353>>>>>
92353>>>>>    Function pbCompareDate_DateTime Returns Boolean
92355>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92356>>>>>    End_Function
92357>>>>>
92357>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92359>>>>>        Set private.pbCompareIndexAscending  to bState
92360>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92361>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92362>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92363>>>>>    End_Procedure
92364>>>>>
92364>>>>>    Function pbCompareIndexAscending Returns Boolean
92366>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92367>>>>>    End_Function
92368>>>>>
92368>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92370>>>>>        Set private.pbCompareIndexUppercase  to bState
92371>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92372>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92373>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92374>>>>>    End_Procedure
92375>>>>>
92375>>>>>    Function pbCompareIndexUppercase Returns Boolean
92377>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92378>>>>>    End_Function
92379>>>>>
92379>>>>>    Procedure Set psSchema String sValue
92381>>>>>        Set private.psSchema  to sValue
92382>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92383>>>>>        Delegate Set psSchema to sValue
92385>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92386>>>>>    End_Procedure
92387>>>>>
92387>>>>>    // First retrieve the private value that might have been set in the object.
92387>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92387>>>>>    // it might have been specified in the SQLConnections.ini file.
92387>>>>>    Function psSchema Returns String
92389>>>>>        String sValue
92389>>>>>        Get private.psSchema to sValue
92390>>>>>        If (sValue = "") Begin
92392>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92393>>>>>        End
92393>>>>>>
92393>>>>>        Function_Return sValue
92394>>>>>    End_Function
92395>>>>>
92395>>>>>    Procedure Set psBaseTableSpace String sValue
92397>>>>>        Set private.psBaseTableSpace  to sValue
92398>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92399>>>>>        Delegate Set psBaseTableSpace to sValue
92401>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92402>>>>>    End_Procedure
92403>>>>>
92403>>>>>    // First retrieve the private value that might have been set in the object.
92403>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92403>>>>>    // it might have been specified in the SQLConnections.ini file.
92403>>>>>    Function psBaseTableSpace Returns String
92405>>>>>        String sValue
92405>>>>>        Get private.psBaseTableSpace to sValue
92406>>>>>        If (sValue = "") Begin
92408>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92409>>>>>        End
92409>>>>>>
92409>>>>>        Function_Return sValue
92410>>>>>    End_Function
92411>>>>>
92411>>>>>    Procedure Set psLongTableSpace String sValue
92413>>>>>        Set private.psLongTableSpace  to sValue
92414>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92415>>>>>        Delegate Set psLongTableSpace to sValue
92417>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92418>>>>>    End_Procedure
92419>>>>>
92419>>>>>    // First retrieve the private value that might have been set in the object.
92419>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92419>>>>>    // it might have been specified in the SQLConnections.ini file.
92419>>>>>    Function psLongTableSpace Returns String
92421>>>>>        String sValue
92421>>>>>        Get private.psLongTableSpace to sValue
92422>>>>>        If (sValue = "") Begin
92424>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
92425>>>>>        End
92425>>>>>>
92425>>>>>        Function_Return sValue
92426>>>>>    End_Function
92427>>>>>
92427>>>>>    Procedure Set psIndexTableSpace String sValue
92429>>>>>        Set private.psIndexTableSpace  to sValue
92430>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92431>>>>>        Delegate Set psIndexTableSpace to sValue
92433>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92434>>>>>    End_Procedure
92435>>>>>
92435>>>>>    // First retrieve the private value that might have been set in the object.
92435>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92435>>>>>    // it might have been specified in the SQLConnections.ini file.
92435>>>>>    Function psIndexTableSpace Returns String
92437>>>>>        String sValue
92437>>>>>        Get private.psIndexTableSpace to sValue
92438>>>>>        If (sValue = "") Begin
92440>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
92441>>>>>        End
92441>>>>>>
92441>>>>>        Function_Return sValue
92442>>>>>    End_Function
92443>>>>>
92443>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92445>>>>>        Set private.psDriverDefaultValueASCII  to sValue
92446>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92447>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
92449>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92450>>>>>    End_Procedure
92451>>>>>
92451>>>>>    // First retrieve the private value that might have been set in the object.
92451>>>>>    // If blank; get it from the parent object
92451>>>>>    Function psDriverDefaultValueASCII Returns String
92453>>>>>        String sValue
92453>>>>>        Get private.psDriverDefaultValueASCII to sValue
92454>>>>>        If (sValue = "") Begin
92456>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
92458>>>>>        End
92458>>>>>>
92458>>>>>        Function_Return sValue
92459>>>>>    End_Function
92460>>>>>
92460>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92462>>>>>        Set private.psDriverDefaultValueBinary  to sValue
92463>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92464>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
92466>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92467>>>>>    End_Procedure
92468>>>>>
92468>>>>>    // First retrieve the private value that might have been set in the object.
92468>>>>>    // If blank; get it from the parent object
92468>>>>>    Function psDriverDefaultValueBinary Returns String
92470>>>>>        String sValue
92470>>>>>        Get private.psDriverDefaultValueBinary to sValue
92471>>>>>        If (sValue = "") Begin
92473>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
92475>>>>>        End
92475>>>>>>
92475>>>>>        Function_Return sValue
92476>>>>>    End_Function
92477>>>>>
92477>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92479>>>>>        Set private.psDriverDefaultValueDate  to sValue
92480>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92481>>>>>        Delegate Set psDriverDefaultValueDate to sValue
92483>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92484>>>>>    End_Procedure
92485>>>>>
92485>>>>>    // First retrieve the private value that might have been set in the object.
92485>>>>>    // If blank; get it from the parent object
92485>>>>>    Function psDriverDefaultValueDate Returns String
92487>>>>>        String sValue
92487>>>>>        Get private.psDriverDefaultValueDate to sValue
92488>>>>>        If (sValue = "") Begin
92490>>>>>            Delegate Get psDriverDefaultValueDate to sValue
92492>>>>>        End
92492>>>>>>
92492>>>>>        Function_Return sValue
92493>>>>>    End_Function
92494>>>>>
92494>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92496>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
92497>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92498>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
92500>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92501>>>>>    End_Procedure
92502>>>>>
92502>>>>>    // First retrieve the private value that might have been set in the object.
92502>>>>>    // If blank; get it from the parent object
92502>>>>>    Function psDriverDefaultValueDateTime Returns String
92504>>>>>        String sValue
92504>>>>>        Get private.psDriverDefaultValueDateTime to sValue
92505>>>>>        If (sValue = "") Begin
92507>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
92509>>>>>        End
92509>>>>>>
92509>>>>>        Function_Return sValue
92510>>>>>    End_Function
92511>>>>>
92511>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92513>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
92514>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92515>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
92517>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92518>>>>>    End_Procedure
92519>>>>>
92519>>>>>    // First retrieve the private value that might have been set in the object.
92519>>>>>    // If blank; get it from the parent object
92519>>>>>    Function psDriverDefaultValueNumeric Returns String
92521>>>>>        String sValue
92521>>>>>        Get private.psDriverDefaultValueNumeric to sValue
92522>>>>>        If (sValue = "") Begin
92524>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
92526>>>>>        End
92526>>>>>>
92526>>>>>        Function_Return sValue
92527>>>>>    End_Function
92528>>>>>
92528>>>>>    Procedure Set psDriverDefaultValueText String sValue
92530>>>>>        Set private.psDriverDefaultValueText  to sValue
92531>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92532>>>>>        Delegate Set psDriverDefaultValueText to sValue
92534>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92535>>>>>    End_Procedure
92536>>>>>
92536>>>>>    // First retrieve the private value that might have been set in the object.
92536>>>>>    // If blank; get it from the parent object
92536>>>>>    Function psDriverDefaultValueText Returns String
92538>>>>>        String sValue
92538>>>>>        Get private.psDriverDefaultValueText to sValue
92539>>>>>        If (sValue = "") Begin
92541>>>>>            Delegate Get psDriverDefaultValueText to sValue
92543>>>>>        End
92543>>>>>>
92543>>>>>        Function_Return sValue
92544>>>>>    End_Function
92545>>>>>
92545>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92547>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
92548>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92549>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
92551>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92552>>>>>    End_Procedure
92553>>>>>
92553>>>>>    // First retrieve the private value that might have been set in the object.
92553>>>>>    // If blank; get it from the parent object
92553>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92555>>>>>        Boolean bState
92555>>>>>        Get private.pbDriverDefaultNullableASCII to bState
92556>>>>>        If (bState = False) Begin
92558>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
92560>>>>>        End
92560>>>>>>
92560>>>>>        Function_Return bState
92561>>>>>    End_Function
92562>>>>>
92562>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92564>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
92565>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92566>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
92568>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92569>>>>>    End_Procedure
92570>>>>>
92570>>>>>    // First retrieve the private value that might have been set in the object.
92570>>>>>    // If blank; get it from the parent object
92570>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92572>>>>>        Boolean bState
92572>>>>>        Get private.pbDriverDefaultNullableBinary to bState
92573>>>>>        If (bState = False) Begin
92575>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
92577>>>>>        End
92577>>>>>>
92577>>>>>        Function_Return bState
92578>>>>>    End_Function
92579>>>>>
92579>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92581>>>>>        Set private.pbDriverDefaultNullableDate  to bState
92582>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92583>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
92585>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92586>>>>>    End_Procedure
92587>>>>>
92587>>>>>    // First retrieve the private value that might have been set in the object.
92587>>>>>    // If blank; get it from the parent object
92587>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92589>>>>>        Boolean bState
92589>>>>>        Get private.pbDriverDefaultNullableDate to bState
92590>>>>>        If (bState = False) Begin
92592>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
92594>>>>>        End
92594>>>>>>
92594>>>>>        Function_Return bState
92595>>>>>    End_Function
92596>>>>>
92596>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92598>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
92599>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92600>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
92602>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92603>>>>>    End_Procedure
92604>>>>>
92604>>>>>    // First retrieve the private value that might have been set in the object.
92604>>>>>    // If blank; get it from the parent object
92604>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92606>>>>>        Boolean bState
92606>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
92607>>>>>        If (bState = False) Begin
92609>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
92611>>>>>        End
92611>>>>>>
92611>>>>>        Function_Return bState
92612>>>>>    End_Function
92613>>>>>
92613>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92615>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
92616>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92617>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
92619>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92620>>>>>    End_Procedure
92621>>>>>
92621>>>>>    // First retrieve the private value that might have been set in the object.
92621>>>>>    // If blank; get it from the parent object
92621>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92623>>>>>        Boolean bState
92623>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
92624>>>>>        If (bState = False) Begin
92626>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
92628>>>>>        End
92628>>>>>>
92628>>>>>        Function_Return bState
92629>>>>>    End_Function
92630>>>>>
92630>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92632>>>>>        Set private.pbDriverDefaultNullableText  to bState
92633>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92634>>>>>        Delegate Set pbDriverDefaultNullableText to bState
92636>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92637>>>>>    End_Procedure
92638>>>>>
92638>>>>>    // First retrieve the private value that might have been set in the object.
92638>>>>>    // If blank; get it from the parent object
92638>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92640>>>>>        Boolean bState
92640>>>>>        Get private.pbDriverDefaultNullableText to bState
92641>>>>>        If (bState = False) Begin
92643>>>>>            Delegate Get pbDriverDefaultNullableText to bState
92645>>>>>        End
92645>>>>>>
92645>>>>>        Function_Return bState
92646>>>>>    End_Function
92647>>>>>
92647>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
92649>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
92649>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
92649>>>>>
92649>>>>>        Get psDriverID to sDriverID
92650>>>>>        Get psSchema to sSchema
92651>>>>>
92651>>>>>        Get psBaseTableSpace to sBaseTableSpace
92652>>>>>        If (sBaseTableSpace <> "") Begin
92654>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92655>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
92657>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92658>>>>>        End
92658>>>>>>
92658>>>>>
92658>>>>>        Get psLongTableSpace to sLongTableSpace
92659>>>>>        If (sLongTableSpace <> "") Begin
92661>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92662>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
92664>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92665>>>>>        End
92665>>>>>>
92665>>>>>
92665>>>>>        Get psIndexTableSpace to sIndexTableSpace
92666>>>>>        If (sIndexTableSpace <> "") Begin
92668>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92669>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
92671>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92672>>>>>        End
92672>>>>>>
92672>>>>>
92672>>>>>        Get pbUseConnectionID to bUseConnectionID
92673>>>>>        Get pbToANSI          to bToANSI
92674>>>>>        Get pbRecnum          to bRecnum
92675>>>>>        Get pbCopyData        to bCopyData
92676>>>>>
92676>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
92677>>>>>
92677>>>>>        Function_Return bOK
92678>>>>>    End_Function
92679>>>>>
92679>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
92679>>>>>//        Boolean bOK bExists
92679>>>>>//        String sDataPath sBackupFolder
92679>>>>>//        
92679>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
92679>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
92679>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92679>>>>>//        Get vFolderFormat sDataPath to sDataPath
92679>>>>>//        
92679>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92679>>>>>//        If (bExists = False) Begin
92679>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92679>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92679>>>>>//            If (bExists = False) Begin
92679>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
92679>>>>>//                Function_Return False
92679>>>>>//            End                                                                                                                                            
92679>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
92679>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
92679>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
92679>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
92679>>>>>//        End
92679>>>>>//        
92679>>>>>//        Set Message_Text of ghoStatusPanel to ""
92679>>>>>//        Function_Return bOK
92679>>>>>//    End_Function
92679>>>>>//
92679>>>>>    // This is automatically called after the OnUpdate
92679>>>>>    // event has been executed. It will automatically update the
92679>>>>>    // version database field/column with the "pnVersionNumber"
92679>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
92679>>>>>    Procedure UpdateVersionColumnValue
92681>>>>>        Number nVersion nCurrentValue
92681>>>>>        Integer hTable iColumn
92681>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
92681>>>>>
92681>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
92681>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
92681>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92683>>>>>        Get pbVersionUpdate to bVersionUpdate
92684>>>>>
92684>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
92686>>>>>            Get pnVersionNumber to nVersion
92687>>>>>            Delegate Get piDbVersionFileNumber  to hTable
92689>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
92691>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
92691>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
92691>>>>>            Close DF_ALL DF_PERMANENT
92692>>>>>
92692>>>>>            Open hTable
92694>>>>>
92694>>>>>            // It is then the developer responsibility to take care of finding
92694>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
92694>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92696>>>>>            If (bUseCustomDbVersion = True) Begin
92698>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
92700>>>>>            End
92700>>>>>>
92700>>>>>
92700>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92703>>>>>            If (nCurrentValue < nVersion) Begin
92705>>>>>                Lock
92706>>>>>>
92706>>>>>                    If (bUseCustomDbVersion = False) Begin
92708>>>>>                        Vfind hTable Recnum GE                            
92710>>>>>                    End
92710>>>>>>
92710>>>>>                    Set_Field_Value hTable iColumn to nVersion
92713>>>>>                    SaveRecord hTable
92714>>>>>                Unlock
92715>>>>>>
92715>>>>>            End
92715>>>>>>
92715>>>>>            Close hTable
92716>>>>>        End
92716>>>>>>
92716>>>>>    End_Procedure
92717>>>>>
92717>>>>>// Property of the container object (cDbUpdateHandler)
92717>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
92717>>>>>
92717>>>>>    Procedure End_Construct_Object
92719>>>>>        Forward Send End_Construct_Object
92721>>>>>        Send ProcessUpdate True
92722>>>>>    End_Procedure
92723>>>>>    
92723>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
92725>>>>>        Number nVersion nCurrentValue
92725>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
92725>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
92725>>>>>        String sObjectName
92725>>>>>        tDbVersionInfo[] dbVersionInfoArray
92725>>>>>        tDbVersionInfo[] dbVersionInfoArray
92726>>>>>
92726>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
92728>>>>>
92728>>>>>        // If the programmer forgot to set the version number we do not allow for the application
92728>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
92728>>>>>        // one database update is depended on an earlier update and that earlier version
92728>>>>>        // update was never executed it could lead to disastrous results.
92728>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
92728>>>>>        Get pnVersionNumber to nVersion
92729>>>>>        If (nVersion = 0) Begin
92731>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
92732>>>>>            Move (Name(Self)) to sObjectName
92733>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
92734>>>>>>
92734>>>>>            Send Exit_Application
92735>>>>>        End
92735>>>>>>
92735>>>>>
92735>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
92735>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
92735>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
92737>>>>>        If (bOnPreUpdateExecuted = False) Begin
92739>>>>>            Delegate Send OnPreUpdate
92741>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
92743>>>>>        End
92743>>>>>>
92743>>>>>        
92743>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
92745>>>>>        
92745>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92747>>>>>        If (bUseCustomDbVersion = False) Begin
92749>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
92749>>>>>        End
92749>>>>>>
92749>>>>>        Else Begin
92750>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
92751>>>>>            If (bTableExists = False) Begin
92753>>>>>                Delegate Send OnCreateCustomDbVersionTable
92755>>>>>            End
92755>>>>>>
92755>>>>>        End
92755>>>>>>
92755>>>>>        
92755>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
92755>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
92755>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
92757>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
92759>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
92760>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
92761>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
92762>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
92764>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
92766>>>>>        End
92766>>>>>>
92766>>>>>
92766>>>>>        Delegate Get piDbVersionFileNumber  to hTable
92768>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
92770>>>>>
92770>>>>>        Open hTable
92772>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92775>>>>>        If (bOpened = False) Begin
92777>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
92778>>>>>            Send Exit_Application
92779>>>>>        End
92779>>>>>>
92779>>>>>        
92779>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
92779>>>>>        // in case we take care of it here.
92779>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
92782>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
92784>>>>>            Vfind hTable 0 GT
92786>>>>>        End
92786>>>>>>
92786>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
92789>>>>>        If (bSystemTable = True) Begin
92791>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92794>>>>>        End
92794>>>>>>
92794>>>>>        Else Begin
92795>>>>>            If (bUseCustomDbVersion = True) Begin
92797>>>>>                Send OnFindVersionRecord
92798>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
92801>>>>>            End
92801>>>>>>
92801>>>>>        End
92801>>>>>>
92801>>>>>
92801>>>>>        Close hTable
92802>>>>>
92802>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
92802>>>>>        // If not set we do nothing.
92802>>>>>        If (nCurrentValue < nVersion) Begin
92804>>>>>
92804>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
92804>>>>>            // execution of database update code. So if true _and_ one error
92804>>>>>            // has already occured; we're out of here.
92804>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
92806>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92808>>>>>            If (bStopOnFirstError = True) Begin
92810>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
92812>>>>>                    Procedure_Return
92813>>>>>                End
92813>>>>>>
92813>>>>>            End
92813>>>>>>
92813>>>>>
92813>>>>>            // This is send to the parent container object (cDbUpdateHandler)
92813>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
92815>>>>>
92815>>>>>            // If the parent property pbContinueOnError = False, an update
92815>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
92815>>>>>            Delegate Get pbContinueOnError to bContinueOnError
92817>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
92819>>>>>                Procedure_Return
92820>>>>>            End
92820>>>>>>
92820>>>>>
92820>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
92822>>>>>
92822>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
92823>>>>>
92823>>>>>            // *** Programmer's main hook event for database update functions:
92823>>>>>            Send OnUpdate
92824>>>>>
92824>>>>>            Set pbVersionUpdate to True
92825>>>>>            Send UpdateVersionColumnValue
92826>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
92828>>>>>        End
92828>>>>>>
92828>>>>>
92828>>>>>    End_Procedure
92829>>>>>
92829>>>>>End_Class
92830>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
92830>>>>>//****************************************************************************
92830>>>>>// $Module type: Class
92830>>>>>// $Module name: cDbUpdateUserCount.pkg
92830>>>>>// $Author     : Emil Stojanov Quantaris B.V.
92830>>>>>//
92830>>>>>//               Collected from DAW's newsgroups.
92830>>>>>//
92830>>>>>// Description : It uses the windows API to lock bytes in a file.
92830>>>>>//               If the application or PC craches it will release the lock
92830>>>>>//               automatically.
92830>>>>>//
92830>>>>>// Note 1      : It will count the number of running app's, so if a
92830>>>>>//               user starts the app twice on one machine it will count as two users.
92830>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
92830>>>>>//               However, to not conflict with any other usage of this class it was
92830>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
92830>>>>>//               and cDbUpdateVersion classes)
92830>>>>>//
92830>>>>>// $Rev History:
92830>>>>>//    2008-10-17  Module header created (Militaty data format)
92830>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
92830>>>>>//                for easy translation to other languages.
92830>>>>>//                Added the tUserCount struct for easier passing of parameters.
92830>>>>>//                Added the ApplicationPath message.
92830>>>>>//****************************************************************************
92830>>>>>Use LanguageText.pkg
92830>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
92830>>>>>>>Use GlobalFunctionsProcedures.pkg
92830>>>>>>>// Sample:
92830>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
92830>>>>>>>
92830>>>>>>>
92830>>>>>>>// Symbols used by UserCounting
92830>>>>>>>    Define GENERIC_READ         for |CI$80000000
92830>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
92830>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
92830>>>>>>>    Define GENERIC_ALL          for |CI$10000000
92830>>>>>>>    Define CREATE_NEW           for 1
92830>>>>>>>    Define CREATE_ALWAYS        for 2
92830>>>>>>>    Define OPEN_EXISTING        for 3
92830>>>>>>>    Define OPEN_ALWAYS          for 4
92830>>>>>>>    Define TRUNCATE_EXISTING    for 5
92830>>>>>>>    Define FILE_BEGIN           for 0
92830>>>>>>>    Define FILE_CURRENT         for 1
92830>>>>>>>    Define FILE_END             for 2
92830>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
92830>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
92830>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
92830>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
92830>>>>>>>    Define _MAX_PATH  for 260
92830>>>>>>>    Define _MAX_DRIVE for 3
92830>>>>>>>    Define _MAX_DIR   for 256
92830>>>>>>>    Define _MAX_FNAME for 256
92830>>>>>>>    Define _MAX_EXT   for 256
92830>>>>>>>
92830>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
92831>>>>>>>
92831>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
92832>>>>>>>
92832>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
92833>>>>>>>
92833>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
92834>>>>>>>
92834>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
92835>>>>>>>
92835>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
92836>>>>>>>
92836>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
92837>>>>>>>
92837>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
92838>>>>>>>// Sample:
92838>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
92838>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
92840>>>>>>>    Boolean bReturn
92840>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
92841>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
92842>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
92843>>>>>>>    Function_Return bReturn
92844>>>>>>>End_Function
92845>>>>>Use vWin32fh.pkg
92845>>>>>Use seq_chnl.pkg
92845>>>>>
92845>>>>>// User interface constant strings:
92845>>>>>    Define CS_UserCountError            for "User count error:"
92845>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
92845>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
92845>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
92845>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>
92845>>>>>    Struct tUserCount
92845>>>>>        Integer iUserCount
92845>>>>>        Integer iError
92845>>>>>        String  sErrorTxt
92845>>>>>    End_Struct
92845>>>>>
92845>>>>>    Define CI_UserCountMaxUsers for 9999
92845>>>>>
92845>>>>>Class cDbUpdateUserCount is a cObject
92846>>>>>    Procedure Construct_Object
92848>>>>>        Forward Send Construct_Object
92850>>>>>
92850>>>>>        Property String  psLockFileName
92851>>>>>        Property Integer piMaxUsers
92852>>>>>        Property Boolean pbCheckDataFlexUserCount True
92853>>>>>
92853>>>>>        Property Handle  phUserCountFile
92854>>>>>        Property Integer pdwLockPosition
92855>>>>>    End_Procedure
92856>>>>>
92856>>>>>    Function IsProgramRunning Returns Boolean
92858>>>>>        tUserCount UserCount
92858>>>>>        tUserCount UserCount
92858>>>>>
92858>>>>>        Get CheckUserCount to UserCount
92859>>>>>
92859>>>>>        Function_Return (UserCount.iUserCount > 1)
92860>>>>>    End_Function
92861>>>>>
92861>>>>>    // Returns the full path of the Application (no trailing "\")
92861>>>>>    Function ApplicationPath Returns String
92863>>>>>        String sApplicationFileName sPath
92863>>>>>        Integer iNumChars iRetval
92863>>>>>
92863>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
92864>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
92865>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
92866>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
92867>>>>>        Move (CString(sApplicationFileName)) to sPath
92868>>>>>
92868>>>>>        Function_Return sPath
92869>>>>>    End_Function
92870>>>>>
92870>>>>>    Function OpenUserCountFile String sFileName Returns Handle
92872>>>>>        Handle  hFile
92872>>>>>        Pointer pFileName
92872>>>>>        String sPath sFile
92872>>>>>        Integer iCh
92872>>>>>
92872>>>>>        Move (Addressof(sFileName)) to pFileName
92873>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
92874>>>>>
92874>>>>>        // If lock file doesn't exist, create it.
92874>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
92876>>>>>            Get ApplicationPath to sPath
92877>>>>>            Get vFolderFormat sPath to sPath
92878>>>>>            Move (sPath + psLockFileName(Self)) to sFile
92879>>>>>            Get Seq_Open_Output_Channel sFile to iCh
92880>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
92882>>>>>                Function_Return 0
92883>>>>>            End
92883>>>>>>
92883>>>>>            Direct_Output channel iCh sFile
92885>>>>>                Write channel iCh ""
92887>>>>>            Send Seq_Close_Channel iCh
92888>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
92889>>>>>        End
92889>>>>>>
92889>>>>>
92889>>>>>        Function_Return hFile
92890>>>>>    End_Function
92891>>>>>
92891>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
92893>>>>>        Integer iReturnValue 
92893>>>>>        Boolean bOK
92893>>>>>
92893>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
92894>>>>>        If (iReturnValue = 0) Begin
92896>>>>>            Move False to bOK
92897>>>>>        End
92897>>>>>>
92897>>>>>        Else Begin
92898>>>>>            Move True to bOK
92899>>>>>        End
92899>>>>>>
92899>>>>>        Function_Return bOK
92900>>>>>    End_Function
92901>>>>>
92901>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
92903>>>>>        Integer iReturnValue
92903>>>>>        Boolean bOK
92903>>>>>
92903>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
92904>>>>>        If (iReturnValue = 0) Begin
92906>>>>>            Move False to bOK
92907>>>>>        End
92907>>>>>>
92907>>>>>        Else Begin
92908>>>>>            Move True to bOK
92909>>>>>        End           
92909>>>>>>
92909>>>>>        Function_Return bOK
92910>>>>>    End_Function
92911>>>>>
92911>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
92913>>>>>        dWord dwCurrPos
92913>>>>>
92913>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
92914>>>>>        Function_Return dwCurrPos
92915>>>>>    End_Function
92916>>>>>
92916>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
92918>>>>>        DWord dwCurrPos
92918>>>>>
92918>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
92919>>>>>        Function_Return dwCurrPos
92920>>>>>    End_Function
92921>>>>>
92921>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
92923>>>>>        Integer iReturnValue                               
92923>>>>>        Boolean bOK
92923>>>>>        String  sBuffer
92923>>>>>        Pointer pBuffer
92923>>>>>        String  sSize
92923>>>>>        Pointer pSize
92923>>>>>
92923>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
92924>>>>>        Move (AddressOf(sBuffer)) to pBuffer
92925>>>>>
92925>>>>>        Move (Repeat((Character(0)),4)) to sSize
92926>>>>>        Move (AddressOf(sSize)) to pSize
92927>>>>>
92927>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
92928>>>>>        If (iReturnValue = 0) Begin
92930>>>>>            Move False to bOK
92931>>>>>        End
92931>>>>>>
92931>>>>>        Else Begin
92932>>>>>            Move True to bOK
92933>>>>>        End                 
92933>>>>>>
92933>>>>>        Function_Return bOK
92934>>>>>    End_Function
92935>>>>>
92935>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
92937>>>>>        Integer iReturnValue
92937>>>>>
92937>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
92938>>>>>        Function_Return iReturnValue
92939>>>>>    End_Function
92940>>>>>
92940>>>>>    Procedure DoCheckUserCount
92942>>>>>        tUserCount UserCount
92942>>>>>        tUserCount UserCount
92942>>>>>
92942>>>>>        Get CheckUserCount to UserCount
92943>>>>>        // If all is fine, we're done.
92943>>>>>        If (UserCount.iError = 0) Begin
92945>>>>>            Procedure_Return
92946>>>>>        End
92946>>>>>>
92946>>>>>
92946>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
92947>>>>>
92947>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
92949>>>>>            Abort
92950>>>>>>
92950>>>>>        End
92950>>>>>>
92950>>>>>    End_Procedure
92951>>>>>
92951>>>>>    Function CheckUserCount Returns tUserCount
92953>>>>>        Handle  hFile
92953>>>>>        String  sPath sFile
92953>>>>>        Integer iResult
92953>>>>>        DWord   dwFilePos
92953>>>>>        Integer bLocked
92953>>>>>        Integer iMaxUsers
92953>>>>>        Integer iCurUser
92953>>>>>        tUserCount UserCount
92953>>>>>        tUserCount UserCount
92953>>>>>
92953>>>>>        Move 0 to UserCount.iError
92954>>>>>
92954>>>>>        Get phUserCountFile to hFile
92955>>>>>        If (not(hFile)) Begin
92957>>>>>            Get ApplicationPath to sPath
92958>>>>>            Get vFolderFormat sPath to sPath
92959>>>>>            Move (sPath + psLockFileName(Self)) to sFile
92960>>>>>            Get OpenUserCountFile sFile to hFile
92961>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
92963>>>>>                Move 1 to UserCount.iUserCount
92964>>>>>                Move 1 to UserCount.iError
92965>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
92966>>>>>                Function_Return UserCount
92967>>>>>            End
92967>>>>>>
92967>>>>>            Else Begin
92968>>>>>                Move False to bLocked
92969>>>>>                Set phUserCountFile to hFile
92970>>>>>                Get piMaxUsers to iMaxUsers
92971>>>>>
92971>>>>>                // Set Filepointer to beginning of the file
92971>>>>>                Get ResetUserCountPointer hFile to dwFilePos
92972>>>>>                If (dwFilePos = -1) Begin
92974>>>>>                    Move 1 to UserCount.iUserCount
92975>>>>>                    Move 2 to UserCount.iError
92976>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
92977>>>>>                    Function_Return UserCount
92978>>>>>                End
92978>>>>>>
92978>>>>>                For iCurUser from 1 to iMaxUsers
92984>>>>>>
92984>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
92985>>>>>                    If (not(iResult)) Begin  // byte is locked
92987>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
92988>>>>>                        If (dwFilePos = -1) Begin
92990>>>>>                            Move 1 to UserCount.iUserCount
92991>>>>>                            Move 3 to UserCount.iError
92992>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
92993>>>>>                            Function_Return UserCount
92994>>>>>                        End
92994>>>>>>
92994>>>>>                    End
92994>>>>>>
92994>>>>>                    Else Begin  // byte is not locked
92995>>>>>                        Set pdwLockPosition to dwFilePos
92996>>>>>                        Move True to bLocked
92997>>>>>                        Move iMaxUsers to iCurUser
92998>>>>>                    End
92998>>>>>>
92998>>>>>                Loop
92999>>>>>>
92999>>>>>                If (not(bLocked)) Begin
93001>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93002>>>>>                    Move 4 to UserCount.iError
93003>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93004>>>>>                    Function_Return UserCount
93005>>>>>                End
93005>>>>>>
93005>>>>>            End
93005>>>>>>
93005>>>>>        End
93005>>>>>>
93005>>>>>
93005>>>>>        Function_Return UserCount
93006>>>>>    End_Function
93007>>>>>
93007>>>>>
93007>>>>>    Procedure DoReleaseUserCount
93009>>>>>        Integer iResult
93009>>>>>        Handle  hFile
93009>>>>>        DWord   dwLockPos
93009>>>>>
93009>>>>>        Get phUserCountFile to hFile
93010>>>>>        Get pdwLockPosition to dwLockPos
93011>>>>>        If (hFile) Begin
93013>>>>>            If (dwLockPos) Begin
93015>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93016>>>>>            End
93016>>>>>>
93016>>>>>            Get CloseUserCountFile hFile to iResult
93017>>>>>        End
93017>>>>>>
93017>>>>>    End_Procedure
93018>>>>>
93018>>>>>    Function CurrentNumberOfUsers Returns Integer
93020>>>>>        Handle  hFile
93020>>>>>        Integer iMaxUsers
93020>>>>>        DWord   dwFilePos
93020>>>>>        Integer iCurUser
93020>>>>>        Integer iResult
93020>>>>>        Integer iNumberOfLocks
93020>>>>>        String  sPath sFile
93020>>>>>
93020>>>>>        Move 0 to iNumberOfLocks
93021>>>>>
93021>>>>>        Get ApplicationPath to sPath
93022>>>>>        Get vFolderFormat sPath to sPath
93023>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93024>>>>>        Get OpenUserCountFile sFile to hFile
93025>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93027>>>>>            Send UserError CS_UnableToInitUserCountSys
93028>>>>>            Abort
93029>>>>>>
93029>>>>>        End
93029>>>>>>
93029>>>>>
93029>>>>>        If (hFile > 0) Begin
93031>>>>>            Get piMaxUsers To iMaxUsers
93032>>>>>
93032>>>>>            // Set Filepointer to beginning of the file
93032>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93033>>>>>            If (dwFilePos = -1) Begin
93035>>>>>                Send UserError CS_UnableResetUserCountSys
93036>>>>>                Abort
93037>>>>>>
93037>>>>>            End
93037>>>>>>
93037>>>>>            For iCurUser from 1 to iMaxUsers
93043>>>>>>
93043>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93044>>>>>                If (Not(iResult)) Begin  // byte is locked
93046>>>>>                    Increment iNumberOfLocks
93047>>>>>                End
93047>>>>>>
93047>>>>>                Else Begin  // byte is not locked
93048>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93049>>>>>                End
93049>>>>>>
93049>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93050>>>>>                If (dwFilePos = -1) Begin
93052>>>>>                    Send UserError CS_ErrorAdvancingPointer
93053>>>>>                    Abort
93054>>>>>>
93054>>>>>                End
93054>>>>>>
93054>>>>>            Loop
93055>>>>>>
93055>>>>>        End
93055>>>>>>
93055>>>>>        Get CloseUserCountFile hFile to iResult
93056>>>>>        Function_Return iNumberOfLocks
93057>>>>>    End_Function
93058>>>>>
93058>>>>>End_Class
93059>>>Use cDbUpdateFunctionLibrary.pkg
93059>>>
93059>>>//{ DataBindable=True }
93059>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
93059>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
93060>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary
93060>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
93060>>>
93060>>>    Procedure Construct_Object
93062>>>        tUserCount UserCount
93062>>>        tUserCount UserCount
93062>>>        Integer iUserCount
93062>>>        Handle ho                     
93062>>>
93062>>>        Forward Send Construct_Object
93064>>>        Move Self to ghoDbUpdateHandler  
93065>>>        
93065>>>        // Latin1_General_CI_AS = General Insensitive collation
93065>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93065>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93065>>>        // Good read about which collation to select:
93065>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93065>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93066>>>
93066>>>        // Struct array that will contain pnVersionNumbers & object id's of
93066>>>        // all child cDbVersion objects.
93066>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93067>>>
93067>>>        Property Integer Error_Processing_State False  // internal usage
93068>>>        
93068>>>        Property Boolean Private.pbDbVersionCheckDone False
93069>>>
93069>>>        Property Boolean pbUseCustomDbVersion False  
93070>>>        
93070>>>        // If this property = True _and_ no DbVersion table exists 
93070>>>        // when the framework is started, a DbVersion table will be created automatically.
93070>>>        Property Boolean pbAutoCreateDbVersionTable True
93071>>>
93071>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93071>>>        // the Filelist.cfg slot number indicated by this property will be used
93071>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93071>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93071>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93071>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93071>>>        Property Integer Private.piDbVersionFileNumber -1
93072>>>        Property Integer Private.piDbVersionFieldNumber 1
93073>>>
93073>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93073>>>        // that creates all library properties
93073>>>        Send CreateDbUpdateLibraryProperties
93074>>>
93074>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93075>>>
93075>>>        // Error handling:
93075>>>        Property Boolean Private.pbOnCreateExecuted False
93076>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93077>>>        Property Boolean Private.pbProcessingError False
93078>>>        Property Boolean pbDbUpdateErrorHasOccured False
93079>>>        // Don't touch. It is being used by the cDbUpdateVersion
93079>>>        // subclass to tell if that particular update went OK or not.
93079>>>        Property Boolean Private.pbUpdateVersionObjectError False
93080>>>        Property String[] paSQLQueryMessages
93081>>>
93081>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93082>>>        Move Self to Error_Object_Id
93083>>>        // Error handling:
93083>>>        // Temporarily redirect all errors to this object so we can silently
93083>>>        // log all errors that might appear while updating the database.
93083>>>        // We temporarily redirect all errors to this object so we can
93083>>>        // log and write errors to the log file. It will be reset after
93083>>>        // the database updates have been finished.
93083>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93084>>>
93084>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93085>>>
93085>>>        // Error Reporting Related
93085>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93085>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93086>>>
93086>>>        // If the pbContinueOnError = False, an update
93086>>>        // of another cDbUpdateVersion object will _not_ be
93086>>>        // performed if an error occured in a previous
93086>>>        // cDbUpdateVersion object.
93086>>>        Property Boolean pbContinueOnError False
93087>>>        // Stops execution in other cDbUpdateVersion objecs,
93087>>>        // if errors occurred in one cDbUpdateVersion object.
93087>>>        Property Boolean pbStopOnFirstError False
93088>>>        // If True errors that occured while updating the database
93088>>>        // will be shown in the default app for .txt files when done.
93088>>>        // Note: The log file will _always_ be created in the Data folder.
93088>>>        Property Boolean pbShowErrorLogPostRun True
93089>>>
93089>>>        // Be _very_ careful to set this property to true!
93089>>>        // If = True, no question will be asked if the update
93089>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93089>>>        // the error log won't be shown. The logfile itself will still be created though.
93089>>>        // You have to know what you're doing!
93089>>>        Property Boolean pbSilentMode False
93090>>>        
93090>>>        Property Boolean pbEnableCancelButton False
93091>>>
93091>>>        // Don't touch! Very private. The value is used by the error log to write for which
93091>>>        // cDbUpdateVersion object an error occured.
93091>>>        Property Number pnCurrentVersionUpdate 0
93092>>>
93092>>>        // The user counting logic is used to safe-guard agains anybody else is
93092>>>        // using the application when a database update is to be performed.
93092>>>        // (Garters & suspenders!)
93092>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93093>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93094>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93095>>>
93095>>>        // This lock file is used to guard against somebody else tries to start the
93095>>>        // application while updates are in progress.
93095>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93096>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93097>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93098>>>                                                                                      // Only the current user allowed.
93098>>>        // Properties for the table & column of a system file field/column where
93098>>>        // the database version update number gets saved.
93098>>>        Property Integer Private.Data_File  0
93099>>>        Property Integer Private.Data_Field 0
93100>>>
93100>>>        // Property that is used to indicate that we have already
93100>>>        // started the database update.
93100>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93101>>>
93101>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93101>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93101>>>        // change of the database has been made.
93101>>>        Property Boolean Private.pbDatabaseWasUpdated False
93102>>>
93102>>>        // We need to trigger the user counting system so that a bit in the
93102>>>        // user counting file is locked. This is to guard that not more than one user
93102>>>        // is currently runnning the program.
93102>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93103>>>
93103>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93104>>>        If (iUserCount > 0) Begin
93106>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93107>>>            Send Exit_Application
93108>>>        End
93108>>>>
93108>>>
93108>>>        Set pbHandleQueryErrors to False
93109>>>            
93109>>>        Property Handle phoSQLConnectionHandler 0
93110>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93110>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93110>>>        // etc information.
93110>>>        If (ghoSQLConnectionHandler = 0) Begin
93112>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93113>>>            Set phoSQLConnectionHandler to ho
93114>>>        End             
93114>>>>
93114>>>        
93114>>>        Property Boolean pbCheckIntFiles False   
93115>>>        Property Handle  phIntFilesTable 2048
93116>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93117>>>        
93117>>>        Set Icon to "Default.ico"
93118>>>    End_Procedure
93119>>>
93119>>>    Procedure End_Construct_Object
93121>>>        Boolean bCheckIntFiles
93121>>>        
93121>>>        Forward Send End_Construct_Object
93123>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93125>>>            Send OnCreate
93126>>>            Set Private.pbOnCreateExecuted to True
93127>>>        End
93127>>>>
93127>>>        Send Cleanup
93128>>>    End_Procedure
93129>>>    
93129>>>    // Programmers hook event.
93129>>>    Procedure OnCreate
93131>>>    End_Procedure        
93132>>>                                 
93132>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93132>>>    //                                                
93132>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
93132>>>    // cDbUpdateHandler object.
93132>>>    //
93132>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93132>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93132>>>    //
93132>>>    // If not done previously the phIntFilesTable will be created and filled with data
93132>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93132>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93132>>>    // of Filelist.cfg is made for backup purposes.
93132>>>    //
93132>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93132>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93132>>>    Procedure CheckIntFilesIntegrity
93134>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
93134>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
93134>>>        String sFileListZipFile sParam sProgram sFile 
93134>>>        Integer iDataPaths iCount
93134>>>        Handle hTable hIntFilesTable                    
93134>>>        UChar[] asFileListArray 
93135>>>        String[] asSavedIntFile
93136>>>        tDUFIntFile[] DUFIntFiles
93136>>>        tDUFIntFile[] DUFIntFiles
93137>>>        
93137>>>        Get pbCheckIntFiles to bCheckIntFiles
93138>>>        If (bCheckIntFiles = False) Begin
93140>>>            Procedure_Return
93141>>>        End
93141>>>>
93141>>>        
93141>>>        Move True to bResult        
93142>>>        
93142>>>        // Note: Include_Resource is a compiler directive!
93142>>>        // It will embedd the Filelist.cfg from the developers machine
93142>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
93142>>>        // need to change the next code line.         
93142>>>        //
93142>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93142>>>        // when we get here and then the compiler can't embedd it!        
93142>>>        // ToDo: Change compiler directives in Project properties (?)
93142>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93142>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93142>>>        
93142>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93143>>>        Get vFilePathExists sFileListName to bExists 
93144>>>        If (bExists = True) Begin
93146>>>            Get ParseFolderName sFileListName to sDataPath    
93147>>>            Get vFolderFormat sDataPath to sDataPath                              
93148>>>            Get ParseFileName sFileListName to sFile
93149>>>            // We need to create a backup copy of Filelist.cfg.
93149>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
93150>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
93151>>>            If (bOK = False) Begin
93153>>>                Move False to bResult
93154>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
93155>>>>
93155>>>            End
93155>>>>
93155>>>        End
93155>>>>
93155>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
93155>>>        Else Begin
93156>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
93157>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
93157>>>            If (bOK = False) Begin   
93159>>>                Move False to bResult
93160>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
93161>>>>
93161>>>            End
93161>>>>
93161>>>        End
93161>>>>
93161>>>        
93161>>>        Get phIntFilesTable to hIntFilesTable
93162>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
93165>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
93166>>>        // This will automatically create the phIntFilesTable if not exists.
93166>>>        // It is used to save data from the current set of .int files.
93166>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
93168>>>            Send AutoCreateIntFilesTable
93169>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93170>>>            If (bIntFilesTablesCheckDone = False) Begin
93172>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
93173>>>                Send Exit_Application of ghoApplication
93174>>>            End
93174>>>>
93174>>>        End                                                       
93174>>>>
93174>>>        
93174>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
93174>>>        // ToDo: Or should this always be attempted? Else the 
93174>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93175>>>        Move (IsDebuggerPresent()) to bDevelop
93176>>>        If (bDevelop = False) Begin
93178>>>            Get vFolderExists sDDSrcPath to bDevelop
93179>>>        End
93179>>>>
93179>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93180>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93181>>>        For iCount from 1 to iDataPaths
93187>>>>
93187>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93188>>>            Get vFolderFormat sDataPath to sDataPath 
93189>>>            Get vFolderExists sDataPath to bExists
93190>>>            If (bExists = True) Begin                  
93192>>>                Move 0 to hTable
93193>>>                Repeat
93193>>>>
93193>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93196>>>                    If (hTable <> 0) Begin
93198>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93201>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93202>>>                        If (bIsSQL = True) Begin     
93204>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93205>>>                            Move (sIntFileName + ".int")    to sIntFileName
93206>>>                            Get IsIntFileSaved sIntFileName to bSaved  
93207>>>                            Move True to bOK            
93208>>>                            
93208>>>                            // Save .int file to database if not done previously.
93208>>>                            // We only attempt to read .int files on a development machine.
93208>>>                            If (bDevelop = True) Begin
93210>>>                                If (bSaved = False) Begin
93212>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93213>>>                                    If (bOK = False) Begin
93215>>>                                        Move False to bResult    
93216>>>                                    End
93216>>>>
93216>>>                                End         
93216>>>>
93216>>>                                If (bOK = True) Begin
93218>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93219>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
93221>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93222>>>                                        If (bOK = False) Begin
93224>>>                                            Move False to bResult
93225>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93226>>>>
93226>>>                                        End
93226>>>>
93226>>>                                    End
93226>>>>
93226>>>                                End
93226>>>>
93226>>>                            End
93226>>>>
93226>>>                            
93226>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
93227>>>                            If (bExists = False) Begin                           
93229>>>                                // If the .int file is missing on disk; create it from database.
93229>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
93230>>>                                If (bOK = False) Begin         
93232>>>                                    Move False to bResult
93233>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
93234>>>>
93234>>>                                End
93234>>>>
93234>>>                            End
93234>>>>
93234>>>                        End
93234>>>>
93234>>>                    End
93234>>>>
93234>>>                Until (hTable = 0)
93236>>>            End
93236>>>>
93236>>>        Loop       
93237>>>>
93237>>>        
93237>>>        // If an error occured we need to exit the application.
93237>>>        If (bResult = False) Begin  
93239>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
93240>>>            Send Exit_Application
93241>>>        End
93241>>>>
93241>>>        
93241>>>    End_Procedure               
93242>>>
93242>>>    // To update currently saved IntFile data to the database.
93242>>>    // Because it is much easier, we first delete all current records and
93242>>>    // then saves the changed .int file to the database.
93242>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93244>>>        Boolean bOK
93244>>>        
93244>>>        Move False to bOK
93245>>>
93245>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93246>>>        If (bOK = True) Begin
93248>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93249>>>        End
93249>>>>
93249>>>        
93249>>>        Function_Return bOK
93250>>>    End_Function
93251>>>    
93251>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93253>>>        Handle hTable
93253>>>        Boolean bOK
93253>>>        Integer iColumn iIndex   
93253>>>        String sFileName
93253>>>        
93253>>>        Move False to bOK
93254>>>        Get phIntFilesTable to hTable
93255>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93256>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93257>>>
93257>>>        Open hTable
93259>>>        Set_Field_Value hTable iColumn to sIntFileName
93262>>>        Vfind hTable iIndex GE
93264>>>        Get_Field_Value hTable iColumn to sFileName
93267>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93269>>>            Move True to bOK    
93270>>>        End
93270>>>>
93270>>>        Close hTable
93271>>>        
93271>>>        Function_Return bOK       
93272>>>    End_Function   
93273>>>    
93273>>>    // Checks that the passed .int file is the same as what is saved in the database.
93273>>>    // If not same, the return string array will contain the read .int file,
93273>>>    // else the returned array will be empty.
93273>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93275>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93279>>>        Boolean bIsSame
93279>>>        
93279>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
93280>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
93281>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93282>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93283>>>        
93283>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93284>>>        If (bIsSame = False) Begin
93286>>>            Move asIntFileOrg to asReturnIntFile    
93287>>>        End
93287>>>>
93287>>>        
93287>>>        Function_Return asReturnIntFile    
93288>>>    End_Function                                   
93289>>>    
93289>>>    // Takes a string array as parameter and returns a new
93289>>>    // string array without any empty rows and all rows trimmed.
93289>>>    // This is e.g. used by the HasIntFileChanged message to compare
93289>>>    // two .int file arrays. 
93289>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93291>>>        Integer iSize iCount iRow
93291>>>        String sVal        
93291>>>        String[] asRetValArray
93292>>>        
93292>>>        Move (SizeOfArray(asIntFile)) to iSize
93293>>>        If (iSize = 0) Begin
93295>>>            Function_Return asRetValArray
93296>>>        End                          
93296>>>>
93296>>>        Decrement iSize         
93297>>>        Move 0 to iRow
93298>>>        
93298>>>        For iCount from 0  to iSize
93304>>>>
93304>>>            Move asIntFile[iCount] to sVal
93305>>>            Move (Trim(sVal)) to sVal
93306>>>            If (sVal <> "") Begin
93308>>>                Move sVal to asRetValArray[iRow]
93309>>>                Increment iRow        
93310>>>            End
93310>>>>
93310>>>        Loop
93311>>>>
93311>>>        
93311>>>        Function_Return asRetValArray
93312>>>    End_Function
93313>>>    
93313>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93315>>>        Handle hTable
93315>>>        Boolean bOK bErr
93315>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93315>>>        Number iID
93315>>>        String sFileName
93315>>>        String[] asIntFile
93316>>>        
93316>>>        Move Err to bErr
93317>>>        Move False to Err
93318>>>        Move False to bOK
93319>>>        Get phIntFilesTable to hTable  
93320>>>        Move 1              to iIDCol
93321>>>        Move 2              to iFileCol
93322>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93323>>>        Move 1              to iIDIdx   // Main ID index.
93324>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93325>>>
93325>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93326>>>        Move (SizeOfArray(asIntFile)) to iSize
93327>>>        If (iSize = 0) Begin
93329>>>            Function_Return False
93330>>>        End
93330>>>>
93330>>>        Decrement iSize
93331>>>        Open hTable  
93333>>>                  
93333>>>        // Find the last used ID no:
93333>>>        Fill_Field hTable iIDCol with DF_HIGH
93335>>>        Vfind hTable iIDIdx LE
93337>>>        Get_Field_Value hTable iIDCol to iID 
93340>>>        // This only happens the very first time we save a record.
93340>>>        If (iID = 999999999999) Begin
93342>>>            Move 0 to iID
93343>>>        End
93343>>>>
93343>>>        Increment iID        
93344>>>        
93344>>>        Lock
93345>>>>
93345>>>            For iCount from 0 to iSize
93351>>>>
93351>>>                Clear hTable
93352>>>                Set_Field_Value hTable iIDCol   to iID     
93355>>>                Set_Field_Value hTable iFileCol to sIntFileName
93358>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
93361>>>                SaveRecord hTable
93362>>>                Increment iID
93363>>>            Loop
93364>>>>
93364>>>        Unlock
93365>>>>
93365>>>        Close hTable
93366>>>        
93366>>>        Move (not(Err)) to bOK
93367>>>        Move bErr to Err
93368>>>        
93368>>>        Function_Return bOK
93369>>>    End_Function
93370>>>    
93370>>>    // Deletes all records for the passed sIntFileName value,
93370>>>    // from the phIntFilesTable.
93370>>>    // Returns True if no errors occured.
93370>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
93372>>>        Handle hTable
93372>>>        Boolean bOK bErr bFound
93372>>>        Integer iFileCol iIndex
93372>>>        String sVal
93372>>>        String[] asIntFile
93373>>>        
93373>>>        Move Err to bErr
93374>>>        Move False to Err
93375>>>        Move False to bOK
93376>>>        Move 2              to iFileCol
93377>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93378>>>        Get phIntFilesTable to hTable  
93379>>>        Open hTable  
93381>>>                  
93381>>>        // Find the first record
93381>>>        Set_Field_Value hTable iFileCol to sIntFileName
93384>>>        Vfind hTable iIndex GE
93386>>>        Get_Field_Value hTable iFileCol to sVal
93389>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93390>>>        While (bFound = True)
93394>>>            Delete hTable
93395>>>            Vfind hTable iIndex GT
93397>>>            Get_Field_Value hTable iFileCol to sVal
93400>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93401>>>        Loop
93402>>>>
93402>>>        Unlock
93403>>>>
93403>>>        Close hTable
93404>>>        
93404>>>        Move (not(Err)) to bOK
93405>>>        Move bErr to Err
93406>>>        
93406>>>        Function_Return bOK
93407>>>    End_Function
93408>>>
93408>>>    // Returns all saved phIntFilesTable records for the passed 
93408>>>    // sIntFileName value as a string array.
93408>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
93410>>>        Handle hTable
93410>>>        Boolean bOK bErr bFound
93410>>>        Integer iFileCol iTextCol iIndex
93410>>>        String sVal sFileName
93410>>>        String[] asIntFile asEmptyArray
93412>>>        
93412>>>        Move Err to bErr
93413>>>        Move False to Err
93414>>>        Move False to bOK
93415>>>        Move 2              to iFileCol
93416>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93417>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93418>>>        Get phIntFilesTable to hTable  
93419>>>        Open hTable  
93421>>>
93421>>>        // Find the first record
93421>>>        Set_Field_Value hTable iFileCol to sIntFileName
93424>>>        Vfind hTable iIndex GE
93426>>>        Get_Field_Value hTable iFileCol to sFileName
93429>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93430>>>        While (bFound = True)
93434>>>            Get_Field_Value hTable iFileCol to sFileName
93437>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93438>>>            If (bFound = True) Begin
93440>>>                Get_Field_Value hTable iTextCol to sVal
93443>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
93444>>>            End
93444>>>>
93444>>>            Vfind hTable iIndex GT
93446>>>        Loop
93447>>>>
93447>>>        
93447>>>        Close hTable
93448>>>        Move (not(Err)) to bOK
93449>>>        If (bOK = False) Begin
93451>>>            Move asEmptyArray to asIntFile
93452>>>        End
93452>>>>
93452>>>        Move bErr to Err               
93453>>>        
93453>>>        Function_Return asIntFile
93454>>>    End_Function
93455>>>
93455>>>    // Reads the passed sIntFileName from disk and returns its value
93455>>>    // as a string array.
93455>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
93457>>>        String[] asIntFile       
93458>>>        String sFileName sLine
93458>>>        Integer iCh iSize iCount
93458>>>        
93458>>>        Get vFolderFormat sPath to sPath
93459>>>        If (not(sIntFileName contains ".")) Begin
93461>>>            Move (sIntFileName + ".int") to sIntFileName
93462>>>        End
93462>>>>
93462>>>        Move (sPath + sIntFileName) to sFileName
93463>>>        Get Seq_Open_input_Channel sFileName to iCh
93464>>>        If (iCh < 0) Begin
93466>>>            Function_Return asIntFile
93467>>>        End                                 
93467>>>>
93467>>>        
93467>>>        Repeat
93467>>>>
93467>>>            Readln channel iCh sLine
93469>>>            If (SeqEof = False) Begin
93471>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
93472>>>            End
93472>>>>
93472>>>        Until (SeqEof = True)
93474>>>        Send Seq_Close_Channel iCh    
93475>>>        
93475>>>        Function_Return asIntFile
93476>>>    End_Function
93477>>>    
93477>>>    // Reads the Filelist.cfg from memeory as a resource.
93477>>>    // The Filelist.cfg has been compiled into the program.
93477>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
93479>>>        Integer iCh iCount
93479>>>        Number nByteCount
93479>>>        String[] asFileListArray sEmptyArray
93481>>>        String sLine
93481>>>        UChar[] uCharData
93482>>>        
93482>>>        Move False to Err
93483>>>        Get Seq_New_Channel to iCh
93484>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93486>>>            Error DFERR_PROGRAM 'No channel available...'
93487>>>>
93487>>>            Function_Return sEmptyArray
93488>>>        End
93488>>>>
93488>>>
93488>>>        // First decide the size of the script
93488>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
93490>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
93492>>>        Close_Input channel iCh
93494>>>        Send Seq_Release_Channel iCh
93495>>>
93495>>>        Function_Return uCharData
93496>>>    End_Function    
93497>>>    
93497>>>    // Writes a copy of the workspace Filelist.cfg to disk.
93497>>>    // It does so by reading from a memory resource, as the file has
93497>>>    // been compiled into the program.
93497>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
93499>>>        Boolean bOK bErr
93499>>>        Integer iSize iCh
93499>>>        
93499>>>        Move Err to bErr
93500>>>        Move False to Err
93501>>>        Move False to bOK
93502>>>        Move (SizeOfArray(asFileListArray)) to iSize
93503>>>        If (iSize = 0) Begin
93505>>>            Function_Return False
93506>>>        End
93506>>>>
93506>>>
93506>>>        Get Seq_New_Channel to iCh
93507>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93509>>>            Error DFERR_PROGRAM 'No channel available...'
93510>>>>
93510>>>            Function_Return False
93511>>>        End                      
93511>>>>
93511>>>        
93511>>>        Direct_Output channel iCh sFileListName
93513>>>        Writeln channel iCh asFileListArray
93516>>>                
93516>>>        Close_Input channel iCh
93518>>>        Send Seq_Release_Channel iCh
93519>>>        Move (not(Err)) to bOK
93520>>>        Move bErr to Err
93521>>>        
93521>>>        Function_Return bOK
93522>>>    End_Function
93523>>>
93523>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
93523>>>    // It first deletes the .cch file (if any).
93523>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
93525>>>        Boolean bOK bFound bExists bErr
93525>>>        Integer iCh iSize iCount
93525>>>        String sFileName sCCHFileName sVal
93525>>>        String[] asIntFile
93526>>>        
93526>>>        Move Err to bErr   
93527>>>        Move False to Err
93528>>>        Move False to bOK
93529>>>
93529>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
93530>>>        Move (SizeOfArray(asIntFile)) to iSize
93531>>>        If (iSize = 0) Begin
93533>>>            Function_Return False        
93534>>>        End                      
93534>>>>
93534>>>        Decrement iSize
93535>>>        
93535>>>        Get Seq_New_Channel to iCh
93536>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93538>>>            Function_Return False
93539>>>        End   
93539>>>>
93539>>>        
93539>>>        // Before we start to actually create the new .int file, make sure we delete
93539>>>        // the .cch file first.                                     
93539>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
93540>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
93541>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
93542>>>        If (bExists = True) Begin
93544>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
93545>>>            If (bOK = False) Begin
93547>>>                Function_Return False
93548>>>            End
93548>>>>
93548>>>        End
93548>>>>
93548>>>        
93548>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
93550>>>        For iCount from 0 to iSize
93556>>>>
93556>>>            Writeln channel iCh asIntFile[iCount]
93559>>>        Loop
93560>>>>
93560>>>        
93560>>>        Close_Input channel iCh
93562>>>        Send Seq_Release_Channel iCh
93563>>>        Move (not(Err)) to bOK
93564>>>        Move bErr to Err
93565>>>        
93565>>>        Function_Return bOK
93566>>>    End_Function   
93567>>>              
93567>>>    // Automatically writes .int files to disk that is missing.
93567>>>    // We only need to make this test this once, but because the message is called
93567>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
93567>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
93567>>>    Procedure AutoCreateIntFilesTable 
93569>>>        Integer hTable 
93569>>>        Boolean bIntFilesTablesCheckDone bTableExists
93569>>>        String sInfoTxt 
93569>>>        
93569>>>        Get phIntFilesTable to hTable  
93570>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93571>>>        If (bIntFilesTablesCheckDone = True) Begin
93573>>>            Procedure_Return
93574>>>        End
93574>>>>
93574>>>
93574>>>        If (hTable < 1) Begin
93576>>>            Set Private.pbIntFilesTablesCheckDone to False
93577>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93578>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
93579>>>>
93579>>>            Procedure_Return
93580>>>        End
93580>>>>
93580>>>
93580>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
93581>>>        If (bTableExists = True) Begin
93583>>>            Set Private.pbIntFilesTablesCheckDone to True
93584>>>            Procedure_Return
93585>>>        End
93585>>>>
93585>>>
93585>>>        Send CreateIntFilesTable hTable
93586>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93587>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93588>>>    End_Function
93589>>>                
93589>>>    Procedure CreateIntFilesTable Handle hTable
93591>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
93591>>>        Boolean bTableExists bOK bUseConnectionID bExists
93591>>>        tAPIColumn[] APIColumn
93591>>>        tAPIColumn[] APIColumn
93592>>>
93592>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93593>>>        If (bTableExists = True) Begin
93595>>>            Procedure_Return
93596>>>        End
93596>>>>
93596>>>
93596>>>        Move False to Err
93597>>>        Get psDriverID to sDriverID
93598>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93599>>>
93599>>>        Move CS_IntFilesTableRootName to sTableName
93600>>>
93600>>>        Move 1                  to APIColumn[0].iFieldNumber
93601>>>        Move "ID"               to APIColumn[0].sFieldName
93602>>>        Move DF_BCD             to APIColumn[0].iType
93603>>>        Move False              to APIColumn[0].bIsSQLType
93604>>>        Move 12                 to APIColumn[0].iLength
93605>>>        Move 0                  to APIColumn[0].iPrecision
93606>>>
93606>>>        Move 2                  to APIColumn[1].iFieldNumber
93607>>>        Move "IntFileName"      to APIColumn[1].sFieldName
93608>>>        Move DF_ASCII           to APIColumn[1].iType
93609>>>        Move False              to APIColumn[1].bIsSQLType
93610>>>        Move 50                 to APIColumn[1].iLength
93611>>>        Move 0                  to APIColumn[1].iPrecision
93612>>>
93612>>>        Move 3                  to APIColumn[2].iFieldNumber
93613>>>        Move "IntLineText"      to APIColumn[2].sFieldName
93614>>>        Move DF_ASCII           to APIColumn[2].iType
93615>>>        Move False              to APIColumn[2].bIsSQLType
93616>>>        Move 100                to APIColumn[2].iLength
93617>>>        Move 0                  to APIColumn[2].iPrecision
93618>>>
93618>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93619>>>        
93619>>>        If (bOK = True and Err = False) Begin
93621>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93622>>>        End
93622>>>>
93622>>>        Else Begin
93623>>>            Set Private.pbIntFilesTablesCheckDone to False
93624>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93625>>>            Error DFERR_PROGRAM sInfoTxt
93626>>>>
93626>>>            Procedure_Return
93627>>>        End
93627>>>>
93627>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93628>>>        
93628>>>        Open hTable
93630>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
93631>>>        If (bOK = True) Begin
93633>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
93634>>>        End
93634>>>>
93634>>>        If (bOK = False) Begin
93636>>>            Set Private.pbIntFilesTablesCheckDone to False
93637>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93638>>>            Error DFERR_PROGRAM sInfoTxt
93639>>>>
93639>>>            Procedure_Return
93640>>>        End                    
93640>>>>
93640>>>        
93640>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
93640>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93641>>>        Get vFolderFormat sDataPath to sDataPath
93642>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
93643>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
93644>>>        If (bExists = True) Begin
93646>>>            Move CS_IntFilesTableRootName to sTableName
93647>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
93648>>>            If (bExists = True) Begin
93650>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
93651>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
93652>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
93653>>>            End
93653>>>>
93653>>>        End
93653>>>>
93653>>>        
93653>>>        Set Private.pbIntFilesTablesCheckDone to True
93654>>>    End_Procedure
93655>>>
93655>>>    Procedure CheckAutoCreateDbVersionTable
93657>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
93657>>>        Integer iDbVersionFileNumber
93657>>>
93657>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
93658>>>        If (bDbVersionCheckDone = True) Begin
93660>>>            Procedure_Return
93661>>>        End
93661>>>>
93661>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
93662>>>        If (bUseCustomDbVersion = True) Begin
93664>>>            Procedure_Return
93665>>>        End
93665>>>>
93665>>>
93665>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
93666>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
93668>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93669>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
93670>>>>
93670>>>            Send Exit_Application
93671>>>        End
93671>>>>
93671>>>
93671>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
93672>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93673>>>        If (bTableExists = True) Begin
93675>>>            Set Private.pbDbVersionCheckDone to True
93676>>>            Procedure_Return
93677>>>        End
93677>>>>
93677>>>
93677>>>        Send CreateDbVersionTable iDbVersionFileNumber
93678>>>
93678>>>        // We only need to these DbVersion checks once, but because this message is called
93678>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
93678>>>        // we use a property to only run these tests once.
93678>>>        Set Private.pbDbVersionCheckDone to True
93679>>>    End_Procedure
93680>>>
93680>>>    Procedure CreateDbVersionTable Handle hTable
93682>>>        String sTableName sColumnName sInfoTxt sDriverID 
93682>>>        Boolean bTableExists bOK bUseConnectionID
93682>>>        tAPIColumn[] APIColumn
93682>>>        tAPIColumn[] APIColumn
93683>>>
93683>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93684>>>        If (bTableExists = True) Begin
93686>>>            Procedure_Return
93687>>>        End
93687>>>>
93687>>>
93687>>>        Get psDriverID to sDriverID
93688>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93689>>>
93689>>>        Move "DbVersion"        to sTableName
93690>>>        Move 1                  to APIColumn[0].iFieldNumber
93691>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
93692>>>        Move DF_BCD             to APIColumn[0].iType
93693>>>        Move False              to APIColumn[0].bIsSQLType
93694>>>        Move 4                  to APIColumn[0].iLength
93695>>>        Move 2                  to APIColumn[0].iPrecision
93696>>>
93696>>>        Move False to Err                                
93697>>>        
93697>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
93697>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
93697>>>        Set psDriverID to DATAFLEX_ID
93698>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93699>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93700>>>        Set psDriverID to sDriverID
93701>>>        
93701>>>        If (bOK = True and Err = False) Begin
93703>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
93703>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93704>>>        End
93704>>>>
93704>>>        Else Begin
93705>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
93706>>>        End
93706>>>>
93706>>>
93706>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93707>>>    End_Procedure
93708>>>
93708>>>    Procedure Set pbVerboseState Boolean bVerboseState
93710>>>        Handle ho
93710>>>        Get phoLogFile to ho
93711>>>        Set pbVerboseState of ho to bVerboseState
93712>>>    End_Procedure
93713>>>
93713>>>    Function pbVerboseState Returns Boolean
93715>>>        Boolean bVerboseState
93715>>>        Handle ho
93715>>>        Get phoLogFile to ho
93716>>>        Get pbVerboseState of ho to bVerboseState
93717>>>        Function_Return bVerboseState
93718>>>    End_Function
93719>>>
93719>>>    // Callback functionality used when e.g. calling driver functions directly.
93719>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
93719>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
93721>>>        Integer iPerc
93721>>>        Number nReady nTotal nVersion
93721>>>        Boolean bVerboseState
93721>>>        Handle hoLogFile
93721>>>
93721>>>        Get pbVerboseState to bVerboseState
93722>>>        Get pnCurrentVersionUpdate to nVersion
93723>>>        Get phoLogFile     to hoLogFile
93724>>>        Send DoAdvance of ghoProgressBar
93725>>>
93725>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
93727>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93728>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
93729>>>        End
93729>>>>
93729>>>        If (sCallback_Text contains "Creating index") Begin
93731>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
93732>>>        End
93732>>>>
93732>>>
93732>>>        Case Begin
93732>>>            Case (iCallback_Type = DF_Message_Text)
93734>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93735>>>                Set Action_Text  of ghoStatusPanel to ""
93736>>>                If (bVerboseState = True) Begin
93738>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93739>>>                End
93739>>>>
93739>>>                Case Break
93740>>>            Case (iCallback_Type = DF_Message_Heading_1)
93743>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93744>>>                If (bVerboseState = True) Begin
93746>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93747>>>                End
93747>>>>
93747>>>                Case Break
93748>>>            Case (iCallback_Type = DF_Message_Heading_2)
93751>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93752>>>                Set Action_Text  of ghoStatusPanel to ""
93753>>>                If (bVerboseState = True) Begin
93755>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93756>>>                End
93756>>>>
93756>>>                Case Break
93757>>>            Case (iCallback_Type = DF_Message_Heading_3)
93760>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93761>>>                Set Action_Text  of ghoStatusPanel to ""
93762>>>                If (bVerboseState = True) Begin
93764>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93765>>>                End
93765>>>>
93765>>>                Case Break
93766>>>            Case (iCallback_Type = DF_Message_Heading_4)
93769>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93770>>>                Set Action_Text  of ghoStatusPanel to ""
93771>>>                If (bVerboseState = True) Begin
93773>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93774>>>                End
93774>>>>
93774>>>                Case Break
93775>>>            Case (iCallback_Type = DF_Message_Heading_5)
93778>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93779>>>                Set Action_Text  of ghoStatusPanel to ""
93780>>>                If (bVerboseState = True) Begin
93782>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93783>>>                End
93783>>>>
93783>>>                Case Break
93784>>>            Case (iCallback_Type = DF_Message_Warning)
93787>>>                If (bVerboseState = True) Begin
93789>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93790>>>                End
93790>>>>
93790>>>                Case Break
93791>>>            Case (iCallback_Type = DF_Message_Progress_Title)
93794>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
93795>>>                Set Action_Text  of ghoStatusPanel to ""
93796>>>                If (bVerboseState = True) Begin
93798>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
93799>>>                End
93799>>>>
93799>>>                Case Break
93800>>>            Case (iCallback_Type = DF_Message_Progress_Value)
93803>>>                //*** Interpret numbers
93803>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
93804>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
93805>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
93806>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
93807>>>                Set piPosition of ghoProgressBar to iPerc
93808>>>                Case Break
93809>>>            Case Else
93809>>>                Set Message_Text to ""
93810>>>                Set Action_Text  to ""
93811>>>        Case End
93811>>>
93811>>>        Send ProcessEvents of ghoStatusPanel
93812>>>        Function_Return False
93813>>>    End_Function
93814>>>
93814>>>    // This was made to be a procedure/function pair so we
93814>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
93814>>>
93814>>>    Procedure Set piDbType Integer iDbType
93816>>>        If (ghoSQLConnectionHandler = 0) Begin
93818>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93819>>>>
93819>>>            Procedure_Return
93820>>>        End
93820>>>>
93820>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
93821>>>    End_Procedure
93822>>>
93822>>>    Function piDbType Returns Integer
93824>>>        Integer iDbType
93824>>>        If (ghoSQLConnectionHandler = 0) Begin
93826>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93827>>>>
93827>>>            Function_Return ""
93828>>>        End
93828>>>>
93828>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
93829>>>        Function_Return iDbType
93830>>>    End_Function
93831>>>
93831>>>    Procedure Set psDriverID String sDriverID
93833>>>        If (ghoSQLConnectionHandler = 0) Begin
93835>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93836>>>>
93836>>>            Procedure_Return
93837>>>        End
93837>>>>
93837>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
93838>>>    End_Procedure
93839>>>
93839>>>    Function psDriverID Returns String
93841>>>        String sValue
93841>>>        If (ghoSQLConnectionHandler = 0) Begin
93843>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93844>>>>
93844>>>            Function_Return ""
93845>>>        End
93845>>>>
93845>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
93846>>>        Function_Return sValue
93847>>>    End_Function
93848>>>
93848>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
93850>>>        If (ghoSQLConnectionHandler = 0) Begin
93852>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93853>>>>
93853>>>            Procedure_Return
93854>>>        End
93854>>>>
93854>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
93855>>>    End_Procedure
93856>>>
93856>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
93858>>>        Integer iRetval
93858>>>        If (ghoSQLConnectionHandler = 0) Begin
93860>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93861>>>>
93861>>>            Function_Return 2
93862>>>        End
93862>>>>
93862>>>
93862>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
93863>>>        Function_Return iRetval
93864>>>    End_Function
93865>>>
93865>>>    Procedure Set psConnectionID String sValue
93867>>>        If (ghoSQLConnectionHandler = 0) Begin
93869>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93870>>>>
93870>>>            Procedure_Return
93871>>>        End
93871>>>>
93871>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
93872>>>    End_Procedure
93873>>>
93873>>>    Function psConnectionID Returns String
93875>>>        String sValue
93875>>>        If (ghoSQLConnectionHandler = 0) Begin
93877>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93878>>>>
93878>>>            Function_Return ""
93879>>>        End
93879>>>>
93879>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
93880>>>
93880>>>        Function_Return sValue
93881>>>    End_Function
93882>>>
93882>>>    // These "properties" are settings of the cCLIHandler class, but are being
93882>>>    // relayed to the ghoSQLConnectionHandler object
93882>>>    // simply by changing one of its parameters.
93882>>>    Procedure Set psServer String sValue
93884>>>        If (ghoSQLConnectionHandler = 0) Begin
93886>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93887>>>>
93887>>>            Procedure_Return
93888>>>        End
93888>>>>
93888>>>        Set psServer of ghoSQLConnectionHandler to sValue
93889>>>    End_Procedure
93890>>>
93890>>>    Function psServer Returns String
93892>>>        String sValue
93892>>>        If (ghoSQLConnectionHandler = 0) Begin
93894>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93895>>>>
93895>>>            Function_Return ""
93896>>>        End
93896>>>>
93896>>>        Get psServer of ghoSQLConnectionHandler to sValue
93897>>>
93897>>>        Function_Return sValue
93898>>>    End_Function
93899>>>
93899>>>    Procedure Set psDatabase String sValue
93901>>>        If (ghoSQLConnectionHandler = 0) Begin
93903>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93904>>>>
93904>>>            Procedure_Return
93905>>>        End
93905>>>>
93905>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
93906>>>    End_Procedure
93907>>>
93907>>>    Function psDatabase Returns String
93909>>>        String sValue
93909>>>        If (ghoSQLConnectionHandler = 0) Begin
93911>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93912>>>>
93912>>>            Function_Return ""
93913>>>        End
93913>>>>
93913>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
93914>>>
93914>>>        Function_Return sValue
93915>>>    End_Function
93916>>>
93916>>>    Procedure Set psUserID String sValue
93918>>>        If (ghoSQLConnectionHandler = 0) Begin
93920>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93921>>>>
93921>>>            Procedure_Return
93922>>>        End
93922>>>>
93922>>>        Set psUserID of ghoSQLConnectionHandler to sValue
93923>>>    End_Procedure
93924>>>
93924>>>    Function psUserID Returns String
93926>>>        String sValue
93926>>>        If (ghoSQLConnectionHandler = 0) Begin
93928>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93929>>>>
93929>>>            Function_Return ""
93930>>>        End
93930>>>>
93930>>>        Get psUserID of ghoSQLConnectionHandler to sValue
93931>>>
93931>>>        Function_Return sValue
93932>>>    End_Function
93933>>>
93933>>>    Procedure Set psPassword String sValue
93935>>>        If (ghoSQLConnectionHandler = 0) Begin
93937>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93938>>>>
93938>>>            Procedure_Return
93939>>>        End
93939>>>>
93939>>>        Set psPassword of ghoSQLConnectionHandler to sValue
93940>>>    End_Procedure
93941>>>
93941>>>    Function psPassword Returns String
93943>>>        String sValue
93943>>>        If (ghoSQLConnectionHandler = 0) Begin
93945>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93946>>>>
93946>>>            Function_Return ""
93947>>>        End
93947>>>>
93947>>>        Get psPassword of ghoSQLConnectionHandler to sValue
93948>>>
93948>>>        Function_Return sValue
93949>>>    End_Function
93950>>>
93950>>>    Procedure Set pbTrusted Boolean bValue
93952>>>        If (ghoSQLConnectionHandler = 0) Begin
93954>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93955>>>>
93955>>>            Procedure_Return
93956>>>        End
93956>>>>
93956>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
93957>>>    End_Procedure
93958>>>
93958>>>    Function pbTrusted Returns Boolean
93960>>>        Boolean bValue
93960>>>        If (ghoSQLConnectionHandler = 0) Begin
93962>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93963>>>>
93963>>>            Function_Return False
93964>>>        End
93964>>>>
93964>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
93965>>>
93965>>>        Function_Return bValue
93966>>>    End_Function
93967>>>
93967>>>    Procedure Set psConnectionString String sValue
93969>>>        If (ghoSQLConnectionHandler = 0) Begin
93971>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93972>>>>
93972>>>            Procedure_Return
93973>>>        End
93973>>>>
93973>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
93974>>>    End_Procedure
93975>>>
93975>>>    Function psConnectionString Returns String
93977>>>        String sValue
93977>>>        If (ghoSQLConnectionHandler = 0) Begin
93979>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93980>>>>
93980>>>            Function_Return ""
93981>>>        End
93981>>>>
93981>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
93982>>>
93982>>>        Function_Return sValue
93983>>>    End_Function
93984>>>
93984>>>    Function piConnectionOptions Returns Integer
93986>>>        Integer iValue
93986>>>        If (ghoSQLConnectionHandler = 0) Begin
93988>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
93989>>>>
93989>>>            Function_Return 0
93990>>>        End
93990>>>>
93990>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
93991>>>
93991>>>        Function_Return iValue
93992>>>    End_Function
93993>>>
93993>>>
93993>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
93995>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
93996>>>    End_Procedure
93997>>>
93997>>>    Function pbCheckDataFlexUserCount Returns Boolean
93999>>>        Boolean bState
93999>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94000>>>        Function_Return bState
94001>>>    End_Function
94002>>>
94002>>>    Procedure Set psLogTextFile String sValue
94004>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94005>>>    End_Procedure
94006>>>
94006>>>    Function psLogTextFile Returns String
94008>>>        String sValue
94008>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94009>>>        Function_Return sValue
94010>>>    End_Function
94011>>>
94011>>>    Procedure Set psEditorProgram String sValue
94013>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94014>>>    End_Procedure
94015>>>
94015>>>    Function psEditorProgram Returns String
94017>>>        String sValue
94017>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94018>>>        Function_Return sValue
94019>>>    End_Function
94020>>>
94020>>>    Procedure Set pbUseDataTableLog Boolean bState
94022>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94023>>>    End_Procedure
94024>>>
94024>>>    Function pbUseDataTableLog Returns Boolean
94026>>>        Boolean bState
94026>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94027>>>        Function_Return bState
94028>>>    End_Function
94029>>>
94029>>>    Procedure Set pbQuickWrite Boolean bState
94031>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94032>>>    End_Procedure
94033>>>
94033>>>    Function pbQuickWrite Returns Boolean
94035>>>        Boolean bState
94035>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94036>>>        Function_Return bState
94037>>>    End_Function
94038>>>
94038>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94040>>>        Boolean bUpdateVersionObjectError bVerboseState
94040>>>        Integer iSize iCount
94040>>>        Number nVersion
94040>>>        String[] aSQLQueryMessages
94041>>>
94041>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94042>>>        Set Private.pbDatabaseWasUpdated to bState
94043>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94043>>>        // to the log that it was OK.
94043>>>        If (bUpdateVersionObjectError = False) Begin
94045>>>            Get pnCurrentVersionUpdate to nVersion
94046>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94047>>>        End
94047>>>>
94047>>>
94047>>>        Get pbVerboseState to bVerboseState
94048>>>        If (bVerboseState = True) Begin
94050>>>            Get paSQLQueryMessages to aSQLQueryMessages
94051>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94052>>>            Decrement iSize
94053>>>            For iCount from 0 to iSize
94059>>>>
94059>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94060>>>            Loop
94061>>>>
94061>>>        End
94061>>>>
94061>>>
94061>>>    End_Procedure 
94062>>>    
94062>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94064>>>        Set Private.piDbVersionFileNumber to iFileNumber
94065>>>    End_Procedure                                         
94066>>>    
94066>>>    Function piDbVersionFileNumber Returns Integer
94068>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94069>>>    End_Function
94070>>>
94070>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94072>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94073>>>    End_Procedure                                         
94074>>>    
94074>>>    Function piDbVersionFieldNumber Returns Integer
94076>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94077>>>    End_Function
94078>>>
94078>>>    Function pbDatabaseWasUpdated Returns Boolean
94080>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94081>>>    End_Function
94082>>>    
94082>>>    //
94082>>>    Procedure ReinitializeFramework  
94084>>>        tDbVersionInfo[] aDbVersionInfoArray
94084>>>        tDbVersionInfo[] aDbVersionInfoArray
94085>>>        Handle hoDbVersionObject
94085>>>        Integer iSize iCount
94085>>>        
94085>>>        Set Private.pbDatabaseUpdateStarted to False
94086>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94087>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94088>>>        Decrement iSize
94089>>>        
94089>>>        For iCount from 0 to iSize
94095>>>>
94095>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94096>>>            Send ProcessUpdate                  of hoDbVersionObject False
94097>>>        Loop
94098>>>>
94098>>>        Send Cleanup
94099>>>    End_Procedure
94100>>>    
94100>>>    // This event is triggered by the cDbUpdateVersion child class when
94100>>>    // a database change is to be started, and is considered private.
94100>>>    // It is only executed once for the first cDbUpateVersion object!
94100>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94102>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94102>>>        Integer iRetval iDataFlexUsers iUserCount
94102>>>        Handle hoUserCountSystem
94102>>>        tUserCount UserCount
94102>>>        tUserCount UserCount
94102>>>        DateTime dtUpdateStarted
94102>>>        tSQLConnection SQLConnection
94102>>>        tSQLConnection SQLConnection
94102>>>
94102>>>        // *Important:* If we already started the update; we do no further checking.
94102>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94103>>>        If (bDatabaseUpdateStarted = True) Begin
94105>>>            Procedure_Return
94106>>>        End
94106>>>>
94106>>>
94106>>>        // If not silent mode; Ask user if OK to start database update.
94106>>>        If (pbSilentMode(Self) = False) Begin
94108>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94109>>>            If (iRetval <> MBR_Yes) Begin
94111>>>                Send Exit_Application
94112>>>            End
94112>>>>
94112>>>        End
94112>>>>
94112>>>        
94112>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94113>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94114>>>        Send Start_StatusPanel      of ghoStatusPanel
94115>>>
94115>>>        // This will save the status of all open tables including Master/Alias settings,
94115>>>        // so we can restore them later;
94115>>>        Send SaveOpenTables
94116>>>
94116>>>        Move 0 to iDataFlexUsers
94117>>>        // Make various tests to check that the database is not in use.
94117>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94118>>>        // We also use our own user counting mechanism to guard against the
94118>>>        // database isn't opened already as we need exclusive access to the tables.:
94118>>>        Get phoUserCountSystem to hoUserCountSystem
94119>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94120>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94121>>>
94121>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94122>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94122>>>        If (bCheckDataFlexUserCount = True) Begin
94124>>>            Get_Current_User_Count to iDataFlexUsers
94125>>>            // For some reason DataFlex - in some cases - might think that 2 users
94125>>>            // are in use while debugging from the Studio.
94125>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94127>>>                Decrement iDataFlexUsers
94128>>>            End
94128>>>>
94128>>>        End 
94128>>>>
94128>>>        Else Begin
94129>>>            Move 1 to iDataFlexUsers 
94130>>>            Move 1 to iUserCount
94131>>>            Move False to bInUse
94132>>>        End
94132>>>>
94132>>>
94132>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94134>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94135>>>            If (iRetval <> MBR_Yes) Begin
94137>>>                Send Exit_Application
94138>>>            End
94138>>>>
94138>>>        End
94138>>>>
94138>>>
94138>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94140>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94141>>>            Send Exit_Application
94142>>>        End
94142>>>>
94142>>>
94142>>>        // This will put a look on the DbUpdateLock.ucf file.
94142>>>        // It is released when the update process is finished
94142>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94143>>>
94143>>>        Move (CurrentDateTime()) to dtUpdateStarted
94144>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94145>>>        Set Private.pbDatabaseUpdateStarted to True
94146>>>
94146>>>        // We need to close all tables before starting to make changes.
94146>>>        Close DF_ALL DF_PERMANENT
94147>>>
94147>>>        // If these properties has not exclicitly been set in the object, set them
94147>>>        // to settings from the SQLConnections.ini file;
94147>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94148>>>        If (psSchema(Self) = "") Begin
94150>>>            Set psSchema            to SQLConnection.sSchema
94151>>>        End
94151>>>>
94151>>>        If (psBaseTableSpace(Self) = "") Begin
94153>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94154>>>        End
94154>>>>
94154>>>        If (psLongTableSpace(Self) = "") Begin
94156>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94157>>>        End
94157>>>>
94157>>>        If (psIndexTableSpace(Self) = "") Begin
94159>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94160>>>        End
94160>>>>
94160>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94162>>>            Procedure_Return
94163>>>        End
94163>>>>
94163>>>
94163>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94164>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94166>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94167>>>            Send Stop_StatusPanel of ghoStatusPanel
94168>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94168>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94169>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94169>>>            Send Exit_Application
94170>>>        End
94170>>>>
94170>>>    End_Procedure
94171>>>
94171>>>    // *** Hook message for pre-processing ***
94171>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94171>>>    // Aka, when another table than the standard "DbVersion" is used.
94171>>>    Procedure OnCreateCustomDbVersionTable
94173>>>    End_Procedure
94174>>>    
94174>>>    // *** Hook message for pre-processing ***
94174>>>    // The programmer can use this event for putting code that
94174>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94174>>>    // child objects are executed.
94174>>>    Procedure OnPreUpdate
94176>>>    End_Procedure
94177>>>
94177>>>    // *** Hook message for post-processing ***
94177>>>    // The programmer should use this event for putting code that
94177>>>    // needs to be executed _after_ all database updates have finished.
94177>>>    Procedure OnPostUpdate
94179>>>    End_Procedure
94180>>>
94180>>>    // *** Hook message for custom DbVersion record find ***
94180>>>    // The programmer can use this event for putting code that
94180>>>    // needs to be executed to find a *custom* DbVersion table record.
94180>>>    // By default the DbVersion table is used but this can be
94180>>>    // customized by adding this line to the code;
94180>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94180>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94180>>>    //       to save the current database version to. Only if you use your own
94180>>>    //       table _and_ it is not a system table (contains only one record).
94180>>>    Procedure OnFindVersionRecord
94182>>>        // Open MyTable
94182>>>        // Move xx to MyTable.Field1
94182>>>        // Move yy to MyTable.Field2
94182>>>        // Find le MyTable by Index.x
94182>>>    End_Procedure
94183>>>
94183>>>    // Hook event for writing header error text (pre-update) to
94183>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94183>>>    // Don't forget to Open the table first (!) as all
94183>>>    // tables have been closed at this stage.
94183>>>    // The start date & time is passed.
94183>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94185>>>    End_Procedure
94186>>>
94186>>>    // Hook event to log errors to a database table.
94186>>>    // Only called if the pbUseDataTableLog = True.
94186>>>    // Don't forget to Open the table first (!) as all
94186>>>    // tables have been closed at this stage.
94186>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94186>>>    // will contain just one row, as it is called for each error
94186>>>    // that occurred. Else it is called once at the end after all updates
94186>>>    // have run and contains all errors.
94186>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94188>>>    End_Procedure
94189>>>
94189>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94189>>>    Procedure Cleanup
94191>>>        Boolean bDatabaseWasUpdated bError
94191>>>
94191>>>        Send CheckAutoCreateDbVersionTable
94192>>>        Send RestoreOpenTables
94193>>>
94193>>>        // The function library have two purposes; one is to use it in the
94193>>>        // Database Update Framework, but it can also be used on its own.
94193>>>        // If that is the case it has its own error handling system, which
94193>>>        // we temporarily disbled when running updates because we have
94193>>>        // error handling/logging here too... We now restore its setting.
94193>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94195>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94196>>>        End
94196>>>>
94196>>>        Set pbHandleQueryErrors to True
94197>>>
94197>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94198>>>        Get pbDbUpdateErrorHasOccured to bError
94199>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94201>>>
94201>>>            // We should always create the log as it also contains info about
94201>>>            // the update being successful.
94201>>>            Send WriteErrorLog of (phoLogFile(Self))
94202>>>
94202>>>            // This is a programmer's hook message:
94202>>>            Send OnPostUpdate
94203>>>
94203>>>            Send Stop_StatusPanel of ghoStatusPanel
94204>>>
94204>>>            If (pbSilentMode(Self) = False) Begin
94206>>>                If (bError = True) Begin
94208>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94210>>>                        Send ShowErrorLog of (phoLogFile(Self))
94211>>>                    End
94211>>>>
94211>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94212>>>                    Send Exit_Application
94213>>>                End
94213>>>>
94213>>>                Else Begin
94214>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94216>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94217>>>                    End
94217>>>>
94217>>>                    Else Begin
94218>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94219>>>                    End
94219>>>>
94219>>>
94219>>>                End
94219>>>>
94219>>>            End
94219>>>>
94219>>>        End
94219>>>>
94219>>>
94219>>>        // Restore the standard error handler:
94219>>>        Get piOrgErrorHandlerID to Error_Object_Id
94220>>>    End_Procedure
94221>>>
94221>>>    // We do this _before_ we close the database to make changes, and save
94221>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94221>>>    // we reopen the database.
94221>>>    Procedure SaveOpenTables
94223>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94223>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94224>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94225>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94226>>>    End_Procedure
94227>>>
94227>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94227>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94227>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94229>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94229>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94230>>>        Integer hTable iMasterAliasType iSize
94230>>>        Boolean bOpen
94230>>>
94230>>>        Move 0 to hTable
94231>>>        Repeat
94231>>>>
94231>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94234>>>            If (hTable <> 0) Begin
94236>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94239>>>                If (bOpen = True) Begin
94241>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94244>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94245>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94246>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94247>>>                End
94247>>>>
94247>>>            End
94247>>>>
94247>>>        Until (hTable = 0)
94249>>>
94249>>>        Function_Return aDbUpdateHandlerMasterAlias
94250>>>    End_Function
94251>>>
94251>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94251>>>    // Takes one parameter:
94251>>>    //   A struct array with all master & alias
94251>>>    Procedure RestoreOpenTables
94253>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94253>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94254>>>        Integer hTable iFileAlias iSize iCount
94254>>>        Boolean bOpen
94254>>>        String sRootName
94254>>>
94254>>>        Move 0 to hTable
94255>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94256>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94257>>>        Decrement iSize
94258>>>        For iCount from 0 to iSize
94264>>>>
94264>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94265>>>            // We also need to check that the table hasn't been removed...
94265>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94268>>>            If (hTable <> 0 and sRootName <> "") Begin
94270>>>                Open hTable
94272>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94275>>>                If (bOpen = True) Begin
94277>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94278>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94280>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94283>>>                    End
94283>>>>
94283>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94286>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94289>>>                    End
94289>>>>
94289>>>                End
94289>>>>
94289>>>            End
94289>>>>
94289>>>        Loop
94290>>>>
94290>>>    End_Procedure
94291>>>
94291>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94291>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94291>>>    Procedure CheckForDuplicates Number nVersion
94293>>>        tDbVersionInfo[] DbVersionInfoArray
94293>>>        tDbVersionInfo[] DbVersionInfoArray
94294>>>        Integer iCount iSize iHits iDuplicateIndex
94294>>>        Number nCompare
94294>>>        Handle hObject1 hObject2
94294>>>        String sObjectName1 sObjectName2
94294>>>        Boolean bObjectOrderError
94294>>>
94294>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94295>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94296>>>        Decrement iSize
94297>>>        Move 0 to iHits
94298>>>        Move 0 to nCompare
94299>>>        Move False to bObjectOrderError
94300>>>        For iCount from 0 to iSize
94306>>>>
94306>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94308>>>                Increment iHits
94309>>>                If (iHits > 1) Begin
94311>>>                    Move iCount to iDuplicateIndex
94312>>>                    If (nCompare <> 0) Begin
94314>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94315>>>                    End
94315>>>>
94315>>>                End
94315>>>>
94315>>>            End
94315>>>>
94315>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94316>>>        Loop
94317>>>>
94317>>>        If (iHits > 1) Begin
94319>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94320>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94321>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94322>>>            Move (Name(hObject1)) to sObjectName1
94323>>>            Move (Name(hObject2)) to sObjectName2
94324>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94325>>>>
94325>>>            Send Exit_Application
94326>>>        End
94326>>>>
94326>>>        Else If (bObjectOrderError = True) Begin
94329>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94330>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94331>>>>
94331>>>            Send Exit_Application
94332>>>        End
94332>>>>
94332>>>    End_Procedure
94333>>>
94333>>>    // We take care of all errors in the Error_Report below and
94333>>>    // collect them all to an array property. So just ignore any
94333>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94333>>>    // in some other package.
94333>>>    Procedure Ignore_Error Integer iError
94335>>>    End_Procedure
94336>>>
94336>>>    Procedure Trap_Error Integer iError
94338>>>    End_Procedure
94339>>>
94339>>>    // Build complete error description from Flexerrs and user error message.
94339>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94341>>>        String Full_Error_Text
94341>>>        
94341>>>        Move (Trim(ErrMsg)) to ErrMsg
94342>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94343>>>        
94343>>>        If (ErrMsg <> "") Begin
94345>>>            
94345>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94347>>>                // Make sure last character of error text is a separating symbol.
94347>>>                // if not, add a "." So we have format of "error-text. error-detail"
94347>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
94350>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
94351>>>            End
94351>>>>
94351>>>            Else ;                Move ErrMsg to Full_Error_Text
94353>>>            
94353>>>        End
94353>>>>
94353>>>        
94353>>>        Function_Return Full_Error_Text
94354>>>    End_Function
94355>>>
94355>>>    // While we update the database we collect all errors in
94355>>>    // the struct array paDbUpdateErrorArray.
94355>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94357>>>        Number nVersion
94357>>>        Handle hoLogFile 
94357>>>//        String sErrExtraText
94357>>>        
94357>>>        If (Private.pbProcessingError(Self)) Begin
94359>>>            Procedure_Return
94360>>>        End
94360>>>>
94360>>>
94360>>>        // The UtilTableNameFromHandleToString function does a:
94360>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
94360>>>        // and it generates an error if the table is of the embedded type.
94360>>>        // As we don't want to trigger an error in that very specific case,
94360>>>        // we just ignore it here.
94360>>>        //
94360>>>        // If no report mode, just set the err indicator to true.
94360>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
94362>>>            Move False to Err
94363>>>            Procedure_Return
94364>>>        End
94364>>>>
94364>>>
94364>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
94366>>>            Procedure_Return
94367>>>        End
94367>>>>
94367>>>
94367>>>        Set Private.pbProcessingError to True
94368>>>        Set Private.pbUpdateVersionObjectError to True
94369>>>
94369>>>        Set pbDbUpdateErrorHasOccured to True
94370>>>        Get pnCurrentVersionUpdate to nVersion
94371>>>        Get phoLogFile to hoLogFile
94372>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
94373>>>
94373>>>        Set Private.pbProcessingError to False
94374>>>    End_Procedure
94375>>>
94375>>>End_Class
94376>
94376>Object oHtmlHelp is a cHtmlHelp
94378>    Set pbAlwaysOnTop to False
94379>
94379>    // Overriden class message to also handle internet HTML Help links;
94379>    // which in which case we should not try to find the path to the help file.
94379>    Function GetHelpFile Returns String
94382>        String sHelpFile
94382>
94382>        Get psHelpFile of ghoApplication to sHelpFile
94383>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
94385>            Get_File_Path sHelpFile to sHelpFile
94386>        End
94386>        Function_Return sHelpFile
94387>    End_Function
94388>
94388>End_Object
94389>
94389>Object oApplication is a cApplication
94391>    Set peHelpType to htHtmlHelp
94392>
94392>    // Note: These help file settings gets changed by the Help toolbar button(s).
94392>    Set psHelpFile to "Developer5.chm"
94393>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
94393>
94393>    Set pbPreserveEnvironment to True
94394>    Set psProduct to "Database Update Framework Lab"
94395>    Set psCompany to "RDC Tools International" 
94396>
94396>    Property String psCompileDateAndTime
94398>    // This is used by the About object to display the compile date & time:
94398>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
94398>
94398>    // DF 19 and up.
94398>        Object oConnection is a cConnection
94400>            Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\LoginEncryption.pkg)
94400>>>Use cLoginEncryption.pkg
94400>>>
94400>>>Object oLoginEncryption is a cLoginEncryption
94402>>>
94402>>>    // this must be created in your appsrc directory and must contain an encryption
94402>>>    // key that is set to psEncryptPassword. It will look something like this
94402>>>    //
94402>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
94402>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
94402>>>>// Studio generated login encryption key
94402>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
94403>>>>
94403>>>    
94403>>>    // use this to register this object to your cConnection Object. This object
94403>>>    // must be created after the cConnection object
94403>>>    Move Self to ghoLoginEncryption
94404>>>End_Object
94405>            Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 23.0\Pkg\DatabaseLoginDialog.dg)
94405>>>
94405>>>Use Windows.pkg
94405>>>Use cConnection.pkg
94405>>>Use dfLine.pkg
94405>>>
94405>>>Object oDatabaseLoginDialog is a ModalPanel
94407>>>    Set Label to "Database Login"
94408>>>    Set Location to 2 2
94409>>>    Set Size to 110 211
94410>>>    
94410>>>    Property String psId
94412>>>    Property Boolean pbOk False
94414>>>    Property Boolean pbChanged False
94416>>>    Property Boolean pbAllowRemember True
94418>>>    
94418>>>    // this registers this object with the cConnection object.
94418>>>    Move Self to ghoLoginConnectDialog
94419>>>    
94419>>>    Object oUserIDForm is a Form
94421>>>        Set Label to "User Name"
94422>>>        Set Size to 12 85
94423>>>        Set Location to 34 79
94424>>>        Set Label_Col_Offset to 64
94425>>>        Set peAnchors to anTopLeftRight
94426>>>    End_Object
94427>>>    
94427>>>    Object oPwdForm is a Form
94429>>>        Set Size to 12 85
94430>>>        Set Location to 49 79
94431>>>        Set Label_Col_Offset to 64
94432>>>        Set Password_State to True
94433>>>        Set peAnchors to anTopLeftRight
94434>>>        Set Label to "Password"
94435>>>    End_Object
94436>>>    
94436>>>    Object oTrustedConnection is a CheckBox
94438>>>        Set Size to 10 50
94439>>>        Set Location to 65 79
94440>>>        Set Label to "Trusted Connection"
94441>>>    End_Object
94442>>>    
94442>>>    Object oRemember is a CheckBox
94444>>>        Set Size to 10 50
94445>>>        Set Location to 79 14
94446>>>        Set Label to "Remember and don't ask again"
94447>>>        Set Checked_State to True
94448>>>    End_Object
94449>>>    
94449>>>    Object oLogin_btn is a Button
94451>>>        Set Label to "&Login"
94452>>>        Set Location to 92 102
94453>>>        Set peAnchors to anBottomRight
94454>>>        Set Default_State to True
94455>>>        
94455>>>        Procedure OnClick
94458>>>            Boolean bTrust
94458>>>            String sUser sPwd sConn sErr sId
94458>>>            Integer iError
94458>>>            Get psId to sId
94459>>>            Get Value of oUserIDForm to sUser
94460>>>            Get Value of oPwdForm to sPwd
94461>>>            Get Checked_State of oTrustedConnection to bTrust
94462>>>            
94462>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
94463>>>            If (iError=0) Begin
94465>>>                Set pbOk to True
94466>>>                Set pbChanged to True
94467>>>                Send Close_Panel
94468>>>            End
94468>>>>
94468>>>            Else Begin
94469>>>                Get psErrorText of ghoConnection to sErr
94470>>>                Send UserError sErr "Login Error"
94471>>>            End
94471>>>>
94471>>>        End_Procedure
94472>>>    End_Object
94473>>>    
94473>>>    Object oCancel_btn is a Button
94475>>>        Set Label to "&Cancel"
94476>>>        Set Location to 92 157
94477>>>        Set peAnchors to anBottomRight
94478>>>        
94478>>>        Procedure OnClick
94481>>>            Send Close_Panel
94482>>>        End_Procedure
94483>>>    End_Object
94484>>>    
94484>>>    Object oConnectionIdInfo is a TextBox
94486>>>        Set Size to 10 50
94487>>>        Set Location to 4 14
94488>>>        Set Label to 'Connection Id='
94489>>>    End_Object
94490>>>    
94490>>>    Object oConnectionServerInfo is a TextBox
94492>>>        Set Size to 10 50
94493>>>        Set Location to 16 14
94494>>>        Set Label to 'Server'
94495>>>    End_Object
94496>>>    
94496>>>    Object oLineControl1 is a LineControl
94498>>>        Set Size to 2 202
94499>>>        Set Location to 29 5
94500>>>    End_Object
94501>>>    
94501>>>    Function LoginConnectIdDialog String sId Returns Boolean
94504>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
94504>>>        String sUser sPwd sDescription
94504>>>        tConnection Connect
94504>>>        tConnection Connect
94504>>>        
94504>>>        Get pbAllowRemember to bAllowRemember
94505>>>        
94505>>>        
94505>>>        If not bAllowRemember Begin
94507>>>            Set Enabled_State of oRemember to bRemember
94508>>>            Set Visible_State of oRemember to bRemember
94509>>>        End
94509>>>>
94509>>>        
94509>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
94510>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
94511>>>        Set Value of oConnectionServerInfo to Connect.sString
94512>>>        
94512>>>        Set psId to sId
94513>>>        Set pbOk to False
94514>>>        Set pbChanged to False
94515>>>        Set Value of oUserIDForm to Connect.sUID
94516>>>        Set Value of oPwdForm to ""
94517>>>        
94517>>>        Send Popup
94518>>>        
94518>>>        Get pbOk to bOk
94519>>>        Get pbChanged to bChanged
94520>>>        If (bChanged and bOk) Begin
94522>>>            If bAllowRemember Begin
94524>>>                Get Checked_State of oRemember to bRemember
94525>>>                If bRemember Begin
94527>>>                    Get Checked_State of oTrustedConnection to bTrusted
94528>>>                    If not (bTrusted) Begin
94530>>>                        Get Value of oUserIDForm to sUser
94531>>>                        Get Value of oPwdForm to sPwd
94532>>>                    End
94532>>>>
94532>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
94533>>>                End
94533>>>>
94533>>>            End
94533>>>>
94533>>>        End
94533>>>>
94533>>>        Function_Return bOk
94534>>>    End_Function
94535>>>    
94535>>>    
94535>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
94536>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
94537>>>End_Object
94538>>>
94538>        End_Object
94539>
94539>    Procedure End_Construct_Object
94542>        String sCompileTime  
94542>        Integer iPos
94542>        
94542>        Forward Send End_Construct_Object
94544>        Direct_Input "resource: res_CompileHeader"
94545>        Readln sCompileTime
94546>        Move (Pos('"', sCompileTime)) to iPos
94547>        If (iPos <> 0) Begin
94549>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
94550>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
94551>            Set psCompileDateAndTime to sCompileTime
94552>        End
94552>        Close_Input
94553>    End_Procedure
94554>
94554>End_Object   
94555>
94555>Object oDbUpdateHandler is a cDbUpdateHandler 
94557>    Set piDbVersionFieldNumber to 1
94558>    Set piDbVersionFileNumber to 1
94559>    
94559>End_Object
94560>
94560>Object oCJSkinFramework is a cCJSkinFramework
94562>    Set pbLoadPreference to True
94563>End_Object
94564>
94564>Object oToolTipController is a cToolTipController
94566>    Set piDurationPopup to 10000
94567>    Set piMaxWidth to 500
94568>    Move Self to ghoToolTipController
94569>End_Object
94570>
94570>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oEditContextMenu.pkg)
94570>>>Use cCJStandardMenuItemClasses.pkg
94570>>>
94570>>>Object oEditContextMenu is a cCJContextMenu
94572>>>    
94572>>>    Move Self to Default_Form_Floating_Menu_ID
94573>>>    
94573>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94575>>>    End_Object
94576>>>    
94576>>>    Object oCutMenuItem is a cCJCutMenuItem
94578>>>        Set pbControlBeginGroup to True
94579>>>    End_Object
94580>>>    
94580>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94582>>>    End_Object
94583>>>
94583>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94585>>>    End_Object
94586>>>
94586>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94588>>>    End_Object
94589>>>
94589>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94591>>>        Set pbControlBeginGroup to True
94592>>>    End_Object
94593>>>
94593>>>End_Object
94594>>>
94594>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oDEOEditContextMenu17.pkg)
94594>>>Use Windows.pkg
94594>>>Use cCJStandardMenuItemClasses.pkg
94594>>>Use cCJDeoMenuItemClasses.pkg
94594>>>
94594>>>
94594>>>Object oDEOEditContextMenu17 is a cCJContextMenu
94596>>>    
94596>>>    Move Self to Default_dbFloating_Menu_ID
94597>>>    
94597>>>    Object oUndoMenuItem is a cCJUndoMenuItem
94599>>>    End_Object
94600>>>    
94600>>>    Object oCutMenuItem is a cCJCutMenuItem
94602>>>        Set pbControlBeginGroup to True
94603>>>    End_Object
94604>>>    
94604>>>    Object oCopyMenuItem is a cCJCopyMenuItem
94606>>>    End_Object
94607>>>
94607>>>    Object oPasteMenuItem is a cCJPasteMenuItem
94609>>>    End_Object
94610>>>
94610>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
94612>>>    End_Object
94613>>>
94613>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
94615>>>        Set pbControlBeginGroup to True
94616>>>    End_Object
94617>>>
94617>>>    Object oPromptMenuItem is a cCJPromptMenuItem
94619>>>        Set pbControlBeginGroup to True
94620>>>    End_Object
94621>>>
94621>>>    Object oFindNextMenu is a cCJFindNextMenuItem
94623>>>        Set pbControlBeginGroup to True
94624>>>    End_Object
94625>>>
94625>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
94627>>>    End_Object
94628>>>
94628>>>    Object oClearMenuItem is a cCJClearMenuItem
94630>>>        Set pbControlBeginGroup to True
94631>>>    End_Object
94632>>>
94632>>>    Object oClearAllMenu is a cCJClearAllMenuItem
94634>>>    End_Object
94635>>>
94635>>>    Object oSaveMenu is a cCJSaveMenuItem
94637>>>    End_Object
94638>>>    
94638>>>    Object oDeleteMenu is a cCJDeleteMenuItem
94640>>>    End_Object
94641>>>
94641>>>    Object oRememberitem is a cCJRememberFieldMenuItem
94643>>>        Set pbControlBeginGroup to True
94644>>>    End_Object
94645>>>
94645>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
94647>>>    End_Object
94648>>>
94648>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
94650>>>    End_Object
94651>>>
94651>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
94653>>>    End_Object
94654>>>
94654>>>End_Object
94655>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cSkinComboBoxCJMenuItem.pkg)
94655>>>Use cCJCommandBarSystem.pkg
94655>>>Use Wingdi.pkg
94655>>>Use LanguageText.pkg
94655>>>
94655>>>// User interface constant strings:
94655>>>Define CS_NoSkinShort For "-None"
94655>>>Define CS_NoSkinLong  For "Do not use a skin"
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>
94655>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
94656>>>
94656>>>    Procedure Construct_Object
94658>>>        Forward Send Construct_Object
94660>>>
94660>>>        Set peControlType to xtpControlComboBox
94661>>>
94661>>>        Property tSkinInformation[] pSkins
94662>>>
94662>>>    End_Procedure
94663>>>
94663>>>    Procedure End_Construct_Object
94665>>>        Forward Send End_Construct_Object
94667>>>    End_Procedure
94668>>>
94668>>>    // Custom array sort for the tSkinInformation struct array.
94668>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
94668>>>    // Why?
94668>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
94668>>>    // create a custom sort algorithm.
94668>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
94668>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
94668>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
94668>>>    // randomly ordered. This custom sort method will take care of that.
94668>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
94670>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94672>>>            Function_Return (GT)
94673>>>        End
94673>>>>
94673>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
94675>>>            Function_Return (LT)
94676>>>        End
94676>>>>
94676>>>        Function_Return (EQ)
94677>>>    End_Function
94678>>>
94678>>>    Procedure OnCreateControl Handle hoObj
94680>>>        Forward Send OnCreateControl hoObj
94682>>>
94682>>>        Send LoadSkins
94683>>>        Send FillComboList hoObj
94684>>>    End_Procedure
94685>>>
94685>>>    // Load all skins. We will only look for skins in expected
94685>>>    // directory which is the Programs folder.
94685>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
94685>>>    // This is not the case with the 'standard' VDF behaviour.
94685>>>    Procedure LoadSkins
94687>>>        Integer iCount iItems iSize
94687>>>        Boolean bFound
94687>>>        String sFile sIni sSkin
94687>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
94687>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
94689>>>        tSkinInformation NoneRow
94689>>>        tSkinInformation NoneRow
94689>>>
94689>>>        If (ghoSkinFramework > 0) Begin
94691>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
94692>>>
94692>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
94693>>>            Move CS_NoSkinShort to NoneRow.sName
94694>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
94695>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
94696>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
94697>>>
94697>>>            // Get the currently loaded skin.
94697>>>            Get psSkinFile of ghoSkinFramework to sFile
94698>>>            Get psSkinIni  of ghoSkinFramework to sIni
94699>>>
94699>>>            // Remove all Extra Large and Large skins from the array.
94699>>>            Move (SizeOfArray(SkinsArray)) to iItems
94700>>>            Decrement iItems
94701>>>            For iCount From 0 to iItems
94707>>>>
94707>>>                Move SkinsArray[iCount].sSkinIni to sSkin
94708>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
94709>>>                If (bFound = False) Begin
94711>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
94712>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
94713>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
94714>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
94715>>>                End
94715>>>>
94715>>>            Loop
94716>>>>
94716>>>            Set pSkins to SkinsArrayNoLarge
94717>>>        End
94717>>>>
94717>>>    End_Procedure
94718>>>
94718>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
94718>>>    Procedure FillComboList Handle hoCombo
94720>>>        Integer iCount iItems iCurrent iTxtEntentSize
94720>>>        String  sFile sIni sCurrSkin
94720>>>        String  sSkin sSkinText
94720>>>        tSkinInformation[] SkinsArray
94720>>>        tSkinInformation[] SkinsArray
94721>>>        Integer iSize
94721>>>
94721>>>        If (ghoSkinFramework < 1) Begin
94723>>>            Procedure_Return
94724>>>        End
94724>>>>
94724>>>
94724>>>        // Get the currently loaded skin.
94724>>>        Get psSkinFile of ghoSkinFramework to sFile
94725>>>        Get psSkinIni  of ghoSkinFramework to sIni
94726>>>        Get pSkins to SkinsArray
94727>>>        Move (SizeOfArray(SkinsArray)) to iItems
94728>>>        Decrement iItems
94729>>>        Send ComClear of hoCombo
94730>>>
94730>>>        For iCount From 0 to iItems
94736>>>>
94736>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
94737>>>            Move (Replace(".ini", sSkin, "")) to sSkin
94738>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
94739>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
94740>>>            Get Text_Extent sSkinText to iSize
94741>>>            If (iSize > iTxtEntentSize) Begin
94743>>>                Move iSize to iTxtEntentSize
94744>>>            End
94744>>>>
94744>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
94745>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
94747>>>                Move iCount to iCurrent
94748>>>            End
94748>>>>
94748>>>        Loop
94749>>>>
94749>>>
94749>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
94750>>>        Set ComDropDownWidth of hoCombo  to iSize
94751>>>        Set ComWidth         of hoCombo  to (iSize + 100)
94752>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
94753>>>    End_Procedure
94754>>>
94754>>>    // Event for when an item is selected from the comboform
94754>>>    Procedure OnExecute Variant vCommandBarControl
94756>>>        Handle  hoCombo
94756>>>        Integer iSelection
94756>>>        String  sSkinFile sSkinIni
94756>>>        tSkinInformation[] SkinsArray
94756>>>        tSkinInformation[] SkinsArray
94757>>>
94757>>>        // Create and bind proxy control
94757>>>        Get CreateProxyControl vCommandBarControl to hoCombo
94758>>>        // Get the current selection
94758>>>        Get ComListIndex of hoCombo to iSelection
94759>>>        Decrement iSelection
94760>>>        Get pSkins to SkinsArray
94761>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
94762>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
94763>>>
94763>>>        Send DoChangeSkin sSkinFile sSkinIni
94764>>>
94764>>>        // Dispose of the proxy control
94764>>>        Send Destroy of hoCombo
94765>>>    End_Procedure
94766>>>
94766>>>    // Send this message to change the current skin.
94766>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
94768>>>        Handle hoClient
94768>>>
94768>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
94769>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
94770>>>        Send ApplySkin of ghoSkinFramework
94771>>>
94771>>>        // Note: The following line is essential for the resizing logic
94771>>>        // to function properly when changing a skin and a view is maximized.
94771>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
94772>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
94773>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
94774>>>    End_Procedure
94775>>>
94775>>>    // Returns: DPI setting as an integer.
94775>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
94775>>>    //                      iDPI=120 is "Medium setting" 125%
94775>>>    //                      iDPI= 144 is "Large setting" 150%
94775>>>    Function GetCurrentDPI Returns Integer
94777>>>        Handle hDC
94777>>>        Integer iPixelsX
94777>>>        Move (GetDC(0)) to hDC
94778>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
94779>>>        Move (ReleaseDC(0, hDC)) to hDC
94780>>>        Function_Return iPixelsX
94781>>>    End_Function
94782>>>
94782>>>End_Class
94783>
94783>Object oMain is a Panel
94785>    Set Label to "Test Program - The Database Update Framework"
94786>    Set Location to 2 2
94787>    Set Size to 309 493
94788>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
94789>    Set Icon to "TestTools.ico"
94790>
94790>    Property Handle phoViewMenu 0
94792>    Property Handle phoReportMenu 0
94794>
94794>    Object oCommandBarSystem is a cCJCommandBarSystem
94796>        Set pbTimerUpdate to True
94797>            Set pbAutoResizeIcons to True
94798>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
94799>            Set peVisualTheme to xtpThemeOffice2013Publisher
94800>            Set pbLargeIcons to True
94801>
94801>        Procedure OnCreateCommandBars
94804>            Handle hoOptions
94804>            Forward Send OnCreateCommandBars
94806>                Get OptionsObject to hoOptions
94807>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
94808>        End_Procedure
94809>
94809>
94809>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
94812>            Set ComShowIcons of hoTabPaintManager to True
94813>
94813>            // This will truncate the middle part of long items
94813>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
94814>        End_Procedure
94815>
94815>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
94815>        // the previous tab workspace view.
94815>        Object oPreviousTabAction is a cCJAction
94817>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
94818>            Procedure OnExecute Variant vCommandBarControl
94821>                Handle hoCommandBars hoClientArea
94821>                Forward Send OnExecute vCommandBarControl
94823>                Get CommandBarSystemObject to hoCommandBars
94824>                Get ClientAreaObject of hoCommandBars to hoClientArea
94825>                If hoClientArea Begin
94827>                    Send Switch_Next_View of hoClientArea
94828>                End
94828>            End_Procedure
94829>        End_Object
94830>
94830>        Object oToolBar is a cCJToolbar
94832>            Set psTitle to "Edit Toolbar"
94833>            Set pbGripper to False
94834>            Set peStretched to stStretch
94835>
94835>            Object oCutToolbarItem is a cCJCutMenuItem  
94837>                Set psImage to "ActionCut1.ico"
94838>            End_Object
94839>
94839>            Object oCopyToolbarItem is a cCJCopyMenuItem
94841>                Set psImage to "ActionCopy1.ico"
94842>            End_Object
94843>
94843>            Object oPasteToolbarItem is a cCJPasteMenuItem
94845>                Set psImage to "ActionPaste1.ico"
94846>            End_Object
94847>
94847>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
94849>                Set psImage to "ActionDelete1.ico"
94850>                Set pbControlBeginGroup to True
94851>            End_Object
94852>
94852>            Object oTheme_tb is a cCJMenuItem
94854>                Set peControlType to xtpControlLabel
94855>                Set psCaption to "Theme:"
94856>                Set pbControlBeginGroup to True
94857>            End_Object
94858>
94858>            Object oThemeItem is a cCJMenuItem
94860>                Set peControlType to xtpControlComboBox
94861>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
94862>
94862>                Procedure OnCreateControl Handle hoObj
94865>                    Integer iItem eTheme
94865>                    Set ComWidth of hoObj to 250
94866>                    Send FillComboList hoObj
94867>                    Get peVisualTheme to eTheme
94868>                    Get FindDataItem hoObj eTheme to iItem
94869>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
94870>                End_Procedure
94871>
94871>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
94874>                    Integer iCount i eTheme
94874>                    Get ComListCount of hoCombo to iCount
94875>                    For i from 1 to iCount
94881>                        Get ComItemData of hoCombo i to eTheme
94882>                        If (eTheme=eVal) Begin
94884>                            Send SetTheTheme eTheme
94885>                            Function_Return i
94886>                        End
94886>                    Loop
94887>                    Function_Return 0
94888>                End_Function
94889>
94889>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
94892>                    Integer iCount
94892>                    Get ComListCount of hoCombo to iCount
94893>                    Increment iCount
94894>                    Send ComAddItem  of hoCombo sText iCount
94895>                    Set ComItemData  of hoCombo iCount to  eTheme
94896>                End_Procedure
94897>
94897>                Procedure FillComboList Handle hoCombo
94900>                    Send ComClear     of hoCombo
94901>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
94902>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
94903>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
94904>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
94905>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
94906>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
94907>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
94908>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
94909>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
94910>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
94911>    
94911>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
94912>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
94913>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
94914>    
94914>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
94915>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
94916>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
94917>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
94918>    
94918>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
94919>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
94920>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
94921>    
94921>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
94922>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
94923>    
94923>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
94924>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
94925>    
94925>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
94926>    
94926>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
94927>    
94927>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
94928>                End_Procedure
94929>
94929>                Function CurrentTheme Handle vCommandBarControl Returns Integer
94932>                    Handle hMessage hoCombo
94932>                    Integer iIndex
94932>                    // create and bind  proxy control
94932>                    Get CreateProxyControl vCommandBarControl to hoCombo
94933>                    // get the current selection
94933>                    Get ComListIndex of hoCombo to iIndex
94934>                    // note the index selections are 1 based
94934>                    If (iIndex > 0) Begin
94936>                        // get the ItemData for the selected item and send that message
94936>                        Get ComItemData of hoCombo iIndex to hMessage
94937>                        Function_Return hMessage
94938>                    End
94938>                    // dispose of the proxy control
94938>                    Send Destroy of hoCombo
94939>                    Function_Return 0
94940>                End_Function
94941>
94941>                Procedure OnExecute Variant vCommandBarControl
94944>                    Integer eTheme
94944>                    Integer iColor
94944>                    Get CurrentTheme vCommandBarControl to eTheme
94945>                    Set peVisualTheme of ghoCommandBars to eTheme
94946>                    Send ComRecalcLayout of ghoCommandBars
94947>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
94948>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
94950>                End_Procedure
94951>
94951>                Procedure SetTheTheme Integer eTheme
94954>                    Integer iColor
94954>                    Set peVisualTheme of ghoCommandBars to eTheme
94955>                    Send ComRecalcLayout of ghoCommandBars
94956>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
94957>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
94959>                End_Procedure
94960>
94960>                Function ConvertSystemColor Integer iColor Returns Integer
94963>                    Integer iSysColor
94963>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
94965>                        Move clNone to iColor
94966>                    End
94966>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
94969>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
94970>                        Move (GetSysColor(iSysColor)) to iColor
94971>                    End
94971>                    Function_Return iColor
94972>                End_Function
94973>
94973>            End_Object
94974>
94974>            Object oAbout_MenuItem is a cCJMenuItem
94976>                Set psCaption to "About"
94977>                Set psToolTip to "About Info"
94978>                Set psDescription to "About the program"
94979>                Set psImage to "ActionAbout1.ico"
94980>                Set pbControlBeginGroup to True
94981>                Procedure OnExecute Variant vCommandBarControl
94984>                    Forward Send OnExecute vCommandBarControl
94986>                    Send Activate_About of (Client_Id(ghoCommandBars))
94987>                End_Procedure
94988>            End_Object
94989>
94989>            Object oHelpMenuItem is a cCJHelpMenuItem
94991>                Set peControlType to xtpControlSplitButtonPopup
94992>                Set psImage to "ActionHelp1.ico"
94993>
94993>                Procedure OnExecute Variant vCommandBarControl
94996>                    Forward Send OnExecute vCommandBarControl
94998>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
94999>                    Send ShowProgramHelp
95000>                End_Procedure
95001>
95001>                Object oHelpMenuItemLocal is a cCJMenuItem
95003>                    Set psCaption to "Local HTML Help"
95004>                    Set psImage to "ActionHelp1.ico"
95005>                    Procedure OnExecute Variant vCommandBarControl
95008>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95009>                        Send ShowProgramHelp
95010>                    End_Procedure
95011>                End_Object
95012>
95012>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95014>                    Set psCaption to "Internet Online HTML Help"
95015>                    Set psImage to "ActionHelp1.ico"
95016>                    Procedure OnExecute Variant vCommandBarControl
95019>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95020>                    End_Procedure
95021>
95021>                End_Object
95022>            End_Object
95023>
95023>            Object oExitMenuItem is a cCJExitMenuItem
95025>                Set psImage to "ActionExit1.ico"
95026>                Set psToolTip to "Exit application"
95027>                Set psDescription to "Exit the program (Alt+F4)"
95028>                Set pbControlBeginGroup to True
95029>            End_Object
95030>        End_Object
95031>
95031>//        Object oSpacerBar is a cCJToolbar
95031>//            Set pbDockNextTo to False
95031>//            Set pbShowExpandButton to False
95031>//            Set pbGripper to False
95031>//            Set peStretched to stStretch
95031>//            Set pbCustomizable to False
95031>//            Set pbCloseable to False
95031>//            Set pbEnableDocking to False
95031>//            Set pbHideWrap to True
95031>//
95031>//            Object oFiller is a cCJMenuItem
95031>//            End_Object
95031>//
95031>//        End_Object
95031>
95031>        Object oStatusBar is a cCJStatusBar
95033>
95033>            Object oStatusPane1 is a cCJStatusBarPane
95035>                Set piID to sbpIDIdlePane
95036>                Set pbStyleStretch to True
95037>            End_Object
95038>            Object oStatusPane2 is a cCJStatusBarPane
95040>                Set phoViewPane to Self
95041>                Set pbStyleStretch to True
95042>            End_Object
95043>
95043>        End_Object
95044>
95044>    End_Object
95045>
95045>    Object oClientArea is a ClientArea
95047>
95047>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95047>
95047>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\StdAbout.pkg)
95047>>>//************************************************************************
95047>>>// Confidential Trade Secret.
95047>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95047>>>// as an unpublished work.  All rights reserved.
95047>>>// DataFlex is a registered trademark of Data Access Corporation.
95047>>>//
95047>>>//************************************************************************
95047>>>//************************************************************************
95047>>>//
95047>>>// $File name  : StdAbout.pkg
95047>>>// $File title : Standard about object package for VDF
95047>>>// Notice      :
95047>>>// $Author(s)  : John Tuohy
95047>>>//
95047>>>// $Rev History
95047>>>//
95047>>>// JT 06/27/97   File created
95047>>>//************************************************************************
95047>>>
95047>>>// This provides a quick and simple way to create an about package for a program.
95047>>>// You need to create a message inside you client area called Activate_About.
95047>>>// Within this message you should send the message DoAbout passing needed
95047>>>// string information.
95047>>>//
95047>>>//       Procedure Activate_About
95047>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95047>>>//       End_Procedure
95047>>>//    where: sTitle =     Name of application. If none provided, uses caption
95047>>>//                        bar title
95047>>>//           sVersion   = Version Line. If none provided, will be blank
95047>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95047>>>//           sAuthor    = Author name, blank if none provided
95047>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95047>>>//                        is used.
95047>>>// It is expected that you will place this in your own object package. For
95047>>>// example an order about package may look like this:
95047>>>//
95047>>>//   // OrderAbout.pkg
95047>>>//   Use StdAbout.pkg
95047>>>//   Procedure Activate_About
95047>>>//      String sTitle sCopyright sVersion sAuthor
95047>>>//      Move "My Order Entry System" to sTitle
95047>>>//      Move "Version 2.1" to sVersion
95047>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95047>>>//      Move "John Smith"  to sAuthor
95047>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95047>>>//   end_procedure
95047>>>//   // end of file.
95047>>>
95047>>>Use DfAbout.pkg
95047>>>
95047>>>// *************************************************************************
95047>>>//  Public message. This is the default message. It is expected that you will
95047>>>//   create your own message to override this
95047>>>// *************************************************************************
95047>>>
95047>>>Procedure Activate_About
95050>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95051>>>End_Procedure
95052>>>
95052>>>// *************************************************************************
95052>>>//  Public message. It is expected that you will send this message (most
95052>>>//  likely from Activate_About. This creates an about object, activates it
95052>>>//  and destroys it when done. It is not exepected that you will augment this.
95052>>>// *************************************************************************
95052>>>// Sample usage:
95052>>>//   The first two params will automatically be filled from the application settings if not provided.
95052>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95052>>>
95052>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95055>>>    Integer hoObj hoMain iArgs
95055>>>    String sValue
95055>>>
95055>>>    // Create object
95055>>>    Object About is an AboutDialog
95057>>>    // Uncomment these two lines if you would like to have a resizable About object.
95057>>>    //            Set Border_Style to Border_Thick
95057>>>    //            Set peAnchors to anAll
95057>>>
95057>>>    // Add checking for the number of arguments passed to avoid runtime errors
95057>>>    // if one of them is not passed. This makes the interface
95057>>>    // more flexible.
95057>>>        Move num_arguments to iArgs
95058>>>
95058>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95058>>>        If (iArgs > 0 and sTitle = "") Begin
95060>>>            Get Main_Window of Desktop to hoMain
95061>>>            If hoMain Begin
95063>>>                Get Label of hoMain to sValue
95064>>>            End
95064>>>>
95064>>>        End
95064>>>>
95064>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95067>>>            Move sTitle to sValue
95068>>>        End
95068>>>>
95068>>>        Else If (iArgs = 0) Begin
95071>>>            Get Main_Window of Desktop to hoMain
95072>>>            If hoMain Begin
95074>>>                Get Label of hoMain to sValue
95075>>>            End
95075>>>>
95075>>>        End
95075>>>>
95075>>>
95075>>>        If (sValue <> "") Begin
95077>>>            Send Add_LineLn sValue
95078>>>        End
95078>>>>
95078>>>        Move "" to sValue
95079>>>
95079>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95079>>>        // For this to work the Project Properties Version must have been set in the Studio.
95079>>>        If (iArgs < 2) Begin
95081>>>            Move "" to sValue
95082>>>        End
95082>>>>
95082>>>        Else Begin
95083>>>            Move sVersion to sValue
95084>>>        End
95084>>>>
95084>>>        Set Version to sValue
95085>>>
95085>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95087>>>            Send Add_LineLn sCopyRight
95088>>>        End
95088>>>>
95088>>>
95088>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95088>>>        // else we do.
95088>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95090>>>            Send Add_Line sAuthor
95091>>>        End
95091>>>>
95091>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95094>>>            Send Add_LineLn sAuthor
95095>>>        End
95095>>>>
95095>>>
95095>>>        // Square bitmaps of 80x80 works best
95095>>>        If (iArgs > 4 and sBitmap <> "") Begin
95097>>>            Set Logo to sBitMap
95098>>>        End
95098>>>>
95098>>>
95098>>>        // Here starts handling of the five optional params:
95098>>>        If (iArgs = 6 and sParam6  <> "") Begin
95100>>>            Send Add_Line sParam6
95101>>>        End
95101>>>>
95101>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95104>>>            Send Add_LineLn sParam6
95105>>>        End
95105>>>>
95105>>>
95105>>>        If (iArgs = 7 and sParam7  <> "") Begin
95107>>>            Send Add_Line sParam7
95108>>>        End
95108>>>>
95108>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95111>>>            Send Add_LineLn sParam7
95112>>>        End
95112>>>>
95112>>>
95112>>>        If (iArgs = 8 and sParam8  <> "") Begin
95114>>>            Send Add_Line sParam8
95115>>>        End
95115>>>>
95115>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95118>>>            Send Add_LineLn sParam8
95119>>>        End
95119>>>>
95119>>>
95119>>>        If (iArgs = 9 and sParam9  <> "") Begin
95121>>>            Send Add_Line sParam9
95122>>>        End
95122>>>>
95122>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95125>>>            Send Add_LineLn sParam9
95126>>>        End
95126>>>>
95126>>>
95126>>>        If (iArgs = 10 and sParam10 <> "") Begin
95128>>>            Send Add_Line sParam10
95129>>>        End
95129>>>>
95129>>>
95129>>>        Move Self to hoObj
95130>>>    End_Object
95131>>>
95131>>>    Send Popup   of hoObj // Popup the about object
95132>>>    Send Destroy of hoObj // When done, it will be destroyed
95133>>>End_Procedure
95134>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95134>>>Use Windows.pkg
95134>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridPromptList.pkg)
95134>>>>>Use Windows.pkg
95134>>>>>Use cCJGrid.pkg
95134>>>>>Use umPromptRelational.pkg
95134>>>>>
95134>>>>>Class cCJGridPromptList is a cCJGrid
95135>>>>>    
95135>>>>>    Procedure Construct_Object
95137>>>>>        Forward Send Construct_Object
95139>>>>>        
95139>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95140>>>>>        Property Boolean Private_pbAutoOrdering True
95141>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95142>>>>>        Property Integer peUpdateMode umPromptValue
95143>>>>>        Property Integer piUpdateColumn 0
95144>>>>>        Property Integer piInitialColumn -1
95145>>>>>        Property String  psSeedValue ''
95146>>>>>        Property Handle phmPromptUpdateCallback 0
95147>>>>>        Property Integer phoInvokingObject
95148>>>>>        
95148>>>>>        Property Boolean pbStoredAutoSeed
95149>>>>>        Property Boolean pbStoredAutoOrdering
95150>>>>>        Property Boolean pbStoredAutoSearch
95151>>>>>        Property Integer peStoredUpdateMode
95152>>>>>        Property Integer piStoredUpdateColumn
95153>>>>>        Property Integer piStoredInitialColumn
95154>>>>>        Property Handle  phmStoredPromptUpdateCallback
95155>>>>>        Property Boolean pbStoredSelectionEnable
95156>>>>>        Property Boolean pbStoredMultipleSelection
95157>>>>>        
95157>>>>>        // internally set by list
95157>>>>>        // these must be set upon closing the list and can be used for manual list updates
95157>>>>>        Property Boolean pbCanceled
95158>>>>>        Property Integer[] pSelectedRows
95159>>>>>        
95159>>>>>        Property Boolean pbNeedsNewOrdering
95160>>>>>        Property Boolean pbRequestSearch
95161>>>>>        Property tGridKeyPair[] pSearchKeys
95162>>>>>        
95162>>>>>        // these properties makes a prompt list a prompt list
95162>>>>>        // and should not be changed.
95162>>>>>        Set pbEditOnKeyNavigation to False
95163>>>>>        Set pbEditOnClick to False
95164>>>>>        Set pbReadOnly to True
95165>>>>>        Set pbFocusSubItems to True
95166>>>>>        
95166>>>>>        // these could maybe be changed
95166>>>>>        Set pbShadeSortColumn to True
95167>>>>>        Set pbHeaderReorders to True
95168>>>>>        Set pbHeaderTogglesDirection to True
95169>>>>>        Set pbHeaderSelectsColumn to True
95170>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95171>>>>>        Set piFocusCellBackColor to clNone
95172>>>>>        Set piFocusCellForeColor to clNone
95173>>>>>        Set piFocusCellRectangleColor to clBlack
95174>>>>>        Set pbUseFocusCellRectangle to False
95175>>>>>        Set pbSelectionEnable to True
95176>>>>>        
95176>>>>>        On_Key kEnter Send Ok
95177>>>>>        On_Key kCancel Send Cancel
95178>>>>>        
95178>>>>>    End_Procedure
95179>>>>>    
95179>>>>>    // reorder list automatically on column change
95179>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95179>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95181>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95182>>>>>        Set pbFocusSubItems to bAutoOrder
95183>>>>>    End_Procedure
95184>>>>>    
95184>>>>>    Function pbAutoOrdering Returns Boolean
95186>>>>>        Boolean bAutoOrder
95186>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95187>>>>>        Function_Return bAutoOrder
95188>>>>>    End_Function
95189>>>>>    
95189>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95189>>>>>    Procedure OnIdle
95191>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95191>>>>>        Handle hoCol
95191>>>>>        Integer iKy1 iKy2 iCol
95191>>>>>        
95191>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95192>>>>>        If bNeedsReorder Begin
95194>>>>>            Get SelectedColumn to iCol
95195>>>>>            If (iCol<>-1) Begin
95197>>>>>                
95197>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95198>>>>>                Set pbHeaderTogglesDirection to False
95199>>>>>                Send HeaderReorder iCol
95200>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95201>>>>>                
95201>>>>>                Set pbNeedsNewOrdering to False
95202>>>>>            End
95202>>>>>>
95202>>>>>        End
95202>>>>>>
95202>>>>>        
95202>>>>>        Get pbRequestSearch to bSearch
95203>>>>>        If bSearch Begin
95205>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95206>>>>>        End
95206>>>>>>
95206>>>>>        
95206>>>>>        Forward Send OnIdle
95208>>>>>    End_Procedure
95209>>>>>    
95209>>>>>    Procedure OnStoreDefaults
95211>>>>>        Integer iVal
95211>>>>>        Boolean bVal
95211>>>>>        
95211>>>>>        Get pbAutoSeed to bVal
95212>>>>>        Set pbStoredAutoSeed to bVal
95213>>>>>        
95213>>>>>        Get pbAutoOrdering to bVal
95214>>>>>        Set pbStoredAutoOrdering to bVal
95215>>>>>        
95215>>>>>        Get pbAutoSearch to bVal
95216>>>>>        Set pbStoredAutoSearch to bVal
95217>>>>>        
95217>>>>>        Get peUpdateMode to iVal
95218>>>>>        Set peStoredUpdateMode to iVal
95219>>>>>        
95219>>>>>        Get piUpdateColumn to iVal
95220>>>>>        Set piStoredUpdateColumn to iVal
95221>>>>>        
95221>>>>>        Get piInitialColumn to iVal
95222>>>>>        Set piStoredInitialColumn to iVal
95223>>>>>        
95223>>>>>        Get phmPromptUpdateCallback to iVal
95224>>>>>        Set phmStoredPromptUpdateCallback to iVal
95225>>>>>        
95225>>>>>        Get pbSelectionEnable to bVal
95226>>>>>        Set pbStoredSelectionEnable to bVal
95227>>>>>        
95227>>>>>        Get pbMultipleSelection to bVal
95228>>>>>        Set pbStoredMultipleSelection to bVal
95229>>>>>        
95229>>>>>    End_Procedure
95230>>>>>    
95230>>>>>    Procedure OnRestoreDefaults
95232>>>>>        Integer iVal
95232>>>>>        Boolean bVal
95232>>>>>        
95232>>>>>        Get pbStoredAutoSeed to bVal
95233>>>>>        Set pbAutoSeed to bVal
95234>>>>>        
95234>>>>>        Get pbStoredAutoOrdering to bVal
95235>>>>>        Set pbAutoOrdering to bVal
95236>>>>>        
95236>>>>>        Get pbStoredAutoSearch to bVal
95237>>>>>        Set pbAutoSearch to bVal
95238>>>>>        
95238>>>>>        Get peStoredUpdateMode to iVal
95239>>>>>        Set peUpdateMode to iVal
95240>>>>>        
95240>>>>>        Get piStoredInitialColumn to iVal
95241>>>>>        Set piInitialColumn to iVal
95242>>>>>        
95242>>>>>        Get phmStoredPromptUpdateCallback to iVal
95243>>>>>        Set phmPromptUpdateCallback to iVal
95244>>>>>        
95244>>>>>        Get pbStoredSelectionEnable to bVal
95245>>>>>        Set pbSelectionEnable to bVal
95246>>>>>        
95246>>>>>        Get pbStoredMultipleSelection to bVal
95247>>>>>        Set pbMultipleSelection to bVal
95248>>>>>        
95248>>>>>    End_Procedure
95249>>>>>    
95249>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95249>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95249>>>>>    // Suitable for augmentation
95249>>>>>    Procedure OnSeedData
95251>>>>>        Integer iUpdateColumn iSortColumn
95251>>>>>        Boolean bSeed bAuto
95251>>>>>        String sValue
95251>>>>>        Handle hoCol
95251>>>>>        
95251>>>>>        Get piUpdateColumn to iUpdateColumn
95252>>>>>        Get psSeedValue to sValue
95253>>>>>        Get pbAutoSeed to bSeed
95254>>>>>        Get piSortColumn to iSortColumn
95255>>>>>        Get pbAutoOrdering to bAuto
95256>>>>>        // if not yet sorted and this is auto ordering we will
95256>>>>>        // sort the data for the search column. We do this to make the
95256>>>>>        // column search GE logic work properly.
95256>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95258>>>>>            Get ColumnObject iUpdateColumn to hoCol
95259>>>>>            Send SortGridByColumn hoCol False
95260>>>>>        End
95260>>>>>>
95260>>>>>        
95260>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95262>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95263>>>>>        End
95263>>>>>>
95263>>>>>        Else Begin
95264>>>>>            Send MovetoFirstRow
95265>>>>>        End
95265>>>>>>
95265>>>>>        
95265>>>>>    End_Procedure
95266>>>>>    
95266>>>>>    Procedure OnMoveValueOutByValue
95268>>>>>        String sValue
95268>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95268>>>>>        Integer iRow iCol
95268>>>>>        Integer[] SelRowsIndexes
95269>>>>>        
95269>>>>>        Get phoInvokingObject to hoInvokingObject
95270>>>>>        Get pSelectedRows to SelRowsIndexes
95271>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95273>>>>>            Get piUpdateColumn to iCol
95274>>>>>            Get ColumnObject iCol to hoCol
95275>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95276>>>>>            Set Value of hoInvokingObject to sValue
95277>>>>>            Set Item_Changed_State of hoInvokingObject to True
95278>>>>>        End
95278>>>>>>
95278>>>>>    End_Procedure
95279>>>>>    
95279>>>>>    Procedure OnMoveValueOutByCustom
95281>>>>>    End_Procedure
95282>>>>>    
95282>>>>>    // augment to popup a search window when allowed
95282>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95284>>>>>        Boolean bSubFocus bAutoSearch bChar
95284>>>>>        Integer iVal
95284>>>>>        
95284>>>>>        Get pbFocusSubItems to bSubFocus
95285>>>>>        Get pbAutoSearch to bAutoSearch
95286>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95288>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95290>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95292>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95293>>>>>                Move (iVal<>0) to bChar
95294>>>>>            End
95294>>>>>>
95294>>>>>            If bChar Begin
95296>>>>>                // this can get called multiple times before a search dialog pops up
95296>>>>>                Send AddToSearchKeys llKeyCode llShift
95297>>>>>            End
95297>>>>>>
95297>>>>>        End
95297>>>>>>
95297>>>>>    End_Procedure
95298>>>>>    
95298>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95300>>>>>        Boolean bAutoSearch
95300>>>>>        Integer iKeyCode iShiftCode
95300>>>>>        Get pbAutoSearch to bAutoSearch
95301>>>>>        If bAutoSearch Begin
95303>>>>>            // this can get called multiple times before a search dialog pops up
95303>>>>>            Get piLastKey to iKeyCode
95304>>>>>            Get piLastKey2 to iShiftCode
95305>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95306>>>>>        End
95306>>>>>>
95306>>>>>        Move True to llCancel
95307>>>>>    End_Procedure
95308>>>>>    
95308>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95310>>>>>        Send ClearSearchRequest // kill any deferred search popup
95311>>>>>        Forward Send OnComRowDblClick llRow llItem
95313>>>>>    End_Procedure
95314>>>>>    
95314>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95316>>>>>        Send Ok
95317>>>>>    End_Procedure
95318>>>>>    
95318>>>>>    
95318>>>>>    // we don't want a menu for prompt lists
95318>>>>>    Function CreateContextMenu Returns Handle
95320>>>>>        Function_Return 0
95321>>>>>    End_Function
95322>>>>>    
95322>>>>>    // if we use auto-ordering, change the order when the column changes
95322>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95324>>>>>        Boolean bAutoOrder
95324>>>>>        Forward Send ColumnChanged iOld iNew
95326>>>>>        Get pbAutoOrdering to bAutoOrder
95327>>>>>        If bAutoOrder Begin
95329>>>>>            // will be reordered in idle event
95329>>>>>            Set pbNeedsNewOrdering to True
95330>>>>>        End
95330>>>>>>
95330>>>>>    End_Procedure
95331>>>>>    
95331>>>>>    
95331>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95333>>>>>        Integer eMode
95333>>>>>        Integer[] SelRowsIndexes
95334>>>>>        Set pbCanceled to True // assume cancel unless changed
95335>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95336>>>>>        Get peUpdateMode to eMode
95337>>>>>        If (eMode<>umPromptNonInvoking) Begin
95339>>>>>            Send OnStoreDefaults
95340>>>>>        End
95340>>>>>>
95340>>>>>        Send InitializePromptList
95341>>>>>        Forward Send Add_Focus hoParent
95343>>>>>        Send LoadData
95344>>>>>        Set psSeedValue to ""
95345>>>>>    End_Procedure
95346>>>>>    
95346>>>>>    // called before the list is activated.
95346>>>>>    Procedure InitializePromptList
95348>>>>>        Integer hoInvokingObject
95348>>>>>        Boolean bAutoColumn bAutoSeed
95348>>>>>        Integer i iOldMode eUpdateMode
95348>>>>>        String sValue
95348>>>>>        
95348>>>>>        Get peUpdateMode to eUpdateMode
95349>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95351>>>>>            Get Focus of Desktop to hoInvokingObject
95352>>>>>            If (hoInvokingObject<=Desktop) Begin
95354>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95355>>>>>>
95355>>>>>                Procedure_Return
95356>>>>>            End
95356>>>>>>
95356>>>>>            
95356>>>>>            Set phoInvokingObject to hoInvokingObject
95357>>>>>            
95357>>>>>            Send Prompt_Callback to hoInvokingObject Self
95358>>>>>            Get peUpdateMode to eUpdateMode
95359>>>>>        End
95359>>>>>>
95359>>>>>        
95359>>>>>        Send ClearSearchRequest // clear the search keys
95360>>>>>        Set pbNeedsNewOrdering to False
95361>>>>>        
95361>>>>>        Get pbAutoSeed to bAutoSeed
95362>>>>>        
95362>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
95364>>>>>            Get Value of hoInvokingObject to sValue
95365>>>>>            Set psSeedValue to sValue
95366>>>>>        End
95366>>>>>>
95366>>>>>        
95366>>>>>    End_Procedure
95367>>>>>    
95367>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
95367>>>>>    Procedure LoadData
95369>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
95369>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
95369>>>>>        Integer eUpdateMode
95369>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
95369>>>>>        
95369>>>>>        Get phoDataSource to hoDataSource
95370>>>>>        Get peUpdateMode to eUpdateMode
95371>>>>>        Get phoInvokingObject to hoInvokingObject
95372>>>>>        Get pbAutoSeed to bAutoSeed
95373>>>>>        Get piInitialColumn to iInitialColumn
95374>>>>>        Get piUpdateColumn to iUpdateColumn
95375>>>>>        Get RowCount of hoDataSource to iRows
95376>>>>>        
95376>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
95376>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
95376>>>>>        If (iInitialColumn=-1) Begin
95378>>>>>            Move iUpdateColumn to iInitialColumn
95379>>>>>        End
95379>>>>>>
95379>>>>>        If (iInitialColumn>=0) Begin
95381>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
95382>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
95383>>>>>        End
95383>>>>>>
95383>>>>>        Send OnSeedData // find a good starting place for the row
95384>>>>>        Get pbFocusSubItems to bSubFocus
95385>>>>>        If bSubFocus Begin
95387>>>>>            // if column focus, which is normal, go to initialcolumn
95387>>>>>            If hoInitialColumn Begin
95389>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
95390>>>>>            End
95390>>>>>>
95390>>>>>            Else Begin
95391>>>>>                Send MoveToFirstEnterableColumn
95392>>>>>            End
95392>>>>>>
95392>>>>>        End
95392>>>>>>
95392>>>>>        
95392>>>>>    End_Procedure
95393>>>>>    
95393>>>>>    // This is only called in a successful close
95393>>>>>    Procedure ClosePromptList
95395>>>>>        Handle hoDataSource hoInvokingObject
95395>>>>>        Handle hmCallBack
95395>>>>>        Integer iRow eUpdateMode
95395>>>>>        Integer[] SelRowsIndexes
95396>>>>>        
95396>>>>>        Get phoDataSource to hoDataSource
95397>>>>>        Get phoInvokingObject to hoInvokingObject
95398>>>>>        
95398>>>>>        If (pbMultipleSelection(Self)) Begin
95400>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
95401>>>>>        End
95401>>>>>>
95401>>>>>        Else Begin
95402>>>>>            Get SelectedRow of hoDataSource to iRow
95403>>>>>            If (iRow<>-1) Begin
95405>>>>>                Move iRow to SelRowsIndexes[0]
95406>>>>>            End
95406>>>>>>
95406>>>>>        End
95406>>>>>>
95406>>>>>        
95406>>>>>        Set pbCanceled to False
95407>>>>>        Set pSelectedRows to SelRowsIndexes
95408>>>>>        
95408>>>>>        Get peUpdateMode to eUpdateMode
95409>>>>>        // if non-invoking there is by definition, no move value out
95409>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95411>>>>>            
95411>>>>>            If (eUpdateMode=umPromptValue) Begin
95413>>>>>                Send OnMoveValueOutByValue
95414>>>>>            End
95414>>>>>>
95414>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
95417>>>>>                Send OnMoveValueOutByCustom
95418>>>>>            End
95418>>>>>>
95418>>>>>            Get phmPromptUpdateCallback to hmCallBack
95419>>>>>            If hmCallBack Begin
95421>>>>>                Send hmCallBack of hoInvokingObject Self
95422>>>>>            End
95422>>>>>>
95422>>>>>        End
95422>>>>>>
95422>>>>>        
95422>>>>>        Send Close_Panel
95423>>>>>    End_Procedure
95424>>>>>    
95424>>>>>    // augment to send OnRestoreDefaults.
95424>>>>>    Procedure Release_Focus
95426>>>>>        Integer eUpdateMode
95426>>>>>        Get peUpdateMode to eUpdateMode
95427>>>>>        Forward Send Release_Focus
95429>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95431>>>>>            Send OnRestoreDefaults
95432>>>>>        End
95432>>>>>>
95432>>>>>    End_Procedure
95433>>>>>    
95433>>>>>    Function SelectedRowIds Returns RowID[]
95435>>>>>        RowID[] SelectedRowids
95436>>>>>        Integer[] SelectedRows
95437>>>>>        Integer i iRows
95437>>>>>        Handle hoDataSource
95437>>>>>        Get phoDataSource to hoDataSource
95438>>>>>        Get pSelectedRows to SelectedRows
95439>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95440>>>>>        For i from 0 to (iRows-1)
95446>>>>>>
95446>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
95447>>>>>        Loop
95448>>>>>>
95448>>>>>        Function_Return SelectedRowids
95449>>>>>    End_Function
95450>>>>>    
95450>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
95452>>>>>        String[] SelectedValues
95453>>>>>        Integer[] SelectedRows
95454>>>>>        Integer i iRows
95454>>>>>        Handle hoCol
95454>>>>>        Get ColumnObject iCol to hoCol
95455>>>>>        Get pSelectedRows to SelectedRows
95456>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
95457>>>>>        For i from 0 to (iRows-1)
95463>>>>>>
95463>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
95464>>>>>        Loop
95465>>>>>>
95465>>>>>        Function_Return SelectedValues
95466>>>>>    End_Function
95467>>>>>    
95467>>>>>    Procedure Ok Returns Integer
95469>>>>>        Send ClosePromptList
95470>>>>>    End_Procedure
95471>>>>>    
95471>>>>>    Procedure Cancel Returns Integer
95473>>>>>        Send Close_Panel
95474>>>>>    End_Procedure
95475>>>>>    
95475>>>>>    Procedure Search
95477>>>>>        Send Activate // give focus back to list so focus things are correct
95478>>>>>        Send Request_Search 0 0
95479>>>>>    End_Procedure
95480>>>>>    
95480>>>>>    // do a search using the current keys in the search key buffer for the sort column.
95480>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
95480>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
95480>>>>>    Procedure Request_SearchEx
95482>>>>>        tGridKeyPair[] Keys
95482>>>>>        tGridKeyPair[] Keys
95483>>>>>        Integer iCol
95483>>>>>        Handle hoCol hoSearchDialog
95483>>>>>        Boolean bOk
95483>>>>>        String sValue
95483>>>>>        
95483>>>>>        Get piSortColumn to iCol
95484>>>>>        If (iCol<>-1) Begin
95486>>>>>            Get ColumnObject iCol to hoCol
95487>>>>>            Get pSearchKeys to Keys
95488>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
95489>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
95490>>>>>            If bOk Begin
95492>>>>>                Send RequestFindColumnValue iCol sValue True 0
95493>>>>>            End
95493>>>>>>
95493>>>>>            Send Destroy of hoSearchDialog
95494>>>>>        End
95494>>>>>>
95494>>>>>        Send ClearSearchRequest // clear the search keys
95495>>>>>    End_Procedure
95496>>>>>    
95496>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
95496>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
95498>>>>>        tGridKeyPair[] Keys
95498>>>>>        tGridKeyPair[] Keys
95499>>>>>        tGridKeyPair KeyPair
95499>>>>>        tGridKeyPair KeyPair
95499>>>>>        Set pbRequestSearch to True
95500>>>>>        Move iKeyCode to KeyPair.KeyCode
95501>>>>>        Move iShiftCode to KeyPair.ShiftCode
95502>>>>>        Get pSearchKeys to Keys
95503>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
95504>>>>>        Set pSearchKeys to Keys
95505>>>>>    End_Procedure
95506>>>>>    
95506>>>>>    Procedure ClearSearchRequest
95508>>>>>        tGridKeyPair[] SearchKeys
95508>>>>>        tGridKeyPair[] SearchKeys
95509>>>>>        Set pSearchKeys to SearchKeys
95510>>>>>        Set pbRequestSearch to False
95511>>>>>    End_Procedure
95512>>>>>    
95512>>>>>End_Class
95513>>>>>
95513>>>Use cDbUpdateFunctionLibrary.pkg
95513>>>Use MSSqldrv.pkg
95513>>>Use db2_drv.pkg
95513>>>Use odbc_drv.pkg
95513>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\cRDCModalPanel.pkg)
95513>>>>>//****************************************************************************
95513>>>>>// $Module type: Class
95513>>>>>// $Module name: cRDCModalPanel
95513>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
95513>>>>>// Created     : 2014-03-17 @ 12:33
95513>>>>>//
95513>>>>>// Description :
95513>>>>>//
95513>>>>>// $Rev History:
95513>>>>>//    2014-03-17  Module header created
95513>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95513>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95513>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95513>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95513>>>>>// in the help folder for more details.
95513>>>>>//
95513>>>>>//****************************************************************************
95513>>>>>Use Windows.pkg
95513>>>>>Use cCJCommandBarSystem.pkg   
95513>>>>>Use cCJSkinFramework.pkg
95513>>>>>
95513>>>>>Class cRDCModalPanel is a ModalPanel
95514>>>>>
95514>>>>>    Procedure Construct_Object
95516>>>>>        Forward Send Construct_Object
95518>>>>>
95518>>>>>        Set Maximize_Icon to True
95519>>>>>        Set Minimize_Icon to False
95520>>>>>        Set Border_Style to Border_Thick
95521>>>>>        Set Locate_Mode to Center_On_Parent
95522>>>>>
95522>>>>>        Property String Private_Icon
95523>>>>>        Property Handle phoDialogCommandbar
95524>>>>>    End_Procedure
95525>>>>>
95525>>>>>    Procedure Set Icon String sIcon
95527>>>>>        Forward Set Icon to sIcon
95529>>>>>        Set Private_Icon to sIcon
95530>>>>>    End_Procedure
95531>>>>>
95531>>>>>    Function Icon Returns String
95533>>>>>        String sIcon
95533>>>>>        Get Private_Icon to sIcon
95534>>>>>        Function_Return sIcon
95535>>>>>    End_Function
95536>>>>>
95536>>>>>    Procedure Page Integer iPageObject
95538>>>>>        String sIcon
95538>>>>>        Integer hWnd
95538>>>>>        
95538>>>>>        Forward Send Page iPageObject
95540>>>>>        Get Private_Icon to sIcon
95541>>>>>        If (sIcon <> "") Begin
95543>>>>>            Set Icon to sIcon
95544>>>>>        End
95544>>>>>>
95544>>>>>
95544>>>>>        Get Window_Handle to hWnd
95545>>>>>
95545>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
95547>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
95548>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
95549>>>>>        End
95549>>>>>>
95549>>>>>    End_Procedure
95550>>>>>
95550>>>>>    // Put a status bar at the bottom of the panel, which makes
95550>>>>>    // status_help work and puts a gripper in the lower right corner.
95550>>>>>    Procedure End_Construct_Object
95552>>>>>        Integer iStyle iSize iOffset
95552>>>>>
95552>>>>>        Forward Send End_Construct_Object
95554>>>>>
95554>>>>>        Get Border_Style to iStyle
95555>>>>>        Move 8 to iOffset
95556>>>>>        If (iStyle = Border_Thick) Begin
95558>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
95560>>>>>                Object oStatusBar is a cCJStatusBar
95562>>>>>                    Set phoDialogCommandbar to Self
95563>>>>>                    Object oStatusIdle is a cCJStatusBarPane
95565>>>>>                        Set piId to sbpIDIdlePane
95566>>>>>                        Set pbStyleStretch to True
95567>>>>>                    End_Object
95568>>>>>                End_Object
95569>>>>>            End_Object
95570>>>>>            Get Size to iSize
95571>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
95572>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
95573>>>>>        End
95573>>>>>>
95573>>>>>
95573>>>>>    End_Procedure
95574>>>>>
95574>>>>>    Procedure Popup
95576>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
95577>>>>>        Forward Send Popup
95579>>>>>    End_Procedure
95580>>>>>
95580>>>>>End_Class
95581>>>
95581>>>Object oDatabaseSelection_sl is a cRDCModalPanel
95583>>>    Set Label to "SQL Database Selection"
95584>>>    Set Size to 119 183
95585>>>    Set piMinSize to 89 170
95586>>>    Set Location to 2 2
95587>>>    Set Border_Style to Border_Thick
95588>>>    Set Icon to "DatabaseLookup1.ico"
95589>>>
95589>>>    Property String[] psTheData
95591>>>
95591>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
95593>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
95595>>>        End_Object
95596>>>    End
95596>>>>
95596>>>
95596>>>    Object oSelList is a cCJGridPromptList
95598>>>        Set Size to 89 167
95599>>>        Set Location to 6 6
95600>>>        Set peAnchors to anAll
95601>>>        Set pbAllowColumnRemove to False
95602>>>        Set pbUseAlternateRowBackgroundColor to True
95603>>>        Set pbGrayIfDisable to False
95604>>>        Set pbHeaderReorders to False
95605>>>        Set pbHeaderSelectsColumn to False
95606>>>        Set pbHeaderTogglesDirection to False
95607>>>        Set pbShadeSortColumn to False
95608>>>        Set piFocusCellBackColor to clDkGray
95609>>>
95609>>>        Object oName is a cCJGridColumn
95611>>>            Set piWidth to 334
95612>>>            Set psCaption to "Database Name"
95613>>>        End_Object
95614>>>
95614>>>        Procedure Activating
95617>>>            tDataSourceRow[] MyData
95617>>>            tDataSourceRow[] MyData
95618>>>            Handle hoDataSource
95618>>>            String[] sTheData
95619>>>            Integer iCount iSize
95619>>>
95619>>>            Send Cursor_Wait of Cursor_Control
95620>>>            Forward Send Activating
95622>>>
95622>>>            Get psTheData to sTheData
95623>>>            Move (SizeOfArray(sTheData)) to iSize
95624>>>            Decrement iSize
95625>>>            For iCount from 0 to iSize
95631>>>>
95631>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
95632>>>            Loop
95633>>>>
95633>>>
95633>>>            Get phoDataSource to hoDataSource
95634>>>            Send InitializeData of hoDataSource MyData
95635>>>            Send Cursor_Ready of Cursor_Control
95636>>>        End_Procedure
95637>>>
95637>>>    End_Object
95638>>>
95638>>>    Object oOK_Btn is a Button
95640>>>        Set Size to 14 50
95641>>>        Set Label    to "&OK"
95642>>>        Set Location to 98 68
95643>>>        Set peAnchors To anBottomRight
95644>>>
95644>>>        Procedure OnClick
95647>>>            Send Ok of oSelList
95648>>>        End_Procedure
95649>>>
95649>>>    End_Object
95650>>>
95650>>>    Object oCancel_Btn is a Button
95652>>>        Set Size to 14 50
95653>>>        Set Label    to "&Cancel"
95654>>>        Set Location to 98 123
95655>>>        Set peAnchors to anBottomRight
95656>>>
95656>>>        Procedure OnClick
95659>>>            Send Close_Panel
95660>>>        End_Procedure
95661>>>
95661>>>    End_Object
95662>>>
95662>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95663>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95664>>>End_Object
95665>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
95665>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
95665>>>Use Windows.pkg
95665>>>Use vWin32fh.pkg
95665>>>
95665>>>Object oSQLDatabaseBackup_dg is a ModalPanel
95667>>>    Set Size to 104 298
95668>>>    Set Label to "SQL Database Backup"
95669>>>    Set piMinSize to 89 211
95670>>>    Set Location to 2 4
95671>>>    Set Border_Style To Border_Thick
95672>>>
95672>>>    Property Boolean pbOK False
95674>>>    Property String  psDatabase
95676>>>    Property String  psPath
95678>>>    Property String  psBackupName
95680>>>
95680>>>    Object oDatabase_fm is a Form
95682>>>        Set Size to 13 204
95683>>>        Set Location to 14 71
95684>>>        Set Label_Justification_Mode to JMode_Right
95685>>>        Set Label_Col_Offset to 2
95686>>>        Set Label to "Database Name"
95687>>>        Set Enabled_State to False
95688>>>        Set peAnchors to anTopLeftRight
95689>>>
95689>>>        Procedure Page Integer iPageObject
95692>>>            String sValue
95692>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
95693>>>            Set Value to sValue
95694>>>            Set psDatabase to sValue
95695>>>            Forward Send Page iPageObject
95697>>>        End_Procedure
95698>>>
95698>>>    End_Object
95699>>>
95699>>>    Object oBackupName_fm is a Form
95701>>>        Set Size to 13 204
95702>>>        Set Location to 29 71
95703>>>        Set Label_Justification_Mode to JMode_Right
95704>>>        Set Label_Col_Offset to 2
95705>>>        Set Label to "Backup Name"
95706>>>        Set peAnchors to anTopLeftRight
95707>>>
95707>>>        Procedure Page Integer iPageObject
95710>>>            String sValue
95710>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
95711>>>            Set Value to sValue
95712>>>            Forward Send Page iPageObject
95714>>>        End_Procedure
95715>>>
95715>>>        Procedure OnChange
95718>>>            String sValue
95718>>>            Get Value to sValue
95719>>>            Set psBackupName to sValue
95720>>>        End_Procedure
95721>>>
95721>>>    End_Object
95722>>>
95722>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
95724>>>        Set Size to 10 50
95725>>>        Set Location to 50 71
95726>>>        Set Label to "Use Default SQL Backup Folder"
95727>>>        Set Checked_State to True
95728>>>
95728>>>        Procedure OnChange
95731>>>            Boolean bChecked
95731>>>            Get Checked_State to bChecked
95732>>>            Set Enabled_State of oPath_fm to (bChecked = False)
95733>>>        End_Procedure
95734>>>
95734>>>    End_Object
95735>>>
95735>>>    Object oPath_fm is a Form
95737>>>        Set Size to 13 204
95738>>>        Set Location to 62 71
95739>>>        Set Label_Justification_Mode to JMode_Right
95740>>>        Set Label_Col_Offset to 2
95741>>>        Set Label to "Path"
95742>>>        Set Prompt_Button_Mode to PB_PromptOn
95743>>>        Set peAnchors to anTopLeftRight
95744>>>        Set Enabled_State to False
95745>>>
95745>>>        Procedure Page Integer iPageObject
95748>>>            String sValue
95748>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
95749>>>            Get vFolderFormat sValue to sValue
95750>>>            Move (sValue + "Backup") to sValue
95751>>>            Set Value to sValue
95752>>>            Forward Send Page iPageObject
95754>>>        End_Procedure
95755>>>
95755>>>        Procedure Prompt
95758>>>            String sPath sFileMask sRetval
95758>>>
95758>>>            Get Value to sPath
95759>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
95760>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
95761>>>            If (sRetval <> "") Begin
95763>>>                Get ParseFolderName sRetval to sPath
95764>>>                If (Right(sPath, 1) ="\") Begin
95766>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
95767>>>                End
95767>>>>
95767>>>                Set Value to sPath
95768>>>            End
95768>>>>
95768>>>        End_Procedure
95769>>>
95769>>>        Procedure OnChange
95772>>>            String sValue
95772>>>            Get Value to sValue
95773>>>            Set psPath to sValue
95774>>>        End_Procedure
95775>>>
95775>>>    End_Object
95776>>>
95776>>>    Object oOK_Btn is a Button
95778>>>        Set Label    to "&OK"
95779>>>        Set Location to 81 169
95780>>>        Set peAnchors to anBottomRight
95781>>>
95781>>>        Procedure OnClick
95784>>>            Set pbOK to True
95785>>>            Send Close_Panel
95786>>>        End_Procedure
95787>>>
95787>>>    End_Object
95788>>>
95788>>>    Object oCancel_Btn is a Button
95790>>>        Set Label    to "&Cancel"
95791>>>        Set Location to 81 224
95792>>>        Set peAnchors to anBottomRight
95793>>>
95793>>>        Procedure OnClick
95796>>>            Set pbOK to False
95797>>>            Send Close_Panel
95798>>>        End_Procedure
95799>>>
95799>>>    End_Object
95800>>>
95800>>>    Object oButton1 is a Button
95802>>>        Set Size to 14 96
95803>>>        Set Location to 80 32
95804>>>        Set Label to "Enum table types"
95805>>>
95805>>>        Procedure OnClick
95808>>>            String sDriverID
95808>>>            tSQLConnection SQLConnection
95808>>>            tSQLConnection SQLConnection
95808>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
95809>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
95810>>>        End_Procedure
95811>>>
95811>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
95814>>>            Handle hoCLIHandler
95814>>>            Integer iNumTables iTableCount
95814>>>
95814>>>            Get Create U_cCLIHandler to hoCLIhandler
95815>>>            If (hoCLIHandler > 0) Begin
95817>>>                Set psDriverID of hoCLIHandler to sDriver
95818>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
95819>>>                For iTableCount from 1 to iNumTables
95825>>>>
95825>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
95827>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
95829>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
95831>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
95833>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
95833>>>//                    For iColumnCount from 1 to iNumColumns
95833>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
95833>>>//                    Loop
95833>>>                    Showln
95834>>>                Loop
95835>>>>
95835>>>                Send Destroy of hoCLIHandler
95836>>>            End
95836>>>>
95836>>>        End_Procedure
95837>>>
95837>>>    End_Object
95838>>>
95838>>>    Procedure Page Integer iPageObject
95841>>>        Set Icon to "DbBackup1.ico"
95842>>>        Forward Send Page iPageObject
95844>>>    End_Procedure
95845>>>
95845>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
95846>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
95847>>>
95847>>>End_Object
95848>>>
95848>>>// *** General purpose access method for this dialog ***
95848>>>Function MakeSQLDatabaseBackup Returns Boolean
95851>>>    Handle ho
95851>>>    Boolean bOK bDefault
95851>>>    String sDatabase sPath sBackupName
95851>>>
95851>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
95852>>>    Set pbOK of ho to False
95853>>>    Send Popup of ho
95854>>>
95854>>>    Get pbOk of ho to bOK
95855>>>    If (bOK = True) Begin
95857>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
95858>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
95859>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
95860>>>        If (bDefault = False) Begin
95862>>>            Get Value of (oPath_fm(ho)) to sPath
95863>>>        End
95863>>>>
95863>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
95864>>>    End
95864>>>>
95864>>>
95864>>>    Function_Return bOK
95865>>>End_Function
95866>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
95866>>>Use Windows.pkg
95866>>>Use DFClient.pkg
95866>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cDbScrollingContainer.pkg)
95866>>>>>// Provides support for db aware scrolling containers.
95866>>>>>// Scrolling containers is provided by creating two objects,
95866>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
95866>>>>>// The host has no public interface, you just drop the object. It should have only one child object
95866>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
95866>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
95866>>>>>
95866>>>>>Use DFClient.pkg
95866>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cScrollingContainerMixin.pkg)
95866>>>>>>>// Mixin classes for scrolling container support:
95866>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
95866>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
95866>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
95866>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
95866>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
95866>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
95866>>>>>>>
95866>>>>>>>Use Windows.pkg
95866>>>>>>>Use Winuser.pkg
95866>>>>>>>Use tWinStructs.pkg
95866>>>>>>>
95866>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
95866>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
95866>>>>>>>// support for the scrolling client area mixin object.
95866>>>>>>>
95866>>>>>>>Class cScrollingClientAreaMixin is a Mixin
95867>>>>>>>    
95867>>>>>>>    Procedure Define_cScrollingClientAreaMixin
95869>>>>>>>        
95869>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
95870>>>>>>>        Set Border_Style to Border_None
95871>>>>>>>        
95871>>>>>>>        Property Boolean pbAutoScroll True
95872>>>>>>>        Property Boolean pbAutoScrollFocus True
95873>>>>>>>        Property Integer piAutoScrollMarginX 5
95874>>>>>>>        Property Integer piAutoScrollMarginY 5
95875>>>>>>>        Property Integer piAutoScrollMinX 0
95876>>>>>>>        Property Integer piAutoScrollMinY 0
95877>>>>>>>        Property Boolean pbShowDisabledScrollBar False
95878>>>>>>>        
95878>>>>>>>        
95878>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
95879>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
95880>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
95881>>>>>>>        // keeps track of scrolling
95881>>>>>>>        Property Integer piCurrentVertScrolled 0
95882>>>>>>>        Property Integer piCurrentHorzScrolled 0
95883>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
95884>>>>>>>        Delegate Set phoScrollingClientArea to Self
95886>>>>>>>        
95886>>>>>>>        // set this true to make this a tabbed workspace view (design time)
95886>>>>>>>        Property Boolean pbTabWorkspaceView False
95887>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
95887>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
95888>>>>>>>    End_Procedure
95889>>>>>>>    
95889>>>>>>>    // low level event sent from windows.
95889>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
95891>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
95891>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
95892>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
95893>>>>>>>        If (wParam<0) Begin
95895>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
95896>>>>>>>        End
95896>>>>>>>>
95896>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
95897>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
95898>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
95898>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
95899>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
95900>>>>>>>        // If we have enough Clicks send OnMouseWheel
95900>>>>>>>        If (iClicks<>0) Begin
95902>>>>>>>            Send OnMouseWheel iClicks iKeys
95903>>>>>>>        End
95903>>>>>>>>
95903>>>>>>>        // tell windows that we've handled the event.
95903>>>>>>>        Set Windows_Override_State to True
95904>>>>>>>    End_Procedure
95905>>>>>>>    
95905>>>>>>>    
95905>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
95905>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
95907>>>>>>>        Integer iLineScrollUnit
95907>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
95908>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
95909>>>>>>>    End_Procedure
95910>>>>>>>    
95910>>>>>>>    // should be sent by WM_VSCROLL
95910>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
95912>>>>>>>        Boolean bOk
95912>>>>>>>        tWinScrollInfo ScrollInfo
95912>>>>>>>        tWinScrollInfo ScrollInfo
95912>>>>>>>        Integer iLineScrollUnit
95912>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
95913>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
95914>>>>>>>        If bOk Begin
95916>>>>>>>            
95916>>>>>>>            Case Begin
95916>>>>>>>                Case (iType=SB_PAGEDOWN)
95918>>>>>>>                    Send VScroll ScrollInfo.nPage
95919>>>>>>>                    Case Break
95920>>>>>>>                
95920>>>>>>>                Case (iType=SB_PAGEUP)
95923>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
95924>>>>>>>                    Case Break
95925>>>>>>>                
95925>>>>>>>                Case (iType=SB_LINEDOWN)
95928>>>>>>>                    Send VScroll iLineScrollUnit
95929>>>>>>>                    Case Break
95930>>>>>>>                
95930>>>>>>>                Case (iType=SB_LINEUP)
95933>>>>>>>                    Send VScroll (-iLineScrollUnit)
95934>>>>>>>                    Case Break
95935>>>>>>>                
95935>>>>>>>                Case (iType=SB_BOTTOM)
95938>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
95939>>>>>>>                    Case Break
95940>>>>>>>                
95940>>>>>>>                Case (iType=SB_Top)
95943>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
95944>>>>>>>                    Case Break
95945>>>>>>>                
95945>>>>>>>                Case (iType=SB_THUMBPOSITION)
95948>>>>>>>                    Case Break
95949>>>>>>>                
95949>>>>>>>                Case (iType=SB_THUMBTRACK)
95952>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
95953>>>>>>>                    Case Break
95954>>>>>>>            Case End
95954>>>>>>>        End
95954>>>>>>>>
95954>>>>>>>    End_Procedure
95955>>>>>>>    
95955>>>>>>>    // should be sent by WM_HSCROLL
95955>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
95957>>>>>>>        Boolean bOk
95957>>>>>>>        tWinScrollInfo ScrollInfo
95957>>>>>>>        tWinScrollInfo ScrollInfo
95957>>>>>>>        Integer iLineScrollUnit
95957>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
95958>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
95959>>>>>>>        If bOk Begin
95961>>>>>>>            
95961>>>>>>>            Case Begin
95961>>>>>>>                Case (iType=SB_PAGEDOWN)
95963>>>>>>>                    Send hScroll ScrollInfo.nPage
95964>>>>>>>                    Case Break
95965>>>>>>>                
95965>>>>>>>                Case (iType=SB_PAGEUP)
95968>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
95969>>>>>>>                    Case Break
95970>>>>>>>                
95970>>>>>>>                Case (iType=SB_LINEDOWN)
95973>>>>>>>                    Send hScroll iLineScrollUnit
95974>>>>>>>                    Case Break
95975>>>>>>>                
95975>>>>>>>                Case (iType=SB_LINEUP)
95978>>>>>>>                    Send hScroll (-iLineScrollUnit)
95979>>>>>>>                    Case Break
95980>>>>>>>                
95980>>>>>>>                Case (iType=SB_BOTTOM)
95983>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
95984>>>>>>>                    Case Break
95985>>>>>>>                
95985>>>>>>>                Case (iType=SB_Top)
95988>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
95989>>>>>>>                    Case Break
95990>>>>>>>                
95990>>>>>>>                Case (iType=SB_THUMBPOSITION)
95993>>>>>>>                    Case Break
95994>>>>>>>                
95994>>>>>>>                Case (iType=SB_THUMBTRACK)
95997>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
95998>>>>>>>                    Case Break
95999>>>>>>>            Case End
95999>>>>>>>        End
95999>>>>>>>>
95999>>>>>>>    End_Procedure
96000>>>>>>>    
96000>>>>>>>    
96000>>>>>>>    // this calls SetScrollInfo with proper info
96000>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96002>>>>>>>        tWinScrollInfo ScrollInfo
96002>>>>>>>        tWinScrollInfo ScrollInfo
96002>>>>>>>        Integer iVoid
96002>>>>>>>        Handle hWnd
96002>>>>>>>        Boolean bShow
96002>>>>>>>        
96002>>>>>>>        Delegate Get Window_Handle to hWnd
96004>>>>>>>        If (hWnd <> 0) Begin
96006>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96007>>>>>>>            
96007>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96008>>>>>>>            Get pbShowDisabledScrollBar to bShow
96009>>>>>>>            If bShow Begin
96011>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96012>>>>>>>            End
96012>>>>>>>>
96012>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96013>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96014>>>>>>>            Move iPageSize to ScrollInfo.nPage
96015>>>>>>>            Move 0 to ScrollInfo.nPos
96016>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96017>>>>>>>            
96017>>>>>>>        End
96017>>>>>>>>
96017>>>>>>>    End_Procedure
96018>>>>>>>    
96018>>>>>>>    // this wraps GetScrollInfo
96018>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96020>>>>>>>        Boolean bOk
96020>>>>>>>        Handle hWnd
96020>>>>>>>        
96020>>>>>>>        Delegate Get Window_Handle to hWnd
96022>>>>>>>        If (hWnd <> 0) Begin
96024>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96025>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96026>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96027>>>>>>>        End
96027>>>>>>>>
96027>>>>>>>        Function_Return bOk
96028>>>>>>>    End_Function
96029>>>>>>>    
96029>>>>>>>    // this wraps SetScrollPos
96029>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96031>>>>>>>        Integer iVoid
96031>>>>>>>        Handle hWnd
96031>>>>>>>        
96031>>>>>>>        Delegate Get Window_Handle to hWnd
96033>>>>>>>        If (hWnd <> 0) Begin
96035>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96036>>>>>>>        End
96036>>>>>>>>
96036>>>>>>>    End_Procedure
96037>>>>>>>    
96037>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96037>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96037>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96039>>>>>>>        Send ScrollClientArea
96040>>>>>>>    End_Procedure
96041>>>>>>>    
96041>>>>>>>    // augment to handle the scrolling area initialization.
96041>>>>>>>    Procedure Add_Focus Handle hoParent
96043>>>>>>>        Forward Send Add_Focus hoParent
96045>>>>>>>        // at this the scrolling container and client area should both be paged.
96045>>>>>>>        // child objects ae also paged with initial anchors applied
96045>>>>>>>        Send CalculateAutoScrollMinimums
96046>>>>>>>    End_Procedure
96047>>>>>>>    
96047>>>>>>>    Procedure Page Integer iPage
96049>>>>>>>        Forward Send Page iPage
96051>>>>>>>        If iPage Begin
96053>>>>>>>            // at this the scrolling container and client area should both be paged
96053>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96053>>>>>>>            // the child items are paged (else they may get anchored oddly)
96053>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96053>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96053>>>>>>>            // before they were really needed. This should be more accurate
96053>>>>>>>            Send SetScrollBarInfo True 0 0 0
96054>>>>>>>            Send SetScrollBarInfo False 0 0 0
96055>>>>>>>        End
96055>>>>>>>>
96055>>>>>>>    End_Procedure
96056>>>>>>>    
96056>>>>>>>    // determine scrolling minimums and set the client area as required.
96056>>>>>>>    
96056>>>>>>>    Procedure CalculateAutoScrollMinimums
96058>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96058>>>>>>>        Integer iAutoMinX iAutoMinY
96058>>>>>>>        Boolean bAutoScroll
96058>>>>>>>        Handle hoNext hoFirst
96058>>>>>>>        
96058>>>>>>>        Get pbAutoScroll to bAutoScroll
96059>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96060>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96061>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96062>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96063>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96064>>>>>>>        Set piMinimumHeight to iAutoMinY
96065>>>>>>>        Set piMinimumWidth to iAutoMinX
96066>>>>>>>        
96066>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96068>>>>>>>            
96068>>>>>>>            Get Next_Level to hoFirst
96069>>>>>>>            Move hoFirst to hoNext
96070>>>>>>>            If (hoFirst) Begin
96072>>>>>>>                Repeat
96072>>>>>>>>
96072>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96073>>>>>>>                    Get GuiLocation of hoNext to iLoc
96074>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96075>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96076>>>>>>>                    Get Next_Focus of hoNext to hoNext
96077>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96079>>>>>>>                
96079>>>>>>>                If (iAutoMinY=0) Begin
96081>>>>>>>                    Get piAutoScrollMarginY to iMargin
96082>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96083>>>>>>>                End
96083>>>>>>>>
96083>>>>>>>                
96083>>>>>>>                If (iAutoMinX=0) Begin
96085>>>>>>>                    Get piAutoScrollMarginX to iMargin
96086>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96087>>>>>>>                    
96087>>>>>>>                End
96087>>>>>>>>
96087>>>>>>>            End
96087>>>>>>>>
96087>>>>>>>        End
96087>>>>>>>>
96087>>>>>>>        
96087>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96087>>>>>>>        Broadcast Set pbAnchorCreated to False
96089>>>>>>>        Send ScrollClientArea
96090>>>>>>>        // after the scroll set up, reinitialize all anchors.
96090>>>>>>>        Broadcast Send DoCreateAnchors
96092>>>>>>>    End_Procedure
96093>>>>>>>    
96093>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96093>>>>>>>    // work of scrolling.
96093>>>>>>>    
96093>>>>>>>    Procedure ScrollClientArea
96095>>>>>>>        Integer iSiz
96095>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96095>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96095>>>>>>>        Integer iSzY iSzX iLocX iLocY
96095>>>>>>>        
96095>>>>>>>        Delegate Get GuiClientSize to iSiz
96097>>>>>>>        Move (Hi(iSiz)) to iHeight
96098>>>>>>>        Move (Low(iSiz)) to iWidth
96099>>>>>>>        
96099>>>>>>>        // Vertical scrolling
96099>>>>>>>        
96099>>>>>>>        Get piMinimumHeight to iOrig
96100>>>>>>>        Get piMinimumWidth to iWOrig
96101>>>>>>>        
96101>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96103>>>>>>>            
96103>>>>>>>            If (iOrig<>0) Begin
96105>>>>>>>                Get piCurrentVertScrolled to iHCur
96106>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96106>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96108>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96109>>>>>>>                    Set piCurrentVertScrolled to iHCur
96110>>>>>>>                End
96110>>>>>>>>
96110>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96112>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96113>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96114>>>>>>>                End
96114>>>>>>>>
96114>>>>>>>                Else Begin
96115>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96116>>>>>>>                End
96116>>>>>>>>
96116>>>>>>>            End
96116>>>>>>>>
96116>>>>>>>            
96116>>>>>>>            // Horiz scrolling
96116>>>>>>>            
96116>>>>>>>            Get piCurrentHorzScrolled to iWCur
96117>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96117>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96119>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96120>>>>>>>                Set piCurrentHorzScrolled to iWCur
96121>>>>>>>            End
96121>>>>>>>>
96121>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96123>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96124>>>>>>>                Send SetScrollBarPosInfo False iWCur
96125>>>>>>>            End
96125>>>>>>>>
96125>>>>>>>            Else Begin
96126>>>>>>>                Send SetScrollBarInfo False 0 0 0
96127>>>>>>>            End
96127>>>>>>>>
96127>>>>>>>        End
96127>>>>>>>>
96127>>>>>>>        
96127>>>>>>>        // this could change depending on scrollbars appearing or not
96127>>>>>>>        Delegate Get GuiClientSize to iSiz
96129>>>>>>>        
96129>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96129>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96129>>>>>>>        // This is required to make anchors work sensibly
96129>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96130>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96131>>>>>>>        Move (-iHCur) to iLocY
96132>>>>>>>        Move (-iWCur) to iLocX
96133>>>>>>>        
96133>>>>>>>        // Allow chance to make modifications
96133>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96134>>>>>>>        
96134>>>>>>>        Set GuiSize to iSzY iSzX
96135>>>>>>>        // if we've scrolled, we need to reposition the container
96135>>>>>>>        Set GuiLocation to iLocY iLocX
96136>>>>>>>    End_Procedure
96137>>>>>>>    
96137>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96137>>>>>>>    // this way, it does not interfere with anchors.
96137>>>>>>>    
96137>>>>>>>    Procedure VScroll Integer iDelta
96139>>>>>>>        Integer iHeight iCur iOrig iSiz
96139>>>>>>>        Delegate Get GuiClientSize to iSiz
96141>>>>>>>        Move (hi(iSiz)) to iHeight
96142>>>>>>>        Get piCurrentVertScrolled to iCur
96143>>>>>>>        Get piMinimumHeight to iOrig
96144>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96146>>>>>>>            Procedure_Return
96147>>>>>>>        End
96147>>>>>>>>
96147>>>>>>>        // make sure delta is within range
96147>>>>>>>        If (iDelta+iCur<0) Begin
96149>>>>>>>            Move (-iCur) to iDelta
96150>>>>>>>        End
96150>>>>>>>>
96150>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96153>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96154>>>>>>>        End
96154>>>>>>>>
96154>>>>>>>        If (iDelta=0) ;            Procedure_Return
96157>>>>>>>        
96157>>>>>>>        Move (iCur + iDelta) to iCur
96158>>>>>>>        Set piCurrentVertScrolled to iCur
96159>>>>>>>        Send SetScrollBarPosInfo True iCur
96160>>>>>>>        Get GuiLocation to iSiz
96161>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96162>>>>>>>        Send ScrollClientArea
96163>>>>>>>    End_Procedure
96164>>>>>>>    
96164>>>>>>>    
96164>>>>>>>    Procedure HScroll Integer iDelta
96166>>>>>>>        Integer iHeight iCur iOrig iSiz
96166>>>>>>>        Delegate Get GuiClientSize to iSiz
96168>>>>>>>        Move (low(iSiz)) to iHeight
96169>>>>>>>        Get piCurrentHorzScrolled to iCur
96170>>>>>>>        Get piMinimumWidth to iOrig
96171>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96173>>>>>>>            Procedure_Return
96174>>>>>>>        End
96174>>>>>>>>
96174>>>>>>>        If (iDelta+iCur<0) Begin
96176>>>>>>>            Move (-iCur) to iDelta
96177>>>>>>>        End
96177>>>>>>>>
96177>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96180>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96181>>>>>>>        End
96181>>>>>>>>
96181>>>>>>>        If (iDelta=0) ;            Procedure_Return
96184>>>>>>>        
96184>>>>>>>        Move (iCur + iDelta) to iCur
96185>>>>>>>        Set piCurrentHorzScrolled to iCur
96186>>>>>>>        Send SetScrollBarPosInfo False iCur
96187>>>>>>>        Get GuiLocation to iSiz
96188>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96189>>>>>>>        Send ScrollClientArea
96190>>>>>>>    End_Procedure
96191>>>>>>>    
96191>>>>>>>    // make sure client is a 0,0
96191>>>>>>>    Procedure ScrollHome
96193>>>>>>>        Send SetVScrollbox SB_TOP 0
96194>>>>>>>        Send SetHScrollbox SB_TOP 0
96195>>>>>>>    End_Procedure
96196>>>>>>>    
96196>>>>>>>    // get relative GUI location of this object to the parent one passed.
96196>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96198>>>>>>>        Integer ivoid
96198>>>>>>>        tWinRect Rect0 Rect1
96198>>>>>>>        tWinRect Rect0 Rect1
96198>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96199>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96200>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96201>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96202>>>>>>>    End_Procedure
96203>>>>>>>    
96203>>>>>>>    // This scrolls this object into visual range.
96203>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96205>>>>>>>        Handle hoScrollingContainer
96205>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96205>>>>>>>        Integer iViewHeight iViewWidth
96205>>>>>>>        Integer iRelLocHeight iRelLocWidth
96205>>>>>>>        Integer iSize iControlHeight iControlWidth
96205>>>>>>>        Integer iScroll
96205>>>>>>>        Integer iMarginX iMarginY
96205>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96205>>>>>>>        
96205>>>>>>>        Get piAutoScrollMarginX to iMarginX
96206>>>>>>>        Get piAutoScrollMarginY to iMarginY
96207>>>>>>>        
96207>>>>>>>        // the scrolling container
96207>>>>>>>        Move Self to hoScrollingContainer
96208>>>>>>>        // the amount the SC is currently scrolled
96208>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96209>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96210>>>>>>>        
96210>>>>>>>        // size of view's client area (this is the viewport area)
96210>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96211>>>>>>>        Move (hi(iSize)) to iViewHeight
96212>>>>>>>        Move (low(iSize)) to iViewWidth
96213>>>>>>>        
96213>>>>>>>        // get this object's location relative to the scrolling container
96213>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96214>>>>>>>        
96214>>>>>>>        // we expect that the client size is the window size but just in case
96214>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96215>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96216>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96217>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96218>>>>>>>        
96218>>>>>>>        // the outer size of the control object
96218>>>>>>>        Get GUIWindowSize of hoControl to iSize
96219>>>>>>>        Move (hi(iSize)) to iControlHeight
96220>>>>>>>        Move (low(iSize)) to iControlWidth
96221>>>>>>>        
96221>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96221>>>>>>>        
96221>>>>>>>        // Vertical Scroll
96221>>>>>>>        
96221>>>>>>>        // Vertical Scroll down
96221>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96221>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96223>>>>>>>            
96223>>>>>>>            // set scroll amount so that the bottom of the control is visible
96223>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96224>>>>>>>            
96224>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96224>>>>>>>            // top of the object appears at the bottom
96224>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96226>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96227>>>>>>>            End
96227>>>>>>>>
96227>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96227>>>>>>>            If (iScroll>0) Begin
96229>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96230>>>>>>>            End
96230>>>>>>>>
96230>>>>>>>        End
96230>>>>>>>>
96230>>>>>>>        // else vertical scroll up
96230>>>>>>>        // We scroll if the top of the object is not visible.
96230>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96233>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96233>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96234>>>>>>>            If (iScroll<0) Begin
96236>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96237>>>>>>>            End
96237>>>>>>>>
96237>>>>>>>        End
96237>>>>>>>>
96237>>>>>>>        
96237>>>>>>>        // Horizonal Scroll
96237>>>>>>>        
96237>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96237>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96239>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96240>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96242>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96243>>>>>>>            End
96243>>>>>>>>
96243>>>>>>>            If (iScroll>0) Begin
96245>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96246>>>>>>>            End
96246>>>>>>>>
96246>>>>>>>        End
96246>>>>>>>>
96246>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96248>>>>>>>            // if this can fit by moving all the way to left, do so.
96248>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96250>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96251>>>>>>>            End
96251>>>>>>>>
96251>>>>>>>            Else Begin
96252>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96253>>>>>>>            End
96253>>>>>>>>
96253>>>>>>>            If (iScroll<0) Begin
96255>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96256>>>>>>>            End
96256>>>>>>>>
96256>>>>>>>        End
96256>>>>>>>>
96256>>>>>>>        
96256>>>>>>>        
96256>>>>>>>    End_Procedure
96257>>>>>>>    
96257>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96257>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96259>>>>>>>        Boolean bScrollOnFocus
96259>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96260>>>>>>>        If bScrollOnFocus Begin
96262>>>>>>>            Send ScrollObjectInRange hoControl
96263>>>>>>>        End
96263>>>>>>>>
96263>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96265>>>>>>>    End_Procedure
96266>>>>>>>    
96266>>>>>>>    
96266>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96268>>>>>>>        Boolean bCenter
96268>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96269>>>>>>>        Function_Return bCenter
96270>>>>>>>    End_Function
96271>>>>>>>    
96271>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96273>>>>>>>        Boolean bTabWorkspaceView
96273>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96274>>>>>>>        If bTabWorkspaceView Begin
96276>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96277>>>>>>>        End
96277>>>>>>>>
96277>>>>>>>    End_Procedure
96278>>>>>>>    
96278>>>>>>>    Function ParentView Returns Handle
96280>>>>>>>        Function_Return (Parent(Parent(Self)))
96281>>>>>>>    End_Function
96282>>>>>>>    
96282>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96284>>>>>>>        Integer iSize iMax iDiff
96284>>>>>>>        Handle hoView
96284>>>>>>>        Boolean bCenter bModal
96284>>>>>>>        Get ParentView to hoView
96285>>>>>>>        Get Block_Mouse_State of hoView to bModal
96286>>>>>>>        If not bModal Begin
96288>>>>>>>            Get CenterTabWorkspaceView to bCenter
96289>>>>>>>            Get GuiSize of hoView to iSize
96290>>>>>>>            Get piMaxSize of hoView to iMax
96291>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
96292>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
96294>>>>>>>                If bCenter Begin
96296>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
96297>>>>>>>                End
96297>>>>>>>>
96297>>>>>>>                Move (Low(iMax)) to iWidth
96298>>>>>>>            End
96298>>>>>>>>
96298>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
96300>>>>>>>                If bCenter Begin
96302>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
96303>>>>>>>                    Move (iLocy min 25) to  iLocY
96304>>>>>>>                End
96304>>>>>>>>
96304>>>>>>>                Move (Hi(imax)) to iHeight
96305>>>>>>>            End
96305>>>>>>>>
96305>>>>>>>        End
96305>>>>>>>>
96305>>>>>>>    End_Procedure
96306>>>>>>>    
96306>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
96306>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
96306>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
96306>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
96306>>>>>>>    // This should almost always yield the right answer.
96306>>>>>>>    // This is called by the scrolling container's end_constructor
96306>>>>>>>    Procedure AutoSetTabWorkspaceView
96308>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
96308>>>>>>>        Handle hoParent
96308>>>>>>>        Integer iSize
96308>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
96309>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
96311>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
96312>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
96312>>>>>>>            // change this after the commandbar is paged.
96312>>>>>>>            If (bTabView) Begin
96314>>>>>>>                Get ParentView to hoParent
96315>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
96316>>>>>>>                If (bIsView) Begin
96318>>>>>>>                    // set this as a tab workspace view
96318>>>>>>>                    Set pbTabWorkspaceView to True
96319>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
96319>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
96319>>>>>>>                    Set pbAutoScroll to True
96320>>>>>>>                    
96320>>>>>>>                End
96320>>>>>>>>
96320>>>>>>>            End
96320>>>>>>>>
96320>>>>>>>        End
96320>>>>>>>>
96320>>>>>>>    End_Procedure
96321>>>>>>>    
96321>>>>>>>End_Class
96322>>>>>>>
96322>>>>>>>// Container scrolling class support. Nothing in here is public
96322>>>>>>>Class cScrollingContainerMixin is a Mixin
96323>>>>>>>    
96323>>>>>>>    Procedure Define_cScrollingContainerMixin
96325>>>>>>>        Forward Set Border_Style to Border_None
96327>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
96328>>>>>>>        Forward Set peAnchors to anAll
96330>>>>>>>        
96330>>>>>>>        // forcing scrollbars right away seems to make painting better
96330>>>>>>>        Set Window_Style WS_HSCROLL to True
96331>>>>>>>        Set Window_Style WS_VSCROLL to True
96332>>>>>>>        
96332>>>>>>>        Property Handle phoScrollingClientArea 0
96333>>>>>>>    End_Procedure
96334>>>>>>>    
96334>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
96334>>>>>>>    Procedure Set peAnchors Integer eAnchors
96336>>>>>>>    End_Procedure
96337>>>>>>>    
96337>>>>>>>    // if a border style is set, it will not work. We won't let that happen
96337>>>>>>>    Procedure Set Border_Style Integer eStyle
96339>>>>>>>    End_Procedure
96340>>>>>>>    
96340>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
96340>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96342>>>>>>>        Handle hoClient
96342>>>>>>>        Get phoScrollingClientArea to hoClient
96343>>>>>>>        If hoClient Begin
96345>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
96346>>>>>>>        End
96346>>>>>>>>
96346>>>>>>>    End_Procedure
96347>>>>>>>    
96347>>>>>>>    // should be sent by WM_VSCROLL
96347>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96349>>>>>>>        Handle hoClient
96349>>>>>>>        Get phoScrollingClientArea to hoClient
96350>>>>>>>        If hoClient Begin
96352>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
96353>>>>>>>        End
96353>>>>>>>>
96353>>>>>>>    End_Procedure
96354>>>>>>>    
96354>>>>>>>    // should be sent by WM_HSCROLL
96354>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96356>>>>>>>        Handle hoClient
96356>>>>>>>        Get phoScrollingClientArea to hoClient
96357>>>>>>>        If hoClient Begin
96359>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
96360>>>>>>>        End
96360>>>>>>>>
96360>>>>>>>    End_Procedure
96361>>>>>>>    
96361>>>>>>>    // augmented to adjust its size to the size of the parent client area.
96361>>>>>>>    // After this is set, anchors will handle any further resizing.
96361>>>>>>>    Procedure Page Integer iState
96363>>>>>>>        Integer iSiz iHeight iWidth
96363>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
96363>>>>>>>        Boolean bGroup
96363>>>>>>>        Handle hoClient
96363>>>>>>>        If (iState =1) Begin
96365>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
96367>>>>>>>            // We have special code to support groups because they
96367>>>>>>>            // draw a border inside of the client rectangle
96367>>>>>>>            If bGroup Begin
96369>>>>>>>                Get Physical_FontSize to iFontSize
96370>>>>>>>                Move (Hi(iFontSize)) to iTop
96371>>>>>>>                Move 2 to iLeft
96372>>>>>>>                Move 2 to iRight
96373>>>>>>>                Move 2 to iBottom
96374>>>>>>>            End
96374>>>>>>>>
96374>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
96374>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
96374>>>>>>>            // makes anchors work properly with unpaged tab-pages
96374>>>>>>>            Delegate Get GetContainerClientSize to iSiz
96376>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
96377>>>>>>>            Set GuiLocation to iTop iLeft
96378>>>>>>>            Send Adjust_Logicals
96379>>>>>>>        End
96379>>>>>>>>
96379>>>>>>>        Forward Send Page iState
96381>>>>>>>    End_Procedure
96382>>>>>>>    
96382>>>>>>>    Procedure End_Construct_Object
96384>>>>>>>        Handle hoClient
96384>>>>>>>        Forward Send End_Construct_Object
96386>>>>>>>        Get phoScrollingClientArea to hoClient
96387>>>>>>>        If (hoClient) Begin
96389>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
96390>>>>>>>        End
96390>>>>>>>>
96390>>>>>>>    End_Procedure
96391>>>>>>>    
96391>>>>>>>End_Class
96392>>>>>
96392>>>>>Class cDbScrollingClientArea is a dbContainer3d
96393>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
96394>>>>>    Procedure Construct_Object
96396>>>>>        Forward Send Construct_Object
96398>>>>>        Send Define_cScrollingClientAreaMixin
96399>>>>>    End_Procedure
96400>>>>>End_Class
96401>>>>>
96401>>>>>
96401>>>>>
96401>>>>>Class cDbScrollingContainer is a dbContainer3d
96402>>>>>    Import_Class_Protocol cScrollingContainerMixin
96403>>>>>    Procedure Construct_Object
96405>>>>>        Forward Send Construct_Object
96407>>>>>        Send Define_cScrollingContainerMixin
96408>>>>>    End_Procedure
96409>>>>>End_Class
96410>>>Use cDbUpdateFunctionLibrary.pkg
96410>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButtonDPI.pkg)
96410>>>>>//****************************************************************************
96410>>>>>// $Module type: Package
96410>>>>>// $Module name: cRDCButtonDPI.pkg
96410>>>>>//
96410>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96410>>>>>// Copyright (c) 2013 RDC Tools International
96410>>>>>// E-mail      : support@rdctools.com
96410>>>>>// Web-site    : http://www.rdctools.com
96410>>>>>//
96410>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96410>>>>>//
96410>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96410>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96410>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96410>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96410>>>>>// in the help folder for more details.
96410>>>>>//
96410>>>>>//****************************************************************************
96410>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib20\AppSrc\cRDCButton.pkg)
96410>>>>>>>//****************************************************************************
96410>>>>>>>// $Module type: Package
96410>>>>>>>// $Module name: cRDCButton.pkg
96410>>>>>>>//
96410>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96410>>>>>>>// Copyright (c) 2013 RDC Tools International
96410>>>>>>>// E-mail      : support@rdctools.com
96410>>>>>>>// Web-site    : http://www.rdctools.com
96410>>>>>>>//
96410>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
96410>>>>>>>//
96410>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96410>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96410>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96410>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96410>>>>>>>// in the help folder for more details.
96410>>>>>>>//
96410>>>>>>>//****************************************************************************
96410>>>>>>>Use Windows.pkg
96410>>>>>>>Use Enclient.pkg
96410>>>>>>>Use errornum.inc
96410>>>>>>>
96410>>>>>>>Class cButtonIdleHandler is a cIdleHandler
96411>>>>>>>    Procedure Construct_Object
96413>>>>>>>        Forward Send Construct_Object
96415>>>>>>>
96415>>>>>>>    End_Procedure
96416>>>>>>>
96416>>>>>>>    Procedure OnIdle
96418>>>>>>>        Delegate Send DoUpdate
96420>>>>>>>    End_Procedure
96421>>>>>>>
96421>>>>>>>End_Class
96422>>>>>>>
96422>>>>>>>Class cRDCButton is a Button
96423>>>>>>>
96423>>>>>>>    Procedure Construct_Object
96425>>>>>>>        Forward Send Construct_Object
96427>>>>>>>
96427>>>>>>>        Property Boolean pbAutoEnable True
96428>>>>>>>
96428>>>>>>>        Property Boolean pbEnabled True
96429>>>>>>>
96429>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
96430>>>>>>>
96430>>>>>>>        On_Key kCancel Send CancelIfPopupObject
96431>>>>>>>    End_Procedure
96432>>>>>>>
96432>>>>>>>    Procedure CancelIfPopupObject
96434>>>>>>>        Boolean bIsInPopupObject
96434>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
96436>>>>>>>        If (bIsInPopupObject = True) Begin
96438>>>>>>>            Send Close_Panel
96439>>>>>>>        End
96439>>>>>>>>
96439>>>>>>>    End_Procedure
96440>>>>>>>
96440>>>>>>>    Procedure End_Construct_Object
96442>>>>>>>        String sTooltip sStatus_Help
96442>>>>>>>
96442>>>>>>>        Forward Send End_Construct_Object
96444>>>>>>>
96444>>>>>>>        Get psToolTip   to sTooltip
96445>>>>>>>        Get Status_Help to sStatus_Help
96446>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96448>>>>>>>            Set psToolTip to sStatus_Help
96449>>>>>>>        End
96449>>>>>>>>
96449>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
96451>>>>>>>            Set Status_Help to sToolTip
96452>>>>>>>        End
96452>>>>>>>>
96452>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96453>>>>>>>    End_Procedure
96454>>>>>>>
96454>>>>>>>    Procedure DoUpdate
96456>>>>>>>        If (pbAutoEnable(Self) = False) Begin
96458>>>>>>>            Procedure_Return
96459>>>>>>>        End
96459>>>>>>>>
96459>>>>>>>        Set Enabled_State to (IsEnabled(Self))
96460>>>>>>>    End_Procedure
96461>>>>>>>
96461>>>>>>>    Function IsEnabled Returns Boolean
96463>>>>>>>        Boolean bEnabled
96463>>>>>>>        Get pbEnabled to bEnabled
96464>>>>>>>        Function_Return bEnabled
96465>>>>>>>    End_Function
96466>>>>>>>
96466>>>>>>>    // Enable the idle handler timer when the button is activated
96466>>>>>>>    Procedure Activating
96468>>>>>>>        Forward Send Activating
96470>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96471>>>>>>>    End_Procedure
96472>>>>>>>
96472>>>>>>>    // Disable the idle handler when the button is deactivated
96472>>>>>>>    Procedure Deactivating
96474>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96475>>>>>>>        Forward Send Deactivating
96477>>>>>>>    End_Procedure
96478>>>>>>>
96478>>>>>>>End_Class
96479>>>>>
96479>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
96479>>>>>Class cRDCButtonDPI is a cRDCButton
96480>>>>>    Procedure Construct_Object
96482>>>>>        Integer iIconSize
96482>>>>>        Forward Send Construct_Object
96484>>>>>        Set piImageMarginLeft to 10
96485>>>>>    End_Procedure
96486>>>>>
96486>>>>>    // Returns: DPI setting as an integer.
96486>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
96486>>>>>    //                      iDPI=120 is "Medium setting" 125%
96486>>>>>    //                      iDPI= 144 is "Large setting" 150%
96486>>>>>    Function GetCurrentDPI Returns Integer
96488>>>>>        Handle hDC
96488>>>>>        Integer iPixelsX
96488>>>>>        Move (GetDC(0)) to hDC
96489>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
96490>>>>>        Move (ReleaseDC(0, hDC)) to hDC
96491>>>>>        Function_Return iPixelsX
96492>>>>>    End_Function
96493>>>>>
96493>>>>>    Function GetCorrectIconSize Returns Integer
96495>>>>>        Integer iPixelsX iIndex iSize
96495>>>>>        Integer[] iaSizes
96496>>>>>
96496>>>>>        Move 16 to iaSizes[0]
96497>>>>>        Move 24 to iaSizes[1]
96498>>>>>        Move 32 to iaSizes[2]
96499>>>>>        Move 48 to iaSizes[3]
96500>>>>>        Move 64 to iaSizes[4]
96501>>>>>
96501>>>>>        Get piImageSize to iSize  // the "100%" size
96502>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
96503>>>>>        Move (0 max iIndex) to iIndex
96504>>>>>        Get GetCurrentDPI to iPixelsX
96505>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
96505>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
96505>>>>>        // will increment iIndex as many times as we need here.
96505>>>>>        Case Begin
96505>>>>>            Case (iPixelsX > 144)
96507>>>>>                Increment iIndex
96508>>>>>            Case (iPixelsX = 144)
96511>>>>>                Increment iIndex
96512>>>>>            Case (iPixelsX = 120)
96515>>>>>                Increment iIndex
96516>>>>>        Case End
96516>>>>>        Move (iIndex min 4) to iIndex
96517>>>>>        Function_Return iaSizes[iIndex]
96518>>>>>    End_Function
96519>>>>>
96519>>>>>    Procedure Set psToolTip String sToolTip
96521>>>>>        String sStatusHelp
96521>>>>>
96521>>>>>        Get Status_Help to sStatusHelp
96522>>>>>        If (sStatusHelp = "") Begin
96524>>>>>            Set Status_Help to sToolTip
96525>>>>>        End
96525>>>>>>
96525>>>>>
96525>>>>>        Forward Set psToolTip to sToolTip
96527>>>>>    End_Procedure
96528>>>>>
96528>>>>>End_Class
96529>>>Use DatabaseSelection.dg
96529>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
96529>>>>>Use Windows.pkg
96529>>>>>Use cCJGridPromptList.pkg
96529>>>>>Use MSSqldrv.pkg
96529>>>>>Use db2_drv.pkg
96529>>>>>Use odbc_drv.pkg    
96529>>>>>Use cRDCModalPanel.pkg
96529>>>>>Use cDbUpdateFunctionLibrary.pkg
96529>>>>>
96529>>>>>Object oServerSelection_sl is a cRDCModalPanel
96531>>>>>    Set Size to 105 225
96532>>>>>    Set Label to "Database Server/DSN Selection"
96533>>>>>    Set piMinSize to 89 211
96534>>>>>    Set Location to 2 2
96535>>>>>    Set Icon to "ServerLookup1.ico"
96536>>>>>
96536>>>>>    Property String[] psTheData
96538>>>>>
96538>>>>>    Object oSelList is a cCJGridPromptList
96540>>>>>        Set Size to 72 215
96541>>>>>        Set Location to 6 6
96542>>>>>        Set peAnchors to anAll
96543>>>>>        Set pbAllowColumnRemove to False
96544>>>>>        Set pbUseAlternateRowBackgroundColor to True
96545>>>>>        Set pbGrayIfDisable to False
96546>>>>>        Set pbHeaderReorders to False
96547>>>>>        Set pbHeaderSelectsColumn to False
96548>>>>>        Set pbHeaderTogglesDirection to False
96549>>>>>        Set pbShadeSortColumn to False
96550>>>>>        Set piFocusCellBackColor to clDkGray
96551>>>>>
96551>>>>>        Object oName is a cCJGridColumn
96553>>>>>            Set piWidth to 358
96554>>>>>            Set psCaption to "Name"
96555>>>>>        End_Object
96556>>>>>
96556>>>>>        Procedure Activating
96559>>>>>            tDataSourceRow[] MyData
96559>>>>>            tDataSourceRow[] MyData
96560>>>>>            Handle hoDataSource
96560>>>>>            String[] sTheData
96561>>>>>            Integer iCount iSize
96561>>>>>
96561>>>>>            Send Cursor_Wait of Cursor_Control
96562>>>>>            Get psTheData to sTheData
96563>>>>>            Move (SizeOfArray(sTheData)) to iSize
96564>>>>>            Decrement iSize
96565>>>>>            For iCount from 0 to iSize
96571>>>>>>
96571>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96572>>>>>            Loop
96573>>>>>>
96573>>>>>
96573>>>>>            Forward Send Activating
96575>>>>>
96575>>>>>            Get phoDataSource to hoDataSource
96576>>>>>            Send InitializeData of hoDataSource MyData
96577>>>>>            Send Cursor_Ready of Cursor_Control
96578>>>>>        End_Procedure
96579>>>>>
96579>>>>>    End_Object
96580>>>>>
96580>>>>>    Object oOK_Btn is a Button
96582>>>>>        Set Size to 14 50
96583>>>>>        Set Label    to "&OK"
96584>>>>>        Set Location to 85 116
96585>>>>>        Set peAnchors To anBottomRight
96586>>>>>
96586>>>>>        Procedure OnClick
96589>>>>>            Send Ok of oSelList
96590>>>>>        End_Procedure
96591>>>>>
96591>>>>>    End_Object
96592>>>>>
96592>>>>>    Object oCancel_Btn is a Button
96594>>>>>        Set Size to 14 50
96595>>>>>        Set Label    to "&Cancel"
96596>>>>>        Set Location to 85 171
96597>>>>>        Set peAnchors to anBottomRight
96598>>>>>
96598>>>>>        Procedure OnClick
96601>>>>>            Send Close_Panel
96602>>>>>        End_Procedure
96603>>>>>
96603>>>>>    End_Object
96604>>>>>
96604>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96605>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96606>>>>>End_Object
96607>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
96607>>>>>Use Windows.pkg
96607>>>>>Use cCJGridPromptList.pkg
96607>>>>>Use cDbUpdateFunctionLibrary.pkg
96607>>>>>Use MSSqldrv.pkg
96607>>>>>Use db2_drv.pkg
96607>>>>>Use odbc_drv.pkg
96607>>>>>Use cCJGridColumn.pkg
96607>>>>>
96607>>>>>Object oSQLConnections is a ModalPanel
96609>>>>>    Set Label to "SQL Connections"
96610>>>>>    Set Size to 121 397
96611>>>>>    Set piMinSize to 89 185
96612>>>>>    Set Location to 2 2
96613>>>>>    Set Border_Style to Border_Thick
96614>>>>>
96614>>>>>    Property tSQLConnection[] psTheData
96616>>>>>
96616>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
96616>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96616>>>>>//        End_Object
96616>>>>>//    End
96616>>>>>
96616>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
96618>>>>>        Set Size to 90 377
96619>>>>>        Set Location to 6 6
96620>>>>>        Set peAnchors to anAll
96621>>>>>        Set pbAllowColumnRemove to False
96622>>>>>        Set pbUseAlternateRowBackgroundColor to True
96623>>>>>        Set pbGrayIfDisable to False
96624>>>>>        Set pbHeaderReorders to False
96625>>>>>        Set pbHeaderSelectsColumn to False
96626>>>>>        Set pbHeaderTogglesDirection to False
96627>>>>>        Set pbShadeSortColumn to False
96628>>>>>        Set piFocusCellBackColor to clDkGray  
96629>>>>>        Set pbRestoreLayout to True
96630>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
96631>>>>>
96631>>>>>        Object oID_Col is a cCJGridColumn
96633>>>>>            Set piWidth to 132
96634>>>>>            Set psCaption to "ID"
96635>>>>>        End_Object
96636>>>>>
96636>>>>>        Object oDbType_Col is a cCJGridColumn
96638>>>>>            Set piWidth to 182
96639>>>>>            Set psCaption to "Database Type"
96640>>>>>        End_Object
96641>>>>>
96641>>>>>        Object oServer_Col is a cCJGridColumn
96643>>>>>            Set piWidth to 296
96644>>>>>            Set psCaption to "Server/DSN"
96645>>>>>        End_Object
96646>>>>>
96646>>>>>        Object oDatabase_Col is a cCJGridColumn
96648>>>>>            Set piWidth to 211
96649>>>>>            Set psCaption to "Database"
96650>>>>>        End_Object
96651>>>>>
96651>>>>>        Object oDriverID_Col is a cCJGridColumn
96653>>>>>            Set piWidth to 121
96654>>>>>            Set psCaption to "Driver ID"
96655>>>>>        End_Object
96656>>>>>
96656>>>>>        Procedure Activating
96659>>>>>            tDataSourceRow[] MyData
96659>>>>>            tDataSourceRow[] MyData
96660>>>>>            Handle hoDataSource
96660>>>>>            Integer iCount iSize iPos
96660>>>>>            String sDriverID sConnectionID sValue
96660>>>>>            tSQLConnection[] sTheData
96660>>>>>            tSQLConnection[] sTheData
96661>>>>>
96661>>>>>            Send Cursor_Wait of Cursor_Control
96662>>>>>            Forward Send Activating
96664>>>>>
96664>>>>>            Get psTheData to sTheData
96665>>>>>            Move (SizeOfArray(sTheData)) to iSize
96666>>>>>            Decrement iSize
96667>>>>>            For iCount from 0 to iSize
96673>>>>>>
96673>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
96674>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
96675>>>>>                Move sValue                         to MyData[iCount].sValue[1]
96676>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
96677>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
96678>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
96679>>>>>            Loop
96680>>>>>>
96680>>>>>
96680>>>>>            Get phoDataSource to hoDataSource
96681>>>>>            Send InitializeData of hoDataSource MyData
96682>>>>>            Send Cursor_Ready of Cursor_Control
96683>>>>>        End_Procedure
96684>>>>>
96684>>>>>    End_Object
96685>>>>>
96685>>>>>    Object oOK_Btn is a Button
96687>>>>>        Set Label    to "&OK"
96688>>>>>        Set Location to 101 280
96689>>>>>        Set peAnchors to anBottomRight
96690>>>>>
96690>>>>>        Procedure OnClick
96693>>>>>            Send Ok of oSelListSQLConnections
96694>>>>>        End_Procedure
96695>>>>>
96695>>>>>    End_Object
96696>>>>>
96696>>>>>    Object oCancel_Btn is a Button
96698>>>>>        Set Label    to "&Cancel"
96699>>>>>        Set Location to 101 335
96700>>>>>        Set peAnchors to anBottomRight
96701>>>>>
96701>>>>>        Procedure OnClick
96704>>>>>            Send Close_Panel
96705>>>>>        End_Procedure
96706>>>>>
96706>>>>>    End_Object
96707>>>>>
96707>>>>>    Procedure Page Integer iPageObject
96710>>>>>        Set Icon to "SQLConnections1.ico"
96711>>>>>        Forward Send Page iPageObject
96713>>>>>    End_Procedure
96714>>>>>
96714>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96715>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96716>>>>>End_Object
96717>>>
96717>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
96727>>>>
96727>>>Object oSQLConnections_vw is a dbView
96729>>>    Set Border_Style to Border_Thick
96730>>>    Set Size to 251 427
96731>>>    Set Location to 2 2
96732>>>    Set Label to "SQL Connections"
96733>>>    Set pbAutoActivate to True
96734>>>    Set Icon to "SQLConnections1.ico"
96735>>>
96735>>>    Object oScrollingContainer1 is a cDbScrollingContainer
96737>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
96739>>>
96739>>>            Object oCurrentSettings_grp is a Group
96741>>>                Set Size to 232 402
96742>>>                Set Location to 6 12
96743>>>                Set Label to "Current Connection Settings"
96744>>>                Set peAnchors to anAll
96745>>>
96745>>>                Object oConnectionID_fm is a Form
96747>>>                    Set Size to 12 100
96748>>>                    Set Location to 12 68
96749>>>                    Set Label to "Connection ID"
96750>>>                    Set Label_Col_Offset to 2
96751>>>                    Set Label_Justification_Mode to JMode_Right
96752>>>                    Set Prompt_Button_Mode to PB_PromptOn
96753>>>                    Set Prompt_Object to (oSQLConnections(Self))
96754>>>
96754>>>                    Procedure Prompt
96757>>>                        String[] sTheData
96758>>>                        String sCurrentVal sNewVal
96758>>>                        Handle hoIniFile ho
96758>>>                        Integer iSize iCount
96758>>>                        tSQLConnection[] SQLConnectionArray
96758>>>                        tSQLConnection[] SQLConnectionArray
96759>>>
96759>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
96760>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
96761>>>                        Get Value to sCurrentVal
96762>>>                        Get Prompt_Object to ho
96763>>>                        Set psTheData of ho to SQLConnectionArray
96764>>>
96764>>>                        Forward Send Prompt
96766>>>                        Get Value to sNewVal
96767>>>                        If (sCurrentVal <> sNewVal) Begin
96769>>>                            Send Cursor_Wait of Cursor_Control
96770>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
96771>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
96773>>>                            Send Cursor_Ready of Cursor_Control
96774>>>                            Send KeyAction of oTestLogin_btn
96775>>>                        End
96775>>>>
96775>>>                    End_Procedure   
96776>>>                    
96776>>>                    Procedure PromptUpdate Handle hoPrompt
96779>>>                        String[] sSelectedNames                    
96780>>>                
96780>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
96781>>>                        If (SizeOfArray(sSelectedNames)) Begin
96783>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
96784>>>                            Delegate Send Page True // Broadcast sends refresh
96786>>>                        End
96786>>>>
96786>>>                    End_Procedure   
96787>>>
96787>>>                    Procedure Prompt_Callback Handle hoPrompt
96790>>>                        String sServer
96790>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
96791>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
96792>>>                        Get Value of oServer_fm to sServer
96793>>>                        Set psSeedValue of hoPrompt to sServer
96794>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
96795>>>                    End_Procedure
96796>>>
96796>>>                    Procedure Refresh
96799>>>                        String sValue
96799>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
96800>>>                        Set Value to sValue
96801>>>                    End_Procedure
96802>>>
96802>>>                End_Object
96803>>>
96803>>>                Object oDriverID_cf is a ComboForm
96805>>>                    Set Size to 12 91
96806>>>                    Set Location to 12 222
96807>>>                    Set Label_Col_Offset to 2
96808>>>                    Set Label_Justification_Mode to JMode_Right
96809>>>                    Set Label to "Driver ID"
96810>>>                    Set Entry_State to False
96811>>>                    Set Enabled_State to False
96812>>>
96812>>>                    Procedure Combo_Fill_List
96815>>>                        Send Combo_Add_Item MSSQLDRV_ID
96816>>>                        Send Combo_Add_Item DB2_DRV_ID
96817>>>                        Send Combo_Add_Item ODBC_DRV_ID
96818>>>                    End_Procedure
96819>>>
96819>>>                    Procedure OnChange
96822>>>                        String sValue sOrgValue
96822>>>                        Boolean bEnabled bChecked
96822>>>
96822>>>                        Get Value to sValue
96823>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
96824>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
96826>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
96827>>>                        End
96827>>>>
96827>>>                        Move (sValue <> "None") to bEnabled
96828>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
96830>>>                        Set Enabled_State to False
96831>>>                        Set Enabled_State of oConnectionString_fm to False
96832>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
96833>>>
96833>>>                        Get Checked_State of oTrusted_cb  to bChecked
96834>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
96835>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
96836>>>                    End_Procedure
96837>>>
96837>>>                    Procedure Refresh
96840>>>                        String sValue
96840>>>
96840>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
96841>>>                        Set Value to sValue
96842>>>                    End_Procedure
96843>>>
96843>>>                End_Object
96844>>>
96844>>>                Object oServer_fm is a Form
96846>>>                    Set Size to 12 100
96847>>>                    Set Location to 26 68
96848>>>                    Set Label to "Server"
96849>>>                    Set Label_Col_Offset to 2
96850>>>                    Set Label_Justification_Mode to JMode_Right
96851>>>                    Set Prompt_Button_Mode to PB_PromptOn
96852>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
96853>>>
96853>>>                    Procedure Refresh
96856>>>                        String sValue
96856>>>                        Get psServer of ghoSQLConnectionHandler to sValue
96857>>>                        Set Value to sValue
96858>>>                    End_Procedure
96859>>>
96859>>>                    Procedure Prompt
96862>>>                        String[] sTheData
96863>>>                        String sDriverID
96863>>>                        Handle ho
96863>>>
96863>>>                        Send Cursor_Wait of Cursor_Control
96864>>>                        Get Prompt_Object to ho
96865>>>                        Get Value of oDriverID_cf to sDriverID
96866>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
96867>>>                        Set psTheData of ho to sTheData
96868>>>                        Send Cursor_Ready of Cursor_Control
96869>>>
96869>>>                        Forward Send Prompt
96871>>>                    End_Procedure
96872>>>
96872>>>                End_Object
96873>>>
96873>>>                Object oDatabase_fm is a Form
96875>>>                    Set Size to 12 91
96876>>>                    Set Location to 26 222
96877>>>                    Set Label to "Database"
96878>>>                    Set Label_Col_Offset to 2
96879>>>                    Set Label_Justification_Mode to JMode_Right
96880>>>                    Set Prompt_Button_Mode to PB_PromptOn
96881>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
96882>>>                    Set peAnchors to anNone
96883>>>                    Set Entry_State to False
96884>>>
96884>>>                    Procedure Refresh
96887>>>                        String sDatabase
96887>>>
96887>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
96888>>>                        Set Value to sDatabase
96889>>>                    End_Procedure
96890>>>
96890>>>                    Procedure Prompt
96893>>>                        String[] sTheData
96894>>>                        Handle ho
96894>>>                        String sDriverID
96894>>>
96894>>>                        Get Value of oDriverID_cf to sDriverID
96895>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
96896>>>
96896>>>                        Get Prompt_Object to ho
96897>>>                        Set psTheData of ho to sTheData
96898>>>
96898>>>                        Forward Send Prompt
96900>>>                    End_Procedure
96901>>>
96901>>>                    Procedure OnChange
96904>>>                        String sValue sOrgValue
96904>>>                        Get Value to sValue
96905>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
96906>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
96908>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
96909>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
96910>>>                            Set Value of oConnectionString_fm to sValue
96911>>>                        End
96911>>>>
96911>>>                    End_Procedure
96912>>>
96912>>>                End_Object
96913>>>
96913>>>                Object oTrusted_cb is a CheckBox
96915>>>                    Set Size to 10 50
96916>>>                    Set Location to 45 68
96917>>>                    Set Label to "Use Trusted Connection"
96918>>>
96918>>>                    Procedure Refresh
96921>>>                        Boolean bValue
96921>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
96922>>>                        Set Checked_State to bValue
96923>>>                    End_Procedure
96924>>>
96924>>>                    Procedure OnChange
96927>>>                        Boolean bChecked
96927>>>
96927>>>                        Get Checked_State to bChecked
96928>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
96929>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
96930>>>                    End_Procedure
96931>>>
96931>>>                End_Object
96932>>>
96932>>>                Object oUserID_fm is a Form
96934>>>                    Set Size to 12 100
96935>>>                    Set Location to 57 68
96936>>>                    Set Label to "UserID"
96937>>>                    Set Label_Col_Offset to 2
96938>>>                    Set Label_Justification_Mode to JMode_Right
96939>>>
96939>>>                    Procedure Refresh
96942>>>                        String sValue
96942>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
96943>>>                        Set Value to sValue
96944>>>                    End_Procedure
96945>>>
96945>>>                End_Object
96946>>>
96946>>>                Object oPassword_fm is a Form
96948>>>                    Set Size to 12 91
96949>>>                    Set Location to 57 222
96950>>>                    Set Label to "Password"
96951>>>                    Set Label_Col_Offset to 2
96952>>>                    Set Label_Justification_Mode to JMode_Right
96953>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
96953>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
96954>>>                    Set Password_State to True
96955>>>
96955>>>                    Procedure Refresh
96958>>>                        String sValue
96958>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
96959>>>                        Set Value to sValue
96960>>>                    End_Procedure
96961>>>
96961>>>                End_Object
96962>>>
96962>>>                Object oViewPassword_btn is a cRDCButtonDPI
96964>>>                    Set Size to 12 19
96965>>>                    Set Location to 57 317
96966>>>                    Set psToolTip to "Toggle password"
96967>>>                    Set psImage to "ViewPassword1.ico"
96968>>>                    Set piImageMarginLeft to 0
96969>>>
96969>>>                    Procedure OnClick
96972>>>                        Boolean bState
96972>>>                        Get Password_State of oPassword_fm to bState
96973>>>                        Send Page_Object   of oPassword_fm False
96974>>>                        Set Password_State of oPassword_fm to (not(bState))
96975>>>                        Send Page_Object   of oPassword_fm True
96976>>>                    End_Procedure
96977>>>
96977>>>                End_Object
96978>>>
96978>>>                Object oTestLogin_btn is a cRDCButtonDPI
96980>>>                    Set Size to 12 56
96981>>>                    Set Location to 57 340
96982>>>                    Set Label to "Test Login"
96983>>>                    Set peAnchors to anNone
96984>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
96985>>>                    Set FontWeight to fw_Bold
96986>>>                    Set psImage to "ActionLogin1.ico"
96987>>>                    Set piImageMarginLeft to 0
96988>>>
96988>>>                    Procedure OnClick
96991>>>                        tSQLConnection SQLConnection
96991>>>                        tSQLConnection SQLConnection
96991>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
96991>>>                        Boolean bTrusted bLoginSuccessful
96991>>>                        Integer iDriverID
96991>>>                        Handle hoDriver
96991>>>
96991>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
96992>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
96993>>>                        Get Value of oServer_fm          to SQLConnection.sServer
96994>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
96995>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
96996>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
96997>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
96998>>>
96998>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
96999>>>
96999>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97000>>>                        If (iDriverID = 0) Begin
97002>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97003>>>                            Procedure_Return
97004>>>                        End
97004>>>>
97004>>>
97004>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97007>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97008>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97009>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97010>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97011>>>                        Send Destroy   of hoDriver
97012>>>
97012>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97013>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97015>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97016>>>                            Set Value of oConnectionString_fm to sConnectionString
97017>>>                            Send Info_Box "Login Successful!"
97018>>>                        End
97018>>>>
97018>>>                        Else Begin
97019>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97020>>>                        End
97020>>>>
97020>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97022>>>                        Move 0 to LastErr
97023>>>                    End_Procedure
97024>>>
97024>>>                End_Object
97025>>>
97025>>>                Object oConnectionString_fm is a Form
97027>>>                    Set Size to 12 328
97028>>>                    Set Location to 82 68
97029>>>                    Set Label to "Connection String"    
97030>>>                    Set Label_Col_Offset to 2
97031>>>                    Set Label_Justification_Mode to JMode_Right
97032>>>                    Set peAnchors to anTopLeftRight
97033>>>                    Set Enabled_State to False
97034>>>
97034>>>                    Procedure Refresh
97037>>>                        String sValue
97037>>>                        tSQLConnection SQLConnection
97037>>>                        tSQLConnection SQLConnection
97037>>>
97037>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97038>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97039>>>                        Set Value to sValue
97040>>>                    End_Procedure
97041>>>
97041>>>                End_Object
97042>>>
97042>>>                Object oInfo_tb is a TextBox
97044>>>                    Set Auto_Size_State to False
97045>>>                    Set Size to 18 303
97046>>>                    Set Location to 106 8
97047>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97048>>>                    Set Justification_Mode to JMode_Left
97049>>>                    Set FontItalics to True
97050>>>                End_Object
97051>>>
97051>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97053>>>                    Set Size to 21 83
97054>>>                    Set Location to 106 315
97055>>>                    Set Label to "SQL Connections"
97056>>>                    Set peAnchors to anNone
97057>>>                    Set psImage to "SQLConnections1.ico"
97058>>>
97058>>>                    Procedure OnClick 
97061>>>                        Runprogram Background "DUFSQLConnections.exe"
97062>>>                    End_Procedure
97063>>>
97063>>>                End_Object
97064>>>
97064>>>                Object oGetCollation_btn is a Button
97066>>>                    Set Size to 27 91
97067>>>                    Set Location to 154 38
97068>>>                    Set Label to 'Get Database Collation'
97069>>>                
97069>>>                    Procedure OnClick
97072>>>                        String sCollation sDatabase
97072>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97073>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97074>>>                        Set Value of oGetCollation_fm to sCollation
97075>>>                    End_Procedure
97076>>>                
97076>>>                End_Object
97077>>>
97077>>>                Object oGetCollation_fm is a Form
97079>>>                    Set Size to 12 148
97080>>>                    Set Location to 162 143
97081>>>                    Set Label to "Current SQL Collation Name"
97082>>>                    Set Label_Col_Offset to 0
97083>>>                    Set Label_Row_Offset to 1
97084>>>                    Set Label_Justification_Mode to JMode_Top
97085>>>                End_Object
97086>>>        
97086>>>                Object oSetCollation_btn is a Button
97088>>>                    Set Size to 27 91
97089>>>                    Set Location to 188 38
97090>>>                    Set Label to "Set Database Collation"
97091>>>                
97091>>>                    Procedure OnClick
97094>>>                        String sCollation sDatabase sErrorText
97094>>>                        Boolean bOK
97094>>>                        Integer iRetval  
97094>>>                        tSqlErrorArray aSqlErrorArray
97094>>>                        tSqlErrorArray aSqlErrorArray
97094>>>                        
97094>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97095>>>                        Get Value of oSetCollation_fm to sCollation
97096>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97097>>>                        If (iRetval <> MBR_Yes) Begin
97099>>>                            Procedure_Return
97100>>>                        End
97100>>>>
97100>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97101>>>                        If (bOK = True) Begin
97103>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97104>>>                        End
97104>>>>
97104>>>                        Else Begin                   
97105>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97106>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97107>>>                            Move (sErrorText + "\n")                  to sErrorText
97108>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97109>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97110>>>                        End
97110>>>>
97110>>>
97110>>>                    End_Procedure
97111>>>                
97111>>>                End_Object
97112>>>
97112>>>                Object oSetCollation_fm is a Form
97114>>>                    Set Size to 12 148
97115>>>                    Set Location to 197 143
97116>>>                    Set Label to "New SQL Collation Name"
97117>>>                    Set Label_Col_Offset to 0
97118>>>                    Set Label_Row_Offset to 1
97119>>>                    Set Label_Justification_Mode to JMode_Top
97120>>>                End_Object
97121>>>
97121>>>                Procedure Page Integer iPageObject
97124>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97126>>>                    Forward Send Page iPageObject
97128>>>                End_Procedure
97129>>>
97129>>>            End_Object
97130>>>
97130>>>        End_Object
97131>>>        
97131>>>    End_Object
97132>>>
97132>>>End_Object
97133>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97133>>>Use Windows.pkg
97133>>>Use DFClient.pkg
97133>>>Use Dfspnfrm.pkg
97133>>>Use cDbScrollingContainer.pkg
97133>>>Use cRDCButtonDPI.pkg
97133>>>Use cDbUpdateFunctionLibrary.pkg
97133>>>Use SQLDatabaseBackup.dg
97133>>>
97133>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97143>>>>
97143>>>Object oSQLFunctions_vw is a dbView
97145>>>    Set Border_Style to Border_Thick
97146>>>    Set Size to 260 426
97147>>>    Set Location to -4 2
97148>>>    Set Label to "Functions"
97149>>>    Set pbAutoActivate to True
97150>>>    Set Icon to "Sql1.ico"
97151>>>
97151>>>    Procedure OnSetFocus
97154>>>        String sValue
97154>>>        tSQLConnection SQLConnection
97154>>>        tSQLConnection SQLConnection
97154>>>
97154>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97155>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97156>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97157>>>        Set Value of oSQLConnectionString_fm to sValue
97158>>>    End_Procedure
97159>>>
97159>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97161>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97163>>>
97163>>>            Object oSQLFunctionTests_grp is a Group
97165>>>                Set Size to 243 402
97166>>>                Set Location to 7 12
97167>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97168>>>                Set peAnchors to anAll
97169>>>
97169>>>                Object oSQLConnectionString_fm is a Form
97171>>>                    Set Size to 12 375
97172>>>                    Set Location to 23 14
97173>>>                    Set Label to "Current Connection String Settings:"
97174>>>                    Set Label_Col_Offset to 0
97175>>>                    Set Label_Justification_Mode to JMode_Top
97176>>>                    Set peAnchors to anTopLeftRight
97177>>>                    Set Enabled_State to False
97178>>>                    Set Label_Row_Offset to 1
97179>>>                End_Object
97180>>>
97180>>>                Object oSQLDatabase_fm is a Form
97182>>>                    Set Size to 12 86
97183>>>                    Set Location to 50 14
97184>>>                    Set Label to "Database:"
97185>>>                    Set Label_Col_Offset to 0
97186>>>                    Set Label_Justification_Mode to JMode_Top
97187>>>                    Set Label_Row_Offset to 1
97188>>>                    Set FontWeight to fw_Bold
97189>>>                    Set Enabled_State to False
97190>>>                End_Object
97191>>>
97191>>>                Object oDriverID2_cf is a ComboForm
97193>>>                    Set Size to 12 91
97194>>>                    Set Location to 50 121
97195>>>                    Set Label_Col_Offset to 0
97196>>>                    Set Label_Justification_Mode to JMode_Top
97197>>>                    Set Label to "Driver ID:"
97198>>>                    Set Entry_State to False
97199>>>                    Set Enabled_State to False
97200>>>                    Set Label_Row_Offset to 1
97201>>>
97201>>>                    Procedure Combo_Fill_List
97204>>>                        Send Combo_Add_Item MSSQLDRV_ID
97205>>>                        Send Combo_Add_Item DB2_DRV_ID
97206>>>                        Send Combo_Add_Item ODBC_DRV_ID
97207>>>                    End_Procedure
97208>>>
97208>>>                    Procedure Refresh
97211>>>                        String sValue
97211>>>
97211>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97212>>>                        Set Value to sValue
97213>>>                    End_Procedure
97214>>>
97214>>>                End_Object
97215>>>
97215>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97217>>>                    Set Size to 12 109
97218>>>                    Set Location to 50 220
97219>>>                    Set Label to "Backup MS-SQL Database"
97220>>>                    Set psImage to "DbBackup1.ico"
97221>>>
97221>>>                    Procedure OnClick
97224>>>                        Boolean bOK
97224>>>
97224>>>                        // SQLDatabaseBackup dialog:
97224>>>                        Get MakeSQLDatabaseBackup to bOK
97225>>>
97225>>>                        If (bOK = True) Begin
97227>>>                            Send Info_Box "The backup of the database was successful!"
97228>>>                        End
97228>>>>
97228>>>                        Else Begin
97229>>>                            Send Info_Box "The database was not backup up"
97230>>>                        End
97230>>>>
97230>>>                    End_Procedure
97231>>>
97231>>>                End_Object
97232>>>
97232>>>                Object oDatabaseInfo_tb is a TextBox
97234>>>                    Set Auto_Size_State to False
97235>>>                    Set Size to 25 96
97236>>>                    Set Location to 64 14
97237>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97238>>>                    Set Justification_Mode to JMode_Left
97239>>>                End_Object
97240>>>
97240>>>                Object oSQLInfo_tb is a TextBox
97242>>>                    Set Auto_Size_State to False
97243>>>                    Set Size to 37 270
97244>>>                    Set Location to 76 118
97245>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97246>>>                    Set Justification_Mode to JMode_Left
97247>>>                End_Object
97248>>>
97248>>>                Object oSQLTableName_cf is a ComboForm
97250>>>                    Set Size to 12 96
97251>>>                    Set Location to 106 14
97252>>>                    Set Label_Col_Offset to 0
97253>>>                    Set Label_Justification_Mode to JMode_Top
97254>>>                    Set Label to "Select Table:"
97255>>>                    Set Label_Row_Offset to 1
97256>>>                    Set Entry_State to False
97257>>>
97257>>>                    Procedure OnDropDown
97260>>>                        Send DoCombo_Fill_List
97261>>>                    End_Procedure
97262>>>
97262>>>                    Procedure OnCloseUp
97265>>>                        Send Delete_Data of oSQLColumnName_cf
97266>>>                    End_Procedure
97267>>>
97267>>>                    Procedure DoCombo_Fill_List
97270>>>                        String[] sTablesArray
97271>>>                        String sDriverID
97271>>>                        Integer iCount iSize
97271>>>
97271>>>                        Send Delete_Data
97272>>>                        Get Value of oDriverID2_cf to sDriverID
97273>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97274>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97275>>>                        Decrement iSize
97276>>>                        For iCount from 0 to iSize
97282>>>>
97282>>>                            Send Combo_Add_Item sTablesArray[iCount]
97283>>>                        Loop
97284>>>>
97284>>>                    End_Procedure
97285>>>
97285>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97285>>>                    // Augmented Value function.
97285>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97285>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97285>>>                    Function Value Integer iItem Returns String
97288>>>                        String sValue
97288>>>                        Get WinCombo_Current_Item to iItem
97289>>>                        Get WinCombo_Value iItem  to sValue
97290>>>                        Function_Return sValue
97291>>>                    End_Function
97292>>>
97292>>>                End_Object
97293>>>
97293>>>                Object oSQLColumnName_cf is a ComboForm
97295>>>                    Set Size to 12 96
97296>>>                    Set Location to 134 14
97297>>>                    Set Label_Col_Offset to 0
97298>>>                    Set Label_Justification_Mode to JMode_Top
97299>>>                    Set Label to "Select Column:"
97300>>>                    Set Label_Row_Offset to 1
97301>>>                    Set Entry_State to False
97302>>>
97302>>>                    Procedure DoCombo_Fill_List
97305>>>                        String[] sColumnsArray
97306>>>                        String sTableName sDriverID
97306>>>                        Integer iCount iSize
97306>>>
97306>>>                        Send Delete_Data
97307>>>                        Get Value of oDriverID2_cf    to sDriverID
97308>>>                        Get Value of oSQLTableName_cf to sTableName
97309>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
97310>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
97311>>>                        Decrement iSize
97312>>>                        For iCount from 0 to iSize
97318>>>>
97318>>>                            Send Combo_Add_Item sColumnsArray[iCount]
97319>>>                        Loop
97320>>>>
97320>>>                        If (iSize > 1) Begin
97322>>>                            Set Current_Item to 1
97323>>>                        End
97323>>>>
97323>>>                    End_Procedure
97324>>>
97324>>>                    Procedure OnDropDown
97327>>>                        Send DoCombo_Fill_List
97328>>>                    End_Procedure
97329>>>                End_Object
97330>>>
97330>>>                Object oSQLRenameColumnTo_fm is a Form
97332>>>                    Set Size to 12 96
97333>>>                    Set Location to 134 116
97334>>>                    Set Label_Col_Offset to 0
97335>>>                    Set Label_Justification_Mode to JMode_Top
97336>>>                    Set Label to "Rename Column To:"
97337>>>                    Set Label_Row_Offset to 1
97338>>>                    Set Value to "NewColumnName"
97339>>>                End_Object
97340>>>
97340>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
97342>>>                    Set Size to 12 69
97343>>>                    Set Location to 134 220
97344>>>                    Set Label to "Rename Column"
97345>>>                    Set psToolTip to "Test of SQLColumnRename function"
97346>>>                    Set MultiLineState to True
97347>>>
97347>>>                    Procedure OnClick
97350>>>                        Boolean bOk
97350>>>                        Handle hTable
97350>>>                        String sTableName sColumnName sNewColumnName sDriverID
97350>>>
97350>>>                        Get Value of oSQLTableName_cf to sTableName
97351>>>                        If (sTableName = "") Begin
97353>>>                            Send Info_Box "You need to select a table first..."
97354>>>                            Procedure_Return
97355>>>                        End
97355>>>>
97355>>>                        Get Value of oSQLColumnName_cf to sColumnName
97356>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
97358>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
97359>>>                            Procedure_Return
97360>>>                        End
97360>>>>
97360>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
97361>>>                        If (Trim(sNewColumnName) = "") Begin
97363>>>                            Send Info_Box "You need to enter a column name to rename to..."
97364>>>                            Procedure_Return
97365>>>                        End
97365>>>>
97365>>>
97365>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97366>>>                        If (hTable = 0) Begin
97368>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
97369>>>                            Procedure_Return
97370>>>                        End
97370>>>>
97370>>>
97370>>>                        Get Value of oDriverID2_cf to sDriverID
97371>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97372>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
97373>>>                        If (bOk = True) Begin
97375>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
97375>>>                            Send Delete_Data of oSQLColumnName_cf
97376>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
97377>>>                        End
97377>>>>
97377>>>                        Else Begin
97378>>>                            Send Info_Box "Nope, that didn't work..."
97379>>>                        End
97379>>>>
97379>>>
97379>>>                    End_Procedure
97380>>>
97380>>>                End_Object
97381>>>
97381>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
97383>>>                    Set Size to 12 91
97384>>>                    Set Location to 134 297
97385>>>                    Set Label to "Drop Column"
97386>>>                    Set psToolTip to "Test of SQLColumnRemove function"
97387>>>                    Set psImage to "DeleteColumn1.ico"
97388>>>
97388>>>                    Procedure OnClick
97391>>>                        Boolean bOk
97391>>>                        String sTableName sColumnName sDriverID
97391>>>                        Integer iRetval
97391>>>
97391>>>                        Get Value of oDriverID2_cf              to sDriverID
97392>>>                        Get Value of oSQLTableName_cf           to sTableName
97393>>>                        Get Value of oSQLColumnName_cf          to sColumnName
97394>>>
97394>>>                        If (sTableName = "" or sColumnName = "") Begin
97396>>>                            Send Info_Box "You first need to select a table and a column."
97397>>>                            Procedure_Return
97398>>>                        End
97398>>>>
97398>>>
97398>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
97399>>>                        If (iRetval <> MBR_Yes) Begin
97401>>>                            Procedure_Return
97402>>>                        End
97402>>>>
97402>>>
97402>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
97403>>>
97403>>>                        If (bOk = True) Begin
97405>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
97405>>>                            Send Delete_Data of oSQLColumnName_cf
97406>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
97407>>>                        End
97407>>>>
97407>>>                        Else Begin
97408>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
97409>>>                            Procedure_Return
97410>>>                        End
97410>>>>
97410>>>
97410>>>                    End_Procedure
97411>>>
97411>>>                End_Object
97412>>>
97412>>>                Object oSQLAddColumnName_fm is a Form
97414>>>                    Set Size to 12 96
97415>>>                    Set Location to 177 14
97416>>>                    Set Label_Col_Offset to 0
97417>>>                    Set Label_Justification_Mode to JMode_Top
97418>>>                    Set Label to "Column Name:"
97419>>>                    Set Label_Row_Offset to 1
97420>>>                    Set Value to "NewColumn"
97421>>>                End_Object
97422>>>
97422>>>                Object oSQLColumnType_cf is a ComboForm
97424>>>                    Set Size to 12 96
97425>>>                    Set Location to 177 116
97426>>>                    Set Label_Col_Offset to 0
97427>>>                    Set Label_Justification_Mode to JMode_Top
97428>>>                    Set Label_Row_Offset to 1
97429>>>                    Set Label to "Type:"
97430>>>                    Set Entry_State to False
97431>>>
97431>>>                    Procedure Combo_Fill_List
97434>>>                        tColumnType[] ColumnTypeArray
97434>>>                        tColumnType[] ColumnTypeArray
97435>>>                        Integer iSize iCount iDbType
97435>>>                        String sDriverID
97435>>>
97435>>>                        Send Delete_Data
97436>>>                        Get Value of oDriverID2_cf to sDriverID
97437>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
97438>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
97439>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
97440>>>                        Decrement iSize
97441>>>                        For iCount from 0 to iSize
97447>>>>
97447>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
97448>>>                        Loop
97449>>>>
97449>>>                        If (iSize > 0) Begin
97451>>>                            Set Value to ColumnTypeArray[0].sSQLType
97452>>>                        End
97452>>>>
97452>>>                    End_Procedure
97453>>>
97453>>>                    Procedure OnChange
97456>>>                        Integer iType iSize iDec
97456>>>                        tSQLConnection SQLConnection
97456>>>                        tSQLConnection SQLConnection
97456>>>                        Boolean bFixed
97456>>>
97456>>>                        Get SelectedType to iType
97457>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97458>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
97459>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
97460>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
97461>>>
97461>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
97462>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
97463>>>                        Set Value         of oSQLLength_sf   to iSize
97464>>>                        If (iDec = 0) Begin
97466>>>                            Set Value     of oSQLDecimals_sf to ""
97467>>>                        End
97467>>>>
97467>>>                        Else Begin
97468>>>                            Set Value     of oSQLDecimals_sf to iDec
97469>>>                        End
97469>>>>
97469>>>                        If (bFixed = False) Begin
97471>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
97472>>>                        End
97472>>>>
97472>>>                    End_Procedure
97473>>>
97473>>>                    Function SelectedType Returns Integer
97476>>>                        String sValue sDriverID
97476>>>                        Integer iType iDbType
97476>>>
97476>>>                        Get Value to sValue
97477>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
97478>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
97479>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
97480>>>
97480>>>                        Function_Return iType
97481>>>                    End_Function
97482>>>
97482>>>                End_Object
97483>>>
97483>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
97485>>>                    Set Size to 12 69
97486>>>                    Set Location to 177 220
97487>>>                    Set Label to "Add Column"
97488>>>                    Set psToolTip to "Test of SQLColumnAdd function"
97489>>>                    Set psImage to "AddColumn1.ico"
97490>>>
97490>>>                    Procedure OnClick
97493>>>                        Boolean bOk bInitialize
97493>>>                        Handle hTable
97493>>>                        String sTableName sColumnName sType sColumnValue sDriverID
97493>>>                        Integer iType iLength iDecimals
97493>>>
97493>>>                        Get Value of oDriverID2_cf              to sDriverID
97494>>>                        Get Value of oSQLTableName_cf           to sTableName
97495>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
97496>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
97497>>>                        Get Value         of oSQLColumnType_cf  to sType
97498>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
97499>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
97500>>>                        Get Value         of oSQLLength_sf      to iLength
97501>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
97502>>>
97502>>>                        If (sTableName <> "") Begin
97504>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97505>>>                            If (hTable = 0) Begin
97507>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97508>>>                            End
97508>>>>
97508>>>                        End
97508>>>>
97508>>>                        If (hTable = 0) Begin
97510>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
97511>>>                            Procedure_Return
97512>>>                        End
97512>>>>
97512>>>                        If (sColumnName = "") Begin
97514>>>                            Send Info_Box "You need to enter a column name"
97515>>>                            Procedure_Return
97516>>>                        End
97516>>>>
97516>>>
97516>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
97517>>>
97517>>>                        If (bOk = True) Begin
97519>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
97520>>>                        End
97520>>>>
97520>>>                        Else Begin
97521>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
97522>>>                            Procedure_Return
97523>>>                        End
97523>>>>
97523>>>
97523>>>                    End_Procedure
97524>>>
97524>>>                End_Object
97525>>>
97525>>>//                Object oTest_btn is a cRDCButtonDPI
97525>>>//                    Set Size to 13 92
97525>>>//                    Set Location to 177 298
97525>>>//                    Set Label to "Test SQL script button"
97525>>>//
97525>>>//                    Procedure OnClick
97525>>>//                        Boolean bOK
97525>>>//                        String sTableName sColumnName
97525>>>//
97525>>>//                        Get Value of oSQLTableName_cf      to sTableName
97525>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
97525>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
97525>>>//
97525>>>//                    End_Procedure
97525>>>//
97525>>>//                End_Object
97525>>>
97525>>>                Object oSQLLength_sf is a SpinForm
97527>>>                    Set Label to "Length:"
97528>>>                    Set Size to 12 40
97529>>>                    Set Location to 202 16
97530>>>                    Set Label_Col_Offset to 0
97531>>>                    Set Label_Justification_Mode to JMode_Top
97532>>>                    Set Label_Row_Offset to 1
97533>>>                    Set Value to "10"
97534>>>                    Set Maximum_Position to 500
97535>>>                    Set Minimum_Position to 1
97536>>>                End_Object
97537>>>
97537>>>                Object oSQLDecimals_sf is a SpinForm
97539>>>                    Set Label to "Decimals:"
97540>>>                    Set Size to 12 33
97541>>>                    Set Location to 202 60
97542>>>                    Set Label_Col_Offset to 0
97543>>>                    Set Label_Justification_Mode to JMode_Top
97544>>>                    Set Label_Row_Offset to 1
97545>>>                    Set Value to "0"
97546>>>                    Set Maximum_Position to 16
97547>>>                    Set Minimum_Position to 1
97548>>>                End_Object
97549>>>
97549>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
97551>>>                    Set Size to 12 85
97552>>>                    Set Location to 202 116
97553>>>                    Set Label to "Initialize Column Value"
97554>>>
97554>>>                    Procedure OnChange
97557>>>                        Boolean bChecked
97557>>>
97557>>>                        Get Checked_State to bChecked
97558>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
97559>>>                    End_Procedure
97560>>>
97560>>>                End_Object
97561>>>
97561>>>                Object oSQLColumnValue_fm is a Form
97563>>>                    Set Size to 12 96
97564>>>                    Set Location to 218 116
97565>>>                    Set Label_Col_Offset to 2
97566>>>                    Set Label_Justification_Mode to JMode_Right
97567>>>                    Set Label to "Column Value"
97568>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
97569>>>                    Set Enabled_State to False
97570>>>                End_Object
97571>>>
97571>>>                Object oEnumRelations_btn is a cRDCButtonDPI
97573>>>                    Set Size to 12 91
97574>>>                    Set Location to 116 297
97575>>>                    Set Label to "Test Enum SQL Relations"
97576>>>
97576>>>                    Procedure OnClick
97579>>>                        tSQLRelation[] SQLRelationArray
97579>>>                        tSQLRelation[] SQLRelationArray
97580>>>                        String sTableName sDriverID
97580>>>                        Integer iSize iCount
97580>>>
97580>>>                        Get Value of oDriverID2_cf to sDriverID
97581>>>                        Get Value of oSQLTableName_cf to sTableName
97582>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
97583>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
97584>>>                        Decrement iSize
97585>>>                        For iCount from 0 to iSize
97591>>>>
97591>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
97600>>>                        Loop
97601>>>>
97601>>>                        If (iSize < 1) Begin
97603>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
97604>>>                        End
97604>>>>
97604>>>
97604>>>                    End_Procedure
97605>>>
97605>>>                End_Object
97606>>>
97606>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
97608>>>                    Set Size to 12 101
97609>>>                    Set Location to 177 297
97610>>>                    Set Label to "Enumerate Logged In Users"
97611>>>
97611>>>                    Procedure OnClick
97614>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97614>>>                        tSQLLoggedInUser[] SQLLoggedInUser
97615>>>                        String sDriverID sDatabase
97615>>>                        Integer iSize iCount
97615>>>
97615>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97616>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
97617>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
97618>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
97619>>>                        Decrement iSize
97620>>>
97620>>>                        Showln "SQL User Name" " and Program:"
97623>>>                        For iCount from 0 to iSize
97629>>>>
97629>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
97633>>>                        Loop
97634>>>>
97634>>>                    End_Procedure
97635>>>
97635>>>                End_Object
97636>>>
97636>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
97638>>>                    Set Size to 12 101
97639>>>                    Set Location to 193 297
97640>>>                    Set Label to "Is Table or View?"
97641>>>
97641>>>                    Procedure OnClick
97644>>>                        String sDriverID sTableName
97644>>>                        Handle hTable
97644>>>                        Boolean bViewTableType
97644>>>
97644>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97645>>>                        Get Value of oSQLTableName_cf to sTableName
97646>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97647>>>                        If (hTable = 0) Begin
97649>>>                            Procedure_Return
97650>>>                        End
97650>>>>
97650>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
97651>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
97652>>>                    End_Procedure
97653>>>
97653>>>                End_Object
97654>>>
97654>>>            End_Object
97655>>>
97655>>>        End_Object
97656>>>
97656>>>    End_Object
97657>>>
97657>>>End_Object
97658>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
97658>>>Use Windows.pkg
97658>>>Use DFClient.pkg
97658>>>Use Dfspnfrm.pkg
97658>>>Use Dfline.pkg
97658>>>Use cDbScrollingContainer.pkg
97658>>>Use cRDCButtonDPI.pkg
97658>>>Use cDbUpdateFunctionLibrary.pkg
97658>>>
97658>>>Define CI_Table1_FileNo for 401
97658>>>Define CI_View1_FileNo  for 402
97658>>>
97658>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
97668>>>>
97668>>>Object oAPIFunctions_vw is a dbView
97670>>>    Set Border_Style to Border_Thick
97671>>>    Set Size to 237 424
97672>>>    Set Location to 17 2
97673>>>    Set Label to "API Functions"
97674>>>    Set pbAutoActivate to True
97675>>>    Set Icon to "APIFunctions1.ico"
97676>>>
97676>>>    Property String psTableName ""
97678>>>
97678>>>    Procedure OnSetFocus
97681>>>        String sValue
97681>>>        tSQLConnection SQLConnection
97681>>>        tSQLConnection SQLConnection
97681>>>
97681>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97682>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
97683>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97684>>>        Set Value of oApiConnectionString_fm to sValue
97685>>>    End_Procedure
97686>>>
97686>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97688>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97690>>>
97690>>>            Object oApiFunctions_grp is a Group
97692>>>                Set Size to 222 402
97693>>>                Set Location to 6 12
97694>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
97695>>>                Set peAnchors to anAll
97696>>>
97696>>>                Object oApiConnectionString_fm is a Form
97698>>>                    Set Size to 12 368
97699>>>                    Set Location to 23 14
97700>>>                    Set Label to "Current Connection String Settings:"
97701>>>                    Set Label_Col_Offset to 0
97702>>>                    Set Label_Justification_Mode to JMode_Top
97703>>>                    Set peAnchors to anTopLeftRight
97704>>>                    Set Enabled_State to False
97705>>>                    Set Label_Row_Offset to 1
97706>>>                End_Object
97707>>>
97707>>>                Object oApiDatabase_fm is a Form
97709>>>                    Set Size to 12 86
97710>>>                    Set Location to 50 14
97711>>>                    Set Label to "Database:"
97712>>>                    Set Label_Col_Offset to 0
97713>>>                    Set Label_Justification_Mode to JMode_Top
97714>>>                    Set Label_Row_Offset to 1
97715>>>                    Set Enabled_State to False
97716>>>                    Set FontWeight to fw_Bold
97717>>>//                    Set Label_FontWeight to fw_Bold
97717>>>
97717>>>                    Procedure Page Integer iPageObject
97720>>>                        String sValue
97720>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
97721>>>                        Set Value to sValue
97722>>>
97722>>>                        Forward Send Page iPageObject
97724>>>                    End_Procedure
97725>>>
97725>>>                End_Object
97726>>>
97726>>>                Object oDriverID3_cf is a ComboForm
97728>>>                    Set Size to 12 91
97729>>>                    Set Location to 51 121
97730>>>                    Set Label_Col_Offset to 0
97731>>>                    Set Label_Justification_Mode to JMode_Top
97732>>>                    Set Label to "Driver ID:"
97733>>>                    Set Entry_State to False
97734>>>                    Set Enabled_State to False
97735>>>                    Set Label_Row_Offset to 1
97736>>>                    Set Enabled_State to False
97737>>>
97737>>>                    Procedure Combo_Fill_List
97740>>>                        Send Combo_Add_Item MSSQLDRV_ID
97741>>>                        Send Combo_Add_Item DB2_DRV_ID
97742>>>                        Send Combo_Add_Item ODBC_DRV_ID
97743>>>                    End_Procedure
97744>>>
97744>>>                    Procedure Refresh
97747>>>                        String sValue
97747>>>
97747>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97748>>>                        Set Value to sValue
97749>>>                    End_Procedure
97750>>>
97750>>>                End_Object
97751>>>
97751>>>                Object oDatabaseInfo_tb is a TextBox
97753>>>                    Set Auto_Size_State to False
97754>>>                    Set Size to 25 96
97755>>>                    Set Location to 64 14
97756>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97757>>>                    Set Justification_Mode to JMode_Left
97758>>>                End_Object
97759>>>
97759>>>                Object oApiTableName_fm is a Form
97761>>>                    Set Size to 12 77
97762>>>                    Set Location to 114 14
97763>>>                    Set Label_Col_Offset to 0
97764>>>                    Set Label_Justification_Mode to JMode_Top
97765>>>                    Set Label to "Table Name:"
97766>>>                    Set Label_Row_Offset to 1
97767>>>                    Set Value to "NewTable"
97768>>>                    Procedure OnChange
97771>>>                        String sValue
97771>>>                        Get Value to sValue
97772>>>                        Set psTableName to sValue
97773>>>                    End_Procedure
97774>>>                    Send OnChange
97775>>>                End_Object
97776>>>
97776>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
97778>>>                    Set Size to 12 69
97779>>>                    Set Location to 114 271
97780>>>                    Set Label to "Add Table"
97781>>>                    Set psImage to "ActionAddTable1.ico"
97782>>>
97782>>>                    Procedure OnClick
97785>>>                        Boolean bOk
97785>>>                        Handle hTable
97785>>>                        String sTableName sDriverID
97785>>>
97785>>>                        Get Value of oDriverID3_cf to sDriverID
97786>>>                        Get Value of oApiTableName_fm to sTableName
97787>>>                        Move (Trim(sTableName)) to sTableName
97788>>>                        If (sTableName = "") Begin
97790>>>                            Send Info_Box "You first need to enter a table name."
97791>>>                            Procedure_Return
97792>>>                        End
97792>>>>
97792>>>
97792>>>                        Send Cursor_Wait of Cursor_Control
97793>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97794>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97795>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
97796>>>                        If (bOk = True) Begin
97798>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
97799>>>                        End
97799>>>>
97799>>>                        Else Begin
97800>>>                            Send Cursor_Ready of Cursor_Control
97801>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
97802>>>                            Procedure_Return
97803>>>                        End
97803>>>>
97803>>>
97803>>>                    End_Procedure
97804>>>
97804>>>                End_Object
97805>>>
97805>>>                Object oApiAddColumn_fm is a Form
97807>>>                    Set Size to 12 77
97808>>>                    Set Location to 141 14
97809>>>                    Set Label_Col_Offset to 0
97810>>>                    Set Label_Justification_Mode to JMode_Top
97811>>>                    Set Label to "Column Name:"
97812>>>                    Set Label_Row_Offset to 1
97813>>>                    Set Value to "NewColumn"
97814>>>                End_Object
97815>>>
97815>>>                Object oApiColumnType_cf is a ComboForm
97817>>>                    Set Size to 12 85
97818>>>                    Set Location to 141 96
97819>>>                    Set Label_Col_Offset to 0
97820>>>                    Set Label_Justification_Mode to JMode_Top
97821>>>                    Set Label_Row_Offset to 1
97822>>>                    Set Label to "Type:"
97823>>>                    Set Entry_State to False
97824>>>
97824>>>                    Procedure Combo_Fill_List
97827>>>                        tColumnType[] ColumnTypeArray
97827>>>                        tColumnType[] ColumnTypeArray
97828>>>                        Integer iSize iCount
97828>>>
97828>>>                        Send Delete_Data
97829>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
97830>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
97831>>>                        Decrement iSize
97832>>>                        For iCount from 0 to iSize
97838>>>>
97838>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
97839>>>                        Loop
97840>>>>
97840>>>                        Set Value to ColumnTypeArray[0].sSQLType
97841>>>                    End_Procedure
97842>>>
97842>>>                    Procedure OnChange
97845>>>                        Integer iType iSize iDec
97845>>>                        tSQLConnection SQLConnection
97845>>>                        tSQLConnection SQLConnection
97845>>>                        Boolean bFixed
97845>>>
97845>>>                        Get SelectedType to iType
97846>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97847>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
97848>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
97849>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
97850>>>
97850>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
97851>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
97852>>>                        Set Value         of oApiLength_sf   to iSize
97853>>>                        If (iDec = 0) Begin
97855>>>                            Set Value     of oApiDecimals_sf to ""
97856>>>                        End
97856>>>>
97856>>>                        Else Begin
97857>>>                            Set Value     of oApiDecimals_sf to iDec
97858>>>                        End
97858>>>>
97858>>>                        If (bFixed = False) Begin
97860>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
97861>>>                        End
97861>>>>
97861>>>                    End_Procedure
97862>>>
97862>>>                    Function SelectedType Returns Integer
97865>>>                        String sValue
97865>>>                        Integer iType
97865>>>
97865>>>                        Get Value to sValue
97866>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
97867>>>
97867>>>                        Function_Return iType
97868>>>                    End_Function
97869>>>
97869>>>                End_Object
97870>>>
97870>>>                Object oApiLength_sf is a SpinForm
97872>>>                    Set Label to "Length:"
97873>>>                    Set Size to 12 35
97874>>>                    Set Location to 141 186
97875>>>                    Set Label_Col_Offset to 0
97876>>>                    Set Label_Justification_Mode to JMode_Top
97877>>>                    Set Label_Row_Offset to 1
97878>>>                    Set Value to "10"
97879>>>                    Set Maximum_Position to 500
97880>>>                    Set Minimum_Position to 1
97881>>>                End_Object
97882>>>
97882>>>                Object oApiDecimals_sf is a SpinForm
97884>>>                    Set Label to "Decimals:"
97885>>>                    Set Size to 12 33
97886>>>                    Set Location to 141 225
97887>>>                    Set Label_Col_Offset to 0
97888>>>                    Set Label_Justification_Mode to JMode_Top
97889>>>                    Set Label_Row_Offset to 1
97890>>>                    Set Value to "0"
97891>>>                    Set Maximum_Position to 16
97892>>>                    Set Minimum_Position to 1
97893>>>                End_Object
97894>>>
97894>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
97896>>>                    Set Size to 12 69
97897>>>                    Set Location to 141 271
97898>>>                    Set Label to "Add Column"
97899>>>                    Set psToolTip to "ApiColumnAdd function"
97900>>>                    Set psImage to "ActionAddColumn1.ico"
97901>>>
97901>>>                    Procedure OnClick
97904>>>                        Boolean bOk
97904>>>                        Handle hTable
97904>>>                        String sTableName sColumnName sType sDriverID
97904>>>                        Integer iType iLength iDecimals
97904>>>
97904>>>                        Get Value of oDriverID3_cf            to sDriverID
97905>>>                        Get Value of oApiTableName_fm         to sTableName
97906>>>                        Get Value of oApiAddColumn_fm         to sColumnName
97907>>>                        Get SelectedType of oApiColumnType_cf to iType
97908>>>                        Get Value        of oApiLength_sf     to iLength
97909>>>                        Get Value        of oApiDecimals_sf   to iDecimals
97910>>>
97910>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97911>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97912>>>                        If (hTable = 0) Begin
97914>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
97915>>>                            Procedure_Return
97916>>>                        End
97916>>>>
97916>>>                        If (sColumnName = "") Begin
97918>>>                            Send Info_Box "You need to enter a column name"
97919>>>                            Procedure_Return
97920>>>                        End
97920>>>>
97920>>>
97920>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
97921>>>                        If (bOk = True) Begin
97923>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
97924>>>                        End
97924>>>>
97924>>>                        Else Begin
97925>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
97926>>>                            Procedure_Return
97927>>>                        End
97927>>>>
97927>>>
97927>>>                    End_Procedure
97928>>>
97928>>>                End_Object
97929>>>
97929>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
97931>>>                    Set Size to 26 77
97932>>>                    Set Location to 184 14
97933>>>                    Set Label to "Create 'New' Table with Three Columns"
97934>>>                    Set MultiLineState to True
97935>>>                    Set psImage to "ActionAddTable1.ico"
97936>>>
97936>>>                    Procedure OnClick
97939>>>                        Boolean bOk
97939>>>                        Handle hTable
97939>>>                        String sTableName sDriverID
97939>>>
97939>>>                        Get Value of oDriverID3_cf to sDriverID
97940>>>                        Get Value of oApiTableName_fm to sTableName
97941>>>                        Move (Trim(sTableName)) to sTableName
97942>>>                        If (sTableName = "") Begin
97944>>>                            Send Info_Box "You first need to enter a table name."
97945>>>                            Procedure_Return
97946>>>                        End
97946>>>>
97946>>>
97946>>>                        Send Cursor_Wait of Cursor_Control
97947>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
97948>>>
97948>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
97949>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
97950>>>                        If (bOk = True) Begin
97952>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
97953>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
97954>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
97955>>>                        End
97955>>>>
97955>>>                        Send Cursor_Ready of Cursor_Control
97956>>>
97956>>>                        If (bOk = True) Begin
97958>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
97959>>>                        End
97959>>>>
97959>>>                        Else Begin
97960>>>                            Send Cursor_Ready of Cursor_Control
97961>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
97962>>>                            Procedure_Return
97963>>>                        End
97963>>>>
97963>>>
97963>>>                    End_Procedure
97964>>>
97964>>>                End_Object
97965>>>
97965>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
97967>>>                    Set Size to 26 77
97968>>>                    Set Location to 184 96
97969>>>                    Set Label to "Remove 'New' Table"
97970>>>                    Set psImage to "ActionDeleteTable1.ico"
97971>>>                    Set MultiLineState to True
97972>>>
97972>>>                    Procedure OnClick
97975>>>                        Boolean bOk
97975>>>                        Integer iRetval
97975>>>                        Handle hTable
97975>>>                        String sTableName sDriverID
97975>>>
97975>>>                        Get Value of oDriverID3_cf to sDriverID
97976>>>                        Get Value of oApiTableName_fm to sTableName
97977>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
97978>>>                        If (iRetval = MBR_Yes) Begin
97980>>>                            Send Cursor_Wait of Cursor_Control
97981>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
97982>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
97983>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
97984>>>                            Send Cursor_Ready of Cursor_Control
97985>>>                            If (bOk = True) Begin
97987>>>                                Send Info_Box "Table removed"
97988>>>                            End
97988>>>>
97988>>>                            Else Begin
97989>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
97990>>>                            End
97990>>>>
97990>>>                        End
97990>>>>
97990>>>                    End_Procedure
97991>>>
97991>>>                End_Object
97992>>>
97992>>>                Object oLineControl1 is a LineControl
97994>>>                    Set Size to 2 387
97995>>>                    Set Location to 96 6
97996>>>                    Set peAnchors to anTopLeftRight
97997>>>                End_Object
97998>>>
97998>>>                Object oLineControl2 is a LineControl
98000>>>                    Set Size to 3 248
98001>>>                    Set Location to 171 9
98002>>>                End_Object
98003>>>
98003>>>                Object oTestError_fm is a Form
98005>>>                    Set Size to 13 64
98006>>>                    Set Location to 186 180
98007>>>                    Set Form_Datatype to 0 
98008>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98009>>>                End_Object
98010>>>
98010>>>Register_Function FetchErrorDescription Integer iError Returns String
98010>>>                Object oFindErrorText_Btn is a Button
98012>>>                    Set Size to 13 70
98013>>>                    Set Location to 186 248
98014>>>                    Set Label to "Find Error Text"
98015>>>                
98015>>>                    Procedure OnClick
98018>>>                        String sRetval
98018>>>                        Integer iError 
98018>>>                        Handle hoLogFile
98018>>>                        
98018>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98019>>>                        Get Value of oTestError_fm to iError
98020>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98021>>>                        Set Value of oErrorText_fm to sRetval    
98022>>>                    End_Procedure
98023>>>                
98023>>>                End_Object
98024>>>
98024>>>                Object oErrorText_fm is a Form
98026>>>                    Set Size to 13 213
98027>>>                    Set Location to 202 180
98028>>>                End_Object
98029>>>
98029>>>            End_Object
98030>>>
98030>>>        End_Object
98031>>>
98031>>>    End_Object
98032>>>
98032>>>End_Object
98033>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98033>>>
98033>>>Use Windows.pkg
98033>>>Use DFClient.pkg
98033>>>Use Dfline.pkg
98033>>>Use cDbScrollingContainer.pkg
98033>>>Use cRDCButtonDPI.pkg
98033>>>Use cDbUpdateFunctionLibrary.pkg
98033>>>Use Dftreevw.pkg
98033>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98033>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98033>>>>>//
98033>>>>>// This program is free software; you can redistribute it and/or
98033>>>>>// modify it under the terms of the GNU General Public License
98033>>>>>// as published by the Free Software Foundation; version 2
98033>>>>>// of the License.
98033>>>>>
98033>>>>>// This program is distributed in the hope that it will be useful,
98033>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98033>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98033>>>>>// GNU General Public License for more details.
98033>>>>>
98033>>>>>// You should have received a copy of the GNU General Public License
98033>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98033>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98033>>>>>Use Windows.pkg
98033>>>>>
98033>>>>>Object oWorkingMessagePanel is a ToolPanel
98035>>>>>    Set Label    to "Working"
98036>>>>>    Set Size to 48 150
98037>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98038>>>>>    Set Popup_State to True
98039>>>>>
98039>>>>>    Object oWorkingMessage is a Textbox
98041>>>>>        Set Label to "Working message..."
98042>>>>>        Set Location to 15 5
98043>>>>>        Set Size to 27 123
98044>>>>>        Set Auto_Size_State to False
98045>>>>>        Set Justification_Mode to JMode_Center
98046>>>>>        Set FontWeight to fw_Bold
98047>>>>>    End_Object
98048>>>>>
98048>>>>>End_Object
98049>>>>>
98049>>>>>Procedure StartWorkingMessage Global String sText
98051>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98052>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98053>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98054>>>>>End_Procedure
98055>>>>>
98055>>>>>Procedure StopWorkingMessage Global
98057>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98058>>>>>End_Procedure
98059>>>Use DUFStatusPanel.pkg
98059>>>Use cCharTranslate.pkg
98059>>>
98059>>>Struct tFilelistDUF
98059>>>    Integer iFileNumber
98059>>>    String sLogicalName
98059>>>    String sRootName
98059>>>    String sDisplayName
98059>>>End_Struct
98059>>>
98059>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98069>>>>
98069>>>Object oUtilFunctions_vw is a dbView
98071>>>    Set Border_Style to Border_Thick
98072>>>    Set Size to 291 428
98073>>>    Set Location to 2 1
98074>>>    Set Label to "Utility Functions"
98075>>>    Set pbAutoActivate to True
98076>>>    Set Icon to "TestTools1.ico"
98077>>>    Set pbAcceptDropFiles to True
98078>>>
98078>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98080>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98082>>>
98082>>>            Object oSQL_grp is a Group
98084>>>                Set Size to 88 402
98085>>>                Set Location to 7 12
98086>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98087>>>                Set peAnchors to anTopLeftRight
98088>>>
98088>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98090>>>                    Set Size to 14 219
98091>>>                    Set Location to 13 13
98092>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98093>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98094>>>                    Set psImage to "ActionCreateDatabase1.ico"
98095>>>
98095>>>                    Procedure OnClick
98098>>>                        String sInfoText sDriverID
98098>>>                        Boolean bOK
98098>>>                        TimeSpan tsTotalQueryTime
98098>>>                        Integer iRetval
98098>>>
98098>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98098>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98098>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98098>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98099>>>                        If (iRetval <> MBR_Yes) Begin
98101>>>                            Procedure_Return
98102>>>                        End
98102>>>>
98102>>>
98102>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98103>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98105>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98106>>>                            Procedure_Return
98107>>>                        End
98107>>>>
98107>>>
98107>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98108>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98109>>>                        Send StopWorkingMessage
98110>>>
98110>>>                        If (bOK = True) Begin
98112>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98113>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98114>>>                        End
98114>>>>
98114>>>
98114>>>                        Else Begin
98115>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98116>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98117>>>                        End
98117>>>>
98117>>>
98117>>>                        Send Info_Box sInfoText
98118>>>                    End_Procedure
98119>>>
98119>>>                End_Object
98120>>>
98120>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98122>>>                    Set Size to 14 219
98123>>>                    Set Location to 33 13
98124>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98125>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98126>>>                    Set psImage to "ActionCreateDatabase1.ico"
98127>>>
98127>>>                    Procedure OnClick
98130>>>                        String sInfoText sDriverID
98130>>>                        Boolean bOK
98130>>>                        TimeSpan tsTotalQueryTime
98130>>>                        Integer iRetval
98130>>>
98130>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98130>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98130>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98130>>>
98130>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98131>>>                        If (iRetval <> MBR_Yes) Begin
98133>>>                            Procedure_Return
98134>>>                        End
98134>>>>
98134>>>
98134>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98135>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98137>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98138>>>                            Procedure_Return
98139>>>                        End
98139>>>>
98139>>>
98139>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98140>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98141>>>                        Send StopWorkingMessage
98142>>>
98142>>>                        If (bOK = True) Begin
98144>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98145>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98146>>>                        End
98146>>>>
98146>>>
98146>>>                        Else Begin
98147>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98148>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98149>>>                        End
98149>>>>
98149>>>
98149>>>                        Send Info_Box sInfoText
98150>>>                    End_Procedure
98151>>>
98151>>>                End_Object
98152>>>
98152>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98154>>>                    Set Size to 14 219
98155>>>                    Set Location to 53 13
98156>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98157>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98158>>>                    Set psImage to "ActionCreateDatabase1.ico"
98159>>>
98159>>>                    Procedure OnClick
98162>>>                        String sInfoText sDriverID
98162>>>                        Boolean bOK
98162>>>                        TimeSpan tsTotalQueryTime
98162>>>                        Integer iRetval
98162>>>
98162>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98162>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98162>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98162>>>
98162>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98163>>>                        If (iRetval <> MBR_Yes) Begin
98165>>>                            Procedure_Return
98166>>>                        End
98166>>>>
98166>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98167>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98169>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98170>>>                            Procedure_Return
98171>>>                        End
98171>>>>
98171>>>
98171>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98172>>>
98172>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98173>>>
98173>>>                        Send StopWorkingMessage
98174>>>                        If (bOK = True) Begin
98176>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98177>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98178>>>                        End
98178>>>>
98178>>>
98178>>>                        Else Begin
98179>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98180>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98181>>>                        End
98181>>>>
98181>>>
98181>>>                        Send Info_Box sInfoText
98182>>>                    End_Procedure
98183>>>
98183>>>                End_Object
98184>>>
98184>>>                Object oInfo_tb is a TextBox
98186>>>                    Set Auto_Size_State to False
98187>>>                    Set Size to 25 158
98188>>>                    Set Location to 53 238
98189>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98190>>>                    Set Justification_Mode to JMode_Left
98191>>>                    Set peAnchors to anTopLeftRight
98192>>>                End_Object
98193>>>
98193>>>        //  This will choke the computer so don't try it!
98193>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98193>>>        //            Set Size to 14 312
98193>>>        //            Set Location to 97 45
98193>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98193>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98193>>>        //
98193>>>        //            Procedure OnClick
98193>>>        //                String sInfoText
98193>>>        //                Boolean bOK
98193>>>        //                TimeSpan tsTotalQueryTime
98193>>>        //                Integer iRetval
98193>>>        //
98193>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98193>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98193>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98193>>>        //Procedure_Return
98193>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98193>>>        //                If (iRetval <> MBR_Yes) Begin
98193>>>        //                    Procedure_Return
98193>>>        //                End
98193>>>        //
98193>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98193>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98193>>>        //                Send StopWorkingMessage
98193>>>        //
98193>>>        //                If (bOK = True) Begin
98193>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98193>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98193>>>        //                End
98193>>>        //
98193>>>        //                Else Begin
98193>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98193>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98193>>>        //                End
98193>>>        //
98193>>>        //                Send Info_Box sInfoText
98193>>>        //            End_Procedure
98193>>>        //
98193>>>        //        End_Object
98193>>>
98193>>>            End_Object
98194>>>
98194>>>            Object oChangeIntFiles_grp is a Group
98196>>>                Set Size to 65 402
98197>>>                Set Location to 102 12
98198>>>                Set Label to "Change Old .int files to use Connection ID's"
98199>>>                Set peAnchors to anTopLeftRight
98200>>>
98200>>>                Object oSelectDataPath_fm is a Form
98202>>>                    Set Size to 12 300
98203>>>                    Set Location to 22 13
98204>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98205>>>                    Set Label_Col_Offset to 0
98206>>>                    Set Label_Row_Offset to 1
98207>>>                    Set Label_Justification_Mode to JMode_Top
98208>>>
98208>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98208>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98208>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98209>>>                    Set peAnchors to anTopLeftRight
98210>>>
98210>>>                    Procedure Prompt
98213>>>                        String sPath sFileMask sRetval
98213>>>
98213>>>                        Get psDataPathFirstPart to sPath
98214>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98215>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98216>>>                        If (sRetval <> "") Begin
98218>>>                            Get ParseFolderName sRetval to sPath
98219>>>                            If (Right(sPath, 1) ="\") Begin
98221>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98222>>>                            End
98222>>>>
98222>>>                            Set Value to sPath
98223>>>                        End
98223>>>>
98223>>>                    End_Procedure
98224>>>
98224>>>                    // Returns the first datapath found in the psDataPath property.
98224>>>                    // The returned path always ends with a "\"
98224>>>                    Function psDataPathFirstPart Returns String
98227>>>                        String sDataPath
98227>>>                        Integer iCount
98227>>>
98227>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98228>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98229>>>                        If (iCount > 1) Begin
98231>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98232>>>                        End
98232>>>>
98232>>>                        If (sDataPath <> "") Begin
98234>>>                            Get vFolderFormat sDataPath to sDataPath
98235>>>                        End
98235>>>>
98235>>>
98235>>>                        Function_Return sDataPath
98236>>>                    End_Function
98237>>>
98237>>>                End_Object
98238>>>
98238>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98240>>>                    Set Size to 13 73
98241>>>                    Set Location to 22 320
98242>>>                    Set Label to "Select Folder"
98243>>>                    Set psToolTip to "Please select an .int file from the data folder"
98244>>>                    Set peAnchors to anTopRight
98245>>>                    Set psImage to "ActionOpen1.ico"
98246>>>
98246>>>                    Procedure OnClick
98249>>>                        Send Prompt to oSelectDataPath_fm
98250>>>                    End_Procedure
98251>>>
98251>>>                End_Object
98252>>>
98252>>>                Object oConnectionID_fm is a Form
98254>>>                    Set Size to 13 111
98255>>>                    Set Location to 38 202
98256>>>                    Set Label_Col_Offset to 2
98257>>>                    Set Label_Justification_Mode to JMode_Right
98258>>>                    Set Label to "Change to DFConnID:"
98259>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98260>>>                    Set peAnchors to anTopRight
98261>>>                End_Object
98262>>>
98262>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98264>>>                    Set Size to 13 68
98265>>>                    Set Location to 38 320
98266>>>                    Set Label to "GO !"
98267>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98268>>>                    Set FontWeight to fw_Bold
98269>>>                    Set peAnchors to anTopRight
98270>>>
98270>>>                    Procedure OnClick
98273>>>                        String sDataPath sConnectionID
98273>>>                        Boolean bExists bActive
98273>>>                        Integer iRetval
98273>>>
98273>>>                        Get Value of oSelectDataPath_fm to sDataPath
98274>>>                        Get vFolderExists sDataPath to bExists
98275>>>                        If (bExists = False) Begin
98277>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98278>>>                            Procedure_Return
98279>>>                        End
98279>>>>
98279>>>                        Get Value of oConnectionID_fm to sConnectionID
98280>>>                        Move (Trim(sConnectionID)) to sConnectionID
98281>>>                        If (sConnectionID = "") Begin
98283>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98284>>>                            Procedure_Return
98285>>>                        End
98285>>>>
98285>>>
98285>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98286>>>                        If (iRetval <> MBR_Yes) Begin
98288>>>                            Procedure_Return
98289>>>                        End
98289>>>>
98289>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98290>>>                        If (iRetval <> MBR_Yes) Begin
98292>>>                            Procedure_Return
98293>>>                        End
98293>>>>
98293>>>
98293>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
98294>>>                        If (iRetval <> 0) Begin
98296>>>                            Send Info_Box "Could not delete .cch files!"
98297>>>                            Procedure_Return
98298>>>                        End
98298>>>>
98298>>>
98298>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
98299>>>                        Send Start_StatusPanel of ghoStatusPanel
98300>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
98301>>>
98301>>>                        Get Active_State of ghoStatusPanel to bActive
98302>>>                        If (bActive = False) Begin
98304>>>                            Send Info_Box "Process interupted..."
98305>>>                        End
98305>>>>
98305>>>                        Else Begin
98306>>>                            Send Stop_StatusPanel of ghoStatusPanel
98307>>>                            Send Info_Box "Ready! All .int files changed."
98308>>>                        End
98308>>>>
98308>>>                    End_Procedure
98309>>>
98309>>>                End_Object
98310>>>
98310>>>            End_Object
98311>>>
98311>>>            Object oRemoveFilelistDriverIDs_grp is a Group
98313>>>                Set Size to 59 402
98314>>>                Set Location to 171 12
98315>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
98316>>>                Set peAnchors to anTopLeftRight
98317>>>//                Set TextColor to clGreen
98317>>>//
98317>>>//                Procedure Page Integer iPage
98317>>>//                    Integer ia iz
98317>>>//                    Forward Send Page iPage
98317>>>//                    Move 0 to iz
98317>>>//                    Move (AddressOf(iz)) to ia
98317>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
98317>>>//                End_Procedure
98317>>>
98317>>>                Object oFilelistPath_fm is a Form
98319>>>                    Set Size to 13 299
98320>>>                    Set Location to 22 13
98321>>>                    Set Label to "Path and Filelist.cfg Name:"
98322>>>                    Set Label_Col_Offset to 0
98323>>>                    Set Label_Row_Offset to 1
98324>>>                    Set Label_Justification_Mode to JMode_Top
98325>>>
98325>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98325>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98325>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
98326>>>                    Set peAnchors to anTopLeftRight
98327>>>
98327>>>                    Procedure Prompt
98330>>>                        String sFileName sPath sFileMask sRetval
98330>>>
98330>>>                        Get Value to sFileName
98331>>>                        Get ParseFolderName sFileName to sPath
98332>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
98333>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
98334>>>                        If (sRetval <> "") Begin
98336>>>                            Set Value to sRetval
98337>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
98340>>>                        End
98340>>>>
98340>>>                    End_Procedure
98341>>>
98341>>>                    Procedure OnCreate
98344>>>                        String sFilelist
98344>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
98347>>>                        Set Value to sFilelist
98348>>>                    End_Procedure
98349>>>                    Send OnCreate
98350>>>
98350>>>                End_Object
98351>>>
98351>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
98353>>>                    Set Size to 13 73
98354>>>                    Set Location to 22 319
98355>>>                    Set Label to "Select Filelist.cfg"
98356>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
98357>>>                    Set peAnchors to anTopRight
98358>>>
98358>>>                    Procedure OnClick
98361>>>                        Send Prompt to oFilelistPath_fm
98362>>>                    End_Procedure
98363>>>
98363>>>                End_Object
98364>>>
98364>>>                Object oInfo_tb is a TextBox
98366>>>                    Set Size to 9 207
98367>>>                    Set Location to 40 138
98368>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
98369>>>                    Set peAnchors to anTopRight
98370>>>                End_Object
98371>>>
98371>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
98373>>>                    Set Size to 13 68
98374>>>                    Set Location to 38 319
98375>>>                    Set Label to "GO !"
98376>>>                    Set FontWeight to fw_Bold
98377>>>                    Set peAnchors to anTopRight
98378>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
98379>>>
98379>>>                    Procedure OnClick
98382>>>                        String sFileList
98382>>>                        Integer iRetval iCount
98382>>>                        Boolean bExits
98382>>>
98382>>>                        Get Value of oFilelistPath_fm to sFileList
98383>>>                        Get vFilePathExists sFileList to bExits
98384>>>                        If (bExits = False) Begin
98386>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
98387>>>                            Procedure_Return
98388>>>                        End
98388>>>>
98388>>>
98388>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
98389>>>                        If (iRetval <> MBR_Yes) Begin
98391>>>                            Procedure_Return
98392>>>                        End
98392>>>>
98392>>>                        Send Cursor_Wait of Cursor_Control
98393>>>
98393>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
98394>>>
98394>>>                        Send Cursor_Ready of Cursor_Control
98395>>>                        If (iCount <> 0) Begin
98397>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
98398>>>                        End
98398>>>>
98398>>>                        Else Begin
98399>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
98400>>>                        End
98400>>>>
98400>>>
98400>>>                    End_Procedure
98401>>>
98401>>>                End_Object
98402>>>
98402>>>            End_Object
98403>>>
98403>>>            Object oOutput_grp is a Group
98405>>>                Set Size to 47 402
98406>>>                Set Location to 234 12
98407>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
98408>>>                Set peAnchors to anTopLeftRight
98409>>>
98409>>>                Object oOutput_rg is a RadioGroup
98411>>>                    Set Location to 18 13
98412>>>                    Set Size to 25 288
98413>>>                    Set Label to "Filelist Output Order"
98414>>>
98414>>>                    Object oRadio1 is a Radio
98416>>>                        Set Label to "Filelist Number"
98417>>>                        Set Size to 10 61
98418>>>                        Set Location to 10 7
98419>>>                    End_Object
98420>>>
98420>>>                    Object oRadio2 is a Radio
98422>>>                        Set Label to "Logical Name"
98423>>>                        Set Size to 10 61
98424>>>                        Set Location to 10 77
98425>>>                    End_Object
98426>>>
98426>>>                    Object oRadio3 is a Radio
98428>>>                        Set Label to "Root Name"
98429>>>                        Set Size to 10 61
98430>>>                        Set Location to 10 147
98431>>>                    End_Object
98432>>>
98432>>>                    Object oRadio4 is a Radio
98434>>>                        Set Label to "Display Name"
98435>>>                        Set Size to 10 62
98436>>>                        Set Location to 10 213
98437>>>                    End_Object
98438>>>
98438>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
98441>>>                        Forward Send Notify_Select_State iToItem iFromItem
98443>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
98444>>>                    End_Procedure
98445>>>
98445>>>                End_Object
98446>>>                
98446>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
98448>>>                    Set Size to 13 78
98449>>>                    Set Location to 26 315
98450>>>                    Set Label to "Print to Filelist.txt"
98451>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
98452>>>                    Set psImage to "ActionDocument1.ico"
98453>>>
98453>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
98455>>>
98455>>>                    // Custom array sort function.
98455>>>                    // iSortOrder = 0 -> Filelist number order
98455>>>                    // iSortOrder = 1 -> Logical name order
98455>>>                    // iSortOrder = 2 -> Root name order
98455>>>                    // iSortOrder = 3 -> Display name order
98455>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
98458>>>                        Integer iSortOrder
98458>>>
98458>>>                        Get piSortOrder to iSortOrder
98459>>>
98459>>>                        Case Begin
98459>>>                            Case (iSortOrder = 0)
98461>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
98463>>>                                    Function_Return (GT)
98464>>>                                End
98464>>>>
98464>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
98466>>>                                    Function_Return (LT)
98467>>>                                End
98467>>>>
98467>>>                                Function_Return (EQ)
98468>>>                            Case (iSortOrder = 1)
98471>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
98473>>>                                    Function_Return (GT)
98474>>>                                End
98474>>>>
98474>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
98476>>>                                    Function_Return (LT)
98477>>>                                End
98477>>>>
98477>>>                                Function_Return (EQ)
98478>>>                            Case (iSortOrder = 2)
98481>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
98483>>>                                    Function_Return (GT)
98484>>>                                End
98484>>>>
98484>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
98486>>>                                    Function_Return (LT)
98487>>>                                End
98487>>>>
98487>>>                                Function_Return (EQ)
98488>>>                            Case (iSortOrder = 3)
98491>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
98493>>>                                    Function_Return (GT)
98494>>>                                End
98494>>>>
98494>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
98496>>>                                    Function_Return (LT)
98497>>>                                End
98497>>>>
98497>>>                                Function_Return (EQ)
98498>>>                        Case End
98498>>>
98498>>>                    End_Function
98499>>>
98499>>>                    Procedure OnClick
98502>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
98502>>>                        Integer iCh iCount iSize
98502>>>                        Handle hTable
98502>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98502>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
98504>>>
98504>>>                        Get Value of oFilelistPath_fm to sFileList
98505>>>                        Move (Trim(sFileList)) to sFileList
98506>>>                        If (sFileList = "") Begin
98508>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
98509>>>                            Procedure_Return
98510>>>                        End
98510>>>>
98510>>>
98510>>>                        Get ParseFolderName sFileList to sPath
98511>>>                        Get vFolderFormat sPath to sPath
98512>>>                        Get ParseFileName sFileList to sOutputName
98513>>>                        Get ParseFileExtension sFileList to sExt
98514>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
98515>>>                        Move (sOutputName + "txt")           to sOutputName
98516>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
98517>>>                        If (iCh < 0) Begin
98519>>>                            Procedure_Return
98520>>>                        End
98520>>>>
98520>>>
98520>>>                        Move 0 to hTable
98521>>>                        Writeln channel iCh sFileList
98524>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
98527>>>                        Writeln channel iCh "==================================================================================================="
98530>>>                        Writeln channel iCh
98532>>>
98532>>>                        Move 0 to iCount
98533>>>                        Repeat
98533>>>>
98533>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98536>>>                            If (hTable > 0) Begin
98538>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
98539>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
98542>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
98545>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
98548>>>                                Increment iCount
98549>>>                            End
98549>>>>
98549>>>                        Until (hTable = 0)
98551>>>
98551>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
98552>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
98553>>>                        Decrement iSize
98554>>>
98554>>>                        For iCount from 0 to iSize
98560>>>>
98560>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
98561>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
98562>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
98563>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
98564>>>
98564>>>                            Get PadLeft (String(hTable))        09 to sTable
98565>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
98566>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
98567>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
98568>>>
98568>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
98574>>>                        Loop
98575>>>>
98575>>>
98575>>>                        Writeln channel iCh "==================================================================================================="
98578>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
98582>>>                        Close_Output
98583>>>
98583>>>                        Send vShellExecute "open" sOutputName "" sPath
98584>>>                    End_Procedure
98585>>>
98585>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
98588>>>                        String sChar
98588>>>
98588>>>                        If (Num_Arguments >= 3) Begin
98590>>>                            Move sOptChar to sChar
98591>>>                        End
98591>>>>
98591>>>                        Else Begin
98592>>>                            Move " " to sChar
98593>>>                        End
98593>>>>
98593>>>
98593>>>                        While (Length(sString) < iLength)
98597>>>                            Move (sChar + sString) to sString
98598>>>                        Loop
98599>>>>
98599>>>
98599>>>                        Function_Return sString
98600>>>                    End_Function
98601>>>
98601>>>                End_Object
98602>>>            End_Object
98603>>>
98603>>>        End_Object
98604>>>
98604>>>    End_Object
98605>>>
98605>>>    Procedure OnFileDropped String sFilename Boolean bLast
98608>>>        String sTest
98608>>>        Forward Send OnFileDropped sFilename bLast
98610>>>        If (bLast = True) Begin
98612>>>            Get ParseFileName sFilename to sTest
98613>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
98615>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
98616>>>                Procedure_Return
98617>>>            End
98617>>>>
98617>>>            Set Value of oFilelistPath_fm to sFilename
98618>>>        End
98618>>>>
98618>>>    End_Procedure
98619>>>
98619>>>End_Object
98620>
98620>        Procedure Activate_About
98623>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
98624>        End_Procedure
98625>
98625>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
98626>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
98627>        On_Key Key_Ctrl+Key_W             Send Close_Panel
98628>    End_Object
98629>
98629>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
98629>    // in the oHtmlHelp object, so we need to explitetly send the message
98629>    // to that object.
98629>    Procedure ShowProgramHelp
98632>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
98633>    End_Procedure
98634>
98634>    On_Key Key_F1 Send ShowProgramHelp
98635>End_Object
98636>
98636>// We do this to activate the first view:
98636>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
98636>Start_UI
98637>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52526
Total Resources: 9
Total Commands : 98636
Total Windows  : 0
Total Pages    : 0
Static Data    : 767741
Message area   : 636476
Total Blocks   : 75336
