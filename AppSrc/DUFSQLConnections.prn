Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFSQLConnections.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 20.1\Pkg\dfallent.pkd)
73081>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardCommandBarSystem.pkg)
73081>>>// these are all the packages used in a standard MDI menubar/toolbar system
73081>>>
73081>>>Use cCJCommandBarSystem.pkg
73081>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardMenuItemClasses.pkg)
73081>>>>>Use Dfpanel.pkg
73081>>>>>Use cCJCommandBarSystem.pkg
73081>>>>>Use LanguageText.pkg
73081>>>>>
73081>>>>>
73081>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73082>>>>>    
73082>>>>>    Procedure Construct_Object
73084>>>>>        Forward Send Construct_Object
73086>>>>>        Set psCaption   to C_$CaptionUndo
73087>>>>>        Set psToolTip to C_$ToolTipUndo
73088>>>>>        Set psDescription to C_$DescUndo
73089>>>>>        Set psImage to "ActionUndo.ico"
73090>>>>>        Set pbActiveUpdate to True
73091>>>>>        Set psCategory to C_$CategoryEdit
73092>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73093>>>>>    End_Procedure
73094>>>>>    
73094>>>>>    Procedure OnExecute Variant vCommandBarControl
73096>>>>>        Send Undo of (focus(Self))
73097>>>>>    End_Procedure
73098>>>>>    
73098>>>>>    Function IsEnabled Returns Boolean
73100>>>>>        Boolean bEnabled
73100>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73101>>>>>        Function_Return bEnabled
73102>>>>>    End_Function
73103>>>>>    
73103>>>>>End_Class
73104>>>>>
73104>>>>>
73104>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73105>>>>>    
73105>>>>>    Procedure Construct_Object
73107>>>>>        Forward Send Construct_Object
73109>>>>>        Set psCaption   to C_$CaptionDelete
73110>>>>>        Set psToolTip to C_$ToolTipDelete
73111>>>>>        Set psDescription to C_$DescDelete
73112>>>>>        Set psImage to "actionDelete.ico"
73113>>>>>        Set psShortcut to C_$Key_Delete
73114>>>>>        Set pbActiveUpdate to True
73115>>>>>        Set psCategory to C_$CategoryEdit
73116>>>>>    End_Procedure
73117>>>>>    
73117>>>>>    
73117>>>>>    Procedure OnExecute Variant vCommandBarControl
73119>>>>>        Send Delete of (focus(Self))
73120>>>>>    End_Procedure
73121>>>>>    
73121>>>>>    Function IsEnabled Returns Boolean
73123>>>>>        Boolean bEnabled
73123>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73124>>>>>        Function_Return bEnabled
73125>>>>>    End_Function
73126>>>>>    
73126>>>>>End_Class
73127>>>>>
73127>>>>>
73127>>>>>Class cCJCutMenuItem is a cCJMenuItem
73128>>>>>    
73128>>>>>    Procedure Construct_Object
73130>>>>>        Forward Send Construct_Object
73132>>>>>        Set psCaption   to C_$CaptionCut
73133>>>>>        Set psToolTip to C_$TooltipCut
73134>>>>>        Set psDescription to C_$DescCut
73135>>>>>        Set psImage to "actionCut.ico"
73136>>>>>        Set psShortcut to C_$Key_Ctrl_X
73137>>>>>        Set pbActiveUpdate to True
73138>>>>>        Set psCategory to C_$CategoryEdit
73139>>>>>    End_Procedure
73140>>>>>    
73140>>>>>    
73140>>>>>    Procedure OnExecute Variant vCommandBarControl
73142>>>>>        Send Cut of (focus(Self))
73143>>>>>    End_Procedure
73144>>>>>    
73144>>>>>    Function IsEnabled Returns Boolean
73146>>>>>        Boolean bEnabled
73146>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73147>>>>>        Function_Return bEnabled
73148>>>>>    End_Function
73149>>>>>    
73149>>>>>End_Class
73150>>>>>
73150>>>>>
73150>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73151>>>>>    
73151>>>>>    Procedure Construct_Object
73153>>>>>        Forward Send Construct_Object
73155>>>>>        Set psCaption   to C_$CaptionCopy
73156>>>>>        Set psToolTip to C_$ToolTipCopy
73157>>>>>        Set psDescription to C_$DescCopy
73158>>>>>        Set psImage to "actionCopy.ico"
73159>>>>>        Set psShortcut to C_$Key_Ctrl_C
73160>>>>>        Set pbActiveUpdate to True
73161>>>>>        Set psCategory to C_$CategoryEdit
73162>>>>>    End_Procedure
73163>>>>>    
73163>>>>>    
73163>>>>>    Procedure OnExecute Variant vCommandBarControl
73165>>>>>        Send Copy of (focus(Self))
73166>>>>>    End_Procedure
73167>>>>>    
73167>>>>>    Function IsEnabled Returns Boolean
73169>>>>>        Boolean bEnabled
73169>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73170>>>>>        Function_Return bEnabled
73171>>>>>    End_Function
73172>>>>>    
73172>>>>>End_Class
73173>>>>>
73173>>>>>
73173>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73174>>>>>    
73174>>>>>    Procedure Construct_Object
73176>>>>>        Forward Send Construct_Object
73178>>>>>        Set psCaption   to C_$CaptionPaste
73179>>>>>        Set psToolTip to C_$ToolTipPaste
73180>>>>>        Set psDescription to C_$DescPaste
73181>>>>>        Set psImage to "actionPaste.ico"
73182>>>>>        Set pbActiveUpdate to True
73183>>>>>        Set psShortcut to C_$Key_Ctrl_V
73184>>>>>        Set psCategory to C_$CategoryEdit
73185>>>>>    End_Procedure
73186>>>>>    
73186>>>>>    
73186>>>>>    Procedure OnExecute Variant vCommandBarControl
73188>>>>>        Send Paste of (focus(Self))
73189>>>>>    End_Procedure
73190>>>>>    
73190>>>>>    Function IsEnabled Returns Boolean
73192>>>>>        Boolean bEnabled
73192>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73193>>>>>        Function_Return bEnabled
73194>>>>>    End_Function
73195>>>>>    
73195>>>>>End_Class
73196>>>>>
73196>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73197>>>>>    
73197>>>>>    Procedure Construct_Object
73199>>>>>        Forward Send Construct_Object
73201>>>>>        Set psCaption   to C_$CaptionSelectAll
73202>>>>>        Set psToolTip to C_$ToolTipSelectAll
73203>>>>>        Set psDescription to C_$DescSelectAll
73204>>>>>        Set pbActiveUpdate to True
73205>>>>>        Set psShortcut to C_$Key_Ctrl_A
73206>>>>>        Set psCategory to C_$CategoryEdit
73207>>>>>    End_Procedure
73208>>>>>    
73208>>>>>    
73208>>>>>    Procedure OnExecute Variant vCommandBarControl
73210>>>>>        Send Select_All of (focus(Self))
73211>>>>>    End_Procedure
73212>>>>>    
73212>>>>>    Function IsEnabled Returns Boolean
73214>>>>>        Boolean bEnabled
73214>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73215>>>>>        Function_Return bEnabled
73216>>>>>    End_Function
73217>>>>>    
73217>>>>>End_Class
73218>>>>>
73218>>>>>
73218>>>>>Class cCJExitMenuItem is a cCJMenuItem
73219>>>>>    
73219>>>>>    Procedure Construct_Object
73221>>>>>        Forward Send Construct_Object
73223>>>>>        Set psCaption to C_$CaptionExit
73224>>>>>        Set psToolTip to C_$ToolTipExit
73225>>>>>        Set psDescription to C_$ToolTipExit
73226>>>>>        Set psShortcut to C_$Key_Alt_F4
73227>>>>>        Set psCategory to C_$CategoryFile
73228>>>>>    End_Procedure
73229>>>>>    
73229>>>>>    Procedure OnExecute Variant vCommandBarControl
73231>>>>>        Send Exit_Application of Desktop
73232>>>>>    End_Procedure
73233>>>>>    
73233>>>>>End_Class
73234>>>>>
73234>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73235>>>>>    
73235>>>>>    Procedure Construct_Object
73237>>>>>        Forward Send Construct_Object
73239>>>>>        Set psCaption to C_$CaptionHelp
73240>>>>>        Set psDescription to C_$ToolTipHelp
73241>>>>>        Set psToolTip to C_$DescHelp
73242>>>>>        Set psImage to "ActionHelp.ico"
73243>>>>>        Set psShortcut to "F1"
73244>>>>>        Set psCategory to C_$CategoryHelp
73245>>>>>    End_Procedure
73246>>>>>    
73246>>>>>    Procedure OnExecute Variant vCommandBarControl
73248>>>>>        Send Help of (Focus(Self))
73249>>>>>    End_Procedure
73250>>>>>    
73250>>>>>End_Class
73251>>>>>
73251>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73252>>>>>    
73252>>>>>    Procedure Construct_Object
73254>>>>>        Forward Send Construct_Object
73256>>>>>        Set psCaption to C_$CaptionAddStatusbar
73257>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73258>>>>>        Set psDescription to  C_$DescAddStatusbar
73259>>>>>        Set psCategory to C_$CategoryWindow
73260>>>>>    End_Procedure
73261>>>>>    
73261>>>>>    Procedure OnExecute Variant vCommandBarControl
73263>>>>>        Handle hoCommandBars hoClientArea
73263>>>>>        Get CommandBarSystemObject to hoCommandBars
73264>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73265>>>>>        If hoClientArea Begin
73267>>>>>            // the clientarea's parent panel has message
73267>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73268>>>>>        End
73268>>>>>>
73268>>>>>    End_Procedure
73269>>>>>    
73269>>>>>    Function IsChecked Returns Boolean
73271>>>>>        Boolean bOn
73271>>>>>        Handle hoCommandBars hoClientArea
73271>>>>>        Get CommandBarSystemObject to hoCommandBars
73272>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73273>>>>>        If hoClientArea Begin
73275>>>>>            // the clientarea's parent panel has message
73275>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73276>>>>>        End
73276>>>>>>
73276>>>>>        Function_Return bOn
73277>>>>>    End_Function
73278>>>>>End_Class
73279>>>>>
73279>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73280>>>>>    
73280>>>>>    Procedure Construct_Object
73282>>>>>        Forward Send Construct_Object
73284>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73285>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73286>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73287>>>>>        Set psCategory to C_$CategoryWindow
73288>>>>>    End_Procedure
73289>>>>>    
73289>>>>>    Procedure OnExecute Variant vCommandBarControl
73291>>>>>        Handle hoCommandBars hoClientArea
73291>>>>>        Get CommandBarSystemObject to hoCommandBars
73292>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73293>>>>>        If hoClientArea Begin
73295>>>>>            // the clientarea's parent panel has message
73295>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73296>>>>>        End
73296>>>>>>
73296>>>>>    End_Procedure
73297>>>>>    
73297>>>>>    Function IsChecked Returns Boolean
73299>>>>>        Boolean bOn
73299>>>>>        Handle hoCommandBars hoClientArea
73299>>>>>        Get CommandBarSystemObject to hoCommandBars
73300>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73301>>>>>        If hoClientArea Begin
73303>>>>>            // the clientarea's parent panel has message
73303>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73304>>>>>        End
73304>>>>>>
73304>>>>>        Function_Return bOn
73305>>>>>    End_Function
73306>>>>>End_Class
73307>>>>>
73307>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73308>>>>>    
73308>>>>>    Procedure Construct_Object
73310>>>>>        Forward Send Construct_Object
73312>>>>>        Set psCaption to C_$CaptionRestoreMenus
73313>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73314>>>>>        Set psDescription to C_$DescRestoreMenus
73315>>>>>        Set psCategory to C_$CategoryWindow
73316>>>>>    End_Procedure
73317>>>>>    
73317>>>>>    Procedure OnExecute Variant vCommandBarControl
73319>>>>>        Handle hoCommandBars
73319>>>>>        Get CommandBarSystemObject to hoCommandBars
73320>>>>>        Send RestoreLayout of hoCommandBars
73321>>>>>    End_Procedure
73322>>>>>    
73322>>>>>End_Class
73323>>>>>
73323>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73324>>>>>    
73324>>>>>    Procedure Construct_Object
73326>>>>>        Forward Send Construct_Object
73328>>>>>        Set psCaption to C_$CaptionCascade
73329>>>>>        Set psToolTip to C_$ToolTipCascade
73330>>>>>        Set psDescription to  C_$DescCascade
73331>>>>>        Set psImage to "ActionCascade.ico"
73332>>>>>        Set psCategory to C_$CategoryWindow
73333>>>>>    End_Procedure
73334>>>>>    
73334>>>>>    Procedure OnExecute Variant vCommandBarControl
73336>>>>>        Handle hoCommandBars hoClientArea
73336>>>>>        Get CommandBarSystemObject to hoCommandBars
73337>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73338>>>>>        If hoClientArea Begin
73340>>>>>            Send Cascade_Windows of hoClientArea
73341>>>>>        End
73341>>>>>>
73341>>>>>    End_Procedure
73342>>>>>End_Class
73343>>>>>
73343>>>>>Class cCJTileHorizontally is a cCJMenuItem
73344>>>>>    
73344>>>>>    Procedure Construct_Object
73346>>>>>        Forward Send Construct_Object
73348>>>>>        Set psCaption to C_$CaptionTileHorizontally
73349>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73350>>>>>        Set psDescription to  C_$DescTileHorizontally
73351>>>>>        Set psImage to "ActionTileHorizontally.ico"
73352>>>>>        Set psCategory to C_$CategoryWindow
73353>>>>>    End_Procedure
73354>>>>>    
73354>>>>>    Procedure OnExecute Variant vCommandBarControl
73356>>>>>        Handle hoCommandBars hoClientArea
73356>>>>>        Get CommandBarSystemObject to hoCommandBars
73357>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73358>>>>>        If hoClientArea Begin
73360>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73361>>>>>        End
73361>>>>>>
73361>>>>>    End_Procedure
73362>>>>>End_Class
73363>>>>>
73363>>>>>Class cCJTileVertically is a cCJMenuItem
73364>>>>>    
73364>>>>>    Procedure Construct_Object
73366>>>>>        Forward Send Construct_Object
73368>>>>>        Set psCaption to C_$CaptionTileVertically
73369>>>>>        Set psToolTip to C_$ToolTipTileVertically
73370>>>>>        Set psDescription to  C_$DescTileVertically
73371>>>>>        Set psImage to "ActionTileVertically.ico"
73372>>>>>        Set psCategory to C_$CategoryWindow
73373>>>>>    End_Procedure
73374>>>>>    
73374>>>>>    Procedure OnExecute Variant vCommandBarControl
73376>>>>>        Handle hoCommandBars hoClientArea
73376>>>>>        Get CommandBarSystemObject to hoCommandBars
73377>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73378>>>>>        If hoClientArea Begin
73380>>>>>            Send Tile_Windows_Vertical of hoClientArea
73381>>>>>        End
73381>>>>>>
73381>>>>>    End_Procedure
73382>>>>>End_Class
73383>>>>>
73383>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73384>>>>>    
73384>>>>>    Procedure Construct_Object
73386>>>>>        Forward Send Construct_Object
73388>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73389>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73390>>>>>        Set psDescription to  C_$DescMinimizeWindows
73391>>>>>        Set psCategory to C_$CategoryWindow
73392>>>>>    End_Procedure
73393>>>>>    
73393>>>>>    Procedure OnExecute Variant vCommandBarControl
73395>>>>>        Handle hoCommandBars hoClientArea
73395>>>>>        Get CommandBarSystemObject to hoCommandBars
73396>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73397>>>>>        If hoClientArea Begin
73399>>>>>            // the clientarea's parent panel has message
73399>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73400>>>>>        End
73400>>>>>>
73400>>>>>    End_Procedure
73401>>>>>End_Class
73402>>>>>
73402>>>>>
73402>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73403>>>>>    
73403>>>>>    Procedure Construct_Object
73405>>>>>        Forward Send Construct_Object
73407>>>>>        Set psCaption to C_$CaptionRestoreWindows
73408>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73409>>>>>        Set psDescription to  C_$DescRestoreWindows
73410>>>>>        Set psCategory to C_$CategoryWindow
73411>>>>>    End_Procedure
73412>>>>>    
73412>>>>>    Procedure OnExecute Variant vCommandBarControl
73414>>>>>        Handle hoCommandBars hoClientArea
73414>>>>>        Get CommandBarSystemObject to hoCommandBars
73415>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73416>>>>>        If hoClientArea Begin
73418>>>>>            // the clientarea's parent panel has message
73418>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73419>>>>>        End
73419>>>>>>
73419>>>>>    End_Procedure
73420>>>>>End_Class
73421>>>>>
73421>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73422>>>>>    
73422>>>>>    Procedure Construct_Object
73424>>>>>        Forward Send Construct_Object
73426>>>>>        Set psCaption to C_$CaptionArrangeIcons
73427>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73428>>>>>        Set psDescription to  C_$DescArrangeIcons
73429>>>>>        Set psCategory to C_$CategoryWindow
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Procedure OnExecute Variant vCommandBarControl
73433>>>>>        Handle hoCommandBars hoClientArea
73433>>>>>        Get CommandBarSystemObject to hoCommandBars
73434>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73435>>>>>        If hoClientArea Begin
73437>>>>>            Send Arrange_Icons of hoClientArea
73438>>>>>        End
73438>>>>>>
73438>>>>>    End_Procedure
73439>>>>>    
73439>>>>>End_Class
73440>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJAboutMenuItem.pkg)
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>// It is expected that if you use this class that you provide an about object that is
73440>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73440>>>>>// because you may wish to create your own custom about package.
73440>>>>>
73440>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73441>>>>>
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption to C_$CaptionAbout
73446>>>>>        Set psDescription to C_$ToolTipAbout
73447>>>>>        Set psToolTip to C_$DescAbout
73448>>>>>        Set psImage to "ActionAbout.ico"
73449>>>>>        Set psCategory to C_$CategoryHelp
73450>>>>>    End_Procedure
73451>>>>>    
73451>>>>>    Procedure OnExecute Variant vCommandBarControl
73453>>>>>        Handle hoCommandBars hoClientArea
73453>>>>>        Get CommandBarSystemObject to hoCommandBars
73454>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73455>>>>>        If hoClientArea Begin
73457>>>>>            Send Activate_About of hoClientArea
73458>>>>>        End
73458>>>>>>
73458>>>>>    End_Procedure
73459>>>>>
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>Use cCJDeoMenuItemClasses.pkg
73460>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJMDIWindowsMenuItem.pkg)
73460>>>>>Use cCJCommandBarSystem.pkg
73460>>>>>
73460>>>>>Register_Function Client_ID Returns Integer
73460>>>>>
73460>>>>>// only used by cCJMDIWIndowsMenuItem
73460>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Property Handle phWindow 0 // object id of view
73466>>>>>        Set pbControlFlagNoMovable to True
73467>>>>>        Set pbActiveUpdate to True
73468>>>>>    End_Procedure
73469>>>>>    
73469>>>>>    Procedure OnExecute Variant vCommandBarControl
73471>>>>>        Handle hWindow
73471>>>>>        Get phWindow to hWindow
73472>>>>>        Send Activate_View of hWindow
73473>>>>>    End_Procedure
73474>>>>>    
73474>>>>>End_Class
73475>>>>>
73475>>>>>
73475>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73476>>>>>    
73476>>>>>    Procedure Construct_Object
73478>>>>>        Forward Send Construct_Object
73480>>>>>        Property Handle[] phArrayOfWindows
73481>>>>>        Set peControlType to xtpControlPopup
73482>>>>>        Set psCategory to C_$CategoryWindow
73483>>>>>    End_Procedure
73484>>>>>    
73484>>>>>    // This adds MDI windows to the existing menu items.
73484>>>>>    // This removes any existing windows menus and always adds a new set to the end
73484>>>>>    
73484>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73486>>>>>        Handle  hClientArea hView
73486>>>>>        String  sLabel
73486>>>>>        Integer i iWindows
73486>>>>>        Handle[] hArrayOfWindows
73487>>>>>        Variant vItem
73487>>>>>        
73487>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73487>>>>>        // also assume that destroying an action removes all menu instances of that action
73487>>>>>        Get phArrayOfWindows to hArrayOfWindows
73488>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73489>>>>>        For i from 0 to (iWindows-1)
73495>>>>>>
73495>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73496>>>>>        Loop
73497>>>>>>
73497>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73498>>>>>        
73498>>>>>        // Add all views to this menu. Create the action and add the item
73498>>>>>        Move 0 to i
73499>>>>>        Get Client_Id to hClientArea // object id of client area
73500>>>>>        If (hClientArea > 0) Begin
73502>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73503>>>>>            While (hView <> 0)
73507>>>>>                If (Active_State(hView)) Begin
73509>>>>>                    // create the action
73509>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73510>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73511>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73512>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73513>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73515>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73516>>>>>                    End
73516>>>>>>
73516>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73517>>>>>                    If (i=0) Begin
73519>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73520>>>>>                    End
73520>>>>>>
73520>>>>>                    // Create a menu item for this action
73520>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73521>>>>>                    Increment i
73522>>>>>                End
73522>>>>>>
73522>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73523>>>>>            Loop
73524>>>>>>
73524>>>>>        End
73524>>>>>>
73524>>>>>        
73524>>>>>        Set phArrayOfWindows to hArrayOfWindows
73525>>>>>        
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>End_Class
73527>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
73527>>>// This code is part of VDF GUIdance
73527>>>// Visit us @ http://www.vdf-guidance.com
73527>>>// e-Mail us @ info@vdf-guidance.com
73527>>>// VDF GUIdance is a mutual project of
73527>>>// Frank Vandervelpen - Vandervelpen Systems and
73527>>>// Wil van Antwerpen  - Antwise Solutions
73527>>>// All software source code should be used <<AS IS>> without any warranty.
73527>>>//
73527>>>//
73527>>>// *** Windows 32bit file handling wrapper class ***
73527>>>//
73527>>>
73527>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
73527>>>//                   This may be painfull for some of you, but it was really needed as it was
73527>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
73527>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
73527>>>//
73527>>>// The used naming-convention is:
73527>>>//     - a prefix of "vWin32_" for every external function declaration
73527>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
73527>>>//
73527>>>// By using this we are guarding ourselves for conflicts with variable declarations
73527>>>// of DataAccess in the future.
73527>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
73527>>>//
73527>>>// mm-dd-yyyy Author Description
73527>>>//
73527>>>//                   vSHGetFolderPath added to retrieve the new shell folders
73527>>>//                   vGetWindowsDirectory
73527>>>//
73527>>>//                   vGetTempFileName
73527>>>//                   vGetTempPath
73527>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
73527>>>//                   This is an absolute need for WebApp. We expect you to handle the
73527>>>//                   error in your application anyways. Changed this for:
73527>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
73527>>>// 03-02-2002 **WvA: vRemoveDirectory added
73527>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
73527>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
73527>>>//                   It is renamed too avoid this.
73527>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
73527>>>//                   function vSelectedFileName is now just SelectedFileName
73527>>>//                   Removed the local keyword in the variable declarations
73527>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
73527>>>//                   created file-open dialog
73527>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
73527>>>//                   in that it didn't exactly return the correct filename of the file created.
73527>>>//                   This has now been taken care of.
73527>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
73527>>>//                   These declarations are now included from the vWin32fh header file.
73527>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
73527>>>//                   Before today one could always undo the operation, as of now you cannot as
73527>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
73527>>>//                   Since i don't really expect someone to use that feature it has been removed.
73527>>>//                   One can however restore to the old way of handling by simply calling the
73527>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
73527>>>//                   filehandling operations
73527>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
73527>>>//                   as well as the StringFromRightOfChar function.
73527>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
73527>>>//                   DISABLED now as testing shows that it does not work as advertised...
73527>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
73527>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
73527>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
73527>>>//                   extended characters are treated ok too.
73527>>>//                   Reported by Flemming from
73527>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
73527>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
73527>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
73527>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
73527>>>//                   Added vSelectSavefile function to create a file save dialog
73527>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
73527>>>//                   Added vParentPath function to retrieve the parent "node" of a path
73527>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
73527>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
73527>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
73527>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
73527>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
73527>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
73527>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
73527>>>
73527>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
73527>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
73527>>>>>//***************************************************************************
73527>>>>>//*
73527>>>>>//* Class:        cvSaveAsDialog
73527>>>>>//* Package Name: cvFileDialogs.pkg
73527>>>>>//*
73527>>>>>//***************************************************************************
73527>>>>>
73527>>>>>Use File_dlg.pkg
73527>>>>>
73527>>>>>// *WvA: 13-01-1999 Created
73527>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
73527>>>>>// This function opens the Windows standard file open dialog and returns the selected
73527>>>>>// file_name.
73527>>>>>Class cvSelectFile_Dialog is an OpenDialog
73528>>>>>
73528>>>>>    Procedure Construct_Object Integer iImage_Id
73530>>>>>        Forward Send Construct_Object iImage_Id
73532>>>>>        Set HideReadOnly_State to True
73533>>>>>    End_Procedure
73534>>>>>
73534>>>>>    Function SelectedFileName Returns String
73536>>>>>        String sFileName
73536>>>>>        Move "" to sFileName
73537>>>>>        If (Show_Dialog(Self)) Begin
73539>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73540>>>>>        End
73540>>>>>>
73540>>>>>        Function_Return sFileName
73541>>>>>    End_Function
73542>>>>>End_Class
73543>>>>>
73543>>>>>// *WvA: 13-01-1999 Created
73543>>>>>// This function opens the Windows standard file open dialog and returns the selected
73543>>>>>// file_name. Returns '' if the user didn't make a selection.
73543>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
73543>>>>>//                   file-open dialog
73543>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
73545>>>>>    String sSelectedFile
73545>>>>>    Integer hoOpenFileDialog
73545>>>>>
73545>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
73547>>>>>
73547>>>>>        Set Dialog_Caption    to sCaptionText
73548>>>>>        Set Filter_String     to sSupportedFileTypes
73549>>>>>        Set Initial_Folder    to sInitialFolder
73550>>>>>
73550>>>>>        Move Self       to hoOpenFileDialog
73551>>>>>    End_Object
73552>>>>>
73552>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
73553>>>>>    Send Destroy_Object to hoOpenFileDialog
73554>>>>>    Function_Return sSelectedFile
73555>>>>>End_Function
73556>>>>>
73556>>>>>Class cvSaveAsDialog is a SaveAsDialog
73557>>>>>
73557>>>>>    Procedure Construct_Object
73559>>>>>        Forward Send Construct_Object
73561>>>>>        Set HideReadOnly_State to True
73562>>>>>    End_Procedure
73563>>>>>
73563>>>>>    Function SelectedFileName Returns String
73565>>>>>        String sFileName
73565>>>>>        Move "" to sFileName
73566>>>>>        If (Show_Dialog(Self)) Begin
73568>>>>>            Move (RTrim(File_Name(Self))) to sFileName
73569>>>>>        End
73569>>>>>>
73569>>>>>        Function_Return sFileName
73570>>>>>    End_Function
73571>>>>>
73571>>>>>End_Class
73572>>>>>
73572>>>>>// Added optional default filename as suggested by Nils
73572>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
73574>>>>>    String sSelectedFile
73574>>>>>    Integer hoDialog
73574>>>>>
73574>>>>>    Move "" to sSelectedFile
73575>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
73576>>>>>    If (hoDialog) Begin
73578>>>>>    //Set NoChangeDir_State Of hoDialog To True
73578>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
73579>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
73580>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
73581>>>>>        If (Num_Arguments = 4) Begin
73583>>>>>            Set File_Title        of hoDialog to sDefaultFileName
73584>>>>>        End
73584>>>>>>
73584>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
73585>>>>>        Send Destroy of hoDialog
73586>>>>>    End
73586>>>>>>
73586>>>>>    Function_Return sSelectedFile
73587>>>>>End_Function
73588>>>Use Seq_chnl.pkg
73588>>>
73588>>>Use windows.pkg
73588>>>Use Dll.pkg
73588>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
73588>>>>>//TH-Header
73588>>>>>//*****************************************************************************************
73588>>>>>// Copyright (c)  2004 KURANT Project
73588>>>>>// All rights reserved.
73588>>>>>//
73588>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
73588>>>>>// $ProjectName : Windows 32 bits file handling
73588>>>>>// $Authors     : Wil van Antwerpen
73588>>>>>// $Created     : 19.02.2004  19:25
73588>>>>>// $Type        : BSD (as in do with it whatever you like)
73588>>>>>//
73588>>>>>// Contents:
73588>>>>>//  This file contains the Windows API external function call definitions and
73588>>>>>//  constants as they are used in the vWin32fh package.
73588>>>>>//*****************************************************************************************
73588>>>>>//TH-RevisionStart
73588>>>>>//TH-RevisionEnd
73588>>>>>
73588>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
73588>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
73588>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
73588>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
73588>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
73588>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
73588>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
73588>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
73588>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
73588>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
73588>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
73588>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
73588>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
73588>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
73588>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73588>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
73588>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
73588>>>>>
73588>>>>>
73588>>>>>Define vMax_Path     For |CI260
73588>>>>>Define vMinChar      For |CI$80
73588>>>>>Define vMaxChar      For |CI$7F
73588>>>>>Define vMinShort     For |CI$8000
73588>>>>>Define vMaxShort     For |CI$7FFF
73588>>>>>Define vMinLong      For |CI$80000000
73588>>>>>Define vMaxLong      For |CI$7FFFFFFF
73588>>>>>Define vMaxByte      For |CI$FF
73588>>>>>Define vMaxWord      For |CI$FFFF
73588>>>>>Define vMaxDword     For |CI$FFFFFFFF
73588>>>>>
73588>>>>>
73588>>>>>
73588>>>>>// For FindFirstFile
73588>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
73588>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
73588>>>>>Define vERROR_NO_MORE_FILES    For |CI18
73588>>>>>
73588>>>>>// The defines below can be used to find out what kind of error has occurred if
73588>>>>>// the API-call ShellExecute is used.
73588>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
73588>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
73588>>>>>Define vERROR_BAD_FORMAT       For |CI0011
73588>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
73588>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
73588>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
73588>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
73588>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
73588>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
73588>>>>>Define vSE_ERR_FNF             For |CI0002
73588>>>>>Define vSE_ERR_NOASSOC         For |CI0031
73588>>>>>Define vSE_ERR_OOM             For |CI0008
73588>>>>>Define vSE_ERR_PNF             For |CI0003
73588>>>>>Define vSE_ERR_SHARE           For |CI0026
73588>>>>>
73588>>>>>
73588>>>>>// C-Structure
73588>>>>>//typedef struct _browseinfo {
73588>>>>>//    HWND hwndOwner;
73588>>>>>//    LPCITEMIDLIST pidlRoot;
73588>>>>>//    LPSTR pszDisplayName;
73588>>>>>//    LPCSTR lpszTitle;
73588>>>>>//    UINT ulFlags;
73588>>>>>//    BFFCALLBACK lpfn;
73588>>>>>//    LPARAM lParam;
73588>>>>>//    int iImage;
73588>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
73588>>>>>
73588>>>>>//declare C structure struct_browseinfo
73588>>>>>//as documented in MSDN under Windows Shell API
73588>>>>>Struct tvBrowseInfo
73588>>>>>  Handle    hWndOwner
73588>>>>>  Pointer   pIDLRoot
73588>>>>>  Pointer   pszDisplayName
73588>>>>>  Pointer   lpszTitle
73588>>>>>  dWord     ulFlags
73588>>>>>  Pointer   lpfnCallback
73588>>>>>  dWord     lParam
73588>>>>>  DWord     iImage
73588>>>>>End_Struct // tvBrowseInfo
73588>>>>>
73588>>>>>// Browsing for directory.
73588>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
73588>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
73588>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
73588>>>>>                                            // The callback function can set the status text by
73588>>>>>                                            // sending messages to the dialog box.
73588>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
73588>>>>>
73588>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
73588>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
73588>>>>>
73588>>>>>// message from browser
73588>>>>>//Define BFFM_INITIALIZED        1
73588>>>>>//Define BFFM_SELCHANGED         2
73588>>>>>
73588>>>>>// messages to browser
73588>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
73588>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
73588>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
73588>>>>>
73588>>>>>
73588>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
73589>>>>>
73589>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
73590>>>>>
73590>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
73591>>>>>
73591>>>>>
73591>>>>>
73591>>>>>
73591>>>>>Struct tvSecurity_attributes
73591>>>>>  DWord   nLength
73591>>>>>  Pointer lpDescriptor
73591>>>>>  Integer bInheritHandle
73591>>>>>End_Struct // tvSecurity_attributes
73591>>>>>
73591>>>>>//nLength:
73591>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
73591>>>>>// SECURITY_ATTRIBUTES structure.
73591>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
73591>>>>>// value of the nLength member. However, an application should still set it properly.
73591>>>>>// That ensures current, future, and cross-platform compatibility.
73591>>>>>//
73591>>>>>//lpSecurityDescriptor:
73591>>>>>// Points to a security descriptor for the object that controls the sharing of it.
73591>>>>>// If NULL is specified for this member, the object may be assigned the default security
73591>>>>>// descriptor of the calling process.
73591>>>>>//
73591>>>>>//bInheritHandle:
73591>>>>>// Specifies whether the returned handle is inherited when a new process is created.
73591>>>>>// If this member is TRUE, the new process inherits the handle.
73591>>>>>
73591>>>>>
73591>>>>>// BOOL CreateDirectory(
73591>>>>>//    LPCTSTR lpPathName,
73591>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
73591>>>>>//   );
73591>>>>>//
73591>>>>>// lpPathName
73591>>>>>//  Points to a null-terminated string that specifies the path of the directory
73591>>>>>//  to be created.
73591>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73591>>>>>//  This limit is related to how the CreateDirectory function parses paths.
73591>>>>>// lpSecurityAttributes
73591>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
73591>>>>>//  determines whether the returned handle can be inherited by child processes.
73591>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
73591>>>>>// Returns:
73591>>>>>//  If the function succeeds, the return value is nonzero.
73591>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73591>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
73592>>>>>
73592>>>>>
73592>>>>>// lpPathName
73592>>>>>//  Points to a null-terminated string that specifies the path of the directory
73592>>>>>//  to be removed.
73592>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
73592>>>>>// Returns:
73592>>>>>//  If the function succeeds, the return value is nonzero.
73592>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
73592>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
73593>>>>>
73593>>>>>
73593>>>>>
73593>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
73593>>>>>// executable file or a document file.
73593>>>>>//
73593>>>>>// Operation can be one of the following:
73593>>>>>//    "OPEN"  The function opens the file specified by lpFile.
73593>>>>>//            The file can be an executable file or a document file.
73593>>>>>//            The file can be a folder to open.
73593>>>>>//    "PRINT" The function prints the file specified by lpFile.
73593>>>>>//            The file should be a document file. If the file is an executable file,
73593>>>>>//            the function opens the file, as if "open" had been specified.
73593>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
73593>>>>>//
73593>>>>>// Return Values:
73593>>>>>//
73593>>>>>// If the function succeeds, the return value is the instance handle of the application that
73593>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
73593>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
73593>>>>>//
73593>>>>>// The following table lists these error values:
73593>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
73593>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
73593>>>>>// Public Const ERROR_BAD_FORMAT = 11&
73593>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
73593>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
73593>>>>>// Public Const SE_ERR_DDEBUSY = 30
73593>>>>>// Public Const SE_ERR_DDEFAIL = 29
73593>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
73593>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
73593>>>>>// Public Const SE_ERR_FNF = 2
73593>>>>>// Public Const SE_ERR_NOASSOC = 31
73593>>>>>// Public Const SE_ERR_OOM = 8
73593>>>>>// Public Const SE_ERR_PNF = 3
73593>>>>>// Public Const SE_ERR_SHARE = 26
73593>>>>>
73593>>>>>
73593>>>>>
73593>>>>>// Code to open the program that is associated with the selected file.
73593>>>>>//
73593>>>>>// External function call used in Procedure DoStartDocument
73593>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
73594>>>>>
73594>>>>>
73594>>>>>
73594>>>>>
73594>>>>>Define vFO_MOVE                For |CI$0001
73594>>>>>Define vFO_COPY                For |CI$0002
73594>>>>>Define vFO_DELETE              For |CI$0003
73594>>>>>Define vFO_RENAME              For |CI$0004
73594>>>>>
73594>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
73594>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
73594>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
73594>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
73594>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
73594>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
73594>>>>>                                          // Must be freed using SHFreeNameMappings
73594>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
73594>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
73594>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
73594>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
73594>>>>>
73594>>>>>Struct tvShFileOpStruct
73594>>>>>  Handle  hWnd
73594>>>>>  Integer wFunc
73594>>>>>  Pointer pFrom
73594>>>>>  Pointer pTo
73594>>>>>  Short   fFlags
73594>>>>>  Short   fAnyOperationsAborted
73594>>>>>  Pointer hNameMappings
73594>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
73594>>>>>End_Struct // tvShFileOpStruct
73594>>>>>
73594>>>>>// hwnd
73594>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
73594>>>>>
73594>>>>>// wFunc
73594>>>>>//   Operation to perform. This member can be one of the following values:
73594>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
73594>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
73594>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
73594>>>>>//     FO_RENAME   Renames the files specified by pFrom.
73594>>>>>
73594>>>>>// pFrom
73594>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
73594>>>>>//   be null-separated. The list of names must be double null-terminated.
73594>>>>>
73594>>>>>// pTo
73594>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
73594>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
73594>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
73594>>>>>//   double null-terminated.
73594>>>>>
73594>>>>>// fAnyOperationsAborted
73594>>>>>//   Value that receives TRUE if the user aborted any file operations before they
73594>>>>>//   were completed or FALSE otherwise.
73594>>>>>
73594>>>>>
73594>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
73594>>>>>// This can be a file or a folder.
73594>>>>>// With thanks to Andrew S Kaplan
73594>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
73595>>>>>
73595>>>>>
73595>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
73595>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
73596>>>>>
73596>>>>>
73596>>>>>
73596>>>>>// Courtesy Of Vincent Oorsprong
73596>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
73596>>>>>//   Pointer lpPathName ;
73596>>>>>//   Pointer lpPrefixString ;
73596>>>>>//   Integer uUnique ;
73596>>>>>//   Pointer lpTempFileName ;
73596>>>>>//   Returns Integer
73596>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
73596>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
73597>>>>>
73597>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
73598>>>>>
73598>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
73599>>>>>
73599>>>>>// from:
73599>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
73599>>>>>//
73599>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
73599>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
73599>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
73599>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
73599>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
73599>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
73599>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
73599>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
73599>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
73599>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
73599>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
73599>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
73599>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
73599>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
73599>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
73599>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
73599>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
73599>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
73599>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
73599>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
73599>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
73599>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
73599>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
73599>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
73599>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
73599>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
73599>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
73599>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
73599>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
73599>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
73599>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
73599>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
73599>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
73599>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
73599>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
73599>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
73599>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
73599>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
73599>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
73599>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
73599>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
73599>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
73599>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
73599>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
73599>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
73599>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
73599>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
73599>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
73599>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
73599>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
73599>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
73599>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
73599>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
73599>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
73599>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
73599>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
73599>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
73599>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
73599>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
73599>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
73599>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
73599>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
73599>>>>>
73599>>>>>
73599>>>>>//HRESULT SHGetFolderPath(
73599>>>>>//    HWND hwndOwner,
73599>>>>>//    int nFolder,
73599>>>>>//    HANDLE hToken,
73599>>>>>//    DWORD dwFlags,
73599>>>>>//    LPTSTR pszPath
73599>>>>>//);
73599>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
73599>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
73599>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
73599>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
73599>>>>>// If that fails, it will try to simulate the appropriate behavior.
73599>>>>>//
73599>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
73600>>>>>
73600>>>>>
73600>>>>>
73600>>>>>Struct tvWin32FindData
73600>>>>> Dword            dwFileAttributes
73600>>>>> Dword            ftCreationLowDateTime
73600>>>>> Dword            ftCreationHighDateTime
73600>>>>> dword            ftLastAccessLowDateTime
73600>>>>> Dword            ftLastAccessHighDateTime
73600>>>>> Dword            ftLastWriteLowDateTime
73600>>>>> Dword            ftLastWriteHighDateTime
73600>>>>> Dword            nFileSizeHigh
73600>>>>> Dword            nFileSizeLow
73600>>>>> Dword            dwReserved0
73600>>>>> Dword            dwReserved1
73600>>>>> UChar[vMax_Path] cFileName
73600>>>>> UChar[14]        cAlternateFileName
73600>>>>>End_Struct
73600>>>>>
73600>>>>>// Courtesy Of Vincent Oorsprong
73600>>>>>// lpFileName      : address of name of file to search for
73600>>>>>// lpFindFileData  : address of returned information
73600>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
73601>>>>>
73601>>>>>// Courtesy Of Vincent Oorsprong
73601>>>>>// hFindFile       : handle of search
73601>>>>>// lpFindFileData  : address of structure for data on found file
73601>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73602>>>>>
73602>>>>>//
73602>>>>>// Unicode equivalents
73602>>>>>//
73602>>>>>// lpFileName      : address of name of file to search for
73602>>>>>// lpFindFileData  : address of returned information
73602>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
73603>>>>>
73603>>>>>// hFindFile       : handle of search
73603>>>>>// lpFindFileData  : address of structure for data on found file
73603>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
73604>>>>>
73604>>>>>
73604>>>>>// Courtesy Of Vincent Oorsprong
73604>>>>>//  hFindFile      : file search handle
73604>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
73605>>>>>
73605>>>>>
73605>>>>>
73605>>>>>Struct tvFileTime
73605>>>>>  DWord dwLowDateTime
73605>>>>>  DWord dwHighDateTime
73605>>>>>End_Struct
73605>>>>>
73605>>>>>
73605>>>>>Struct tvSystemTime
73605>>>>>  UShort wYear
73605>>>>>  UShort wMonth
73605>>>>>  UShort wDayOfWeek
73605>>>>>  UShort wDay
73605>>>>>  UShort wHour
73605>>>>>  UShort wMinute
73605>>>>>  UShort wSecond
73605>>>>>  UShort wMilliSeconds
73605>>>>>End_Struct
73605>>>>>
73605>>>>>
73605>>>>>// Courtesy Of Vincent Oorsprong
73605>>>>>//  lpFileTime     : pointer to file time to convert
73605>>>>>//  lpSystemTime   : pointer to structure to receive system time
73605>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
73606>>>>>
73606>>>>>// Courtesy Of Vincent Oorsprong
73606>>>>>// This function formats the time in a picture-string passed
73606>>>>>//
73606>>>>>// Picture      Meaning
73606>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
73606>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
73606>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
73606>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
73606>>>>>//    m         Minutes with no leading zero for single-digit minutes
73606>>>>>//    mm        Minutes with leading zero for single-digit minutes
73606>>>>>//    s         Seconds with no leading zero for single-digit seconds
73606>>>>>//    ss        Seconds with leading zero for single-digit seconds
73606>>>>>//    t         One character time marker string, such as A or P
73606>>>>>//    tt        Multicharacter time marker string, such as AM or PM
73606>>>>>//
73606>>>>>// For example, to get the time string  "11:29:40 PM"
73606>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
73606>>>>>
73606>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
73607>>>>>
73607>>>>>
73607>>>>>// Courtesy Of Vincent Oorsprong
73607>>>>>// This function formats the date in a picture-string passed
73607>>>>>//
73607>>>>>// Picture      Meaning
73607>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
73607>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
73607>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
73607>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
73607>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
73607>>>>>//              value associated with the specified locale.
73607>>>>>//    M         Month as digits with no leading zero for single-digit months.
73607>>>>>//    MM        Month as digits with leading zero for single-digit months.
73607>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
73607>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
73607>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
73607>>>>>//              associated with the specified locale.
73607>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
73607>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
73607>>>>>//    yyyy      Year represented hy full four digits.
73607>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
73607>>>>>//              with the specified locale. This element is ignored if the date to be formatted
73607>>>>>//              does not have an associated era or period string.
73607>>>>>// For example, to get the date string  "Wed, Aug 31 94"
73607>>>>>// use the following picture string:    "ddd","MMM dd yy"
73607>>>>>
73607>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
73608>>>>>
73608>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
73608>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
73608>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
73608>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
73608>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
73608>>>>>
73608>>>>>//  Date Flags for GetDateFormatW.
73608>>>>>//
73608>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
73608>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
73608>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
73608>>>>>
73608>>>>>
73608>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
73609>>>>>
73609>>>>>
73609>>>>>// **WvA: 20-02-2004
73609>>>>>// While i was testing the format capabilities i stumbled over a very
73609>>>>>// weird problem where it looks like that the integer value gets somehow translated
73609>>>>>// incorrectly into an unsigned integer.
73609>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
73609>>>>>// It does smell a bit fishy though
73609>>>>>// Tested it with the same results on both VDF7 and VDF9.1
73609>>>>>
73609>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
73609>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
73609>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
73609>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
73609>>>>>
73609>>>>>// Possible errors that can be returned by the shellformat function
73609>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
73609>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
73609>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
73609>>>>>
73609>>>>>
73609>>>>> // Courtesy Of Steve Walter,
73609>>>>> // USA Software, Inc
73609>>>>> // Format a disk
73609>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
73609>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
73610>>>>>
73610>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
73610>>>>>
73610>>>>>// SHCreateDirectoryEx
73610>>>>>
73610>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
73610>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
73610>>>>>//
73610>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
73610>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
73610>>>>>//    the files are visible. If they are not visible, expect one of the following:
73610>>>>>//
73610>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
73610>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
73610>>>>>//        ERROR_CANCELLED.
73610>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
73610>>>>>
73610>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
73610>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
73610>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
73610>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
73610>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
73610>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
73610>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
73610>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
73610>>>>>
73610>>>>>//        int SHCreateDirectoryEx(
73610>>>>>//            HWND hwnd,
73610>>>>>//            LPCTSTR pszPath,
73610>>>>>//            const SECURITY_ATTRIBUTES *psa
73610>>>>>//        );
73610>>>>>
73610>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
73611>>>>>
73611>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
73612>>>
73612>>>
73612>>>//
73612>>>// Gets the string from the right of the last sStopChar in sFrom
73612>>>// If sStopChar has no occurences in the string an empty string is
73612>>>// returned.
73612>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
73614>>>    String  sRetVal
73614>>>    String  sChar
73614>>>    Integer iLength
73614>>>    Integer iPos
73614>>>    Boolean bStopChar
73614>>>    Move "" to sRetval
73615>>>    Move (Length(sFrom)) to iLength
73616>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
73618>>>        Move iLength   to iPos
73619>>>        Move (False)   to bStopChar
73620>>>        While Not bStopChar
73624>>>            Move (Mid(sFrom,1,iPos)) to sChar
73625>>>            Decrement iPos
73626>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
73628>>>                Move (True) to bStopChar
73629>>>            End
73629>>>>
73629>>>            Else Begin
73630>>>                Move (sChar+sRetVal) to sRetVal
73631>>>            End
73631>>>>
73631>>>        Loop
73632>>>>
73632>>>    End
73632>>>>
73632>>>    Function_Return sRetVal
73633>>>End_Function
73634>>>
73634>>>// Pre:  sFileName contains the complete path of the file.
73634>>>// Post: returns the complete path of the file.
73634>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
73634>>>Function ParseFolderName Global String sFileName Returns String
73636>>>    String sFile
73636>>>    String sFolderName
73636>>>    String sDirSep // this is "\" for windows, or "/" for unix
73636>>>
73636>>>    Move "" to sFolderName
73637>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
73638>>>    If sDirSep In sFileName Begin
73640>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
73641>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
73642>>>    End
73642>>>>
73642>>>    Else If ":" In sFileName Begin
73645>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
73646>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
73647>>>    End
73647>>>>
73647>>>    Function_Return sFolderName
73648>>>End_Function
73649>>>
73649>>>// Pre:  sFileName contains the complete path of the file.
73649>>>// post: The returned filename has it's path removed, but will have a extension
73649>>>Function ParseFileName Global String sFileName Returns String
73651>>>    String sFolderName
73651>>>    String sDirSep // this is "\" for windows, or "/" for unix
73651>>>
73651>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
73652>>>    Get ParseFolderName sFileName to sFolderName
73653>>>    If (sFolderName <> "") Begin
73655>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
73656>>>    End
73656>>>>
73656>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
73657>>>    Function_Return sFilename
73658>>>End_Function
73659>>>
73659>>>// Pre:  sFileName may contain the complete path of the file.
73659>>>//       or contain multiple dots in the filename, so temp.gif.bak will
73659>>>//       return "bak" as the extension and not "gif"
73659>>>// Post: returns the extension only, this extension can be a valid unixlike extension
73659>>>//       such as "html" or "java"
73659>>>Function ParseFileExtension Global String sFileName Returns String
73661>>>    String  sFileExtension
73661>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
73662>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
73663>>>    Function_Return sFileExtension
73664>>>End_Function
73665>>>
73665>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
73665>>>
73665>>>Function DDE_Error_To_String Integer iErrorID Returns String
73667>>>    String sMessage
73667>>>    Case Begin
73667>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
73669>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
73670>>>            Case Break
73671>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
73674>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
73675>>>            Case Break
73676>>>        Case (iErrorID = vERROR_BAD_FORMAT)
73679>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
73680>>>            Case Break
73681>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
73684>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
73685>>>            Case Break
73686>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
73689>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
73690>>>            Case Break
73691>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
73694>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
73695>>>            Case Break
73696>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
73699>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
73700>>>            Case Break
73701>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
73704>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
73705>>>            Case Break
73706>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
73709>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
73710>>>            Case Break
73711>>>        Case (iErrorID = vSE_ERR_NOASSOC)
73714>>>            Move CS_DDE_ERR_NOASSOC to sMessage
73715>>>            Case Break
73716>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
73719>>>            Move CS_DDE_ERR_OOM to sMessage
73720>>>            Case Break
73721>>>        Case (iErrorID = vSE_ERR_PNF)
73724>>>            Move CS_DDE_ERR_PNF to sMessage
73725>>>            Case Break
73726>>>        Case (iErrorID = vSE_ERR_SHARE)
73729>>>            Move CS_DDE_ERR_SHARE to sMessage
73730>>>            Case Break
73731>>>        Case Else
73731>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
73732>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
73733>>>            Case Break
73734>>>    Case End
73734>>>    Function_Return sMessage
73735>>>End_Function
73736>>>
73736>>>Procedure vDDE_Error_Handler Integer iErrorID
73738>>>    String sMessage
73738>>>    Get DDE_Error_To_String iErrorID to sMessage
73739>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
73740>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
73741>>>End_Procedure
73742>>>
73742>>>// Does the directory exist? - No = false, Yes = True
73742>>>// This also works with UNC path encoding and wildcards
73742>>>Function vFolderExists Global String sFolderName Returns Boolean
73744>>>    Boolean bFolderExists
73744>>>    Boolean bStop
73744>>>    String  sFolder sTmp
73744>>>    Integer iCh
73744>>>
73744>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
73744>>>    Move (Utf8ToAnsi(Trim(sFolderName))) to sFolderName
73745>>>    If (sFolderName = "") Begin
73747>>>        Function_Return False
73748>>>    End
73748>>>>
73748>>>
73748>>>    Move True  to bFolderExists
73749>>>    Move False to bStop
73750>>>    Move "dir:" to sFolder
73751>>>    Append sFolder sFolderName
73752>>>    Get Seq_New_Channel to iCh  // get free channel for input
73753>>>    Direct_Input channel iCh sFolder
73755>>>    Repeat
73755>>>>
73755>>>        Readln channel iCh sTmp
73757>>>        Move (SeqEof) to bStop
73758>>>        If (Trim(sTmp)="") Begin
73760>>>            Move False to bFolderExists
73761>>>        End
73761>>>>
73761>>>        Else Begin
73762>>>            Move True to bFolderExists
73763>>>            Move True to bStop
73764>>>        End
73764>>>>
73764>>>    Until (bStop)
73766>>>    Close_Input channel iCh
73768>>>    Send Seq_Release_Channel iCh
73769>>>    Function_Return bFolderExists
73770>>>End_Function
73771>>>
73771>>>// returns folder name if a folder was selected, otherwise returns ""
73771>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
73773>>>    String sFolder sTitle sPath
73773>>>    Pointer lpItemIdList
73773>>>    Integer iFolderSelected iRetval
73773>>>    tvBrowseInfo BrowseInfo
73773>>>    tvBrowseInfo BrowseInfo
73773>>>
73773>>>    Move "" to sPath
73774>>>    If (sDialogTitle<>"") Begin
73776>>>        Move sDialogTitle to sTitle
73777>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
73777>>>        // disables showing some commonly used ascii characters like ascii 137 (├½)
73777>>>        // These chars are correctly shown if no toansi is used.
73777>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
73777>>>        // selected it will always be valid.
73777>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
73778>>>    End
73778>>>>
73778>>>
73778>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
73779>>>
73779>>>    // Torben Lund added line below. Move handle of focus object to structure before
73779>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
73779>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
73780>>>
73780>>>    // null 128 chars into var (make space)
73780>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73781>>>
73781>>>    // select folder
73781>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
73782>>>    // get selected folder name
73782>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
73783>>>
73783>>>    // release memory resources that are used by the ItemIdList
73783>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
73784>>>
73784>>>    If (iFolderSelected<>0) Begin
73786>>>        Move (CString(sFolder)) to sPath
73787>>>    End
73787>>>>
73787>>>    Function_Return  sPath
73788>>>End_Function
73789>>>
73789>>>// returns 0 if the folder is created.
73789>>>//         1 if the API-call returned an error.
73789>>>Function vCreateDirectory Global String sNewFolder Returns Integer
73791>>>    String  sFolder
73791>>>    Integer iRetval bFolderCreated
73791>>>    tvSecurity_attributes SA
73791>>>    tvSecurity_attributes SA
73791>>>
73791>>>    Move False to bFolderCreated
73792>>>
73792>>>    // null MAX_PATH chars into var (make space)
73792>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
73793>>>
73793>>>    If (sNewFolder <> "") Begin
73795>>>
73795>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
73796>>>        Move  0  to SA.lpDescriptor
73797>>>        Move  1  to SA.bInheritHandle
73798>>>
73798>>>        //
73798>>>        Move (sNewFolder+"") to sFolder
73799>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
73800>>>    End
73800>>>>
73800>>>
73800>>>    If (bFolderCreated=false) Begin
73802>>>        Move 1 to iRetVal
73803>>>    End
73803>>>>
73803>>>    Function_Return iRetVal
73804>>>End_Function
73805>>>
73805>>>// **WvA: 03-02-2002 Function created.
73805>>>// With this function one can remove a directory.
73805>>>// returns 0 if the folder is removed.
73805>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
73805>>>//         2 if the folder did not exist
73805>>>//         3 if the sFolder parameter passed is equal to ""
73805>>>Function vRemoveDirectory Global String sFolder Returns Integer
73807>>>    Boolean bRemoved
73807>>>    String  sPath
73807>>>    Integer iRetval
73807>>>
73807>>>    Move 0     to iRetVal
73808>>>    Move False to bRemoved
73809>>>    Move (Trim(sFolder)) to sFolder
73810>>>    If (sFolder="") Begin
73812>>>        Move 3 to iRetVal
73813>>>    End
73813>>>>
73813>>>    If (vFolderExists(sFolder)=False) Begin
73815>>>        Move 2 to iRetVal
73816>>>    End
73816>>>>
73816>>>    If (iRetVal=0) Begin
73818>>>    // null MAX_PATH chars into var (make space)
73818>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
73819>>>        //
73819>>>        Move (Insert(sFolder,sPath,1)) to sPath
73820>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
73821>>>    End
73821>>>>
73821>>>
73821>>>    If (iRetVal=0 And bRemoved=False) Begin
73823>>>        Move 1 to iRetVal
73824>>>    End
73824>>>>
73824>>>    Function_Return iRetVal
73825>>>End_Function
73826>>>
73826>>>// This function informs the user that he entered a yet unknown folder and
73826>>>// asks if he/she wants to create the folder (Yes/No)
73826>>>// Choice: "Yes" - this creates the folder
73826>>>//                 if successful, the function returns false
73826>>>//                 else it will be true.
73826>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
73826>>>//                 For example: to stop a save
73826>>>// Precondition: A foldername must be entered. We do not check for empty paths
73826>>>// This function returns a non-zero value if the folder isn't created afterwards
73826>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
73828>>>    Integer bIsNotValid
73828>>>    Integer iUsers_Choice
73828>>>    String  sMessage
73828>>>
73828>>>    If (vFolderExists(sFolderName) Eq 0) Begin
73830>>>        Move "The folder '" to sMessage
73831>>>        Append sMessage sFolderName
73832>>>        Append sMessage "' does not yet exist,\n"
73833>>>        Append sMessage "Do you want to create it now?"
73834>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
73835>>>        Case Begin
73835>>>            Case (iUsers_Choice = MBR_Yes)
73837>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
73838>>>                If bIsNotValid Begin
73840>>>                    Move "An error occurred while trying to create folder '" to sMessage
73841>>>                    Append sMessage sFolderName "'.\n\n"
73843>>>                    Send Info_Box sMessage "Info"
73844>>>                End
73844>>>>
73844>>>                Case Break
73845>>>            Case (iUsers_Choice = MBR_No)
73848>>>                Move dfTrue to bIsNotValid // Cancel the save
73849>>>                Case Break
73850>>>        Case End
73850>>>    End
73850>>>>
73850>>>    Function_Return bIsNotValid
73851>>>End_Function
73852>>>
73852>>>// This will perform an operation on a file (e.g. open) with the application
73852>>>// registered in the Windows Registry to open that type of file (via its extension)
73852>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
73852>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
73854>>>    Handle  hInstance hWnd
73854>>>    // remove any leading/trailing spaces in the string
73854>>>    Move (Trim(sDocument)) to sDocument
73855>>>    Move (Trim(sPath))     to sPath
73856>>>    // Make the strings readable for windows API, by converting them to null-terminated
73856>>>    Append sOperation   (Character(0))
73857>>>    Append sDocument    (Character(0))
73858>>>    Append sParameters  (Character(0))
73859>>>    Append sPath        (Character(0))
73860>>>
73860>>>    Get Window_Handle to hWnd
73861>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
73862>>>    If (hInstance <= 32) Begin
73864>>>        Send vDDE_Error_Handler hInstance
73865>>>    End
73865>>>>
73865>>>End_Procedure
73866>>>
73866>>>Class cShellFileOperations is a Array
73867>>>
73867>>>    Procedure Construct_Object
73869>>>        Forward Send Construct_Object
73871>>>        Property Integer piDeleteFlags        0
73872>>>        Property Integer piCopyFlags          0
73873>>>        Property Integer piMoveFlags          0
73874>>>        Property Integer piRenameFlags        0
73875>>>
73875>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
73876>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
73877>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
73878>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
73879>>>    End_Procedure
73880>>>
73880>>>    // This function uses the shell API to perform a file operation on the
73880>>>    // files supplied.
73880>>>    //
73880>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
73882>>>        Integer  iRetVal
73882>>>        Integer  iUserAbort
73882>>>        tvShFileOpStruct FOS
73882>>>        tvShFileOpStruct FOS
73882>>>
73882>>>        Move (Utf8ToAnsi(sSource)+Character(0)+Character(0))      to sSource
73883>>>        Move (Utf8ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
73884>>>        If (eOperation <> vFO_DELETE) Begin
73886>>>            Move (AddressOf(sDestination)) to FOS.pTo
73887>>>        End
73887>>>>
73887>>>
73887>>>        Move eOperation           to FOS.wFunc
73888>>>        Move (AddressOf(sSource)) to FOS.pFrom
73889>>>        Move iFlags               to FOS.fFlags
73890>>>
73890>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
73891>>>        Move FOS.fAnyOperationsAborted to iUserAbort
73892>>>        If (iUserAbort <> 0) Begin
73894>>>            Move 80 to iRetVal  // file Operation Aborted by USER
73895>>>        End
73895>>>>
73895>>>        Function_Return (iRetVal)
73896>>>    End_Function
73897>>>
73897>>>    Function sfoDeleteFile String sFileName Returns Integer
73899>>>        Integer  iRetVal
73899>>>        Integer  iFlags
73899>>>
73899>>>        Get piDeleteFlags to iFlags
73900>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
73901>>>        Function_Return iRetVal
73902>>>    End_Function
73903>>>
73903>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
73905>>>        Integer  iRetVal
73905>>>        Integer  iFlags
73905>>>
73905>>>        Get piCopyFlags to iFlags
73906>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
73907>>>        Function_Return iRetVal
73908>>>    End_Function
73909>>>
73909>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
73911>>>        Integer  iRetVal
73911>>>        Integer  iFlags
73911>>>
73911>>>        Get piMoveFlags to iFlags
73912>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
73913>>>        Function_Return iRetVal
73914>>>    End_Function
73915>>>
73915>>>    // Rename a file or folder
73915>>>    // Returns a nonzero value if the operation failed.
73915>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
73917>>>        Integer  iRetVal
73917>>>        Integer  iFlags
73917>>>
73917>>>        Get piRenameFlags to iFlags
73918>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
73919>>>        Function_Return iRetVal
73920>>>    End_Function
73921>>>
73921>>>    // Courtesy Of Steve Walter
73921>>>    // Requires Windows 2000 and up according to msdn but it was
73921>>>    //  in fact available before that as an unpublished API call
73921>>>    //  a little google search shows that this was already available
73921>>>    //  in windows 95 and NT
73921>>>    //
73921>>>    // The format is controlled by the dialog interface.
73921>>>    // That is, the user must click the OK button To actually Begin the format
73921>>>    // the format cannot be started programmatically.
73921>>>    // An alternative to this functionality would be to use a controlpanel
73921>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
73921>>>    //
73921>>>    // hWnd = The windows handle of the object from which the format Function
73921>>>    //        is called.
73921>>>    // To Get this,
73921>>>    //          use:  Get Window_Handle Of <object>
73921>>>    //          For instance, in this app, we're going to use the Report_Panel:
73921>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
73921>>>    //
73921>>>    // sDrive = The drive letter. At this moment only A and B are valid
73921>>>    //
73921>>>    // iOptions = Format options.
73921>>>    //  SHFMT_OPT_DEFAULT = Quick format
73921>>>    //  SHFMT_OPT_FULL    = Full Format
73921>>>    //  SHFMT_OPT_SYSONLY = System only
73921>>>    //  3                 = Full format with system. (unsupported)
73921>>>    //
73921>>>    // Return Values:
73921>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
73921>>>    //  SHFMT_CANCEL   = Format cancelled by user.
73921>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
73921>>>    //
73921>>>    //
73921>>>    // *** ATTENTION: This function has been disabled as it doesn't
73921>>>    //                seem to work, i must have made a silly mistake
73921>>>    //                somewhere.
73921>>>    //
73921>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
73923>>>        Handle   hWnd
73923>>>        Integer  iObj
73923>>>        DWord    dwReturnVal
73923>>>        Integer iDrive
73923>>>
73923>>>        Function_Return 1 // STOP HERE
73924>>>
73924>>>        Move (Trim(sDrive)) to sDrive
73925>>>        If ( sDrive <> '' ) Begin
73927>>>            If ( sDrive Contains ':' ) Begin
73929>>>                Move (Replace(':',sDrive,'')) to sDrive
73930>>>            End
73930>>>>
73930>>>            If (Not( 'AB' Contains sDrive )) Begin
73932>>>                Function_Return (SHFMT_NOFORMAT)
73933>>>            End
73933>>>>
73933>>>            If ( sDrive = 'A' ) Begin
73935>>>                Move 0 to iDrive
73936>>>            End
73936>>>>
73936>>>            Else If ( sDrive = 'B' ) Begin
73939>>>                Move 1 to iDrive
73940>>>            End
73940>>>>
73940>>>            // Window_Handle Of Desktop equals to 0
73940>>>
73940>>>            Get focus of desktop to iObj
73941>>>            If (iObj>desktop) Begin
73943>>>                Get Container_Handle of iObj to hWnd
73944>>>            End
73944>>>>
73944>>>            While (hWnd=0 And iObj<>Desktop)
73948>>>                Get Parent of iObj to iObj
73949>>>                Get Container_Handle of iObj to hWnd
73950>>>            Loop
73951>>>>
73951>>>
73951>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
73951>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
73952>>>        End
73952>>>>
73952>>>        Else Begin
73953>>>            Move (SHFMT_ERROR) to dwReturnVal
73954>>>        End
73954>>>>
73954>>>        Function_Return dwReturnVal
73955>>>    End_Function
73956>>>
73956>>>    //Example:
73956>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
73956>>>    //                                          mode.
73956>>>
73956>>>End_Class
73957>>>
73957>>>Object oShellFileOperations is a cShellFileOperations
73959>>>End_Object
73960>>>
73960>>>// Restore to the old way of working with the shell file operations.
73960>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
73960>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
73960>>>Procedure vWin32fhCompatibilityMode
73962>>>    Integer hoSFO
73962>>>    Integer iFlags
73962>>>
73962>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
73963>>>    Move (oShellFileOperations(Self)) to hoSFO
73964>>>
73964>>>    Set piDeleteFlags of hoSFO to iFlags
73965>>>    Set piCopyFlags   of hoSFO to iFlags
73966>>>    Set piMoveFlags   of hoSFO to iFlags
73967>>>    Set piRenameFlags of hoSFO to iFlags
73968>>>End_Procedure
73969>>>
73969>>>// Delete a file or folder
73969>>>// Returns a nonzero value if the operation failed.
73969>>>Function vDeleteFile Global String sFileName Returns Integer
73971>>>    Integer  iRetVal
73971>>>
73971>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
73972>>>    Function_Return iRetVal
73973>>>End_Function
73974>>>
73974>>>// Copy a file or folder
73974>>>// Returns a nonzero value if the operation failed.
73974>>>Function vCopyFile Global String sSource String sDestination Returns Integer
73976>>>    Integer  iRetVal
73976>>>
73976>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73977>>>    Function_Return iRetVal
73978>>>End_Function
73979>>>
73979>>>// Move a file or folder
73979>>>// Returns a nonzero value if the operation failed.
73979>>>Function vMoveFile Global String sSource String sDestination Returns Integer
73981>>>    Integer  iRetVal
73981>>>
73981>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73982>>>    Function_Return iRetVal
73983>>>End_Function
73984>>>
73984>>>// Rename a file or folder
73984>>>// Returns a nonzero value if the operation failed.
73984>>>Function vRenameFile Global String sSource String sDestination Returns Integer
73986>>>    Integer  iRetVal
73986>>>
73986>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
73987>>>    Function_Return iRetVal
73988>>>End_Function
73989>>>
73989>>>Function vGetWindowsDirectory Returns String
73991>>>    String  sDirectory
73991>>>    Integer iVoid
73991>>>
73991>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
73992>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
73993>>>    Function_Return (CString(sDirectory))
73994>>>End_Function
73995>>>
73995>>>Function vGetTempPath Returns String
73997>>>    Integer iRetval
73997>>>    String  sTempPath
73997>>>
73997>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
73998>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
73999>>>    Function_Return (Cstring(sTempPath))
74000>>>End_Function
74001>>>
74001>>>// Courtesy of Marco Kuipers
74001>>>Function vMakeTempFile Returns String
74003>>>    Integer iRetval
74003>>>    String  sTempPath
74003>>>    String  sTempFileName
74003>>>    String  sPrefixString
74003>>>
74003>>>    Get vGetTempPath to sTempPath
74004>>>    If (sTempPath = "") Begin
74006>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
74007>>>        If (sTempPath<>"") Begin
74009>>>            Move (sTempPath+"\Temp\") to sTempPath
74010>>>        End
74010>>>>
74010>>>    End
74010>>>>
74010>>>
74010>>>    If (sTempPath = "") Begin
74012>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
74012>>>    // makes little sense. Leaving this in as it was old behavior.
74012>>>        Get_Current_Directory to sTempPath
74013>>>    End
74013>>>>
74013>>>
74013>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
74014>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
74016>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
74017>>>>
74017>>>    End
74017>>>>
74017>>>
74017>>>    Move (ZeroString(vMax_Path)) to sTempFileName
74018>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
74019>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
74020>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
74022>>>    //Get ShowLastError to iRetval
74022>>>        Move "" to sTempFileName
74023>>>    End
74023>>>>
74023>>>
74023>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
74024>>>End_Function
74025>>>
74025>>>// This function creates a uniquely named temporary file in folder sPath
74025>>>// The file created will have a prefix based on the first 3 characters in sPrefix
74025>>>// Note that you will have to cleanup the tempfile yourself as the function
74025>>>// does not take care of that.
74025>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
74027>>>    Integer iRetVal
74027>>>    String sTempFileName
74027>>>
74027>>>    Move (Utf8ToAnsi(sPath)+Character(0))   to sPath
74028>>>    Move (Utf8ToAnsi(sPrefix)+Character(0)) to sPrefix
74029>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
74030>>>
74030>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
74031>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
74032>>>    Function_Return sTempFileName
74033>>>End_Function
74034>>>
74034>>>//
74034>>>// Get a specific shell folder for example to get the desktop folder
74034>>>// simply call this function and pass it vCSIDL_DESKTOP
74034>>>//
74034>>>Function vSHGetFolderPath Integer eFolder Returns String
74036>>>    String  sFolder
74036>>>    Integer iVoid
74036>>>    Handle  hWnd
74036>>>
74036>>>    Move (Window_Handle(focus(desktop))) to hWnd
74037>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74038>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
74039>>>    Function_Return (CString(sFolder))
74040>>>End_Function
74041>>>
74041>>>// Courtesy Of Vincent Oorsprong
74041>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
74043>>>    String  sFormattedTime sFormattedDate
74043>>>    String  sFileDateTime
74043>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
74043>>>    tvFileTime   FileTime
74043>>>    tvFileTime   FileTime
74043>>>    tvSystemTime SystemTime
74043>>>    tvSystemTime SystemTime
74043>>>
74043>>>    Move "" to sFileDateTime
74044>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
74045>>>    Move dwHighDateTime to FileTime.dwHighDateTime
74046>>>
74046>>>    Move 0 to SystemTime.wYear
74047>>>
74047>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
74048>>>    If (iSuccess = 1) Begin
74050>>>        Move (ZeroString(255))        to sFormattedTime
74051>>>        Move (Length(sFormattedTime)) to iLenCcTime
74052>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
74053>>>        Move (ZeroString(255))        to sFormattedDate
74054>>>        Move (Length(sFormattedDate)) to iLenCcDate
74055>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
74056>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
74057>>>    End
74057>>>>
74057>>>    Function_Return sFileDateTime
74058>>>End_Function
74059>>>
74059>>>// **WvA:
74059>>>// A windows replacement for the standard function FileExists.
74059>>>// This version will also return (true) for a file when it is open by an application.
74059>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
74059>>>// Example: Get vFilePathExists "C:\config.sy?"
74059>>>// This will return true if you have a file matching these conditions. (aka config.sys)
74059>>>Function vFilePathExists Global String sFilePathMask Returns Integer
74061>>>    String  sDirSep
74061>>>    Handle  hFindFile
74061>>>    Integer iVoid
74061>>>    tvWin32FindData FindData
74061>>>    tvWin32FindData FindData
74061>>>
74061>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74062>>>    Move (Utf8ToANSI(Trim(sFilePathMask))) to sFilePathMask
74063>>>    If (Length(sFilePathMask)>0) Begin
74065>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
74065>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74066>>>        While (Right(sFilePathMask, 1) = sDirSep)
74070>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
74071>>>        Loop
74072>>>>
74072>>>
74072>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74073>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
74074>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74075>>>    End
74075>>>>
74075>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74076>>>End_Function
74077>>>
74077>>>//
74077>>>// WideChar version of the function, do not use, it's an experiment
74077>>>//
74077>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
74079>>>    Handle  hFindFile
74079>>>    Integer iVoid
74079>>>    tvWin32FindData FindData
74079>>>    tvWin32FindData FindData
74079>>>
74079>>>    Move vINVALID_HANDLE_VALUE to hFindFile
74080>>>
74080>>>    If (Length(sFilePathMask)>0) Begin
74082>>>
74082>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74083>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
74084>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
74085>>>    End
74085>>>>
74085>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
74086>>>End_Function
74087>>>
74087>>>// **WvA
74087>>>// Formats a foldername by first trimming it and after that by sticking a
74087>>>// directory separator (/\) to the end if it doesn't have one there already.
74087>>>// The folder may contain a drive letter or UNC encoding.
74087>>>Function vFolderFormat Global String sFolderName Returns String
74089>>>    String sDirSep
74089>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
74090>>>    Move (Trim(sFolderName)) to sFolderName
74091>>>    If (Right(sFolderName,1)<>sDirSep) Begin
74093>>>        Move (sFolderName+sDirSep) to sFolderName
74094>>>    End
74094>>>>
74094>>>    Function_Return sFolderName
74095>>>End_Function
74096>>>
74096>>>//
74096>>>// Returns the amount of files in the folder (if it exists)
74096>>>// Returns -1 if folder doesn't exist.
74096>>>// The files "." and ".." are not counted.
74096>>>//
74096>>>Function vFolderFileCount Global String sFolderName Returns Integer
74098>>>    Boolean bFound
74098>>>    Handle  hFindFile
74098>>>    Integer iCount  iVoid
74098>>>    Integer iSuccess
74098>>>    String  sFileName
74098>>>    tvWin32FindData FindData
74098>>>    tvWin32FindData FindData
74098>>>
74098>>>    Move -1 to iCount
74099>>>    Get vFolderFormat sFolderName to sFolderName
74100>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
74101>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74102>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
74103>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
74104>>>    If (bFound) Begin
74106>>>        Move 0 to iCount
74107>>>    End
74107>>>>
74107>>>    While (bFound)
74111>>>        Increment iCount
74112>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
74113>>>        If (sFileName="." or sFileName="..") Begin
74115>>>            Decrement iCount
74116>>>        End
74116>>>>
74116>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
74117>>>        Move (iSuccess<>0) to bFound
74118>>>    Loop
74119>>>>
74119>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74120>>>    Function_Return iCount
74121>>>End_Function
74122>>>
74122>>>//
74122>>>// Gets the parent path of the currently supplied path
74122>>>// Returns "" when we are at the root folder.
74122>>>//
74122>>>Function vParentPath Global String sPath Returns String
74124>>>    String sStrip sDirSep
74124>>>
74124>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74125>>>    Move (Trim(sPath)) to sPath
74126>>>    If (Right(sPath,1) = sDirSep) Begin
74128>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
74129>>>    End
74129>>>>
74129>>>    If (Pos(sDirSep, sPath)) Begin
74131>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
74132>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
74133>>>    End
74133>>>>
74133>>>    Else Begin
74134>>>        Move "" to sPath
74135>>>    End
74135>>>>
74135>>>    Function_Return sPath
74136>>>End_Function
74137>>>
74137>>>// Create the folder, including intermediate directories.
74137>>>// Don't panic if the folder already exists.
74137>>>// Michael Mullan June 2009.
74137>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
74139>>>    String  sFolder
74139>>>    Integer iRetval iFolderCreated
74139>>>    tvSecurity_attributes SA
74139>>>    tvSecurity_attributes SA
74139>>>
74139>>>    Move 0 to iFolderCreated
74140>>>
74140>>>    // null MAX_PATH chars into var (make space)
74140>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74141>>>    If (sNewFolder <> "") Begin
74143>>>
74143>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74144>>>        Move  0  to SA.lpDescriptor
74145>>>        Move  1  to SA.bInheritHandle
74146>>>
74146>>>        //
74146>>>        Move (sNewFolder+"") to sFolder
74147>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
74148>>>    End
74148>>>>
74148>>>
74148>>>    If (iFolderCreated <> 0) Begin
74150>>>        Move 1 to iRetVal
74151>>>        Case Begin
74151>>>            Case (iFolderCreated = 161)
74153>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
74154>>>>
74154>>>                Case Break
74155>>>            Case (iFolderCreated = 206)
74158>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
74159>>>>
74159>>>                Case Break
74160>>>            Case (iFolderCreated = 3)
74163>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
74164>>>>
74164>>>                Case Break
74165>>>            Case (iFolderCreated = 80)
74168>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
74169>>>                Case Break
74170>>>            Case (iFolderCreated = 183)
74173>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
74174>>>                Case Break
74175>>>            Case (iFolderCreated = 1223)
74178>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
74179>>>>
74179>>>                Case Break
74180>>>            Case Else
74180>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
74181>>>>
74181>>>        Case End
74181>>>    End
74181>>>>
74181>>>    Function_Return iRetVal
74182>>>End_Function
74183>>>
74183>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
74185>>>    DWord   dwFileSizeHigh dwFileSizeLow
74185>>>    Integer iFileSize iVoid
74185>>>    Handle  hFindFile
74185>>>    tvWin32FindData FindData
74185>>>    tvWin32FindData FindData
74185>>>
74185>>>    Move (sFileName+"") to sFileName
74186>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
74187>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
74188>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
74190>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
74191>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
74192>>>    End
74192>>>>
74192>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
74193>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
74194>>>
74194>>>    Function_Return iFileSize
74195>>>End_Function
74196>>>
74196>>>//
74196>>>// Based on code in Peter Crook's Browse folder workspace
74196>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
74196>>>//
74196>>>//=============================================================================
74196>>>// Verifies that a path is a valid directory.
74196>>>//
74196>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
74196>>>//
74196>>>// Parameters:
74196>>>//      sPath - Address of the path to verify.
74196>>>//=============================================================================
74196>>>Function vPathIsDirectory Global String sPath Returns Boolean
74198>>>    Integer iResult
74198>>>    Boolean bRetVal
74198>>>
74198>>>    Move false to bRetVal
74199>>>    Move (Utf8ToAnsi(sPath) - Character (0)) to sPath
74200>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
74201>>>    If (iResult<>0) Begin
74203>>>        Move True to bRetVal
74204>>>    End
74204>>>>
74204>>>
74204>>>    Function_Return bRetVal
74205>>>End_Function
74206>>>
74206>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJSkinFramework.pkg)
74206>>>Use windows.pkg
74206>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJComSkinFramework.pkg)
74206>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v20.0.0.ocx
74206>>>>>Use FlexCom20.pkg
74206>>>>>
74206>>>>>// Changes to Imported package
74206>>>>>//     OLEXTPxx to XTPxx
74206>>>>>//     OLExtpxx to xtpxx
74206>>>>>//     OLESkinFramework to SkinFramework
74206>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
74206>>>>>//     cCom classes to cCJ
74206>>>>>//     cCJAutomationObject back to cComAutomationObject
74206>>>>>//     cCJActiveXControl back to cComActiveXControl
74206>>>>>//     cCJSkinFramework to cCJComSkinFramework
74206>>>>>//     Use statements as noted below (classes moved to these files)
74206>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
74206>>>>>
74206>>>>>// These have been extracted from this class and moved into seperate packages
74206>>>>>// because other Codejock classes use these.
74206>>>>>Use cCJColorManager.pkg     // cCJColorManager
74206>>>>>
74206>>>>>
74206>>>>>Define SkinFrameworkApplyOptions for Integer
74206>>>>>    Define xtpSkinApplyMetrics for 1
74206>>>>>    Define xtpSkinApplyFrame for 2
74206>>>>>    Define xtpSkinApplyColors for 4
74206>>>>>    Define xtpSkinApplyMenus for 8
74206>>>>>
74206>>>>>// CLSID: {C0DE2000-28D7-4F2C-87A7-7266367B4655}
74206>>>>>// Dispatch interface for SkinFramework Control
74206>>>>>Class cCJ_DSkinFramework is a Mixin
74207>>>>>
74207>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
74209>>>>>        SkinFrameworkApplyOptions retVal
74209>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
74210>>>>>        Function_Return retVal
74211>>>>>    End_Function
74212>>>>>
74212>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
74214>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
74215>>>>>    End_Procedure
74216>>>>>
74216>>>>>    Function ComAutoApplyNewWindows Returns Boolean
74218>>>>>        Boolean retVal
74218>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
74219>>>>>        Function_Return retVal
74220>>>>>    End_Function
74221>>>>>
74221>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
74223>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
74224>>>>>    End_Procedure
74225>>>>>
74225>>>>>    Function ComAutoApplyNewThreads Returns Boolean
74227>>>>>        Boolean retVal
74227>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
74228>>>>>        Function_Return retVal
74229>>>>>    End_Function
74230>>>>>
74230>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
74232>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
74233>>>>>    End_Procedure
74234>>>>>
74234>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74236>>>>>        Handle hDispatchDriver
74236>>>>>        Boolean retVal
74236>>>>>        Get phDispatchDriver to hDispatchDriver
74237>>>>>        Send PrepareParams to hDispatchDriver 2
74238>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74239>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74240>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74241>>>>>        Function_Return retVal
74242>>>>>    End_Function
74243>>>>>
74243>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74245>>>>>        Handle hDispatchDriver
74245>>>>>        Get phDispatchDriver to hDispatchDriver
74246>>>>>        Send PrepareParams to hDispatchDriver 1
74247>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74248>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74249>>>>>    End_Procedure
74250>>>>>
74250>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74252>>>>>        Handle hDispatchDriver
74252>>>>>        Get phDispatchDriver to hDispatchDriver
74253>>>>>        Send PrepareParams to hDispatchDriver 2
74254>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74255>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74256>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74257>>>>>    End_Procedure
74258>>>>>
74258>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74260>>>>>        Handle hDispatchDriver
74260>>>>>        Get phDispatchDriver to hDispatchDriver
74261>>>>>        Send PrepareParams to hDispatchDriver 1
74262>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74263>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74264>>>>>    End_Procedure
74265>>>>>
74265>>>>>    Procedure ComRemoveAllWindows
74267>>>>>        Handle hDispatchDriver
74267>>>>>        Get phDispatchDriver to hDispatchDriver
74268>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74269>>>>>    End_Procedure
74270>>>>>
74270>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74272>>>>>        Handle hDispatchDriver
74272>>>>>        Get phDispatchDriver to hDispatchDriver
74273>>>>>        Send PrepareParams to hDispatchDriver 2
74274>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74275>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74276>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74277>>>>>    End_Procedure
74278>>>>>
74278>>>>>    Procedure ComRemoveWindowClass String llClassName
74280>>>>>        Handle hDispatchDriver
74280>>>>>        Get phDispatchDriver to hDispatchDriver
74281>>>>>        Send PrepareParams to hDispatchDriver 1
74282>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74283>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74284>>>>>    End_Procedure
74285>>>>>
74285>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74287>>>>>        Handle hDispatchDriver
74287>>>>>        Variant retVal
74287>>>>>        Get phDispatchDriver to hDispatchDriver
74288>>>>>        Send PrepareParams to hDispatchDriver 2
74289>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74290>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74291>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74292>>>>>        Function_Return retVal
74293>>>>>    End_Function
74294>>>>>
74294>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74296>>>>>        Handle hDispatchDriver
74296>>>>>        Variant retVal
74296>>>>>        Get phDispatchDriver to hDispatchDriver
74297>>>>>        Send PrepareParams to hDispatchDriver 1
74298>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74299>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74300>>>>>        Function_Return retVal
74301>>>>>    End_Function
74302>>>>>
74302>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74304>>>>>        Handle hDispatchDriver
74304>>>>>        OLE_COLOR retVal
74304>>>>>        Get phDispatchDriver to hDispatchDriver
74305>>>>>        Send PrepareParams to hDispatchDriver 1
74306>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74307>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74308>>>>>        Function_Return retVal
74309>>>>>    End_Function
74310>>>>>
74310>>>>>    Procedure ComExcludeModule String llModuleName
74312>>>>>        Handle hDispatchDriver
74312>>>>>        Get phDispatchDriver to hDispatchDriver
74313>>>>>        Send PrepareParams to hDispatchDriver 1
74314>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74315>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74316>>>>>    End_Procedure
74317>>>>>
74317>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74319>>>>>        Handle hDispatchDriver
74319>>>>>        Variant retVal
74319>>>>>        Get phDispatchDriver to hDispatchDriver
74320>>>>>        Send PrepareParams to hDispatchDriver 2
74321>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74322>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74323>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74324>>>>>        Function_Return retVal
74325>>>>>    End_Function
74326>>>>>
74326>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74328>>>>>        Handle hDispatchDriver
74328>>>>>        Get phDispatchDriver to hDispatchDriver
74329>>>>>        Send PrepareParams to hDispatchDriver 2
74330>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74331>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74332>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74333>>>>>    End_Procedure
74334>>>>>
74334>>>>>    Procedure ComAboutBox
74336>>>>>        Handle hDispatchDriver
74336>>>>>        Get phDispatchDriver to hDispatchDriver
74337>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74338>>>>>    End_Procedure
74339>>>>>End_Class
74340>>>>>
74340>>>>>// CLSID: {C0DE2000-4463-4030-B324-AC6A8075FEC8}
74340>>>>>// Event interface for SkinFramework Control
74340>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74341>>>>>
74341>>>>>    Procedure RegisterComEvents
74343>>>>>    End_Procedure
74344>>>>>End_Class
74345>>>>>
74345>>>>>// CoClass
74345>>>>>// ProgID: Codejock.SkinFramework.20.0.0
74345>>>>>// CLSID: {C0DE2000-2217-42EE-B1B0-82C890431F17}
74345>>>>>// SkinFramework Control
74345>>>>>Class cCJComSkinFramework is a cComActiveXControl
74346>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74347>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74348>>>>>
74348>>>>>    Procedure Construct_Object
74350>>>>>        Forward Send Construct_Object
74352>>>>>        Set psProgID to "{C0DE2000-2217-42EE-B1B0-82C890431F17}"
74353>>>>>        Set psEventId to "{C0DE2000-4463-4030-B324-AC6A8075FEC8}"
74354>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2021 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v20.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74355>>>>>        Set peAutoCreate to acAutoCreate
74356>>>>>    End_Procedure
74357>>>>>End_Class
74358>>>>>
74358>>>>>// CLSID: {C0DE2000-CA9A-4AA9-8601-0AB7F551AA3D}
74358>>>>>// SkinFramework Global Settings
74358>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74359>>>>>
74359>>>>>    Function ComLicense Returns String
74361>>>>>        String retVal
74361>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74362>>>>>        Function_Return retVal
74363>>>>>    End_Function
74364>>>>>
74364>>>>>    Procedure Set ComLicense String value
74366>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74367>>>>>    End_Procedure
74368>>>>>
74368>>>>>    Function ComTitle Returns String
74370>>>>>        String retVal
74370>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74371>>>>>        Function_Return retVal
74372>>>>>    End_Function
74373>>>>>
74373>>>>>    Procedure Set ComTitle String value
74375>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74376>>>>>    End_Procedure
74377>>>>>
74377>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74377>>>>>    Function ComUseLegacyCore Returns Boolean
74379>>>>>        Boolean retVal
74379>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74380>>>>>        Function_Return retVal
74381>>>>>    End_Function
74382>>>>>
74382>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74382>>>>>    Procedure Set ComUseLegacyCore Boolean value
74384>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74385>>>>>    End_Procedure
74386>>>>>
74386>>>>>    Function ComVersion Returns String
74388>>>>>        Handle hDispatchDriver
74388>>>>>        String retVal
74388>>>>>        Get phDispatchDriver to hDispatchDriver
74389>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74390>>>>>        Function_Return retVal
74391>>>>>    End_Function
74392>>>>>
74392>>>>>    Function ComUnicode Returns Boolean
74394>>>>>        Handle hDispatchDriver
74394>>>>>        Boolean retVal
74394>>>>>        Get phDispatchDriver to hDispatchDriver
74395>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74396>>>>>        Function_Return retVal
74397>>>>>    End_Function
74398>>>>>
74398>>>>>    Function ComOcxPath Returns String
74400>>>>>        Handle hDispatchDriver
74400>>>>>        String retVal
74400>>>>>        Get phDispatchDriver to hDispatchDriver
74401>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74402>>>>>        Function_Return retVal
74403>>>>>    End_Function
74404>>>>>End_Class
74405>>>>>
74405>>>>>// CoClass
74405>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.20.0.0
74405>>>>>// CLSID: {C0DE2000-F744-4373-B38D-29CE83EF0EE5}
74405>>>>>// SkinFramework Global Settings
74405>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74406>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74407>>>>>
74407>>>>>    Procedure Construct_Object
74409>>>>>        Forward Send Construct_Object
74411>>>>>        Set psProgID to "{C0DE2000-F744-4373-B38D-29CE83EF0EE5}"
74412>>>>>        Set peAutoCreate to acNoAutoCreate
74413>>>>>    End_Procedure
74414>>>>>End_Class
74415>>>>>
74415>>>>>// CLSID: {C0DE2000-1038-498E-A936-361F08B4C4AA}
74415>>>>>Class cCJSkinIniFile is a cComAutomationObject
74416>>>>>
74416>>>>>    Function ComColorScheme Returns String
74418>>>>>        String retVal
74418>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74419>>>>>        Function_Return retVal
74420>>>>>    End_Function
74421>>>>>
74421>>>>>    Procedure Set ComColorScheme String value
74423>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74424>>>>>    End_Procedure
74425>>>>>
74425>>>>>    Function ComFontSize Returns String
74427>>>>>        String retVal
74427>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74428>>>>>        Function_Return retVal
74429>>>>>    End_Function
74430>>>>>
74430>>>>>    Procedure Set ComFontSize String value
74432>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74433>>>>>    End_Procedure
74434>>>>>
74434>>>>>    Function ComIniFileName Returns String
74436>>>>>        String retVal
74436>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74437>>>>>        Function_Return retVal
74438>>>>>    End_Function
74439>>>>>
74439>>>>>    Procedure Set ComIniFileName String value
74441>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74442>>>>>    End_Procedure
74443>>>>>End_Class
74444>>>>>
74444>>>>>// CLSID: {C0DE2000-4834-499E-95B4-30E0C3F43A10}
74444>>>>>Class cCJSkinDescription is a cComAutomationObject
74445>>>>>
74445>>>>>    Function ComName Returns String
74447>>>>>        String retVal
74447>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74448>>>>>        Function_Return retVal
74449>>>>>    End_Function
74450>>>>>
74450>>>>>    Procedure Set ComName String value
74452>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74453>>>>>    End_Procedure
74454>>>>>
74454>>>>>    Function ComPath Returns String
74456>>>>>        String retVal
74456>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74457>>>>>        Function_Return retVal
74458>>>>>    End_Function
74459>>>>>
74459>>>>>    Procedure Set ComPath String value
74461>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74462>>>>>    End_Procedure
74463>>>>>
74463>>>>>    Function ComCount Returns Integer
74465>>>>>        Handle hDispatchDriver
74465>>>>>        Integer retVal
74465>>>>>        Get phDispatchDriver to hDispatchDriver
74466>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74467>>>>>        Function_Return retVal
74468>>>>>    End_Function
74469>>>>>
74469>>>>>    Function ComIniFile Integer llIndex Returns Variant
74471>>>>>        Handle hDispatchDriver
74471>>>>>        Variant retVal
74471>>>>>        Get phDispatchDriver to hDispatchDriver
74472>>>>>        Send PrepareParams to hDispatchDriver 1
74473>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74474>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74475>>>>>        Function_Return retVal
74476>>>>>    End_Function
74477>>>>>
74477>>>>>    Function Com_NewEnum Returns Variant
74479>>>>>        Handle hDispatchDriver
74479>>>>>        Variant retVal
74479>>>>>        Get phDispatchDriver to hDispatchDriver
74480>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74481>>>>>        Function_Return retVal
74482>>>>>    End_Function
74483>>>>>End_Class
74484>>>>>
74484>>>>>// CLSID: {C0DE2000-FB37-4B08-A2B9-F6F8B253D697}
74484>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74485>>>>>
74485>>>>>    Function ComCount Returns Integer
74487>>>>>        Handle hDispatchDriver
74487>>>>>        Integer retVal
74487>>>>>        Get phDispatchDriver to hDispatchDriver
74488>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74489>>>>>        Function_Return retVal
74490>>>>>    End_Function
74491>>>>>
74491>>>>>    Function ComSkin Integer llIndex Returns Variant
74493>>>>>        Handle hDispatchDriver
74493>>>>>        Variant retVal
74493>>>>>        Get phDispatchDriver to hDispatchDriver
74494>>>>>        Send PrepareParams to hDispatchDriver 1
74495>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74496>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74497>>>>>        Function_Return retVal
74498>>>>>    End_Function
74499>>>>>
74499>>>>>    Function Com_NewEnum Returns Variant
74501>>>>>        Handle hDispatchDriver
74501>>>>>        Variant retVal
74501>>>>>        Get phDispatchDriver to hDispatchDriver
74502>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74503>>>>>        Function_Return retVal
74504>>>>>    End_Function
74505>>>>>End_Class
74506>>>>>
74506>>>>>// CLSID: {C0DE2000-C56F-43C0-BCF1-8193B35FE4C4}
74506>>>>>Class cCJSkinSchema is a cComAutomationObject
74507>>>>>
74507>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74509>>>>>        Handle hDispatchDriver
74509>>>>>        OLE_COLOR retVal
74509>>>>>        Get phDispatchDriver to hDispatchDriver
74510>>>>>        Send PrepareParams to hDispatchDriver 1
74511>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74512>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74513>>>>>        Function_Return retVal
74514>>>>>    End_Function
74515>>>>>End_Class
74516>>>Use cApplication.pkg
74516>>>
74516>>>Struct tSkinInformation
74516>>>    String sName     // description of the skin
74516>>>    String sSkinfile // file path. Can be relative or full
74516>>>    String sSkinIni  // section name
74516>>>End_Struct
74516>>>
74516>>>
74516>>>Class cCJSkinFramework is a cCJComSkinFramework
74517>>>    
74517>>>    Procedure Construct_Object
74519>>>        Forward Send Construct_Object
74521>>>        
74521>>>        Property String psSkinFile ""
74522>>>        Property String psSkinIni ""
74523>>>        Property Boolean pbLoadPreference False
74524>>>        
74524>>>        Set peAutoCreate to acAutoCreate
74525>>>        
74525>>>        Move Self to ghoSkinFramework
74526>>>    End_Procedure
74527>>>    
74527>>>    // return the default skin path, which is the programs directory.
74527>>>    // This requires an application object.
74527>>>    // If you want to different skin path, override this.
74527>>>    Function SkinPath Returns String
74529>>>        String sPath sPaths
74529>>>        Handle hoWorkspace
74529>>>        If ghoApplication Begin
74531>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74532>>>            Get psProgramPath of hoWorkspace to sPaths
74533>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74534>>>        End
74534>>>>
74534>>>        Else Begin
74535>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74536>>>>
74536>>>        End
74536>>>>
74536>>>        Function_Return sPath
74537>>>    End_Function
74538>>>    
74538>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74538>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74538>>>    Function SkinQFile Returns String
74540>>>        String sFile sPath sSep
74540>>>        Boolean bQualified
74540>>>        Get psSkinFile to sFile
74541>>>        If not (IsFileNameQualified(sFile)) Begin
74543>>>            Get SkinPath to sPath
74544>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74545>>>            Move (sPath - sSep - sFile) to sFile
74546>>>        End
74546>>>>
74546>>>        Function_Return sFile
74547>>>    End_Function
74548>>>    
74548>>>    // defines the default VDF window class mapping.
74548>>>    Procedure OnAddVDFWindowClasses
74550>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74551>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74552>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74553>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74554>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74555>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74556>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74557>>>        Send ComAddWindowClass "DFbutton"                "Button"
74558>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74559>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74560>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74561>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74562>>>        Send ComAddWindowClass "DFedit"                  "edit"
74563>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74564>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74565>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74566>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74567>>>        // External class
74567>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74568>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74569>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74570>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74571>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74572>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74573>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74574>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74575>>>    End_Procedure
74576>>>    
74576>>>    // Used to support developer designed class mappings (e.g. COM controls)
74576>>>    Procedure OnAddCustomWindowClasses
74578>>>    End_Procedure
74579>>>    
74579>>>    // called when object is created during end_construct_object.
74579>>>    Procedure OnCreate
74581>>>        Integer iOpts
74581>>>        Boolean bUseWindowsFont
74581>>>        Forward Send OnCreate
74583>>>        
74583>>>        // if we are using the windows fonts we will disable the apply metrics which
74583>>>        // never really looked good anyway. This test only exists or legacy purposes
74583>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74584>>>        If bUseWindowsFont Begin
74586>>>            Get ComApplyOptions to iOpts
74587>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74588>>>        End
74588>>>>
74588>>>        
74588>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74588>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74588>>>        // and this was the suggested workaround.
74588>>>        Set ComAutoApplyNewThreads to False
74589>>>        
74589>>>        Send OnAddVDFWindowClasses
74590>>>        Send OnAddCustomWindowClasses
74591>>>        
74591>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74591>>>        If (pbLoadPreference(Self)) Begin
74593>>>            Send LoadSkinPreference
74594>>>        End
74594>>>>
74594>>>        // if a skin file name exists, we apply the skin.
74594>>>        If (psSkinFile(Self)<>"") Begin
74596>>>            Send ApplySkin
74597>>>        End
74597>>>>
74597>>>    End_Procedure
74598>>>    
74598>>>    // called by framework as part of application exit.
74598>>>    Procedure Broadcast_Notify_Exit_Application
74600>>>        Send Notify_Exit_Application
74601>>>    End_Procedure
74602>>>    
74602>>>    Procedure Notify_Exit_Application
74604>>>        If (pbLoadPreference(Self)) Begin
74606>>>            Send SaveSkinPreference
74607>>>        End
74607>>>>
74607>>>    End_Procedure
74608>>>    
74608>>>    Procedure NotifyPreApplySkin
74610>>>        Broadcast Send OnPreApplySkin of Desktop True
74612>>>    End_Procedure
74613>>>    
74613>>>    Procedure NotifyPostApplySkin
74615>>>        Broadcast Send OnPostApplySkin of Desktop True
74617>>>    End_Procedure
74618>>>    
74618>>>    // returns an array of all skins in the path. If path is "", use the default path.
74618>>>    // If the default path is used, returns the file names as relative names, else use full path.
74618>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74620>>>        tSkinInformation[] Skins
74620>>>        tSkinInformation[] Skins
74621>>>        String sSkinName sSkinFile sDefaultPath sSep
74621>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74621>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74621>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74621>>>        Integer iPos iDfltLen
74621>>>        Boolean bUseRelativePath
74621>>>        
74621>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74622>>>        
74622>>>        Get SkinPath to sDefaultPath
74623>>>        If (sPath="") Begin
74625>>>            Move sDefaultPath to sPath
74626>>>        End
74626>>>>
74626>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74627>>>        Move (Length(sDefaultPath)) to iDfltLen
74628>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74629>>>        
74629>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74630>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74632>>>            
74632>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74633>>>            Get Create U_cCJSkinDescription to hSkinDescription
74634>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74635>>>            
74635>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74636>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74637>>>            
74637>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74643>>>>
74643>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74644>>>                Set pvComObject of hSkinDescription to vSkinDescription
74645>>>                
74645>>>                Get ComCount of hSkinDescription to iNumSkins
74646>>>                
74646>>>                For iSkinsCount from 0 to (iNumSkins-1)
74652>>>>
74652>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74653>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74654>>>                    
74654>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74655>>>                    Get ComPath of hSkinDescription to sSkinFile
74656>>>                    If bUseRelativePath Begin
74658>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74659>>>                        If iPos Begin
74661>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74662>>>                            While (Left(sSkinFile,1)=sSep)
74666>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74667>>>                            Loop
74668>>>>
74668>>>                        End
74668>>>>
74668>>>                    End
74668>>>>
74668>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74669>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74670>>>                    
74670>>>                    Increment iArrayItem
74671>>>                Loop
74672>>>>
74672>>>            Loop
74673>>>>
74673>>>            
74673>>>            Send Destroy of hSkinDescriptions
74674>>>            Send Destroy of hSkinDescription
74675>>>            Send Destroy of hSkinIniFile
74676>>>            
74676>>>        End
74676>>>>
74676>>>        Function_Return Skins
74677>>>    End_Function
74678>>>    
74678>>>    // Save the skin preference. This requires an application object.
74678>>>    // Only do this if the application object allows it.
74678>>>    // This is called during startup if pbLoadPreference is True
74678>>>    // Suitable for override
74678>>>    Procedure SaveSkinPreference
74680>>>        String sSkin sIni
74680>>>        If ghoApplication Begin
74682>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74684>>>                Get psSkinFile to sSkin
74685>>>                Get psSkinIni to sIni
74686>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74687>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74688>>>            End
74688>>>>
74688>>>        End
74688>>>>
74688>>>        Else Begin
74689>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74690>>>>
74690>>>        End
74690>>>>
74690>>>    End_Procedure
74691>>>    
74691>>>    // Load the skin preference. This requires an application object.
74691>>>    // Only do this if the application object allows it.
74691>>>    // This is called during startup if pbLoadPreference is True
74691>>>    // Suitable for override
74691>>>    Procedure LoadSkinPreference
74693>>>        String sSkin sIni
74693>>>        Boolean bExists
74693>>>        If ghoApplication Begin
74695>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74697>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74698>>>                If bExists Begin
74700>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74701>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74702>>>                    Set psSkinFile to sSkin
74703>>>                    Set psSkinIni to sIni
74704>>>                End
74704>>>>
74704>>>            End
74704>>>>
74704>>>        End
74704>>>>
74704>>>        Else Begin
74705>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74706>>>>
74706>>>        End
74706>>>>
74706>>>    End_Procedure
74707>>>    
74707>>>    // Can be called to apply the current skin.
74707>>>    Procedure ApplySkin
74709>>>        Boolean bOk
74709>>>        String sSkin sIni
74709>>>        If (IsComObjectCreated(Self)) Begin
74711>>>            Get SkinQFile to sSkin
74712>>>            Get psSkinIni to sIni
74713>>>            
74713>>>            Send NotifyPreApplySkin
74714>>>            // when skins are used we don't want to use built in Visual Styles
74714>>>            Send EnableVisualStyles of Desktop (sSkin="")
74715>>>            Get ComLoadSkin sSkin sIni to bOK
74716>>>            If (sSkin<>"" and not(bOk)) Begin
74718>>>                // if not ok, no skin was appied. Enable visual styles
74718>>>                Send EnableVisualStyles of Desktop True
74719>>>            End
74719>>>>
74719>>>            Send NotifyPostApplySkin
74720>>>        End
74720>>>>
74720>>>    End_Procedure
74721>>>    
74721>>>    
74721>>>End_Class
74722>Use cCJCommandBarSystem.pkg                      
74722>// Unmark this Define statement if using Mertech drivers!
74722>Define DUF_Use_Mertech_Drivers
74722>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
74722>>>//****************************************************************************
74722>>>// $Module type: Class
74722>>>// $Module name: cSQLConnectionIniFile.pkg
74722>>>//
74722>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
74722>>>// Copyright (c) 2012 RDC Tools International
74722>>>// E-mail      : support@rdctools.com
74722>>>// Web-site    : http://www.rdctools.com
74722>>>//
74722>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
74722>>>//
74722>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
74722>>>//               properties of that object.
74722>>>//
74722>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
74722>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
74722>>>// This is free software; you can redistribute it and/or modify it under the terms of the
74722>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
74722>>>// in the help folder for more details.
74722>>>//
74722>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
74722>>>>>//****************************************************************************
74722>>>>>// $Module type: Include file
74722>>>>>// $Module name: cSQLConnectionIniFile.inc
74722>>>>>//
74722>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
74722>>>>>// Copyright (c) 2012 RDC Tools International
74722>>>>>// E-mail      : support@rdctools.com
74722>>>>>// Web-site    : http://www.rdctools.com
74722>>>>>//
74722>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
74722>>>>>//
74722>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
74722>>>>>//
74722>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
74722>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
74722>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
74722>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
74722>>>>>// in the help folder for more details.
74722>>>>>//
74722>>>>>Use Winkern.pkg
74722>>>>>Use cIniFile.pkg
74722>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCryptographerEx.pkg)
74722>>>>>>>Use VdfBase.pkg
74722>>>>>>>
74722>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.1\Pkg\CryptographerConstants.pkg)
74722>>>>>>>>>//   Author  : Ulbe Stellema
74722>>>>>>>>>// Algorithm classes
74722>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
74722>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
74722>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
74722>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
74722>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
74722>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
74722>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
74722>>>>>>>>>
74722>>>>>>>>>// Algorithm types
74722>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
74722>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
74722>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
74722>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
74722>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
74722>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
74722>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
74722>>>>>>>>>
74722>>>>>>>>>// Generic sub-ids
74722>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
74722>>>>>>>>>
74722>>>>>>>>>// RSA sub-ids
74722>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
74722>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
74722>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
74722>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
74722>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
74722>>>>>>>>>
74722>>>>>>>>>// DSS sub-ids
74722>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
74722>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
74722>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
74722>>>>>>>>>
74722>>>>>>>>>// DES sub_ids
74722>>>>>>>>>Define ALG_SID_DES                      for 1
74722>>>>>>>>>Define ALG_SID_3DES                     for 3
74722>>>>>>>>>Define ALG_SID_DESX                     for 4
74722>>>>>>>>>Define ALG_SID_IDEA                     for 5
74722>>>>>>>>>Define ALG_SID_CAST                     for 6
74722>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
74722>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
74722>>>>>>>>>Define ALG_SID_3DES_112                 for 9
74722>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
74722>>>>>>>>>Define ALG_SID_RC5                      for 13
74722>>>>>>>>>Define ALG_SID_AES_128                  for 14
74722>>>>>>>>>Define ALG_SID_AES_192                  for 15
74722>>>>>>>>>Define ALG_SID_AES_256                  for 16
74722>>>>>>>>>Define ALG_SID_AES                      for 17
74722>>>>>>>>>
74722>>>>>>>>>// Fortezza sub-ids
74722>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
74722>>>>>>>>>Define ALG_SID_TEK                      for 11
74722>>>>>>>>>
74722>>>>>>>>>// RC2 sub-ids
74722>>>>>>>>>Define ALG_SID_RC2                      for 2
74722>>>>>>>>>
74722>>>>>>>>>// Stream cipher sub-ids
74722>>>>>>>>>Define ALG_SID_RC4                      for 1
74722>>>>>>>>>Define ALG_SID_SEAL                     for 2
74722>>>>>>>>>
74722>>>>>>>>>// Diffie-Hellman sub-ids
74722>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
74722>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
74722>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
74722>>>>>>>>>Define ALG_SID_KEA                      for 4
74722>>>>>>>>>
74722>>>>>>>>>// Hash sub ids
74722>>>>>>>>>Define ALG_SID_MD2                      for 1
74722>>>>>>>>>Define ALG_SID_MD4                      for 2
74722>>>>>>>>>Define ALG_SID_MD5                      for 3
74722>>>>>>>>>Define ALG_SID_SHA                      for 4
74722>>>>>>>>>Define ALG_SID_SHA1                     for 4
74722>>>>>>>>>Define ALG_SID_MAC                      for 5
74722>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
74722>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
74722>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
74722>>>>>>>>>Define ALG_SID_HMAC                     for 9
74722>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
74722>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
74722>>>>>>>>>Define ALG_SID_SHA_256                  for 12
74722>>>>>>>>>Define ALG_SID_SHA_384                  for 13
74722>>>>>>>>>Define ALG_SID_SHA_512                  for 14
74722>>>>>>>>>
74722>>>>>>>>>// secure channel sub ids
74722>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
74722>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
74722>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
74722>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
74722>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
74722>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
74722>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
74722>>>>>>>>>
74722>>>>>>>>>// algorithm identifier definitions
74722>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
74722>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
74722>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
74722>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
74722>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
74722>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
74722>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
74722>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
74722>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
74722>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
74722>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
74722>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
74722>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
74722>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
74722>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
74722>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
74722>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
74722>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
74722>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
74722>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
74722>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
74722>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
74722>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
74722>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
74722>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
74722>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
74722>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
74722>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
74722>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
74722>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
74722>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
74722>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
74722>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
74722>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
74722>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
74722>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
74722>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
74722>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
74722>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
74722>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
74722>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
74722>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
74722>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
74722>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
74722>>>>>>>>>
74722>>>>>>>>>// Providers
74722>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
74722>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
74722>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
74722>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
74722>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
74722>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
74722>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
74722>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
74722>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
74722>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
74722>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
74722>>>>>>>>>
74722>>>>>>>>>// dwFlags definitions for CryptAcquireContext
74722>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
74722>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
74722>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
74722>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
74722>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
74722>>>>>>>>>
74722>>>>>>>>>// dwFlag definitions for CryptGenKey
74722>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
74722>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
74722>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
74722>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
74722>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
74722>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
74722>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
74722>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
74722>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
74722>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
74722>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
74722>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
74722>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
74722>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
74722>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
74722>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
74722>>>>>>>>>
74722>>>>>>>>>// Provider types
74722>>>>>>>>>Define PROV_RSA_FULL                    for 1
74722>>>>>>>>>Define PROV_RSA_SIG                     for 2
74722>>>>>>>>>Define PROV_DSS                         for 3
74722>>>>>>>>>Define PROV_FORTEZZA                    for 4
74722>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
74722>>>>>>>>>Define PROV_SSL                         for 6
74722>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
74722>>>>>>>>>Define PROV_DSS_DH                      for 13
74722>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
74722>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
74722>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
74722>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
74722>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
74722>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
74722>>>>>>>>>Define PROV_RNG                         for 21
74722>>>>>>>>>Define PROV_INTEL_SEC                   for 22
74722>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
74722>>>>>>>>>Define PROV_RSA_AES                     for 24
74722>>>>>>>>>
74722>>>>>>>>>// KP_MODE
74722>>>>>>>>>// KP_MODE
74722>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
74722>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
74722>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
74722>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
74722>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
74722>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
74722>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
74722>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
74722>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
74722>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
74722>>>>>>>>>
74722>>>>>>>>>// dwParam definitions for CryptGetKeyParam
74722>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
74722>>>>>>>>>Define KP_SALT                          for 2       // Salt value
74722>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
74722>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
74722>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
74722>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
74722>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
74722>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
74722>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
74722>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
74722>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
74722>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
74722>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
74722>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
74722>>>>>>>>>Define KP_Y                             for 15      // Y value
74722>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
74722>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
74722>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
74722>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
74722>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
74722>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
74722>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
74722>>>>>>>>>Define KP_RP                            for 23
74722>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
74722>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
74722>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
74722>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
74722>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
74722>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
74722>>>>>>>>>Define KP_KEYVAL                        for 30
74722>>>>>>>>>Define KP_ADMIN_PIN                     for 31
74722>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
74722>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
74722>>>>>>>>>Define KP_PREHASH                       for 34
74722>>>>>>>>>Define KP_ROUNDS                        for 35
74722>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
74722>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
74722>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
74722>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
74722>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
74722>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
74722>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
74722>>>>>>>>>
74722>>>>>>>>>// dwParam definitions for CryptGetHashParam
74722>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
74722>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
74722>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
74722>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
74722>>>>>>>>>
74722>>>>>>>>>// key BLOB types
74722>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
74722>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
74722>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
74722>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
74722>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
74722>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
74722>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
74722>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
74722>>>>>>>>>
74722>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
74722>>>>>>>>>
74722>>>>>>>>>// KP_PADDING
74722>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
74722>>>>>>>>>Define RANDOM_PADDING                   for 2
74722>>>>>>>>>Define ZERO_PADDING                     for 3
74722>>>>>>>>>
74722>>>>>>>>>//  Structure cryptimportkey
74722>>>>>>>>>Struct PUBLICKEYSTRUC
74722>>>>>>>>>    UChar    bType
74722>>>>>>>>>    UChar    bVersion
74722>>>>>>>>>    UShort   reserved
74722>>>>>>>>>    UInteger aiKeyAlg
74722>>>>>>>>>End_Struct
74722>>>>>>>>>
74722>>>>>>>>>Struct tPLAINTEXTKEYBLOB
74722>>>>>>>>>    PUBLICKEYSTRUC hdr
74722>>>>>>>>>    PUBLICKEYSTRUC hdr
74722>>>>>>>>>    UInteger       dwKeySize
74722>>>>>>>>>//    UChar[]        rgbKeyData
74722>>>>>>>>>End_Struct
74722>>>>>>>>>
74722>>>>>>>>>
74722>>>>>>>>>
74722>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
74722>>>>>>>>>Struct HMAC_INFO
74722>>>>>>>>>    UInteger HashAlgid
74722>>>>>>>>>    Pointer pbInnerString
74722>>>>>>>>>    DWord cbInnerString
74722>>>>>>>>>    Pointer pbOuterString
74722>>>>>>>>>    DWord cbOuterString
74722>>>>>>>>>End_Struct
74722>>>>>>>>>
74722>>>>>>>>>Struct BLOBHEADER
74722>>>>>>>>>    UChar   bType
74722>>>>>>>>>    UChar   bVersion
74722>>>>>>>>>    Short   reserved
74722>>>>>>>>>    Integer aiKeyAlg
74722>>>>>>>>>End_Struct
74722>>>>>>>>>
74722>>>>>>>>>Struct CryptoBlob
74722>>>>>>>>>    BLOBHEADER  header
74722>>>>>>>>>    BLOBHEADER  header
74722>>>>>>>>>    Integer     cbKeySize
74722>>>>>>>>>    UChar[32]   rgbKeyData
74722>>>>>>>>>End_Struct
74722>>>>>>>>>
74722>>>>>>>>>
74722>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
74722>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
74723>>>>>>>>>
74723>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
74723>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
74725>>>>>>>>>    
74725>>>>>>>>>    Boolean bResult
74725>>>>>>>>>    UWide   uwContainer uwProvider
74725>>>>>>>>>    UWide   uwContainer uwProvider
74725>>>>>>>>>
74725>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
74726>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
74727>>>>>>>>>    
74727>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
74728>>>>>>>>>
74728>>>>>>>>>    Function_Return bResult
74729>>>>>>>>>End_Function
74730>>>>>>>>>
74730>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
74731>>>>>>>>>
74731>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
74732>>>>>>>>>
74732>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
74733>>>>>>>>>
74733>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
74734>>>>>>>>>
74734>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
74735>>>>>>>>>
74735>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
74736>>>>>>>>>
74736>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
74737>>>>>>>>>
74737>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
74738>>>>>>>>>
74738>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
74739>>>>>>>>>    
74739>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
74740>>>>>>>>>
74740>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
74741>>>>>>>>>
74741>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
74742>>>>>>>>>
74742>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
74743>>>>>>>>>    
74743>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
74744>>>>>>>>>    
74744>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
74745>>>>>>>>>    
74745>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
74746>>>>>>>
74746>>>>>>>Class cCryptographerEx is a cObject
74747>>>>>>>    
74747>>>>>>>    Procedure Construct_Object
74749>>>>>>>        Forward Send Construct_Object
74751>>>>>>>        
74751>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
74752>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
74753>>>>>>>        Property Integer    piCipher    CALG_RC4
74754>>>>>>>        Property Integer    piHash      CALG_MD5
74755>>>>>>>        
74755>>>>>>>        // Private properties
74755>>>>>>>        Property Handle     Private_phProv
74756>>>>>>>        
74756>>>>>>>        // Block cipher properties
74756>>>>>>>        Property UChar[]    paKey
74757>>>>>>>        Property UChar[]    paIV
74758>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
74759>>>>>>>        Property Integer    piKeyType       CALG_AES_256
74760>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
74761>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
74762>>>>>>>        Property Integer    piBlockSize     16
74763>>>>>>>    End_Procedure
74764>>>>>>>    
74764>>>>>>>    
74764>>>>>>>    // Acquire key container handle
74764>>>>>>>    Function AcquireContext Returns Handle
74766>>>>>>>        Integer iProvider
74766>>>>>>>        WString wProvider
74766>>>>>>>        Handle hProv
74766>>>>>>>        Boolean bOk
74766>>>>>>>        Pointer pProv
74766>>>>>>>        
74766>>>>>>>        Move 0 to hProv
74767>>>>>>>        Get piProvider to iProvider
74768>>>>>>>        Get psProvider to wProvider
74769>>>>>>>        
74769>>>>>>>        //  Determine address to be passed as provider
74769>>>>>>>        If (Trim(wProvider) <> "") Begin
74771>>>>>>>            Move (AddressOf(wProvider)) to pProv
74772>>>>>>>        End
74772>>>>>>>>
74772>>>>>>>        Else Begin
74773>>>>>>>            Move 0 to pProv
74774>>>>>>>        End
74774>>>>>>>>
74774>>>>>>>        
74774>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
74774>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
74775>>>>>>>        If (not(bOk) or hProv = 0) Begin
74777>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
74778>>>>>>>        End
74778>>>>>>>>
74778>>>>>>>        
74778>>>>>>>        If (not(bOk) or hProv = 0) Begin
74780>>>>>>>            // Fallback to original
74780>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
74781>>>>>>>            
74781>>>>>>>            If (not(bOk) or hProv = 0) Begin
74783>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
74784>>>>>>>            End
74784>>>>>>>>
74784>>>>>>>        End
74784>>>>>>>>
74784>>>>>>>        Set Private_phProv to hProv
74785>>>>>>>        
74785>>>>>>>        Function_Return hProv
74786>>>>>>>    End_Function
74787>>>>>>>    
74787>>>>>>>    // Releases key container handle
74787>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
74789>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
74790>>>>>>>    End_Function
74791>>>>>>>    
74791>>>>>>>    // Creates hash object
74791>>>>>>>    Function CreateHash Handle hProv Returns Handle
74793>>>>>>>        Integer iAlgorithm
74793>>>>>>>        Handle hHash
74793>>>>>>>        Boolean bOk
74793>>>>>>>        
74793>>>>>>>        Move 0 to hHash
74794>>>>>>>        Get piHash to iAlgorithm
74795>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
74796>>>>>>>        
74796>>>>>>>        Function_Return hHash
74797>>>>>>>    End_Function
74798>>>>>>>    
74798>>>>>>>    // Destroys the hash object
74798>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
74800>>>>>>>        Function_Return (CryptDestroyHash(hHash))
74801>>>>>>>    End_Function
74802>>>>>>>    
74802>>>>>>>    // Adds data to hash object
74802>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
74804>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
74805>>>>>>>    End_Function
74806>>>>>>>    
74806>>>>>>>    // Generates session key
74806>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
74808>>>>>>>        Integer iAlgorithm
74808>>>>>>>        Handle hKey
74808>>>>>>>        Boolean bOk
74808>>>>>>>        
74808>>>>>>>        Move 0 to hKey
74809>>>>>>>        Get piCipher to iAlgorithm
74810>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
74811>>>>>>>        
74811>>>>>>>        Function_Return hKey
74812>>>>>>>    End_Function
74813>>>>>>>    
74813>>>>>>>    // Imports a plain text key
74813>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
74815>>>>>>>        tPLAINTEXTKEYBLOB blobhead
74815>>>>>>>        tPLAINTEXTKEYBLOB blobhead
74815>>>>>>>        Boolean   bSuccess
74815>>>>>>>        Handle    hKey
74815>>>>>>>        Integer   iHeadSize iKeySize
74815>>>>>>>        UChar[]   ucaKeyblob
74816>>>>>>>        Integer iVoid
74816>>>>>>>        
74816>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
74817>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
74818>>>>>>>        
74818>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
74819>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
74820>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
74821>>>>>>>        Move iKeySize           to blobhead.dwKeySize
74822>>>>>>>        
74822>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
74823>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
74824>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
74825>>>>>>>        
74825>>>>>>>        Move 0 to hKey
74826>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
74827>>>>>>>        If (not(bSuccess)) Begin
74829>>>>>>>            Move (ShowLastError()) to iVoid
74830>>>>>>>        End
74830>>>>>>>>
74830>>>>>>>        
74830>>>>>>>        Function_Return hKey
74831>>>>>>>    End_Function
74832>>>>>>>    
74832>>>>>>>    // Destroys the key
74832>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
74834>>>>>>>        Function_Return (CryptDestroyKey(hKey))
74835>>>>>>>    End_Function
74836>>>>>>>    
74836>>>>>>>    // Retrieves key data
74836>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
74838>>>>>>>        Integer iBuffer iLen
74838>>>>>>>        Boolean bOk
74838>>>>>>>        
74838>>>>>>>        Move (SizeOfType(Integer)) to iLen
74839>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
74840>>>>>>>        Function_Return iBuffer
74841>>>>>>>    End_Function
74842>>>>>>>    
74842>>>>>>>    // Retrieves a hash value
74842>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
74844>>>>>>>        UChar[] ucHash
74845>>>>>>>        Integer liResult
74845>>>>>>>        DWord   dwDataLen
74845>>>>>>>        
74845>>>>>>>        Move 0 to dwDataLen
74846>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
74847>>>>>>>        If (liResult = 0) ;            Function_Return ""
74850>>>>>>>        
74850>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
74851>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
74852>>>>>>>        If (liResult = 0) ;            Function_Return ""
74855>>>>>>>        
74855>>>>>>>        Function_Return ucHash
74856>>>>>>>    End_Function
74857>>>>>>>
74857>>>>>>>    // Encrypts data
74857>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
74859>>>>>>>        Handle hProv hHash hKey
74859>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
74859>>>>>>>        Boolean bOk
74859>>>>>>>        
74859>>>>>>>        Get AcquireContext to hProv
74860>>>>>>>        If (hProv) Begin
74862>>>>>>>            Get CreateHash hProv to hHash
74863>>>>>>>            If (hHash) Begin
74865>>>>>>>                Get HashData hHash ucPassword to bOk
74866>>>>>>>                If (bOk) Begin
74868>>>>>>>                    Get piCipher to iAlgorithm
74869>>>>>>>                    Get DeriveKey hProv hHash to hKey
74870>>>>>>>                End
74870>>>>>>>>
74870>>>>>>>                Get DestroyHash hHash to bOk
74871>>>>>>>            End
74871>>>>>>>>
74871>>>>>>>            
74871>>>>>>>            If (hKey) Begin
74873>>>>>>>                //  First call to determine resulting data size
74873>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
74874>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
74875>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
74876>>>>>>>                
74876>>>>>>>                //  Reserve space in string
74876>>>>>>>                If (iDataLen < iCipherLen) Begin
74878>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
74879>>>>>>>                End
74879>>>>>>>>
74879>>>>>>>                
74879>>>>>>>                //  Call to really decrypt
74879>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
74880>>>>>>>                //If (not(bOk)) Begin
74880>>>>>>>                //Move "" to sData
74880>>>>>>>                //Move (GetLastError()) to iErr
74880>>>>>>>                //End
74880>>>>>>>                
74880>>>>>>>                Get DestroyKey hKey to bOk
74881>>>>>>>            End 
74881>>>>>>>>
74881>>>>>>>            Get ReleaseContext hProv to bOk
74882>>>>>>>        End 
74882>>>>>>>>
74882>>>>>>>        Function_Return ucData
74883>>>>>>>    End_Function
74884>>>>>>>    
74884>>>>>>>    // Decrypts data
74884>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
74886>>>>>>>        Handle hProv hHash hKey
74886>>>>>>>        Integer iAlgorithm iDataLen
74886>>>>>>>        Boolean bOk
74886>>>>>>>        
74886>>>>>>>        Get AcquireContext to hProv
74887>>>>>>>        If (hProv) Begin
74889>>>>>>>            Get CreateHash hProv to hHash
74890>>>>>>>            If (hHash) Begin
74892>>>>>>>                Get HashData hHash ucPassword to bOk
74893>>>>>>>                If (bOk) Begin
74895>>>>>>>                    Get piCipher to iAlgorithm
74896>>>>>>>                    Get DeriveKey hProv hHash to hKey
74897>>>>>>>                End
74897>>>>>>>>
74897>>>>>>>                Get DestroyHash hHash to bOk
74898>>>>>>>            End
74898>>>>>>>>
74898>>>>>>>            
74898>>>>>>>            If (hKey) Begin
74900>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
74901>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
74902>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
74902>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
74904>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
74905>>>>>>>                End
74905>>>>>>>>
74905>>>>>>>                
74905>>>>>>>                Get DestroyKey hKey to bOk
74906>>>>>>>            End
74906>>>>>>>>
74906>>>>>>>            Get ReleaseContext hProv to bOk
74907>>>>>>>        End
74907>>>>>>>>
74907>>>>>>>        Function_Return ucData
74908>>>>>>>    End_Function
74909>>>>>>>    
74909>>>>>>>    // Creates a key
74909>>>>>>>    Function CreateKey Handle hProv Returns Handle
74911>>>>>>>        Integer iAlg iType iByte iLength iSize
74911>>>>>>>        CryptoBlob keyBlob
74911>>>>>>>        CryptoBlob keyBlob
74911>>>>>>>        Boolean bOk
74911>>>>>>>        Handle hKey
74911>>>>>>>        UChar[] aKey
74912>>>>>>>
74912>>>>>>>        Get paKey to aKey
74913>>>>>>>        Get piKeyAlg to iAlg
74914>>>>>>>        Get piKeyType to iType
74915>>>>>>>        Move iAlg                   to keyBlob.header.bType
74916>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
74917>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
74918>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
74919>>>>>>>        
74919>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
74920>>>>>>>        For iByte from 0 to iLength
74926>>>>>>>>
74926>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
74927>>>>>>>        Loop
74928>>>>>>>>
74928>>>>>>>        
74928>>>>>>>        Move 0 to hKey
74929>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
74930>>>>>>>        Function_Return hKey
74931>>>>>>>    End_Function
74932>>>>>>>    
74932>>>>>>>    // Sets the key parameters
74932>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
74934>>>>>>>        Integer iPadding iMode
74934>>>>>>>        Boolean bOk
74934>>>>>>>        UChar[] aIV
74935>>>>>>>        
74935>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
74935>>>>>>>        //For iByte from 0 to iLength
74935>>>>>>>        //    Move iByte to aIV[iByte]
74935>>>>>>>        //Loop
74935>>>>>>>
74935>>>>>>>        // Set initialization vector
74935>>>>>>>        Get paIV to aIV
74936>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
74937>>>>>>>        If (bOk) Begin
74939>>>>>>>            // Set padding
74939>>>>>>>            Get piKeyPadding to iPadding
74940>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
74941>>>>>>>            If (bOk) Begin
74943>>>>>>>                // Set move
74943>>>>>>>                Get piKeyMode to iMode
74944>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
74945>>>>>>>            End
74945>>>>>>>>
74945>>>>>>>        End
74945>>>>>>>>
74945>>>>>>>        Function_Return bOk        
74946>>>>>>>    End_Function
74947>>>>>>>    
74947>>>>>>>    // Encrypts using block cipher
74947>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
74949>>>>>>>        Handle hProv hKey
74949>>>>>>>        Integer iLen iSize iBlocks
74949>>>>>>>        Boolean bOk
74949>>>>>>>        
74949>>>>>>>        Get AcquireContext to hProv
74950>>>>>>>        If (hProv) Begin
74952>>>>>>>            // Create key
74952>>>>>>>            Get CreateKey hProv to hKey
74953>>>>>>>            If (hKey) Begin
74955>>>>>>>                Get SetKeyParameters hKey to bOk
74956>>>>>>>                If (bOk) Begin
74958>>>>>>>                    // Buffer for block ciphers can be up to block length larger
74958>>>>>>>                    Get piBlockSize to iSize
74959>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
74960>>>>>>>                    
74960>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
74961>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
74962>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
74963>>>>>>>                End
74963>>>>>>>>
74963>>>>>>>                Get DestroyKey hKey to bOk
74964>>>>>>>            End
74964>>>>>>>>
74964>>>>>>>            Get ReleaseContext hProv to bOk
74965>>>>>>>        End
74965>>>>>>>>
74965>>>>>>>        Function_Return ucData
74966>>>>>>>    End_Function
74967>>>>>>>    
74967>>>>>>>    // Decrypts using block cipher
74967>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
74969>>>>>>>        Handle hProv hKey
74969>>>>>>>        Integer iLen
74969>>>>>>>        Boolean bOk
74969>>>>>>>        
74969>>>>>>>        Get AcquireContext to hProv
74970>>>>>>>        If (hProv) Begin
74972>>>>>>>            // Create key
74972>>>>>>>            Get CreateKey hProv to hKey
74973>>>>>>>            If (hKey) Begin
74975>>>>>>>                Get SetKeyParameters hKey to bOk
74976>>>>>>>                If (bOk) Begin
74978>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
74979>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
74980>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
74981>>>>>>>                End
74981>>>>>>>>
74981>>>>>>>                Get DestroyKey hKey to bOk
74982>>>>>>>            End
74982>>>>>>>>
74982>>>>>>>            Get ReleaseContext hProv to bOk
74983>>>>>>>        End
74983>>>>>>>>
74983>>>>>>>        Function_Return ucData
74984>>>>>>>    End_Function
74985>>>>>>>    
74985>>>>>>>    
74985>>>>>>>    //  Generates random data.
74985>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
74987>>>>>>>        Handle hProv
74987>>>>>>>        UChar[] uaResult
74988>>>>>>>        Boolean bRes
74988>>>>>>>        
74988>>>>>>>        Get AcquireContext to hProv
74989>>>>>>>        
74989>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
74990>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
74991>>>>>>>        
74991>>>>>>>        Get ReleaseContext hProv to bRes
74992>>>>>>>        
74992>>>>>>>        Function_Return uaResult
74993>>>>>>>    End_Function
74994>>>>>>>    
74994>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
74994>>>>>>>    Function GenerateRandomString Integer iLength Returns String
74996>>>>>>>        String sResult
74996>>>>>>>        UChar[] ucData
74997>>>>>>>        Pointer pBase64
74997>>>>>>>        Integer iVoid
74997>>>>>>>        
74997>>>>>>>        Get GenerateRandom iLength to ucData
74998>>>>>>>        
74998>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
74999>>>>>>>        Move (PointerToString(pBase64)) to sResult
75000>>>>>>>        Move (Free(pBase64)) to iVoid
75001>>>>>>>        
75001>>>>>>>        Function_Return (Left(sResult, iLength))
75002>>>>>>>    End_Function
75003>>>>>>>    
75003>>>>>>>End_Class
75004>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
75004>>>>>>>//> This package enables base64 encoding and decoding of strings:
75004>>>>>>>//>
75004>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
75004>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
75004>>>>>>>//>
75004>>>>>>>//> Remember to set the "max argument size" if dealing with very large
75004>>>>>>>//> strings.
75004>>>>>>>//>
75004>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
75004>>>>>>>//> Base64Decode) that are built into the runtime.
75004>>>>>>>//>
75004>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
75004>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
75004>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
75004>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
75004>>>>>>>
75004>>>>>>>Use VdfBase.pkg
75004>>>>>>>
75004>>>>>>>// Functions in vdfBase64.dll
75004>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
75005>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
75006>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
75007>>>>>>>
75007>>>>>>>// Structure
75007>>>>>>>Struct txxfBase64Buffer
75007>>>>>>>    Pointer pData
75007>>>>>>>    Integer iLength
75007>>>>>>>End_Struct 
75007>>>>>>>
75007>>>>>>>Global_Variable Integer oBase64Functions
75007>>>>>>>
75007>>>>>>>Object _oBase64Functions is a cObject
75009>>>>>>>    Move Self to oBase64Functions
75010>>>>>>>
75010>>>>>>>
75010>>>>>>>    Function EncodeString String sValue Returns String
75013>>>>>>>        Address pBase64
75013>>>>>>>        String sResult
75013>>>>>>>        Integer iVoid
75013>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
75014>>>>>>>        Move (PointerToString(pBase64)) to sResult
75015>>>>>>>        Move (Free(pBase64)) to iVoid
75016>>>>>>>        Function_Return sResult
75017>>>>>>>    End_Function
75018>>>>>>>
75018>>>>>>>    Function DecodeString String sValue Returns String
75021>>>>>>>        Address pBinary
75021>>>>>>>        String sBinary
75021>>>>>>>        Integer iVoid iLen
75021>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
75022>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
75023>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
75024>>>>>>>        Move (Free(pBinary)) to iVoid
75025>>>>>>>        Function_Return sBinary
75026>>>>>>>    End_Function
75027>>>>>>>
75027>>>>>>>End_Object
75028>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\MSSqldrv.pkg)
75028>>>>>>>//     Package that declares MS SQL driver constants and functions.
75028>>>>>>>//     This package can be used by developers who want to add Data Access
75028>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75028>>>>>>>
75028>>>>>>>Use Cli.pkg
75028>>>>>>>Use SQL.pkg
75028>>>>>>>
75028>>>>>>>//   Driver Indentification
75028>>>>>>>
75028>>>>>>>//   Error number constants
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>// SQL Server spcific types.
75028>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75028>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75028>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75028>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75028>>>>>>>
75028>>>>>>>// SQL Server spcific types.
75028>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75028>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75028>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75028>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75028>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75028>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75028>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75028>>>>>>>//
75028>>>>>>>//     Setup a constraint for a file.
75028>>>>>>>
75028>>>>>>>
75028>>>>>>>Class cMSSQLHandler is a cCLIHandler
75029>>>>>>>    
75029>>>>>>>    Procedure Construct_Object
75031>>>>>>>        Forward Send Construct_Object
75033>>>>>>>        
75033>>>>>>>        Set psDriverID to MSSQLDRV_ID
75034>>>>>>>    End_Procedure
75035>>>>>>>    
75035>>>>>>>    
75035>>>>>>>    
75035>>>>>>>    //   Extract the list from the out connect string.
75035>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75037>>>>>>>        String  sItem
75037>>>>>>>        Integer iStart
75037>>>>>>>        Integer iEnd
75037>>>>>>>        
75037>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75040>>>>>>>        
75040>>>>>>>        Send Delete_Data to hoStore
75041>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75042>>>>>>>        While (iStart > 0)
75046>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75047>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75050>>>>>>>            Else Begin
75051>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75052>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75053>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75056>>>>>>>                
75056>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75059>>>>>>>                
75059>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75062>>>>>>>            End
75062>>>>>>>>
75062>>>>>>>        Loop
75063>>>>>>>>
75063>>>>>>>        
75063>>>>>>>        Function_Return (Item_Count(hoStore))
75064>>>>>>>    End_Procedure
75065>>>>>>>    
75065>>>>>>>    
75065>>>>>>>    
75065>>>>>>>    //   Call the driver's browse connect function
75065>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75067>>>>>>>        String  sDriver
75067>>>>>>>        String  sOutConnStr
75067>>>>>>>        Integer iArg
75067>>>>>>>        Integer iRetval
75067>>>>>>>        
75067>>>>>>>        Get psDriverID to sDriver
75068>>>>>>>        If (sDriver <> "") Begin
75070>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75071>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75076>>>>>>>        End
75076>>>>>>>>
75076>>>>>>>        
75076>>>>>>>        Function_Return sOutConnStr
75077>>>>>>>    End_Function// BrowseConnect
75078>>>>>>>    
75078>>>>>>>    
75078>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75080>>>>>>>        String  sDriver
75080>>>>>>>        String  sOutConnStr
75080>>>>>>>        Integer iArg
75080>>>>>>>        Integer iRetval
75080>>>>>>>        
75080>>>>>>>        Move 1 to iArg // Browses only local
75081>>>>>>>        
75081>>>>>>>        Get psDriverID to sDriver
75082>>>>>>>        If (sDriver <> "") Begin
75084>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75085>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75090>>>>>>>        End
75090>>>>>>>>
75090>>>>>>>        
75090>>>>>>>        Function_Return sOutConnStr
75091>>>>>>>    End_Function// BrowseConnect
75092>>>>>>>    
75092>>>>>>>    
75092>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75094>>>>>>>        
75094>>>>>>>        String  sServerList
75094>>>>>>>        Integer iNumServers
75094>>>>>>>        Integer iDriver
75094>>>>>>>        Integer iClientVersion
75094>>>>>>>        String  sDriver
75094>>>>>>>        
75094>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75095>>>>>>>        
75095>>>>>>>        If (iDriver) Begin
75097>>>>>>>            
75097>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75100>>>>>>>            
75100>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75101>>>>>>>            
75101>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75102>>>>>>>            If (iNetworkLocal = 0) Begin
75104>>>>>>>                Get BrowseConnect sDriver to sServerList
75105>>>>>>>            End
75105>>>>>>>>
75105>>>>>>>            Else Begin
75106>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75107>>>>>>>            End
75107>>>>>>>>
75107>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75108>>>>>>>        End
75108>>>>>>>>
75108>>>>>>>        
75108>>>>>>>        Function_Return iNumServers
75109>>>>>>>        
75109>>>>>>>    End_Function
75110>>>>>>>    
75110>>>>>>>    //   Enumerate the available SQL Server database servers
75110>>>>>>>    //   This function will return all SQL Server instances on the network.
75110>>>>>>>    //   This may take a long time.
75110>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75110>>>>>>>    Function EnumerateServers Returns Integer
75112>>>>>>>        
75112>>>>>>>        Integer iNumServers
75112>>>>>>>        Integer iNetworkLocal
75112>>>>>>>        
75112>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75113>>>>>>>        
75113>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75114>>>>>>>        
75114>>>>>>>        Function_Return iNumServers
75115>>>>>>>        
75115>>>>>>>    End_Function
75116>>>>>>>    
75116>>>>>>>    
75116>>>>>>>    //   Enumerate the available SQL Server database servers
75116>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75116>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75116>>>>>>>    Function EnumerateServersLocal Returns Integer
75118>>>>>>>        
75118>>>>>>>        Integer iNumServers
75118>>>>>>>        Integer iNetworkLocal
75118>>>>>>>        
75118>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75119>>>>>>>        
75119>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75120>>>>>>>        
75120>>>>>>>        Function_Return iNumServers
75121>>>>>>>        
75121>>>>>>>    End_Function
75122>>>>>>>    
75122>>>>>>>    
75122>>>>>>>    
75122>>>>>>>    //   Enumerate database in a given server.
75122>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75124>>>>>>>        Integer hoSQL
75124>>>>>>>        String  sConnect
75124>>>>>>>        String  sDatabase
75124>>>>>>>        Integer hdbc
75124>>>>>>>        Integer hstmt
75124>>>>>>>        Integer iFetchResult
75124>>>>>>>        
75124>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75127>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75130>>>>>>>        
75130>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75133>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75135>>>>>>>        
75135>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75137>>>>>>>            Move Current_Object to hoSQL
75138>>>>>>>        End_Object
75139>>>>>>>        
75139>>>>>>>        If (hoSQL <> 0) Begin
75141>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75142>>>>>>>            If (hdbc <> 0) Begin
75144>>>>>>>                Get SQLOpen of hdbc to hstmt
75145>>>>>>>                If (hstmt <> 0) Begin
75147>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75147>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75147>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75147>>>>>>>                    //   stay the same.
75147>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75148>>>>>>>                    Send SQLCall to hstmt
75149>>>>>>>                    Repeat
75149>>>>>>>>
75149>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75150>>>>>>>                        If (iFetchResult <> 0) Begin
75152>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75153>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75154>>>>>>>                        End
75154>>>>>>>>
75154>>>>>>>                    Until (iFetchResult = 0)
75156>>>>>>>                    
75156>>>>>>>                    Send SQLClose to hstmt
75157>>>>>>>                End
75157>>>>>>>>
75157>>>>>>>                Send SQLDisconnect to hdbc
75158>>>>>>>            End
75158>>>>>>>>
75158>>>>>>>        End
75158>>>>>>>>
75158>>>>>>>        Send Destroy_Object to hoSQL
75159>>>>>>>        
75159>>>>>>>        Function_Return (Item_Count(Current_Object))
75160>>>>>>>    End_Function
75161>>>>>>>    
75161>>>>>>>    
75161>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75163>>>>>>>        
75163>>>>>>>        String  sSqlServerClientVersionName
75163>>>>>>>        
75163>>>>>>>        
75163>>>>>>>        Case Begin
75163>>>>>>>            
75163>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75165>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75166>>>>>>>                Case Break
75167>>>>>>>                
75167>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75170>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75171>>>>>>>                Case Break
75172>>>>>>>            
75172>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75175>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75176>>>>>>>                Case Break
75177>>>>>>>            
75177>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75180>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75181>>>>>>>                Case Break
75182>>>>>>>            
75182>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75185>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75186>>>>>>>                Case Break
75187>>>>>>>            
75187>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75190>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75191>>>>>>>                Case Break
75192>>>>>>>            
75192>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75195>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75196>>>>>>>                Case Break
75197>>>>>>>            
75197>>>>>>>            Case Else
75197>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
75198>>>>>>>                
75198>>>>>>>        Case End
75198>>>>>>>        
75198>>>>>>>        
75198>>>>>>>        Function_Return sSqlServerClientVersionName
75199>>>>>>>        
75199>>>>>>>    End_Function
75200>>>>>>>
75200>>>>>>>
75200>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75202>>>>>>>        
75202>>>>>>>        String  sSqlServerClientDriverName
75202>>>>>>>        
75202>>>>>>>        Case Begin
75202>>>>>>>            
75202>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75204>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75205>>>>>>>                Case Break
75206>>>>>>>                
75206>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75209>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75210>>>>>>>                Case Break
75211>>>>>>>            
75211>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75214>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75215>>>>>>>                Case Break
75216>>>>>>>            
75216>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75219>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75220>>>>>>>                Case Break
75221>>>>>>>            
75221>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75224>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75225>>>>>>>                Case Break
75226>>>>>>>            
75226>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75229>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75230>>>>>>>                Case Break
75231>>>>>>>            
75231>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75234>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75235>>>>>>>                Case Break
75236>>>>>>>            
75236>>>>>>>            Case Else
75236>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75237>>>>>>>                
75237>>>>>>>        Case End
75237>>>>>>>        
75237>>>>>>>        
75237>>>>>>>        Function_Return sSqlServerClientDriverName
75238>>>>>>>        
75238>>>>>>>    End_Function
75239>>>>>>>    
75239>>>>>>>    
75239>>>>>>>End_Class
75240>>>>>>>
75240>>>>>>>
75240>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\db2_drv.pkg)
75240>>>>>>>// DB2_DRV.PKG                                                          
75240>>>>>>>//   Package that declares DB2 driver constants and functions.          
75240>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75240>>>>>>>//   specific code to a DataFlex application.                           
75240>>>>>>>
75240>>>>>>>Use Cli.pkg
75240>>>>>>>
75240>>>>>>>// Driver attributes
75240>>>>>>>
75240>>>>>>>
75240>>>>>>>// Driver Indentification
75240>>>>>>>
75240>>>>>>>// Error number constants
75240>>>>>>>
75240>>>>>>>// Call driver function identifiers
75240>>>>>>>
75240>>>>>>>// DB2 specific data types
75240>>>>>>>Define SQL_CLOB           for   (-99)
75240>>>>>>>Define SQL_BLOB           for   (-98)
75240>>>>>>>Define SQL_XML            for   (-370)
75240>>>>>>>// DB2 Graphic types are Unicode types
75240>>>>>>>Define SQL_GRAPHIC        for   (-95)
75240>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75240>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75240>>>>>>>Define SQL_DBCLOB         for   (-350)
75240>>>>>>>
75240>>>>>>>
75240>>>>>>>// Extra DB2 commands
75240>>>>>>>
75240>>>>>>>
75240>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75240>>>>>>>//   Setup a constraint for a file.                                     
75240>>>>>>>
75240>>>>>>>
75240>>>>>>>
75240>>>>>>>Class cDB2Handler is a cCLIHandler
75241>>>>>>>    
75241>>>>>>>    Procedure Construct_Object
75243>>>>>>>        Forward Send Construct_Object
75245>>>>>>>        
75245>>>>>>>        Set psDriverID to DB2_DRV_ID
75246>>>>>>>    End_Procedure
75247>>>>>>>    
75247>>>>>>>    
75247>>>>>>>    
75247>>>>>>>    // Reset the datasource list to the beginning
75247>>>>>>>    Procedure SeedDataSources
75249>>>>>>>        String  sDriver
75249>>>>>>>        String  sVoid
75249>>>>>>>        Integer iRetval
75249>>>>>>>        
75249>>>>>>>        Get psDriverID to sDriver
75250>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75257>>>>>>>    End_Procedure
75258>>>>>>>    
75258>>>>>>>    
75258>>>>>>>    
75258>>>>>>>    // Call the driver's data sources function
75258>>>>>>>    Function DataSources Returns String
75260>>>>>>>        String  sDriver
75260>>>>>>>        String  sDataSource
75260>>>>>>>        String  sDescription
75260>>>>>>>        Integer iLength
75260>>>>>>>        Integer iRetval
75260>>>>>>>        
75260>>>>>>>        Get psDriverID to sDriver
75261>>>>>>>        If (sDriver <> "") Begin
75263>>>>>>>            Move 8192 to iLength
75264>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75265>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75266>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75271>>>>>>>        End
75271>>>>>>>>
75271>>>>>>>        
75271>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75274>>>>>>>        Else ;            Function_Return ""
75276>>>>>>>    End_Function
75277>>>>>>>    
75277>>>>>>>End_Class
75278>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\odbc_drv.pkg)
75278>>>>>>>//   Package that declares ODBC driver constants and functions.         
75278>>>>>>>//   This package can be used by developers who want to add Data Access 
75278>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75278>>>>>>>
75278>>>>>>>Use Cli.pkg
75278>>>>>>>
75278>>>>>>>// Driver Indentification
75278>>>>>>>
75278>>>>>>>// Error number constants
75278>>>>>>>
75278>>>>>>>// Call driver function identifiers
75278>>>>>>>
75278>>>>>>>Class cODBCHandler is a cCLIHandler
75279>>>>>>>    
75279>>>>>>>    Procedure Construct_Object
75281>>>>>>>        Forward Send Construct_Object
75283>>>>>>>        
75283>>>>>>>        Set psDriverID to ODBC_DRV_ID
75284>>>>>>>    End_Procedure
75285>>>>>>>    
75285>>>>>>>    
75285>>>>>>>    
75285>>>>>>>    // Setup the type of data sources returned by the datasources function
75285>>>>>>>    Procedure Set DataSourceType Integer iNewType
75287>>>>>>>        String  sDriver
75287>>>>>>>        String  sVoid
75287>>>>>>>        Integer iRetval
75287>>>>>>>        
75287>>>>>>>        Get psDriverID to sDriver
75288>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75295>>>>>>>    End_Procedure
75296>>>>>>>    
75296>>>>>>>    
75296>>>>>>>    // Call the driver's data sources function
75296>>>>>>>    Function DataSources Returns String
75298>>>>>>>        String  sDriver
75298>>>>>>>        String  sDataSource
75298>>>>>>>        String  sDescription
75298>>>>>>>        Integer iLength
75298>>>>>>>        Integer iRetval
75298>>>>>>>        
75298>>>>>>>        Get psDriverID to sDriver
75299>>>>>>>        If (sDriver <> "") Begin
75301>>>>>>>            Move 8192 to iLength
75302>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75303>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75304>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75309>>>>>>>        End
75309>>>>>>>>
75309>>>>>>>        
75309>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75312>>>>>>>        Else ;            Function_Return ""
75314>>>>>>>    End_Function
75315>>>>>>>    
75315>>>>>>>End_Class
75316>>>>>>>
75316>>>>>Use DFBtrDrv.pkg
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.1\Pkg\DFBTRDRV.PKG)
75316>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75316>>>>>>>// Notice      : This package contains constants and commands, used to call
75316>>>>>>>//               specific functions in the DFBTRDRV.
75316>>>>>>>Use Ui
75316>>>>>>>//
75316>>>>>>>// Driver Indentification
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>// Driver attributes
75316>>>>>>>//
75316>>>>>>>// Call_Driver functions ID's
75316>>>>>>>//
75316>>>>>>>//
75316>>>>>>>// DFBTRFN_CONVERT_FILE options
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// DFBTRFN_SET_OWNER options
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to create all vars which may be needed
75316>>>>>>>// in other commands.
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to set the owner of a Btrieve file.
75316>>>>>>>// File must have been opened.
75316>>>>>>>// Filenumber needs to be passed.
75316>>>>>>>// To clear set the owner to "".
75316>>>>>>>// Examples:
75316>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75316>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75316>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75316>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75316>>>>>>>// To clear:
75316>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to parse DFBTR_SET_OWNVER
75316>>>>>>>// options.
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to parse for Callback
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to clear the owner of a Btrieve file.
75316>>>>>>>// File must have been opened.
75316>>>>>>>// Filenumber needs to be passed.
75316>>>>>>>// Examples:
75316>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to add a owner name to the internal list of ownernames
75316>>>>>>>// which will be tries when opening files.
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to remove all owners from the internal list of ownernames
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75316>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75316>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75316>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to change the transaction type.
75316>>>>>>>// Valid types are:
75316>>>>>>>//     DFBTRTT_NONE
75316>>>>>>>//     DFBTRTT_EXCLUSIVE
75316>>>>>>>//     DFBTRTT_CONCURRENT
75316>>>>>>>//
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to get the current transaction type.
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to set explicit_locking
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to get explicit locking
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>//
75316>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75316>>>>>>>//
75316>>>>>>>
75316>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75316>>>>>>>//          call several Dfbtrdrv releated methods.
75316>>>>>>>
75316>>>>>>>Class cDFBtrDrvHandler is an Array
75317>>>>>>>    
75317>>>>>>>    Procedure Construct_Object Integer iImage
75319>>>>>>>        Forward Send Construct_object iImage
75321>>>>>>>        
75321>>>>>>>        Property String  psDriverID "DFBTRDRV"
75322>>>>>>>    End_Procedure
75323>>>>>>>    
75323>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75323>>>>>>>    //
75323>>>>>>>    
75323>>>>>>>    Function CKRevision Returns String
75325>>>>>>>        String  sDriverID
75325>>>>>>>        String  sRevision
75325>>>>>>>        String  sVoid
75325>>>>>>>        Integer iRetval
75325>>>>>>>        
75325>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75325>>>>>>>        // This error would otherwise be raised when we have an older
75325>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75325>>>>>>>        Send Ignore_error to Error_object_Id 20491
75326>>>>>>>        Get psDriverID to sDriverID
75327>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75328>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75333>>>>>>>        Send Trap_Error to Error_object_Id 20491
75334>>>>>>>        If (Trim(sRevision) = "") Begin
75336>>>>>>>            // Unable to get the revision. return all zeroes.
75336>>>>>>>            Move "0.0.0.0" to sRevision
75337>>>>>>>        End
75337>>>>>>>>
75337>>>>>>>        Function_Return sRevision
75338>>>>>>>    End_Function
75339>>>>>>>    
75339>>>>>>>    Function CkUsesUri Returns Integer
75341>>>>>>>        String  sDriverID
75341>>>>>>>        String  sVoid1
75341>>>>>>>        String  sVoid2
75341>>>>>>>        Integer iRetval
75341>>>>>>>        
75341>>>>>>>        Get psDriverID to sDriverID
75342>>>>>>>        
75342>>>>>>>        Move 0 to iRetval
75343>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75343>>>>>>>        // This error would otherwise be raised when we have an older
75343>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75343>>>>>>>        Send Ignore_error to Error_object_Id 20491
75344>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75349>>>>>>>        Send Trap_Error to Error_object_Id 20491
75350>>>>>>>        
75350>>>>>>>        Function_Return iRetval
75351>>>>>>>    End_Function
75352>>>>>>>    
75352>>>>>>>    
75352>>>>>>>    
75352>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75352>>>>>>>    //
75352>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75352>>>>>>>    //
75352>>>>>>>    
75352>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75354>>>>>>>        Integer iPartRev
75354>>>>>>>        Integer iCurrentPart
75354>>>>>>>        Integer iSeparatorPos
75354>>>>>>>        
75354>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75357>>>>>>>        
75357>>>>>>>        Move 0 to iCurrentPart
75358>>>>>>>        Repeat
75358>>>>>>>>
75358>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75359>>>>>>>            If (iSeparatorPos > 0) Begin
75361>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
75362>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
75363>>>>>>>                Increment iCurrentPart
75364>>>>>>>            End
75364>>>>>>>>
75364>>>>>>>            Else If (sRevision <> "") Begin
75367>>>>>>>                Move sRevision to iPartRev
75368>>>>>>>                Move "" to sRevision
75369>>>>>>>                Increment iCurrentPart
75370>>>>>>>            End
75370>>>>>>>>
75370>>>>>>>            Else ;                Move -1 to iPartRev
75372>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
75374>>>>>>>        
75374>>>>>>>        Function_Return iPartRev
75375>>>>>>>    End_Function
75376>>>>>>>    
75376>>>>>>>    
75376>>>>>>>    
75376>>>>>>>    //
75376>>>>>>>    //  Returns the major revision of the CK
75376>>>>>>>    //
75376>>>>>>>    
75376>>>>>>>    Function CKMajorRevision Returns Integer
75378>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
75379>>>>>>>    End_Function
75380>>>>>>>    
75380>>>>>>>    
75380>>>>>>>    
75380>>>>>>>    //  Returns the minor revision of the CK
75380>>>>>>>    //
75380>>>>>>>    
75380>>>>>>>    Function CKMinorRevision Returns Integer
75382>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
75383>>>>>>>    End_Function
75384>>>>>>>    
75384>>>>>>>    
75384>>>>>>>    //  Returns the release revision of the CK
75384>>>>>>>    //
75384>>>>>>>    
75384>>>>>>>    Function CKReleaseRevision Returns Integer
75386>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
75387>>>>>>>    End_Function
75388>>>>>>>    
75388>>>>>>>    
75388>>>>>>>    //  Returns the major revision of the CK
75388>>>>>>>    //
75388>>>>>>>    
75388>>>>>>>    Function CKBuildRevision Returns Integer
75390>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
75391>>>>>>>    End_Function
75392>>>>>>>    
75392>>>>>>>    
75392>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
75392>>>>>>>    //
75392>>>>>>>    
75392>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
75394>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
75397>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
75400>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
75403>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
75406>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
75409>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
75413>>>>>>>            End
75413>>>>>>>>
75413>>>>>>>        End
75413>>>>>>>>
75413>>>>>>>        
75413>>>>>>>        Function_Return (False)
75414>>>>>>>    End_Function
75415>>>>>>>    
75415>>>>>>>    //   Functions to query the Pervasive.SQL version:
75415>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
75415>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
75415>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
75415>>>>>>>    //
75415>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
75415>>>>>>>    //   in the following format:
75415>>>>>>>    //       <version>.<revision>.<type>
75415>>>>>>>    //   possible values for <type>:
75415>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
75415>>>>>>>    //         server using Workgroup authentication mode
75415>>>>>>>    //       C for client cache engine
75415>>>>>>>    //       D for DOS workstation
75415>>>>>>>    //       N for client Requester
75415>>>>>>>    //       S for NetWare server
75415>>>>>>>    //       T for 32-bit Windows server engine
75415>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
75415>>>>>>>    //
75415>>>>>>>    //   example:
75415>>>>>>>    //       8.50.T
75415>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
75415>>>>>>>    //   32-bits Windows server.
75415>>>>>>>    //
75415>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
75415>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
75415>>>>>>>    //
75415>>>>>>>    //   If the version information is not available or can not be obtained
75415>>>>>>>    //   the functions will return "0.0.0"
75415>>>>>>>    
75415>>>>>>>    //  Returns the version information of the
75415>>>>>>>    //           Pervasive.SQL Client requester.
75415>>>>>>>    
75415>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
75417>>>>>>>        
75417>>>>>>>        String  sDriverID
75417>>>>>>>        String  sVersion
75417>>>>>>>        String  sVoid
75417>>>>>>>        Integer iRetval
75417>>>>>>>        
75417>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75417>>>>>>>        // This error would otherwise be raised when we have an older
75417>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75417>>>>>>>        Send Ignore_error to Error_object_Id 20491
75418>>>>>>>        Get psDriverID to sDriverID
75419>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75420>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75425>>>>>>>        Send Trap_Error to Error_object_Id 20491
75426>>>>>>>        If (Trim(sVersion) = "") Begin
75428>>>>>>>            // Unable to get the revision. return all zeroes.
75428>>>>>>>            Move "0.0.0" to sVersion
75429>>>>>>>        End
75429>>>>>>>>
75429>>>>>>>        Function_Return sVersion
75430>>>>>>>    End_Function
75431>>>>>>>    
75431>>>>>>>    //           Pervasive.SQL Engine
75431>>>>>>>    
75431>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
75433>>>>>>>        
75433>>>>>>>        String  sDriverID
75433>>>>>>>        String  sVersion
75433>>>>>>>        String  sVoid
75433>>>>>>>        Integer iRetval
75433>>>>>>>        
75433>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75433>>>>>>>        // This error would otherwise be raised when we have an older
75433>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75433>>>>>>>        Send Ignore_error to Error_object_Id 20491
75434>>>>>>>        Get psDriverID to sDriverID
75435>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75436>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75441>>>>>>>        Send Trap_Error to Error_object_Id 20491
75442>>>>>>>        If (Trim(sVersion) = "") Begin
75444>>>>>>>            // Unable to get the revision. return all zeroes.
75444>>>>>>>            Move "0.0.0" to sVersion
75445>>>>>>>        End
75445>>>>>>>>
75445>>>>>>>        Function_Return sVersion
75446>>>>>>>    End_Function
75447>>>>>>>    
75447>>>>>>>    //  Returns the version information of the
75447>>>>>>>    //           Pervasive.SQL Server Engine
75447>>>>>>>    
75447>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
75449>>>>>>>        
75449>>>>>>>        String  sDriverID
75449>>>>>>>        String  sVersion
75449>>>>>>>        String  sVoid
75449>>>>>>>        Integer iRetval
75449>>>>>>>        
75449>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75449>>>>>>>        // This error would otherwise be raised when we have an older
75449>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75449>>>>>>>        Send Ignore_error to Error_object_Id 20491
75450>>>>>>>        Get psDriverID to sDriverID
75451>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75452>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75457>>>>>>>        Send Trap_Error to Error_object_Id 20491
75458>>>>>>>        If (Trim(sVersion) = "") Begin
75460>>>>>>>            // Unable to get the revision. return all zeroes.
75460>>>>>>>            Move "0.0.0" to sVersion
75461>>>>>>>        End
75461>>>>>>>>
75461>>>>>>>        Function_Return sVersion
75462>>>>>>>    End_Function
75463>>>>>>>    
75463>>>>>>>End_Class
75464>>>>>>>
75464>>>>>>>
75464>>>>>Use vWin32fh.pkg
75464>>>>>
75464>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
75464>>>>>>>// *** The Database Update Framework Include file for Languages ***
75464>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
75464>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
75464>>>>>>>//
75464>>>>>>>Use LanguageText.Pkg
75464>>>>>>>
75464>>>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
75464>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
75464>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
75464>>>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
75464>>>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
75464>>>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
75464>>>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
75464>>>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
75464>>>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
75464>>>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
75464>>>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
75464>>>>>>>    Define CS_DUF_CopyingData               for "Copying data"
75464>>>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
75464>>>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
75464>>>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
75464>>>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
75464>>>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
75464>>>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
75464>>>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
75464>>>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
75464>>>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
75464>>>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
75464>>>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
75464>>>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
75464>>>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
75464>>>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
75464>>>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
75464>>>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
75464>>>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
75464>>>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
75464>>>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
75464>>>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
75464>>>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
75464>>>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
75464>>>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
75464>>>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
75464>>>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>>>
75464>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
75464>>>>>>>//
75464>>>>>>>// Use of Mertech drivers:
75464>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
75464>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
75464>>>>>>>//Define DUF_Use_Mertech_Drivers
75464>>>>>>>//
#REM USE MERTECH.INC
75464>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
75464>>>>>>>>>//*************************************************************************
75464>>>>>>>>>//*                                                                       *
75464>>>>>>>>>//*  Confidential Trade Secret.                                           *
75464>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
75464>>>>>>>>>//*  All rights reserved.                                                 *
75464>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
75464>>>>>>>>>//*                                                                       *
75464>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
75464>>>>>>>>>// * the Database Update Framework (DUF)                                  *
75464>>>>>>>>>// *                                                                      *
75464>>>>>>>>>//*************************************************************************
75464>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mertech.inc)
75464>>>>>>>>>>>//*************************************************************************
75464>>>>>>>>>>>//*                                                                       *
75464>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
75464>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
75464>>>>>>>>>>>//*  All rights reserved.                                                 *
75464>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
75464>>>>>>>>>>>//*                                                                       *
75464>>>>>>>>>>>//*************************************************************************
75464>>>>>>>>>>>Use UI
75464>>>>>>>>>>>Use SEQ_CHNL.PKG
75464>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM MERTECH.INC VERSION 3.3.1.5
#REM -----------------------------------------------
75464>>>>>>>>>>>
75464>>>>>>>>>>>Object oMertechInc_Work is an Array  
75466>>>>>>>>>>>    CompilerWarnings Off
75466>>>>>>>>>>>    Property String psWork Public (Repeat("                                ", 512))
75468>>>>>>>>>>>    CompilerWarnings On
75468>>>>>>>>>>>End_Object
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>// #DEFINE's
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
75469>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
75469>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
75469>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
75469>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
75469>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
75469>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
75469>>>>>>>>>>>/// to turn on local caching.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
75469>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default value: True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
75469>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
75469>>>>>>>>>>>///
75469>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
75469>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
75469>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
75469>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
75469>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the Database
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
75469>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
75469>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
75469>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
75469>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
75469>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
75469>>>>>>>>>>>/// local processing of rows (such as in a batch process).
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default value: 10
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
75469>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Attribute Value
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
75469>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
75469>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
75469>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
75469>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
75469>>>>>>>>>>>/// entry is pointing to.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
75469>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
75469>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
75469>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
75469>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
75469>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
75469>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
75469>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default value: True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
75469>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_STATIC
75469>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
75469>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
75469>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
75469>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
75469>>>>>>>>>>>/// when a table contains configuration or static information used in
75469>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
75469>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
75469>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
75469>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
75469>>>>>>>>>>>/// this on very large tables.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
75469>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
75469>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
75469>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
75469>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
75469>>>>>>>>>>>/// entry is pointing to.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the database server.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
75469>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
75469>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
75469>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
75469>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a readonly attribute.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>
75469>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
75469>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
75469>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
75469>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
75469>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
75469>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
75469>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
75469>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
75469>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
75469>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
75469>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
75469>>>>>>>>>>>/// in Oracle and PostgreSQL.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// move 0 to hFile
75469>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///             // More table creation here
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
75469>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
75469>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
75469>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
75469>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
75469>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
75469>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
75469>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
75469>>>>>>>>>>>/// only available for Oracle and Postgre.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// move 0 to hFile
75469>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///             // More table creation here
75469>>>>>>>>>>>///             //
75469>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
75469>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
75469>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
75469>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
75469>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
75469>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
75469>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
75469>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
75469>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
75469>>>>>>>>>>>/// compelling reason to do otherwise.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
75469>>>>>>>>>>>
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open ORDERHEA
75469>>>>>>>>>>>/// Handle  hFile
75469>>>>>>>>>>>/// Boolean bRetrieve
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
75469>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
75469>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
75469>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
75469>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
75469>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     PGFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Name of the Schema
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open ORDERHEA
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// String sSchemaName
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
75469>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
75469>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
75469>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
75469>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
75469>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
75469>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
75469>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
75469>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
75469>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
75469>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
75469>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
75469>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Deprecated
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              SERVER_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
75469>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
75469>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
75469>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
75469>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// to indicate how the INT file will be written.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              SERVER_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
75469>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
75469>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
75469>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
75469>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
75469>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
75469>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Deprecated
75469>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
75469>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
75469>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
75469>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
75469>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
75469>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
75469>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
75469>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
75469>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
75469>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
75469>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
75469>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
75469>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Deprecated
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
75469>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
75469>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
75469>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
75469>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
75469>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
75469>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
75469>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
75469>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Default Value: False
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
75469>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
75469>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Close Customer
75469>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
75469>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
75469>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
75469>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
75469>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
75469>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
75469>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
75469>>>>>>>>>>>/// to false will not.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Boolean bTranslate
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
75469>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
75469>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
75469>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
75469>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
75469>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
75469>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
75469>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
75469>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
75469>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
75469>>>>>>>>>>>/// or inside of a Structure_Start.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Boolean bEpoch
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
75469>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
75469>>>>>>>>>>>
75469>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
75469>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
75469>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
75469>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
75469>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
75469>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
75469>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Integer bLocked
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
75469>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_CASING
75469>>>>>>>>>>>/// @Description Controls the filename and column name casing.
75469>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
75469>>>>>>>>>>>/// to uppercase.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber          Number of the file
75469>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Integer eCasing
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
75469>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
75469>>>>>>>>>>>
75469>>>>>>>>>>>
75469>>>>>>>>>>>Define DF_FILE_CASING                               For 634
75469>>>>>>>>>>>
75469>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
75469>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
75469>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
75469>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
75469>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
75469>>>>>>>>>>>/// See Mertech.cfg
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
75469>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>/// String sDefault
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Integer iColumn
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move "California" to sDefault
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>/// Move 3 to iColumn
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
75469>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
75469>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
75469>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
75469>>>>>>>>>>>/// column in a table.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
75469>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
75469>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
75469>>>>>>>>>>>/// recompile your program.
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  FileName              Name of the file
75469>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// #INCLUDE MERTECH.INC
75469>>>>>>>>>>>/// string sDateTime sDatabaseName
75469>>>>>>>>>>>/// open ORDERHEA
75469>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
75469>>>>>>>>>>>/// find GE ORDERHEA by recnum
75469>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
75469>>>>>>>>>>>/// showln "sDateTime: " sDateTime
75469>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
75469>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
75469>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
75469>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
75469>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a ReadOnly attribute.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber          Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
75469>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// String sName
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
75469>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_NULL
75469>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
75469>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
75469>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
75469>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
75469>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber          Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
75469>>>>>>>>>>>/// @Param  variable                    Boolean variable
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>/// Integer iColumn
75469>>>>>>>>>>>/// Boolean bAllowNull
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>/// Move 3 to iColumn
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
75469>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
75469>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
75469>>>>>>>>>>>
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
75469>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
75469>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
75469>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
75469>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
75469>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
75469>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
75469>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
75469>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
75469>>>>>>>>>>>/// so these lists of constants can again prove useful.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber          Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
75469>>>>>>>>>>>/// @Param  variable                    variable for the native data type
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iColumn iType
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
75469>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
75469>>>>>>>>>>>///     Structure_End hFile
75469>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
75469>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
75469>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
75469>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
75469>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
75469>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
75469>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
75469>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
75469>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
75469>>>>>>>>>>>/// value is stored as a boolean, either true or false.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber          Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
75469>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iColumn
75469>>>>>>>>>>>/// Boolean bIncrement
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
75469>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
75469>>>>>>>>>>>///     Structure_End hFile
75469>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
75469>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
75469>>>>>>>>>>>/// index was created correctly at the SQL backend
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a ReadOnly attribute
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
75469>>>>>>>>>>>/// @Param  variable              True if created, false if not
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Handle  hFile
75469>>>>>>>>>>>/// Integer iIndex
75469>>>>>>>>>>>/// Boolean bCreated
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>/// Move 1 To iIndex
75469>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
75469>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_INDEX_NAME
75469>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
75469>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
75469>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
75469>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
75469>>>>>>>>>>>/// index.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a ReadOnly attribute
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
75469>>>>>>>>>>>/// @Param  variable              Name of the index
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iFile iIndex iIndexes
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Open Orderhea
75469>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// For iIndex From 0 to iIndexes
75469>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
75469>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
75469>>>>>>>>>>>/// Loop
75469>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
75469>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
75469>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
75469>>>>>>>>>>>/// done at any time, but setting the index must be during a
75469>>>>>>>>>>>/// Structure_Start or during table creation.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Deprecated
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iKey
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
75469>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
75469>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
75469>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
75469>>>>>>>>>>>/// done at any time, but setting the index must be during a
75469>>>>>>>>>>>/// Structure_Start or during table creation.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iKey
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
75469>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
75469>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
75469>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
75469>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
75469>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a ReadOnly attribute
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     ORAFlex
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
75469>>>>>>>>>>>/// @Param  variable              String indicating validity
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// String sIndexStatus
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
75469>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
75469>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
75469>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
75469>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
75469>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
75469>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
75469>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
75469>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
75469>>>>>>>>>>>/// @Param  variable              String indicating if unique
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// String sIndexUnique
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
75469>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
75469>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
75469>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
75469>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
75469>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
75469>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
75469>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
75469>>>>>>>>>>>/// to a LOB data type.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
75469>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Boolean bIsLOB
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
75469>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
75469>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
75469>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
75469>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
75469>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
75469>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
75469>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
75469>>>>>>>>>>>/// is provided with this attribute.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// This is a ReadOnly attribute
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
75469>>>>>>>>>>>/// @See
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Integer iRelations
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
75469>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
75469>>>>>>>>>>>
75469>>>>>>>>>>>//TODO
75469>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
75469>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
75469>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
75469>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
75469>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
75469>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
75469>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Currently Unsupported Attribute
75469>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
75469>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
75469>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
75469>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
75469>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
75469>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
75469>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
75469>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
75469>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
75469>>>>>>>>>>>/// it can not be turned back on (set to True).
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
75469>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Boolean bRecnum
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
75469>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
75469>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
75469>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
75469>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
75469>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
75469>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
75469>>>>>>>>>>>/// 0 is returned.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
75469>>>>>>>>>>>/// the index used as the primary key.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
75469>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Boolean bPrimary
75469>>>>>>>>>>>/// Handle hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Move Customer.File_Number to hFile
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Structure_Start hFile
75469>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
75469>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
75469>>>>>>>>>>>/// Structure_End hFile
75469>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
75469>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
75469>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
75469>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Assumptions
75469>>>>>>>>>>>/// @Status      Public
75469>>>>>>>>>>>/// @Drivers     All
75469>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
75469>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
75469>>>>>>>>>>>/// @INTOPT
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
75469>>>>>>>>>>>/// @Param  FileNumber            Number of the file
75469>>>>>>>>>>>/// @Param  variable              String name of recnum field
75469>>>>>>>>>>>/// @Example
75469>>>>>>>>>>>/// Open Customer
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// String sRecnum
75469>>>>>>>>>>>///
75469>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
75469>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
75469>>>>>>>>>>>
75469>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
75469>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
75469>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
75469>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
75469>>>>>>>>>>>
75469>>>>>>>>>>>// SQLFlex Lock Type
75469>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Extended Callback Types
75469>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
75469>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
75469>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Drivers
75469>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
75469>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
75469>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
75469>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
75469>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
75469>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
75469>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Delimiter for SQL ID objects
75469>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
75469>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
75469>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
75469>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
75469>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
75469>>>>>>>>>>>
75469>>>>>>>>>>>// dfStructureEnd Option bits
75469>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
75469>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
75469>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
75469>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
75469>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Additional Data Types
75469>>>>>>>>>>>Define DF_DATETIME                                  For 7
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Call_Driver Functions
75469>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
75469>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
75469>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
75469>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
75469>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                   for ((22 * (2^16)) + 11)
75469>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
75469>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
75469>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
75469>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
75469>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
75469>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
75469>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
75469>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
75469>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
75469>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
75469>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
75469>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
75469>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
75469>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
75469>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
75469>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
75469>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
75469>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
75469>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
75469>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
75469>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
75469>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
75469>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
75469>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
75469>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
75469>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
75469>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
75469>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
75469>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
75469>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
75469>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
75469>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
75469>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
75469>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
75469>>>>>>>>>>>
75469>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
75469>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
75469>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
75469>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
75469>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
75469>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
75469>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
75469>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
75469>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
75469>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
75469>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
75469>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
75469>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
75469>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
75469>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
75469>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
75469>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
75469>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
75469>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
75469>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
75469>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
75469>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
75469>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
75469>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
75469>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
75469>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
75469>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
75469>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
75469>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
75469>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
75469>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
75469>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
75469>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
75469>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
75469>>>>>>>>>>>Define CALLDRV_100                                  For 100
75469>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
75469>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
75469>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
75469>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
75469>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK_EX                    for 111
75469>>>>>>>>>>>Define CALLDRV_PARAM_RETURN_TYPE                    For 112
75469>>>>>>>>>>>Define CALLDRV_CONNECTION_STRING                    for 113
75469>>>>>>>>>>>Define CALLDRV_GET_SQL_CURSOR_TYPE                  for 114
75469>>>>>>>>>>>
75469>>>>>>>>>>>// License and environment settings
75469>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
75469>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
75469>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
75469>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
75469>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
75469>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
75469>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
75469>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
75469>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
75469>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
75469>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
75469>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
75469>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
75469>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
75469>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
75469>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
75469>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
75469>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
75469>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
75469>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
75469>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
75469>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
75469>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
75469>>>>>>>>>>>
75469>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
75469>>>>>>>>>>>
75469>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
75469>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
75469>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
75469>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
75469>>>>>>>>>>>
75469>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
75469>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
75469>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
75469>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
75469>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
75469>>>>>>>>>>>
75469>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
75469>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
75469>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
75469>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
75469>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
75469>>>>>>>>>>>
75469>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
75469>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
75469>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
75469>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
75469>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
75469>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
75469>>>>>>>>>>>
75469>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
75469>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
75469>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
75469>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
75469>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
75469>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Embedded SQL Cursor Types
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
75469>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Driver Call Direction
75469>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
75469>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Inverse Key types
75469>>>>>>>>>>>Define REGULAR_SEG                                  For -1
75469>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
75469>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
75469>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
75469>>>>>>>>>>>
75469>>>>>>>>>>>//DB2 Index Types
75469>>>>>>>>>>>Define REG_INDEX                                    For 0
75469>>>>>>>>>>>Define REV_INDEX                                    For 1
75469>>>>>>>>>>>Define CLUST_INDEX                                  For 2
75469>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
75469>>>>>>>>>>>
75469>>>>>>>>>>>//Oracle Procedure Arguments type
75469>>>>>>>>>>>Define IS_NONE                                      For 0
75469>>>>>>>>>>>Define IS_IN                                        For 1
75469>>>>>>>>>>>Define IS_OUT                                       For 2
75469>>>>>>>>>>>Define IS_IN_OUT                                    For 3
75469>>>>>>>>>>>Define IS_RSET                                      For 4
75469>>>>>>>>>>>
75469>>>>>>>>>>>// SQL_GET_COL Attributes
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
75469>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
75469>>>>>>>>>>>
75469>>>>>>>>>>>// MySQL Data Types
75469>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
75469>>>>>>>>>>>Define eMySQL_TINY                                  For 1
75469>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
75469>>>>>>>>>>>Define eMySQL_LONG                                  For 3
75469>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
75469>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
75469>>>>>>>>>>>Define eMySQL_NULL                                  For 6
75469>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
75469>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
75469>>>>>>>>>>>Define eMySQL_INT24                                 For 9
75469>>>>>>>>>>>Define eMySQL_DATE                                  For 10
75469>>>>>>>>>>>Define eMySQL_TIME                                  For 11
75469>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
75469>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
75469>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
75469>>>>>>>>>>>Define eMySQL_BIT                                   For 16
75469>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
75469>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
75469>>>>>>>>>>>Define eMySQL_SET                                   For 248
75469>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
75469>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
75469>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
75469>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
75469>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
75469>>>>>>>>>>>Define eMySQL_STRING                                For 254
75469>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
75469>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
75469>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
75469>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
75469>>>>>>>>>>>
75469>>>>>>>>>>>// Oracle Data Types
75469>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
75469>>>>>>>>>>>Define eOracle_NUMBER                               For   2
75469>>>>>>>>>>>Define eOracle_INT                                  For   3
75469>>>>>>>>>>>Define eOracle_FLOAT                                For   4
75469>>>>>>>>>>>Define eOracle_STRING                               For   5
75469>>>>>>>>>>>Define eOracle_LONG                                 For   8
75469>>>>>>>>>>>Define eOracle_ROWID                                For  11
75469>>>>>>>>>>>Define eOracle_DATE                                 For  12
75469>>>>>>>>>>>Define eOracle_RAW                                  For  23
75469>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
75469>>>>>>>>>>>Define eOracle_CHAR                                 For  96
75469>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
75469>>>>>>>>>>>Define eOracle_CLOB                                 For 112
75469>>>>>>>>>>>Define eOracle_BLOB                                 For 113
75469>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
75469>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
75469>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
75469>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
75469>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
75469>>>>>>>>>>>Define eOracle_NCHAR                                For 286
75469>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
75469>>>>>>>>>>>Define eOracle_NCLOB                                For 288
75469>>>>>>>>>>>
75469>>>>>>>>>>>// PostgreSQL Data Types
75469>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
75469>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
75469>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
75469>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
75469>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
75469>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
75469>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
75469>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
75469>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
75469>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
75469>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
75469>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
75469>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
75469>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
75469>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
75469>>>>>>>>>>>Define ePgSQL_OID                                   For   26
75469>>>>>>>>>>>Define ePgSQL_TID                                   For   27
75469>>>>>>>>>>>Define ePgSQL_XID                                   For   28
75469>>>>>>>>>>>Define ePgSQL_CID                                   For   29
75469>>>>>>>>>>>Define ePgSQL_XML                                   For  142
75469>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
75469>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
75469>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
75469>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
75469>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
75469>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
75469>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
75469>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
75469>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
75469>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
75469>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
75469>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
75469>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
75469>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
75469>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
75469>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
75469>>>>>>>>>>>Define ePgSQL_INET                                  For  869
75469>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
75469>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
75469>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
75469>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
75469>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
75469>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
75469>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
75469>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
75469>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
75469>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
75469>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
75469>>>>>>>>>>>
75469>>>>>>>>>>>// SQL Server Data Types
75469>>>>>>>>>>>Define eSQLServer_NA                                For    0
75469>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
75469>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
75469>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
75469>>>>>>>>>>>Define eSQLServer_INT                               For    4
75469>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
75469>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
75469>>>>>>>>>>>Define eSQLServer_REAL                              For    7
75469>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
75469>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
75469>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
75469>>>>>>>>>>>Define eSQLServer_DATE                              For   40
75469>>>>>>>>>>>Define eSQLServer_TIME                              For   41
75469>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
75469>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
75469>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
75469>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
75469>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
75469>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
75469>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
75469>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
75469>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
75469>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
75469>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
75469>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
75469>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
75469>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
75469>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
75469>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
75469>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
75469>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
75469>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
75469>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
75469>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
75469>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
75469>>>>>>>>>>>Define eSQLServer_XML                               For -370
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>//Error Text
75469>>>>>>>>>>>//==========
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>//Define Self if needed
75469>>>>>>>>>>>//=====================
75469>>>>>>>>>>>
75469>>>>>>>>>>>
75469>>>>>>>>>>>//=============================================================================
75469>>>>>>>>>>>//Define varibles we need
75469>>>>>>>>>>>//=======================
75469>>>>>>>>>>>
75469>>>>>>>>>>>    Define MertechInc_Variables_Defined
75469>>>>>>>>>>>
75469>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
75469>>>>>>>>>>>
75469>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
75469>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
75469>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
75469>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
75469>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
75469>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
75469>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
75469>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
75469>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
75469>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
75469>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
75469>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
75469>>>>>>>>>>>    Integer MertechInc_iWork2
75469>>>>>>>>>>>    Integer MertechInc_iWork3
75469>>>>>>>>>>>    Integer MertechInc_SizeCheckDone
75469>>>>>>>>>>>    Integer MertechInc_LastCursorNum
75469>>>>>>>>>>>    Move -2 to MertechInc_LastCursorNum // -1 means default cursor, so we're using -2 no cursor yet
75470>>>>>>>>>>>    Integer MertechInc_DefaultCursorType
75470>>>>>>>>>>>
75470>>>>>>>>>>>    Move CALLDRV_ENUMERATE_CURSOR_TYPE_NONE to MertechInc_DefaultCursorType
75471>>>>>>>>>>>
75471>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
75471>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
75471>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
75471>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
75471>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
75471>>>>>>>>>>>
75471>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
75471>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
75471>>>>>>>>>>>    Move "" to MertechInc_Blank
75472>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
75473>>>>>>>>>>>
75473>>>>>>>>>>>
75473>>>>>>>>>>>//=============================================================================
75473>>>>>>>>>>>//Use Obsolete Code
75473>>>>>>>>>>>//=================
75473>>>>>>>>>>>
75473>>>>>>>>>>>
75473>>>>>>>>>>>
75473>>>>>>>>>>>//=============================================================================
75473>>>>>>>>>>>//Comment Block Template
75473>>>>>>>>>>>//======================
75473>>>>>>>>>>>
75473>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
75473>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
75473>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
75473>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
75473>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
75473>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
75473>>>>>>>>>>>///     no need for <br> or <p> tags.
75473>>>>>>>>>>>///
75473>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
75473>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
75473>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
75473>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
75473>>>>>>>>>>>/// @See {list of related commands}
75473>>>>>>>>>>>///
75473>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
75473>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
75473>>>>>>>>>>>/// @DBMS {List of supported databases}
75473>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
75473>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
75473>>>>>>>>>>>///
75473>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
75473>>>>>>>>>>>
75473>>>>>>>>>>>//=============================================================================
75473>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
75473>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
75473>>>>>>>>>>>/// that will be used by the macro commands.
75473>>>>>>>>>>>///
75473>>>>>>>>>>>/// @Assumptions
75473>>>>>>>>>>>/// @Status      Internal Use Only
75473>>>>>>>>>>>/// @Drivers     All
75473>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
75473>>>>>>>>>>>/// @See
75473>>>>>>>>>>>//Most commands Use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
75473>>>>>>>>>>>//all the Time. It has been moved to this method to remove that duplication.
75473>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
75475>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
75475>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
75480>>>>>>>>>>>    Else Begin
75481>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
75484>>>>>>>>>>>        For MertechInc_iLoop from 1 to MertechInc_iCount
75490>>>>>>>>>>>>
75490>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
75493>>>>>>>>>>>            Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
75494>>>>>>>>>>>            If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
75497>>>>>>>>>>>            Else Move "" to MertechInc_DriverName
75499>>>>>>>>>>>        Loop
75500>>>>>>>>>>>>
75500>>>>>>>>>>>    End
75500>>>>>>>>>>>>
75500>>>>>>>>>>>
75500>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
75500>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSPgSQL and MertechInc_DriverName NE MDSMySQL) Begin
75502>>>>>>>>>>>
75502>>>>>>>>>>>        //Report invalid driver
75502>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
75503>>>>>>>>>>>>
75503>>>>>>>>>>>
75503>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
75503>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
75503>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
75503>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
75504>>>>>>>>>>>    End
75504>>>>>>>>>>>>
75504>>>>>>>>>>>End_Procedure
75505>>>>>>>>>>>
75505>>>>>>>>>>>
75505>>>>>>>>>>>//=============================================================================
75505>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
75505>>>>>>>>>>>/// @Description Returns a string full of spaces.
75505>>>>>>>>>>>///
75505>>>>>>>>>>>/// @Assumptions
75505>>>>>>>>>>>/// @Status      Internal
75505>>>>>>>>>>>/// @Drivers     n/a
75505>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
75505>>>>>>>>>>>/// @See
75505>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
75507>>>>>>>>>>>   String sWork
75507>>>>>>>>>>>   Integer iBlocks iRemainder
75507>>>>>>>>>>>
75507>>>>>>>>>>>   If (iSize <= 1) Begin
75509>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
75509>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
75512>>>>>>>>>>>          Else Move 16384 to iSize
75514>>>>>>>>>>>   End
75514>>>>>>>>>>>>
75514>>>>>>>>>>>
75514>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
75514>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
75514>>>>>>>>>>>   Move (iSize / 32) to iBlocks
75515>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
75516>>>>>>>>>>>
75516>>>>>>>>>>>   If (iBlocks > 0) Begin
75518>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
75519>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
75520>>>>>>>>>>>   End
75520>>>>>>>>>>>>
75520>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
75522>>>>>>>>>>>
75522>>>>>>>>>>>   Function_Return sWork
75523>>>>>>>>>>>End_Function
75524>>>>>>>>>>>
75524>>>>>>>>>>>//=============================================================================
75524>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
75524>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
75524>>>>>>>>>>>/// separator to '.'.
75524>>>>>>>>>>>///
75524>>>>>>>>>>>/// @Assumptions
75524>>>>>>>>>>>/// @Status      Internal
75524>>>>>>>>>>>/// @Drivers     n/a
75524>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
75524>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
75526>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
75529>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
75534>>>>>>>>>>>End_Procedure
75535>>>>>>>>>>>
75535>>>>>>>>>>>//=============================================================================
75535>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
75535>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
75535>>>>>>>>>>>///
75535>>>>>>>>>>>/// @Status      Internal
75535>>>>>>>>>>>/// @Drivers     n/a
75535>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
75535>>>>>>>>>>>///
75535>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
75537>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
75542>>>>>>>>>>>End_Procedure
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        FETCH_FIELD
75543>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
75543>>>>>>>>>>>/// next FIND (query).
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Status      Internal
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
75543>>>>>>>>>>>/// @Param  FileNum    is the File Number
75543>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
75543>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
75543>>>>>>>>>>>/// @Param  FileNum  is the File Number
75543>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
75543>>>>>>>>>>>///
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
75543>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
75543>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
75543>>>>>>>>>>>/// what is actually happening at certain points.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
75543>>>>>>>>>>>/// @Status      Public
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
75543>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
75543>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
75543>>>>>>>>>>>/// open Customer
75543>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
75543>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
75543>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
75543>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
75543>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
75543>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
75543>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
75543>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
75543>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions
75543>>>>>>>>>>>/// @Status      Public
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
75543>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
75543>>>>>>>>>>>/// @Param  FileNumber          The number of the file
75543>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
75543>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>/// Open Customer
75543>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
75543>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
75543>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// Clear Customer
75543>>>>>>>>>>>/// Repeat
75543>>>>>>>>>>>///    Find Gt Customer by Index.1
75543>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
75543>>>>>>>>>>>/// Until (Not(Found))
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
75543>>>>>>>>>>>
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
75543>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
75543>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
75543>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
75543>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
75543>>>>>>>>>>>/// which will fetch no columns.
75543>>>>>>>>>>>/// @Assumptions
75543>>>>>>>>>>>/// @Status      Public
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
75543>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
75543>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
75543>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
75543>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>/// Open Customer
75543>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
75543>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
75543>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// Clear Customer
75543>>>>>>>>>>>/// Repeat
75543>>>>>>>>>>>///    Find Gt Customer by Index.1
75543>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
75543>>>>>>>>>>>/// Until (Not(Found))
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
75543>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
75543>>>>>>>>>>>/// per query
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions
75543>>>>>>>>>>>/// @Status      Deprecated
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
75543>>>>>>>>>>>/// @See
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
75543>>>>>>>>>>>/// @Param  FileNumber          The number of the file
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>///     open Customer
75543>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
75543>>>>>>>>>>>///     Repeat
75543>>>>>>>>>>>///             find gt Customer by Recnum
75543>>>>>>>>>>>///         If (Found) Begin
75543>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
75543>>>>>>>>>>>///         end
75543>>>>>>>>>>>///     until (Customer.ID = 10)
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
75543>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
75543>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
75543>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
75543>>>>>>>>>>>/// the cache.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions
75543>>>>>>>>>>>/// @Status      Public
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
75543>>>>>>>>>>>/// @See
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
75543>>>>>>>>>>>/// @Param  FileNumber          The number of the file
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>/// Open Customer
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// Find gt Customer by Index.1
75543>>>>>>>>>>>/// While (Found) Begin
75543>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
75543>>>>>>>>>>>/// Loop
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        SQL_FOR_SET
75543>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
75543>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
75543>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
75543>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
75543>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
75543>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
75543>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
75543>>>>>>>>>>>/// will be adequate for most situations.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions
75543>>>>>>>>>>>/// @Status      Public
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75543>>>>>>>>>>>/// @See
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
75543>>>>>>>>>>>/// @Param  FileNumber          The number of the file
75543>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
75543>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
75543>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
75543>>>>>>>>>>>/// @Example
75543>>>>>>>>>>>/// Open Customer
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
75543>>>>>>>>>>>/// find gt Customer by Index.1
75543>>>>>>>>>>>
75543>>>>>>>>>>>//=============================================================================
75543>>>>>>>>>>>/// @Name        SQL_SET
75543>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
75543>>>>>>>>>>>/// sql execution.
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75543>>>>>>>>>>>/// @Status      Deprecated
75543>>>>>>>>>>>/// @Drivers     All
75543>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75543>>>>>>>>>>>/// @See         SQL_SET_STMT
75543>>>>>>>>>>>///
75543>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
75543>>>>>>>>>>>/// @Param  FileNumber          The number of the file
75543>>>>>>>>>>>
75543>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
75545>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
75550>>>>>>>>>>>End_Procedure
75551>>>>>>>>>>>
75551>>>>>>>>>>>//=============================================================================
75551>>>>>>>>>>>/// @Name        SQL_APPEND
75551>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
75551>>>>>>>>>>>/// already set.
75551>>>>>>>>>>>///
75551>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75551>>>>>>>>>>>/// @Status      Deprecated
75551>>>>>>>>>>>/// @Drivers     All
75551>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75551>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
75551>>>>>>>>>>>
75551>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
75553>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
75558>>>>>>>>>>>End_Procedure
75559>>>>>>>>>>>
75559>>>>>>>>>>>//=============================================================================
75559>>>>>>>>>>>/// @Name        SQL_EXECUTE
75559>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
75559>>>>>>>>>>>/// finishing any pending transaction.
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Assumptions
75559>>>>>>>>>>>/// @Status      Deprecated
75559>>>>>>>>>>>/// @Drivers     All
75559>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75559>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
75559>>>>>>>>>>>
75559>>>>>>>>>>>//=============================================================================
75559>>>>>>>>>>>/// @Name        LOCK_TABLE
75559>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Assumptions
75559>>>>>>>>>>>/// @Status      Deprecated
75559>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
75559>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75559>>>>>>>>>>>/// @See
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
75559>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
75559>>>>>>>>>>>
75559>>>>>>>>>>>//=============================================================================
75559>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
75559>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
75559>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
75559>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
75559>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
75559>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
75559>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
75559>>>>>>>>>>>/// be done on the "finderr" variable.
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
75559>>>>>>>>>>>/// @Status      Public
75559>>>>>>>>>>>/// @Drivers     All
75559>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75559>>>>>>>>>>>/// @See
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
75559>>>>>>>>>>>/// @Param  database            Name of the database
75559>>>>>>>>>>>/// @Param  username            Name of the user
75559>>>>>>>>>>>/// @Param  table                       Name of the table being checked
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Example
75559>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
75559>>>>>>>>>>>/// If (finderr) Begin
75559>>>>>>>>>>>///     Showln "This table does not exist"
75559>>>>>>>>>>>/// End
75559>>>>>>>>>>>
75559>>>>>>>>>>>//=============================================================================
75559>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
75559>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
75559>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
75559>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
75559>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
75559>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
75559>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75559>>>>>>>>>>>/// @Status      Public
75559>>>>>>>>>>>/// @Drivers     All
75559>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75559>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
75559>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
75559>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// @Example
75559>>>>>>>>>>>/// Open Customer
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
75559>>>>>>>>>>>///
75559>>>>>>>>>>>/// For_All Customer by Index.1 do
75559>>>>>>>>>>>///     Showln Customer.FirstName
75559>>>>>>>>>>>/// End_For_All
75559>>>>>>>>>>>
75559>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
75561>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
75566>>>>>>>>>>>End_Procedure
75567>>>>>>>>>>>
75567>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
75569>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
75574>>>>>>>>>>>End_Procedure
75575>>>>>>>>>>>
75575>>>>>>>>>>>//=============================================================================
75575>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
75575>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
75575>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75575>>>>>>>>>>>/// @Status      Public
75575>>>>>>>>>>>/// @Drivers     All
75575>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75575>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
75575>>>>>>>>>>>/// @Param  File                        Name or number of the file
75575>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// @Example
75575>>>>>>>>>>>/// Open Customer
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// String sCon
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
75575>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
75575>>>>>>>>>>>///
75575>>>>>>>>>>>/// For_All Customer by Index.1 do
75575>>>>>>>>>>>///     Showln Customer.FirstName
75575>>>>>>>>>>>///     Showln sCon
75575>>>>>>>>>>>/// End_For_All
75575>>>>>>>>>>>
75575>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
75577>>>>>>>>>>>    String sConstraint
75577>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
75578>>>>>>>>>>>
75578>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
75583>>>>>>>>>>>    Function_Return sConstraint
75584>>>>>>>>>>>End_Function
75585>>>>>>>>>>>
75585>>>>>>>>>>>//=============================================================================
75585>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
75585>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
75585>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
75585>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
75585>>>>>>>>>>>/// pass ACTIVATE to this command.
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Status      Public
75585>>>>>>>>>>>/// @Drivers     All
75585>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75585>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
75585>>>>>>>>>>>/// @Param  File                        Name or Number of the file
75585>>>>>>>>>>>/// @Param  Activate            Activates the constraint
75585>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Example
75585>>>>>>>>>>>/// Open Customer
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
75585>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// For_All Customer by Index.1 do
75585>>>>>>>>>>>///     Showln Customer.FirstName
75585>>>>>>>>>>>/// End_For_All
75585>>>>>>>>>>>
75585>>>>>>>>>>>//=============================================================================
75585>>>>>>>>>>>/// @Name        CREATE_TD_FILE
75585>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Assumptions
75585>>>>>>>>>>>/// @Status      Deprecated
75585>>>>>>>>>>>/// @Drivers     All
75585>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
75585>>>>>>>>>>>/// @See
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
75585>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
75585>>>>>>>>>>>
75585>>>>>>>>>>>//=============================================================================
75585>>>>>>>>>>>/// @Name        OPEN_INT
75585>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
75585>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
75585>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
75585>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
75585>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
75585>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
75585>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
75585>>>>>>>>>>>/// command will act as a normal open command.
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Assumptions
75585>>>>>>>>>>>/// @Status      Public
75585>>>>>>>>>>>/// @Drivers     All
75585>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
75585>>>>>>>>>>>/// @See
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
75585>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
75585>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
75585>>>>>>>>>>>/// @Example
75585>>>>>>>>>>>/// OPEN_INT "customer" as Customer
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// For_All Customer by Index.1 do
75585>>>>>>>>>>>///     Showln Customer.FirstName
75585>>>>>>>>>>>/// End_For_All
75585>>>>>>>>>>>
75585>>>>>>>>>>>//=============================================================================
75585>>>>>>>>>>>/// @Name        SET_OPEN_MODE
75585>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
75585>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
75585>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
75585>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
75585>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
75585>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
75585>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
75585>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
75585>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
75585>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
75585>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// Default Value: DEFAULT (Off)
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Assumptions
75585>>>>>>>>>>>/// @Status      Public
75585>>>>>>>>>>>/// @Drivers     All
75585>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
75585>>>>>>>>>>>/// @See
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
75585>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
75585>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Example
75585>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
75585>>>>>>>>>>>/// Open "customer.int" as Customer
75585>>>>>>>>>>>/// ...
75585>>>>>>>>>>>/// ...
75585>>>>>>>>>>>/// Find gt Customer by Index.1
75585>>>>>>>>>>>
75585>>>>>>>>>>>//=============================================================================
75585>>>>>>>>>>>/// @Name        SQL_SET_STMT
75585>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
75585>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
75585>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
75585>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
75585>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
75585>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
75585>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75585>>>>>>>>>>>/// @Status      Public
75585>>>>>>>>>>>/// @Drivers     All
75585>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
75585>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
75585>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
75585>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75585>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// @Example
75585>>>>>>>>>>>/// Open Customer
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
75585>>>>>>>>>>>///
75585>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75585>>>>>>>>>>>/// SQL_PREPARE_STMT
75585>>>>>>>>>>>/// SQL_EXECUTE_STMT
75585>>>>>>>>>>>/// While (Found)
75585>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
75585>>>>>>>>>>>///     Showln sID
75585>>>>>>>>>>>///     Showln sFirstName
75585>>>>>>>>>>>///     Showln sLastName
75585>>>>>>>>>>>///     Showln sDOB
75585>>>>>>>>>>>/// Loop
75585>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75585>>>>>>>>>>>
75585>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
75587>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
75592>>>>>>>>>>>End_Procedure
75593>>>>>>>>>>>
75593>>>>>>>>>>>//=============================================================================
75593>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
75593>>>>>>>>>>>/// @Description This command is used to append a command string to the
75593>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
75593>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
75593>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
75593>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
75593>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
75593>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
75593>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
75593>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
75593>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
75593>>>>>>>>>>>/// @Status      Public
75593>>>>>>>>>>>/// @Drivers     All
75593>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
75593>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
75593>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
75593>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
75593>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// @Example
75593>>>>>>>>>>>/// Open Customer
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
75593>>>>>>>>>>>///
75593>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75593>>>>>>>>>>>/// SQL_PREPARE_STMT
75593>>>>>>>>>>>/// SQL_EXECUTE_STMT
75593>>>>>>>>>>>/// While (Found)
75593>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
75593>>>>>>>>>>>///     Showln sID
75593>>>>>>>>>>>///     Showln sFirstName
75593>>>>>>>>>>>///     Showln sLastName
75593>>>>>>>>>>>///     Showln sDOB
75593>>>>>>>>>>>/// Loop
75593>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75593>>>>>>>>>>>
75593>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
75595>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
75600>>>>>>>>>>>End_Procedure
75601>>>>>>>>>>>
75601>>>>>>>>>>>//=============================================================================
75601>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
75601>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
75601>>>>>>>>>>>/// already set.
75601>>>>>>>>>>>///
75601>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
75601>>>>>>>>>>>/// @Status      Internal
75601>>>>>>>>>>>/// @Drivers     All
75601>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75601>>>>>>>>>>>/// @See
75601>>>>>>>>>>>///
75601>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
75601>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
75601>>>>>>>>>>>/// @Param fileName                             Name of the file
75601>>>>>>>>>>>/// @Param fieldName                    Name of the field
75601>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
75601>>>>>>>>>>>
75601>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
75603>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
75608>>>>>>>>>>>End_Procedure
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
75609>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
75609>>>>>>>>>>>/// with the same value.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Deprecated
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75609>>>>>>>>>>>/// @See
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
75609>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
75609>>>>>>>>>>>/// @Param variable                     The value being uploaded
75609>>>>>>>>>>>/// @Param fileName                     The name of the file
75609>>>>>>>>>>>/// @Param fieldName            The name of the field
75609>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Example
75609>>>>>>>>>>>/// Open Customer
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
75609>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
75609>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
75609>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
75609>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
75609>>>>>>>>>>>/// embedded SQL statement execution.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Internal
75609>>>>>>>>>>>/// @Drivers     SQLFlex
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75609>>>>>>>>>>>/// @See
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
75609>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
75609>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
75609>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
75609>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
75609>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
75609>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
75609>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Internal
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75609>>>>>>>>>>>/// @See
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
75609>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Internal
75609>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75609>>>>>>>>>>>/// @See
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
75609>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
75609>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
75609>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
75609>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
75609>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
75609>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
75609>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
75609>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
75609>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
75609>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
75609>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
75609>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Public
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
75609>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
75609>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
75609>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
75609>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
75609>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
75609>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
75609>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
75609>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
75609>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Example
75609>>>>>>>>>>>/// Open Customer
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// String sID sFirstName
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75609>>>>>>>>>>>/// SQL_PREPARE_STMT
75609>>>>>>>>>>>/// SQL_EXECUTE_STMT
75609>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
75609>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
75609>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
75609>>>>>>>>>>>/// compatibility.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Internal
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
75609>>>>>>>>>>>/// @See
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
75609>>>>>>>>>>>/// @Param FileNumber                   The number of the file
75609>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
75609>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
75609>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
75609>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
75609>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
75609>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
75609>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
75609>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
75609>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
75609>>>>>>>>>>>/// which will retrieve every column in the table.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Public
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
75609>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Param file                 Name or number of the file
75609>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
75609>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Example
75609>>>>>>>>>>>/// Open Customer
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75609>>>>>>>>>>>/// SQL_PREPARE_STMT
75609>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
75609>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
75609>>>>>>>>>>>/// While (Found)
75609>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
75609>>>>>>>>>>>///     Showln Customer.ID
75609>>>>>>>>>>>///     Showln Customer.FirstName
75609>>>>>>>>>>>///     Showln Customer.LastName
75609>>>>>>>>>>>///     Showln Customer.DOB
75609>>>>>>>>>>>/// Loop
75609>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75609>>>>>>>>>>>
75609>>>>>>>>>>>//=============================================================================
75609>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
75609>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
75609>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
75609>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
75609>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
75609>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
75609>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
75609>>>>>>>>>>>/// by the maximun number.
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Assumptions
75609>>>>>>>>>>>/// @Status      Public
75609>>>>>>>>>>>/// @Drivers     All
75609>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
75609>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
75609>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
75609>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
75609>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
75609>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// @Example
75609>>>>>>>>>>>/// Open Customer
75609>>>>>>>>>>>///
75609>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75609>>>>>>>>>>>/// SQL_PREPARE_STMT
75609>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
75609>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
75609>>>>>>>>>>>/// While (Found)
75609>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
75609>>>>>>>>>>>///     Showln Customer.ID
75609>>>>>>>>>>>///     Showln Customer.FirstName
75609>>>>>>>>>>>///     Showln Customer.LastName
75609>>>>>>>>>>>///     Showln Customer.DOB
75609>>>>>>>>>>>/// Loop
75609>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75609>>>>>>>>>>>
75609>>>>>>>>>>>
75609>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
75609>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
75609>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
75611>>>>>>>>>>>    SQL_EXECUTE_STMT
75651>>>>>>>>>>>End_Procedure
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
75652>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
75652>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
75652>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
75652>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
75652>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
75652>>>>>>>>>>>/// are generally only needed when a table is being altered.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Public
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
75652>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
75652>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
75652>>>>>>>>>>>/// SQL_PREPARE_STMT
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT
75652>>>>>>>>>>>/// SQL_COMMIT_STMT
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
75652>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
75652>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
75652>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
75652>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
75652>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
75652>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Public
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
75652>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
75652>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
75652>>>>>>>>>>>/// SQL_PREPARE_STMT
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT
75652>>>>>>>>>>>/// SQL_COMMIT_STMT
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
75652>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
75652>>>>>>>>>>>/// transaction will not be committed by the server.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Public
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
75652>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
75652>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
75652>>>>>>>>>>>/// SQL_PREPARE_STMT
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT
75652>>>>>>>>>>>/// If (Err) Begin
75652>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
75652>>>>>>>>>>>///     Showln errorString
75652>>>>>>>>>>>///     SQL_ROLLBACK_STMT
75652>>>>>>>>>>>/// End
75652>>>>>>>>>>>/// Else
75652>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
75652>>>>>>>>>>>///     SQL_COMMIT_STMT
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
75652>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
75652>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
75652>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Internal
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
75652>>>>>>>>>>>/// @See
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
75652>>>>>>>>>>>/// @Param server                               The name of the server being used
75652>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
75652>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
75652>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
75652>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
75652>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
75652>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
75652>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
75652>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
75652>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
75652>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
75652>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
75652>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Public
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
75652>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
75652>>>>>>>>>>>/// @Param  file                                The name or number of the file
75652>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
75652>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// String sID sRecnum
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
75652>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
75652>>>>>>>>>>>/// SQL_PREPARE_STMT
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT
75652>>>>>>>>>>>/// While (found)
75652>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
75652>>>>>>>>>>>///     If (found) Begin
75652>>>>>>>>>>>///             Showln sID
75652>>>>>>>>>>>///    End
75652>>>>>>>>>>>/// Loop
75652>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// Open Customer
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75652>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
75652>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
75652>>>>>>>>>>>/// While (Found)
75652>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
75652>>>>>>>>>>>///     Showln Customer.ID
75652>>>>>>>>>>>///     Showln Customer.FirstName
75652>>>>>>>>>>>///             Showln Customer.LastName
75652>>>>>>>>>>>/// Loop
75652>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        GET_RESULT_SET
75652>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
75652>>>>>>>>>>>/// query or stored procedure.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Deprecated
75652>>>>>>>>>>>/// @Drivers     All
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
75652>>>>>>>>>>>/// @See
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
75652>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
75652>>>>>>>>>>>
75652>>>>>>>>>>>//=============================================================================
75652>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
75652>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
75652>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
75652>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
75652>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
75652>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
75652>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
75652>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Assumptions
75652>>>>>>>>>>>/// @Status      Public
75652>>>>>>>>>>>/// @Drivers     SQLFlex
75652>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
75652>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
75652>>>>>>>>>>>/// @Param column                               Column number to get chunk from
75652>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
75652>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
75652>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
75652>>>>>>>>>>>///
75652>>>>>>>>>>>/// @Example
75652>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75652>>>>>>>>>>>/// SQL_PREPARE_STMT
75652>>>>>>>>>>>/// SQL_EXECUTE_STMT
75652>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
75652>>>>>>>>>>>/// If (Found) Begin
75652>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
75652>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
75652>>>>>>>>>>>///     Showln sChunk
75652>>>>>>>>>>>///     Showln iLength
75652>>>>>>>>>>>/// End
75652>>>>>>>>>>>
75652>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
75654>>>>>>>>>>>    Integer iChuck_Size
75654>>>>>>>>>>>    String sChunk
75654>>>>>>>>>>>
75654>>>>>>>>>>>    //Get current Chuck size and pre size string
75654>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
75659>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
75660>>>>>>>>>>>
75660>>>>>>>>>>>    //Get data
75660>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
75665>>>>>>>>>>>
75665>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
75665>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
75665>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
75666>>>>>>>>>>>
75666>>>>>>>>>>>    Function_Return sChunk
75667>>>>>>>>>>>End_Function
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
75668>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
75668>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
75668>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
75668>>>>>>>>>>>/// the maximum chunk size.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     SQLFlex
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
75668>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
75668>>>>>>>>>>>/// If (Found) Begin
75668>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
75668>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
75668>>>>>>>>>>>///     Showln sChunk
75668>>>>>>>>>>>///     Showln iLength
75668>>>>>>>>>>>/// End
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
75668>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
75668>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     SQLFlex
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
75668>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
75668>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
75668>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
75668>>>>>>>>>>>/// than the maximum size set with this command, then this will override
75668>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     SQLFlex
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
75668>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
75668>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
75668>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     SQLFlex
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
75668>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
75668>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
75668>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
75668>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
75668>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
75668>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
75668>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
75668>>>>>>>>>>>/// Showln iNumCols
75668>>>>>>>>>>>
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
75668>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Deprecated
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
75668>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// Integer iNumCols
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
75668>>>>>>>>>>>/// Showln iNumCols
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
75668>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
75668>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
75668>>>>>>>>>>>/// the result set to the record buffer.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
75668>>>>>>>>>>>/// on server and cursor types.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
75668>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// Integer iNumRows
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
75668>>>>>>>>>>>/// Showln iNumRows
75668>>>>>>>>>>>
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
75668>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
75668>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
75668>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
75668>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
75668>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
75668>>>>>>>>>>>/// @Param columnNumber                 The column number being used
75668>>>>>>>>>>>/// @Param variable                             String variable for the column name
75668>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// Open Customer
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// String sColumnName
75668>>>>>>>>>>>/// Integer iLength
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
75668>>>>>>>>>>>/// showln sColumnName
75668>>>>>>>>>>>/// showln iLength
75668>>>>>>>>>>>
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
75668>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Deprecated
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
75668>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
75668>>>>>>>>>>>/// @Param columnNumber                 The column number being used
75668>>>>>>>>>>>/// @Param variable                             String variable for the column name
75668>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
75668>>>>>>>>>>>/// @Description This command is used to get specific column information from
75668>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
75668>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
75668>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
75668>>>>>>>>>>>/// below for more information.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// Supported attributes are:
75668>>>>>>>>>>>/// <dl>
75668>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
75668>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
75668>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
75668>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
75668>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
75668>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
75668>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
75668>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
75668>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
75668>>>>>>>>>>>/// </dl>
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Public
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75668>>>>>>>>>>>/// @See
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
75668>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
75668>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
75668>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Example
75668>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// Open Customer
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75668>>>>>>>>>>>/// SQL_PREPARE_STMT
75668>>>>>>>>>>>/// SQL_EXECUTE_STMT
75668>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
75668>>>>>>>>>>>/// If (Found) Begin
75668>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
75668>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
75668>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
75668>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
75668>>>>>>>>>>>/// End
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
75668>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Internal
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
75668>>>>>>>>>>>/// @See
75668>>>>>>>>>>>
75668>>>>>>>>>>>//=============================================================================
75668>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
75668>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
75668>>>>>>>>>>>///
75668>>>>>>>>>>>/// @Assumptions
75668>>>>>>>>>>>/// @Status      Internal
75668>>>>>>>>>>>/// @Drivers     All
75668>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
75668>>>>>>>>>>>/// @See
75668>>>>>>>>>>>
75668>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer iWhichParam Returns String
75670>>>>>>>>>>>    String sReturnValue
75670>>>>>>>>>>>
75670>>>>>>>>>>>    Get Value of (oMertechInc_Work(Current_Object)) item iWhichParam to MertechInc_iWork
75671>>>>>>>>>>>    If MertechInc_iWork lt 16384 ;        Move (Repeat("                                ", ((MertechInc_iWork/32)+1))) to sReturnValue
75674>>>>>>>>>>>    Else Get psWork of oMertechInc_Work to sReturnValue
75676>>>>>>>>>>>
75676>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank (|CI$10000 * iWhichParam) RESULT MertechInc_iRet
75681>>>>>>>>>>>
75681>>>>>>>>>>>    Function_Return sReturnValue
75682>>>>>>>>>>>End_Function
75683>>>>>>>>>>>
75683>>>>>>>>>>>
75683>>>>>>>>>>>//=============================================================================
75683>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
75683>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
75683>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
75683>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
75683>>>>>>>>>>>/// columns on a table.
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>/// @Status      Public
75683>>>>>>>>>>>/// @Drivers     All
75683>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
75683>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Example
75683>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
75683>>>>>>>>>>>/// SQL_PREPARE_STMT
75683>>>>>>>>>>>/// SQL_EXECUTE_STMT
75683>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
75683>>>>>>>>>>>/// If (Found) Begin
75683>>>>>>>>>>>///     Showln sTable
75683>>>>>>>>>>>///     Showln sOwner
75683>>>>>>>>>>>///     Showln sTableType
75683>>>>>>>>>>>///     Showln dtCreated
75683>>>>>>>>>>>/// End
75683>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
75683>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
75683>>>>>>>>>>>/// If (Found) Begin
75683>>>>>>>>>>>///     Showln sColumnName
75683>>>>>>>>>>>///     Showln sColumnType
75683>>>>>>>>>>>///     Showln sComputed
75683>>>>>>>>>>>///     Showln sLength
75683>>>>>>>>>>>/// End
75683>>>>>>>>>>>
75683>>>>>>>>>>>//=============================================================================
75683>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
75683>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
75683>>>>>>>>>>>/// then stops.
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Assumptions
75683>>>>>>>>>>>/// @Status      Internal
75683>>>>>>>>>>>/// @Drivers     All
75683>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>
75683>>>>>>>>>>>//=============================================================================
75683>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
75683>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
75683>>>>>>>>>>>/// them to the current query.
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Assumptions
75683>>>>>>>>>>>/// @Status      internal
75683>>>>>>>>>>>/// @Drivers     All
75683>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>
75683>>>>>>>>>>>//=============================================================================
75683>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
75683>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
75683>>>>>>>>>>>/// "BINDING" is encountered.
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Assumptions
75683>>>>>>>>>>>/// @Status      Internal
75683>>>>>>>>>>>/// @Drivers     All
75683>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>
75683>>>>>>>>>>>//=============================================================================
75683>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
75683>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
75683>>>>>>>>>>>///
75683>>>>>>>>>>>/// @Assumptions
75683>>>>>>>>>>>/// @Status      Internal
75683>>>>>>>>>>>/// @Drivers     All
75683>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75683>>>>>>>>>>>/// @See
75683>>>>>>>>>>>
75683>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
75685>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
75690>>>>>>>>>>>End_Procedure
75691>>>>>>>>>>>
75691>>>>>>>>>>>//=============================================================================
75691>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
75691>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
75691>>>>>>>>>>>///
75691>>>>>>>>>>>/// @Assumptions
75691>>>>>>>>>>>/// @Status      Internal
75691>>>>>>>>>>>/// @Drivers     OraFlex
75691>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75691>>>>>>>>>>>/// @See
75691>>>>>>>>>>>
75691>>>>>>>>>>>//=============================================================================
75691>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
75691>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
75691>>>>>>>>>>>///
75691>>>>>>>>>>>/// @Assumptions
75691>>>>>>>>>>>/// @Status      Internal
75691>>>>>>>>>>>/// @Drivers     All
75691>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75691>>>>>>>>>>>/// @See
75691>>>>>>>>>>>
75691>>>>>>>>>>>//=============================================================================
75691>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
75691>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
75691>>>>>>>>>>>///
75691>>>>>>>>>>>/// @Assumptions
75691>>>>>>>>>>>/// @Status      Internal
75691>>>>>>>>>>>/// @Drivers     All
75691>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75691>>>>>>>>>>>/// @See
75691>>>>>>>>>>>
75691>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
75693>>>>>>>>>>>    String sReturnValue
75693>>>>>>>>>>>    Integer iSize
75693>>>>>>>>>>>
75693>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
75696>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
75696>>>>>>>>>>>
75696>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
75697>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
75702>>>>>>>>>>>
75702>>>>>>>>>>>    Function_Return sReturnValue
75703>>>>>>>>>>>End_Function
75704>>>>>>>>>>>
75704>>>>>>>>>>>//=============================================================================
75704>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
75704>>>>>>>>>>>/// @Description This command is used to get the value of a specific
75704>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
75704>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
75704>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
75704>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
75704>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
75704>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
75704>>>>>>>>>>>/// in order to work properly.
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Assumptions
75704>>>>>>>>>>>/// @Status      Deprecated
75704>>>>>>>>>>>/// @Drivers     All
75704>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
75704>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
75704>>>>>>>>>>>/// @Param parameter            Number of the parameter
75704>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Example
75704>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
75704>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
75704>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
75704>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// Showln sStatus
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Example
75704>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
75704>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
75704>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
75704>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
75704>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// Showln sStatus
75704>>>>>>>>>>>// OLI:
75704>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
75704>>>>>>>>>>>
75704>>>>>>>>>>>//=============================================================================
75704>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
75704>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
75704>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
75704>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
75704>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
75704>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
75704>>>>>>>>>>>/// a specific reason to do so.
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Assumptions
75704>>>>>>>>>>>/// @Status      Public
75704>>>>>>>>>>>/// @Drivers     All
75704>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
75704>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
75704>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
75704>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
75704>>>>>>>>>>>///
75704>>>>>>>>>>>/// @Example
75704>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
75704>>>>>>>>>>>/// SQL_PREPARE_STMT
75704>>>>>>>>>>>/// SQL_EXECUTE_STMT
75704>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
75704>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
75704>>>>>>>>>>>/// For fieldIndex from 1 to iCols
75704>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
75704>>>>>>>>>>>///     Showln sValue
75704>>>>>>>>>>>/// Loop
75704>>>>>>>>>>>
75704>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
75706>>>>>>>>>>>    String sReturnValue
75706>>>>>>>>>>>    Integer iSize
75706>>>>>>>>>>>
75706>>>>>>>>>>>    Move 0 to iSize
75707>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
75748>>>>>>>>>>>>
75748>>>>>>>>>>>
75748>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
75749>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
75750>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
75755>>>>>>>>>>>
75755>>>>>>>>>>>    Function_Return sReturnValue
75756>>>>>>>>>>>End_Function
75757>>>>>>>>>>>
75757>>>>>>>>>>>//=============================================================================
75757>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
75757>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
75757>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
75757>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
75757>>>>>>>>>>>/// when no name is set.
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Assumptions
75757>>>>>>>>>>>/// @Status      Public
75757>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
75757>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
75757>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
75757>>>>>>>>>>>/// @Param variable                     Name of the schema
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Example
75757>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
75757>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
75757>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
75757>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
75757>>>>>>>>>>>
75757>>>>>>>>>>>//=============================================================================
75757>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
75757>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
75757>>>>>>>>>>>/// used to open tables.
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Assumptions
75757>>>>>>>>>>>/// @Status      Public
75757>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
75757>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
75757>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
75757>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Example
75757>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
75757>>>>>>>>>>>/// Showln sName
75757>>>>>>>>>>>
75757>>>>>>>>>>>//=============================================================================
75757>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
75757>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
75757>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
75757>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
75757>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
75757>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
75757>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
75757>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
75757>>>>>>>>>>>/// is set to true.
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Assumptions
75757>>>>>>>>>>>/// @Status      Deprecated
75757>>>>>>>>>>>/// @Drivers     ORAFLex
75757>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
75757>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
75757>>>>>>>>>>>/// @Param procedure            Full name of the procedure
75757>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Example
75757>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
75757>>>>>>>>>>>
75757>>>>>>>>>>>//=============================================================================
75757>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
75757>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
75757>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
75757>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
75757>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
75757>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
75757>>>>>>>>>>>/// will be passed.
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
75757>>>>>>>>>>>/// @Status      Public
75757>>>>>>>>>>>/// @Drivers     All
75757>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
75757>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
75757>>>>>>>>>>>/// @Param procedure            Full name of the procedure
75757>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
75757>>>>>>>>>>>///
75757>>>>>>>>>>>/// @Example
75757>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
75757>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
75757>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
75757>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
75757>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
75757>>>>>>>>>>>
75757>>>>>>>>>>>
75757>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
75759>>>>>>>>>>>    Integer iParam
75759>>>>>>>>>>>
75759>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
75760>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
75761>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
75762>>>>>>>>>>>
75762>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
75794>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
75826>>>>>>>>>>>    SQL_APPEND_STMT to "( "
75858>>>>>>>>>>>    For iParam from 1 to iNumpar
75864>>>>>>>>>>>>
75864>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
75943>>>>>>>>>>>    Loop
75944>>>>>>>>>>>>
75944>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
75976>>>>>>>>>>>    SQL_PREPARE_STMT
76025>>>>>>>>>>> End_Procedure
76026>>>>>>>>>>>
76026>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
76028>>>>>>>>>>>    Integer iParam
76028>>>>>>>>>>>
76028>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
76029>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
76030>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
76031>>>>>>>>>>>
76031>>>>>>>>>>>    SQL_SET_STMT to "CALL "
76063>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
76095>>>>>>>>>>>    SQL_APPEND_STMT to "("
76127>>>>>>>>>>>    For iParam from 1 to iNumpar
76133>>>>>>>>>>>>
76133>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
76212>>>>>>>>>>>    Loop
76213>>>>>>>>>>>>
76213>>>>>>>>>>>    SQL_APPEND_STMT to ")"
76245>>>>>>>>>>>    SQL_PREPARE_STMT
76294>>>>>>>>>>>End_Procedure
76295>>>>>>>>>>>
76295>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
76297>>>>>>>>>>>    Integer iParam
76297>>>>>>>>>>>    String  sParam
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
76298>>>>>>>>>>>
76298>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
76298>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
76298>>>>>>>>>>>    // from the call.
76298>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
76330>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
76362>>>>>>>>>>>
76362>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
76362>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
76362>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
76362>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
76396>>>>>>>>>>>
76396>>>>>>>>>>>    For iParam from 1 to iNumpar
76402>>>>>>>>>>>>
76402>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
76481>>>>>>>>>>>    Loop
76482>>>>>>>>>>>>
76482>>>>>>>>>>>
76482>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
76516>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
76548>>>>>>>>>>>
76548>>>>>>>>>>>    SQL_PREPARE_STMT CURSOR_TYPE TYPE_NONE
76604>>>>>>>>>>>
76604>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
76604>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
76604>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
76627>>>>>>>>>>>End_Procedure
76628>>>>>>>>>>>
76628>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
76630>>>>>>>>>>>    Integer iParam
76630>>>>>>>>>>>    String  sParam
76630>>>>>>>>>>>
76630>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
76631>>>>>>>>>>>
76631>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
76631>>>>>>>>>>>    // open/close parens
76631>>>>>>>>>>>    SQL_SET_STMT to strProcName
76663>>>>>>>>>>>
76663>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
76663>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
76663>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
76663>>>>>>>>>>>    SQL_APPEND_STMT to "( "
76695>>>>>>>>>>>
76695>>>>>>>>>>>    For iParam from 1 to iNumpar
76701>>>>>>>>>>>>
76701>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
76780>>>>>>>>>>>    Loop
76781>>>>>>>>>>>>
76781>>>>>>>>>>>
76781>>>>>>>>>>>    SQL_APPEND_STMT to ")"
76813>>>>>>>>>>>
76813>>>>>>>>>>>    SQL_PREPARE_STMT
76862>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
76862>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
76867>>>>>>>>>>>End_Procedure
76868>>>>>>>>>>>
76868>>>>>>>>>>>//=============================================================================
76868>>>>>>>>>>>/// @Name        SQL_GET_STMT
76868>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
76868>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
76868>>>>>>>>>>>/// what character to start the string at and also the maximum number of
76868>>>>>>>>>>>/// characters to allow for the string.
76868>>>>>>>>>>>///
76868>>>>>>>>>>>/// @Assumptions
76868>>>>>>>>>>>/// @Status      Public
76868>>>>>>>>>>>/// @Drivers     All
76868>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
76868>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
76868>>>>>>>>>>>///
76868>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
76868>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
76868>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
76868>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
76868>>>>>>>>>>>///
76868>>>>>>>>>>>/// @Example
76868>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76868>>>>>>>>>>>/// SQL_PREPARE_STMT
76868>>>>>>>>>>>/// SQL_EXECUTE_STMT
76868>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
76868>>>>>>>>>>>/// If (Found) Begin
76868>>>>>>>>>>>///     Showln sFirstName
76868>>>>>>>>>>>///     Showln sLastName
76868>>>>>>>>>>>/// End
76868>>>>>>>>>>>///
76868>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
76868>>>>>>>>>>>/// Showln sValue
76868>>>>>>>>>>>
76868>>>>>>>>>>>
76868>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
76870>>>>>>>>>>>    String sStatement
76870>>>>>>>>>>>
76870>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
76896>>>>>>>>>>>>
76896>>>>>>>>>>>
76896>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
76898>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
76899>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
76904>>>>>>>>>>>    End
76904>>>>>>>>>>>>
76904>>>>>>>>>>>    Function_Return sStatement
76905>>>>>>>>>>>End_Function
76906>>>>>>>>>>>
76906>>>>>>>>>>>//=============================================================================
76906>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
76906>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
76906>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
76906>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
76906>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
76906>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
76906>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
76906>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
76906>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
76906>>>>>>>>>>>/// current user will be inserted before the function name.
76906>>>>>>>>>>>///
76906>>>>>>>>>>>/// @Assumptions
76906>>>>>>>>>>>/// @Status      Public
76906>>>>>>>>>>>/// @Drivers     All
76906>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
76906>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
76906>>>>>>>>>>>///
76906>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
76906>>>>>>>>>>>/// @Param function                     Full name of the function
76906>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
76906>>>>>>>>>>>///
76906>>>>>>>>>>>/// @Example
76906>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
76906>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
76906>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
76906>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
76906>>>>>>>>>>>/// Showln dDOB
76906>>>>>>>>>>>
76906>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
76908>>>>>>>>>>>    Integer iParam
76908>>>>>>>>>>>
76908>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
76940>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
76972>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77004>>>>>>>>>>>    SQL_APPEND_STMT to "( "
77036>>>>>>>>>>>    For iParam from 1 to iNumpar
77042>>>>>>>>>>>>
77042>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
77121>>>>>>>>>>>    Loop
77122>>>>>>>>>>>>
77122>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
77154>>>>>>>>>>>    SQL_PREPARE_STMT
77203>>>>>>>>>>>
77203>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
77204>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
77209>>>>>>>>>>>
77209>>>>>>>>>>>    Increment MertechInc_iParamCount
77210>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
77211>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
77216>>>>>>>>>>>End_Procedure
77217>>>>>>>>>>>
77217>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
77219>>>>>>>>>>>    Integer iParam
77219>>>>>>>>>>>
77219>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
77220>>>>>>>>>>>
77220>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
77252>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77284>>>>>>>>>>>    SQL_APPEND_STMT to "("
77316>>>>>>>>>>>    For iParam from 1 to iNumpar
77322>>>>>>>>>>>>
77322>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
77401>>>>>>>>>>>    Loop
77402>>>>>>>>>>>>
77402>>>>>>>>>>>    SQL_APPEND_STMT to ")"
77434>>>>>>>>>>>    SQL_PREPARE_STMT
77483>>>>>>>>>>>End_Procedure
77484>>>>>>>>>>>
77484>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
77486>>>>>>>>>>>    Integer iParam
77486>>>>>>>>>>>
77486>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
77487>>>>>>>>>>>
77487>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
77489>>>>>>>>>>>        String schema
77489>>>>>>>>>>>        GET_SCHEMA_NAME to schema
77535>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
77536>>>>>>>>>>>    End
77536>>>>>>>>>>>>
77536>>>>>>>>>>>
77536>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
77568>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77600>>>>>>>>>>>    SQL_APPEND_STMT to "("
77632>>>>>>>>>>>End_Procedure
77633>>>>>>>>>>>
77633>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
77635>>>>>>>>>>>    Integer iParam
77635>>>>>>>>>>>
77635>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
77636>>>>>>>>>>>
77636>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
77668>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77700>>>>>>>>>>>    SQL_APPEND_STMT to "("
77732>>>>>>>>>>>End_Procedure
77733>>>>>>>>>>>
77733>>>>>>>>>>>//=============================================================================
77733>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
77733>>>>>>>>>>>/// @Description
77733>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
77733>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
77733>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
77733>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
77733>>>>>>>>>>>/// for each parameter.
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
77733>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
77733>>>>>>>>>>>/// regarded as input, output or both.
77733>>>>>>>>>>>///
77733>>>>>>>>>>>///@Assumptions
77733>>>>>>>>>>>/// @Status      Public
77733>>>>>>>>>>>/// @Drivers     All
77733>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
77733>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
77733>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
77733>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
77733>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// @Example
77733>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
77733>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
77733>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
77733>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
77733>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
77733>>>>>>>>>>>
77733>>>>>>>>>>>
77733>>>>>>>>>>>
77733>>>>>>>>>>>//=============================================================================
77733>>>>>>>>>>>/// @Name        SQL_SET_QUERY_PARAMETER
77733>>>>>>>>>>>/// @Description
77733>>>>>>>>>>>/// Use this command to set the value of the parameters that are defined in your
77733>>>>>>>>>>>/// SQL Query. Each backend uses a different syntax for paramterized queries,
77733>>>>>>>>>>>/// but all have the same goal of removing the risk of SQL Injection attacks.
77733>>>>>>>>>>>/// Oracle and PostgreSQL allow for named parameters which this command supports
77733>>>>>>>>>>>/// by passing the first parameter as a string containing the named parameter
77733>>>>>>>>>>>/// (without the syntactical sugar). For MS-SQL and MySQL only positional
77733>>>>>>>>>>>/// parameters are supported and the first parameter to this command should be an
77733>>>>>>>>>>>/// integer containing the ordinal position of the parameter.
77733>>>>>>>>>>>///
77733>>>>>>>>>>>///
77733>>>>>>>>>>>///@Assumptions
77733>>>>>>>>>>>/// @Status      Public
77733>>>>>>>>>>>/// @Drivers     All
77733>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
77733>>>>>>>>>>>/// @See         SQL_SET_STMT SQL_EXECUTE_STMT
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// @Syntax SQL_SET_QUERY_PARAMETER {param} to {variable}
77733>>>>>>>>>>>/// @Param param                     Either a string containing the named parameter or an integer of it's ordinal position.
77733>>>>>>>>>>>/// @Param variable/constant         Variable or constant holding the parameter to be passed.
77733>>>>>>>>>>>///
77733>>>>>>>>>>>/// @Example
77733>>>>>>>>>>>/// SQL_SET_STMT "Select name from Customer where status = ? and city = ?"
77733>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 1 to "Y"
77733>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 2 to "Fresno"
77733>>>>>>>>>>>/// SQL_EXECUTE_STMT
77733>>>>>>>>>>>
77733>>>>>>>>>>>Function MDS_Get_Param_Type Global Variant vVal Returns Integer
77735>>>>>>>>>>>    Local Integer vartype retval
77735>>>>>>>>>>>    Local Variant some_val
77735>>>>>>>>>>>    Move vVal to some_val
77736>>>>>>>>>>>    Move (DeRefW(AddressOf(some_val), 0)) to vartype
77737>>>>>>>>>>>
77737>>>>>>>>>>>    If (vartype = 2) Begin
77739>>>>>>>>>>>        Move ((13 * (2^24)) + 6) to retval
77740>>>>>>>>>>>    End
77740>>>>>>>>>>>>
77740>>>>>>>>>>>    Else If (vartype = 3) Begin
77743>>>>>>>>>>>        Move ((3 * (2^24)) + 11) to retval
77744>>>>>>>>>>>    End
77744>>>>>>>>>>>>
77744>>>>>>>>>>>    Else If (vartype = 4) Begin // OLE_VT_R4
77747>>>>>>>>>>>        Move ((10 * (2^24)) + 11) to retval
77748>>>>>>>>>>>    End
77748>>>>>>>>>>>>
77748>>>>>>>>>>>    Else If (vartype = 5) Begin // OLE_VT_R8
77751>>>>>>>>>>>        Move ((5 * (2^24)) + 26) to retval
77752>>>>>>>>>>>    End
77752>>>>>>>>>>>>
77752>>>>>>>>>>>    Else If (vartype = 6) Begin // OLE_VT_Currency
77755>>>>>>>>>>>        Move ((18 * (2^24)) + 21) to retval
77756>>>>>>>>>>>    End
77756>>>>>>>>>>>>
77756>>>>>>>>>>>    Else If (vartype = 7) Begin // OLE_VT_Date
77759>>>>>>>>>>>        Move ((9 * (2^24)) + 26) to retval
77760>>>>>>>>>>>    End
77760>>>>>>>>>>>>
77760>>>>>>>>>>>    Else If (vartype = 11) Begin // OLE_VT_Bool
77763>>>>>>>>>>>        Move ((16 * (2^24)) + 1) to retval
77764>>>>>>>>>>>    End
77764>>>>>>>>>>>>
77764>>>>>>>>>>>    Else If (vartype = 14) Begin // OLE_VT_Decimal
77767>>>>>>>>>>>        Move ((2 * (2^24)) + 34) to retval
77768>>>>>>>>>>>    End
77768>>>>>>>>>>>>
77768>>>>>>>>>>>    Else If (vartype = 16) Begin // OLE_VT_I1
77771>>>>>>>>>>>        Move ((11 * (2^24)) + 4) to retval
77772>>>>>>>>>>>    End
77772>>>>>>>>>>>>
77772>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_Ui1
77775>>>>>>>>>>>        Move ((12 * (2^24)) + 3) to retval
77776>>>>>>>>>>>    End
77776>>>>>>>>>>>>
77776>>>>>>>>>>>    Else If (vartype = 18) Begin // OLE_VT_Ui2
77779>>>>>>>>>>>        Move ((14 * (2^24)) + 5) to retval
77780>>>>>>>>>>>    End
77780>>>>>>>>>>>>
77780>>>>>>>>>>>    Else If (vartype = 19) Begin // OLE_VT_Ui4
77783>>>>>>>>>>>        Move ((15 * (2^24)) + 10) to retval
77784>>>>>>>>>>>    End
77784>>>>>>>>>>>>
77784>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_I8
77787>>>>>>>>>>>        Move ((4 * (2^24)) + 20) to retval
77788>>>>>>>>>>>    End
77788>>>>>>>>>>>>
77788>>>>>>>>>>>
77788>>>>>>>>>>>    Function_Return retval
77789>>>>>>>>>>>End_Function
77790>>>>>>>>>>>
77790>>>>>>>>>>>//=============================================================================
77790>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
77790>>>>>>>>>>>/// @Description This command is used to get the value of a specific
77790>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
77790>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
77790>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
77790>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
77790>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
77790>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
77790>>>>>>>>>>>/// in order to work properly.
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Assumptions
77790>>>>>>>>>>>/// @Status      Public
77790>>>>>>>>>>>/// @Drivers     All
77790>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
77790>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
77790>>>>>>>>>>>/// @Param parameter            Number of paramater to return
77790>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Example
77790>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
77790>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
77790>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
77790>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// Showln sStatus
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Example
77790>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
77790>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
77790>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
77790>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
77790>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// Showln sStatus
77790>>>>>>>>>>>
77790>>>>>>>>>>>
77790>>>>>>>>>>>
77790>>>>>>>>>>>//=============================================================================
77790>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
77790>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
77790>>>>>>>>>>>/// function call. After the function has been successfully called, this
77790>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Assumptions
77790>>>>>>>>>>>/// @Status      Public
77790>>>>>>>>>>>/// @Drivers     All
77790>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77790>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
77790>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Example
77790>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
77790>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
77790>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
77790>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
77790>>>>>>>>>>>/// Showln dDOB
77790>>>>>>>>>>>
77790>>>>>>>>>>>//=============================================================================
77790>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
77790>>>>>>>>>>>/// @Description This command is used to execute the function statement
77790>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
77790>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
77790>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
77790>>>>>>>>>>>/// command will not get any returned values but will simply execute the
77790>>>>>>>>>>>/// function.
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Assumptions
77790>>>>>>>>>>>/// @Status      Public
77790>>>>>>>>>>>/// @Drivers     All
77790>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77790>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
77790>>>>>>>>>>>///
77790>>>>>>>>>>>/// @Example
77790>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
77790>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
77790>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
77790>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
77790>>>>>>>>>>>/// Showln dDOB
77790>>>>>>>>>>>
77790>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
77792>>>>>>>>>>>    Integer iParam
77792>>>>>>>>>>>    String  sParam
77792>>>>>>>>>>>
77792>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
77794>>>>>>>>>>>       SQL_APPEND_STMT to ')'
77826>>>>>>>>>>>       SQL_PREPARE_STMT
77875>>>>>>>>>>>    End
77875>>>>>>>>>>>>
77875>>>>>>>>>>>
77875>>>>>>>>>>>    SQL_EXECUTE_STMT
77915>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
77917>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
77967>>>>>>>>>>>    End
77967>>>>>>>>>>>>
77967>>>>>>>>>>>End_Procedure
77968>>>>>>>>>>>
77968>>>>>>>>>>>//=============================================================================
77968>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
77968>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
77968>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
77968>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
77968>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
77968>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
77968>>>>>>>>>>>/// @Status      Public
77968>>>>>>>>>>>/// @Drivers     ORAFLex
77968>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
77968>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
77968>>>>>>>>>>>/// @Param procedure            Full name of the procedure
77968>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Example
77968>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
77968>>>>>>>>>>>/// Showln sStatus
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
77968>>>>>>>>>>>/// Showln sStatus
77968>>>>>>>>>>>
77968>>>>>>>>>>>
77968>>>>>>>>>>>//=============================================================================
77968>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
77968>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
77968>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
77968>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
77968>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
77968>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
77968>>>>>>>>>>>/// returned value. Note that this command can only return a single value
77968>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
77968>>>>>>>>>>>/// dealing with multiple return values.
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// Assumptions
77968>>>>>>>>>>>/// @Status      Public
77968>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
77968>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77968>>>>>>>>>>>/// @See
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
77968>>>>>>>>>>>/// @Param function                     Full name of the function
77968>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
77968>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Example
77968>>>>>>>>>>>/// Move 5 to sCustomerID
77968>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
77968>>>>>>>>>>>/// Showln sStatus
77968>>>>>>>>>>>
77968>>>>>>>>>>>//=============================================================================
77968>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
77968>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
77968>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
77968>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
77968>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Assumptions
77968>>>>>>>>>>>/// @Status      Public
77968>>>>>>>>>>>/// @Drivers     All
77968>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77968>>>>>>>>>>>/// @See
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
77968>>>>>>>>>>>/// @Param FileNumber           The file number
77968>>>>>>>>>>>/// @Param variable                     Path of the file being output to
77968>>>>>>>>>>>///
77968>>>>>>>>>>>///@Example
77968>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
77968>>>>>>>>>>>
77968>>>>>>>>>>>//=============================================================================
77968>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
77968>>>>>>>>>>>/// @Description This command is used to get an error message
77968>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
77968>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
77968>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
77968>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
77968>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Assumptions
77968>>>>>>>>>>>/// @Status      Public
77968>>>>>>>>>>>/// @Drivers     All
77968>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77968>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
77968>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
77968>>>>>>>>>>>///
77968>>>>>>>>>>>/// @Example
77968>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
77968>>>>>>>>>>>
77968>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
77970>>>>>>>>>>>    String sMessage
77970>>>>>>>>>>>
77970>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
77971>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
77976>>>>>>>>>>>
77976>>>>>>>>>>>    Function_Return sMessage
77977>>>>>>>>>>>End_Function
77978>>>>>>>>>>>
77978>>>>>>>>>>>//=============================================================================
77978>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
77978>>>>>>>>>>>/// @Description This command is used to get the last error message used
77978>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
77978>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
77978>>>>>>>>>>>///
77978>>>>>>>>>>>/// @Assumptions
77978>>>>>>>>>>>/// @Status      Public
77978>>>>>>>>>>>/// @Drivers     All
77978>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77978>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
77978>>>>>>>>>>>///
77978>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
77978>>>>>>>>>>>/// @Param server                       Name of the server
77978>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
77978>>>>>>>>>>>///
77978>>>>>>>>>>>/// @Example
77978>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
77978>>>>>>>>>>>
77978>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
77980>>>>>>>>>>>    String sMessage
77980>>>>>>>>>>>
77980>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
77981>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
77986>>>>>>>>>>>
77986>>>>>>>>>>>    Function_Return sMessage
77987>>>>>>>>>>>End_Function
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
77988>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
77988>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
77988>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
77988>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
77988>>>>>>>>>>>/// this message is enabled.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
77988>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
77988>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// Move Customer.File_Number to hFile
77988>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// Structure_Start hFile
77988>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
77988>>>>>>>>>>>/// Structure_End hFile
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
77988>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
77988>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
77988>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
77988>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
77988>>>>>>>>>>>/// for data from columns that are not part of the query.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
77988>>>>>>>>>>>/// ENABLED to turn the error messages back on.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
77988>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// Open Customer
77988>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
77988>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
77988>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// Clear Customer
77988>>>>>>>>>>>/// Repeat
77988>>>>>>>>>>>///    Find Gt Customer by Index.1
77988>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
77988>>>>>>>>>>>/// Until (Not(Found))
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SQLFlex_REVISION
77988>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
77988>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
77988>>>>>>>>>>>/// specified variable.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Deprecated
77988>>>>>>>>>>>/// @Drivers     SQLFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
77988>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SQLFlex_REVISION sVersion
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
77988>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
77988>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
77988>>>>>>>>>>>/// specified variable.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Deprecated
77988>>>>>>>>>>>/// @Drivers     SQLFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
77988>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        LOGGED_USERS
77988>>>>>>>>>>>/// @Description This command returns the number of native users that are
77988>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
77988>>>>>>>>>>>/// is passed with the command.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
77988>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
77988>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
77988>>>>>>>>>>>/// the current license.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 LOGGED_USERS
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
77988>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
77988>>>>>>>>>>>
77988>>>>>>>>>>> //=============================================================================
77988>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_SESSIONS
77988>>>>>>>>>>>/// @Description This command returns the maximum number of sessions allowed by
77988>>>>>>>>>>>/// the current license.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2015-06-25 by Anton
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_SESSIONS {variable}
77988>>>>>>>>>>>/// @Param variable         Variable to hold the maximum number of sessions
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_SESSIONS sMax
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
77988>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
77988>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
77988>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
77988>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
77988>>>>>>>>>>>/// a certain query. If the database is not specified with this command
77988>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
77988>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
77988>>>>>>>>>>>/// use SQL_USE_DATABASE.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
77988>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
77988>>>>>>>>>>>/// @Param database                     Name of the database
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
77988>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
77988>>>>>>>>>>>/// Open Customer
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
77988>>>>>>>>>>>/// @Description This command is used to get the name of the database
77988>>>>>>>>>>>/// currently being used. The name of the database is returned into the
77988>>>>>>>>>>>/// specified string. Even though this command works either way, it is
77988>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
77988>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        GET_NAME_SPACE
77988>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
77988>>>>>>>>>>>/// used with the current application.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     PgFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 SET_NAME_SPACE
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
77988>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_NAME_SPACE
77988>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
77988>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
77988>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
77988>>>>>>>>>>>/// specify relational data. Note that this command will override the
77988>>>>>>>>>>>/// NAME_SPACE value in the INT file.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     PgFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
77988>>>>>>>>>>>/// @See                 GET_NAME_SPACE
77988>>>>>>>>>>>/// @INTOPT              NAME_SPACE
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
77988>>>>>>>>>>>/// @Param variable                     Name of the name space
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SET_NAME_SPACE to "public"
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
77988>>>>>>>>>>>/// @Description This command is used to specify which database is used
77988>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
77988>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
77988>>>>>>>>>>>/// If none is specified then the default database is used. This can
77988>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
77988>>>>>>>>>>>/// database not currently being used. Note that this only works if
77988>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
77988>>>>>>>>>>>/// "TestDB.Customer".
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
77988>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
77988>>>>>>>>>>>/// @Param database                     Name of the database
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
77988>>>>>>>>>>>/// SQL_PREPARE_STMT
77988>>>>>>>>>>>/// SQL_EXECUTE_STMT
77988>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
77988>>>>>>>>>>>/// If (Found) Begin
77988>>>>>>>>>>>///     Showln sFirstName
77988>>>>>>>>>>>///     Showln sLastName
77988>>>>>>>>>>>/// End
77988>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>/// @Description This command is used to set the server to be used when
77988>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
77988>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
77988>>>>>>>>>>>/// then the server used during login will be used. This command is only
77988>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
77988>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
77988>>>>>>>>>>>/// @INTOPT              SERVER_NAME
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
77988>>>>>>>>>>>/// @Param server                       Name of the server
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
77988>>>>>>>>>>>
77988>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
77988>>>>>>>>>>>//               replace conflicts with the property SET message.
77988>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>/// @Description This command returns the name of the server to be used
77988>>>>>>>>>>>/// for opening and querying tables.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
77988>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
77988>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
77988>>>>>>>>>>>
77988>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
77988>>>>>>>>>>>//               replace conflicts with the property GET message.
77988>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
77988>>>>>>>>>>>/// @Description This command is used to specify which server to use for
77988>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
77988>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
77988>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
77988>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
77988>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
77988>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
77988>>>>>>>>>>>/// @Param server               Name of the server
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
77988>>>>>>>>>>>/// @Description This command returns the server currently being used for
77988>>>>>>>>>>>/// embedded SQL statements.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
77988>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
77988>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
77988>>>>>>>>>>>/// @Description This command allows the user to login with a specified
77988>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
77988>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
77988>>>>>>>>>>>/// a specific user for different situations. For example, if a company
77988>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
77988>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
77988>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
77988>>>>>>>>>>>/// easily distinguishing themselves from other users.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     SQLFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
77988>>>>>>>>>>>/// @See
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
77988>>>>>>>>>>>/// @Param server               Server to use for login
77988>>>>>>>>>>>/// @Param username     Username to use for login
77988>>>>>>>>>>>/// @Param password     Password to use for login
77988>>>>>>>>>>>/// @Param hostname     Hostname to use for login
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
77988>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
77988>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
77988>>>>>>>>>>>/// been executed and all rows have been fetched.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
77988>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
77988>>>>>>>>>>>/// SQL_PREPARE_STMT
77988>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
77988>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
77988>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
77988>>>>>>>>>>>/// If (Found) Begin
77988>>>>>>>>>>>///     Showln Customer.FirstName
77988>>>>>>>>>>>///     Showln Customer.LastName
77988>>>>>>>>>>>/// End
77988>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
77988>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
77988>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
77988>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
77988>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
77988>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
77988>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
77988>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
77988>>>>>>>>>>>/// or just for a specific table.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
77988>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
77988>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
77988>>>>>>>>>>>/// @See
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
77988>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
77988>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
77988>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
77988>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
77988>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
77988>>>>>>>>>>>/// effects they can have on transactions.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
77988>>>>>>>>>>>/// for MSSQL).
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
77988>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
77988>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
77988>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
77988>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
77988>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
77988>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
77988>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
77988>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
77988>>>>>>>>>>>/// good practice.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
77988>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
77988>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
77988>>>>>>>>>>>/// by other transactions.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
77988>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
77988>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
77988>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
77988>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
77988>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
77988>>>>>>>>>>>/// do so.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
77988>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
77988>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
77988>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
77988>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
77988>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
77988>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
77988>>>>>>>>>>>/// @See
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
77988>>>>>>>>>>>/// @Param server                       Name of the server
77988>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
77988>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
77988>>>>>>>>>>>
77988>>>>>>>>>>>//=============================================================================
77988>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
77988>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
77988>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
77988>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
77988>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
77988>>>>>>>>>>>/// migrating passwords with special characters may call for different code
77988>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
77988>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
77988>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
77988>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
77988>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
77988>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
77988>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
77988>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
77988>>>>>>>>>>>/// on will automatically enable those custom translations.
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Assumptions
77988>>>>>>>>>>>/// @Status      Public
77988>>>>>>>>>>>/// @Drivers     All
77988>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
77988>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
77988>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
77988>>>>>>>>>>>///
77988>>>>>>>>>>>/// @Example
77988>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
77988>>>>>>>>>>>
77988>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
77990>>>>>>>>>>>    Move iChar to MertechInc_sArg1
77991>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
77992>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
77997>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
78000>>>>>>>>>>>End_Procedure
78001>>>>>>>>>>>
78001>>>>>>>>>>>//=============================================================================
78001>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
78001>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
78001>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
78001>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
78001>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
78001>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
78001>>>>>>>>>>>/// work.
78001>>>>>>>>>>>///
78001>>>>>>>>>>>/// @Assumptions
78001>>>>>>>>>>>/// @Status      Public
78001>>>>>>>>>>>/// @Drivers     All
78001>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78001>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
78001>>>>>>>>>>>///
78001>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
78001>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
78001>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
78001>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
78001>>>>>>>>>>>
78001>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
78003>>>>>>>>>>>    Move iChar to MertechInc_sArg1
78004>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
78005>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
78010>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
78013>>>>>>>>>>>End_Function
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
78014>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
78014>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
78014>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
78014>>>>>>>>>>>/// will be returned.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
78014>>>>>>>>>>>/// @Status      Public
78014>>>>>>>>>>>/// @Drivers     All
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
78014>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
78014>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
78014>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
78014>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
78014>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
78014>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
78014>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
78014>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
78014>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
78014>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
78014>>>>>>>>>>>/// driver.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Public
78014>>>>>>>>>>>/// @Drivers     SQLFlex
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
78014>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Example
78014>>>>>>>>>>>/// Structure_Start hFile
78014>>>>>>>>>>>///
78014>>>>>>>>>>>///     Create_Field hFile
78014>>>>>>>>>>>///
78014>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
78014>>>>>>>>>>>///
78014>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
78014>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
78014>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// Structure_End hFile
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
78014>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
78014>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
78014>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
78014>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
78014>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
78014>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
78014>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
78014>>>>>>>>>>>/// in most situations, that should be used instead of this command.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Deprecated
78014>>>>>>>>>>>/// @Drivers     ORAFlex
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
78014>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
78014>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Deprecated
78014>>>>>>>>>>>/// @Drivers     SQLFlex
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
78014>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
78014>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
78014>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Public
78014>>>>>>>>>>>/// @Drivers     All
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
78014>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Example
78014>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
78014>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
78014>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
78014>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
78014>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
78014>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
78014>>>>>>>>>>>/// statements will wait indefinitely before timing out.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Public
78014>>>>>>>>>>>/// @Drivers     SQLFlex
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78014>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
78014>>>>>>>>>>>/// @Param server                       Name of the server
78014>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Example
78014>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
78014>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
78014>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
78014>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
78014>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
78014>>>>>>>>>>>/// that the statement will wait indefinitely.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Public
78014>>>>>>>>>>>/// @Drivers     SQLFlex
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78014>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
78014>>>>>>>>>>>/// @Param server                       Name of the server
78014>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Example
78014>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
78014>>>>>>>>>>>
78014>>>>>>>>>>>//=============================================================================
78014>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
78014>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
78014>>>>>>>>>>>///
78014>>>>>>>>>>>/// @Assumptions
78014>>>>>>>>>>>/// @Status      Internal
78014>>>>>>>>>>>/// @Drivers     All
78014>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78014>>>>>>>>>>>/// @See
78014>>>>>>>>>>>
78014>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
78016>>>>>>>>>>>    String sValue
78016>>>>>>>>>>>
78016>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
78017>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
78022>>>>>>>>>>>
78022>>>>>>>>>>>    Function_Return sValue
78023>>>>>>>>>>>End_Function
78024>>>>>>>>>>>
78024>>>>>>>>>>>//=============================================================================
78024>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
78024>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
78024>>>>>>>>>>>///
78024>>>>>>>>>>>/// @Assumptions
78024>>>>>>>>>>>/// @Status      Internal
78024>>>>>>>>>>>/// @Drivers     All
78024>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78024>>>>>>>>>>>/// @See
78024>>>>>>>>>>>
78024>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
78026>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
78031>>>>>>>>>>>End_Procedure
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
78032>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
78032>>>>>>>>>>>/// parameters is the keyword BINDING.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Internal
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
78032>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
78032>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Internal
78032>>>>>>>>>>>/// @Drivers     SQLFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>
78032>>>>>>>>>>>
78032>>>>>>>>>>>
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
78032>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
78032>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
78032>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
78032>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
78032>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
78032>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
78032>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
78032>>>>>>>>>>>/// is set to true.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
78032>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78032>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
78032>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
78032>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
78032>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
78032>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
78032>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
78032>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
78032>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
78032>>>>>>>>>>>/// then the indicator "Err" is set to true.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     SQLFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
78032>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78032>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
78032>>>>>>>>>>>/// @Description This command is used to close any open cursors created
78032>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
78032>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
78032>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
78032>>>>>>>>>>>/// use this command once a procedure call is completed.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     SQLFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
78032>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
78032>>>>>>>>>>>/// END_CALL_PROCEDURE
78032>>>>>>>>>>>/// Showln sValue
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
78032>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
78032>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
78032>>>>>>>>>>>/// returned value and must be used after the procedure has already been
78032>>>>>>>>>>>/// built and executed.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     SQLFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
78032>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
78032>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
78032>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
78032>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
78032>>>>>>>>>>>/// Showln sSpaceUsed
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
78032>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
78032>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
78032>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
78032>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
78032>>>>>>>>>>>/// working properly through SQL Server.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
78032>>>>>>>>>>>/// @Param server                       The name of the mirror server
78032>>>>>>>>>>>/// @Param database                     The database acting as a mirror
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
78032>>>>>>>>>>>/// @Description This command is used to get the name of the server
78032>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
78032>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
78032>>>>>>>>>>>/// correct values.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
78032>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
78032>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        COPY_DATA
78032>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
78032>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
78032>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
78032>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
78032>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
78032>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
78032>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
78032>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
78032>>>>>>>>>>>/// order for this process to work properly the table being copied can not
78032>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
78032>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
78032>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
78032>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
78032>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
78032>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
78032>>>>>>>>>>>/// regarding this callback object.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// This function should follow this pattern:
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// sText - Message corresponding to the current status ID
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
78032>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
78032>>>>>>>>>>>///                                                                              process
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
78032>>>>>>>>>>>///                                                                              copy the source data
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
78032>>>>>>>>>>>///                                                                              10% of the data is copied
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
78032>>>>>>>>>>>/// copying process. Returning true will end it.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
78032>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
78032>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
78032>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
78032>>>>>>>>>>>/// @Param from                         Table to copy from.
78032>>>>>>>>>>>/// @Param destination          Table to copy to.
78032>>>>>>>>>>>/// @Param function             Object with callback function (optional)
78032>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Object CallBackObj is a Array
78032>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
78032>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
78032>>>>>>>>>>>///             Showln "Error"
78032>>>>>>>>>>>///                             Showln sText
78032>>>>>>>>>>>///                             Function_Return True
78032>>>>>>>>>>>///         End
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///         Else Showln sText
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///                     Function_Return False
78032>>>>>>>>>>>///
78032>>>>>>>>>>>///     End_Function
78032>>>>>>>>>>>/// End_Object
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78032>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
78032>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        ORAFlex_REVISION
78032>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
78032>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
78032>>>>>>>>>>>/// variable.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     ORAFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
78032>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// ORAFlex_REVISION sVersion
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
78032>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
78032>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
78032>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
78032>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
78032>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
78032>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
78032>>>>>>>>>>>/// from the server.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
78032>>>>>>>>>>>/// @Param server               Name of the server
78032>>>>>>>>>>>
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
78032>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
78032>>>>>>>>>>>/// The trade off is between increased resources on the server and
78032>>>>>>>>>>>/// re-preparing of cursors.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
78032>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
78032>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
78032>>>>>>>>>>>/// changed based on available server resources.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
78032>>>>>>>>>>>/// init.ora
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
78032>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
78032>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
78032>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
78032>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
78032>>>>>>>>>>>/// resources.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
78032>>>>>>>>>>>/// @Param server                       The name of the server
78032>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
78032>>>>>>>>>>>/// @Description This command will return the maximum number of open
78032>>>>>>>>>>>/// cursors allowed by the server.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
78032>>>>>>>>>>>/// @Param server                       Name of the server
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
78032>>>>>>>>>>>/// @Description This command returns the number of cursors currently
78032>>>>>>>>>>>/// open on the server.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
78032>>>>>>>>>>>/// @Param server                       Name of the server
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
78032>>>>>>>>>>>///
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
78032>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
78032>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
78032>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
78032>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
78032>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     OraFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
78032>>>>>>>>>>>/// @Param server                       Name of the server
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
78032>>>>>>>>>>>/// SQL_PREPARE_STMT
78032>>>>>>>>>>>/// SQL_EXECUTE_STMT
78032>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
78032>>>>>>>>>>>/// If (Found) Begin
78032>>>>>>>>>>>///     Showln sDOB
78032>>>>>>>>>>>/// End
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
78032>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
78032>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
78032>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
78032>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
78032>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
78032>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
78032>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
78032>>>>>>>>>>>/// values.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     ORAFLex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
78032>>>>>>>>>>>/// @Param function                     Full name of the function
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78032>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
78032>>>>>>>>>>>/// Showln sStatus
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
78032>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
78032>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
78032>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
78032>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
78032>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
78032>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
78032>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
78032>>>>>>>>>>>/// values.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Status      Deprecated
78032>>>>>>>>>>>/// @Drivers     PGFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
78032>>>>>>>>>>>/// @Param function                     Full name of the function
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78032>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
78032>>>>>>>>>>>/// Showln sStatus
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
78032>>>>>>>>>>>/// @Description Sets the support language for the driver.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Internal
78032>>>>>>>>>>>/// @Drivers     ORAFLex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
78032>>>>>>>>>>>/// @Param server               The name of the server being used
78032>>>>>>>>>>>/// @Param language             The language to set support to
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
78032>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
78032>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
78032>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
78032>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
78032>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
78032>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
78032>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
78032>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
78032>>>>>>>>>>>/// conjuction with finds.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
78032>>>>>>>>>>>/// @Param FileName                     Name of the file
78032>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Open Customer
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// For i from 0 to 1000
78032>>>>>>>>>>>///     Move i to Transactions.ID
78032>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78032>>>>>>>>>>>/// Loop
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
78032>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
78032>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
78032>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
78032>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
78032>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
78032>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
78032>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
78032>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
78032>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
78032>>>>>>>>>>>/// atomicity.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
78032>>>>>>>>>>>/// @Param FileName                     Name of the file
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Open Customer
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// For i from 0 to 1000
78032>>>>>>>>>>>///     Move i to Transactions.ID
78032>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78032>>>>>>>>>>>/// Loop
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
78032>>>>>>>>>>>/// @Description This command indicates the end of the extended record
78032>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78032>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
78032>>>>>>>>>>>/// @Param FileName                     Name of the file
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Open Customer
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// For i from 0 to 1000
78032>>>>>>>>>>>///     Move i to Transactions.ID
78032>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78032>>>>>>>>>>>/// Loop
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
78032>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Internal
78032>>>>>>>>>>>/// @Drivers     SQLFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78032>>>>>>>>>>>/// @See
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
78032>>>>>>>>>>>/// @Description This command enables driver level tracing to the
78032>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
78032>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
78032>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
78032>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
78032>>>>>>>>>>>/// This command can also set the trace to three different levels,
78032>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
78032>>>>>>>>>>>/// trace files can become very large so it is good practice to only
78032>>>>>>>>>>>/// turn them on when specifically needed.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
78032>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
78032>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
78032>>>>>>>>>>>/// @Description This command disables the current trace taking
78032>>>>>>>>>>>/// place on a driver.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78032>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
78032>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
78032>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
78032>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
78032>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
78032>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
78032>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
78032>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
78032>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
78032>>>>>>>>>>>/// @Param FileNumber           Number of the file
78032>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
78032>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
78032>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
78032>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78032>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
78032>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
78032>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
78032>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
78032>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
78032>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
78032>>>>>>>>>>>/// copying all the data into the new table with one command. The
78032>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
78032>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
78032>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
78032>>>>>>>>>>>/// options to use when creating the table.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
78032>>>>>>>>>>>/// @Param FileNumber           Number of the file
78032>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
78032>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
78032>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
78032>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78032>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
78032>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
78032>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
78032>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
78032>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
78032>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
78032>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
78032>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
78032>>>>>>>>>>>/// that can be passed to this command.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
78032>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
78032>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
78032>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
78032>>>>>>>>>>>/// @Description This command returns the file casing standard used
78032>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
78032>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
78032>>>>>>>>>>>/// returned integers.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
78032>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
78032>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
78032>>>>>>>>>>>/// @Description This command sets the default table space to use when
78032>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
78032>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
78032>>>>>>>>>>>/// and indexes.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
78032>>>>>>>>>>>/// @Param variable                     Name of the default table space
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
78032>>>>>>>>>>>/// @Description This command returns the default table space name for
78032>>>>>>>>>>>/// the current database.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>/// @Description This command sets the default table space for indexes
78032>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
78032>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
78032>>>>>>>>>>>/// i.e. tables and indexes.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>/// @Description This command returns the default table space name for
78032>>>>>>>>>>>/// indexes in the current database.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
78032>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
78032>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
78032>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
78032>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
78032>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
78032>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
78032>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78032>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// ENABLE_SCRIPTING
78032>>>>>>>>>>>///     //Table restructuring would go here
78032>>>>>>>>>>>/// DISABLE_SCRIPTING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78032>>>>>>>>>>>/// Showln sChunk
78032>>>>>>>>>>>
78032>>>>>>>>>>>//=============================================================================
78032>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
78032>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
78032>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Assumptions
78032>>>>>>>>>>>/// @Status      Public
78032>>>>>>>>>>>/// @Drivers     All
78032>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
78032>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// @Example
78032>>>>>>>>>>>/// ENABLE_SCRIPTING
78032>>>>>>>>>>>///     //Table restructuring would go here
78032>>>>>>>>>>>/// DISABLE_SCRIPTING
78032>>>>>>>>>>>///
78032>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78032>>>>>>>>>>>/// Showln sChunk
78032>>>>>>>>>>>
78032>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
78034>>>>>>>>>>>    Integer iChuck_Size
78034>>>>>>>>>>>    String sChunk
78034>>>>>>>>>>>
78034>>>>>>>>>>>    //Get current Chuck size and pre size string
78034>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
78039>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
78040>>>>>>>>>>>
78040>>>>>>>>>>>    //Get data
78040>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
78045>>>>>>>>>>>
78045>>>>>>>>>>>    // Replace insert a CR before any LF character
78045>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
78046>>>>>>>>>>>
78046>>>>>>>>>>>    Function_Return sChunk
78047>>>>>>>>>>>End_Function
78048>>>>>>>>>>>
78048>>>>>>>>>>>
78048>>>>>>>>>>>//=============================================================================
78048>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
78048>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
78048>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
78048>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
78048>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Assumptions
78048>>>>>>>>>>>/// @Status      Public
78048>>>>>>>>>>>/// @Drivers     All
78048>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78048>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
78048>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
78048>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
78048>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Example
78048>>>>>>>>>>>/// ENABLE_SCRIPTING
78048>>>>>>>>>>>///     //Table restructuring would go here
78048>>>>>>>>>>>/// DISABLE_SCRIPTING
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78048>>>>>>>>>>>/// Showln sChunk
78048>>>>>>>>>>>
78048>>>>>>>>>>>//=============================================================================
78048>>>>>>>>>>>/// @Name        GET_INT_CHUNK
78048>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
78048>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
78048>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
78048>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Assumptions
78048>>>>>>>>>>>/// @Status      Public
78048>>>>>>>>>>>/// @Drivers     All
78048>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78048>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
78048>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
78048>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
78048>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Example
78048>>>>>>>>>>>/// ENABLE_SCRIPTING
78048>>>>>>>>>>>///     //Table restructuring would go here
78048>>>>>>>>>>>/// DISABLE_SCRIPTING
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
78048>>>>>>>>>>>/// Showln sChunk
78048>>>>>>>>>>>
78048>>>>>>>>>>>//=============================================================================
78048>>>>>>>>>>>/// @Name        REPORT_STMT
78048>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
78048>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
78048>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
78048>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Assumptions
78048>>>>>>>>>>>/// @Status      Public
78048>>>>>>>>>>>/// @Drivers     n/a
78048>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78048>>>>>>>>>>>/// @See
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Example
78048>>>>>>>>>>>/// /Header
78048>>>>>>>>>>>/// __/__/____                                                        Page ___.
78048>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// ID   NAME
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// /Body
78048>>>>>>>>>>>/// ____ _________________________
78048>>>>>>>>>>>/// /Total
78048>>>>>>>>>>>/// Records printed = _______.
78048>>>>>>>>>>>/// /*
78048>>>>>>>>>>>///
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// OPEN SALESP
78048>>>>>>>>>>>/// direct_output "con:"
78048>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
78048>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
78048>>>>>>>>>>>/// sql_prepare_stmt of salesp
78048>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
78048>>>>>>>>>>>/// sql_execute_stmt of salesp
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// Report_stmt SALESP By Index.1
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// Section Header
78048>>>>>>>>>>>///     Sysdate Header.1
78048>>>>>>>>>>>///     Move PageCount to Header.2
78048>>>>>>>>>>>///     output header
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// Section Body
78048>>>>>>>>>>>///     Print Salesp.id   to Body.1
78048>>>>>>>>>>>///     Print Salesp.name to Body.2
78048>>>>>>>>>>>///     output body
78048>>>>>>>>>>>/// Section Total
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// Return
78048>>>>>>>>>>>/// ReportEnd
78048>>>>>>>>>>>
78048>>>>>>>>>>>//=============================================================================
78048>>>>>>>>>>>/// @Name        GET_SERVER_CFG
78048>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
78048>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
78048>>>>>>>>>>>/// explanation of each attribute.
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
78048>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
78048>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
78048>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
78048>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
78048>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
78048>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Assumptions
78048>>>>>>>>>>>/// @Status      Internal
78048>>>>>>>>>>>/// @Drivers     All
78048>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78048>>>>>>>>>>>/// @See
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
78048>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
78048>>>>>>>>>>>/// @Param server                       Name of the server being checked
78048>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78048>>>>>>>>>>>///
78048>>>>>>>>>>>/// @Example
78048>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
78048>>>>>>>>>>>
78048>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
78050>>>>>>>>>>>    String sReturnValue
78050>>>>>>>>>>>
78050>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
78051>>>>>>>>>>>
78051>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
78056>>>>>>>>>>>
78056>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
78056>>>>>>>>>>>    //else we need to return MertechInc_iRet
78056>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
78059>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
78061>>>>>>>>>>>End_Function
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
78062>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Internal
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
78062>>>>>>>>>>>/// @See
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
78062>>>>>>>>>>>/// @Param serverName    Server Name
78062>>>>>>>>>>>/// @Param databaseName  Database Name
78062>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
78062>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Internal
78062>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
78062>>>>>>>>>>>/// @See
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
78062>>>>>>>>>>>/// @Param Server           Server name to get encoding of
78062>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
78062>>>>>>>>>>>/// @Param Var              Variable to hold returned value
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
78062>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Internal
78062>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
78062>>>>>>>>>>>/// @See
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
78062>>>>>>>>>>>/// @Param Server           Server name to get encoding of
78062>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
78062>>>>>>>>>>>/// @Param Value            Value to set
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
78062>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
78062>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     DB2Flex
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
78062>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
78062>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
78062>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_RESULTS
78062>>>>>>>>>>>/// @Description Returns the initial result set.
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     DB2Flex
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_RESULTS
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
78062>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     DB2Flex
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
78062>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
78062>>>>>>>>>>>/// logged into the server.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
78062>>>>>>>>>>>/// @Param server               The name of the server the user is in
78062>>>>>>>>>>>/// @Param variable             Variable to hold the username
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
78062>>>>>>>>>>>/// @Description This command is used to get the password associated with
78062>>>>>>>>>>>/// the user currently logged into the server.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
78062>>>>>>>>>>>/// @Param server               The name of the server the user is in
78062>>>>>>>>>>>/// @Param variable             Variable to hold the password
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
78062>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
78062>>>>>>>>>>>/// @Param DB Name     Name of the database being created
78062>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
78062>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
78062>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
78062>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
78062>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
78062>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
78062>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
78062>>>>>>>>>>>///
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
78062>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
78062>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
78062>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
78062>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
78062>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
78062>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
78062>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
78062>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
78062>>>>>>>>>>>/// String  sName
78062>>>>>>>>>>>/// Number  nOrderTotal
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
78062>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
78062>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
78062>>>>>>>>>>>/// SQL_PREPARE_STMT
78062>>>>>>>>>>>/// SQL_EXECUTE_STMT
78062>>>>>>>>>>>/// Repeat
78062>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
78062>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
78062>>>>>>>>>>>///     If (Found) Begin
78062>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
78062>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
78062>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
78062>>>>>>>>>>>///        SQL_PREPARE_STMT
78062>>>>>>>>>>>///        SQL_EXECUTE_STMT
78062>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
78062>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
78062>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
78062>>>>>>>>>>>///        End
78062>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
78062>>>>>>>>>>>///
78062>>>>>>>>>>>///        Indicate Found True
78062>>>>>>>>>>>///     End
78062>>>>>>>>>>>/// Until (Not(Found))
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
78062>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
78062>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
78062>>>>>>>>>>>/// once the statements associated with them are complete.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable                     Cursor handle to close
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78062>>>>>>>>>>>/// SQL_PREPARE_STMT
78062>>>>>>>>>>>/// SQL_EXECUTE_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
78062>>>>>>>>>>>/// SQL_PREPARE_STMT
78062>>>>>>>>>>>/// SQL_EXECUTE_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// Repeat
78062>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
78062>>>>>>>>>>>///     If (Found) Begin
78062>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
78062>>>>>>>>>>>///     End
78062>>>>>>>>>>>///
78062>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
78062>>>>>>>>>>>///     If (Found) Begin
78062>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
78062>>>>>>>>>>>///     End
78062>>>>>>>>>>>/// Until (FindErr)
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
78062>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
78062>>>>>>>>>>>/// but once it has been created, this command can easily switch between
78062>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
78062>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
78062>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
78062>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable                     Cursor handle to use
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78062>>>>>>>>>>>/// SQL_PREPARE_STMT
78062>>>>>>>>>>>/// SQL_EXECUTE_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
78062>>>>>>>>>>>/// SQL_PREPARE_STMT
78062>>>>>>>>>>>/// SQL_EXECUTE_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// Repeat
78062>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
78062>>>>>>>>>>>///     If (Found) Begin
78062>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
78062>>>>>>>>>>>///     End
78062>>>>>>>>>>>///
78062>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
78062>>>>>>>>>>>///     If (Found) Begin
78062>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
78062>>>>>>>>>>>///     End
78062>>>>>>>>>>>/// Until (FindErr)
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
78062>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>/// @Description This command returns the current active cursor being
78062>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
78062>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Deprecated
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
78062>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Deprecated
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78062>>>>>>>>>>>/// @See
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
78062>>>>>>>>>>>/// @Param server                       Name of the server (optional)
78062>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
78062>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
78062>>>>>>>>>>>/// @Status      Deprecated
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
78062>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
78062>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
78062>>>>>>>>>>>/// @Status      Deprecated
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
78062>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
78062>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
78062>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
78062>>>>>>>>>>>/// variable.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
78062>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
78062>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
78062>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
78062>>>>>>>>>>>/// variable.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
78062>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
78062>>>>>>>>>>>/// @Description This command is used to find out how long until a
78062>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
78062>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
78062>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
78062>>>>>>>>>>>/// is the number of days until the license will expire.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
78062>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
78062>>>>>>>>>>>/// Showln iExpire
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
78062>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
78062>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
78062>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
78062>>>>>>>>>>>/// any open calls, this command should be called before either of those.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Public
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
78062>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Example
78062>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
78062>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
78062>>>>>>>>>>>
78062>>>>>>>>>>>//=============================================================================
78062>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
78062>>>>>>>>>>>/// @Description This command will return the current path of the license
78062>>>>>>>>>>>/// associated with the driver.
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Assumptions
78062>>>>>>>>>>>/// @Status      Internal
78062>>>>>>>>>>>/// @Drivers     All
78062>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78062>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
78062>>>>>>>>>>>///
78062>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
78062>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
78062>>>>>>>>>>>
78062>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
78064>>>>>>>>>>>    String sReturnValue
78064>>>>>>>>>>>
78064>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78090>>>>>>>>>>>>
78090>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
78092>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
78093>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
78098>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
78101>>>>>>>>>>>    End
78101>>>>>>>>>>>>
78101>>>>>>>>>>>
78101>>>>>>>>>>>    Function_Return sReturnValue
78102>>>>>>>>>>>End_Function
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
78103>>>>>>>>>>>/// @Description This command is used to dynamically change the port
78103>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
78103>>>>>>>>>>>/// the port is used for the current session only.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions The port is valid and available
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78103>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
78103>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
78103>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Example
78103>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
78103>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
78103>>>>>>>>>>>/// to the server.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78103>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
78103>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Example
78103>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
78103>>>>>>>>>>>/// @Description This command returns the serial number associated with
78103>>>>>>>>>>>/// the current driver's license.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     All
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78103>>>>>>>>>>>/// @See
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
78103>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Example
78103>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
78103>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
78103>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     MySQLFlex
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78103>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
78103>>>>>>>>>>>/// @Param variable                     Full name of the socket
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
78103>>>>>>>>>>>/// @Description This command returns the name of the socket used to
78103>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     MySQLFlex
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78103>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
78103>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
78103>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
78103>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
78103>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
78103>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
78103>>>>>>>>>>>/// full control over the database.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     OraFlex
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78103>>>>>>>>>>>/// @See
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Example
78103>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
78103>>>>>>>>>>>
78103>>>>>>>>>>>//=============================================================================
78103>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
78103>>>>>>>>>>>/// @Description This command is used to properly escape strings before
78103>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
78103>>>>>>>>>>>/// important when you do not have full control of the strings being passed
78103>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
78103>>>>>>>>>>>/// quoted.
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Assumptions
78103>>>>>>>>>>>/// @Status      Public
78103>>>>>>>>>>>/// @Drivers     All
78103>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78103>>>>>>>>>>>/// @See
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
78103>>>>>>>>>>>/// @Param string               The string to be escaped.
78103>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
78103>>>>>>>>>>>///
78103>>>>>>>>>>>/// @Example
78103>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
78103>>>>>>>>>>>
78103>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
78105>>>>>>>>>>>    String sReturnData
78105>>>>>>>>>>>
78105>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78131>>>>>>>>>>>>
78131>>>>>>>>>>>
78131>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
78133>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
78134>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
78139>>>>>>>>>>>    End
78139>>>>>>>>>>>>
78139>>>>>>>>>>>
78139>>>>>>>>>>>    Function_Return sReturnData
78140>>>>>>>>>>>End_Function
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
78141>>>>>>>>>>>/// @Description
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions
78141>>>>>>>>>>>/// @Status      Internal
78141>>>>>>>>>>>/// @Drivers     OraFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
78141>>>>>>>>>>>/// @See
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
78141>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
78141>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
78141>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
78141>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
78141>>>>>>>>>>>/// the auto incremented column is being manually filled.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions
78141>>>>>>>>>>>/// @Status      Public
78141>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78141>>>>>>>>>>>/// @See
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
78141>>>>>>>>>>>/// @Param FileNumber                   The file number
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_APPEND
78141>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
78141>>>>>>>>>>>/// column in the database. When called, the data corresponding field
78141>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
78141>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
78141>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
78141>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
78141>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear Customer
78141>>>>>>>>>>>/// Find Gt Customer By Index.1
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
78141>>>>>>>>>>>/// Lock
78141>>>>>>>>>>>///    Find Eq Customer by Recnum
78141>>>>>>>>>>>///
78141>>>>>>>>>>>///    Read_Block Customer.Comments 16384
78141>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
78141>>>>>>>>>>>///    Repeat
78141>>>>>>>>>>>///        Read_Block Customer.Comments 16384
78141>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
78141>>>>>>>>>>>///    Until (SeqEOF)
78141>>>>>>>>>>>/// Unlock
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Close_Input
78141>>>>>>>>>>>/// Find Eq Customer By Recnum
78141>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
78141>>>>>>>>>>>/// Showln 'Length: ' iLength
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_LENGTH
78141>>>>>>>>>>>/// @Description This command returns the length of the data in the
78141>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
78141>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
78141>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
78141>>>>>>>>>>>/// @Param variable                     Variable to hold the length
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear Customer
78141>>>>>>>>>>>/// Find Gt Customer By Index.1
78141>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
78141>>>>>>>>>>>/// Showln 'Length: ' iLength
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_READ
78141>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
78141>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
78141>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
78141>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
78141>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
78141>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
78141>>>>>>>>>>>/// All these things considered, when reading data larger than the field
78141>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
78141>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
78141>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
78141>>>>>>>>>>>/// must be done after a successful find on the record.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
78141>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
78141>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
78141>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
78141>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Clear customer
78141>>>>>>>>>>>/// Find Gt customer by Index.1
78141>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// While (liLength > 0)
78141>>>>>>>>>>>///     Write customer.comments
78141>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
78141>>>>>>>>>>>/// Loop
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Close_Output
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_WRITE
78141>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
78141>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
78141>>>>>>>>>>>/// command will take the current value of the respective field in
78141>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
78141>>>>>>>>>>>/// currently in that field will be overridden by the data from the
78141>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
78141>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
78141>>>>>>>>>>>/// are needed to save the changes.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear Customer
78141>>>>>>>>>>>/// Find Gt Customer By Index.1
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
78141>>>>>>>>>>>/// Lock
78141>>>>>>>>>>>///    Find Eq Customer by Recnum
78141>>>>>>>>>>>///
78141>>>>>>>>>>>///    Read_Block Customer.Comments 16384
78141>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
78141>>>>>>>>>>>///    Repeat
78141>>>>>>>>>>>///        Read_Block Customer.Comments 16384
78141>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
78141>>>>>>>>>>>///    Until (SeqEOF)
78141>>>>>>>>>>>/// Unlock
78141>>>>>>>>>>>/// Close_Input
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Find Eq Customer By Recnum
78141>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
78141>>>>>>>>>>>/// Showln 'Length: ' iLength
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
78141>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
78141>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
78141>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
78141>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
78141>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
78141>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
78141>>>>>>>>>>>/// For other servers, the file must be a local file available to the
78141>>>>>>>>>>>/// application that is calling the command. Note that this command must
78141>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
78141>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
78141>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
78141>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear Customer
78141>>>>>>>>>>>/// Find Gt Customer By Index.1
78141>>>>>>>>>>>/// Lock
78141>>>>>>>>>>>///    Find Eq Customer by Recnum
78141>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
78141>>>>>>>>>>>///    Saverecord Customer
78141>>>>>>>>>>>///    // Directory name is case sensitive.
78141>>>>>>>>>>>///    // Make sure the name case matches
78141>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
78141>>>>>>>>>>>/// Unlock
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_ERASE
78141>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
78141>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
78141>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
78141>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
78141>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
78141>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
78141>>>>>>>>>>>/// so no extra commands are needed to save the changes.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
78141>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
78141>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
78141>>>>>>>>>>>/// @Param offset                       Starting position for erase
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear customer
78141>>>>>>>>>>>/// Find Gt customer by Recnum
78141>>>>>>>>>>>/// Lock
78141>>>>>>>>>>>/// Find Eq customer by Recnum
78141>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
78141>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
78141>>>>>>>>>>>/// Unlock
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        LOB_TRUNCATE
78141>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
78141>>>>>>>>>>>/// specified length. By passing the table name and column number, the
78141>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
78141>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
78141>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
78141>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
78141>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     All
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file
78141>>>>>>>>>>>/// @Param FieldNumber          The field number
78141>>>>>>>>>>>/// @Param length                       New length to truncate to
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// Clear Customer
78141>>>>>>>>>>>/// Find Gt Customer By Index.1
78141>>>>>>>>>>>/// Lock
78141>>>>>>>>>>>///    Find Eq Customer by Recnum
78141>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
78141>>>>>>>>>>>///    Saverecord Customer
78141>>>>>>>>>>>/// Unlock
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
78141>>>>>>>>>>>/// @Description This command currently serves no function.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     MySQLFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78141>>>>>>>>>>>/// @See
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
78141>>>>>>>>>>>/// @Param FileName                     Name of the file
78141>>>>>>>>>>>
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
78141>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
78141>>>>>>>>>>>/// will kick off a user after inactivity.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     MySQL
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
78141>>>>>>>>>>>/// @Param ServerName  Server Name.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
78141>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
78141>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
78141>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
78141>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
78141>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
78141>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
78141>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
78141>>>>>>>>>>>/// is set to true.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     MySQLFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
78141>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78141>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
78141>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
78141>>>>>>>>>>>/// Showln sStatus
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
78141>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
78141>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
78141>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
78141>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
78141>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
78141>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
78141>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
78141>>>>>>>>>>>/// values.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Status      Deprecated
78141>>>>>>>>>>>/// @Drivers     MySQLFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
78141>>>>>>>>>>>/// @Param function                     Full name of the function
78141>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78141>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
78141>>>>>>>>>>>/// Showln sStatus
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
78141>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions
78141>>>>>>>>>>>/// @Status      Internal
78141>>>>>>>>>>>/// @Drivers     MySQLFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
78141>>>>>>>>>>>/// @See
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
78141>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
78141>>>>>>>>>>>
78141>>>>>>>>>>>//=============================================================================
78141>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
78141>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
78141>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
78141>>>>>>>>>>>/// all the available server names can be easily retrieved.
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
78141>>>>>>>>>>>/// @Status      Public
78141>>>>>>>>>>>/// @Drivers     SQLFlex
78141>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78141>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
78141>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// @Example
78141>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
78141>>>>>>>>>>>///
78141>>>>>>>>>>>/// While (i <= iServers)
78141>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
78141>>>>>>>>>>>///     Showln sServer
78141>>>>>>>>>>>///     Increment i
78141>>>>>>>>>>>/// Loop
78141>>>>>>>>>>>
78141>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
78143>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
78148>>>>>>>>>>>
78148>>>>>>>>>>>    Function_Return MertechInc_iRet
78149>>>>>>>>>>>End_Function
78150>>>>>>>>>>>
78150>>>>>>>>>>>
78150>>>>>>>>>>>//=============================================================================
78150>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
78150>>>>>>>>>>>/// @Description This command returns the name of the server based on the
78150>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
78150>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
78150>>>>>>>>>>>/// number.
78150>>>>>>>>>>>///
78150>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
78150>>>>>>>>>>>/// @Status      Public
78150>>>>>>>>>>>/// @Drivers     SQLFlex
78150>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78150>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
78150>>>>>>>>>>>///
78150>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
78150>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
78150>>>>>>>>>>>/// @Param variable             Variable to hold the server name
78150>>>>>>>>>>>///
78150>>>>>>>>>>>/// @Example
78150>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
78150>>>>>>>>>>>///
78150>>>>>>>>>>>/// While (i <= iServers)
78150>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
78150>>>>>>>>>>>///     Showln sServer
78150>>>>>>>>>>>///     Increment i
78150>>>>>>>>>>>/// Loop
78150>>>>>>>>>>>
78150>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
78152>>>>>>>>>>>    String sName
78152>>>>>>>>>>>
78152>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
78153>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
78158>>>>>>>>>>>
78158>>>>>>>>>>>    Function_Return sName
78159>>>>>>>>>>>End_Function
78160>>>>>>>>>>>
78160>>>>>>>>>>>
78160>>>>>>>>>>>//=============================================================================
78160>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
78160>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
78160>>>>>>>>>>>/// @Status      Deprecated
78160>>>>>>>>>>>/// @Drivers     All
78160>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
78160>>>>>>>>>>>///
78160>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
78160>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
78160>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
78160>>>>>>>>>>>///
78160>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
78160>>>>>>>>>>>
78160>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
78162>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78188>>>>>>>>>>>>
78188>>>>>>>>>>>
78188>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
78193>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
78196>>>>>>>>>>>End_Procedure
78197>>>>>>>>>>>
78197>>>>>>>>>>>//IGS - commented out by a.n. Other
78197>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
78197>>>>>>>>>>>
78197>>>>>>>>>>>//=============================================================================
78197>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
78197>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
78197>>>>>>>>>>>/// @Status      Deprecated
78197>>>>>>>>>>>/// @Drivers     All
78197>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
78197>>>>>>>>>>>///
78197>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
78197>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
78197>>>>>>>>>>>/// @Param State       Variable to hold returned value
78197>>>>>>>>>>>
78197>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
78199>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78225>>>>>>>>>>>>
78225>>>>>>>>>>>
78225>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
78230>>>>>>>>>>>
78230>>>>>>>>>>>    Function_Return MertechInc_iRet
78231>>>>>>>>>>>End_Function
78232>>>>>>>>>>>
78232>>>>>>>>>>>
78232>>>>>>>>>>>//=============================================================================
78232>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
78232>>>>>>>>>>>/// @Description This command controls the date format of data returned
78232>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
78232>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
78232>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
78232>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
78232>>>>>>>>>>>/// be in the right form, they need to be string variables.
78232>>>>>>>>>>>///
78232>>>>>>>>>>>/// @Assumptions
78232>>>>>>>>>>>/// @Status      Public
78232>>>>>>>>>>>/// @Drivers     SQLFlex
78232>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78232>>>>>>>>>>>/// @See
78232>>>>>>>>>>>///
78232>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
78232>>>>>>>>>>>///
78232>>>>>>>>>>>/// @Example
78232>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
78232>>>>>>>>>>>
78232>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
78234>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78260>>>>>>>>>>>>
78260>>>>>>>>>>>
78260>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
78262>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
78267>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
78270>>>>>>>>>>>    End
78270>>>>>>>>>>>>
78270>>>>>>>>>>>End_Procedure
78271>>>>>>>>>>>
78271>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
78273>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78299>>>>>>>>>>>>
78299>>>>>>>>>>>
78299>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
78301>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
78306>>>>>>>>>>>    End
78306>>>>>>>>>>>>
78306>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
78308>>>>>>>>>>>
78308>>>>>>>>>>>    function_return MertechInc_iRet
78309>>>>>>>>>>>End_Function
78310>>>>>>>>>>>
78310>>>>>>>>>>>
78310>>>>>>>>>>>//=============================================================================
78310>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
78310>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
78310>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
78310>>>>>>>>>>>/// often be stored as null in the server database, this command allows
78310>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
78310>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
78310>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
78310>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
78310>>>>>>>>>>>/// command effects all data types.
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
78310>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
78310>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// DF_BINARY -                                 0X0
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// @Assumptions
78310>>>>>>>>>>>/// @Status      Public
78310>>>>>>>>>>>/// @Drivers     All
78310>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78310>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
78310>>>>>>>>>>>///
78310>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
78310>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
78310>>>>>>>>>>>///
78310>>>>>>>>>>>
78310>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
78312>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78338>>>>>>>>>>>>
78338>>>>>>>>>>>
78338>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
78340>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
78345>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
78348>>>>>>>>>>>    End
78348>>>>>>>>>>>>
78348>>>>>>>>>>>End_Procedure
78349>>>>>>>>>>>
78349>>>>>>>>>>>
78349>>>>>>>>>>>
78349>>>>>>>>>>>
78349>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
78351>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
78377>>>>>>>>>>>>
78377>>>>>>>>>>>
78377>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
78379>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
78384>>>>>>>>>>>    End
78384>>>>>>>>>>>>
78384>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
78386>>>>>>>>>>>
78386>>>>>>>>>>>    Function_Return MertechInc_iRet
78387>>>>>>>>>>>End_Function
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
78388>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
78388>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
78388>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
78388>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
78388>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
78388>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
78388>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
78388>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
78388>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
78388>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// DF_BINARY -                                 0X0
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
78388>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
78388>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
78388>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
78388>>>>>>>>>>>/// the specified data type.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
78388>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
78388>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
78388>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
78388>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
78388>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
78388>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
78388>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
78388>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
78388>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Deprecated
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
78388>>>>>>>>>>>/// @Param FileNumber                   The number of the file
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
78388>>>>>>>>>>>/// @Description This command ends the scripting started by
78388>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
78388>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Deprecated
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
78388>>>>>>>>>>>/// @Param FileNumber                   The number of the file
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
78388>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
78388>>>>>>>>>>>/// the passed database is already attached, no error is generated.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
78388>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
78388>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
78388>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
78388>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
78388>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
78388>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
78388>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
78388>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
78388>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
78388>>>>>>>>>>>/// the currently selected database.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
78388>>>>>>>>>>>/// @See
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
78388>>>>>>>>>>>/// @Param database                     Name of the database
78388>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
78388>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
78388>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
78388>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
78388>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
78388>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
78388>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
78388>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
78388>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
78388>>>>>>>>>>>/// driver).
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
78388>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
78388>>>>>>>>>>>/// normally has open connections to the database.  If you test your
78388>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
78388>>>>>>>>>>>/// other application or tools that access this database are closed) you
78388>>>>>>>>>>>/// can successfully detach the database.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
78388>>>>>>>>>>>/// @Param database                     Name of the database
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
78388>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
78388>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
78388>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
78388>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
78388>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
78388>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
78388>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
78388>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
78388>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
78388>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
78388>>>>>>>>>>>/// called.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// The default value for this command is -1
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status              Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
78388>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
78388>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
78388>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
78388>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
78388>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
78388>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
78388>>>>>>>>>>>/// returns a dynamic count whenever it is called.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// By default the value of this is -1
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status              Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
78388>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
78388>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
78388>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
78388>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
78388>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
78388>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
78388>>>>>>>>>>>/// to -1.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     All
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78388>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SET_CONNECTION_OPTION
78388>>>>>>>>>>>/// @Description This command sets options that are used for the next login call.
78388>>>>>>>>>>>/// Because of this, it should be used after calling load_driver but before
78388>>>>>>>>>>>/// calling Login in most cases. Only options that are not used internally by
78388>>>>>>>>>>>/// the driver can be set using this command. Connection options that CANNOT be
78388>>>>>>>>>>>/// set: Database, Server, FailoverPartner, MarsConn, uid, pwd, Trusted_Connection,
78388>>>>>>>>>>>/// wsid, app, AutoTranslate, Timeout.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
78388>>>>>>>>>>>/// @See         Get_Connection_Option, Clear_Connection_Option
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SET_CONNECTION_OPTION {option} to {value}
78388>>>>>>>>>>>/// @Param option         The connection option to set
78388>>>>>>>>>>>/// @Param value          The value to set the connection option to.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// LOAD_DRIVER "SQL_DRV"
78388>>>>>>>>>>>/// SET_CONNECTION_OPTION "ApplicationIntent" to "ReadOnly"
78388>>>>>>>>>>>/// LOGIN "localhost/sqlexpress01" "" "" "sql_drv"
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        GET_CONNECTION_OPTION
78388>>>>>>>>>>>/// @Description This command gets the value of a connection option that was set
78388>>>>>>>>>>>/// using SET_CONNECTION_OPTION. Only options that are not used internally by
78388>>>>>>>>>>>/// the driver can be retrieved using this command. Connection options that CANNOT be
78388>>>>>>>>>>>/// retrieved: Database, Server, FailoverPartner, MarsConn, uid, pwd,
78388>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
78388>>>>>>>>>>>/// @See         Set_Connection_Option, Clear_Connection_Option
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax GET_CONNECTION_OPTION {option} to {variable}
78388>>>>>>>>>>>/// @Param option         The connection option to get
78388>>>>>>>>>>>/// @Param value          A variable to hold the retrieved value of the connection option.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// GET_CONNECTION_OPTION "ApplicationIntent" to sVal
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        CLEAR_CONNECTION_OPTION
78388>>>>>>>>>>>/// @Description This command will clear any or all connections options that
78388>>>>>>>>>>>/// were set using SET_CONNECTION_OPTION. Passing the keyword ALL will remove
78388>>>>>>>>>>>/// all custom set connection options while passing a string value will clear
78388>>>>>>>>>>>/// just that option passed for the next login call. Connection options that
78388>>>>>>>>>>>/// CANNOT be cleared: Database, Server, FailoverPartner, MarsConn, uid, pwd,
78388>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
78388>>>>>>>>>>>/// @See         Set_Connection_Option, Get_Connection_Option
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax CLEAR_CONNECTION_OPTION ALL | {option}
78388>>>>>>>>>>>/// @Param option         The connection option to clear
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// CLEAR_CONNECTION_OPTION "ApplicationIntent"
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>///
78388>>>>>>>>>>>// Private:
78388>>>>>>>>>>>// Get the filenumber of a file.field parameter
78388>>>>>>>>>>>//
78388>>>>>>>>>>>
78388>>>>>>>>>>>///
78388>>>>>>>>>>>// Private:
78388>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
78388>>>>>>>>>>>//
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>//
78388>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
78388>>>>>>>>>>>//
78388>>>>>>>>>>>
78388>>>>>>>>>>>TYPE tMertechLOB_Args
78388>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
78388>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
78388>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
78388>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
78388>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
78388>>>>>>>>>>>END_TYPE
78388>>>>>>>>>>>
78388>>>>>>>>>>>//=============================================================================
78388>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK_EX
78388>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
78388>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
78388>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
78388>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
78388>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
78388>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
78388>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Assumptions
78388>>>>>>>>>>>/// @Status      Public
78388>>>>>>>>>>>/// @Drivers     SQLFlex
78388>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 by Oliver Nelson
78388>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE SQL_GET_COLUMN_DATA_SIZE
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
78388>>>>>>>>>>>/// @Param column               Column number to get chunk from
78388>>>>>>>>>>>/// @Param offset               Offset to start at for the chunk
78388>>>>>>>>>>>/// @Param variable             Variable to hold the returned chunk
78388>>>>>>>>>>>/// @Param length               Variable to hold the size of the returned chunk
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// @Example
78388>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
78388>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
78388>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78388>>>>>>>>>>>/// SQL_PREPARE_STMT
78388>>>>>>>>>>>/// SQL_EXECUTE_STMT
78388>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
78388>>>>>>>>>>>/// If (Found) Begin
78388>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
78388>>>>>>>>>>>///
78388>>>>>>>>>>>///     Repeat
78388>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
78388>>>>>>>>>>>///         ADD iChunkSize to iProgress
78388>>>>>>>>>>>///         write sChunk
78388>>>>>>>>>>>///     until (iProgress >= iDataSize)
78388>>>>>>>>>>>///
78388>>>>>>>>>>>/// End
78388>>>>>>>>>>>
78388>>>>>>>>>>>
78388>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK_EX Global Integer iColumn Integer iOffset Returns String
78390>>>>>>>>>>>    Local String sLOB_Args
78390>>>>>>>>>>>    Local String sData
78390>>>>>>>>>>>    Local Integer iSize
78390>>>>>>>>>>>
78390>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iSize MertechInc_Blank 1 RESULT MertechInc_iRet
78395>>>>>>>>>>>
78395>>>>>>>>>>>    Move "" to sData
78396>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78397>>>>>>>>>>>    // First move the size of the structure to the Structure
78397>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
78398>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
78399>>>>>>>>>>>    Put iOffset                to sLOB_Args at tMertechLOB_Args.nOffset
78400>>>>>>>>>>>    Put iSize                  to sLOB_Args at tMertechLOB_Args.nSize
78401>>>>>>>>>>>
78401>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78406>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
78407>>>>>>>>>>>
78407>>>>>>>>>>>    If iSize GT 0 Begin
78409>>>>>>>>>>>        Move (Repeat(Character(0), iSize)) to sData
78410>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
78411>>>>>>>>>>>        Put iSize              to sLOB_Args at tMertechLOB_Args.nSize
78412>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
78413>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78418>>>>>>>>>>>        GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
78419>>>>>>>>>>>    End
78419>>>>>>>>>>>>
78419>>>>>>>>>>>    Else Begin
78420>>>>>>>>>>>        Move "" to sData
78421>>>>>>>>>>>    End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>    Function_Return sData
78422>>>>>>>>>>>End_Function // MertechInc_SQL_GET_DATA_CHUNK_EX
78423>>>>>>>>>>>
78423>>>>>>>>>>>//=============================================================================
78423>>>>>>>>>>>/// @Name        SQL_GET_COLUMN_DATA_SIZE
78423>>>>>>>>>>>/// @Description This command is used to get the size of the data in a column
78423>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
78423>>>>>>>>>>>/// the size of the data in the column will be put into the specified variable.
78423>>>>>>>>>>>/// The size returned will be the smaller of the actual size of the data or
78423>>>>>>>>>>>/// the SQL_SET_MAX_DATA_SIZE setting. So for instance, if the data stored in
78423>>>>>>>>>>>/// a column is 64MB, but the SQL_SET_MAX_DATA_SIZE is set to 16MB, then this
78423>>>>>>>>>>>/// command will return 16MB. Note that you may need to use Set_Argument_Size
78423>>>>>>>>>>>/// to allow for a large chunk size because the default maximum string size
78423>>>>>>>>>>>/// in most modern dataflex versions is only 64KB.
78423>>>>>>>>>>>///
78423>>>>>>>>>>>/// @Assumptions
78423>>>>>>>>>>>/// @Status      Public
78423>>>>>>>>>>>/// @Drivers     SQLFlex
78423>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 Oliver Nelson
78423>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK_EX SQL_SET_MAX_DATA_SIZE
78423>>>>>>>>>>>///
78423>>>>>>>>>>>/// @Syntax SQL_GET_COLUMN_DATA_SIZE COLUMN {column} to {variable}
78423>>>>>>>>>>>/// @Param column               Column number to get chunk from
78423>>>>>>>>>>>/// @Param variable             Variable to hold the returned data size
78423>>>>>>>>>>>///
78423>>>>>>>>>>>/// @Example
78423>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
78423>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
78423>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
78423>>>>>>>>>>>///
78423>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78423>>>>>>>>>>>/// SQL_PREPARE_STMT
78423>>>>>>>>>>>/// SQL_EXECUTE_STMT
78423>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
78423>>>>>>>>>>>/// If (Found) Begin
78423>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
78423>>>>>>>>>>>///
78423>>>>>>>>>>>///     Repeat
78423>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
78423>>>>>>>>>>>///         ADD iChunkSize to iProgress
78423>>>>>>>>>>>///         write sChunk
78423>>>>>>>>>>>///     until (iProgress >= iDataSize)
78423>>>>>>>>>>>///
78423>>>>>>>>>>>/// End
78423>>>>>>>>>>>
78423>>>>>>>>>>>
78423>>>>>>>>>>>Function MertechInc_SQL_GET_COLUMN_DATA_SIZE Global Integer iColumn Returns Integer
78425>>>>>>>>>>>    Local String sLOB_Args
78425>>>>>>>>>>>    Local String sData
78425>>>>>>>>>>>    Local Integer iSize
78425>>>>>>>>>>>
78425>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78426>>>>>>>>>>>    // First move the size of the structure to the Structure
78426>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
78427>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
78428>>>>>>>>>>>    Put 0                      to sLOB_Args at tMertechLOB_Args.nOffset
78429>>>>>>>>>>>    Put |CI$7FFFFFFF           to sLOB_Args at tMertechLOB_Args.nSize
78430>>>>>>>>>>>
78430>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78435>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
78436>>>>>>>>>>>
78436>>>>>>>>>>>    Function_Return iSize
78437>>>>>>>>>>>End_Function // MertechInc_SQL_GET_COLUMN_DATA_SIZE
78438>>>>>>>>>>>
78438>>>>>>>>>>>//=============================================================================
78438>>>>>>>>>>>/// @Name        SQL_SET_LOB
78438>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
78438>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
78438>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
78438>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
78438>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
78438>>>>>>>>>>>/// command.
78438>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
78438>>>>>>>>>>>/// perform the Save. This must be done separately.
78438>>>>>>>>>>>///
78438>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78438>>>>>>>>>>>/// @Status      Public
78438>>>>>>>>>>>/// @Drivers     All
78438>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78438>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
78438>>>>>>>>>>>///
78438>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
78438>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
78438>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
78438>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
78438>>>>>>>>>>>///
78438>>>>>>>>>>>/// @Example
78438>>>>>>>>>>>/// Set_Argument_Size 262144
78438>>>>>>>>>>>/// String sLine
78438>>>>>>>>>>>///
78438>>>>>>>>>>>/// Clear Customer
78438>>>>>>>>>>>///    Move iID to Customer.ID
78438>>>>>>>>>>>/// Find Eq Customer by Index.1
78438>>>>>>>>>>>/// If (Found) Begin
78438>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
78438>>>>>>>>>>>///    Reread Customer
78438>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
78438>>>>>>>>>>>///       Read_Block sLine 262144
78438>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
78438>>>>>>>>>>>///       While (not(SeqEof))
78438>>>>>>>>>>>///          Read_Block sLine 262144
78438>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
78438>>>>>>>>>>>///       Loop
78438>>>>>>>>>>>///    Saverecord Customer
78438>>>>>>>>>>>///    Unlock
78438>>>>>>>>>>>///    Close_Input
78438>>>>>>>>>>>/// End
78438>>>>>>>>>>>
78438>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB Global String sDriver Integer iFile Integer iField String sData
78440>>>>>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
78440>>>>>>>>>>>
78440>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78441>>>>>>>>>>>    // First move the size of the structure to the Structure
78441>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
78442>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
78443>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
78444>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
78445>>>>>>>>>>>
78445>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78450>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
78451>>>>>>>>>>>
78451>>>>>>>>>>>//=============================================================================
78451>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
78451>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
78451>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
78451>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
78451>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
78451>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
78451>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
78451>>>>>>>>>>>/// the save. This must be done separately.
78451>>>>>>>>>>>///
78451>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78451>>>>>>>>>>>/// @Status      Public
78451>>>>>>>>>>>/// @Drivers     All
78451>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78451>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
78451>>>>>>>>>>>///
78451>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
78451>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
78451>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
78451>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
78451>>>>>>>>>>>///
78451>>>>>>>>>>>/// @Example
78451>>>>>>>>>>>/// Set_Argument_Size 262144
78451>>>>>>>>>>>/// String sLine
78451>>>>>>>>>>>///
78451>>>>>>>>>>>/// Clear Customer
78451>>>>>>>>>>>///    Move iID to Customer.ID
78451>>>>>>>>>>>/// Find Eq Customer by Index.1
78451>>>>>>>>>>>/// If (Found) Begin
78451>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
78451>>>>>>>>>>>///    Reread Customer
78451>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
78451>>>>>>>>>>>///       Read_Block sLine 262144
78451>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
78451>>>>>>>>>>>///       While (not(SeqEof))
78451>>>>>>>>>>>///          Read_Block sLine 262144
78451>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
78451>>>>>>>>>>>///       Loop
78451>>>>>>>>>>>///    Saverecord Customer
78451>>>>>>>>>>>///    Unlock
78451>>>>>>>>>>>///    Close_Input
78451>>>>>>>>>>>/// End
78451>>>>>>>>>>>
78451>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK Global String sDriver Integer iFile Integer iField String sData
78453>>>>>>>>>>>    String sLOB_Args
78453>>>>>>>>>>>
78453>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78454>>>>>>>>>>>    // First move the size of the structure to the Structure
78454>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
78455>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
78456>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
78457>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
78458>>>>>>>>>>>
78458>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78463>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
78464>>>>>>>>>>>
78464>>>>>>>>>>>//=============================================================================
78464>>>>>>>>>>>/// @Name        SQL_GET_LOB
78464>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
78464>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
78464>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
78464>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
78464>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
78464>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
78464>>>>>>>>>>>/// field value within DataFlex variable size limits.
78464>>>>>>>>>>>///
78464>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78464>>>>>>>>>>>/// @Status      Public
78464>>>>>>>>>>>/// @Drivers     All
78464>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78464>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
78464>>>>>>>>>>>///
78464>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
78464>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
78464>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
78464>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
78464>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
78464>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
78464>>>>>>>>>>>///
78464>>>>>>>>>>>/// @Example
78464>>>>>>>>>>>/// Set_Argument_Size 262144
78464>>>>>>>>>>>/// String sResult
78464>>>>>>>>>>>///
78464>>>>>>>>>>>/// Move 262144 to iChunkSize
78464>>>>>>>>>>>/// Move 0      to iChunk
78464>>>>>>>>>>>///
78464>>>>>>>>>>>/// Clear Customer
78464>>>>>>>>>>>///    Move iID to Customer.ID
78464>>>>>>>>>>>/// Find Eq Customer by Index.1
78464>>>>>>>>>>>/// If (Found) Begin
78464>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
78464>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
78464>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
78464>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
78464>>>>>>>>>>>///       Write sResult
78464>>>>>>>>>>>///       Increment iChunk
78464>>>>>>>>>>>///    Loop
78464>>>>>>>>>>>///    Close_Output
78464>>>>>>>>>>>/// End
78464>>>>>>>>>>>
78464>>>>>>>>>>>
78464>>>>>>>>>>>Function MertechInc_SQL_GET_LOB Global String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
78466>>>>>>>>>>>    String sLOB_Args
78466>>>>>>>>>>>    String sData
78466>>>>>>>>>>>    DWord  nSize
78466>>>>>>>>>>>
78466>>>>>>>>>>>    Move "" To sData
78467>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78468>>>>>>>>>>>    // First move the size of the structure to the Structure
78468>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
78469>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
78470>>>>>>>>>>>
78470>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78475>>>>>>>>>>>
78475>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
78476>>>>>>>>>>>    If (nSize > 0) Begin
78478>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
78480>>>>>>>>>>>        move (Repeat(Character(0), nSize)) to sData
78481>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
78481>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
78482>>>>>>>>>>>      End
78482>>>>>>>>>>>>
78482>>>>>>>>>>>      Else Begin
78483>>>>>>>>>>>        move (Repeat(Character(0), iLength)) to sData
78484>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
78485>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
78486>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
78487>>>>>>>>>>>      End
78487>>>>>>>>>>>>
78487>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78492>>>>>>>>>>>    End
78492>>>>>>>>>>>>
78492>>>>>>>>>>>    Else Begin
78493>>>>>>>>>>>        Move "" to sData
78494>>>>>>>>>>>    End
78494>>>>>>>>>>>>
78494>>>>>>>>>>>    Function_Return sData
78495>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
78496>>>>>>>>>>>
78496>>>>>>>>>>>//=============================================================================
78496>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
78496>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
78496>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
78496>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
78496>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
78496>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78496>>>>>>>>>>>/// @Status      Public
78496>>>>>>>>>>>/// @Drivers     All
78496>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78496>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
78496>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
78496>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
78496>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
78496>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
78496>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Example
78496>>>>>>>>>>>/// Set_Argument_Size 262144
78496>>>>>>>>>>>/// String sResult
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// Move 262144 to iChunkSize
78496>>>>>>>>>>>/// Move 0      to iChunk
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// Clear Customer
78496>>>>>>>>>>>///    Move iID to Customer.ID
78496>>>>>>>>>>>/// Find Eq Customer by Index.1
78496>>>>>>>>>>>/// If (Found) Begin
78496>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
78496>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
78496>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
78496>>>>>>>>>>>///       // Do something with the LOB data
78496>>>>>>>>>>>///       Increment iChunk
78496>>>>>>>>>>>///    Loop
78496>>>>>>>>>>>/// End
78496>>>>>>>>>>>
78496>>>>>>>>>>>//=============================================================================
78496>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
78496>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
78496>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
78496>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78496>>>>>>>>>>>/// @Status      Public
78496>>>>>>>>>>>/// @Drivers     All
78496>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78496>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
78496>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
78496>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
78496>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// @Example
78496>>>>>>>>>>>/// Set_Argument_Size 262144
78496>>>>>>>>>>>/// String sResult
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// Move 16384 to iChunkSize
78496>>>>>>>>>>>/// Move 0     to iChunk
78496>>>>>>>>>>>///
78496>>>>>>>>>>>/// Clear Customer
78496>>>>>>>>>>>///    Move iID to Customer.ID
78496>>>>>>>>>>>/// Find Eq Customer by Index.1
78496>>>>>>>>>>>/// If (Found) Begin
78496>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
78496>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
78496>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
78496>>>>>>>>>>>///       // Do something with the LOB data
78496>>>>>>>>>>>///       Increment iChunk
78496>>>>>>>>>>>///    Loop
78496>>>>>>>>>>>/// End
78496>>>>>>>>>>>
78496>>>>>>>>>>>
78496>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH Global String sDriver Integer iFile Integer iField Returns Integer
78498>>>>>>>>>>>    String sLOB_Args
78498>>>>>>>>>>>    DWord  nSize
78498>>>>>>>>>>>
78498>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78499>>>>>>>>>>>    // First move the size of the structure to the Structure
78499>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
78500>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
78501>>>>>>>>>>>
78501>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78506>>>>>>>>>>>
78506>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
78507>>>>>>>>>>>    Function_Return nSize
78508>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
78509>>>>>>>>>>>
78509>>>>>>>>>>>//=============================================================================
78509>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
78509>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
78509>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
78509>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
78509>>>>>>>>>>>/// null is best.
78509>>>>>>>>>>>///
78509>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
78509>>>>>>>>>>>/// @Status      Public
78509>>>>>>>>>>>/// @Drivers     All
78509>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
78509>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
78509>>>>>>>>>>>///
78509>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
78509>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
78509>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
78509>>>>>>>>>>>///
78509>>>>>>>>>>>/// @Example
78509>>>>>>>>>>>////
78509>>>>>>>>>>>/// Clear Customer
78509>>>>>>>>>>>/// Move iID to Customer.ID
78509>>>>>>>>>>>/// Find Eq Customer by Index.1
78509>>>>>>>>>>>/// If (Found) Begin
78509>>>>>>>>>>>///    Reread Customer
78509>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
78509>>>>>>>>>>>///        Saverecord Customer
78509>>>>>>>>>>>///    Unlock
78509>>>>>>>>>>>/// End
78509>>>>>>>>>>>
78509>>>>>>>>>>>
78509>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL Global String sDriver Integer iFile Integer iField
78511>>>>>>>>>>>    String sLOB_Args
78511>>>>>>>>>>>
78511>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
78512>>>>>>>>>>>    // First move the size of the structure to the Structure
78512>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
78513>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
78514>>>>>>>>>>>
78514>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
78519>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
78520>>>>>>>>>>>
78520>>>>>>>>>>>
#REM ***********************************************
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM END OF MERTECH.INC
#REM ***********************************************
78520>>>>>>>>>>>//=============================================================================
78520>>>>>>>>>>>// End of Mertech.inc
78520>>>>>>>>>>>//=============================================================================
78520>>>>>>>>>Use cli.pkg
78520>>>>>>>>>Use ParseKeyWord.pkg
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78520>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
78520>>>>>>>>>>>
78520>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78522>>>>>>>>>>>    Integer iStart iEnd
78522>>>>>>>>>>>    String sRetval
78522>>>>>>>>>>>
78522>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78523>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78524>>>>>>>>>>>    If (iStart = 0) Begin
78526>>>>>>>>>>>        Function_Return ""
78527>>>>>>>>>>>    End
78527>>>>>>>>>>>>
78527>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78528>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78529>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78531>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78532>>>>>>>>>>>    End
78532>>>>>>>>>>>>
78532>>>>>>>>>>>    Else Begin
78533>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78534>>>>>>>>>>>    End
78534>>>>>>>>>>>>
78534>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78536>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78537>>>>>>>>>>>        Decrement iEnd
78538>>>>>>>>>>>    End
78538>>>>>>>>>>>>
78538>>>>>>>>>>>    If (iEnd <> 0) Begin
78540>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78541>>>>>>>>>>>    End
78541>>>>>>>>>>>>
78541>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78542>>>>>>>>>>>
78542>>>>>>>>>>>    Function_Return (Trim(sRetval))
78543>>>>>>>>>>>End_Function
78544>>>>>>>>>>>
78544>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
78544>>>>>>>>>
78544>>>>>>>>>Struct tCLIHandleMap
78544>>>>>>>>>    Integer iHdbc
78544>>>>>>>>>    String sDriver
78544>>>>>>>>>    String sConnect
78544>>>>>>>>>End_Struct
78544>>>>>>>>>
78544>>>>>>>>>Struct tColumnMap
78544>>>>>>>>>    Integer iFileNum
78544>>>>>>>>>    Variant[] vResultColumn
78544>>>>>>>>>End_Struct
78544>>>>>>>>>
78544>>>>>>>>>//*** Embedded SQL statement attribute constants
78544>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
78544>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
78544>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
78544>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
78544>>>>>>>>>
78544>>>>>>>>>//*** Embedded SQL column attribute constants
78544>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
78544>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
78544>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
78544>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
78544>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
78544>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
78544>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
78544>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
78544>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
78544>>>>>>>>>
78544>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
78544>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
78544>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
78544>>>>>>>>>
78544>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
78544>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
78545>>>>>>>>>
78545>>>>>>>>>//*** Global object handle for the manager
78545>>>>>>>>>Global_Variable Handle _embsqlghoSQLHandleMngr
78545>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
78545>>>>>>>>>
78545>>>>>>>>>Class cSQLStatementDUF is a cObject
78546>>>>>>>>>    Procedure Construct_Object
78548>>>>>>>>>        Forward Send Construct_Object
78550>>>>>>>>>
78550>>>>>>>>>        Property Integer phCLIHandle      0
78551>>>>>>>>>        Property Integer piLastColumn     0
78552>>>>>>>>>        Property Integer piLastArgument   0
78553>>>>>>>>>        Property Integer piBindFile       0
78554>>>>>>>>>        Property Integer piCursorNum      0
78555>>>>>>>>>        Property Boolean pisBeforeFetch   True
78556>>>>>>>>>        Property Integer piParameterCount 0
78557>>>>>>>>>
78557>>>>>>>>>        Property Integer piDataChunkOffset 0
78558>>>>>>>>>        Property String psProcName ""
78559>>>>>>>>>        Property String psSchemaName ""
78560>>>>>>>>>        Property Variant[] pvParams
78561>>>>>>>>>        Property tColumnMap ptColumnMap
78562>>>>>>>>>    End_Procedure
78563>>>>>>>>>
78563>>>>>>>>>
78563>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
78565>>>>>>>>>        Integer hoCLIHandler
78565>>>>>>>>>        String sSQLDate
78565>>>>>>>>>
78565>>>>>>>>>        //*** Create a CLI handler object
78565>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
78567>>>>>>>>>            Move Current_Object to hoCLIHandler
78568>>>>>>>>>        End_Object
78569>>>>>>>>>
78569>>>>>>>>>        //*** Convert the date
78569>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
78570>>>>>>>>>
78570>>>>>>>>>        //*** Destroy the object
78570>>>>>>>>>        Send Destroy_Object to hoCLIHandler
78571>>>>>>>>>
78571>>>>>>>>>        Function_Return sSQLDate
78572>>>>>>>>>    End_Function
78573>>>>>>>>>
78573>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
78575>>>>>>>>>        String sRoutineType
78575>>>>>>>>>
78575>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
78613>>>>>>>>>>
78613>>>>>>>>>
78613>>>>>>>>>        Case Begin
78613>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
78615>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
78647>>>>>>>>>                sql_prepare_stmt
78696>>>>>>>>>                sql_execute_stmt
78736>>>>>>>>>
78736>>>>>>>>>                sql_fetch_next_row into sRoutineType
78911>>>>>>>>>                If (sRoutineType = "P") Begin
78913>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
78914>>>>>>>>>                End
78914>>>>>>>>>>
78914>>>>>>>>>                Else Begin
78915>>>>>>>>>                    Move "FUNCTION" to sRoutineType
78916>>>>>>>>>                End
78916>>>>>>>>>>
78916>>>>>>>>>                Case Break
78917>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
78920>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
78952>>>>>>>>>                sql_prepare_stmt
79001>>>>>>>>>                sql_execute_stmt
79041>>>>>>>>>                sql_fetch_next_row into sRoutineType
79216>>>>>>>>>
79216>>>>>>>>>                Case Break
79217>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
79220>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
79252>>>>>>>>>                sql_prepare_stmt
79301>>>>>>>>>                sql_execute_stmt
79341>>>>>>>>>                sql_fetch_next_row into sRoutineType
79516>>>>>>>>>
79516>>>>>>>>>                Case Break
79517>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
79520>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
79520>>>>>>>>>                // because that is better tested.
79520>>>>>>>>>                Move "PROCEDURE" to sRoutineType
79521>>>>>>>>>                Case Break
79522>>>>>>>>>        Case End
79522>>>>>>>>>
79522>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
79523>>>>>>>>>    End_Function
79524>>>>>>>>>
79524>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
79526>>>>>>>>>        Variant[] vFuncParams
79527>>>>>>>>>        Integer i iParamType
79527>>>>>>>>>
79527>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
79565>>>>>>>>>>
79565>>>>>>>>>
79565>>>>>>>>>        Case Begin
79565>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
79567>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
79599>>>>>>>>>                sql_prepare_stmt
79648>>>>>>>>>                sql_execute_stmt
79688>>>>>>>>>
79688>>>>>>>>>                Repeat
79688>>>>>>>>>>
79688>>>>>>>>>                    sql_fetch_next_row
79738>>>>>>>>>                    If (Found) Begin
79740>>>>>>>>>                        sql_fetch_column 6 into iParamType
79769>>>>>>>>>
79769>>>>>>>>>                        If (iParamType = 1) Begin
79771>>>>>>>>>                            Move "IN" to vFuncParams[i]
79772>>>>>>>>>                        End
79772>>>>>>>>>>
79772>>>>>>>>>                        If (iParamType = 2) Begin
79774>>>>>>>>>                            Move "INOUT" to vFuncParams[i]
79775>>>>>>>>>                        End
79775>>>>>>>>>>
79775>>>>>>>>>                        If (iParamType = 3) Begin
79777>>>>>>>>>                            Move "OUT" to vFuncParams[i]
79778>>>>>>>>>                        End
79778>>>>>>>>>>
79778>>>>>>>>>                        If (iParamType <> 4) Begin
79780>>>>>>>>>                            Increment i
79781>>>>>>>>>                        End
79781>>>>>>>>>>
79781>>>>>>>>>                    End
79781>>>>>>>>>>
79781>>>>>>>>>                Until (not(Found))
79783>>>>>>>>>
79783>>>>>>>>>                Function_Return vFuncParams
79784>>>>>>>>>
79784>>>>>>>>>                Case Break
79785>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
79788>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
79820>>>>>>>>>                sql_prepare_stmt
79869>>>>>>>>>                sql_execute_stmt
79909>>>>>>>>>
79909>>>>>>>>>                Case Break
79910>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
79913>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
79945>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
79977>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
80009>>>>>>>>>                sql_prepare_stmt
80058>>>>>>>>>                sql_execute_stmt
80098>>>>>>>>>
80098>>>>>>>>>                Case Break
80099>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
80102>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
80134>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
80166>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
80198>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
80230>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
80262>>>>>>>>>                sql_prepare_stmt
80311>>>>>>>>>                sql_execute_stmt
80351>>>>>>>>>
80351>>>>>>>>>                Case Break
80352>>>>>>>>>        Case End
80352>>>>>>>>>
80352>>>>>>>>>        Repeat
80352>>>>>>>>>>
80352>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
80527>>>>>>>>>            Increment i
80528>>>>>>>>>        Until (not(Found))
80530>>>>>>>>>
80530>>>>>>>>>        Function_Return vFuncParams
80531>>>>>>>>>    End_Function
80532>>>>>>>>>
80532>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
80534>>>>>>>>>        Set phCLIHandle to hConn
80535>>>>>>>>>    End_Procedure
80536>>>>>>>>>
80536>>>>>>>>>    Procedure FreeHandle
80538>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
80576>>>>>>>>>>
80576>>>>>>>>>
80576>>>>>>>>>                                 Case Begin
80576>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
80578>>>>>>>>>                                END_CALL_PROCEDURE
80583>>>>>>>>>                Case Break
80584>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
80587>>>>>>>>>                Case Break
80588>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
80591>>>>>>>>>                Case Break
80592>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
80595>>>>>>>>>                Case Break
80596>>>>>>>>>        Case End
80596>>>>>>>>>
80596>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
80634>>>>>>>>>>
80634>>>>>>>>>        Send Destroy_Object
80635>>>>>>>>>    End_Procedure
80636>>>>>>>>>
80636>>>>>>>>>    Procedure SQLClose
80638>>>>>>>>>        Send FreeHandle
80639>>>>>>>>>    End_Procedure
80640>>>>>>>>>
80640>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
80642>>>>>>>>>        Integer iErrHandle
80642>>>>>>>>>        Integer iErrNum
80642>>>>>>>>>        String  sLocationInfo
80642>>>>>>>>>
80642>>>>>>>>>        //*** Get the DataFlex statement identifier
80642>>>>>>>>>        Move Current_object to iErrHandle
80643>>>>>>>>>
80643>>>>>>>>>        //*** Determine error number
80643>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
80646>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
80650>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
80654>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
80656>>>>>>>>>
80656>>>>>>>>>        //*** Create location information
80656>>>>>>>>>        Move "[" to sLocationInfo
80657>>>>>>>>>        If (sOriginMsg <> "") Begin
80659>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
80660>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
80661>>>>>>>>>        End
80661>>>>>>>>>>
80661>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
80662>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
80663>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
80664>>>>>>>>>
80664>>>>>>>>>        //*** Generate the error
80664>>>>>>>>>        Error iErrNum sLocationInfo
80665>>>>>>>>>>
80665>>>>>>>>>    End_Procedure
80666>>>>>>>>>
80666>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
80668>>>>>>>>>        Integer iErrHandle
80668>>>>>>>>>        String  sLocationInfo
80668>>>>>>>>>
80668>>>>>>>>>        //*** Get the DataFlex statement identifier
80668>>>>>>>>>        Move Current_object to iErrHandle
80669>>>>>>>>>
80669>>>>>>>>>        //*** Create location information
80669>>>>>>>>>        Move "[" to sLocationInfo
80670>>>>>>>>>        If (sOriginMsg <> "") Begin
80672>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
80673>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
80674>>>>>>>>>        End
80674>>>>>>>>>>
80674>>>>>>>>>        If (sErrtext <> "") Begin
80676>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
80677>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
80678>>>>>>>>>        End
80678>>>>>>>>>>
80678>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
80679>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
80680>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
80681>>>>>>>>>
80681>>>>>>>>>        //*** Generate the error
80681>>>>>>>>>        Error iErrNum sLocationInfo
80682>>>>>>>>>>
80682>>>>>>>>>    End_Procedure
80683>>>>>>>>>
80683>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
80685>>>>>>>>>        Integer bReport
80685>>>>>>>>>
80685>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
80688>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
80691>>>>>>>>>    End_Procedure
80692>>>>>>>>>
80692>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
80694>>>>>>>>>        String sResult
80694>>>>>>>>>        Integer iCols
80694>>>>>>>>>        Integer iOrgDateFmt
80694>>>>>>>>>        Integer iOrgDateSep
80694>>>>>>>>>        String sType
80694>>>>>>>>>
80694>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
80732>>>>>>>>>>
80732>>>>>>>>>
80732>>>>>>>>>        SQL_GET_NUM_COLS to iCols
80766>>>>>>>>>>
80766>>>>>>>>>        If (iCol <= iCols) Begin
80768>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
80768>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
80770>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
80773>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
80776>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
80779>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
80782>>>>>>>>>            End
80782>>>>>>>>>>
80782>>>>>>>>>
80782>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
80782>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
80784>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
80825>>>>>>>>>>
80825>>>>>>>>>                If (sType=5) Begin
80827>>>>>>>>>                    Move "" to sResult
80828>>>>>>>>>                End
80828>>>>>>>>>>
80828>>>>>>>>>                Else Begin
80829>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
80858>>>>>>>>>                End
80858>>>>>>>>>>
80858>>>>>>>>>            End
80858>>>>>>>>>>
80858>>>>>>>>>            Else Begin
80859>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
80888>>>>>>>>>            End
80888>>>>>>>>>>
80888>>>>>>>>>
80888>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
80890>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
80893>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
80896>>>>>>>>>            End
80896>>>>>>>>>>
80896>>>>>>>>>
80896>>>>>>>>>            Function_Return sResult
80897>>>>>>>>>        End
80897>>>>>>>>>>
80897>>>>>>>>>        Else Begin
80898>>>>>>>>>            Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
80899>>>>>>>>>        End
80899>>>>>>>>>>
80899>>>>>>>>>        Function_Return ""
80900>>>>>>>>>    End_Function
80901>>>>>>>>>
80901>>>>>>>>>    Function SQLNextColumn Returns String
80903>>>>>>>>>        Integer iCol
80903>>>>>>>>>        String  sResult
80903>>>>>>>>>
80903>>>>>>>>>        Get piLastColumn to iCol
80904>>>>>>>>>        Increment iCol
80905>>>>>>>>>        Get SQLColumnValue iCol to sResult
80906>>>>>>>>>        Set piLastColumn to iCol
80907>>>>>>>>>
80907>>>>>>>>>        Function_Return sResult
80908>>>>>>>>>    End_Function
80909>>>>>>>>>
80909>>>>>>>>>    Procedure SQLPrepare String sStatement
80911>>>>>>>>>        tColumnMap tColumnMap
80911>>>>>>>>>        tColumnMap tColumnMap
80911>>>>>>>>>        Set ptColumnMap to tColumnMap
80912>>>>>>>>>        Set pisBeforeFetch to True
80913>>>>>>>>>
80913>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
80951>>>>>>>>>>
80951>>>>>>>>>        SQL_SET_STMT to sStatement
80983>>>>>>>>>
80983>>>>>>>>>        SQL_PREPARE_STMT
81032>>>>>>>>>    End_Procedure
81033>>>>>>>>>
81033>>>>>>>>>    Procedure SQLExecute
81035>>>>>>>>>        SQL_EXECUTE_STMT
81075>>>>>>>>>    End_Procedure
81076>>>>>>>>>
81076>>>>>>>>>    Procedure SQLExecDirect String sStatement
81078>>>>>>>>>        tColumnMap tColumnMap
81078>>>>>>>>>        tColumnMap tColumnMap
81078>>>>>>>>>        Set ptColumnMap to tColumnMap
81079>>>>>>>>>        Set pisBeforeFetch to True
81080>>>>>>>>>
81080>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81118>>>>>>>>>>
81118>>>>>>>>>
81118>>>>>>>>>        SQL_SET_STMT to sStatement
81150>>>>>>>>>        SQL_PREPARE_STMT
81199>>>>>>>>>        SQL_EXECUTE_STMT
81239>>>>>>>>>    End_Procedure
81240>>>>>>>>>
81240>>>>>>>>>    Function SQLFetch Returns Integer
81242>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81280>>>>>>>>>>
81280>>>>>>>>>        Set pisBeforeFetch to False
81281>>>>>>>>>
81281>>>>>>>>>        SQL_FETCH_NEXT_ROW
81331>>>>>>>>>        Function_Return (Found)
81332>>>>>>>>>    End_Function
81333>>>>>>>>>
81333>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
81335>>>>>>>>>        tColumnMap tColumnMap
81335>>>>>>>>>        tColumnMap tColumnMap
81335>>>>>>>>>        String[] sBindFileColumns
81336>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
81336>>>>>>>>>        String sColumnName
81336>>>>>>>>>        Variant vFieldValue
81336>>>>>>>>>        Boolean isRecnumTable
81336>>>>>>>>>
81336>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81374>>>>>>>>>>
81374>>>>>>>>>
81374>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
81377>>>>>>>>>        Get ptColumnMap to tColumnMap
81378>>>>>>>>>
81378>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
81380>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
81381>>>>>>>>>
81381>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
81381>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
81384>>>>>>>>>            For i from 0 to iColCnt
81390>>>>>>>>>>
81390>>>>>>>>>                If (isRecnumTable) Begin
81392>>>>>>>>>                    Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
81395>>>>>>>>>                End
81395>>>>>>>>>>
81395>>>>>>>>>                Else Begin
81396>>>>>>>>>                    Move "" to sColumnName
81397>>>>>>>>>                End
81397>>>>>>>>>>
81397>>>>>>>>>
81397>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
81398>>>>>>>>>            Loop
81399>>>>>>>>>>
81399>>>>>>>>>
81399>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
81399>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
81399>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
81399>>>>>>>>>            // column mappped column to -1.
81399>>>>>>>>>            //
81399>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
81399>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
81399>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
81399>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
81399>>>>>>>>>            // to Column 3 of the file buffer)
81399>>>>>>>>>
81399>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
81433>>>>>>>>>>
81433>>>>>>>>>            For i from 1 to iColCnt
81439>>>>>>>>>>
81439>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
81479>>>>>>>>>>
81479>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
81479>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
81479>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
81480>>>>>>>>>
81480>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
81480>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
81480>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
81480>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
81480>>>>>>>>>                // converted to a string so its okay.
81480>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
81482>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
81523>>>>>>>>>>
81523>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
81526>>>>>>>>>
81526>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
81526>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
81526>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
81529>>>>>>>>>
81529>>>>>>>>>                    // Otherwise, break the mapping
81529>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Begin
81531>>>>>>>>>                        Move -1 to tColumnMap.vResultColumn[i-1]
81532>>>>>>>>>                    End
81532>>>>>>>>>>
81532>>>>>>>>>                End
81532>>>>>>>>>>
81532>>>>>>>>>            Loop
81533>>>>>>>>>>
81533>>>>>>>>>
81533>>>>>>>>>            Set ptColumnMap to tColumnMap
81534>>>>>>>>>        End
81534>>>>>>>>>>
81534>>>>>>>>>
81534>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
81535>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
81536>>>>>>>>>        Clear iFileNum
81537>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
81543>>>>>>>>>>
81543>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
81545>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
81574>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
81577>>>>>>>>>            End
81577>>>>>>>>>>
81577>>>>>>>>>        Loop
81578>>>>>>>>>>
81578>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
81581>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
81582>>>>>>>>>    End_Procedure
81583>>>>>>>>>
81583>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
81585>>>>>>>>>        String data
81585>>>>>>>>>        Integer retlen
81585>>>>>>>>>
81585>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81623>>>>>>>>>>
81623>>>>>>>>>
81623>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
81664>>>>>>>>>>
81664>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
81698>>>>>>>>>>
81698>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
81699>>>>>>>>>
81699>>>>>>>>>        Function_Return data
81700>>>>>>>>>    End_Function
81701>>>>>>>>>
81701>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
81703>>>>>>>>>        Integer iNumColumns i iIndex
81703>>>>>>>>>        String[] cols
81704>>>>>>>>>
81704>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81742>>>>>>>>>>
81742>>>>>>>>>
81742>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
81743>>>>>>>>>
81743>>>>>>>>>        For i from 1 to iNumColumns
81749>>>>>>>>>>
81749>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
81789>>>>>>>>>>
81789>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
81790>>>>>>>>>        Loop
81791>>>>>>>>>>
81791>>>>>>>>>
81791>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
81792>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
81793>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
81794>>>>>>>>>    End_Function
81795>>>>>>>>>
81795>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
81797>>>>>>>>>        Integer iCnt
81797>>>>>>>>>
81797>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81835>>>>>>>>>>
81835>>>>>>>>>
81835>>>>>>>>>        Case Begin
81835>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
81837>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
81871>>>>>>>>>>
81871>>>>>>>>>                Function_Return iCnt
81872>>>>>>>>>                Case Break
81873>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
81876>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
81910>>>>>>>>>>
81910>>>>>>>>>
81910>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
81910>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
81912>>>>>>>>>                    If (pisBeforeFetch(Self)) Begin
81914>>>>>>>>>                        Function_Return -1
81915>>>>>>>>>                    End
81915>>>>>>>>>>
81915>>>>>>>>>                End
81915>>>>>>>>>>
81915>>>>>>>>>
81915>>>>>>>>>                Function_Return iCnt
81916>>>>>>>>>                Case Break
81917>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
81920>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
81920>>>>>>>>>                Case Break
81921>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
81924>>>>>>>>>                Function_Return -1
81925>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
81925>>>>>>>>>                Case Break
81926>>>>>>>>>            Case Else
81926>>>>>>>>>        Case End
81926>>>>>>>>>
81926>>>>>>>>>        Function_Return ""
81927>>>>>>>>>    End_Function
81928>>>>>>>>>
81928>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
81930>>>>>>>>>        String sValue
81930>>>>>>>>>        Integer iSQLType
81930>>>>>>>>>        Integer iDFType
81930>>>>>>>>>
81930>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81968>>>>>>>>>>
81968>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
82009>>>>>>>>>>
82009>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
82050>>>>>>>>>>
82050>>>>>>>>>
82050>>>>>>>>>        Case Begin
82050>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
82052>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
82093>>>>>>>>>>
82093>>>>>>>>>
82093>>>>>>>>>                //DAC Driver uses different values.
82093>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
82095>>>>>>>>>                    If (iSQLType=12) Begin
82097>>>>>>>>>                        Move (Integer(sValue-1)) to sValue
82098>>>>>>>>>                    End
82098>>>>>>>>>>
82098>>>>>>>>>                    If (iDFType=5) Begin
82100>>>>>>>>>                        Move "0" to sValue
82101>>>>>>>>>                    End
82101>>>>>>>>>>
82101>>>>>>>>>                    If (iSQLType=40) Begin
82103>>>>>>>>>                        Move "10" to sValue
82104>>>>>>>>>                    End
82104>>>>>>>>>>
82104>>>>>>>>>                End
82104>>>>>>>>>>
82104>>>>>>>>>
82104>>>>>>>>>                Case Break
82105>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
82108>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
82149>>>>>>>>>>
82149>>>>>>>>>                Case Break
82150>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
82153>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
82194>>>>>>>>>>
82194>>>>>>>>>                Case Break
82195>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
82198>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
82239>>>>>>>>>>
82239>>>>>>>>>
82239>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
82239>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
82241>>>>>>>>>                    Move "" to sValue
82242>>>>>>>>>                End
82242>>>>>>>>>>
82242>>>>>>>>>
82242>>>>>>>>>                Case Break
82243>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
82246>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
82287>>>>>>>>>>
82287>>>>>>>>>                Case Break
82288>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
82291>>>>>>>>>                Move iSQLType to sValue
82292>>>>>>>>>
82292>>>>>>>>>                //DAC Driver uses different values.
82292>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
82294>>>>>>>>>                    If (iSQLType=2) Begin
82296>>>>>>>>>                        Move "3" to sValue
82297>>>>>>>>>                    End
82297>>>>>>>>>>
82297>>>>>>>>>                    If (iSQLType=-99) Begin
82299>>>>>>>>>                        Move "12" to sValue
82300>>>>>>>>>                    End
82300>>>>>>>>>>
82300>>>>>>>>>                    If (iSQLType=40) Begin
82302>>>>>>>>>                        Move "91" to sValue
82303>>>>>>>>>                    End
82303>>>>>>>>>>
82303>>>>>>>>>                End
82303>>>>>>>>>>
82303>>>>>>>>>
82303>>>>>>>>>                Case Break
82304>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
82307>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
82348>>>>>>>>>>
82348>>>>>>>>>                Case Break
82349>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
82352>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
82393>>>>>>>>>>
82393>>>>>>>>>
82393>>>>>>>>>                //DAC Driver uses different values.
82393>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
82395>>>>>>>>>                    If (iDFType = 5) Begin
82397>>>>>>>>>                        Move "0" to sValue
82398>>>>>>>>>                    End
82398>>>>>>>>>>
82398>>>>>>>>>                End
82398>>>>>>>>>>
82398>>>>>>>>>                Case Break
82399>>>>>>>>>        Case End
82399>>>>>>>>>
82399>>>>>>>>>        Function_Return sValue
82400>>>>>>>>>    End_Function
82401>>>>>>>>>
82401>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
82403>>>>>>>>>        Set psProcName to sProcName
82404>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
82407>>>>>>>>>        Else ;            Set psSchemaName to ""
82409>>>>>>>>>    End_Procedure
82410>>>>>>>>>
82410>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
82412>>>>>>>>>        Integer iArgnum
82412>>>>>>>>>
82412>>>>>>>>>        Get piLastArgument to iArgnum
82413>>>>>>>>>        Increment iArgnum
82414>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
82415>>>>>>>>>        Set piLastArgument to iArgnum
82416>>>>>>>>>    End_Procedure
82417>>>>>>>>>
82417>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
82419>>>>>>>>>        Variant[] vParams
82420>>>>>>>>>
82420>>>>>>>>>        Get pvParams to vParams
82421>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
82422>>>>>>>>>        Set pvParams to vParams
82423>>>>>>>>>
82423>>>>>>>>>    End_Procedure
82424>>>>>>>>>
82424>>>>>>>>>    Procedure SQLCall
82426>>>>>>>>>        Variant[] vParams
82427>>>>>>>>>        Variant[] vParamOpts
82428>>>>>>>>>        Integer i
82428>>>>>>>>>        Integer iMax
82428>>>>>>>>>        Integer iParamsIn
82428>>>>>>>>>        String sParameter
82428>>>>>>>>>        Boolean bIsProcedure
82428>>>>>>>>>
82428>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82466>>>>>>>>>>
82466>>>>>>>>>
82466>>>>>>>>>        Get pvParams to vParams
82467>>>>>>>>>
82467>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
82467>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
82467>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
82467>>>>>>>>>        // so that after the call you can retrieve the value.
82467>>>>>>>>>
82467>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
82468>>>>>>>>>
82468>>>>>>>>>        If (bIsProcedure) Begin
82470>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
82471>>>>>>>>>
82471>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
82472>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
82473>>>>>>>>>            Set piParameterCount to iMax
82474>>>>>>>>>
82474>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
82518>>>>>>>>>            For i from 1 to iMax
82524>>>>>>>>>>
82524>>>>>>>>>                If ( (i-1) >= iParamsIn) Begin
82526>>>>>>>>>                    Move "" to sParameter
82527>>>>>>>>>                End
82527>>>>>>>>>>
82527>>>>>>>>>                Else Begin
82528>>>>>>>>>                    Move vParams[i-1] to sParameter
82529>>>>>>>>>                End
82529>>>>>>>>>>
82529>>>>>>>>>
82529>>>>>>>>>                Case Begin
82529>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
82531>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
82568>>>>>>>>>>
82568>>>>>>>>>                        Case Break
82569>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
82572>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
82609>>>>>>>>>>
82609>>>>>>>>>                        Case Break
82610>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
82613>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
82650>>>>>>>>>>
82650>>>>>>>>>                        Case Break
82651>>>>>>>>>                Case End
82651>>>>>>>>>            Loop
82652>>>>>>>>>>
82652>>>>>>>>>
82652>>>>>>>>>            SQL_PROCEDURE_EXECUTE
82692>>>>>>>>>        End
82692>>>>>>>>>>
82692>>>>>>>>>        Else Begin
82693>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
82741>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
82747>>>>>>>>>>
82747>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
82916>>>>>>>>>>
82916>>>>>>>>>            Loop
82917>>>>>>>>>>
82917>>>>>>>>>
82917>>>>>>>>>            SQL_FUNCTION_EXECUTE
82918>>>>>>>>>        End
82918>>>>>>>>>>
82918>>>>>>>>>    End_Procedure
82919>>>>>>>>>
82919>>>>>>>>>    Function SQLGetNextArgument Returns String
82921>>>>>>>>>        Integer iArgnum
82921>>>>>>>>>        String  sResult
82921>>>>>>>>>
82921>>>>>>>>>        Get piLastArgument to iArgnum
82922>>>>>>>>>        Increment iArgnum
82923>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
82924>>>>>>>>>        Set piLastArgument to iArgnum
82925>>>>>>>>>
82925>>>>>>>>>        Function_Return sResult
82926>>>>>>>>>    End_Function
82927>>>>>>>>>
82927>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
82929>>>>>>>>>        String retval
82929>>>>>>>>>
82929>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Begin
82931>>>>>>>>>            Function_Return ""
82932>>>>>>>>>        End
82932>>>>>>>>>>
82932>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
82988>>>>>>>>>>
82988>>>>>>>>>
82988>>>>>>>>>        Function_Return retval
82989>>>>>>>>>    End_Function
82990>>>>>>>>>
82990>>>>>>>>>    Function SQLReturnValue Returns String
82992>>>>>>>>>        String retval
82992>>>>>>>>>
82992>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
83080>>>>>>>>>        Function_Return retval
83081>>>>>>>>>    End_Function
83082>>>>>>>>>
83082>>>>>>>>>    Function SQLNextResultSet Returns Integer
83084>>>>>>>>>        SQL_NEXT_RESULT_SET
83120>>>>>>>>>
83120>>>>>>>>>        Function_Return (Found)
83121>>>>>>>>>    End_Function
83122>>>>>>>>>
83122>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
83124>>>>>>>>>        // TODO
83124>>>>>>>>>        Function_Return ""
83125>>>>>>>>>    End_Function
83126>>>>>>>>>
83126>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
83128>>>>>>>>>        // TODO
83128>>>>>>>>>    End_Procedure
83129>>>>>>>>>
83129>>>>>>>>>End_Class
83130>>>>>>>>>
83130>>>>>>>>>Class cSQLConnectionDUF is a cObject
83131>>>>>>>>>    Procedure Construct_Object
83133>>>>>>>>>        Forward Send Construct_Object
83135>>>>>>>>>
83135>>>>>>>>>        Property Handle phCLIHandle 0
83136>>>>>>>>>        Property String psDriverID MertechInc_DriverName
83137>>>>>>>>>        Property Integer piBindFile 0
83138>>>>>>>>>        Property String psUsername ""
83139>>>>>>>>>        Property String psPassword ""
83140>>>>>>>>>
83140>>>>>>>>>        Property String psCurrentDatabase ""
83141>>>>>>>>>
83141>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
83142>>>>>>>>>    End_Procedure
83143>>>>>>>>>
83143>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
83145>>>>>>>>>        Set phCLIHandle      to hCLIHandle
83146>>>>>>>>>        Set psDriverID       to sDrvrId
83147>>>>>>>>>    End_Procedure
83148>>>>>>>>>
83148>>>>>>>>>    Procedure FreeHandle
83150>>>>>>>>>        Send Destroy
83151>>>>>>>>>    End_Procedure
83152>>>>>>>>>
83152>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
83154>>>>>>>>>        tCLIHandleMap conn
83154>>>>>>>>>        tCLIHandleMap conn
83154>>>>>>>>>
83154>>>>>>>>>        Get ptCLIHandleMap to conn
83155>>>>>>>>>        Set psCurrentDatabase to sDatabase
83156>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
83194>>>>>>>>>>
83194>>>>>>>>>    End_Procedure
83195>>>>>>>>>
83195>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
83197>>>>>>>>>        tCLIHandleMap[] maps
83197>>>>>>>>>        tCLIHandleMap[] maps
83198>>>>>>>>>        tCLIHandleMap conn
83198>>>>>>>>>        tCLIHandleMap conn
83198>>>>>>>>>
83198>>>>>>>>>        Get ptCLIHandleMaps to maps
83199>>>>>>>>>        Move sDriver to conn.sDriver
83200>>>>>>>>>        Move sConnect to conn.sConnect
83201>>>>>>>>>
83201>>>>>>>>>        If (SizeOfArray(maps) > 0) Begin
83203>>>>>>>>>            Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
83204>>>>>>>>>        End
83204>>>>>>>>>>
83204>>>>>>>>>        Else Begin
83205>>>>>>>>>            Move 1 to conn.iHdbc
83206>>>>>>>>>        End
83206>>>>>>>>>>
83206>>>>>>>>>
83206>>>>>>>>>        Set CurrentConnection to sDriver sConnect
83207>>>>>>>>>        If (not(Err)) Begin
83209>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
83210>>>>>>>>>            Set ptCLIHandleMaps to maps
83211>>>>>>>>>            Set ptCLIHandleMap to conn
83212>>>>>>>>>        End
83212>>>>>>>>>>
83212>>>>>>>>>
83212>>>>>>>>>        Function_Return Self
83213>>>>>>>>>    End_Function
83214>>>>>>>>>
83214>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83216>>>>>>>>>        Boolean bIsOpen
83216>>>>>>>>>        String sDriver sServer
83216>>>>>>>>>        tCLIHandleMap[] maps
83216>>>>>>>>>        tCLIHandleMap[] maps
83217>>>>>>>>>        tCLIHandleMap conn
83217>>>>>>>>>        tCLIHandleMap conn
83217>>>>>>>>>
83217>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
83220>>>>>>>>>        If (bIsOpen) Begin
83222>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
83222>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
83223>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
83224>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
83227>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
83230>>>>>>>>>
83230>>>>>>>>>            Indicate Err False
83231>>>>>>>>>
83231>>>>>>>>>            Get ptCLIHandleMaps to maps
83232>>>>>>>>>            Move sDriver to conn.sDriver
83233>>>>>>>>>            Move sServer to conn.sConnect
83234>>>>>>>>>
83234>>>>>>>>>            If (SizeOfArray(maps) > 0) Begin
83236>>>>>>>>>                Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
83237>>>>>>>>>            End
83237>>>>>>>>>>
83237>>>>>>>>>            Else Begin
83238>>>>>>>>>                Move 1 to conn.iHdbc
83239>>>>>>>>>            End
83239>>>>>>>>>>
83239>>>>>>>>>
83239>>>>>>>>>            Set CurrentConnection to sDriver sServer
83240>>>>>>>>>            If (not(Err)) Begin
83242>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
83243>>>>>>>>>                Set ptCLIHandleMaps to maps
83244>>>>>>>>>                Set ptCLIHandleMap to conn
83245>>>>>>>>>            End
83245>>>>>>>>>>
83245>>>>>>>>>
83245>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
83246>>>>>>>>>            Set piBindFile to iFileNum
83247>>>>>>>>>        End
83247>>>>>>>>>>
83247>>>>>>>>>        Else Begin
83248>>>>>>>>>            Error 4099 "File Not Open"
83249>>>>>>>>>>
83249>>>>>>>>>        End
83249>>>>>>>>>>
83249>>>>>>>>>
83249>>>>>>>>>        //*** Return success status
83249>>>>>>>>>        Function_Return (not(Err))
83250>>>>>>>>>    End_Function
83251>>>>>>>>>
83251>>>>>>>>>    Procedure SQLDisconnect
83253>>>>>>>>>        tCLIHandleMap map
83253>>>>>>>>>        tCLIHandleMap map
83253>>>>>>>>>        tCLIHandleMap[] maps
83253>>>>>>>>>        tCLIHandleMap[] maps
83254>>>>>>>>>        Integer iFound
83254>>>>>>>>>
83254>>>>>>>>>        Get ptCLIHandleMap to map
83255>>>>>>>>>        Get ptCLIHandleMaps to maps
83256>>>>>>>>>
83256>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
83257>>>>>>>>>        If (iFound > -1) Begin
83259>>>>>>>>>            Send FreeHandle
83260>>>>>>>>>        End
83260>>>>>>>>>>
83260>>>>>>>>>    End_Procedure
83261>>>>>>>>>
83261>>>>>>>>>    Function CreateHandle Returns Integer
83263>>>>>>>>>        Handle hSQL
83263>>>>>>>>>        Integer iCursor
83263>>>>>>>>>
83263>>>>>>>>>        Get Create (RefClass(cSQLStatementDUF)) to hSQL
83264>>>>>>>>>
83264>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
83265>>>>>>>>>
83265>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
83303>>>>>>>>>>
83303>>>>>>>>>        Set piCursorNum of hSQL to iCursor
83304>>>>>>>>>
83304>>>>>>>>>        Function_Return hSQL
83305>>>>>>>>>    End_Function
83306>>>>>>>>>
83306>>>>>>>>>    Function SQLOpen Returns Integer
83308>>>>>>>>>        Handle hDFHandle
83308>>>>>>>>>
83308>>>>>>>>>        Get CreateHandle to hDFHandle
83309>>>>>>>>>
83309>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
83310>>>>>>>>>
83310>>>>>>>>>        Function_Return hDFHandle
83311>>>>>>>>>    End_Function
83312>>>>>>>>>
83312>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
83314>>>>>>>>>        String sCurrentDriver
83314>>>>>>>>>        Integer iDriver
83314>>>>>>>>>        Integer iNumDrivers
83314>>>>>>>>>
83314>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
83317>>>>>>>>>        For iDriver from 1 to iNumDrivers
83323>>>>>>>>>>
83323>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
83326>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
83329>>>>>>>>>        Loop
83330>>>>>>>>>>
83330>>>>>>>>>        Function_Return 0
83331>>>>>>>>>    End_Function
83332>>>>>>>>>
83332>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
83334>>>>>>>>>        String sServer
83334>>>>>>>>>        Integer iNumServers
83334>>>>>>>>>        Integer iServer
83334>>>>>>>>>
83334>>>>>>>>>        If (iDriver <> 0) Begin
83336>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
83339>>>>>>>>>            If (iNumServers<>0) Begin
83341>>>>>>>>>                Move 1 to iServer
83342>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
83345>>>>>>>>>            End
83345>>>>>>>>>>
83345>>>>>>>>>        End
83345>>>>>>>>>>
83345>>>>>>>>>
83345>>>>>>>>>        Function_Return sServer
83346>>>>>>>>>    End_Function
83347>>>>>>>>>
83347>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
83349>>>>>>>>>        Integer iDriver
83349>>>>>>>>>        String sUsername
83349>>>>>>>>>        String sPassword
83349>>>>>>>>>
83349>>>>>>>>>        If (sDriver="") Begin
83351>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
83377>>>>>>>>>>
83377>>>>>>>>>            Move MertechInc_DriverName to sDriver
83378>>>>>>>>>        End
83378>>>>>>>>>>
83378>>>>>>>>>
83378>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
83380>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
83381>>>>>>>>>
83381>>>>>>>>>            If (Trim(sDriver) <> "") Begin
83383>>>>>>>>>                Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
83384>>>>>>>>>            End
83384>>>>>>>>>>
83384>>>>>>>>>            Else Begin
83385>>>>>>>>>                Move "" to MertechInc_CurrentDriver
83386>>>>>>>>>            End
83386>>>>>>>>>>
83386>>>>>>>>>
83386>>>>>>>>>            Get psUsername to sUsername
83387>>>>>>>>>            Get psPassword to sPassword
83388>>>>>>>>>
83388>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
83389>>>>>>>>>
83389>>>>>>>>>            If (sServer   = "") Begin
83391>>>>>>>>>                Get FirstServerForDriverNo iDriver to sServer
83392>>>>>>>>>            End
83392>>>>>>>>>>
83392>>>>>>>>>            If (sUsername = "") Begin
83394>>>>>>>>>                Get_Current_User_Name of sServer to sUsername
83433>>>>>>>>>>
83433>>>>>>>>>            End
83433>>>>>>>>>>
83433>>>>>>>>>            If (sPassword = "") Begin
83435>>>>>>>>>                Get_Current_User_Password of sServer to sPassword
83474>>>>>>>>>>
83474>>>>>>>>>            End
83474>>>>>>>>>>
83474>>>>>>>>>
83474>>>>>>>>>            Move False to Err
83475>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
83476>>>>>>>>>            Login sServer sUsername sPassword sDriver
83478>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
83479>>>>>>>>>
83479>>>>>>>>>            If (Err = False) Begin
83481>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
83486>>>>>>>>>            End
83486>>>>>>>>>>
83486>>>>>>>>>            Else Begin
83487>>>>>>>>>                Procedure_Return
83488>>>>>>>>>            End
83488>>>>>>>>>>
83488>>>>>>>>>
83488>>>>>>>>>            If (MertechInc_iRet = -1) Begin
83490>>>>>>>>>                Move True to Err
83491>>>>>>>>>            End
83491>>>>>>>>>>
83491>>>>>>>>>        End
83491>>>>>>>>>>
83491>>>>>>>>>        Else Begin
83492>>>>>>>>>            Error 4099 "Invalid Driver"
83493>>>>>>>>>>
83493>>>>>>>>>        End
83493>>>>>>>>>>
83493>>>>>>>>>
83493>>>>>>>>>    End_Procedure
83494>>>>>>>>>
83494>>>>>>>>>End_Class
83495>>>>>>>>>
83495>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
83496>>>>>>>>>
83496>>>>>>>>>    Procedure Construct_Object
83498>>>>>>>>>        Forward Send Construct_Object
83500>>>>>>>>>
83500>>>>>>>>>        Property String  psDefaultDriver     ""
83501>>>>>>>>>        Property String  psDefaultConnection ""
83502>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
83503>>>>>>>>>    End_Procedure
83504>>>>>>>>>
83504>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
83506>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
83508>>>>>>>>>            Function_Return (EQ)
83509>>>>>>>>>        End
83509>>>>>>>>>>
83509>>>>>>>>>        Function_Return (GT)
83510>>>>>>>>>    End_Function
83511>>>>>>>>>
83511>>>>>>>>>    Function CreateHandle Returns Handle
83513>>>>>>>>>        Handle hSQL
83513>>>>>>>>>
83513>>>>>>>>>        Get Create (RefClass(cSQLConnectionDUF)) to hSQL
83514>>>>>>>>>        Function_Return hSQL
83515>>>>>>>>>    End_Function
83516>>>>>>>>>
83516>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
83518>>>>>>>>>        Set psDefaultDriver to sDriver
83519>>>>>>>>>        Set psDefaultConnection to sConnect
83520>>>>>>>>>    End_Procedure
83521>>>>>>>>>
83521>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUID String sPWD Returns Handle
83523>>>>>>>>>        Handle hSql
83523>>>>>>>>>        Boolean bOK
83523>>>>>>>>>        String sServer sUsername sPassword
83523>>>>>>>>>
83523>>>>>>>>>        Get CreateHandle to hSql
83524>>>>>>>>>
83524>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
83526>>>>>>>>>            Get psDefaultDriver to sDriver
83527>>>>>>>>>            Get psDefaultConnection to sConnect
83528>>>>>>>>>        End
83528>>>>>>>>>>
83528>>>>>>>>>
83528>>>>>>>>>        If (num_arguments = 2) Begin
83530>>>>>>>>>            Get ParseKeyWord sConnect "SERVER"  to sServer
83531>>>>>>>>>            If (sServer = "") Begin
83533>>>>>>>>>                Get ParseKeyWord sConnect "DSN" to sServer
83534>>>>>>>>>            End
83534>>>>>>>>>>
83534>>>>>>>>>            Get ParseKeyWord sConnect "UID"     to sUsername
83535>>>>>>>>>            Get ParseKeyWord sConnect "PWD"     to sPassword
83536>>>>>>>>>        End
83536>>>>>>>>>>
83536>>>>>>>>>        Else Begin
83537>>>>>>>>>            Move sUID                           to sUsername
83538>>>>>>>>>            Move sPWD                           to sPassword
83539>>>>>>>>>        End
83539>>>>>>>>>>
83539>>>>>>>>>
83539>>>>>>>>>        Set psUsername of hSql to sUsername
83540>>>>>>>>>        Set psPassword of hSql to sPassword
83541>>>>>>>>>
83541>>>>>>>>>        Get SQLConnect of hSql sDriver sServer to bOK
83542>>>>>>>>>        If (not(bOK)) Begin
83544>>>>>>>>>            Send FreeHandle of hSQL
83545>>>>>>>>>            Function_Return 0
83546>>>>>>>>>        End
83546>>>>>>>>>>
83546>>>>>>>>>
83546>>>>>>>>>        Function_Return hSql
83547>>>>>>>>>    End_Function
83548>>>>>>>>>
83548>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
83550>>>>>>>>>        Handle hSql
83550>>>>>>>>>        Boolean bOK
83550>>>>>>>>>
83550>>>>>>>>>        //*** Allocate a new handle
83550>>>>>>>>>        Get CreateHandle to hSql
83551>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
83552>>>>>>>>>
83552>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
83552>>>>>>>>>        If (not(bOK)) Begin
83554>>>>>>>>>            Send FreeHandle of hSql
83555>>>>>>>>>            Function_Return 0
83556>>>>>>>>>        End
83556>>>>>>>>>>
83556>>>>>>>>>
83556>>>>>>>>>        Function_Return hSql
83557>>>>>>>>>    End_Function
83558>>>>>>>>>
83558>>>>>>>>>End_Class
83559>>>>>>>>>
83559>>>>>>>>>
83559>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
83561>>>>>>>>>    Handle hSqlManager
83561>>>>>>>>>
83561>>>>>>>>>    Get Create (RefClass(cSQLHandleManagerDUF)) to hSqlManager
83562>>>>>>>>>    Function_Return hSqlManager
83563>>>>>>>>>End_Function
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
83565>>>>>>>>>
83565>>>>>>>    Use Mertech.inc
83565>>>>>>>
83565>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
83565>>>>>>>>>Use DUFLanguageConstants.inc
83565>>>>>>>>>
83565>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
83565>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
83565>>>>>>>>>
83565>>>>>>>>>    Define DATAFLEX_ID for "DATAFLEX"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_OEM_Txt for "OEM"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_SERVER for "SERVER"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
83565>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
83565>>>>>>>>>
83565>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
83565>>>>>>>>>
83565>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
83565>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler    
83565>>>>>>>>>    Move 0 to ghoDbUpdateHandler
83566>>>>>>>>>
83566>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
83566>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
83567>>>>>>>>>
83567>>>>>>>>>Struct tSQLScriptArray
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>    Boolean bArgumentSizeChanged
83567>>>>>>>>>    Integer iOrgArgumentSize
83567>>>>>>>>>    String[] sSQLScriptArray
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tSqlErrorArray
83567>>>>>>>>>    String[]  sSqlErrorArray
83567>>>>>>>>>    String[]  sSqlStatementArray
83567>>>>>>>>>    Integer[] iSqlErrorArray
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tSqlColumnNew
83567>>>>>>>>>    String  sBaseColumnName
83567>>>>>>>>>    String  sBaseTableName
83567>>>>>>>>>    String  sLabel
83567>>>>>>>>>    Integer iSqlType
83567>>>>>>>>>    Integer iSize
83567>>>>>>>>>    Integer iPrecision
83567>>>>>>>>>    Integer iDFType
83567>>>>>>>>>    Integer iDFNativeType
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tColumnType
83567>>>>>>>>>    String  sSQLType
83567>>>>>>>>>    Integer iSQLType
83567>>>>>>>>>    Boolean bCanEditSize
83567>>>>>>>>>    Integer iDefaultSize
83567>>>>>>>>>    Integer iMinSize
83567>>>>>>>>>    Number  nMaxSize
83567>>>>>>>>>    String  sDataFlexType
83567>>>>>>>>>    Integer iDataFlexType
83567>>>>>>>>>    Boolean bNativeDataType
83567>>>>>>>>>    String  sPrecision
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
83567>>>>>>>>>// Various SQL back-ends can have slightly different
83567>>>>>>>>>// keywords.
83567>>>>>>>>>Struct tSQLKeyWords
83567>>>>>>>>>    Integer iSQLWord
83567>>>>>>>>>    Integer iSQLDbType
83567>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tSQLRelation
83567>>>>>>>>>    Integer iFileNumber
83567>>>>>>>>>    Integer iFieldNumber
83567>>>>>>>>>    String  sFileName
83567>>>>>>>>>    String  sFieldName
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tSQLLoggedInUser
83567>>>>>>>>>    String sUser
83567>>>>>>>>>    String sProgram
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
83567>>>>>>>>>Enumeration_List
83567>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
83567>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
83567>>>>>>>>>End_Enumeration_List
83567>>>>>>>>>
83567>>>>>>>>>// We need to re-define the standard constants because several driver constants
83567>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
83567>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
83567>>>>>>>>>// They can have slightly different SQL keywords.
83567>>>>>>>>>// Note: If a new type is added to the list,
83567>>>>>>>>>//       the struct array xxx must be adjusted
83567>>>>>>>>>//       so that it is filled with all SQL
83567>>>>>>>>>//       keywords for that new type.
83567>>>>>>>>>Enum_List
83567>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
83567>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
83567>>>>>>>>>    Define EN_DbTypeMySQL      for 2
83567>>>>>>>>>    Define EN_DbTypeOracle     for 3
83567>>>>>>>>>    Define EN_DbTypeDB2        for 4
83567>>>>>>>>>    Define EN_DbTypePostgre    for 5
83567>>>>>>>>>    Define EN_DbTypePervasive  for 6
83567>>>>>>>>>//    Define EN_DbTypeMSSQL
83567>>>>>>>>>//    Define EN_DbTypeMySQL
83567>>>>>>>>>//    Define EN_DbTypeOracle
83567>>>>>>>>>//    Define EN_DbTypeDB2
83567>>>>>>>>>//    Define EN_DbTypePostgre
83567>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
83567>>>>>>>>>End_Enum_List
83567>>>>>>>>>
83567>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
83567>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
83567>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
83567>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
83567>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
83567>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
83567>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
83567>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
83567>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
83567>>>>>>>>>
83567>>>>>>>>>// We need to re-define the standard constants because several driver constants
83567>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
83567>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
83567>>>>>>>>>Enum_List
83567>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
83567>>>>>>>>>    Define DF_BCD_DUF       for -1499
83567>>>>>>>>>    Define DF_DATE_DUF      for -1498
83567>>>>>>>>>    Define DF_TEXT_DUF      for -1495
83567>>>>>>>>>    Define DF_BINARY_DUF    for -1494
83567>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
83567>>>>>>>>>End_Enum_List
83567>>>>>>>>>
83567>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
83567>>>>>>>>>
83567>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
83567>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
83567>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
83567>>>>>>>>>
83567>>>>>>>>>// These are not defined pre DF 18:
83567>>>>>>>>>
83567>>>>>>>>>Struct tSQLIntTableInfo
83567>>>>>>>>>    String sDriverName
83567>>>>>>>>>    String sServerName
83567>>>>>>>>>    String sDatabaseName
83567>>>>>>>>>    String sSchemaName
83567>>>>>>>>>    Boolean bRecnumTable
83567>>>>>>>>>    Integer iPrimaryIndex
83567>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
83567>>>>>>>>>    String sTableCharacterFormat
83567>>>>>>>>>    Boolean bUseDummyZeroDate
83567>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
83567>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
83567>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
83567>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
83567>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
83567>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
83567>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
83567>>>>>>>>>    String sFileIndexTablespace
83567>>>>>>>>>    String sFileLongTablespace
83567>>>>>>>>>    String sTableTablespace
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tSQLIntColumnInfo
83567>>>>>>>>>    Integer iFieldNumber
83567>>>>>>>>>    Integer iFieldIndex
83567>>>>>>>>>    Integer iFieldRelatedFile
83567>>>>>>>>>    Integer iFieldRelatedField
83567>>>>>>>>>    Integer iIndexNumber
83567>>>>>>>>>    Integer iIndexNumberSegments
83567>>>>>>>>>    Integer iIndexSegmentField1
83567>>>>>>>>>    Integer iIndexSegmentField2
83567>>>>>>>>>    Integer iIndexSegmentFieldn
83567>>>>>>>>>    String  sIndexName
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIColumn
83567>>>>>>>>>    Integer iFieldNumber
83567>>>>>>>>>    String  sFieldName
83567>>>>>>>>>    Integer iType
83567>>>>>>>>>    String  sType
83567>>>>>>>>>    Integer iLength
83567>>>>>>>>>    Integer iPrecision
83567>>>>>>>>>    Integer iOptions
83567>>>>>>>>>    Boolean bIsSQLType
83567>>>>>>>>>    Boolean bAllowNULL
83567>>>>>>>>>    String  sDefaultValue
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIColumnCompare
83567>>>>>>>>>    Integer iFieldNumber
83567>>>>>>>>>    // FROM database:
83567>>>>>>>>>    Boolean bExistsFrom
83567>>>>>>>>>    String  sFieldNameFrom
83567>>>>>>>>>    Integer iTypeFrom
83567>>>>>>>>>    String  sTypeFrom
83567>>>>>>>>>    Integer iLengthFrom
83567>>>>>>>>>    Integer iPrecisionFrom
83567>>>>>>>>>    Integer iOptionsFrom
83567>>>>>>>>>    Boolean bIsSQLTypeFrom
83567>>>>>>>>>    Boolean bAllowNULLFrom
83567>>>>>>>>>    String  sDefaultValueFrom
83567>>>>>>>>>    Boolean bShouldChangeFrom
83567>>>>>>>>>    Boolean bCancelFrom
83567>>>>>>>>>    Boolean bErrorFrom
83567>>>>>>>>>    // TO database:
83567>>>>>>>>>    Boolean bExistsTo
83567>>>>>>>>>    Integer iFieldNumberTo
83567>>>>>>>>>    String  sFieldNameTo
83567>>>>>>>>>    Integer iTypeTo
83567>>>>>>>>>    String  sTypeTo
83567>>>>>>>>>    Integer iLengthTo
83567>>>>>>>>>    Integer iPrecisionTo
83567>>>>>>>>>    Integer iOptionsTo
83567>>>>>>>>>    Boolean bIsSQLTypeTo
83567>>>>>>>>>    Boolean bAllowNULLTo
83567>>>>>>>>>    String  sDefaultValueTo
83567>>>>>>>>>    Boolean bShouldChangeTo
83567>>>>>>>>>    Boolean bCancelTo
83567>>>>>>>>>    Boolean bErrorTo
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIRelation
83567>>>>>>>>>    Handle  hTableFrom
83567>>>>>>>>>    Integer iColumnFrom
83567>>>>>>>>>    Handle  hTableTo
83567>>>>>>>>>    Integer iColumnTo
83567>>>>>>>>>    String  sLogicalNameFrom
83567>>>>>>>>>    String  sLogicalNameTo
83567>>>>>>>>>    String  sFieldNameFrom
83567>>>>>>>>>    String  sFieldNameTo
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIRelationCompare
83567>>>>>>>>>    // Common:
83567>>>>>>>>>    Handle  hTableFrom
83567>>>>>>>>>    Integer iColumnFrom
83567>>>>>>>>>    Handle  hTableTo
83567>>>>>>>>>    Integer iColumnTo
83567>>>>>>>>>    // FROM database:
83567>>>>>>>>>    Boolean bExistsFrom
83567>>>>>>>>>    String  sLogicalNameFrom_From
83567>>>>>>>>>    String  sLogicalNameTo_From
83567>>>>>>>>>    String  sFieldNameFrom_From
83567>>>>>>>>>    String  sFieldNameTo_From
83567>>>>>>>>>    Boolean bShouldChange_From
83567>>>>>>>>>    Boolean bCancel_From
83567>>>>>>>>>    Boolean bError_From
83567>>>>>>>>>    // TO database:
83567>>>>>>>>>    Boolean bExistsTo
83567>>>>>>>>>    String  sLogicalNameFrom_To
83567>>>>>>>>>    String  sLogicalNameTo_To
83567>>>>>>>>>    String  sFieldNameFrom_To
83567>>>>>>>>>    String  sFieldNameTo_To
83567>>>>>>>>>    Boolean bShouldChange_To
83567>>>>>>>>>    Boolean bCancel_To
83567>>>>>>>>>    Boolean bError_To
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIIndexSegment
83567>>>>>>>>>    Integer iFieldNumber
83567>>>>>>>>>    String  sFieldName
83567>>>>>>>>>    Boolean bUppercase
83567>>>>>>>>>    Boolean bAscending
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIIndex
83567>>>>>>>>>    Integer iIndexNumber
83567>>>>>>>>>    Integer iPrimaryIndex
83567>>>>>>>>>    String  sSQLIndexName
83567>>>>>>>>>    Integer iSQLIndexType
83567>>>>>>>>>    Boolean bIsSQLClustered
83567>>>>>>>>>    Boolean bIsSQLPrimaryKey
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPIIndexCompare
83567>>>>>>>>>    // Common:
83567>>>>>>>>>    Integer iIndexNumber
83567>>>>>>>>>    // FROM database:
83567>>>>>>>>>    Boolean bExistsFrom
83567>>>>>>>>>    Integer iPrimaryIndexFrom
83567>>>>>>>>>    String  sSQLIndexNameFrom
83567>>>>>>>>>    Integer iSQLIndexTypeFrom
83567>>>>>>>>>    Boolean bIsSQLClusteredFrom
83567>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
83567>>>>>>>>>    Boolean bShouldChangeFrom
83567>>>>>>>>>    Boolean bCancelFrom
83567>>>>>>>>>    Boolean bErrorFrom
83567>>>>>>>>>    // TO database:
83567>>>>>>>>>    Boolean bExistsTo
83567>>>>>>>>>    Integer iPrimaryIndexTo
83567>>>>>>>>>    String  sSQLIndexNameTo
83567>>>>>>>>>    Integer iSQLIndexTypeTo
83567>>>>>>>>>    Boolean bIsSQLClusteredTo
83567>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
83567>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
83567>>>>>>>>>    Boolean bShouldChangeTo
83567>>>>>>>>>    Boolean bCancelTo
83567>>>>>>>>>    Boolean bErrorTo
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPITableNameInfo
83567>>>>>>>>>    Integer iTableNumber
83567>>>>>>>>>    String  sRootName
83567>>>>>>>>>    String  sLogicalName
83567>>>>>>>>>    String  sDisplayName
83567>>>>>>>>>    String  sDriverID
83567>>>>>>>>>    Boolean bIsAlias
83567>>>>>>>>>    Boolean bIsSQL
83567>>>>>>>>>    Boolean bIsSystemFile
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPITableNameInfoCompare
83567>>>>>>>>>    Integer iTableNumber
83567>>>>>>>>>    // FROM
83567>>>>>>>>>    Boolean bExistsFrom
83567>>>>>>>>>    String  sRootNameFrom
83567>>>>>>>>>    String  sLogicalNameFrom
83567>>>>>>>>>    String  sDisplayNameFrom
83567>>>>>>>>>    String  sDriverIDFrom
83567>>>>>>>>>    Boolean bIsAliasFrom
83567>>>>>>>>>    Boolean bIsSQLFrom
83567>>>>>>>>>    Boolean bIsSystemFileFrom
83567>>>>>>>>>    // TO database:
83567>>>>>>>>>    Boolean bExistsTo
83567>>>>>>>>>    String  sRootNameTo
83567>>>>>>>>>    String  sLogicalNameTo
83567>>>>>>>>>    String  sDisplayNameTo
83567>>>>>>>>>    String  sDriverIDTo
83567>>>>>>>>>    Boolean bIsAliasTo
83567>>>>>>>>>    Boolean bIsSQLTo
83567>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPITable
83567>>>>>>>>>    Handle hTable
83567>>>>>>>>>    Boolean bFromTable
83567>>>>>>>>>    Boolean bToTable
83567>>>>>>>>>    tAPITableNameInfo ApiTableInfo
83567>>>>>>>>>    tAPITableNameInfo ApiTableInfo
83567>>>>>>>>>    tAPIColumn[]      aApiColumns
83567>>>>>>>>>    tAPIColumn[]      aApiColumns
83567>>>>>>>>>    tAPIIndex[]       aApiIndexes
83567>>>>>>>>>    tAPIIndex[]       aApiIndexes
83567>>>>>>>>>    tAPIRelation[]    aApiRelations
83567>>>>>>>>>    tAPIRelation[]    aApiRelations
83567>>>>>>>>>    Boolean bShouldChange
83567>>>>>>>>>    Boolean bCancel
83567>>>>>>>>>    Boolean bError
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPITableCompare
83567>>>>>>>>>    Handle hTable
83567>>>>>>>>>    // FROM database:
83567>>>>>>>>>    Boolean bExistsFrom
83567>>>>>>>>>    // TO database:
83567>>>>>>>>>    Boolean bExistsTo
83567>>>>>>>>>    // Both:
83567>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
83567>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
83567>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
83567>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
83567>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
83567>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
83567>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
83567>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
83567>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
83567>>>>>>>>>    Boolean bCancel         // User cancel
83567>>>>>>>>>    Boolean bError          // Error occured while collecting data
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Struct tAPITableBooleans
83567>>>>>>>>>    Boolean bApiTableUpdateAuto
83567>>>>>>>>>    Boolean bCompareDate_DateTime
83567>>>>>>>>>    Boolean bCompareIndexAscending
83567>>>>>>>>>    Boolean bCompareIndexUppercase
83567>>>>>>>>>    Boolean bCompareFilelistUppercase
83567>>>>>>>>>End_Struct
83567>>>>>>>>>
83567>>>>>>>>>Define C_tAPIColumn_None for 0
83567>>>>>>>>>Define C_tAPIColumn_Identity for 1
83567>>>>>>>>>
83567>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
83567>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
83567>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
83567>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
83567>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
83567>>>>>>>>>Enum_List
83567>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
83567>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
83567>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
83567>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
83567>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
83567>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
83567>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
83567>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
83567>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
83567>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
83567>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
83567>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
83567>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
83567>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
83567>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
83567>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
83567>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
83567>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
83567>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
83567>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
83567>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
83567>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
83567>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
83567>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
83567>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
83567>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
83567>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
83567>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
83567>>>>>>>>>    Define CI_SQLTo                    //for "TO"
83567>>>>>>>>>    Define CI_SQLGO                    //for "GO"
83567>>>>>>>>>    Define CI_SQLUse                   //for "USE"
83567>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
83567>>>>>>>>>
83567>>>>>>>>>    Define CI_SQLName                  //for "NAME"
83567>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
83567>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
83567>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
83567>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
83567>>>>>>>>>    Define CI_SQLID                    //for "ID"
83567>>>>>>>>>    Define CI_SQLAND                   //for "AND"
83567>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
83567>>>>>>>>>    Define CI_SQLSet                   //for "SET"
83567>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
83567>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
83567>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
83567>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
83567>>>>>>>>>End_Enum_List
83567>>>>>>>>>
83567>>>>>>>>>
83567>>>>>
83567>>>>>// This needs to be after Mertech drivers are defined.
83567>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
83567>>>>>
83567>>>>>
83567>>>>>// Create a new PSQL identifier for the Btrieve driver.
83567>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
83567>>>>>
83567>>>>>
83567>>>>>
83567>>>>>
83567>>>>>
83567>>>>>
83567>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
83567>>>>>// They can have slightly different SQL keywords.
83567>>>>>// Note: If a new type is added to the list,
83567>>>>>//       the struct array xxx must be adjusted
83567>>>>>//       so that it is filled with all SQL
83567>>>>>//       keywords for that new type.
83567>>>>>Enum_List  
83567>>>>>End_Enum_List
83567>>>>>
83567>>>>>// We need to have our "own" constants for the standard DataFlex data types.
83567>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
83567>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
83567>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
83567>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
83567>>>>>Define CS_DbTypeMySQL       for "MySQL"
83567>>>>>Define CS_DbTypeOracle      for "Oracle"
83567>>>>>Define CS_DbTypeDB2         for "IBM DB2"
83567>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
83567>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
83567>>>>>
83567>>>>>
83567>>>>>// SQLConnection.ini constants:
83567>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
83567>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
83567>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
83567>>>>>Define CS_SQLIniSectionName             for "Connection"
83567>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
83567>>>>>
83567>>>>>// DF 19 ini-file settings:
83567>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
83567>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
83567>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
83567>>>>>Define CS_SQLIniUIDKeyword              for "UID"
83567>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
83567>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
83567>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
83567>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
83567>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
83567>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
83567>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
83567>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
83567>>>>>
83567>>>>>// Database Update Framework extended settings:
83567>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
83567>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
83567>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
83567>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
83567>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
83567>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
83567>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
83567>>>>>
83567>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
83567>>>>>Define CS_SQLIniConnectionYes           for "Yes"
83567>>>>>Define CS_SQLIniConnectionNo            for "No"
83567>>>>>
83567>>>>>Struct tSQLConnection
83567>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
83567>>>>>    String sConnectionID            // 2. The name of the connection ID.
83567>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
83567>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
83567>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
83567>>>>>    String sDatabase                // 6. SQL Database
83567>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
83567>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
83567>>>>>    String sUserID                  // 9. User ID
83567>>>>>    String sPassword                // 10. Password
83567>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
83567>>>>>    String sBaseTableSpace          // 12. DB2 specific
83567>>>>>    String sLongTableSpace          // 13. DB2 specific
83567>>>>>    String sIndexTableSpace         // 14. DB2 specific
83567>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
83567>>>>>    Boolean bError                  // 16. Set to true on error.
83567>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
83567>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
83567>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
83567>>>>>End_Struct
83567>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
83567>>>>>Use cSQLConnectionIniFile.inc
83567>>>>>
83567>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
83568>>>>>    Procedure Construct_Object
83570>>>>>        Forward Send Construct_Object
83572>>>>>        Property String psDriverID DATAFLEX_ID
83573>>>>>    End_Procedure
83574>>>>>
83574>>>>>    Function ServerKeyword String sServer Returns String
83576>>>>>        String sRetval
83576>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
83578>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
83579>>>>>        End                                        
83579>>>>>>
83579>>>>>        Else Begin
83580>>>>>            Move CS_SQLIniDSNKeyword to sRetval
83581>>>>>        End
83581>>>>>>
83581>>>>>            
83581>>>>>        Function_Return sRetval
83582>>>>>    End_Function
83583>>>>>
83583>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83585>>>>>        String sConnect sServerKeyWord sDriverID
83585>>>>>
83585>>>>>        Get psDriverID to sDriverID
83586>>>>>        Get ServerKeyword sServer to sServerKeyWord
83587>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
83588>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
83590>>>>>            Move "" to sDatabase
83591>>>>>        End
83591>>>>>>
83591>>>>>        
83591>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
83591>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
83591>>>>>//            Function_Return sConnect
83591>>>>>//        End
83591>>>>>
83591>>>>>        If (sDatabase <> "") Begin
83593>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83594>>>>>        End
83594>>>>>>
83594>>>>>        If (bTrusted = True) Begin
83596>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83597>>>>>        End
83597>>>>>>
83597>>>>>        Else Begin
83598>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83599>>>>>        End
83599>>>>>>
83599>>>>>        Function_Return sConnect
83600>>>>>    End_Function
83601>>>>>
83601>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83603>>>>>        Boolean bLoginSuccessful
83603>>>>>        String sDriverID
83603>>>>>
83603>>>>>        Get psDriverID to sDriverID
83604>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
83606>>>>>            Function_Return True
83607>>>>>        End
83607>>>>>>
83607>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
83608>>>>>        If (bTrusted = False and sDatabase <> "") Begin
83610>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
83611>>>>>            Login sServer sUserId sPassword sDriverID  
83613>>>>>        End
83613>>>>>>
83613>>>>>        Else Begin
83614>>>>>            Login sConnectionString "" "" sDriverID
83616>>>>>        End
83616>>>>>>
83616>>>>>        Move (LastErr = 0) to bLoginSuccessful
83617>>>>>        Function_Return bLoginSuccessful
83618>>>>>    End_Function
83619>>>>>End_Class
83620>>>>>
83620>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
83621>>>>>    Function ServerKeyword String sServer Returns String
83623>>>>>        Function_Return CS_SQLIniServerKeyword
83624>>>>>    End_Function
83625>>>>>End_Class
83626>>>>>
83626>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
83627>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83629>>>>>        Boolean bLoginSuccessful
83629>>>>>        String sDriverID
83629>>>>>
83629>>>>>        Get psDriverID to sDriverID
83630>>>>>        Move (Trim(sDriverID)) to sDriverID
83631>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
83633>>>>>            Function_Return True
83634>>>>>        End
83634>>>>>>
83634>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
83635>>>>>        If (bTrusted = False) Begin
83637>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
83639>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
83640>>>>>            End
83640>>>>>>
83640>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
83643>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
83644>>>>>            End
83644>>>>>>
83644>>>>>            Login sServer sUserId sPassword sDriverID  
83646>>>>>        End
83646>>>>>>
83646>>>>>        Else Begin
83647>>>>>            Login sConnectionString "" "" sDriverID
83649>>>>>        End
83649>>>>>>
83649>>>>>        Move (LastErr = 0) to bLoginSuccessful
83650>>>>>
83650>>>>>        Function_Return bLoginSuccessful
83651>>>>>    End_Function
83652>>>>>End_Class
83653>>>>>
83653>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
83654>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83656>>>>>        Boolean bLoginSuccessful
83656>>>>>        String sDriverID
83656>>>>>
83656>>>>>        Move False to Err
83657>>>>>        Get psDriverID to sDriverID
83658>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
83660>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
83661>>>>>        End
83661>>>>>>
83661>>>>>        Login sServer sUserId sPassword sDriverID
83663>>>>>
83663>>>>>        Move (not(Err)) to bLoginSuccessful
83664>>>>>        Function_Return bLoginSuccessful
83665>>>>>    End_Function
83666>>>>>End_Class
83667>>>>>
83667>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
83668>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83670>>>>>        Boolean bLoginSuccessful
83670>>>>>        String sDriverID
83670>>>>>
83670>>>>>        Move False to Err
83671>>>>>        Get psDriverID to sDriverID
83672>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
83672>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
83672>>>>>//        End
83672>>>>>        Login sServer sUserId sPassword sDriverID
83674>>>>>
83674>>>>>        Move (not(Err)) to bLoginSuccessful
83675>>>>>        Function_Return bLoginSuccessful
83676>>>>>    End_Function
83677>>>>>End_Class
83678>>>>>
83678>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
83679>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83681>>>>>        Function_Return ""
83682>>>>>    End_Function
83683>>>>>End_Class
83684>>>>>
83684>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
83685>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83687>>>>>        Boolean bLoginSuccessful
83687>>>>>        String sDriverID
83687>>>>>
83687>>>>>        Get psDriverID to sDriverID
83688>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
83688>>>>>        Move False to Err
83689>>>>>        If (bTrusted = False) Begin
83691>>>>>            Login sServer sUserId sPassword sDriverID
83693>>>>>        End
83693>>>>>>
83693>>>>>        Else Begin
83694>>>>>            Login sServer "" "" sDriverID
83696>>>>>        End
83696>>>>>>
83696>>>>>        Move (not(Err)) to bLoginSuccessful
83697>>>>>
83697>>>>>        Function_Return bLoginSuccessful
83698>>>>>    End_Function
83699>>>>>End_Class
83700>>>>>
83700>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
83701>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83703>>>>>        Boolean bLoginSuccessful
83703>>>>>        String sDriverID
83703>>>>>        Integer iPos
83703>>>>>
83703>>>>>        Get psDriverID to sDriverID
83704>>>>>        Move (Pos("/", sServer)) to iPos
83705>>>>>        If (iPos = 0) Begin
83707>>>>>            If (sDatabase <> "") Begin
83709>>>>>                Move (sServer + "/" + sDatabase) to sServer
83710>>>>>            End
83710>>>>>>
83710>>>>>        End
83710>>>>>>
83710>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
83710>>>>>        Move False to Err
83711>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
83711>>>>>        Login sServer sUserId sPassword sDriverID
83713>>>>>
83713>>>>>        Move (not(Err)) to bLoginSuccessful
83714>>>>>        Function_Return bLoginSuccessful
83715>>>>>    End_Function
83716>>>>>End_Class
83717>>>>>
83717>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
83718>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83720>>>>>        Boolean bLoginSuccessful
83720>>>>>        String sDriverID
83720>>>>>
83720>>>>>        Get psDriverID to sDriverID
83721>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
83721>>>>>        Move False to Err
83722>>>>>        If (bTrusted = False) Begin
83724>>>>>            Login sServer sUserId sPassword sDriverID
83726>>>>>        End
83726>>>>>>
83726>>>>>        Else Begin
83727>>>>>            Login sServer "" "" sDriverID
83729>>>>>        End
83729>>>>>>
83729>>>>>        Move (not(Err)) to bLoginSuccessful
83730>>>>>        Function_Return bLoginSuccessful
83731>>>>>    End_Function
83732>>>>>End_Class
83733>>>>>
83733>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
83734>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83736>>>>>        Boolean bLoginSuccessful
83736>>>>>        String sDriverID
83736>>>>>
83736>>>>>        Get psDriverID to sDriverID
83737>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
83737>>>>>        Move False to Err
83738>>>>>        If (bTrusted = False) Begin
83740>>>>>            Login sServer sUserId sPassword sDriverID
83742>>>>>        End
83742>>>>>>
83742>>>>>        Else Begin
83743>>>>>            Login sServer "" "" sDriverID
83745>>>>>        End
83745>>>>>>
83745>>>>>        Move (not(Err)) to bLoginSuccessful
83746>>>>>        Function_Return bLoginSuccessful
83747>>>>>    End_Function
83748>>>>>End_Class
83749>>>>>
83749>>>>>Class cDbUpdateDatabaseDriver is a cObject
83750>>>>>    Procedure Construct_Object
83752>>>>>        Forward Send Construct_Object
83754>>>>>        Property String psDriverID DATAFLEX_ID
83755>>>>>        Property Handle phoDriverSpecificObject
83756>>>>>    End_Procedure
83757>>>>>
83757>>>>>    Function CreateDriver Returns Handle
83759>>>>>        String sDriverID
83759>>>>>        Handle hoDriver hcDriverClass
83759>>>>>
83759>>>>>        Get psDriverID to sDriverID
83760>>>>>        Case Begin
83760>>>>>            Case (sDriverID = MSSQLDRV_ID)
83762>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
83763>>>>>                Case Break
83764>>>>>            Case (sDriverID = ODBC_DRV_ID)
83767>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
83768>>>>>                Case Break
83769>>>>>            Case (sDriverID = DB2_DRV_ID)
83772>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
83773>>>>>                Case Break               
83774>>>>>//            Case (sDriverID = DFBTRDRV_ID)
83774>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
83774>>>>>//                Case Break
83774>>>>>            Case (sDriverID = SQLFLEX)
83777>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
83778>>>>>                Case Break
83779>>>>>            Case (sDriverID = ORAFLEX)
83782>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
83783>>>>>                Case Break
83784>>>>>            Case (sDriverID = MDSPgSQL)
83787>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
83788>>>>>                Case Break
83789>>>>>            Case (sDriverID = MDSMySQL)
83792>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
83793>>>>>                Case Break
83794>>>>>            // DATAFLEX_ID = Default driver
83794>>>>>            Case Else
83794>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
83795>>>>>                Move DATAFLEX_ID to sDriverID
83796>>>>>        Case End
83796>>>>>
83796>>>>>        Get Create hcDriverClass to hoDriver
83797>>>>>        Set psDriverID of hoDriver to sDriverID
83798>>>>>        Set phoDriverSpecificObject to hoDriver
83799>>>>>
83799>>>>>        Function_Return hoDriver
83800>>>>>    End_Function
83801>>>>>
83801>>>>>    Procedure DestroyDriver
83803>>>>>        If (phoDriverSpecificObject(Self)) Begin
83805>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
83806>>>>>        End
83806>>>>>>
83806>>>>>    End_Procedure
83807>>>>>
83807>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83809>>>>>        String sConnect
83809>>>>>        Handle hoDriver
83809>>>>>
83809>>>>>        Get CreateDriver to hoDriver
83810>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
83811>>>>>        Send DestroyDriver
83812>>>>>        Function_Return sConnect
83813>>>>>    End_Function
83814>>>>>
83814>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
83816>>>>>        Boolean bLoginSuccessful
83816>>>>>        Handle hoDriver
83816>>>>>
83816>>>>>        Get CreateDriver to hoDriver
83817>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
83818>>>>>        Send DestroyDriver
83819>>>>>        Function_Return bLoginSuccessful
83820>>>>>    End_Function
83821>>>>>
83821>>>>>End_Class
83822>>>
83822>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cLoginEncryption.pkg)
83822>>>>>Use cCryptographerEx.pkg
83822>>>>>
83822>>>>>Class cLoginEncryption is a cObject
83823>>>>>    
83823>>>>>    Procedure Construct_Object
83825>>>>>        Forward Send Construct_Object
83827>>>>>        // this must be set to a multi (40ish) character random key
83827>>>>>        Property String psEncryptPassword ""
83828>>>>>        
83828>>>>>        Object oDataCrypter is a cCryptographerEx
83830>>>>>            Set piHash to CALG_SHA_256
83831>>>>>            Set piCipher to CALG_AES_256
83832>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
83833>>>>>            Set piProvider to PROV_RSA_AES
83834>>>>>        End_Object
83835>>>>>    End_Procedure
83836>>>>>    
83836>>>>>    // This can be augmented to return a password encryption key using any
83836>>>>>    // hidden mechanism desired.
83836>>>>>    Function GetEncryptionPassword Returns String
83838>>>>>        String sPassword
83838>>>>>        Get psEncryptPassword to sPassword
83839>>>>>        Function_Return sPassword
83840>>>>>    End_Function
83841>>>>>    
83841>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
83841>>>>>    //
83841>>>>>    // Params:
83841>>>>>    //   sPlainText     String to encrypt.
83841>>>>>    // Returns:
83841>>>>>    //   Base64 encoded hash.
83841>>>>>    Function EncryptPassword String sPlainText Returns String
83843>>>>>        String sEncryptPassword sBase64
83843>>>>>        UChar[] ucBinary
83844>>>>>        Pointer pBase64
83844>>>>>        Integer iVoid
83844>>>>>        
83844>>>>>        //  Encrypt Key
83844>>>>>        Get GetEncryptionPassword to sEncryptPassword
83845>>>>>        If (sEncryptPassword = "") Begin
83847>>>>>            Error DFERR_PROGRAM "No encryption password set"
83848>>>>>>
83848>>>>>        End
83848>>>>>>
83848>>>>>        
83848>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
83849>>>>>        
83849>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
83851>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
83852>>>>>>
83852>>>>>            Function_Return ""
83853>>>>>        End
83853>>>>>>
83853>>>>>        
83853>>>>>        //  Encode binary hash to Base64
83853>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
83854>>>>>        Move (PointerToString(pBase64)) to sBase64
83855>>>>>        Move (Free(pBase64)) to iVoid
83856>>>>>        
83856>>>>>        Function_Return sBase64
83857>>>>>    End_Function
83858>>>>>    
83858>>>>>    
83858>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
83858>>>>>    //
83858>>>>>    // Params:
83858>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
83858>>>>>    // Returns:
83858>>>>>    //   Readable plain text password
83858>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
83860>>>>>        String sEncryptPassword
83860>>>>>        UChar[] ucBinary ucPlain
83862>>>>>        Boolean bIsHex
83862>>>>>        Integer iLen iVoid
83862>>>>>        Pointer pBinary
83862>>>>>        
83862>>>>>        If (sBase64EncryptedPassword <> "") Begin
83864>>>>>            //  Decode from Base64
83864>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
83865>>>>>            
83865>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
83866>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
83867>>>>>                        
83867>>>>>            Move (Free(pBinary)) to iVoid
83868>>>>>            
83868>>>>>            //  Encrypted binary hash to string
83868>>>>>            Get GetEncryptionPassword to sEncryptPassword
83869>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
83870>>>>>        End
83870>>>>>>
83870>>>>>        
83870>>>>>        Function_Return (UCharArrayToString(ucPlain))
83871>>>>>    End_Function
83872>>>>>End_Class
83873>>>
83873>>>Class cSQLConnectionIniFile is a cIniFile
83874>>>    Procedure Construct_Object
83876>>>        Forward Send Construct_Object
83878>>>
83878>>>        Property String Private_psIniFilePath
83879>>>        Property String Private_psIniFileName CS_SQLIniFileName
83880>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
83881>>>
83881>>>        Property Boolean pbDFConnId False
83882>>>
83882>>>        // *** You really want to change this value! ***
83882>>>        // It is used when encrypting/decrypting passwords.
83882>>>        Property String psHashString "zx!2139(LI0+?ips7433"
83883>>>
83883>>>    End_Procedure
83884>>>
83884>>>    Procedure End_Construct_Object
83886>>>        Forward Send End_Construct_Object
83888>>>    End_Procedure
83889>>>
83889>>>    Procedure Set psIniFilePath String sPath
83891>>>        String sIniFile
83891>>>        Get vFolderFormat sPath to sPath
83892>>>        Set private_psIniFilePath to sPath
83893>>>        Get psIniFileName to sIniFile
83894>>>        Set psFileName to (sPath + sIniFile)
83895>>>    End_Procedure
83896>>>
83896>>>    Function psIniFilePath Returns String
83898>>>        Function_Return (private_psIniFilePath(Self))
83899>>>    End_Function
83900>>>
83900>>>    Procedure Set psIniFileName String sFileName
83902>>>        String sPath
83902>>>        Get psIniFilePath to sPath
83903>>>        Set psFileName to (sPath + sFileName)
83904>>>        Set private_psIniFileName to sFileName
83905>>>    End_Procedure
83906>>>
83906>>>    Function psIniFileName Returns String
83908>>>        Function_Return (private_psIniFileName(Self))
83909>>>    End_Function
83910>>>
83910>>>    // *** Generalized messages to Get & Set values of the ini file.
83910>>>    // Sets a value in the program's ini file (write)
83910>>>    // Pass a section name, the value name parameter and the value itself to be written.
83910>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
83912>>>        String sIniFile sPath
83912>>>
83912>>>        Get psIniFilePath to sPath
83913>>>        Get psIniFileName to sIniFile
83914>>>        Move (sPath + sIniFile) to sIniFile
83915>>>        Set psFileName to sIniFile
83916>>>        Send WriteString sSection sValueName sValue
83917>>>    End_Procedure
83918>>>
83918>>>    // Get a value from program's ini-file (read)
83918>>>    // Pass a section name and the name of the value parameter & a default value.
83918>>>    // Returns the value
83918>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
83920>>>        String sValue sIniFile sPath
83920>>>
83920>>>        Get psIniFilePath to sPath
83921>>>        Get psIniFileName to sIniFile
83922>>>        Move (sPath + sIniFile) to sIniFile
83923>>>        Set psFileName to sIniFile
83924>>>        Get ReadString sSection sValueName sDefaultValue to sValue
83925>>>
83925>>>        Function_Return sValue
83926>>>    End_Function
83927>>>
83927>>>    // Sort function that first sorts on bEnabled & then on the connection string.
83927>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
83929>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
83932>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
83935>>>
83935>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
83938>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
83941>>>
83941>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
83944>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
83947>>>
83947>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
83950>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
83953>>>
83953>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
83956>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
83959>>>
83959>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
83962>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
83965>>>
83965>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
83968>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
83971>>>
83971>>>        Function_Return (EQ)
83972>>>    End_Function
83973>>>
83973>>>    Function SQLIniFileNumberOfConnections Returns Integer
83975>>>        Handle hoSections
83975>>>        Integer iItems
83975>>>
83975>>>        Send ReadSections hoSections
83976>>>        Move (Item_Count(hoSections)) to iItems
83977>>>        Function_Return iItems
83978>>>    End_Function
83979>>>
83979>>>    // The normal connection string looks something like this;
83979>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
83979>>>    // ...but the full connection string looks like this;
83979>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
83979>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
83979>>>//        String sSection
83979>>>//        Integer iCount
83979>>>//
83979>>>//        Move False to Err
83979>>>//        Get psIniSectionName to sSection
83979>>>//        Get SQLIniFileNumberOfConnections to iCount
83979>>>//        Increment iCount
83979>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
83979>>>//
83979>>>//        Function_Return (Err = False)
83979>>>//    End_Function
83979>>>
83979>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
83981>>>        Integer iCount
83981>>>        Boolean bExists
83981>>>        String sSection
83981>>>
83981>>>        Move False to Err
83982>>>        Move 1 to iCount
83983>>>        Get psIniSectionName to sSection
83984>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
83985>>>        While (bExists = True)
83989>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
83990>>>            Increment iCount
83991>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
83992>>>        Loop
83993>>>>
83993>>>        Function_Return (Err = False)
83994>>>    End_Function
83995>>>
83995>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
83997>>>        Integer iCount
83997>>>        String sSection
83997>>>        Boolean bExists
83997>>>
83997>>>        Move False to Err
83998>>>        Move 1 to iCount
83999>>>        Get psIniSectionName to sSection
84000>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
84001>>>        While (bExists = True)
84005>>>            If (iCount = iItem) Begin
84007>>>                Send DeleteSection sSection
84008>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
84008>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
84009>>>            End
84009>>>>
84009>>>            Increment iCount
84010>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
84011>>>        Loop
84012>>>>
84012>>>
84012>>>        Function_Return (Err = False)
84013>>>    End_Function
84014>>>
84014>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
84014>>>    // If it fails the returned struct member SQLConnection.bError = True.
84014>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
84016>>>        tSQLConnection[] SQLConnectionsArray
84016>>>        tSQLConnection[] SQLConnectionsArray
84017>>>        tSQLConnection   SQLConnection
84017>>>        tSQLConnection   SQLConnection
84017>>>        Integer iIndex
84017>>>
84017>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
84018>>>        If (iIndex = -1) Begin
84020>>>            Move True to SQLConnection.bError
84021>>>            Function_Return SQLConnection
84022>>>        End
84022>>>>
84022>>>
84022>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
84023>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
84024>>>
84024>>>        Function_Return SQLConnection
84025>>>    End_Function
84026>>>
84026>>>    // Returns -1 if the passed connection ID was not found, else the item number.
84026>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
84028>>>        tSQLConnection[] SQLConnectionsArray
84028>>>        tSQLConnection[] SQLConnectionsArray
84029>>>        Integer iRetval iCount iSize
84029>>>        String sValue
84029>>>        Boolean bExists
84029>>>
84029>>>        Move -1 to iRetval
84030>>>
84030>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
84031>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
84032>>>        Decrement iSize
84033>>>        For iCount from 0 to iSize
84039>>>>
84039>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
84040>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
84041>>>            If (bExists) Begin
84043>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
84044>>>                Move iSize to iCount         // We're done!
84045>>>            End
84045>>>>
84045>>>        Loop
84046>>>>
84046>>>
84046>>>        Function_Return iRetval
84047>>>    End_Function
84048>>>
84048>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
84048>>>    // Used to check that ConnectionID's are unique.
84048>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
84050>>>        Integer iCount iSize iItems
84050>>>        String sValue
84050>>>        Boolean bExists
84050>>>        tSQLConnection[] SQLConnectionsArray
84050>>>        tSQLConnection[] SQLConnectionsArray
84051>>>
84051>>>        Move 0 to iItems
84052>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
84053>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
84054>>>        Decrement iSize
84055>>>        For iCount from 0 to iSize
84061>>>>
84061>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
84062>>>            Move (sValue = sConnectionID) to bExists
84063>>>            If (bExists) Begin
84065>>>                Increment iItems
84066>>>            End
84066>>>>
84066>>>        Loop
84067>>>>
84067>>>
84067>>>        Function_Return (iItems > 1)
84068>>>    End_Function
84069>>>
84069>>>    // To update the SQLConnections.ini file with a new default Connection ID.
84069>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
84071>>>        Boolean bOK
84071>>>        Integer iSize iCount
84071>>>        tSQLConnection[] SQLConnectionsArray
84071>>>        tSQLConnection[] SQLConnectionsArray
84072>>>        tSQLConnection SQLConnection
84072>>>        tSQLConnection SQLConnection
84072>>>        String sConnectionString
84072>>>
84072>>>        Move False to Err
84073>>>        Get psConnectionString to sConnectionString
84074>>>
84074>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
84075>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
84076>>>        Decrement iSize
84077>>>        // Set all current connection to inactive.
84077>>>        For iCount from 0 to iSize
84083>>>>
84083>>>            Move False to SQLConnectionsArray[iCount].bEnabled
84084>>>        Loop
84085>>>>
84085>>>
84085>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
84086>>>        Move True              to SQLConnection.bEnabled
84087>>>        Move sConnectionString to SQLConnection.sConnectionString
84088>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
84089>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
84090>>>
84090>>>        Function_Return (bOK = True)
84091>>>    End_Function
84092>>>
84092>>>    // Used for updating an existing connection with new data.
84092>>>    // Returns True if successful.
84092>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
84094>>>        Boolean bOK
84094>>>        Integer iItem iSize iCount
84094>>>        tSQLConnection[] SQLConnectionsArray
84094>>>        tSQLConnection[] SQLConnectionsArray
84095>>>
84095>>>        Move False to Err
84096>>>        Move -1 to iItem
84097>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
84098>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
84099>>>        Decrement iSize
84100>>>        // Set all current connection to inactive.
84100>>>        For iCount from 0 to iSize
84106>>>>
84106>>>            Move False to SQLConnectionsArray[iCount].bEnabled
84107>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
84109>>>                Move iCount to iItem
84110>>>            End
84110>>>>
84110>>>        Loop
84111>>>>
84111>>>
84111>>>        If (iItem <> -1) Begin
84113>>>            Move True to SQLConnection.bEnabled
84114>>>            Move SQLConnection to SQLConnectionsArray[iItem]
84115>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
84116>>>        End
84116>>>>
84116>>>
84116>>>        Function_Return (bOK = True)
84117>>>    End_Function
84118>>>
84118>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
84120>>>        tSQLConnection[] SQLConnectionsArray
84120>>>        tSQLConnection[] SQLConnectionsArray
84121>>>        String sSection sValue
84121>>>        Integer iCount
84121>>>        Boolean bExists
84121>>>
84121>>>        Get psIniSectionName to sSection
84122>>>        Get SectionExists sSection to bExists
84123>>>        If (bExists = False) Begin
84125>>>            Function_Return SQLConnectionsArray
84126>>>        End
84126>>>>
84126>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
84127>>>        If (bExists = True) Begin
84129>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
84130>>>>
84130>>>        End
84130>>>>
84130>>>
84130>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
84131>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
84132>>>
84132>>>        While (bExists = True)                 
84136>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
84136>>>            // We always put the enabled/active connection at the top
84136>>>//            Move (iCount = 1) to bEnabled
84136>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
84136>>>
84136>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
84137>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
84138>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
84139>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
84140>>>
84140>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
84140>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
84141>>>            If (sValue = "99") Begin
84143>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
84144>>>            End
84144>>>>
84144>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
84145>>>
84145>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
84146>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
84147>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
84149>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
84150>>>            End
84150>>>>
84150>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
84152>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
84153>>>            End
84153>>>>
84153>>>
84153>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
84154>>>
84154>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
84155>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
84156>>>
84156>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
84157>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
84158>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
84160>>>                Get DecryptPassword sValue to sValue
84161>>>            End
84161>>>>
84161>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
84162>>>
84162>>>            // Here we reconstruct the connection string to be complete with all params;
84162>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
84163>>>
84163>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
84164>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
84165>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
84166>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
84167>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
84168>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
84169>>>
84169>>>            Increment iCount
84170>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
84171>>>        Loop
84172>>>>
84172>>>
84172>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
84172>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
84174>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
84175>>>        End
84175>>>>
84175>>>
84175>>>        Function_Return SQLConnectionsArray
84176>>>    End_Function
84177>>>
84177>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
84179>>>        Integer iCount iSize
84179>>>        Boolean bOK
84179>>>        String sSection sValue
84179>>>
84179>>>        // First we need to _remove_ all current connections from the ini-file.
84179>>>        Move 0 to iCount
84180>>>        Get SQLIniFileDeleteAllConnections to bOK
84181>>>        If (bOK = False) Begin
84183>>>            Function_Return False
84184>>>        End
84184>>>>
84184>>>
84184>>>        Move False to Err
84185>>>        Get psIniSectionName to sSection
84186>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
84186>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
84187>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
84188>>>        Decrement iSize
84189>>>
84189>>>        For iCount from 0 to iSize
84195>>>>
84195>>>            // DF 19 compatible settings:
84195>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
84196>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
84197>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
84198>>>            
84198>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
84199>>>
84199>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
84200>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
84202>>>                Get EncryptPassword sValue to sValue
84203>>>            End
84203>>>>
84203>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
84204>>>
84204>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
84206>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
84207>>>            End
84207>>>>
84207>>>
84207>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
84208>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
84209>>>
84209>>>            // The Database Update Framework extended settings:
84209>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
84210>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
84211>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
84212>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
84213>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
84214>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
84215>>>        Loop
84216>>>>
84216>>>
84216>>>        Function_Return (bOK and Err = False)
84217>>>    End_Function
84218>>>
84218>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
84218>>>    //
84218>>>    // SQL utility function that returns a database type (string) constant
84218>>>    // corresponding to the passed iDbType.
84218>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
84220>>>        String sRetval
84220>>>        If (iDbType = EN_dbTypeMSSQL) Begin
84222>>>            Move CS_dbTypeMSSQL to sRetval
84223>>>        End
84223>>>>
84223>>>        If (iDbType = EN_dbTypeMySQL) Begin
84225>>>            Move CS_dbTypeMySQL to sRetval
84226>>>        End
84226>>>>
84226>>>        If (iDbType = EN_dbTypeOracle) Begin
84228>>>            Move CS_dbTypeOracle to sRetval
84229>>>        End
84229>>>>
84229>>>        If (iDbType = EN_dbTypeDB2) Begin
84231>>>            Move CS_dbTypeDB2 to sRetval
84232>>>        End
84232>>>>
84232>>>        If (iDbType = EN_dbTypePostgre) Begin
84234>>>            Move CS_dbTypePostgre to sRetval
84235>>>        End
84235>>>>
84235>>>        If (iDbType = EN_DbTypePervasive) Begin
84237>>>            Move CS_DbTypePervasive to sRetval
84238>>>        End
84238>>>>
84238>>>        Function_Return sRetval
84239>>>    End_Function
84240>>>
84240>>>    // SQL utility function that returns a database type constant (integer)
84240>>>    // corresponding to the passed sDbType string constant.
84240>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
84242>>>        Integer iRetval
84242>>>        If (sDbType = CS_dbTypeMSSQL) Begin
84244>>>            Move EN_dbTypeMSSQL to iRetval
84245>>>        End
84245>>>>
84245>>>        If (sDbType = CS_dbTypeMySQL) Begin
84247>>>            Move EN_dbTypeMySQL to iRetval
84248>>>        End
84248>>>>
84248>>>        If (sDbType = CS_dbTypeOracle) Begin
84250>>>            Move EN_dbTypeOracle to iRetval
84251>>>        End
84251>>>>
84251>>>        If (sDbType = CS_dbTypeDB2) Begin
84253>>>            Move EN_dbTypeDB2 to iRetval
84254>>>        End
84254>>>>
84254>>>        If (sDbType = CS_dbTypePostgre) Begin
84256>>>            Move EN_dbTypePostgre to iRetval
84257>>>        End
84257>>>>
84257>>>        If (sDbType = CS_DbTypePervasive) Begin
84259>>>            Move EN_DbTypePervasive to iRetval
84260>>>        End
84260>>>>
84260>>>        Function_Return iRetval
84261>>>    End_Function
84262>>>
84262>>>    // Pass an integer DbType and function returns the database type integer as a string value.
84262>>>    // Used e.g. when reading a connection ini-file to display the database type in
84262>>>    // the SQL Connection program's grid.
84262>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
84264>>>        String sRetval
84264>>>        If (iDbType = EN_dbTypeMSSQL) Begin
84266>>>            Move "EN_dbTypeMSSQL" to sRetval
84267>>>        End
84267>>>>
84267>>>        If (iDbType = EN_dbTypeMySQL) Begin
84269>>>            Move "EN_dbTypeMySQL" to sRetval
84270>>>        End
84270>>>>
84270>>>        If (iDbType = EN_dbTypeOracle) Begin
84272>>>            Move "EN_dbTypeOracle" to sRetval
84273>>>        End
84273>>>>
84273>>>        If (iDbType = EN_dbTypeDB2) Begin
84275>>>            Move "EN_dbTypeDB2" to sRetval
84276>>>        End
84276>>>>
84276>>>        If (iDbType = EN_dbTypePostgre) Begin
84278>>>            Move "EN_dbTypePostgre" to sRetval
84279>>>        End
84279>>>>
84279>>>        If (iDbType = EN_DbTypePervasive) Begin
84281>>>            Move "EN_dbTypePervasive" to sRetval
84282>>>        End
84282>>>>
84282>>>        Function_Return sRetval
84283>>>    End_Function
84284>>>
84284>>>    // Pass a driver id and the function will return
84284>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
84284>>>    // quite work and always returns "MS SQL Server"
84284>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
84286>>>        Integer iRetval
84286>>>        If (sDriverID = MSSQLDRV_ID) Begin
84288>>>            Move EN_dbTypeMSSQL to iRetval
84289>>>        End
84289>>>>
84289>>>        If (sDriverID = SQLFLEX) Begin
84291>>>            Move EN_dbTypeMSSQL to iRetval
84292>>>        End
84292>>>>
84292>>>        If (sDriverID = ODBC_DRV_ID) Begin
84294>>>            Move EN_dbTypeMSSQL to iRetval
84295>>>        End
84295>>>>
84295>>>        If (sDriverID = MDSMySQL) Begin
84297>>>            Move EN_dbTypeMySQL to iRetval
84298>>>        End
84298>>>>
84298>>>        If (sDriverID = ORAFLEX) Begin
84300>>>            Move EN_dbTypeOracle to iRetval
84301>>>        End
84301>>>>
84301>>>        If (sDriverID = DB2_DRV_ID) Begin
84303>>>            Move EN_dbTypeDB2 to iRetval
84304>>>        End
84304>>>>
84304>>>        If (sDriverID = MDSPgSQL) Begin
84306>>>            Move EN_dbTypePostgre to iRetval
84307>>>        End
84307>>>>
84307>>>        If (sDriverID = DFBTRDRV_ID) Begin
84309>>>            Move EN_DbTypePervasive to iRetval
84310>>>        End
84310>>>>
84310>>>        Function_Return iRetval
84311>>>    End_Function
84312>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
84312>>>>
84312>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
84314>>>>    Integer iStart iEnd
84314>>>>    String sRetval
84314>>>>
84314>>>>    Move (Trim(sConnect)) to sConnect
84315>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
84316>>>>    If (iStart = 0) Begin
84318>>>>        Function_Return ""
84319>>>>    End
84319>>>>>
84319>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84320>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84321>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84323>>>>        Move (Pos(",", sRetval))          to iEnd
84324>>>>    End
84324>>>>>
84324>>>>    Else Begin
84325>>>>        Move (Pos(";", sRetval))          to iEnd
84326>>>>    End
84326>>>>>
84326>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84328>>>>        Move (Pos(",", sRetval))          to iEnd
84329>>>>        Decrement iEnd
84330>>>>    End
84330>>>>>
84330>>>>    If (iEnd <> 0) Begin
84332>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84333>>>>    End
84333>>>>>
84333>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84334>>>>
84334>>>>    Function_Return (Trim(sRetval))
84335>>>>End_Function
84336>>>>
84336>>>>
84336>>>
84336>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
84338>>>        String sConnect
84338>>>        Handle hoDriver
84338>>>
84338>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
84339>>>        Set psDriverID of hoDriver to sDriverID
84340>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
84341>>>        Send Destroy of hoDriver
84342>>>
84342>>>        Function_Return sConnect
84343>>>    End_Function
84344>>>
84344>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
84344>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
84346>>>        String sConnect
84346>>>
84346>>>        Case Begin
84346>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
84348>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
84349>>>                If (sDatabase <> "") Begin
84351>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84352>>>                End
84352>>>>
84352>>>                Case Break
84353>>>
84353>>>            Case (sDriverID = ODBC_DRV_ID)
84356>>>                If (Uppercase(sServer) contains ".DSN") Begin
84358>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
84359>>>                End
84359>>>>
84359>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
84362>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
84363>>>                End
84363>>>>
84363>>>
84363>>>                If (sDatabase <> "") Begin
84365>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84366>>>                End
84366>>>>
84366>>>                Case Break
84367>>>
84367>>>            Case (sDriverID = DB2_DRV_ID)
84370>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
84371>>>                If (sDatabase <> "") Begin
84373>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84374>>>                End
84374>>>>
84374>>>                Case Break
84375>>>
84375>>>            Case (sDriverID = ORAFLEX)
84378>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
84379>>>                If (sDatabase <> "") Begin
84381>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84382>>>                End
84382>>>>
84382>>>                Case Break
84383>>>
84383>>>            Case (sDriverID = MDSPgSQL)
84386>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
84387>>>                If (sDatabase <> "") Begin
84389>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84390>>>                End
84390>>>>
84390>>>                Case Break
84391>>>
84391>>>            Case (sDriverID = MDSMySQL)
84394>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
84395>>>                If (sDatabase <> "") Begin
84397>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84398>>>                End
84398>>>>
84398>>>                Case Break
84399>>>
84399>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
84402>>>                Break
84403>>>
84403>>>            Case Else
84403>>>                Move "" to sConnect
84404>>>        Case End
84404>>>
84404>>>        Function_Return sConnect
84405>>>    End_Function
84406>>>
84406>>>    // Use Base64
84406>>>    Function EncryptPassword String sPassword Returns String
84408>>>        String sRetval
84408>>>        Handle hoLoginEncryption
84408>>>
84408>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
84409>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
84410>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
84411>>>        Send Destroy of hoLoginEncryption
84412>>>          
84412>>>        Function_Return sRetval
84413>>>    End_Function
84414>>>
84414>>>    Function DecryptPassword String sPassword Returns String
84416>>>        String sRetval
84416>>>        Handle hoLoginEncryption
84416>>>
84416>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
84417>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
84418>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
84419>>>        Send Destroy of hoLoginEncryption
84420>>>
84420>>>        Function_Return sRetval
84421>>>    End_Function
84422>>>
84422>>>    // Returns the full path of the Application (no trailing "\")
84422>>>    Function ApplicationPath Returns String
84424>>>        String sApplicationFileName sPath
84424>>>        Integer iNumChars iRetval
84424>>>
84424>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
84425>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
84426>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
84427>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
84428>>>        Move (CString(sApplicationFileName)) to sPath
84429>>>
84429>>>        Function_Return sPath
84430>>>    End_Function
84431>>>
84431>>>    // Pass a filename including the extension. The return value
84431>>>    // will be the path of of the first found "sSearchFileName in the workspace.
84431>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
84431>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
84433>>>        Boolean bExists
84433>>>        Handle hoPaths hoIniFile
84433>>>        String[] asWorkSpaceFiles
84434>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
84434>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
84434>>>        
84434>>>        Get psIniFilePath to sProgramsPath
84435>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
84436>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
84437>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
84438>>>        If (bExists = True) Begin
84440>>>            Function_Return sProgramsPath
84441>>>        End                      
84441>>>>
84441>>>    
84441>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
84442>>>        If (Right(sProgramsPath, 1) ="\") Begin
84444>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
84445>>>        End                                              
84445>>>>
84445>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
84446>>>        
84446>>>        Move False to bExists
84447>>>        Get Create (RefClass(Array)) to hoPaths
84448>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
84449>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
84450>>>        Decrement iSize       
84451>>>        
84451>>>        For iCount from 0 to iSize
84457>>>>
84457>>>            Move asWorkspaceFiles[iCount] to sFileName
84458>>>            Get Create (Refclass(cIniFile)) to hoIniFile
84459>>>            Set psFileName of hoIniFile to sFileName
84460>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
84461>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
84467>>>>
84467>>>                Get Value of hoPaths iPath to sSection    
84468>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
84469>>>                // Check if there are more than one path specified;
84469>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
84470>>>                If (iNoOfPaths > 1) Begin         
84472>>>                    Move sRelativePath to sRelativePaths
84473>>>                    For iCountPath from 1 to iNoOfPaths
84479>>>>
84479>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
84480>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
84481>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
84482>>>                        Get vFolderFormat sPath to sPath
84483>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
84484>>>                        If (bExists = True) Begin
84486>>>                            Move iNoOfPaths to iCountPath
84487>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
84488>>>                            Move iSize to iCount
84489>>>                        End                                                    
84489>>>>
84489>>>                    Loop
84490>>>>
84490>>>                End
84490>>>>
84490>>>                Else Begin
84491>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
84492>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
84493>>>                    Get vFolderFormat sPath to sPath
84494>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
84495>>>                    If (bExists = True) Begin
84497>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
84498>>>                        Move iSize to iCount
84499>>>                    End                                                    
84499>>>>
84499>>>                End
84499>>>>
84499>>>            Loop
84500>>>>
84500>>>            If (bExists = False) Begin
84502>>>                Move "" to sPath    
84503>>>            End
84503>>>>
84503>>>            Send Destroy of hoIniFile          
84504>>>        Loop        
84505>>>>
84505>>>        Send Destroy of hoPaths
84506>>>        
84506>>>        // Then not found in workspace, look for the file in DFSysPath;
84506>>>        If (sPath = "") Begin
84508>>>            Get_File_Path sSearchFileName to sFileName   
84509>>>            Get ParseFolderName sFileName to sPath
84510>>>        End                  
84510>>>>
84510>>>        
84510>>>        Function_Return sPath    
84511>>>    End_Function
84512>>>    
84512>>>    // Pass the path to the workspace Programs folder - returns a string array
84512>>>    // with one or more .ws file names.
84512>>>    // First checks if there is a .sws file - and if so reads the name of the
84512>>>    // workspace file (.ws) and returns it as a string array.
84512>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
84512>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
84514>>>        String[] asSWSFiles asWorkspaceFiles   
84516>>>        String sFile sHomePath sDirSep
84516>>>        Integer iCh iSize
84516>>>        Boolean bExists      
84516>>>        Handle hoIniFile 
84516>>>        
84516>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
84517>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
84518>>>        If (Right(sProgramsPath, 1) ="\") Begin
84520>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
84521>>>        End                                              
84521>>>>
84521>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
84522>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
84523>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
84524>>>        Get vFolderFormat sHomePath to sHomePath 
84525>>>        
84525>>>        // First check if theres an .sws file. If there is we will open it and
84525>>>        // read the name of the .ws file name.
84525>>>        File_Exist (sHomePath + "*.sws") bExists
84526>>>        If (bExists = True) Begin
84528>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
84529>>>            If (iCh < 0) Begin
84531>>>                Function_Return asSWSFiles
84532>>>            End                                 
84532>>>>
84532>>>            
84532>>>            Repeat
84532>>>>
84532>>>                Readln channel iCh sFile
84534>>>                If (Trim(sFile) <> "") Begin
84536>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
84537>>>                End
84537>>>>
84537>>>            Until (SeqEof = True)
84539>>>            Send Seq_Close_Channel iCh    
84540>>>            
84540>>>            Move (SizeOfArray(asSWSFiles)) to iSize
84541>>>            If (iSize <> 0) Begin
84543>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
84544>>>                // Use the file with that is last as it might have the DataFlex version in it,
84544>>>                // and thus is the latest one and it is more likely it is accurate (?)...
84544>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
84545>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
84546>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
84547>>>                If (sFile <> "") Begin
84549>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
84550>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
84551>>>                    File_Exist sFile bExists
84552>>>                    If (bExists = True) Begin
84554>>>                        Move sFile to asWorkspaceFiles[0] 
84555>>>                    End
84555>>>>
84555>>>                End
84555>>>>
84555>>>                Send Destroy of hoIniFile
84556>>>            End
84556>>>>
84556>>>        End
84556>>>>
84556>>>        
84556>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
84556>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
84558>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
84559>>>            File_Exist (sProgramsPath + "*.ws") bExists
84560>>>            If (bExists = False) Begin
84562>>>                Function_Return asWorkspaceFiles
84563>>>            End
84563>>>>
84563>>>        
84563>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
84564>>>            If (iCh < 0) Begin
84566>>>                Function_Return asWorkspaceFiles
84567>>>            End                                 
84567>>>>
84567>>>            
84567>>>            Repeat
84567>>>>
84567>>>                Readln channel iCh sFile
84569>>>                If (Trim(sFile) <> "") Begin
84571>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
84572>>>                End
84572>>>>
84572>>>            Until (SeqEof = True)
84574>>>            Send Seq_Close_Channel iCh
84575>>>        End
84575>>>>
84575>>>        
84575>>>        Function_Return asWorkspaceFiles
84576>>>    End_Function
84577>>>
84577>>>End_Class
84578>
84578>Object oHtmlHelp is a cHtmlHelp
84580>    Set pbAlwaysOnTop to False
84581>End_Object
84582>
84582>Object oApplication is a cApplication
84584>    Set peHelpType to htHtmlHelp
84585>    Set psHelpFile to "Developer5.chm"
84586>    Set psCompany to "RDC Tools International"
84587>    Set psProduct to "DUF - SQL Connections Manager"
84588>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
84589>    Set psAutoOpenWorkspace to ""
84590>
84590>    Property String psCommandLineIniFilePath ""
84592>    Property Boolean pbIniFileExists False     
84594>    Property Handle phoMainView 0
84596>
84596>    // If the folder contains exactly one workspace file (*.ws), it will be
84596>    // returned. Else an empty string ("") will be returned.
84596>    Function FindWorkspaceFile String sPath Returns String
84599>        String sSingleWorkspaceFile
84599>        Handle hoSQLIniFile                  
84599>        String[] aWsFiles
84600>        Integer iSize
84600>        
84600>        Get Create (RefClass(cSQLConnectionIniFile)) to hoSQLIniFile
84601>        Get WorkspaceIniFiles of hoSQLIniFile sPath to aWsFiles
84602>        Move (SizeOfArray(aWsFiles)) to iSize
84603>        If (iSize = 1) Begin
84605>            Move aWsFiles[0] to sSingleWorkspaceFile
84606>        End                    
84606>        Else Begin
84607>            Move "" to sSingleWorkspaceFile
84608>        End
84608>        Send Destroy of hoSQLIniFile      
84609>        Function_Return sSingleWorkspaceFile
84610>    End_Function
84611>
84611>    Procedure OnCreate
84614>        Integer eOpened
84614>        Handle hoCmdLine
84614>        String sArgument sPath sFileName sWsFile
84614>        Integer iRetval
84614>        Boolean bExists
84614>
84614>        Get phoCommandLine to hoCmdLine
84615>        Get Argument of hoCmdLine 1 to sArgument
84616>        If (sArgument <> "") Begin
84618>            Get ParseFolderName sArgument to sPath
84619>            Get vFolderExists sPath to iRetval
84620>            If (iRetval = True) Begin
84622>                Set psCommandLineIniFilePath to sPath
84623>                Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
84624>                Set pbIniFileExists to bExists
84625>            End
84625>        End
84625>
84625>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
84626>        If (eOpened <> wsWorkspaceOpened) Begin
84628>            Get GetApplicationPath to sPath     
84629>            Get FindWorkspaceFile sPath to sWsFile
84630>            If (sWsFile = "") Begin
84632>                Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
84633>                Get vFilePathExists sWsFile to bExists
84634>                If (bExists = False) Begin
84636>                    Send Stop_Box "No Workspace file selected. Cannot continue!"
84637>                    Send Exit_Application
84638>                End
84638>            End
84638>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
84639>            If (eOpened <> wsWorkspaceOpened) Begin
84641>                Set psHome          of (phoWorkspace(Self)) to sPath
84642>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
84643>                Set psDataPath      of (phoWorkspace(Self)) to sPath
84644>                Set psFileList      of (phoWorkspace(Self)) to sPath
84645>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
84646>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
84647>            End
84647>        End
84647>    End_Procedure  
84648>    
84648>
84648>End_Object
84649>
84649>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
84649>>>//****************************************************************************
84649>>>// $Module type: Class
84649>>>// $Module name: cSQLConnectionHandler.pkg
84649>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
84649>>>// Web-site    : http://www.rdctools.com
84649>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
84649>>>//
84649>>>// Description : A handler class for using CLI connection ID's to login to a database server.
84649>>>//
84649>>>// $Rev History:
84649>>>//    2015-08-11  Module header created
84649>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
84649>>>//                Added a new structure for passing connection data back & forth.
84649>>>//                Added better error handling.
84649>>>//                Added a decompose message for the connection string.
84649>>>//    2017-01-09  Added support for Mertech drivers
84649>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
84649>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
84649>>>//    2017-02-12  Reworked the whole connection property interface.
84649>>>//                Now there is one struct property that is the at cencter of a connection.
84649>>>//****************************************************************************
84649>>>Use cli.pkg
84649>>>Use MSSqldrv.pkg
84649>>>Use db2_drv.pkg
84649>>>Use odbc_drv.pkg
84649>>>Use cSQLConnectionIniFile.pkg
84649>>>Use cDbUpdateDatabaseDriver.pkg
84649>>>Use vWin32fh.pkg
84649>>>
84649>>>// The cConnection class is the new SQL connections class for DF 19.
84649>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
84649>>>
84649>>>// We're making references to this object handle so we need it defined
84649>>>// here as well as for the cDbUpdateHandler class
84649>>>
84649>>>    Global_Variable Handle ghoSQLConnectionHandler
84649>>>    Move 0 to ghoSQLConnectionHandler
84650>>>
84650>>>Class cSQLConnectionHandler is a cObject
84651>>>
84651>>>    Procedure Construct_Object
84653>>>        Forward Send Construct_Object
84655>>>        Move Self to ghoSQLConnectionHandler
84656>>>
84656>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
84657>>>
84657>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
84657>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
84657>>>        // methods to this class.
84657>>>        Property Boolean pbUseConnectionID True
84658>>>        Property Boolean pbToANSI          True
84659>>>        Property Boolean pbRecnum          True
84660>>>        Property Boolean pbCopyData        True
84661>>>        Property Boolean pbApiTableUpdateAuto    False
84662>>>        Property Boolean pbCompareDate_DateTime  False
84663>>>        Property Boolean pbCompareIndexAscending False
84664>>>        Property Boolean pbCompareIndexUppercase False
84665>>>
84665>>>        // Driver default value settings:
84665>>>        // Note: When the object is created the corresponding values
84665>>>        // from the driver .int files are read.
84665>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
84665>>>        Property String psDriverDefaultValueASCII    ""
84666>>>        Property String psDriverDefaultValueBinary   ""
84667>>>        Property String psDriverDefaultValueDate     ""
84668>>>        Property String psDriverDefaultValueDateTime ""
84669>>>        Property String psDriverDefaultValueNumeric  ""
84670>>>        Property String psDriverDefaultValueText     ""
84671>>>
84671>>>        // Driver "nullability" settings:
84671>>>        // Note: When the object is created the corresponding values
84671>>>        // from the driver .int files are read.
84671>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
84671>>>        Property Boolean pbDriverDefaultNullableASCII    False
84672>>>        Property Boolean pbDriverDefaultNullableBinary   False
84673>>>        Property Boolean pbDriverDefaultNullableDate     False
84674>>>        Property Boolean pbDriverDefaultNullableDateTime False
84675>>>        Property Boolean pbDriverDefaultNullableNumeric  False
84676>>>        Property Boolean pbDriverDefaultNullableText     False
84677>>>
84677>>>        // *** This is the central point of connection data for the Database Update Framework ***
84677>>>        //     It is private because the get/set version also updates the DAW/Mertech
84677>>>        //     driver interfaces.
84677>>>        //     There are also procedure/function pairs to set/get individual data members
84677>>>        //     of the struct they are all routed throu this struct property.
84677>>>        Property tSQLConnection Private.pSQLConnection
84678>>>
84678>>>    End_Procedure
84679>>>
84679>>>    Procedure End_Construct_Object
84681>>>        tSQLConnection SQLConnection
84681>>>        tSQLConnection SQLConnection
84681>>>
84681>>>        Forward Send End_Construct_Object
84683>>>
84683>>>        // Now is the time to read and apply SQL connection settings.
84683>>>        Get SetupSQLConnection True True to SQLConnection
84684>>>        Set Private.pSQLConnection to SQLConnection
84685>>>    End_Procedure
84686>>>
84686>>>    // *** Properties ***
84686>>>    // All connection related "properties" (get/set pairs) are really done by changing the
84686>>>    // private.pSQLConnection struct connection property. These "properties" are
84686>>>    // merely here for conveniance.
84686>>>    //
84686>>>    // The pSQLConnection get/set are here so we have a "central hub"
84686>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
84686>>>    // This struct property contains all the connection data.
84686>>>    //
84686>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
84688>>>        Boolean bOK
84688>>>
84688>>>        Set Private.pSQLConnection to SQLConnection
84689>>>
84689>>>        // When starting a program we might not have a connection id yet:
84689>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
84691>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
84691>>>            Procedure_Return
84692>>>        End
84692>>>>
84692>>>
84692>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
84692>>>        // be logged in already and don't want to do it again.
84692>>>        If (SQLConnection.bDAWConnection = False) Begin
84694>>>            // After we have set the class property we need to tell the DAW/Mertech
84694>>>            // driver interfaces about the change & make a new login.
84694>>>            Get SQLLogin SQLConnection to bOK
84695>>>            If (bOK = False) Begin
84697>>>                Error DFERR_PROGRAM "Login error."
84698>>>>
84698>>>            End
84698>>>>
84698>>>        End
84698>>>>
84698>>>
84698>>>        // Now is the time to setup our driver default values by reading the driver .int file:
84698>>>        Send SetupDriverDefaults SQLConnection.sDriverID
84699>>>
84699>>>    End_Procedure
84700>>>
84700>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84700>>>    // attempt to load the driver.
84700>>>    // Returns true if the passed driver is SQL based.
84700>>>    Function IsSQLDriver String sDriverID Returns Boolean
84702>>>        Boolean bOK
84702>>>
84702>>>        Get IsDAWSQLDriver sDriverID to bOK
84703>>>        If (bOK = False) Begin
84705>>>            Get IsMertechDriver sDriverID to bOK
84706>>>        End
84706>>>>
84706>>>
84706>>>        Function_Return bOK
84707>>>    End_Function
84708>>>
84708>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
84708>>>    Procedure SetupDriverDefaults String sDriverID
84710>>>        String sAttributeValue
84710>>>        Integer iDriverID
84710>>>        Boolean bNULL bSQLDriver bIsMertechDriver
84710>>>
84710>>>        Get IsSQLDriver sDriverID to bSQLDriver
84711>>>        If (bSQLDriver = False) Begin
84713>>>            Procedure_Return
84714>>>        End                                      
84714>>>>
84714>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
84715>>>        If (bIsMertechDriver = True) Begin
84717>>>            Procedure_Return
84718>>>        End
84718>>>>
84718>>>        
84718>>>        Get DriverIndex sDriverID to iDriverID
84719>>>
84719>>>        // Driver default values for various data types:
84719>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
84722>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
84723>>>
84723>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
84726>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
84727>>>
84727>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
84730>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
84731>>>
84731>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
84734>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
84735>>>
84735>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
84738>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
84739>>>
84739>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
84742>>>        Set psDriverDefaultValueText                                    to sAttributeValue
84743>>>
84743>>>        // The default setting for the "nullability" of newly created ASCII columns.
84743>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
84746>>>        Set pbDriverDefaultNullableASCII to bNULL
84747>>>
84747>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
84750>>>        Set pbDriverDefaultNullableBinary to bNULL
84751>>>
84751>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
84754>>>        Set pbDriverDefaultNullableDate to bNULL
84755>>>
84755>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
84758>>>        Set pbDriverDefaultNullableDateTime to bNULL
84759>>>
84759>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
84762>>>        Set pbDriverDefaultNullableNumeric to bNULL
84763>>>
84763>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
84766>>>        Set pbDriverDefaultNullableText to bNULL
84767>>>
84767>>>    End_Procedure
84768>>>
84768>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
84770>>>        Boolean bOK bIsDaw bIsMertech
84770>>>        String sConnectionString
84770>>>        Handle hoErrorObj hoDriver hoIniFile
84770>>>        Integer iDriverID
84770>>>
84770>>>        Move False to bOK
84771>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
84772>>>        If (bIsDaw = False) Begin
84774>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
84775>>>            If (bIsMertech = False) Begin
84777>>>                Function_Return False
84778>>>            End
84778>>>>
84778>>>        End
84778>>>>
84778>>>
84778>>>        Get phoSQLConnectionIniFile to hoIniFile
84779>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
84780>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
84781>>>        If (iDriverID = 0) Begin
84783>>>            Move hoErrorObj to Error_Object_Id
84784>>>            Function_Return False
84785>>>        End
84785>>>>
84785>>>
84785>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
84785>>>        If (bIsMertech = False) Begin
84787>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
84790>>>        End
84790>>>>
84790>>>
84790>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
84791>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
84792>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
84793>>>        Send Destroy   of hoDriver
84794>>>
84794>>>        Function_Return bOK
84795>>>    End_Function
84796>>>
84796>>>    Function pSQLConnection Returns tSQLConnection
84798>>>        tSQLConnection SQLConnection
84798>>>        tSQLConnection SQLConnection
84798>>>        Get Private.pSQLConnection to SQLConnection
84799>>>        Function_Return SQLConnection
84800>>>    End_Function
84801>>>
84801>>>    Procedure Set psConnectionID String sValue
84803>>>        tSQLConnection SQLConnection
84803>>>        tSQLConnection SQLConnection
84803>>>
84803>>>        Get Private.pSQLConnection to SQLConnection
84804>>>        If (SQLConnection.sConnectionID = "") Begin
84806>>>            Move sValue to SQLConnection.sConnectionID
84807>>>        End
84807>>>>
84807>>>
84807>>>        // Else we might want to change the current connection ID
84807>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
84810>>>            Move False to Err
84811>>>            Logout SQLConnection.sDriverID
84812>>>            // This will also make a login to the new server.
84812>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
84813>>>        End
84813>>>>
84813>>>        Set pSQLConnection to SQLConnection
84814>>>    End_Procedure
84815>>>
84815>>>    Function psConnectionID Returns String
84817>>>        tSQLConnection SQLConnection
84817>>>        tSQLConnection SQLConnection
84817>>>        Get Private.pSQLConnection to SQLConnection
84818>>>        Function_Return SQLConnection.sConnectionID
84819>>>    End_Function
84820>>>
84820>>>    // Note: If the psDriverID + other connection properties are to be changed,
84820>>>    //       the psDriverID *must* be the first property that is changed!
84820>>>    //       Otherwise errors might be raised by the driver when e.g. the format
84820>>>    //       for a connection string has the wrong format for that driver.
84820>>>    Procedure Set psDriverID String sValue
84822>>>        tSQLConnection SQLConnection
84822>>>        tSQLConnection SQLConnection
84822>>>        Get pSQLConnection to SQLConnection
84823>>>        Move sValue        to SQLConnection.sDriverID
84824>>>        Set pSQLConnection to SQLConnection
84825>>>        If (sValue <> DATAFLEX_ID) Begin
84827>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84828>>>        End
84828>>>>
84828>>>    End_Procedure
84829>>>
84829>>>    Function psDriverID Returns String
84831>>>        tSQLConnection SQLConnection
84831>>>        tSQLConnection SQLConnection
84831>>>        Get Private.pSQLConnection to SQLConnection
84832>>>        If (SQLConnection.sDriverID = "") Begin
84834>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
84835>>>        End
84835>>>>
84835>>>        Function_Return SQLConnection.sDriverID
84836>>>    End_Function
84837>>>
84837>>>    Procedure Set psConnectionString String sValue
84839>>>        tSQLConnection SQLConnection
84839>>>        tSQLConnection SQLConnection
84839>>>        Get Private.pSQLConnection to SQLConnection
84840>>>        Move sValue        to SQLConnection.sConnectionString
84841>>>        Set pSQLConnection to SQLConnection
84842>>>    End_Procedure
84843>>>
84843>>>    Function psConnectionString Returns String
84845>>>        tSQLConnection SQLConnection
84845>>>        tSQLConnection SQLConnection
84845>>>        Get Private.pSQLConnection to SQLConnection
84846>>>        Function_Return SQLConnection.sConnectionString
84847>>>    End_Function
84848>>>
84848>>>    Procedure Set psServer String sValue
84850>>>        tSQLConnection SQLConnection
84850>>>        tSQLConnection SQLConnection
84850>>>        Get Private.pSQLConnection to SQLConnection
84851>>>        Move sValue        to SQLConnection.sServer
84852>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84853>>>        Set pSQLConnection to SQLConnection
84854>>>    End_Procedure
84855>>>
84855>>>    Function psServer Returns String
84857>>>        tSQLConnection SQLConnection
84857>>>        tSQLConnection SQLConnection
84857>>>        Get Private.pSQLConnection to SQLConnection
84858>>>        Function_Return SQLConnection.sServer
84859>>>    End_Function
84860>>>
84860>>>    Procedure Set psDatabase String sValue
84862>>>        tSQLConnection SQLConnection
84862>>>        tSQLConnection SQLConnection
84862>>>        Get Private.pSQLConnection to SQLConnection
84863>>>        Move sValue        to SQLConnection.sDatabase
84864>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84865>>>        Set pSQLConnection to SQLConnection
84866>>>    End_Procedure
84867>>>
84867>>>    Function psDatabase Returns String
84869>>>        tSQLConnection SQLConnection
84869>>>        tSQLConnection SQLConnection
84869>>>        Get Private.pSQLConnection to SQLConnection
84870>>>        Function_Return SQLConnection.sDatabase
84871>>>    End_Function
84872>>>
84872>>>    Procedure Set psUserID String sValue
84874>>>        tSQLConnection SQLConnection
84874>>>        tSQLConnection SQLConnection
84874>>>        Get Private.pSQLConnection to SQLConnection
84875>>>        Move sValue        to SQLConnection.sUserID
84876>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84877>>>        Set pSQLConnection to SQLConnection
84878>>>    End_Procedure
84879>>>
84879>>>    Function psUserID Returns String
84881>>>        tSQLConnection SQLConnection
84881>>>        tSQLConnection SQLConnection
84881>>>        Get Private.pSQLConnection to SQLConnection
84882>>>        Function_Return SQLConnection.sUserID
84883>>>    End_Function
84884>>>
84884>>>    // This is the uncrypted password
84884>>>    Procedure Set psPassword String sValue
84886>>>        tSQLConnection SQLConnection
84886>>>        tSQLConnection SQLConnection
84886>>>        Get Private.pSQLConnection to SQLConnection
84887>>>        Move sValue        to SQLConnection.sPassword
84888>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84889>>>        Set pSQLConnection to SQLConnection
84890>>>    End_Procedure
84891>>>
84891>>>    Function psPassword Returns String
84893>>>        tSQLConnection SQLConnection
84893>>>        tSQLConnection SQLConnection
84893>>>        Get Private.pSQLConnection to SQLConnection
84894>>>        Function_Return SQLConnection.sPassword
84895>>>    End_Function
84896>>>
84896>>>    Procedure Set pbTrusted Boolean bValue
84898>>>        tSQLConnection SQLConnection
84898>>>        tSQLConnection SQLConnection
84898>>>        Get Private.pSQLConnection to SQLConnection
84899>>>        Move bValue        to SQLConnection.bTrusted
84900>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
84901>>>        Set pSQLConnection to SQLConnection
84902>>>    End_Procedure
84903>>>
84903>>>    Function pbTrusted Returns Boolean
84905>>>        tSQLConnection SQLConnection
84905>>>        tSQLConnection SQLConnection
84905>>>        Get Private.pSQLConnection to SQLConnection
84906>>>        Function_Return SQLConnection.bTrusted
84907>>>    End_Function
84908>>>
84908>>>    // *** All of these properties are special to the Database Update Framework ***
84908>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
84908>>>    //     the Private.pSQLConnection property is set instead of the going throu
84908>>>    //     the central pSQLConnection "hub".
84908>>>    Procedure Set pbSilentLogin Boolean bValue
84910>>>        tSQLConnection SQLConnection
84910>>>        tSQLConnection SQLConnection
84910>>>        Get Private.pSQLConnection to SQLConnection
84911>>>        Move bValue to SQLConnection.bTrusted
84912>>>        Set Private.pSQLConnection to SQLConnection
84913>>>    End_Procedure
84914>>>
84914>>>    Function pbSilentLogin Returns Boolean
84916>>>        tSQLConnection SQLConnection
84916>>>        tSQLConnection SQLConnection
84916>>>        Get Private.pSQLConnection to SQLConnection
84917>>>        Function_Return SQLConnection.bSilentLogin
84918>>>    End_Function
84919>>>
84919>>>    Procedure Set piDbType Integer iValue
84921>>>        tSQLConnection SQLConnection
84921>>>        tSQLConnection SQLConnection
84921>>>        Get Private.pSQLConnection to SQLConnection
84922>>>        Move iValue to SQLConnection.iDbType
84923>>>        Set Private.pSQLConnection to SQLConnection
84924>>>    End_Procedure
84925>>>
84925>>>    Function piDbType Returns Integer
84927>>>        tSQLConnection SQLConnection
84927>>>        tSQLConnection SQLConnection
84927>>>        Get Private.pSQLConnection to SQLConnection
84928>>>        Function_Return SQLConnection.iDbType
84929>>>    End_Function
84930>>>
84930>>>    Procedure Set psBaseTableSpace String sValue
84932>>>        tSQLConnection SQLConnection
84932>>>        tSQLConnection SQLConnection
84932>>>        Get Private.pSQLConnection to SQLConnection
84933>>>        Move sValue to SQLConnection.sBaseTableSpace
84934>>>        Set Private.pSQLConnection to SQLConnection
84935>>>    End_Procedure
84936>>>
84936>>>    Function psBaseTableSpace Returns String
84938>>>        tSQLConnection SQLConnection
84938>>>        tSQLConnection SQLConnection
84938>>>        Get Private.pSQLConnection to SQLConnection
84939>>>        Function_Return SQLConnection.sBaseTableSpace
84940>>>    End_Function
84941>>>
84941>>>    Procedure Set psIndexTableSpace String sValue
84943>>>        tSQLConnection SQLConnection
84943>>>        tSQLConnection SQLConnection
84943>>>        Get Private.pSQLConnection to SQLConnection
84944>>>        Move sValue to SQLConnection.sIndexTableSpace
84945>>>        Set Private.pSQLConnection to SQLConnection
84946>>>    End_Procedure
84947>>>
84947>>>    Function psIndexTableSpace Returns String
84949>>>        tSQLConnection SQLConnection
84949>>>        tSQLConnection SQLConnection
84949>>>        Get Private.pSQLConnection to SQLConnection
84950>>>        Function_Return SQLConnection.sIndexTableSpace
84951>>>    End_Function
84952>>>
84952>>>    Procedure Set psLongTableSpace String sValue
84954>>>        tSQLConnection SQLConnection
84954>>>        tSQLConnection SQLConnection
84954>>>        Get Private.pSQLConnection to SQLConnection
84955>>>        Move sValue to SQLConnection.sLongTableSpace
84956>>>        Set Private.pSQLConnection to SQLConnection
84957>>>    End_Procedure
84958>>>
84958>>>    Function psLongTableSpace Returns String
84960>>>        tSQLConnection SQLConnection
84960>>>        tSQLConnection SQLConnection
84960>>>        Get Private.pSQLConnection to SQLConnection
84961>>>        Function_Return SQLConnection.sLongTableSpace
84962>>>    End_Function
84963>>>
84963>>>    Procedure Set psSchema String sValue
84965>>>        tSQLConnection SQLConnection
84965>>>        tSQLConnection SQLConnection
84965>>>        Get Private.pSQLConnection to SQLConnection
84966>>>        Move sValue to SQLConnection.sSchema
84967>>>        Set Private.pSQLConnection to SQLConnection
84968>>>    End_Procedure
84969>>>
84969>>>    Function psSchema Returns String
84971>>>        tSQLConnection SQLConnection
84971>>>        tSQLConnection SQLConnection
84971>>>        Get Private.pSQLConnection to SQLConnection
84972>>>        Function_Return SQLConnection.sSchema
84973>>>    End_Function
84974>>>
84974>>>    Procedure Set pbEnabled Boolean bValue
84976>>>        tSQLConnection SQLConnection
84976>>>        tSQLConnection SQLConnection
84976>>>        Get Private.pSQLConnection to SQLConnection
84977>>>        Move bValue to SQLConnection.bEnabled
84978>>>        Set Private.pSQLConnection to SQLConnection
84979>>>    End_Procedure
84980>>>
84980>>>    Function pbEnabled Returns Boolean
84982>>>        tSQLConnection SQLConnection
84982>>>        tSQLConnection SQLConnection
84982>>>        Get Private.pSQLConnection to SQLConnection
84983>>>        Function_Return SQLConnection.bEnabled
84984>>>    End_Function
84985>>>
84985>>>
84985>>>    // ************************************
84985>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
84987>>>        tSQLConnection SQLConnection
84987>>>        tSQLConnection SQLConnection
84987>>>
84987>>>        // If this object was created by the cDbUpdateHandler class we will
84987>>>        // deferr reading SQL connection values until later.
84987>>>        If (bReadDFConnSettings = True) Begin
84989>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
84989>>>            If (ghoConnection > 0) Begin
84991>>>                Get ReadcConnections to SQLConnection
84992>>>            End
84992>>>>
84992>>>
84992>>>            // In addition to the above; there might be other values set even if a cConnection
84992>>>            // object is used.
84992>>>            If (bReadSQLConnections = True) Begin
84994>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
84995>>>            End
84995>>>>
84995>>>        End
84995>>>>
84995>>>
84995>>>        Function_Return SQLConnection
84996>>>    End_Function
84997>>>
84997>>>    // This is for the new cConnection class used by DF 19 and up (only).
84997>>>    Function ReadcConnections Returns tSQLConnection
84999>>>        tConnection Connection
84999>>>        tConnection Connection
84999>>>        tSQLConnection SQLConnection SQLConnectionEmpty
84999>>>        tSQLConnection SQLConnection SQLConnectionEmpty
84999>>>        Integer iRetval iDbType
84999>>>        Boolean bOK bConnected
84999>>>        String sConnectionID
84999>>>
84999>>>            tConnection[] Connections
84999>>>            tConnection[] Connections
85000>>>            // - If the DF 19 cConnection class has been used in the cApplication object
85000>>>            // - and there are multiple connection id's defined for the same driver. This is
85000>>>            //   because otherwise we can't possibly know which connection id to use... So
85000>>>            //   we then generate an error and abort the program...
85000>>>            Get IsSinglecConnection (&sConnectionID) to bOK
85001>>>            If (bOK = False) Begin
85003>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
85004>>>>
85004>>>                Abort
85005>>>>
85005>>>            End
85005>>>>
85005>>>            If (sConnectionID = "") Begin
85007>>>                Get ConnectionIDs of ghoConnection to Connections
85008>>>                If (SizeOfArray(Connections) > 0) Begin
85010>>>                    Move Connections[0].sId to sConnectionID
85011>>>                End
85011>>>>
85011>>>            End
85011>>>>
85011>>>
85011>>>            Move 0 to iRetval
85012>>>            // DAW DF19 connection info:
85012>>>            // We first check that the connection is OK:
85012>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
85013>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
85013>>>            If (iRetval = -1) Begin
85015>>>                Function_Return SQLConnectionEmpty
85016>>>            End
85016>>>>
85016>>>
85016>>>            If (sConnectionID <> "") Begin
85018>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
85019>>>            End
85019>>>>
85019>>>            If (Connection.sId = "") Begin
85021>>>                Move True to SQLConnectionEmpty.bError
85022>>>                Function_Return SQLConnectionEmpty
85023>>>            End
85023>>>>
85023>>>
85023>>>            // DUF connection info struct property:
85023>>>            Get Private.pSQLConnection                       to SQLConnection
85024>>>
85024>>>            Move Connection.sId to sConnectionID
85025>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
85026>>>
85026>>>            If (bConnected = False) Begin
85028>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
85029>>>                If (iRetval <> 0) Begin
85031>>>                    Send UserError CS_DUF_CannotLoginToServer
85032>>>                    Send Exit_Application
85033>>>                End
85033>>>>
85033>>>                Move True                                   to SQLConnection.bDAWConnection
85034>>>                // We need to get the DAW connection info again as it might have
85034>>>                // been changed in the DAW db login dialog.
85034>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
85035>>>            End
85035>>>>
85035>>>
85035>>>            Move True                                        to SQLConnection.bEnabled
85036>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
85037>>>
85037>>>            // Not used in DUF:
85037>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
85037>>>
85037>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
85038>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
85039>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
85040>>>            Move Connection.sId                              to SQLConnection.sConnectionID
85041>>>            Move Connection.sUID                             to SQLConnection.sUserID
85042>>>            Move Connection.sPWD                             to SQLConnection.sPassword
85043>>>
85043>>>            // Not used in DUF:
85043>>>            // Move Connection.sSection to SQLConnection.xxx
85043>>>
85043>>>            // The rest of the properties of the SQLConnection struct should have been
85043>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
85043>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
85045>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
85046>>>            End
85046>>>>
85046>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
85048>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
85049>>>                If (SQLConnection.sServer = "") Begin
85051>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
85052>>>                End
85052>>>>
85052>>>            End
85052>>>>
85052>>>
85052>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
85053>>>
85053>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
85053>>>            // the value from the driver id:
85053>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
85054>>>            // ...but in case it has been explicitly set in the object we use that value.
85054>>>            Get piDbType                                     to iDbType
85055>>>            If (iDbType <> SQLConnection.iDbType) Begin
85057>>>                Move iDbType to SQLConnection.iDbType
85058>>>            End
85058>>>>
85058>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
85059>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
85060>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
85061>>>            Get psSchema                                     to SQLConnection.sSchema
85062>>>
85062>>>            // We finally set the struct property to the newly fetched values.
85062>>>            Set pSQLConnection to SQLConnection
85063>>>
85063>>>        Function_Return SQLConnection
85064>>>    End_Function
85065>>>
85065>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
85065>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
85065>>>    // connection id for a particular driver.
85065>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
85065>>>    // object. We can then match a connection id from the DAW cConnect class array.
85065>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
85065>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
85065>>>    // connections of the DAW cConnect class.
85065>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
85067>>>        tConnection[] ConnIdArray
85067>>>        tConnection[] ConnIdArray
85068>>>        Integer iCount iSize iConnectionIDCounter
85068>>>        Boolean bEnabled bFound
85068>>>        String sConnectionID2 sDriverID sDriverConn
85068>>>
85068>>>        Move False to bFound
85069>>>        If (ghoConnection > 0) Begin
85071>>>
85071>>>            // The property of the cDbUpdateHandler container object
85071>>>            Get psDriverID to sDriverID
85072>>>
85072>>>            Move 0 to iConnectionIDCounter
85073>>>            // This is the the DAW cConnect array with all registered connection id's.
85073>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
85074>>>            Move (SizeOfArray(ConnIdArray)) to iSize
85075>>>            Decrement iSize
85076>>>            For iCount from 0 to iSize
85082>>>>
85082>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
85083>>>                Move ConnIdArray[iCount].sId to sConnectionID2
85084>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
85085>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
85085>>>                // connection in the DAW cConnect object _and_ that there is only one!
85085>>>                If (sConnectionID = "") Begin
85087>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
85088>>>                End
85088>>>>
85088>>>                Else Begin
85089>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
85091>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
85092>>>                    End
85092>>>>
85092>>>                End
85092>>>>
85092>>>
85092>>>                If (bFound = True) Begin
85094>>>                    Increment iConnectionIDCounter
85095>>>                End
85095>>>>
85095>>>            Loop
85096>>>>
85096>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
85097>>>            If (bFound = True) Begin
85099>>>                Move sConnectionID2 to sConnectionID
85100>>>            End
85100>>>>
85100>>>        End
85100>>>>
85100>>>
85100>>>        // Special case; a cConnection object has been setup in the cApplication,
85100>>>        // but no DFConn.ini record has been created.
85100>>>        If (iSize = -1) Begin
85102>>>            Move True to bFound
85103>>>        End
85103>>>>
85103>>>
85103>>>        Function_Return bFound
85104>>>    End_Function
85105>>>
85105>>>    // Send on object creation to read the default connection string settings, and
85105>>>    // create a connection to the server.
85105>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
85107>>>        String sPath sFileName
85107>>>        Boolean bExists bActive
85107>>>        tSQLConnection[] SQLConnectionArray
85107>>>        tSQLConnection[] SQLConnectionArray
85108>>>        tSQLConnection SQLConnection SQLConnectionEmpty
85108>>>        tSQLConnection SQLConnection SQLConnectionEmpty
85108>>>        Handle hoIniFile
85108>>>        Integer iSize iCount iRetval
85108>>>
85108>>>        Get psIniFilePath to sPath
85109>>>        Get phoSQLConnectionIniFile to hoIniFile
85110>>>        If (sPath = "") Begin
85112>>>            Get ApplicationPath of hoIniFile to sPath
85113>>>            Set psIniFilePath   of hoIniFile to sPath
85114>>>        End
85114>>>>
85114>>>        Get vFolderFormat sPath to sPath
85115>>>        Get psIniFileName to sFileName
85116>>>        Get vFilePathExists (sPath + sFileName) to bExists
85117>>>
85117>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
85118>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
85119>>>        If (iSize = 0) Begin
85121>>>            // This may have been set by the "ReadcConnections" function,
85121>>>            // if a cConnection object has been setup for DataFlex 19 or later
85121>>>            // in the cApplication object.
85121>>>            Get pSQLConnection to SQLConnection
85122>>>            If (SQLConnection.sConnectionID = "") Begin
85124>>>                Function_Return SQLConnectionEmpty
85125>>>            End
85125>>>>
85125>>>            Move SQLConnection to SQLConnectionArray[0] 
85126>>>            Move 1 to iSize
85127>>>        End
85127>>>>
85127>>>
85127>>>        Move False to bActive
85128>>>        // The first connection should be the one that is active, but all connections might have been disabled.
85128>>>        Decrement iSize
85129>>>        For iCount from 0 to iSize
85135>>>>
85135>>>            Move SQLConnectionArray[iCount] to SQLConnection
85136>>>            If (SQLConnection.bEnabled = True) Begin
85138>>>                Move True to bActive
85139>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
85140>>>            End
85140>>>>
85140>>>        Loop
85141>>>>
85141>>>
85141>>>        // In case all connections have been disabled, we're out of here.
85141>>>        If (bActive = False) Begin
85143>>>            Function_Return SQLConnectionEmpty
85144>>>        End
85144>>>>
85144>>>
85144>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
85145>>>
85145>>>        Set pSQLConnection to SQLConnection
85146>>>        Get AutoSetConnectionID to iRetval
85147>>>
85147>>>        Function_Return SQLConnection
85148>>>    End_Function
85149>>>
85149>>>    Procedure Set psIniFilePath String sPath
85151>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
85152>>>    End_Procedure
85153>>>
85153>>>    Function psIniFilePath Returns String
85155>>>        String sRetval
85155>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
85156>>>        Function_Return sRetval
85157>>>    End_Function
85158>>>
85158>>>    Procedure Set psIniFileName String sFileName
85160>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
85161>>>    End_Procedure
85162>>>
85162>>>    Function psIniFileName Returns String
85164>>>        String sRetval
85164>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
85165>>>        Function_Return sRetval
85166>>>    End_Function
85167>>>
85167>>>    Procedure Set psIniSectionName String sSection
85169>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
85170>>>    End_Procedure
85171>>>
85171>>>    Function psIniSectionName Returns String
85173>>>        String sRetval
85173>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
85174>>>        Function_Return sRetval
85175>>>    End_Function
85176>>>
85176>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
85178>>>        Handle ho
85178>>>        Get phoSQLConnectionIniFile to ho
85179>>>        Set IniFileValue of ho to sSection sValueName sValue
85180>>>    End_Procedure
85181>>>
85181>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
85183>>>        Handle ho
85183>>>        String sRetval
85183>>>        Get phoSQLConnectionIniFile to ho
85184>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
85185>>>        Function_Return sRetval
85186>>>    End_Function
85187>>>
85187>>>    Function SectionExists String sSection Returns Boolean
85189>>>        Handle ho
85189>>>        Boolean bRetval
85189>>>        Get phoSQLConnectionIniFile to ho
85190>>>        Get SectionExists of ho sSection to bRetval
85191>>>        Function_Return bRetval
85192>>>    End_Function
85193>>>
85193>>>    Function KeyExists String sSection String sKey Returns Boolean
85195>>>        Handle ho
85195>>>        Boolean bRetval
85195>>>        Get phoSQLConnectionIniFile to ho
85196>>>        Get KeyExists of ho sSection sKey to bRetval
85197>>>        Function_Return bRetval
85198>>>    End_Function
85199>>>
85199>>>    Function EncryptPassword String sPassword Returns String
85201>>>        Handle ho
85201>>>        String sRetval
85201>>>        Get phoSQLConnectionIniFile to ho
85202>>>        Get EncryptPassword of ho sPassword to sRetval
85203>>>        Function_Return sRetval
85204>>>    End_Function
85205>>>
85205>>>    Function DecryptPassword String sPassword Returns String
85207>>>        Handle ho
85207>>>        String sRetval
85207>>>        Get phoSQLConnectionIniFile to ho
85208>>>        Get DecryptPassword of ho sPassword to sRetval
85209>>>        Function_Return sRetval
85210>>>    End_Function
85211>>>
85211>>>    // *** Main Connection Message ***
85211>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
85213>>>        Handle hoDriver
85213>>>        String sConnectionString sError
85213>>>        Boolean bLoginSuccessful
85213>>>
85213>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
85214>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
85215>>>        Set psDriverID of hoDriver to sDriverID
85216>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
85217>>>        If (bLoginSuccessful = False) Begin
85219>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
85220>>>>
85220>>>            If (bExitProgram = True) Begin
85222>>>                Send Exit_Application
85223>>>            End
85223>>>>
85223>>>        End
85223>>>>
85223>>>        Send Destroy of hoDriver
85224>>>    End_Procedure
85225>>>
85225>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
85227>>>        Integer iRetval
85227>>>        Handle hoCLI
85227>>>        String sDriverID
85227>>>
85227>>>        Get psDriverID to sDriverID
85228>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
85229>>>        If (hoCLI <> 0) Begin
85231>>>            Set psDriverID of hoCLI to sDriverID
85232>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
85233>>>            Send Destroy of hoCLI
85234>>>        End
85234>>>>
85234>>>
85234>>>        Function_Return iRetval
85235>>>    End_Function
85236>>>
85236>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
85238>>>        tSQLConnection SQLConnection
85238>>>        tSQLConnection SQLConnection
85238>>>
85238>>>        Set psDriverID to sDriverID
85239>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
85240>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
85241>>>    End_Procedure
85242>>>
85242>>>    // This is needed when e.g. the connection id we have specified in the program code
85242>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
85242>>>    // or the one in the DataFlex Bin folder.)
85242>>>    // We then need to delete the current one before creating a new one.
85242>>>    // This is because the parameters may differ between the program code and the
85242>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
85242>>>    // when one tries to create a Connection ID that already exists.
85242>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
85244>>>        Integer iResult iDriver iNumConn iConn
85244>>>        Handle hoCLI
85244>>>        String sID
85244>>>
85244>>>        If (sDriverID = "" or sConnectionID = "") Begin
85246>>>            Procedure_Return
85247>>>        End
85247>>>>
85247>>>
85247>>>        Move 0 to iResult
85248>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
85249>>>        If (hoCLI <> 0) Begin
85251>>>            Set psDriverID of hoCLI to sDriverID
85252>>>            Get DriverIndex sDriverID to iDriver
85253>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
85256>>>            Decrement iNumConn
85257>>>            For iConn from 0 to iNumConn
85263>>>>
85263>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
85266>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
85268>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
85269>>>                End
85269>>>>
85269>>>            Loop
85270>>>>
85270>>>            Send Destroy of hoCLI
85271>>>        End
85271>>>>
85271>>>
85271>>>    End_Procedure
85272>>>
85272>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
85274>>>        Integer iResult iDriver iNumConn iConn
85274>>>        Handle hoCLI
85274>>>        String sID sConnectionString sVal sDatabase
85274>>>        tSQLConnection SQLConnection
85274>>>        tSQLConnection SQLConnection
85274>>>        Boolean bTrusted
85274>>>
85274>>>        Move 0 to iResult
85275>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
85276>>>        If (hoCLI <> 0) Begin
85278>>>            Set psDriverID of hoCLI to sDriverID
85279>>>            Get DriverIndex sDriverID to iDriver
85280>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
85283>>>            Decrement iNumConn
85284>>>            For iConn from 0 to iNumConn
85290>>>>
85290>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
85293>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
85295>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
85296>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
85299>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
85302>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
85303>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
85306>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
85307>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
85308>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
85309>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
85310>>>
85310>>>                    Case Begin
85310>>>                        Case (sDriverID = MSSQLDRV_ID)
85312>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
85313>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
85314>>>                            Move bTrusted                                               to SQLConnection.bTrusted
85315>>>                            Case Break
85316>>>                        Case (sDriverID = DB2_DRV_ID)
85319>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
85320>>>                            Case Break
85321>>>                        Case (sDriverID = ODBC_DRV_ID)
85324>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
85325>>>                            If (SQLConnection.sServer = "") Begin
85327>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
85328>>>                            End
85328>>>>
85328>>>                            Case Break
85329>>>                        Case (sDriverID = SQLFLEX)
85332>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
85333>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
85334>>>                            If (SQLConnection.bTrusted = True) Begin
85336>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
85337>>>                            End
85337>>>>
85337>>>                            Else Begin
85338>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
85339>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
85340>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
85341>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
85342>>>                            End
85342>>>>
85342>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
85343>>>                            Case Break
85344>>>                        Case (sDriverID = MDSMySQL)
85347>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
85348>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
85349>>>                            If (SQLConnection.bTrusted = True) Begin
85351>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
85352>>>                            End
85352>>>>
85352>>>                            Else Begin
85353>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
85354>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
85355>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
85356>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
85357>>>                            End
85357>>>>
85357>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
85358>>>                            Case Break
85359>>>                        Case (sDriverID = MDSPgSQL)
85362>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
85363>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
85364>>>                            If (SQLConnection.bTrusted = True) Begin
85366>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
85367>>>                            End
85367>>>>
85367>>>                            Else Begin
85368>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
85369>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
85370>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
85371>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
85372>>>                            End
85372>>>>
85372>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
85373>>>                            Case Break
85374>>>
85374>>>                        Case (sDriverID = ORAFLEX)
85377>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
85378>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
85379>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
85380>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
85382>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
85383>>>                            End
85383>>>>
85383>>>                            If (SQLConnection.bTrusted = True) Begin
85385>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
85386>>>                            End
85386>>>>
85386>>>                            Else Begin
85387>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
85388>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
85389>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
85390>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
85391>>>                            End
85391>>>>
85391>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
85392>>>                            Case Break
85393>>>                        Case Else
85393>>>                            Error ("Wrong driver ID passed:" * sDriverID)
85394>>>>
85394>>>                            Case Break
85395>>>                    Case End
85395>>>                End
85395>>>>
85395>>>            Loop
85396>>>>
85396>>>            Send Destroy of hoCLI
85397>>>        End
85397>>>>
85397>>>
85397>>>        Function_Return SQLConnection
85398>>>    End_Function
85399>>>
85399>>>    Function DriverIndex String sDriverID Returns Integer
85401>>>        String  sCurrentDriver
85401>>>        Integer iNumberOfDrivers iDriver iCount
85401>>>
85401>>>        Move 0 to iDriver
85402>>>        Move 0 to iCount
85403>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
85406>>>        For iCount from 1 to iNumberOfDrivers
85412>>>>
85412>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
85415>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
85417>>>                Function_Return iCount
85418>>>            End
85418>>>>
85418>>>        Loop
85419>>>>
85419>>>
85419>>>        // If driver not previously loaded; attempt to do so now.
85419>>>        If (iDriver = 0) Begin
85421>>>            Move 0 to LastErr
85422>>>            Load_Driver sDriverID
85423>>>            // If driver could not be loaded.
85423>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
85425>>>                Move -1 to iCount
85426>>>            End
85426>>>>
85426>>>        End
85426>>>>
85426>>>        Function_Return iCount
85427>>>    End_Function
85428>>>
85428>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
85428>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
85430>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
85430>>>        Boolean bTrusted bSilent
85430>>>        Integer iRetval
85430>>>
85430>>>        Move SQLConnection.sDriverID     to sDriverID
85431>>>        Move SQLConnection.sConnectionID to sConnectionID
85432>>>        Move SQLConnection.sServer       to sServer
85433>>>        Move SQLConnection.sDatabase     to sDatabase
85434>>>        Move SQLConnection.bTrusted      to bTrusted
85435>>>        Move SQLConnection.sUserID       to sUserID
85436>>>        Move SQLConnection.sPassword     to sPassword
85437>>>        Move SQLConnection.bSilentLogin  to bSilent
85438>>>
85438>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
85439>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
85439>>>        Get AutoSetConnectionID to iRetval
85440>>>    End_Procedure
85441>>>
85441>>>    // Called when the object is constructed.
85441>>>    // It will check the psDriverID for a ConnectionID and save it
85441>>>    // as psConnectionID property. It is later used whenever a login to
85441>>>    // the database is needed.
85441>>>    Function AutoSetConnectionID Returns Boolean
85443>>>        String sConnectionID sDriverID sConnectionString
85443>>>        Integer iDriver iRetval
85443>>>        Handle hoCLI
85443>>>        Boolean bOK bSilent bMertechDriver
85443>>>
85443>>>        Get pbSilentLogin      to bSilent
85444>>>        Get psConnectionID     to sConnectionID
85445>>>        Get psConnectionString to sConnectionString
85446>>>        // Get the driver Connection ID string & set the psConnectionString property.
85446>>>        Get psDriverID to sDriverID
85447>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85448>>>        If (bOK = False) Begin
85450>>>            Function_Return False
85451>>>        End
85451>>>>
85451>>>
85451>>>        // Mertech drivers can't use connection ID's.
85451>>>        Get IsMertechDriver sDriverID to bMertechDriver
85452>>>        If (bMertechDriver = True) Begin
85454>>>            // This ensures that the correct Server & Database attributes are set both for
85454>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
85454>>>            Get _MertechSQLManagerHandle to hoCLI
85455>>>            Function_Return (hoCLI <> 0)
85456>>>        End
85456>>>>
85456>>>
85456>>>        Get DriverIndex sDriverID          to iDriver
85457>>>        // If driver not loaded; load it.
85457>>>        If (iDriver = 0) Begin
85459>>>            Load_Driver sDriverID
85460>>>            Get DriverIndex sDriverID      to iDriver
85461>>>        End
85461>>>>
85461>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
85461>>>        If (iDriver = 0) Begin
85463>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
85464>>>>
85464>>>            Function_Return False
85465>>>        End           
85465>>>>
85465>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
85468>>>        
85468>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
85469>>>        Set psDriverID of hoCLI            to sDriverID
85470>>>        // Delete the connection first; in case it exists
85470>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
85471>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
85472>>>        Send Destroy of hoCLI
85473>>>
85473>>>        Function_Return (iRetval = 0)
85474>>>    End_Function
85475>>>
85475>>>    // Returns the handle of the Mertech SQL handler.
85475>>>    // It also ensures that the correct Server & Database attributes are set both for
85475>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
85475>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
85475>>>    //       So the return value is of no use! But we don't need the handle for this class.
85475>>>    Function _MertechSQLManagerHandle Returns Handle
85477>>>        Handle hoSQLHandler
85477>>>        String sDriverID sServer sDatabase
85477>>>
85477>>>        Move 0 to hoSQLHandler
85478>>>        Get psDriverID to sDriverID
85479>>>        Get psServer   to sServer
85480>>>        Get psDatabase to sDatabase
85481>>>        // This command is used to set the server to be used when opening tables
85481>>>        SET_CURRENT_SQL_SERVER to sServer
85524>>>>
85524>>>        // This command is used to specify which server to use for embedded SQL statements,
85524>>>        // but it has been constructed rather studidly as only constants and not variables
85524>>>        // are allowed...
85524>>>        If (sDriverID = MDSPgSQL) Begin
85526>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
85542>>>        End
85542>>>>
85542>>>        If (sDriverID = MDSMySQL) Begin
85544>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
85560>>>        End
85560>>>>
85560>>>        If (sDriverID = ORAFLEX) Begin
85562>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
85578>>>        End
85578>>>>
85578>>>        If (sDriverID = SQLFLEX) Begin
85580>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
85596>>>        End
85596>>>>
85596>>>
85596>>>        // This command is used to specify which database is used for embedded SQL statements.
85596>>>        SQL_USE_DATABASE sDatabase
85634>>>>
85634>>>        SET_DATABASE_NAME to sDatabase
85672>>>>
85672>>>
85672>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
85672>>>        // which object may or may not have been created at this point. So don't use the return
85672>>>        // value for this function!
85672>>>        //Get phoSQLManagerMT to hoSQLHandler
85672>>>
85672>>>        Function_Return hoSQLHandler
85673>>>    End_Function
85674>>>
85674>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
85676>>>        Boolean bOK bMertechDriver
85676>>>
85676>>>        Get IsDAWSQLDriver sDriverID to bOK
85677>>>
85677>>>        If (bOK = False) Begin
85679>>>            Get IsMertechDriver sDriverID to bOK
85680>>>        End
85680>>>>
85680>>>
85680>>>        If (bOK = False) Begin
85682>>>            Get IsMertechDriver sDriverID to bMertechDriver
85683>>>            If (bMertechDriver = True) Begin
85685>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
85686>>>>
85686>>>            End
85686>>>>
85686>>>            Else Begin
85687>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
85688>>>>
85688>>>            End
85688>>>>
85688>>>            Function_Return False
85689>>>        End
85689>>>>
85689>>>
85689>>>        Function_Return True
85690>>>    End_Function
85691>>>
85691>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
85693>>>        Boolean bOK
85693>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
85694>>>        Function_Return bOK
85695>>>    End_Function
85696>>>
85696>>>    Function IsMertechDriver String sDriverID Returns Boolean
85698>>>        Boolean bOK
85698>>>        Move False to bOK
85699>>>//        #IFDEF DUF_Use_Mertech_Drivers
85699>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
85700>>>//        #ENDIF
85700>>>        Function_Return bOK
85701>>>    End_Function
85702>>>
85702>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85704>>>        Handle hoIniFile
85704>>>        String sConnect
85704>>>
85704>>>        Get phoSQLConnectionIniFile to hoIniFile
85705>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
85706>>>
85706>>>        Function_Return sConnect
85707>>>    End_Function
85708>>>
85708>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
85708>>>    // Pass a complete driver connection string
85708>>>    // Returns the following as a struct:
85708>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
85708>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
85708>>>    //
85708>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
85710>>>        tSQLConnection SQLConnection
85710>>>        tSQLConnection SQLConnection
85710>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
85710>>>        Boolean bTrusted bSilent bOK
85710>>>        Integer iPos
85710>>>
85710>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85711>>>        If (bOK = False) Begin
85713>>>            Function_Return SQLConnection
85714>>>        End
85714>>>>
85714>>>
85714>>>        Move False to bTrusted
85715>>>        Move False to bSilent
85716>>>
85716>>>        Case Begin
85716>>>            Case (sDriverID = MSSQLDRV_ID)
85718>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
85719>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
85720>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
85721>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
85722>>>                If (bTrusted = False) Begin
85724>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
85725>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
85726>>>                End
85726>>>>
85726>>>                Case Break
85727>>>
85727>>>            Case (sDriverID = ODBC_DRV_ID)
85730>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
85732>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
85733>>>                End
85733>>>>
85733>>>                Else Begin
85734>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
85735>>>                End
85735>>>>
85735>>>
85735>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
85736>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
85737>>>                If (bTrusted = False) Begin
85739>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
85740>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
85741>>>                End
85741>>>>
85741>>>                Case Break
85742>>>
85742>>>            Case (sDriverID = DB2_DRV_ID)
85745>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
85746>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
85747>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
85748>>>                Case Break
85749>>>
85749>>>            Case (sDriverID = SQLFLEX)
85752>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
85753>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
85754>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
85755>>>                If (bTrusted = False) Begin
85757>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
85758>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
85759>>>                End
85759>>>>
85759>>>                Case Break
85760>>>
85760>>>            Case (sDriverID = ORAFLEX)
85763>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
85764>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
85765>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
85767>>>                    Move (sServer + "/" + sDatabase)                                to sServer
85768>>>                End
85768>>>>
85768>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
85769>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
85770>>>                Case Break
85771>>>
85771>>>            Case (sDriverID = MDSPgSQL)
85774>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
85775>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
85776>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
85777>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
85778>>>                Case Break
85779>>>
85779>>>            Case (sDriverID = MDSMySQL)
85782>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
85783>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
85784>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
85785>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
85786>>>                Case Break
85787>>>
85787>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
85790>>>                Break
85791>>>        Case End
85791>>>
85791>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
85792>>>
85792>>>        // bSilent?
85792>>>        Move (Pos(",0", sConnectionString))                                     to iPos
85793>>>        If (iPos = 0) Begin
85795>>>            Move (Pos(",1", sConnectionString))                                 to iPos
85796>>>        End
85796>>>>
85796>>>        If (iPos = 0) Begin
85798>>>            Move "0"                                                            to sValue
85799>>>        End
85799>>>>
85799>>>        Else Begin
85800>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
85801>>>        End
85801>>>>
85801>>>        Move (If(sValue = 1, True, False))                                      to bSilent
85802>>>
85802>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
85803>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
85804>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
85805>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
85806>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
85807>>>        Move bTrusted                                                           to SQLConnection.bTrusted
85808>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
85809>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
85810>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
85811>>>
85811>>>        Function_Return SQLConnection
85812>>>    End_Function
85813>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
85813>>>>
85813>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
85815>>>>    Integer iStart iEnd
85815>>>>    String sRetval
85815>>>>
85815>>>>    Move (Trim(sConnect)) to sConnect
85816>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
85817>>>>    If (iStart = 0) Begin
85819>>>>        Function_Return ""
85820>>>>    End
85820>>>>>
85820>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
85821>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
85822>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
85824>>>>        Move (Pos(",", sRetval))          to iEnd
85825>>>>    End
85825>>>>>
85825>>>>    Else Begin
85826>>>>        Move (Pos(";", sRetval))          to iEnd
85827>>>>    End
85827>>>>>
85827>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
85829>>>>        Move (Pos(",", sRetval))          to iEnd
85830>>>>        Decrement iEnd
85831>>>>    End
85831>>>>>
85831>>>>    If (iEnd <> 0) Begin
85833>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
85834>>>>    End
85834>>>>>
85834>>>>    Move (Replace("=", sRetval, ""))      to sRetval
85835>>>>
85835>>>>    Function_Return (Trim(sRetval))
85836>>>>End_Function
85837>>>>
85837>>>>
85837>>>
85837>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
85837>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
85839>>>        Handle ho
85839>>>        Integer iIndex
85839>>>        Boolean bRetval bOK
85839>>>        tSQLConnection SQLConnection
85839>>>        tSQLConnection SQLConnection
85839>>>
85839>>>        Get pSQLConnection to SQLConnection
85840>>>        Get phoSQLConnectionIniFile to ho
85841>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
85842>>>        If (iIndex = -1) Begin
85844>>>            Function_Return False
85845>>>        End
85845>>>>
85845>>>
85845>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
85846>>>        Send UpdateConnectionString SQLConnection
85847>>>        If (ghoConnection > 0) Begin
85849>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
85850>>>            If (iIndex <> -1) Begin
85852>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
85853>>>            End
85853>>>>
85853>>>        End
85853>>>>
85853>>>
85853>>>        Function_Return bRetval
85854>>>    End_Function
85855>>>
85855>>>End_Class
85856>Object oSQLConnectionHandler is a cSQLConnectionHandler
85858>    // If a file was passed on the command line - which can be done from the Studio -
85858>    // we change the ini-file path here. (The file name is always the same)
85858>    Procedure End_Construct_Object
85861>        String sPath
85861>        Boolean bExists
85861>        Get psCommandLineIniFilePath of ghoApplication to sPath
85862>        If (sPath <> "") Begin
85864>            Set psIniFilePath to sPath
85865>        End
85865>        Else Begin
85866>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
85867>            Set psIniFilePath to sPath
85868>            Get vFolderFormat sPath to sPath
85869>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
85870>            Set pbIniFileExists of ghoApplication to bExists
85871>        End
85871>        Forward Send End_Construct_Object
85873>    End_Procedure
85874>End_Object
85875>
85875>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
85875>>>
85875>>>//****************************************************************************
85875>>>// $Module type: Class
85875>>>// $Module name: cDbUpdateFunctionLibrary
85875>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
85875>>>// Web-site    : http://www.rdctools.com
85875>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
85875>>>//
85875>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
85875>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
85875>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
85875>>>//               with the help of Sql-scripts.
85875>>>//
85875>>>// $Rev History:
85875>>>//    2014-09-05  Module header created
85875>>>//
85875>>>//****************************************************************************
85875>>>Use cApplication.pkg
85875>>>Use seq_chnl.pkg
85875>>>Use GlobalFunctionsProcedures.pkg
85875>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
85875>>>Use Dfcursor.pkg
85875>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
85875>>>>>// StatPnl.pkg - creates the standard status_panel object.
85875>>>>>//
85875>>>>>//
85875>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
85875>>>>>// invoke the standard status panel. The standard has always been that the package name
85875>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
85875>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
85875>>>>>// prior revisions has been replace with status panel that is part of the application.
85875>>>>>// This should work much better and faster than the old sentinel based solution.
85875>>>>>// While the way this operates has changed, the interface has not and therefore this should work
85875>>>>>// with most applications.
85875>>>>>//
85875>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
85875>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
85875>>>>>// a cleaner more robust interface.
85875>>>>>//
85875>>>>>//
85875>>>>>// Compatibility Note:
85875>>>>>//
85875>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
85875>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
85875>>>>>//
85875>>>>>// If for some reason you application will not work using this as a replacement for the old status
85875>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
85875>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
85875>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
85875>>>>>//
85875>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
85875>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
85875>>>>>//
85875>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
85875>>>>>// can still access the new object via the ghoStatusPanel handle.
85875>>>>>//
85875>>>>>//
85875>>>>>// Creating your own Status Panel objects
85875>>>>>//
85875>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
85875>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
85875>>>>>// with a different file and object name and direct your status panel request to the new object.
85875>>>>>//
85875>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
85875>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
85875>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
85875>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
85875>>>>>// e.g.
85875>>>>>//       Procedure UpdateStatusBar
85875>>>>>//           Send DoAdvance of oProgressBar
85875>>>>>//           Send ProcessEvents
85875>>>>>//       End_Procedure
85875>>>>>//
85875>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
85875>>>>>// messages this will be done for you.
85875>>>>>//
85875>>>>>// the standard Interface for status panels are:
85875>>>>>//
85875>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
85875>>>>>// Send Start_StatusPanel      - start the status panel
85875>>>>>// Send Stop_StatusPanel       - stop the status panel
85875>>>>>// Send Update_StatusPanel     - update the status panel's action area
85875>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
85875>>>>>//
85875>>>>>// Get/Set Caption_Text - updates the caption bar
85875>>>>>// Get/Set Title_Text   - updates the title area
85875>>>>>// Get/Set Message_Text - updates the Message area
85875>>>>>// Get/Set Action_Text  - updates the action area
85875>>>>>// Get/Set Button_Text  - updates the button area
85875>>>>>//
85875>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
85875>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
85875>>>>>//
85875>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
85875>>>>>Use cProcessStatusPanel.pkg
85875>>>>>Use cCJSkinFramework.pkg
85875>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProgressBar.pkg)
85875>>>>>>>Use Windows.pkg
85875>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWinControl.pkg)
85875>>>>>>>>>Use Windows.pkg
85875>>>>>>>>>
85875>>>>>>>>>// Key State Masks for Mouse Messages
85875>>>>>>>>>
85875>>>>>>>>>Define MK_LBUTTON  for |CI$0001
85875>>>>>>>>>Define MK_RBUTTON  for |CI$0002
85875>>>>>>>>>Define MK_SHIFT    for |CI$0004
85875>>>>>>>>>Define MK_CONTROL  for |CI$0008
85875>>>>>>>>>Define MK_MBUTTON  for |CI$0010
85875>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
85875>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
85875>>>>>>>>>
85875>>>>>>>>>Enum_List // Mouse Key Flags
85875>>>>>>>>>    Define mkLeft    for MK_LBUTTON
85875>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
85875>>>>>>>>>    Define mkRight   for MK_RBUTTON
85875>>>>>>>>>    Define mkX1      for MK_XBUTTON1
85875>>>>>>>>>    Define mkX2      for MK_XBUTTON2
85875>>>>>>>>>    Define mkShift   for MK_SHIFT
85875>>>>>>>>>    Define mkControl for MK_CONTROL
85875>>>>>>>>>End_Enum_List
85875>>>>>>>>>
85875>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
85875>>>>>>>>>    Define mbLeft
85875>>>>>>>>>    Define mbMiddle
85875>>>>>>>>>    Define mbRight
85875>>>>>>>>>    Define mbX1
85875>>>>>>>>>    Define mbX2
85875>>>>>>>>>End_Enum_List
85875>>>>>>>>>
85875>>>>>>>>>Class cWinControl is a DfBaseControl
85876>>>>>>>>>    Procedure Construct_Object
85878>>>>>>>>>        Forward Send Construct_Object
85880>>>>>>>>>        Property Integer private_pbEnabled True
85881>>>>>>>>>        Property Integer private_pbVisible True
85882>>>>>>>>>    End_Procedure
85883>>>>>>>>>    
85883>>>>>>>>>    Procedure End_Construct_Object
85885>>>>>>>>>        Forward Send End_Construct_Object
85887>>>>>>>>>        
85887>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
85888>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
85889>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
85890>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
85891>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
85892>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
85893>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
85894>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
85895>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
85896>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
85897>>>>>>>>>    End_Procedure
85898>>>>>>>>>    
85898>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
85900>>>>>>>>>        //Intentionally cancelled
85900>>>>>>>>>    End_Procedure
85901>>>>>>>>>    
85901>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
85903>>>>>>>>>        //Intentionally cancelled
85903>>>>>>>>>    End_Procedure
85904>>>>>>>>>    
85904>>>>>>>>>    Procedure DoRecreateWindow
85906>>>>>>>>>        // Recreates the window
85906>>>>>>>>>        If (Window_Handle(Self)) Begin
85908>>>>>>>>>            // attempt to do this without disturbing the focus tree.
85908>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
85909>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
85910>>>>>>>>>        End
85910>>>>>>>>>>
85910>>>>>>>>>    End_Procedure
85911>>>>>>>>>    
85911>>>>>>>>>    Procedure DoUpdateWindow
85913>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
85913>>>>>>>>>        Handle hWnd
85913>>>>>>>>>        
85913>>>>>>>>>        Get Window_Handle to hWnd
85914>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
85917>>>>>>>>>    End_Procedure
85918>>>>>>>>>    
85918>>>>>>>>>    Procedure Page Integer iState
85920>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
85921>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
85922>>>>>>>>>        Forward Send Page iState
85924>>>>>>>>>    End_Procedure
85925>>>>>>>>>    
85925>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
85927>>>>>>>>>        Integer x y eButton
85927>>>>>>>>>        
85927>>>>>>>>>        Move (Hi(lParam))  to y
85928>>>>>>>>>        Move (Low(lParam)) to x
85929>>>>>>>>>        
85929>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
85930>>>>>>>>>    End_Procedure
85931>>>>>>>>>    
85931>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
85933>>>>>>>>>        Integer x y eButton
85933>>>>>>>>>        
85933>>>>>>>>>        Move (Hi(lParam))  to y
85934>>>>>>>>>        Move (Low(lParam)) to x
85935>>>>>>>>>        
85935>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
85936>>>>>>>>>    End_Procedure
85937>>>>>>>>>    
85937>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
85939>>>>>>>>>        Integer x y eButton
85939>>>>>>>>>        
85939>>>>>>>>>        Move (Hi(lParam))  to y
85940>>>>>>>>>        Move (Low(lParam)) to x
85941>>>>>>>>>        
85941>>>>>>>>>        Send OnMouseUp mbRight x y wParam
85942>>>>>>>>>    End_Procedure
85943>>>>>>>>>    
85943>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
85945>>>>>>>>>        Integer x y eButton fKeys
85945>>>>>>>>>        
85945>>>>>>>>>        Move (Hi(lParam))  to y
85946>>>>>>>>>        Move (Low(lParam)) to x
85947>>>>>>>>>        
85947>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
85948>>>>>>>>>    End_Procedure
85949>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
85951>>>>>>>>>        Integer x y eButton
85951>>>>>>>>>        
85951>>>>>>>>>        Move (Hi(lParam))  to y
85952>>>>>>>>>        Move (Low(lParam)) to x
85953>>>>>>>>>        
85953>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
85954>>>>>>>>>    End_Procedure
85955>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
85957>>>>>>>>>        Integer x y eButton
85957>>>>>>>>>        
85957>>>>>>>>>        Move (Hi(lParam))  to y
85958>>>>>>>>>        Move (Low(lParam)) to x
85959>>>>>>>>>        
85959>>>>>>>>>        Send OnMouseDown mbRight x y wParam
85960>>>>>>>>>    End_Procedure
85961>>>>>>>>>    
85961>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
85963>>>>>>>>>        Integer x y eButton
85963>>>>>>>>>        
85963>>>>>>>>>        Move (Hi(lParam))  to y
85964>>>>>>>>>        Move (Low(lParam)) to x
85965>>>>>>>>>        
85965>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
85966>>>>>>>>>    End_Procedure
85967>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
85969>>>>>>>>>        Integer x y eButton
85969>>>>>>>>>        
85969>>>>>>>>>        Move (Hi(lParam))  to y
85970>>>>>>>>>        Move (Low(lParam)) to x
85971>>>>>>>>>        
85971>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
85972>>>>>>>>>    End_Procedure
85973>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
85975>>>>>>>>>        Integer x y eButton
85975>>>>>>>>>        
85975>>>>>>>>>        Move (Hi(lParam))  to y
85976>>>>>>>>>        Move (Low(lParam)) to x
85977>>>>>>>>>        
85977>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
85978>>>>>>>>>    End_Procedure
85979>>>>>>>>>    
85979>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
85981>>>>>>>>>        Integer x y eButton
85981>>>>>>>>>        
85981>>>>>>>>>        Move (Hi(lParam))  to y
85982>>>>>>>>>        Move (Low(lParam)) to x
85983>>>>>>>>>        
85983>>>>>>>>>        Send OnMouseMove x y wParam
85984>>>>>>>>>    End_Procedure
85985>>>>>>>>>    
85985>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
85987>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
85987>>>>>>>>>        //String sButton
85987>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
85987>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
85987>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
85987>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
85987>>>>>>>>>        
85987>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
85987>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
85987>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
85987>>>>>>>>>    End_Procedure
85988>>>>>>>>>    
85988>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
85990>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
85990>>>>>>>>>        //String sButton
85990>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
85990>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
85990>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
85990>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
85990>>>>>>>>>        
85990>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
85990>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
85990>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
85990>>>>>>>>>    End_Procedure
85991>>>>>>>>>    
85991>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
85993>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
85993>>>>>>>>>        //String sButton
85993>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
85993>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
85993>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
85993>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
85993>>>>>>>>>        
85993>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
85993>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
85993>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
85993>>>>>>>>>    End_Procedure
85994>>>>>>>>>    
85994>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
85996>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
85996>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
85996>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
85996>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
85996>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
85996>>>>>>>>>        
85996>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
85996>>>>>>>>>    End_Procedure
85997>>>>>>>>>    
85997>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
85999>>>>>>>>>        Handle hWnd
85999>>>>>>>>>        
85999>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
86001>>>>>>>>>            Set private_pbEnabled to bEnabled
86002>>>>>>>>>            Get Window_Handle to hWnd
86003>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
86006>>>>>>>>>        End
86006>>>>>>>>>>
86006>>>>>>>>>    End_Procedure
86007>>>>>>>>>    Function pbEnabled Returns Boolean
86009>>>>>>>>>        Function_Return (private_pbEnabled(Self))
86010>>>>>>>>>    End_Function
86011>>>>>>>>>    
86011>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
86013>>>>>>>>>        Handle  hWnd
86013>>>>>>>>>        Integer iVoid
86013>>>>>>>>>        
86013>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
86015>>>>>>>>>            Set private_pbVisible to bVisible
86016>>>>>>>>>            Get Window_Handle to hWnd
86017>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
86020>>>>>>>>>        End
86020>>>>>>>>>>
86020>>>>>>>>>    End_Procedure
86021>>>>>>>>>    Function pbVisible Returns Boolean
86023>>>>>>>>>        Function_Return (private_pbVisible(Self))
86024>>>>>>>>>    End_Function
86025>>>>>>>>>    
86025>>>>>>>>>End_Class
86026>>>>>>>Use CommCtrl.pkg
86026>>>>>>>
86026>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
86026>>>>>>>Class cProgressBar is a cWinControl
86027>>>>>>>    
86027>>>>>>>    Procedure Construct_Object
86029>>>>>>>        Forward Send Construct_Object
86031>>>>>>>        Property Integer private_piMinimum
86032>>>>>>>        Property Integer private_piMaximum   100
86033>>>>>>>        Property Integer private_piAdvanceBy 10
86034>>>>>>>        Property Integer private_piPosition
86035>>>>>>>        Property Integer private_pbVertical  False
86036>>>>>>>        Property Integer private_pbSmooth    False
86037>>>>>>>        Property Integer private_piBackColor clDefault
86038>>>>>>>        Property Integer private_piBarColor  clDefault
86039>>>>>>>        
86039>>>>>>>        Send Define_ToolTip_Support_Mixin
86040>>>>>>>        
86040>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
86041>>>>>>>        Set Focus_Mode to NonFocusable
86042>>>>>>>        Set Skip_State to True
86043>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
86044>>>>>>>    End_Procedure
86045>>>>>>>    
86045>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
86046>>>>>>>    
86046>>>>>>>    Procedure Set piMinimum Integer iMin
86048>>>>>>>        Integer iMax
86048>>>>>>>        
86048>>>>>>>        Set private_piMinimum to iMin
86049>>>>>>>        Get private_piMaximum to iMax
86050>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
86051>>>>>>>    End_Procedure
86052>>>>>>>    Function piMinimum Returns Integer
86054>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
86057>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
86059>>>>>>>    End_Function
86060>>>>>>>    
86060>>>>>>>    Procedure Set piMaximum Integer iMax
86062>>>>>>>        Integer iMin
86062>>>>>>>        
86062>>>>>>>        Set private_piMaximum to iMax
86063>>>>>>>        Get private_piMinimum to iMin
86064>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
86065>>>>>>>    End_Procedure
86066>>>>>>>    Function piMaximum Returns Integer
86068>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
86071>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
86073>>>>>>>    End_Function
86074>>>>>>>    
86074>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
86076>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
86077>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
86078>>>>>>>    End_Procedure
86079>>>>>>>    Function piAdvanceBy Returns Integer
86081>>>>>>>        Function_Return (private_piAdvanceBy(Self))
86082>>>>>>>    End_Function
86083>>>>>>>    
86083>>>>>>>    Procedure Set piPosition Integer iPos
86085>>>>>>>        Set private_piPosition to iPos
86086>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
86087>>>>>>>    End_Procedure
86088>>>>>>>    
86088>>>>>>>    Function piPosition Returns Integer
86090>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
86093>>>>>>>        Else;            Function_Return (private_piPosition(Self))
86095>>>>>>>    End_Function
86096>>>>>>>    
86096>>>>>>>    Procedure Set pbVertical Boolean bVertical
86098>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
86100>>>>>>>            Set private_pbVertical to bVertical
86101>>>>>>>            Send DoRecreateWindow
86102>>>>>>>        End
86102>>>>>>>>
86102>>>>>>>    End_Procedure
86103>>>>>>>    
86103>>>>>>>    Function pbVertical Returns Boolean
86105>>>>>>>        Function_Return (private_pbVertical(Self))
86106>>>>>>>    End_Function
86107>>>>>>>    
86107>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
86109>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
86111>>>>>>>            Set private_pbSmooth to bSmooth
86112>>>>>>>            Send DoRecreateWindow
86113>>>>>>>        End
86113>>>>>>>>
86113>>>>>>>    End_Procedure
86114>>>>>>>    Function pbSmooth Returns Boolean
86116>>>>>>>        Function_Return (private_pbSmooth(Self))
86117>>>>>>>    End_Function
86118>>>>>>>    
86118>>>>>>>    Procedure Set piBackColor Integer rgbColor
86120>>>>>>>        Set private_piBackColor to rgbColor
86121>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
86122>>>>>>>    End_Procedure
86123>>>>>>>    Function piBackColor Returns Integer
86125>>>>>>>        Function_Return (private_piBackColor(Self))
86126>>>>>>>    End_Function
86127>>>>>>>    
86127>>>>>>>    Procedure Set piBarColor Integer rgbColor
86129>>>>>>>        Set private_piBarColor to rgbColor
86130>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
86131>>>>>>>    End_Procedure
86132>>>>>>>    Function piBarColor Returns Integer
86134>>>>>>>        Function_Return (private_piBarColor(Self))
86135>>>>>>>    End_Function
86136>>>>>>>    
86136>>>>>>>    Procedure DoAdvance
86138>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
86139>>>>>>>    End_Procedure
86140>>>>>>>    
86140>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
86142>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
86143>>>>>>>    End_Procedure
86144>>>>>>>    
86144>>>>>>>    Procedure private_DoInitWindow
86146>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
86147>>>>>>>        Set piBackColor to (private_piBackColor(Self))
86148>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
86149>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
86150>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
86151>>>>>>>        Set piPosition  to (private_piPosition(Self))
86152>>>>>>>    End_Procedure
86153>>>>>>>    
86153>>>>>>>    Procedure Page_Object Integer iState
86155>>>>>>>        Handle hWnd
86155>>>>>>>        
86155>>>>>>>        Get Window_Handle to hWnd
86156>>>>>>>        If (hWnd=0 and iState) Begin
86158>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
86159>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
86160>>>>>>>            Forward Send Page_Object True
86162>>>>>>>        End
86162>>>>>>>>
86162>>>>>>>        Else ;            Forward Send Page_Object iState
86165>>>>>>>        
86165>>>>>>>        // Handle tooltip support....
86165>>>>>>>        If (iState = 0) Begin
86167>>>>>>>            Send RequestDeleteToolTip
86168>>>>>>>        End
86168>>>>>>>>
86168>>>>>>>        Else Begin
86169>>>>>>>            Send RequestAddToolTip
86170>>>>>>>        End
86170>>>>>>>>
86170>>>>>>>    End_Procedure
86171>>>>>>>    
86171>>>>>>>    Procedure Page Integer iState
86173>>>>>>>        Forward Send Page iState
86175>>>>>>>        If (iState =1);            Send private_DoInitWindow
86178>>>>>>>    End_Procedure
86179>>>>>>>    
86179>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
86179>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
86179>>>>>>>    // is implemented in a mixin class.
86179>>>>>>>    Procedure RequestAddToolTip
86181>>>>>>>        Send AddToolTip
86182>>>>>>>    End_Procedure
86183>>>>>>>    
86183>>>>>>>    
86183>>>>>>>    // Called by Page_Object. Handles tooltip removal.
86183>>>>>>>    Procedure RequestDeleteToolTip
86185>>>>>>>        Send DeleteToolTip
86186>>>>>>>    End_Procedure
86187>>>>>>>End_Class
86188>>>>>Use Windows.pkg
86188>>>>>Use DUFLanguageConstants.inc
86188>>>>>Use Statpnl.pkg
86188>>>>>
86188>>>>>
86188>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
86188>>>>>
86188>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
86188>>>>>
86188>>>>>Object Status_Panel is a cProcessStatusPanel
86190>>>>>    Set Size to 152 222
86191>>>>>    Set Border_Style to Border_Dialog
86192>>>>>    Set Icon to "Default.ico"
86193>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
86194>>>>>
86194>>>>>    Property Boolean Cancel_Button_Visible_State True
86196>>>>>
86196>>>>>    Procedure Activate
86199>>>>>        Integer iSizeBefore
86199>>>>>        Get GuiSize to iSizeBefore
86200>>>>>        Forward Send Activate
86202>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
86203>>>>>    End_Procedure
86204>>>>>
86204>>>>>    Procedure End_Construct_Object
86207>>>>>        Forward Send End_Construct_Object
86209>>>>>        Set Label of oTitleTxt      to ""
86210>>>>>        Set Label of oTableNameTxt  to ""
86211>>>>>        Set Label of oMessageTxt    to ""
86212>>>>>        Set Label of oActionTxt     to ""
86213>>>>>    End_Procedure
86214>>>>>
86214>>>>>    Object oTitleTxt is a TextBox
86216>>>>>        Set Location to 5 21
86217>>>>>        Set Size to 8 179
86218>>>>>        Set Auto_Size_State to False
86219>>>>>        Set Justification_Mode  to jMode_Center
86220>>>>>        Set Label to "This is the Title Text"
86221>>>>>    End_Object
86222>>>>>
86222>>>>>    Object oTableNameTxt is a TextBox
86224>>>>>        Set Size to 19 204
86225>>>>>        Set Location to 18 9
86226>>>>>        Set Auto_Size_State to False
86227>>>>>        Set Justification_Mode to JMode_Left
86228>>>>>        Set Label to "This is the TableName Text"
86229>>>>>    End_Object
86230>>>>>
86230>>>>>    Object oMessageTxt is a TextBox
86232>>>>>        Set Location to 39 9
86233>>>>>        Set Size to 19 204
86234>>>>>        Set Auto_Size_State to False
86235>>>>>        Set Justification_Mode to JMode_Left
86236>>>>>        Set Label to "This is the Message text"
86237>>>>>    End_Object
86238>>>>>
86238>>>>>    Object oActionTxt is a TextBox
86240>>>>>        Set Size to 16 204
86241>>>>>        Set Location to 60 9
86242>>>>>        Set Auto_Size_State to False
86243>>>>>        Set Justification_Mode to JMode_Left
86244>>>>>        Set Label to "This is the Action Text"
86245>>>>>    End_Object
86246>>>>>
86246>>>>>    Object oStopButton is a Button
86248>>>>>        Set Location to 123 82
86249>>>>>        Set Label to C_$Cancel
86250>>>>>
86250>>>>>        Procedure OnClick 
86253>>>>>            Integer iRetval
86253>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
86254>>>>>            If (iRetval = MBR_Yes) Begin
86256>>>>>                Send Exit_Application
86257>>>>>            End
86257>>>>>>
86257>>>>>        End_Procedure
86258>>>>>
86258>>>>>    End_Object
86259>>>>>
86259>>>>>    Object oPercentage_tb is a TextBox
86261>>>>>        Set Location to 74 196
86262>>>>>        Set Size to 10 25
86263>>>>>//        Set Label to "% Done"
86263>>>>>    End_Object
86264>>>>>
86264>>>>>    Object oCopyRight is a TextBox
86266>>>>>        Set Location to 140 21
86267>>>>>        Set Size to 9 197
86268>>>>>        Set FontPointHeight to 8
86269>>>>>        Set Auto_Size_State to False
86270>>>>>        Set Justification_Mode  to jMode_Center
86271>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
86272>>>>>    End_Object
86273>>>>>
86273>>>>>    Object oProgressBar is a cProgressBar
86275>>>>>        Set Size to 10 179
86276>>>>>        Set Location to 83 22
86277>>>>>        Set pbVisible to True // default
86278>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
86279>>>>>    End_Object
86280>>>>>
86280>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
86283>>>>>        Set pbVisible of ghoProgressBar to bVisible
86284>>>>>    End_Procedure
86285>>>>>
86285>>>>>    Function Progress_Bar_Visible_State Returns Boolean
86288>>>>>        Boolean bVisible
86288>>>>>        Get pbVisible of ghoProgressBar to bVisible
86289>>>>>        Function_Return (bVisible)
86290>>>>>    End_Function
86291>>>>>
86291>>>>>    Object oProgressBarOverall is a cProgressBar
86293>>>>>        Set Size to 10 179
86294>>>>>        Set Location to 107 22
86295>>>>>        Set pbVisible to True // default
86296>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
86297>>>>>    End_Object
86298>>>>>
86298>>>>>    Object oOverallProgress_tb is a TextBox
86300>>>>>        Set Size to 10 65
86301>>>>>        Set Location to 95 24
86302>>>>>        Set Label to "Overall Progress"
86303>>>>>    End_Object
86304>>>>>
86304>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
86307>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
86308>>>>>    End_Procedure
86309>>>>>
86309>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
86312>>>>>        Boolean bVisible
86312>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
86313>>>>>        Function_Return (bVisible)
86314>>>>>    End_Function
86315>>>>>
86315>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
86315>>>>>    // objects defined within this instance of the status panel.
86315>>>>>
86315>>>>>    // note: all of the messages that change text should be forwarded
86315>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
86315>>>>>
86315>>>>>    Procedure Set Message_Text String sText
86318>>>>>        Set Label of oMessageTxt to sText
86319>>>>>        Forward Set Message_Text to sText
86321>>>>>    End_Procedure
86322>>>>>
86322>>>>>    Function Message_Text Returns String
86325>>>>>        Function_Return (Label(oMessageTxt))
86326>>>>>    End_Function
86327>>>>>
86327>>>>>    Procedure Set Action_Text String sText
86330>>>>>        Set Label of oActionTxt to sText
86331>>>>>        Forward Set Action_Text to sText
86333>>>>>    End_Procedure
86334>>>>>
86334>>>>>    Function Action_Text Returns String
86337>>>>>        Function_Return (Label(oActionTxt))
86338>>>>>    End_Function
86339>>>>>
86339>>>>>    Procedure Set Button_Text String sText
86342>>>>>        Set Label of oStopButton to sText
86343>>>>>        Forward Set Button_Text to sText
86345>>>>>    End_Procedure
86346>>>>>
86346>>>>>    Function Button_Text Returns String
86349>>>>>        Function_Return (Label(oStopButton))
86350>>>>>    End_Function
86351>>>>>
86351>>>>>    Procedure Set Title_Text String sText
86354>>>>>        Set Label of oTitleTxt to sText
86355>>>>>        Forward Set Title_Text to sText
86357>>>>>    End_Procedure
86358>>>>>
86358>>>>>    Function Title_Text Returns String
86361>>>>>        Function_Return (Label(oTitleTxt))
86362>>>>>    End_Function
86363>>>>>
86363>>>>>    Procedure Set TableName_Text String sText
86366>>>>>        Set Label of oTableNameTxt to sText
86367>>>>>    End_Procedure
86368>>>>>
86368>>>>>    Function TableName_Text Returns String
86371>>>>>        Function_Return (Label(oTableNameTxt))
86372>>>>>    End_Function
86373>>>>>
86373>>>>>    Procedure Set License_Text String sText
86376>>>>>//        Set Label of oLicense_txt to sText
86376>>>>>    End_Procedure
86377>>>>>
86377>>>>>    // gets called when status panel is activated passing whether a button
86377>>>>>    // should appear
86377>>>>>    Procedure EnableCancelButton Boolean bEnable
86380>>>>>        Boolean bVisible
86380>>>>>        Get Cancel_Button_Visible_State to bVisible
86381>>>>>        If (bEnable = False) Begin
86383>>>>>            Set Visible_State of oStopButton to bVisible
86384>>>>>        End
86384>>>>>>
86384>>>>>        Set Enabled_State of oStopButton to bEnable
86385>>>>>    End_Procedure
86386>>>>>
86386>>>>>    Procedure Reset_StatusPanel
86389>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
86390>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
86391>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
86392>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
86393>>>>>    End_Procedure
86394>>>>>
86394>>>>>//    Object oProgressBar is a cProgressBar
86394>>>>>//        Move Self to ghoProgressBar
86394>>>>>//        Set Location to 1 25
86394>>>>>//        Set Size to 9 173
86394>>>>>//        Set piMinimum        to 0
86394>>>>>//        Set piMaximum        to 2000
86394>>>>>//        Set piAdvanceBy      to 100
86394>>>>>//        Set pbSmooth to True
86394>>>>>//
86394>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
86394>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
86394>>>>>//        // color will show correctly.
86394>>>>>//        Procedure Page Integer iPageObject
86394>>>>>//            Handle hWin
86394>>>>>//            Forward Send Page iPageObject
86394>>>>>//            If (ghoSkinFramework <> 0) Begin
86394>>>>>//                Get Window_Handle to hWin
86394>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
86394>>>>>//            End
86394>>>>>//        End_Procedure
86394>>>>>//    End_Object
86394>>>>>
86394>>>>>End_Object
86395>>>>>
86395>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
86395>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
86395>>>>>//
86395>>>>>// We need to create a mixin class for the library.
86395>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
86395>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
86395>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
86395>>>>>// Note: This class should _not_ have a construct_object defined.
86395>>>>>//
86395>>>>>Use VdfBase.pkg
86395>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinUuid.pkg)
86395>>>>>>>Use Unicode.Pkg
86395>>>>>>>
86395>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
86396>>>>>>>
86396>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
86397>>>>>>>
86397>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
86398>>>>>>>
86398>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
86399>>>>>>>
86399>>>>>>>
86399>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
86399>>>>>>>Function RandomHexUUID Global Returns String
86401>>>>>>>    Pointer pUUID pUUIDStr
86401>>>>>>>    Integer iRetval iOffset iChar
86401>>>>>>>    String sUUID
86401>>>>>>>    
86401>>>>>>>    Move (Alloc(16)) to pUUID
86402>>>>>>>    
86402>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
86403>>>>>>>    
86403>>>>>>>    If (iRetval = 0) Begin
86405>>>>>>>        Move 0 to pUUIDStr
86406>>>>>>>        
86406>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
86407>>>>>>>        If (iRetval = 0) Begin
86409>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
86410>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
86411>>>>>>>            
86411>>>>>>>            Move (Uppercase (sUUID)) to sUUID
86412>>>>>>>        End
86412>>>>>>>>
86412>>>>>>>    End
86412>>>>>>>>
86412>>>>>>>    
86412>>>>>>>    Move (Free(pUUID)) to iRetval
86413>>>>>>>    
86413>>>>>>>    Function_Return sUUID
86414>>>>>>>End_Function
86415>>>>>>>
86415>>>>>>>
86415>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
86415>>>>>>>Function SeqHexUUID Global Returns String
86417>>>>>>>    Pointer pUUID pUUIDStr
86417>>>>>>>    Integer iRetval iOffset iChar
86417>>>>>>>    String sUUID
86417>>>>>>>    
86417>>>>>>>    Move (Alloc(16)) to pUUID
86418>>>>>>>    
86418>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
86419>>>>>>>    
86419>>>>>>>    If (iRetval = 0) Begin
86421>>>>>>>        Move 0 to pUUIDStr
86422>>>>>>>        
86422>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
86423>>>>>>>        If (iRetval = 0) Begin
86425>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
86426>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
86427>>>>>>>            
86427>>>>>>>            Move (Uppercase (sUUID)) to sUUID
86428>>>>>>>        End
86428>>>>>>>>
86428>>>>>>>    End
86428>>>>>>>>
86428>>>>>>>    
86428>>>>>>>    Move (Free(pUUID)) to iRetval
86429>>>>>>>    
86429>>>>>>>    Function_Return sUUID
86430>>>>>>>End_Function
86431>>>>>Use cli.pkg
86431>>>>>Use sql.pkg
86431>>>>>Use MSSqldrv.pkg
86431>>>>>Use db2_drv.pkg
86431>>>>>Use odbc_drv.pkg
86431>>>>>Use DFBTRDRV.PKG
86431>>>>>Use cSQLConnectionIniFile.inc
86431>>>>>Use cDbUpdateFunctionLibrary.inc
86431>>>>>
86431>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
86432>>>>>    Procedure CreateDbUpdateLibraryProperties
86434>>>>>        Handle hoSQLManagerMT
86434>>>>>
86434>>>>>        Property String private.psUseDatabase ""
86435>>>>>
86435>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
86435>>>>>        Property Handle  private.phCurrentTable 0
86436>>>>>        Property Integer private.piCurrentField 0
86437>>>>>
86437>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
86438>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
86439>>>>>
86439>>>>>        Property Handle phoSQLManagerMT
86440>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
86441>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
86442>>>>>
86442>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
86443>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
86444>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
86445>>>>>        Property Handle phoSQLConnectionHandler 0
86446>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
86447>>>>>
86447>>>>>        Property Boolean pbHandleQueryErrors True
86448>>>>>
86448>>>>>        Property tSqlColumnNew[] paQueryColumns
86449>>>>>        Property String[] paSQLFetchResults
86450>>>>>
86450>>>>>        // Error handling
86450>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
86451>>>>>        Property Boolean pbSqlError False
86452>>>>>        Property tSqlErrorArray paSqlErrorArray
86453>>>>>        Property Boolean pbProcessingError False
86454>>>>>
86454>>>>>        // Statistics on query
86454>>>>>        Property TimeSpan ptsTotalQueryTime
86455>>>>>        Property TimeSpan ptsQueryExec
86456>>>>>        Property TimeSpan ptsFetchResults
86457>>>>>        Property Integer piColumns 0
86458>>>>>        Property Integer piRows 0
86459>>>>>        Property Integer piRowType 0
86460>>>>>        Property String[] paQueryMessages
86461>>>>>        Property String psSQLStatementString
86462>>>>>
86462>>>>>        Property Integer[] paTableConvertExceptions
86463>>>>>
86463>>>>>        Property Integer[] paTableDateCorrectionExceptions
86464>>>>>
86464>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
86464>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
86464>>>>>        // the statements in smaller chunks than to execute them all at the same time.
86464>>>>>        Property Integer piChunkMax 500
86465>>>>>
86465>>>>>        // Fill the paSQLKeywordArray array with values;
86465>>>>>        Send SetupSQLKeywordArray
86466>>>>>        Move Self to ghoDbUpdateFunctionLibrary
86467>>>>>    End_Procedure
86468>>>>>
86468>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
86468>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
86470>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
86472>>>>>            Function_Return (EQ)
86473>>>>>        End
86473>>>>>>
86473>>>>>        Function_Return (GT)
86474>>>>>    End_Function
86475>>>>>
86475>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
86475>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
86477>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
86480>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
86483>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
86486>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
86489>>>>>
86489>>>>>        Function_Return (EQ)
86490>>>>>    End_Function
86491>>>>>
86491>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
86493>>>>>        tSQLKeyWords[] SQLKeywordArray
86493>>>>>        tSQLKeyWords[] SQLKeywordArray
86494>>>>>        Integer iSize
86494>>>>>
86494>>>>>        Get paSQLKeywordArray to SQLKeywordArray
86495>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
86496>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
86497>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
86498>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
86499>>>>>
86499>>>>>        Set paSQLKeywordArray to SQLKeywordArray
86500>>>>>    End_Procedure
86501>>>>>
86501>>>>>    // Creates a struct array with all SQL keywords
86501>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
86501>>>>>    // have slightly different wording.
86501>>>>>    // If a new EN_dbTypexxx type is added; additions
86501>>>>>    // needs to be done for every keyword group below.
86501>>>>>    Procedure SetupSQLKeywordArray
86503>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
86503>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
86505>>>>>
86505>>>>>        // This should only be called once; but in case it is
86505>>>>>        // we delete the array first.
86505>>>>>        Set paSQLKeywordArray to SQLKeywordArray
86506>>>>>
86506>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
86506>>>>>        //
86506>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
86507>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
86508>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
86509>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
86510>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
86511>>>>>
86511>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
86512>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
86513>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
86514>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
86515>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
86516>>>>>
86516>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
86517>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
86518>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
86519>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
86520>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
86521>>>>>
86521>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
86522>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
86523>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
86524>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
86525>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
86526>>>>>
86526>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
86527>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
86528>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
86529>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
86530>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
86531>>>>>
86531>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
86532>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
86533>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
86534>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
86535>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
86536>>>>>
86536>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
86537>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
86538>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
86539>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
86540>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
86541>>>>>
86541>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
86542>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
86543>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
86544>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
86545>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
86546>>>>>
86546>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
86547>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
86548>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86549>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
86550>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
86551>>>>>
86551>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
86552>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
86553>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
86554>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
86555>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
86556>>>>>
86556>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
86557>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
86558>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
86559>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
86560>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
86561>>>>>
86561>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
86562>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
86563>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
86564>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
86565>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
86566>>>>>
86566>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
86567>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
86568>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
86569>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
86570>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
86571>>>>>
86571>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
86572>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
86573>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
86574>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
86575>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
86576>>>>>
86576>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
86577>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
86578>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
86579>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
86580>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
86581>>>>>
86581>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
86582>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
86583>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
86584>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
86585>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
86586>>>>>
86586>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
86587>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
86588>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
86589>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
86590>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
86591>>>>>
86591>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
86592>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
86593>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
86594>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
86595>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
86596>>>>>
86596>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
86597>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
86598>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
86599>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
86600>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
86601>>>>>
86601>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
86602>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
86603>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
86604>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
86605>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
86606>>>>>
86606>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
86607>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
86608>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
86609>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
86610>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
86611>>>>>
86611>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
86612>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
86613>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
86614>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
86615>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
86616>>>>>
86616>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
86617>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
86618>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
86619>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
86620>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
86621>>>>>
86621>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
86622>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
86623>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
86624>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
86625>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
86626>>>>>
86626>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
86627>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
86628>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
86629>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
86630>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
86631>>>>>
86631>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
86632>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
86633>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
86634>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
86635>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
86636>>>>>
86636>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
86637>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
86638>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
86639>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
86640>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
86641>>>>>
86641>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
86642>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
86643>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
86644>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
86645>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
86646>>>>>
86646>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
86647>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
86648>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
86649>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
86650>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
86651>>>>>
86651>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
86652>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
86653>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
86654>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
86655>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
86656>>>>>
86656>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
86657>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
86658>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
86659>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
86660>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
86661>>>>>
86661>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
86662>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
86663>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
86664>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
86665>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
86666>>>>>
86666>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
86667>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
86668>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
86669>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
86670>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
86671>>>>>
86671>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
86672>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
86673>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
86674>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
86675>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
86676>>>>>
86676>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
86677>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
86678>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
86679>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
86680>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
86681>>>>>
86681>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
86682>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
86683>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
86684>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
86685>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
86686>>>>>
86686>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
86687>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
86688>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
86689>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
86690>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
86691>>>>>
86691>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
86692>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
86693>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
86694>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
86695>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
86696>>>>>
86696>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
86697>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
86698>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
86699>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
86700>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
86701>>>>>
86701>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
86702>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
86703>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
86704>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
86705>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
86706>>>>>
86706>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
86707>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
86708>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
86709>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
86710>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
86711>>>>>
86711>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
86712>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
86713>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
86714>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
86715>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
86716>>>>>
86716>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
86717>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
86718>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
86719>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
86720>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
86721>>>>>
86721>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
86722>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
86723>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
86724>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
86725>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
86726>>>>>
86726>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
86726>>>>>        Get paSQLKeywordArray to SQLKeywordArray
86727>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
86728>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
86729>>>>>
86729>>>>>    End_Procedure
86730>>>>>
86730>>>>>End_Class
86731>>>Use cSQLConnectionHandler.pkg
86731>>>Use vWin32fh.pkg
86731>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
86731>>>>>
86731>>>>>Use LanguageText.pkg
86731>>>>>Use Windows.pkg
86731>>>>>Use Dfclient.pkg
86731>>>>>Use DFbitmap.pkg
86731>>>>>Use GlobalFunctionsProcedures.pkg
86731>>>>>Use cRichEdit.pkg
86731>>>>>Use cTextEdit.pkg
86731>>>>>Use cRichEdit.pkg
86731>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 20.1\Pkg\gFormatNumbers.pkg)
86731>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cFormatter.pkg)
86731>>>>>>>>>Use VDFBase.pkg
86731>>>>>>>>>
86731>>>>>>>>>Class cFormatter is an cObject
86732>>>>>>>>>    
86732>>>>>>>>>    Procedure Construct_object
86734>>>>>>>>>        Integer iCh
86734>>>>>>>>>        Forward Send construct_object
86736>>>>>>>>>        Property String  psCurrencySymbol
86737>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
86738>>>>>>>>>        
86738>>>>>>>>>        Property String  psLeft
86739>>>>>>>>>        Property String  psright
86740>>>>>>>>>        Property Integer pbThousandsSep
86741>>>>>>>>>        Property Integer piPoints
86742>>>>>>>>>        
86742>>>>>>>>>        Property String  psCurPosLeft
86743>>>>>>>>>        Property String  psCurPosright
86744>>>>>>>>>        Property Integer pbCurPosThousandsSep
86745>>>>>>>>>        Property Integer piCurPosPoints
86746>>>>>>>>>        
86746>>>>>>>>>        Property String  psCurNegLeft
86747>>>>>>>>>        Property String  psCurNegright
86748>>>>>>>>>        Property Integer pbCurNegThousandsSep
86749>>>>>>>>>        Property Integer piCurNegPoints
86750>>>>>>>>>        
86750>>>>>>>>>        Property String  psNumPosLeft
86751>>>>>>>>>        Property String  psNumPosright
86752>>>>>>>>>        Property Integer pbNumPosThousandsSep
86753>>>>>>>>>        Property Integer piNumPosPoints
86754>>>>>>>>>        
86754>>>>>>>>>        Property String  psNumNegLeft
86755>>>>>>>>>        Property String  psNumNegright
86756>>>>>>>>>        Property Integer pbNumNegThousandsSep
86757>>>>>>>>>        Property Integer piNumNegPoints
86758>>>>>>>>>        
86758>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
86759>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
86760>>>>>>>>>        
86760>>>>>>>>>    End_Procedure
86761>>>>>>>>>    
86761>>>>>>>>>    // internal
86761>>>>>>>>>    // parse passed format string and set temporary properties with result
86761>>>>>>>>>    Procedure ParseFormat String sFmt
86763>>>>>>>>>        
86763>>>>>>>>>        String sLeft sRight sDigit
86763>>>>>>>>>        Integer bSep iPos i iDigits
86763>>>>>>>>>        
86763>>>>>>>>>        // replace any literals. A "/" followed by anything.
86763>>>>>>>>>        // some literals are special. $ . , / #
86763>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
86764>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
86765>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
86766>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
86767>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
86768>>>>>>>>>        Move (Character(9)) to sDigit
86769>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
86770>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
86771>>>>>>>>>        
86771>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
86772>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
86775>>>>>>>>>        
86775>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
86776>>>>>>>>>        
86776>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
86777>>>>>>>>>        
86777>>>>>>>>>        // Move all the special literals back into place before parsing
86777>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
86778>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
86779>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
86780>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
86781>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
86782>>>>>>>>>        
86782>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
86784>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
86785>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
86787>>>>>>>>>                Move -2 to iDigits
86788>>>>>>>>>                Increment i
86789>>>>>>>>>            End
86789>>>>>>>>>>
86789>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
86793>>>>>>>>>                Increment i
86794>>>>>>>>>            Loop
86795>>>>>>>>>>
86795>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
86796>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
86799>>>>>>>>>            //
86799>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
86800>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
86804>>>>>>>>>                Increment i
86805>>>>>>>>>            Loop
86806>>>>>>>>>>
86806>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
86807>>>>>>>>>        End
86807>>>>>>>>>>
86807>>>>>>>>>        Else Begin                             // we have no decinal
86808>>>>>>>>>            Move 0 to iDigits                  // so points is none
86809>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
86810>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
86812>>>>>>>>>                Move sFmt to sLeft
86813>>>>>>>>>                Move ""   to sRight
86814>>>>>>>>>            End
86814>>>>>>>>>>
86814>>>>>>>>>            Else Begin
86815>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
86816>>>>>>>>>                Move 1 to i
86817>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
86821>>>>>>>>>                    Increment i
86822>>>>>>>>>                Loop
86823>>>>>>>>>>
86823>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
86824>>>>>>>>>            End
86824>>>>>>>>>>
86824>>>>>>>>>        End
86824>>>>>>>>>>
86824>>>>>>>>>        // set temporary format properties and exit
86824>>>>>>>>>        Set pbThousandsSep to bSep
86825>>>>>>>>>        Set psLeft         to sLeft
86826>>>>>>>>>        Set psRight        to sRight
86827>>>>>>>>>        Set piPoints       to iDigits
86828>>>>>>>>>    End_Procedure
86829>>>>>>>>>    
86829>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
86829>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
86829>>>>>>>>>    //
86829>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
86829>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
86831>>>>>>>>>        String sPos sNeg
86831>>>>>>>>>        Integer iPos
86831>>>>>>>>>        
86831>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
86832>>>>>>>>>        If iPos Begin
86834>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
86835>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
86836>>>>>>>>>        End
86836>>>>>>>>>>
86836>>>>>>>>>        Else Begin
86837>>>>>>>>>            Move sFmt         to sPos
86838>>>>>>>>>            Move ("-" + sFmt) to sNeg
86839>>>>>>>>>        End
86839>>>>>>>>>>
86839>>>>>>>>>        Send ParseFormat sPos
86840>>>>>>>>>        If bCurrency Begin
86842>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
86843>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
86844>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
86845>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
86846>>>>>>>>>        End
86846>>>>>>>>>>
86846>>>>>>>>>        Else Begin
86847>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
86848>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
86849>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
86850>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
86851>>>>>>>>>        End
86851>>>>>>>>>>
86851>>>>>>>>>        
86851>>>>>>>>>        Send ParseFormat sNeg
86852>>>>>>>>>        If bCurrency Begin
86854>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
86855>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
86856>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
86857>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
86858>>>>>>>>>        End
86858>>>>>>>>>>
86858>>>>>>>>>        Else Begin
86859>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
86860>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
86861>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
86862>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
86863>>>>>>>>>        End
86863>>>>>>>>>>
86863>>>>>>>>>    End_Procedure
86864>>>>>>>>>    
86864>>>>>>>>>    // low level formatting. Pass parameters
86864>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
86866>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
86866>>>>>>>>>        Integer bIsNegative iDec iLen iCh
86866>>>>>>>>>        
86866>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
86869>>>>>>>>>        Move (Character(iCh)) to sDec
86870>>>>>>>>>        
86870>>>>>>>>>        Move (abs(nNumber)) to sNumber
86871>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
86872>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
86873>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
86874>>>>>>>>>        // format for decimal separator
86874>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
86877>>>>>>>>>        
86877>>>>>>>>>        // format for thousand sep.
86877>>>>>>>>>        If bSep Begin
86879>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
86882>>>>>>>>>            Move (Character(iCh)) to sSep
86883>>>>>>>>>            Move (Length(sLeft)) to iLen
86884>>>>>>>>>            While (iLen>3)
86888>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
86889>>>>>>>>>                Move (iLen-3) to iLen
86890>>>>>>>>>            Loop
86891>>>>>>>>>>
86891>>>>>>>>>        End
86891>>>>>>>>>>
86891>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
86891>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
86894>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
86895>>>>>>>>>    End_Function
86896>>>>>>>>>    
86896>>>>>>>>>    // Public: Format for currency
86896>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
86898>>>>>>>>>        String  sLeft sRight
86898>>>>>>>>>        Integer bSep
86898>>>>>>>>>        If (nNumber<0) Begin
86900>>>>>>>>>            Get pbCurNegThousandsSep to bSep
86901>>>>>>>>>            Get psCurNegLeft         to sLeft
86902>>>>>>>>>            Get psCurNegRight        to sRight
86903>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
86906>>>>>>>>>        End
86906>>>>>>>>>>
86906>>>>>>>>>        Else Begin
86907>>>>>>>>>            Get pbCurPosThousandsSep to bSep
86908>>>>>>>>>            Get psCurPosLeft         to sLeft
86909>>>>>>>>>            Get psCurPosRight        to sRight
86910>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
86913>>>>>>>>>        End
86913>>>>>>>>>>
86913>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
86914>>>>>>>>>    End_Function
86915>>>>>>>>>    
86915>>>>>>>>>    // Public: Format for numeric
86915>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
86917>>>>>>>>>        String  sLeft sRight
86917>>>>>>>>>        Integer bSep
86917>>>>>>>>>        If (nNumber<0) Begin
86919>>>>>>>>>            Get pbNumNegThousandsSep to bSep
86920>>>>>>>>>            Get psNumNegLeft         to sLeft
86921>>>>>>>>>            Get psNumNegRight        to sRight
86922>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
86925>>>>>>>>>        End
86925>>>>>>>>>>
86925>>>>>>>>>        Else Begin
86926>>>>>>>>>            Get pbNumPosThousandsSep to bSep
86927>>>>>>>>>            Get psNumPosLeft         to sLeft
86928>>>>>>>>>            Get psNumPosRight        to sRight
86929>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
86932>>>>>>>>>        End
86932>>>>>>>>>>
86932>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
86933>>>>>>>>>    End_Function
86934>>>>>>>>>    
86934>>>>>>>>>    
86934>>>>>>>>>    // Public: Format passing format string
86934>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
86936>>>>>>>>>        Integer iPos bIsNeg
86936>>>>>>>>>        String  sLeft sRight
86936>>>>>>>>>        Integer iPoints bSep
86936>>>>>>>>>        Move (nNumber<0) to bIsNeg
86937>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
86938>>>>>>>>>        Case Begin
86938>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
86941>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
86945>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
86949>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
86951>>>>>>>>>        Case End
86951>>>>>>>>>        Send ParseFormat sFmt
86952>>>>>>>>>        Get pbThousandsSep to bSep
86953>>>>>>>>>        Get psLeft         to sLeft
86954>>>>>>>>>        Get psRight        to sRight
86955>>>>>>>>>        Get piPoints       to iPoints
86956>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
86957>>>>>>>>>    End_Function
86958>>>>>>>>>    
86958>>>>>>>>>End_Class
86959>>>>>>>
86959>>>>>>>Global_Variable Handle ghoFormatter
86959>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
86960>>>>>>>
86960>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
86962>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
86963>>>>>>>End_Function
86964>>>>>>>
86964>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
86966>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
86967>>>>>>>End_Function
86968>>>>>>>
86968>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
86970>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
86971>>>>>>>End_Function
86972>>>>>>>
86972>>>>>>>Procedure SetCurrencyFormat Global String sFmt
86974>>>>>>>    Send SetFormat of ghoFormatter sFmt True
86975>>>>>>>End_Procedure
86976>>>>>>>
86976>>>>>>>Procedure SetNumberFormat Global String sFmt
86978>>>>>>>    Send SetFormat of ghoFormatter sFmt False
86979>>>>>>>End_Procedure
86980>>>>>>>
86980>>>>>>>
86980>>>>>Use tWinStructs.pkg
86980>>>>>
86980>>>>>Use cli.pkg
86980>>>>>Use DFBTRDRV.PKG
86980>>>>>Use MSSqldrv.pkg
86980>>>>>Use db2_drv.pkg
86980>>>>>Use odbc_drv.pkg
86980>>>>>Use seq_chnl.pkg
86980>>>>>
86980>>>>>Register_Function phoWorkspace Returns Handle
86980>>>>>Register_Function Help_filename Returns String
86980>>>>>Register_Function GetHelpFile Returns String
86980>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
86980>>>>>
86980>>>>>// Use of Mertech drivers:
86980>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
86980>>>>>    Use mertech.inc
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>// *** Constant Declarations: ***
86980>>>>>//
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>
86980>>>>>// System icon menu constants. If the upper left hand
86980>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
86980>>>>>    Define SC_RESTORE  for |CI$F120
86980>>>>>    Define SC_MOVE     for |CI$F010
86980>>>>>    Define SC_SIZE     for |CI$F000
86980>>>>>    Define SC_MINIMIZE for |CI$F020
86980>>>>>    Define SC_MAXIMIZE for |CI$F030
86980>>>>>    Define SC_CLOSE    for |CI$F060
86980>>>>>    Define SC_KEYMENU  for |CI$F100
86980>>>>>    Define SC_NEXTWINDOW for |CI$F040
86980>>>>>    Define SC_PREVWINDOW for |CI$F050
86980>>>>>
86980>>>>>Define CS_SignProgram        for "signtool.exe"
86980>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
86980>>>>>Define CS_VerifyCredentials  for "verify"
86980>>>>>Define CS_VerifyFileParam    for "/a"
86980>>>>>Define CS_DefAuthVerPolicy   for "/pa"
86980>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
86980>>>>>
86980>>>>>// *** Struct Declarations: ***
86980>>>>>
86980>>>>>Struct AboutSHELLEXECUTEINFO
86980>>>>>    DWord   cbSize
86980>>>>>    Integer fMask
86980>>>>>    Handle  hwnd
86980>>>>>    Pointer lpVerb
86980>>>>>    Pointer lpFile
86980>>>>>    Pointer lpParameters
86980>>>>>    Pointer lpDirectory
86980>>>>>    Integer nShow
86980>>>>>    Pointer hInstApp
86980>>>>>    Pointer lpIDList
86980>>>>>    Pointer lpClass
86980>>>>>    Handle  hkeyClass
86980>>>>>    DWord   dwHotKey
86980>>>>>    Handle  hIconMonitor // Union
86980>>>>>    //Handle  hMonitor     // Union
86980>>>>>    Handle  hProcess
86980>>>>>End_Struct
86980>>>>>
86980>>>>>
86980>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
86980>>>>>//Type MEMORYSTATUS
86980>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
86980>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
86980>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
86980>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
86980>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
86980>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
86980>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
86980>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
86980>>>>>//End_Type
86980>>>>>
86980>>>>>// *** External Function calls: ***
86980>>>>>//
86980>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
86981>>>>>
86981>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
86982>>>>>
86982>>>>>// Do not call directly, use the wrapper function instead
86982>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
86983>>>>>
86983>>>>>    // Wrapper Function WNetGetUser
86983>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
86985>>>>>
86985>>>>>        DWord   dwResult
86985>>>>>        UWide   uwName uwUserName
86985>>>>>        UWide   uwName uwUserName
86985>>>>>
86985>>>>>        Send StringToWide lpName (&uwName)
86986>>>>>
86986>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
86987>>>>>
86987>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
86988>>>>>
86988>>>>>        Send WideToString (&uwUserName) lpUser_Name
86989>>>>>
86989>>>>>        Function_Return dwResult
86990>>>>>    End_Function
86991>>>>>
86991>>>>>
86991>>>>>
86991>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
86992>>>>>
86992>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
86993>>>>>
86993>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
86994>>>>>
86994>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
86995>>>>>
86995>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
86996>>>>>
86996>>>>>// *** Global/Desktop Function Declarations: ***
86996>>>>>
86996>>>>>Function ComputerName Desktop Returns String
86998>>>>>    String sName
86998>>>>>    Get_Environment "COMPUTERNAME" to sName
86999>>>>>>
86999>>>>>    Function_Return sName
87000>>>>>End_Function
87001>>>>>
87001>>>>>Function Network_User_Name Desktop Returns String
87003>>>>>    WString wName
87003>>>>>    Integer iRetval iLength
87003>>>>>
87003>>>>>    Move 0 to iLength
87004>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
87005>>>>>    Move (ZeroString(iLength)) to wName
87006>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
87007>>>>>
87007>>>>>    If (iRetval = NO_ERROR) Begin
87009>>>>>        Function_Return (CString (wName))
87010>>>>>    End
87010>>>>>>
87010>>>>>
87010>>>>>    Function_Return "User Unknown"
87011>>>>>End_Function
87012>>>>>
87012>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
87014>>>>>    String sClient sDriver sClientDriver
87014>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
87014>>>>>    Handle hoMsqlDrv
87014>>>>>
87014>>>>>    Move 0 to iDriver
87015>>>>>    Move "" to sClient
87016>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
87019>>>>>    For iCount from 1 to iNumberOfDrivers
87025>>>>>>
87025>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
87028>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
87030>>>>>            Move iCount to iDriver
87031>>>>>            Move iNumberOfDrivers to iCount // We're done.
87032>>>>>        End
87032>>>>>>
87032>>>>>    Loop
87033>>>>>>
87033>>>>>
87033>>>>>    // This info is (at current) only available for the MS SQL driver:
87033>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
87035>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
87038>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
87039>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
87040>>>>>        Send Destroy of hoMsqlDrv
87041>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
87042>>>>>    End
87042>>>>>>
87042>>>>>
87042>>>>>    Function_Return sClient
87043>>>>>End_Function
87044>>>>>
87044>>>>>// *** Class Declarations: ***
87044>>>>>//
87044>>>>>Class cBitmapContainerDFLink is a BitmapContainer
87045>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
87047>>>>>        Send Mouse_Up iWindowNumber iPosition
87048>>>>>    End_Procedure
87049>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
87051>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
87053>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
87054>>>>>    End_Procedure
87055>>>>>End_Class
87056>>>>>
87056>>>>>Class cCopyEditorContentButton is a Button
87057>>>>>    Procedure Construct_Object
87059>>>>>        Forward Send Construct_Object
87061>>>>>        Property Handle phoEditorHandle
87062>>>>>        Set psToolTip to C_$DescCopy
87063>>>>>    End_Procedure
87064>>>>>
87064>>>>>    Procedure CopyToWindowsClipboard
87066>>>>>        Handle hoEditor
87066>>>>>        Boolean bCanCopy
87066>>>>>        Address aEditorAddress
87066>>>>>
87066>>>>>        Get phoEditorHandle to hoEditor
87067>>>>>        Send Select_All of hoEditor
87068>>>>>        Get CanCopy of hoEditor to bCanCopy
87069>>>>>        If (bCanCopy = True) Begin
87071>>>>>            Get paValue of hoEditor to aEditorAddress
87072>>>>>            Send Copy   of hoEditor
87073>>>>>            // Remove the selection after text is copied to the clipboard.
87073>>>>>            Send Beginning_of_Data of hoEditor
87074>>>>>            Send Info_Box C_$CopyToClipboard_Text
87075>>>>>        End
87075>>>>>>
87075>>>>>    End_Procedure
87076>>>>>End_Class
87077>>>>>
87077>>>>>Class SysinfoDisplay is a cTextEdit
87078>>>>>    Procedure Construct_Object
87080>>>>>        Forward Send Construct_Object
87082>>>>>
87082>>>>>        Set Size to 100 245
87083>>>>>        Set Location to 6 6
87084>>>>>        Set Border_Style to Border_None
87085>>>>>        Set Read_Only_State to True
87086>>>>>        Set pbWrap to True
87087>>>>>        Set peAnchors to anAll
87088>>>>>    End_Procedure
87089>>>>>
87089>>>>>    // Augmented class message to adjust certain text strings that are wrong...
87089>>>>>
87089>>>>>    Procedure AppendTextLn String sText
87091>>>>>        String sWorkspaceWSFile
87091>>>>>
87091>>>>>        // Only works for English:
87091>>>>>        If (ghoApplication > 0) Begin
87093>>>>>            If (sText contains "Workspace Name") Begin
87095>>>>>                Move "Workspace Config Filename:" to sText
87096>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
87097>>>>>                Move (sText * sWorkspaceWSFile) to sText
87098>>>>>            End
87098>>>>>>
87098>>>>>        End
87098>>>>>>
87098>>>>>        Send AppendText sText
87099>>>>>        Send AppendText (character(10))
87100>>>>>    End_Procedure
87101>>>>>
87101>>>>>    //    This method will show the name Of the current directory in the system
87101>>>>>    //    information box
87101>>>>>    Procedure Show_Current_Directory
87103>>>>>        String sDir
87103>>>>>
87103>>>>>        Get_Current_Directory To sDir
87104>>>>>
87104>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
87105>>>>>    End_Procedure
87106>>>>>
87106>>>>>    Procedure Show_Windows_Directory
87108>>>>>        String sWindir
87108>>>>>
87108>>>>>        Get_Windows_Directory To sWindir
87109>>>>>
87109>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
87110>>>>>    End_Procedure
87111>>>>>
87111>>>>>    Procedure Show_Current_User
87113>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
87114>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
87115>>>>>    End_Procedure
87116>>>>>
87116>>>>>    Procedure Show_Number_Format
87118>>>>>        Integer iFormat
87118>>>>>        String sFormatText
87118>>>>>
87118>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
87121>>>>>        Move (Character (iFormat)) To sFormatText
87122>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
87123>>>>>
87123>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
87126>>>>>        Move (Character (iFormat)) to sFormatText
87127>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
87128>>>>>    End_Procedure
87129>>>>>
87129>>>>>    Procedure Show_Filelist_Name
87131>>>>>        String sFilename
87131>>>>>
87131>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
87134>>>>>
87134>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
87135>>>>>    End_Procedure
87136>>>>>
87136>>>>>    Procedure Show_Lock_Delay
87138>>>>>        Integer iLockdelay
87138>>>>>
87138>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
87141>>>>>
87141>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
87142>>>>>    End_Procedure
87143>>>>>
87143>>>>>    Procedure Show_Lock_Timeout
87145>>>>>        Integer iLockTimeout
87145>>>>>
87145>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
87148>>>>>
87148>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
87149>>>>>    End_Procedure
87150>>>>>
87150>>>>>    Procedure Show_Screen_Size
87152>>>>>        Integer iYscreensize iXscreensize
87152>>>>>
87152>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
87153>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
87154>>>>>
87154>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
87155>>>>>    End_Procedure
87156>>>>>
87156>>>>>    Procedure Show_Page_Size
87158>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
87159>>>>>    End_procedure
87160>>>>>
87160>>>>>    Procedure Show_Date
87162>>>>>        Date dToday
87162>>>>>
87162>>>>>        Move (CurrentDateTime()) to dToday
87163>>>>>
87163>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
87164>>>>>    End_procedure
87165>>>>>
87165>>>>>    Procedure Show_Date_Format
87167>>>>>        Integer iDateFormat
87167>>>>>        String sDateFormat
87167>>>>>
87167>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
87170>>>>>        Case Begin
87170>>>>>            Case (iDateFormat = DF_DATE_USA)
87172>>>>>                Move C_$USA To sDateFormat
87173>>>>>                Case Break
87174>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
87177>>>>>                Move C_$European To sDateFormat
87178>>>>>                Case Break
87179>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
87182>>>>>                Move C_$Military To sDateFormat
87183>>>>>                Case Break
87184>>>>>            Case Else
87184>>>>>                Move C_$UnknownDateType To sDateFormat
87185>>>>>                Case Break
87186>>>>>        Case End
87186>>>>>
87186>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
87187>>>>>    End_Procedure
87188>>>>>
87188>>>>>    // 2013-08-14 NGS
87188>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
87188>>>>>    Procedure Show_Systemresources
87190>>>>>        tWinMemoryStatusEx MemoryStatusInfo
87190>>>>>        tWinMemoryStatusEx MemoryStatusInfo
87190>>>>>        Integer iRetval
87190>>>>>        Number nValue
87190>>>>>        String sValue
87190>>>>>
87190>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
87191>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
87192>>>>>        If (iRetval = 0) Begin
87194>>>>>            Move (ShowLastError ()) to iRetval
87195>>>>>            Procedure_Return
87196>>>>>        End
87196>>>>>>
87196>>>>>
87196>>>>>        Send AppendTextLn ""
87197>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
87198>>>>>
87198>>>>>        // Show memory in Gigabytes:
87198>>>>>        Move (nValue/1024/1024/1024) to nValue
87199>>>>>        Move (Round(nValue)) to nValue
87200>>>>>        Get FormatNumber nValue 2 to sValue
87201>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
87202>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
87203>>>>>
87203>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
87203>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
87204>>>>>        Move (Round(nValue)) to nValue
87205>>>>>        Get FormatNumber nValue 0 to sValue
87206>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
87207>>>>>
87207>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
87207>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
87208>>>>>        Move (Round(nValue)) to nValue
87209>>>>>        Get FormatNumber nValue 0 to sValue
87210>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
87211>>>>>
87211>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
87211>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
87212>>>>>        Move (Round(nValue)) to nValue
87213>>>>>        Get FormatNumber nValue 0 to sValue
87214>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
87215>>>>>
87215>>>>>        // Add an empty row after the memory information:
87215>>>>>        Send AppendTextLn ""
87216>>>>>    End_Procedure
87217>>>>>
87217>>>>>    Procedure Show_Registration
87219>>>>>        String sRegName
87219>>>>>        Integer iSN iUsersMax iUserCount
87219>>>>>
87219>>>>>        Registration sRegName iSN
87220>>>>>>
87220>>>>>        Get_Licensed_Max_Users to iUsersMax
87221>>>>>        Get_Current_User_Count to iUserCount
87222>>>>>
87222>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
87223>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
87224>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
87225>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
87226>>>>>    End_Procedure
87227>>>>>
87227>>>>>    //****************************************************************************
87227>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
87227>>>>>    // To the workspace object passing the an object and message To send back
87227>>>>>    // To this object. It is expected that the workspace object will send this
87227>>>>>    // message for every line Of information it wants displayed (passing the
87227>>>>>    // information To be displayed
87227>>>>>    //****************************************************************************
87227>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
87227>>>>>
87227>>>>>    Procedure Show_ServicePack
87229>>>>>        String sKey sVersion sDataFlex
87229>>>>>        Handle hoRegistry
87229>>>>>        Boolean bExists bOpened
87229>>>>>
87229>>>>>        Move "DataFlex"        to sDataFlex
87230>>>>>
87230>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
87231>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
87232>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
87233>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
87234>>>>>
87234>>>>>        If (bExists) Begin
87236>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
87237>>>>>        End
87237>>>>>>
87237>>>>>        Else Begin
87238>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
87239>>>>>        End
87239>>>>>>
87239>>>>>        Get KeyExists of hoRegistry sKey to bExists
87240>>>>>        If (bExists) Begin
87242>>>>>            Get OpenKey of hoRegistry sKey to bOpened
87243>>>>>            If (bOpened) Begin
87245>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
87246>>>>>                If (bExists) Begin
87248>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
87249>>>>>                End
87249>>>>>>
87249>>>>>                Send CloseKey of hoRegistry
87250>>>>>            End
87250>>>>>>
87250>>>>>        End
87250>>>>>>
87250>>>>>        Send Destroy of hoRegistry
87251>>>>>
87251>>>>>        If (sVersion <> "") Begin
87253>>>>>           Send AppendTextLn sVersion
87254>>>>>           Send AppendTextLn ""
87255>>>>>        End
87255>>>>>>
87255>>>>>    End_Procedure
87256>>>>>
87256>>>>>    Procedure Show_WorkspaceInformation
87258>>>>>        Integer hoWorkspace
87258>>>>>
87258>>>>>        If (ghoApplication <> 0) Begin
87260>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
87261>>>>>            If (hoWorkspace <> 0) Begin
87263>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
87264>>>>>            End
87264>>>>>>
87264>>>>>        End
87264>>>>>>
87264>>>>>    End_Procedure
87265>>>>>
87265>>>>>    //****************************************************************************
87265>>>>>    // If connection ids are used, we will send the message EnumerateConnections
87265>>>>>    // to the connection manager object passing the an object and message to send
87265>>>>>    // back to this object. It is expected that the connection manager object will
87265>>>>>    // send this message for every line Of information it wants displayed (passing
87265>>>>>    // the information To be displayed
87265>>>>>    //****************************************************************************
87265>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
87265>>>>>
87265>>>>>    Procedure Show_ConnectionIdInformation
87267>>>>>        If (ghoConnection > 0) Begin
87269>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
87270>>>>>            Send AppendTextLn ""
87271>>>>>        End
87271>>>>>>
87271>>>>>    End_Procedure
87272>>>>>
87272>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
87274>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
87275>>>>>    End_Function
87276>>>>>
87276>>>>>    Procedure Show_Versions
87278>>>>>        Integer iVersion iRevision iBuild
87278>>>>>
87278>>>>>        Version_information iVersion iRevision iBuild
87280>>>>>
87280>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
87281>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
87282>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
87283>>>>>        Send AppendTextLn "This is a 32-bit exe file"
87284>>>>>    End_Procedure
87285>>>>>
87285>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
87287>>>>>        Boolean bOK
87287>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
87288>>>>>        Function_Return bOK
87289>>>>>    End_Function
87290>>>>>
87290>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
87292>>>>>        Boolean bOK
87292>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
87293>>>>>        Function_Return bOK
87294>>>>>    End_Function
87295>>>>>
87295>>>>>    //***
87295>>>>>    //*** BW
87295>>>>>    //*** Procedure: Show_Drivers
87295>>>>>    //*** Purpose  : Show loaded database drivers
87295>>>>>    //***
87295>>>>>
87295>>>>>    Procedure Show_Drivers
87297>>>>>        String sDriverID sVersion sClient sValue
87297>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
87297>>>>>        Handle hoCLIHandler hoBtrvHandler
87297>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
87297>>>>>
87297>>>>>        Move False to bStudioLicense
87298>>>>>
87298>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
87299>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
87300>>>>>
87300>>>>>        // For testing purposes:
87300>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87300>>>>>//        Load_Driver MSSQLDRV_ID
87300>>>>>//        Load_Driver ODBC_DRV_ID
87300>>>>>//        Load_Driver DB2_DRV_ID
87300>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87300>>>>>//
87300>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
87300>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87300>>>>>//            Load_Driver SQLFLEX
87300>>>>>//            Load_Driver MDSPgSQL
87300>>>>>//            Load_Driver MDSMySQL
87300>>>>>//            Load_Driver ORAFLEX
87300>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87300>>>>>//        #ENDIF
87300>>>>>        Move False to Err
87301>>>>>
87301>>>>>        // Loop through all loaded drivers.
87301>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
87304>>>>>        If (iNumberOfDrivers > 1) Begin
87306>>>>>            Send AppendTextLn ""
87307>>>>>        End
87307>>>>>>
87307>>>>>        For iDriver from 1 to iNumberOfDrivers
87313>>>>>>
87313>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
87313>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
87313>>>>>            // would be thrown, so we safeguard from that here.
87313>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
87314>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
87317>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
87318>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
87319>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
87320>>>>>
87320>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
87322>>>>>
87322>>>>>                // Pervasive/Btrieve database
87322>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
87324>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
87325>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
87326>>>>>                    If (sClient <> "0.0.0") Begin
87328>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
87329>>>>>                    End
87329>>>>>>
87329>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
87330>>>>>                    If (sClient <> "0.0.0") Begin
87332>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
87333>>>>>                    End
87333>>>>>>
87333>>>>>                End
87333>>>>>>
87333>>>>>
87333>>>>>                Else Begin
87334>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
87335>>>>>                    Move 0 to iNumServers
87336>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87338>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
87341>>>>>                    End
87341>>>>>>
87341>>>>>
87341>>>>>                    If (bIsDAWDriver = True) Begin
87343>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
87345>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
87346>>>>>                        End
87346>>>>>>
87346>>>>>                        Get CKRevision of hoCLIHandler to sVersion
87347>>>>>                    End
87347>>>>>>
87347>>>>>
87347>>>>>                    If (bIsMertechDriver = True) Begin
87349>>>>>                        GET_DRIVER_REVISION to sVersion
87386>>>>>>
87386>>>>>                    End
87386>>>>>>
87386>>>>>
87386>>>>>                    // If the serialnumber is = 0, it means that the
87386>>>>>                    // Studio licens is in use and there is no
87386>>>>>                    // number of max users defined because the driver is
87386>>>>>                    // relying on the info from the VDF license.
87386>>>>>                    If (bStudioLicense = False) Begin
87388>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
87389>>>>>                        Move (iSerialNo = 0) to bStudioLicense
87390>>>>>                    End
87390>>>>>>
87390>>>>>                End
87390>>>>>>
87390>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
87391>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
87393>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
87394>>>>>                End
87394>>>>>>
87394>>>>>                If (iNumServers <> 0) Begin
87396>>>>>                    For iCount from 1 to iNumServers
87402>>>>>>
87402>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
87405>>>>>                        If (not(sValue contains ";PWD=")) Begin
87407>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
87408>>>>>                        End
87408>>>>>>
87408>>>>>                    Loop
87409>>>>>>
87409>>>>>                End
87409>>>>>>
87409>>>>>            End
87409>>>>>>
87409>>>>>        Loop
87410>>>>>>
87410>>>>>
87410>>>>>        Send AppendTextLn ""
87411>>>>>        If (bStudioLicense = False) Begin
87413>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
87414>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
87415>>>>>        End
87415>>>>>>
87415>>>>>        Else Begin
87416>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
87417>>>>>        End
87417>>>>>>
87417>>>>>        Send Destroy of hoCLIHandler
87418>>>>>        Send Destroy of hoBtrvHandler
87419>>>>>    End_Procedure
87420>>>>>
87420>>>>>    Procedure Show_HelpFile
87422>>>>>        String sHelpFile
87422>>>>>        Integer eHelpType
87422>>>>>
87422>>>>>        If (ghoApplication <> 0) Begin
87424>>>>>            Get peHelpType Of ghoApplication To eHelpType
87425>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
87427>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
87428>>>>>            End
87428>>>>>>
87428>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
87431>>>>>                Get Help_filename Of Help_object_id To sHelpFile
87432>>>>>            End
87432>>>>>>
87432>>>>>            Else Begin
87433>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
87434>>>>>            End
87434>>>>>>
87434>>>>>
87434>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
87435>>>>>        End
87435>>>>>>
87435>>>>>    End_Procedure
87436>>>>>
87436>>>>>    Procedure Show_EnterAsTab
87438>>>>>        Boolean bEnterKeyAsTabKey
87438>>>>>        String sText
87438>>>>>
87438>>>>>        If (ghoApplication <> 0) Begin
87440>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
87441>>>>>            If (bEnterKeyAsTabKey) Begin
87443>>>>>                Move "True" To sText
87444>>>>>            End
87444>>>>>>
87444>>>>>            Else Begin
87445>>>>>                Move "False" To sText
87446>>>>>            End
87446>>>>>>
87446>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
87447>>>>>        End
87447>>>>>>
87447>>>>>    End_Procedure
87448>>>>>
87448>>>>>    //    During activation we will remove the old information and add the newly
87448>>>>>    //    found systeminformation
87448>>>>>    Procedure Add_Focus Integer hoRoot
87450>>>>>        Forward Send Add_Focus hoRoot
87452>>>>>
87452>>>>>        Send Delete_Data
87453>>>>>
87453>>>>>        Set Changed_State To False
87454>>>>>        Set Read_Only_State To True
87455>>>>>
87455>>>>>        Send Show_Registration
87456>>>>>        Send Show_Drivers
87457>>>>>        Send Show_ServicePack
87458>>>>>        Send Show_Versions
87459>>>>>        Send AppendTextLn ""
87460>>>>>
87460>>>>>        If (ghoApplication <> 0) Begin
87462>>>>>            Send Show_WorkSpaceInformation
87463>>>>>            Send Show_HelpFile
87464>>>>>            Send AppendTextLn ""
87465>>>>>        End
87465>>>>>>
87465>>>>>        Else Begin
87466>>>>>            Send AppendTextLn ""
87467>>>>>        End
87467>>>>>>
87467>>>>>
87467>>>>>        If (ghoConnection <> 0) Begin
87469>>>>>            Send Show_ConnectionIdInformation
87470>>>>>        End
87470>>>>>>
87470>>>>>
87470>>>>>        Send Show_Current_User
87471>>>>>        Send Show_Windows_Directory
87472>>>>>        Send Show_Current_Directory
87473>>>>>
87473>>>>>        // This is already shown in the workspace details,
87473>>>>>        // unless no workspace object is present:
87473>>>>>        If (ghoApplication = 0) Begin
87475>>>>>            Send Show_Filelist_Name
87476>>>>>        End
87476>>>>>>
87476>>>>>
87476>>>>>        If (ghoApplication <> 0) Begin
87478>>>>>            Send AppendTextLn ""
87479>>>>>            Send Show_EnterAsTab
87480>>>>>        End
87480>>>>>>
87480>>>>>
87480>>>>>        Send Show_Screen_Size
87481>>>>>        Send Show_Page_Size
87482>>>>>        Send Show_Number_Format
87483>>>>>        Send Show_Date_Format
87484>>>>>        Send Show_Lock_Delay
87485>>>>>        Send Show_Lock_Timeout
87486>>>>>        Send Show_Date
87487>>>>>        Send Show_Systemresources
87488>>>>>        Send Beginning_of_Data
87489>>>>>
87489>>>>>        Set Icon to 'default.ico'
87490>>>>>    End_Procedure
87491>>>>>End_Class
87492>>>>>
87492>>>>>Class SysInfoDialog is a ModalPanel
87493>>>>>    Procedure Construct_Object
87495>>>>>        Forward Send Construct_Object
87497>>>>>
87497>>>>>        Set Label to C_$SystemInformation
87498>>>>>        Set Size to 140 267
87499>>>>>        Set Locate_Mode to CENTER_ON_PARENT
87500>>>>>        Set Border_Style to Border_Thick
87501>>>>>        Set Sysmenu_Icon to False
87502>>>>>
87502>>>>>        // "+1" will make the panel to paint correctly.
87502>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
87503>>>>>
87503>>>>>        // 2014-09-14 NGS
87503>>>>>        // Added a container object around the cTexteditor
87503>>>>>        // object to get a border around the text.
87503>>>>>        Object oSysinfoDisplayContainer is a Container3d
87505>>>>>            Set Location to 2 4
87506>>>>>            Set Size to 110 255
87507>>>>>            Set Border_Style to Border_ClientEdge
87508>>>>>            Set Color to clWhite
87509>>>>>            Set peAnchors to anAll
87510>>>>>
87510>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
87512>>>>>            End_Object
87513>>>>>
87513>>>>>        End_Object
87514>>>>>
87514>>>>>        Object oCloseButton is a Button
87516>>>>>            Set Label to C_$Close
87517>>>>>            Set Location to 120 210
87518>>>>>            Set Message item 0 to msg_Close_Panel
87519>>>>>            Set Default_State To True
87520>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
87520>>>>>            // and changes its peAnchors, we might as well prepare this object
87520>>>>>            // for that situation.
87520>>>>>            Set peAnchors to anBottomRight
87521>>>>>        End_Object
87522>>>>>
87522>>>>>        Object oCopyButton is a cCopyEditorContentButton
87524>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
87525>>>>>            Set Size to 14 50
87526>>>>>            Set Location to 120 158
87527>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87527>>>>>            // we might as well prepare the object for it.
87527>>>>>            Set peAnchors to anBottomRight
87528>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
87529>>>>>        End_Object
87530>>>>>
87530>>>>>        On_Key kCancel Send Close_Panel
87531>>>>>    End_Procedure
87532>>>>>
87532>>>>>    Procedure Page Integer iPageObject
87534>>>>>        Handle hMenu
87534>>>>>        Integer iPrevState
87534>>>>>
87534>>>>>        Forward Send Page iPageObject
87536>>>>>
87536>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
87536>>>>>        //
87536>>>>>    End_Procedure
87537>>>>>
87537>>>>>End_Class
87538>>>>>
87538>>>>>Class cAboutEdit is an cRichEdit
87539>>>>>    Procedure Construct_Object
87541>>>>>        Forward Send Construct_Object
87543>>>>>
87543>>>>>        Property String psContentText
87544>>>>>
87544>>>>>        Set Size to 77 153
87545>>>>>        Set Location to 8 60
87546>>>>>        Set Read_Only_State to True
87547>>>>>        Set Skip_State to True
87548>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
87548>>>>>        // or 1/20 of a printer's point.
87548>>>>>        Set piRightMargin to (0.1 * 1440)
87549>>>>>        Set Border_Style  to Border_None
87550>>>>>    End_Procedure
87551>>>>>
87551>>>>>    // Adds a line of text to the edit object
87551>>>>>    Procedure Add_Line String sText
87553>>>>>        String sContentText
87553>>>>>        Get psContentText to sContentText
87554>>>>>        Move (sContentText + String(sText)) to sContentText
87555>>>>>        Set psContentText to sContentText
87556>>>>>    End_Procedure
87557>>>>>
87557>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
87557>>>>>    // Note that we use a property psContentText and add to it,
87557>>>>>    // because the object isn't paged yet when we add these
87557>>>>>    // values and the COM edit object needs to be paged
87557>>>>>    // for the text to become visible. See Also: Procedure Page below.
87557>>>>>    Procedure Add_LineLn String sText
87559>>>>>        String sContentText sCR
87559>>>>>
87559>>>>>        Move (Character(10) + String(Character(13))) to sCR
87560>>>>>        Get psContentText to sContentText
87561>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
87562>>>>>        Set psContentText to sContentText
87563>>>>>    End_Procedure
87564>>>>>
87564>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
87566>>>>>        String sLinkText
87566>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
87567>>>>>        Send Show_HomePage sLinkText
87568>>>>>    End_Procedure
87569>>>>>
87569>>>>>    Procedure Page Integer iPageObject
87571>>>>>        String sContentText
87571>>>>>
87571>>>>>        Forward Send Page iPageObject
87573>>>>>        Get psContentText to sContentText
87574>>>>>        Send AppendText sContentText
87575>>>>>        send Beginning_of_Data
87576>>>>>    End_Procedure
87577>>>>>
87577>>>>>End_Class
87578>>>>>
87578>>>>>Class AboutDialog is a ModalPanel
87579>>>>>    Procedure Construct_Object
87581>>>>>
87581>>>>>        Forward Send Construct_Object
87583>>>>>
87583>>>>>        Set Label to C_$About
87584>>>>>        Set Size to 118 230
87585>>>>>        Set Locate_Mode to CENTER_ON_PARENT
87586>>>>>        Set Border_Style to Border_Thick
87587>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
87588>>>>>
87588>>>>>        Object oSysInfoDialog is a SysInfoDialog
87590>>>>>        End_Object
87591>>>>>
87591>>>>>        Object oBox is a Container3d
87593>>>>>            Set Border_Style to Border_Normal
87594>>>>>            Set Size to 90 220
87595>>>>>            Set Location to 4 5
87596>>>>>            Set Color to clWhite
87597>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87597>>>>>            // we might as well prepare the object for it.
87597>>>>>            Set peAnchors to anAll
87598>>>>>
87598>>>>>            Object oAboutGraphic is a BitmapContainer
87600>>>>>                Set Border_Style To Border_None
87601>>>>>                Set Bitmap_Style to Bitmap_Center
87602>>>>>                Set Color to clWhite
87603>>>>>                Set Size to 45 50
87604>>>>>                Set Location to 0 3
87605>>>>>            End_Object
87606>>>>>
87606>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
87608>>>>>                Set Border_Style to Border_None
87609>>>>>                Set Bitmap_Style to Bitmap_Center
87610>>>>>                Set Color to clWhite
87611>>>>>                Set Size to 30 55
87612>>>>>                Set Location to 50 3
87613>>>>>            End_Object
87614>>>>>
87614>>>>>            Object oInfoList_Editor is an cAboutEdit
87616>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
87616>>>>>                // we might as well prepare the object for it.
87616>>>>>                Set peAnchors to anAll
87617>>>>>            End_Object
87618>>>>>
87618>>>>>            // These objects are here for backwards compatability only.
87618>>>>>            // They are not used.
87618>>>>>            Object oProductName is a TextBox
87620>>>>>                Set Label To C_$ProductName
87621>>>>>                Set Size To 10 45
87622>>>>>                Set Location To 8 53
87623>>>>>                Set Visible_State to False
87624>>>>>                Set Focus_Mode to NonFocusable
87625>>>>>            End_Object
87626>>>>>
87626>>>>>            Object oVersion is a TextBox
87628>>>>>                Set Label To C_$Version
87629>>>>>                Set Size To 10 25
87630>>>>>                Set Location To 21 53
87631>>>>>                Set Visible_State to False
87632>>>>>                Set Focus_Mode to NonFocusable
87633>>>>>            End_Object
87634>>>>>
87634>>>>>            Object oCopyright is a TextBox
87636>>>>>                Set Label To C_$Copyright
87637>>>>>                Set Size To 10 31
87638>>>>>                Set Location To 34 53
87639>>>>>                Set Visible_State to False
87640>>>>>                Set Focus_Mode to NonFocusable
87641>>>>>            End_Object
87642>>>>>
87642>>>>>            Object oAuthor is a TextBox
87644>>>>>                Set Label To C_$Author
87645>>>>>                Set Size To 10 22
87646>>>>>                Set Location To 46 53
87647>>>>>                Set Visible_State to False
87648>>>>>                Set Focus_Mode to NonFocusable
87649>>>>>            End_Object
87650>>>>>
87650>>>>>        End_Object
87651>>>>>
87651>>>>>        Object oOKButton is a Button
87653>>>>>            On_Item C_$Close Send Close_Panel
87654>>>>>            Set Location to 98 176
87655>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87655>>>>>            // we might as well prepare the object for it.
87655>>>>>            Set peAnchors to anBottomRight
87656>>>>>        End_Object
87657>>>>>
87657>>>>>        Object oSysInfoButton is a Button
87659>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
87660>>>>>            Set Location to 98 123
87661>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87661>>>>>            // we might as well prepare the object for it.
87661>>>>>            Set peAnchors to anBottomRight
87662>>>>>        End_Object
87663>>>>>
87663>>>>>        Object oCopyButton is a cCopyEditorContentButton
87665>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
87666>>>>>            Set Size to 14 50
87667>>>>>            Set Location to 98 70
87668>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87668>>>>>            // we might as well prepare the object for it.
87668>>>>>            Set peAnchors to anBottomRight
87669>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
87670>>>>>        End_Object
87671>>>>>
87671>>>>>        On_Key Kcancel Send KeyAction of oOKButton
87672>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
87673>>>>>        Set LogoDF to "DF32.bmp"
87674>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
87674>>>>>    End_Procedure
87675>>>>>
87675>>>>>    Procedure Page Integer iPageObject
87677>>>>>        Handle hMenu
87677>>>>>        Integer iPrevState
87677>>>>>
87677>>>>>        Forward Send Page iPageObject
87679>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
87679>>>>>        Set Icon to "Default.ico"
87680>>>>>
87680>>>>>        // Shadow upper left corner menu items: (icon menu items)
87680>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
87681>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87682>>>>>        // The "Move" menu command may come in handy to have.
87682>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87682>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87683>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87684>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87685>>>>>        // The "Close" menu command may be good to have.
87685>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87685>>>>>    End_Procedure
87686>>>>>
87686>>>>>    Procedure Set ProductName String sText
87688>>>>>        Set Value of oProductName to sText
87689>>>>>    End_Procedure
87690>>>>>
87690>>>>>    Procedure Set Copyright String sText
87692>>>>>        Set Value of oCopyright to sText
87693>>>>>    End_Procedure
87694>>>>>
87694>>>>>    Procedure Set Author String sText
87696>>>>>        Set Value of oAuthor to sText
87697>>>>>    End_Procedure
87698>>>>>
87698>>>>>    Procedure Set Version String sVersion
87700>>>>>        Handle hoVersionInfo
87700>>>>>        Boolean bIncluded
87700>>>>>        Integer iMajor iMinor iRelease iBuild
87700>>>>>        Date dCompileDate
87700>>>>>        String sCertInfo
87700>>>>>
87700>>>>>        If (sVersion = "") Begin
87702>>>>>            // This automatically shows the program version of the program, if available.
87702>>>>>            // It will be displayed as the second item in the edit object.
87702>>>>>            If (ghoApplication <> 0) Begin
87704>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
87705>>>>>                If (hoVersionInfo <> 0) Begin
87707>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
87708>>>>>                    If (bIncluded) Begin
87710>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
87711>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
87712>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
87713>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
87714>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
87715>>>>>                    End
87715>>>>>>
87715>>>>>                End
87715>>>>>>
87715>>>>>            End
87715>>>>>>
87715>>>>>        End
87715>>>>>>
87715>>>>>
87715>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
87715>>>>>        Get GetCompileDate to dCompileDate
87716>>>>>        If (sVersion <> "") Begin
87718>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
87719>>>>>        End
87719>>>>>>
87719>>>>>
87719>>>>>        Get IsProgramDigitallySigned to sCertInfo
87720>>>>>        If (sCertInfo <> "-1") Begin
87722>>>>>            If (sCertInfo <> "") Begin
87724>>>>>                Send Add_LineLn sCertInfo
87725>>>>>            End
87725>>>>>>
87725>>>>>            Else Begin
87726>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
87727>>>>>            End
87727>>>>>>
87727>>>>>        End
87727>>>>>>
87727>>>>>    End_Procedure
87728>>>>>
87728>>>>>    Function IsDate Desktop String sDate Returns Boolean
87730>>>>>        Boolean bIsDate
87730>>>>>        String sGoodCharacters sChar
87730>>>>>        Integer iCount iLength
87730>>>>>
87730>>>>>        Move True to bIsDate
87731>>>>>        Move "0123456789-/" to sGoodCharacters
87732>>>>>        Move (Length(sDate)) to iLength
87733>>>>>        For iCount from 1 to iLength
87739>>>>>>
87739>>>>>            Move (Left(sDate, 1)) to sChar
87740>>>>>            Move (Mid(sDate, 12, 2)) to sDate
87741>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
87742>>>>>            If (bIsDate = False) Begin
87744>>>>>                Move iLength to iCount
87745>>>>>            End
87745>>>>>>
87745>>>>>        Loop
87746>>>>>>
87746>>>>>        Function_Return bIsDate
87747>>>>>    End_Function
87748>>>>>
87748>>>>>    Function GetCompileDate Returns Date
87750>>>>>        Date dCompileDate
87750>>>>>        String sAppFilename sProgram sData sCompileDate
87750>>>>>        Integer iChannel iPos iDateFormat iCount iSize
87750>>>>>        Boolean bIsValid
87750>>>>>
87750>>>>>        Move 0 to dCompileDate
87751>>>>>        // Get full path to the current running executable
87751>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
87752>>>>>        Get GetApplicationName     of ghoApplication to sProgram
87753>>>>>
87753>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
87753>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
87754>>>>>
87754>>>>>        Get_Argument_Size to iSize
87755>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
87757>>>>>        Move (Pos(sProgram,sData)) to iPos
87758>>>>>        If (iPos > 0) Begin
87760>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
87760>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
87761>>>>>
87761>>>>>            // If the current date format is non US, we need to temporary
87761>>>>>            // change the format and then move the string to the date variable.
87761>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
87764>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
87767>>>>>            Move (Date(sCompileDate))    to dCompileDate
87768>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
87771>>>>>        End
87771>>>>>>
87771>>>>>//        Else Begin
87771>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
87771>>>>>//        End
87771>>>>>
87771>>>>>        Send Seq_Close_Channel iChannel
87772>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
87772>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
87772>>>>>
87772>>>>>        // The data is padded with Character(0)s. Strip them out
87772>>>>>//        Move (CString(sData)) to sData
87772>>>>>
87772>>>>>        // The compile date is after the first ", ", so string parsing is required
87772>>>>>//        Move (Pos(", ", sData)) to iPos
87772>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
87772>>>>>        // If the current date format is non US, we need to temporary
87772>>>>>        // change the format and then move the string to the date variable.
87772>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
87772>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
87772>>>>>//
87772>>>>>//        // Note the build in IsDateValid can return the wrong result
87772>>>>>//        // when controls characters are part of the sCompileDate.
87772>>>>>//        Get IsDate sCompileDate))           to bIsValid
87772>>>>>//        If (bIsValid = True) Begin
87772>>>>>//            Move (Date(sCompileDate))       to dCompileDate
87772>>>>>//        End
87772>>>>>//
87772>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
87772>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
87772>>>>>//        // until we encounter the program name that appears just in front of the compile date.
87772>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
87772>>>>>//        If (dCompileDate = 0) Begin
87772>>>>>//            Move "" to sCompileDate
87772>>>>>//            Move 30000 to iSize
87772>>>>>//            For iCount from 1 to iSize
87772>>>>>//                Readln channel iChannel sData
87772>>>>>//                Move (Pos(sProgram, sData)) to iPos
87772>>>>>//                If (iPos <> 0) Begin
87772>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
87772>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
87772>>>>>//                    Move iSize to iCount // We're out of here.
87772>>>>>//                End
87772>>>>>//            Loop
87772>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
87772>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
87772>>>>>//            End
87772>>>>>//            Get IsDate sCompileDate)) to bIsValid
87772>>>>>//            If (bIsValid = True) Begin
87772>>>>>//                Move (Date(sCompileDate)) to dCompileDate
87772>>>>>//            End
87772>>>>>//        End
87772>>>>>//        Send Seq_Close_Channel iChannel
87772>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
87772>>>>>
87772>>>>>        Function_Return dCompileDate
87773>>>>>    End_Function
87774>>>>>
87774>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
87774>>>>>    // (the passed program), has been finished
87774>>>>>    // The DOS box does also _not_ flash briefly.
87774>>>>>    Procedure RunProgramWait String sProgram String sParameter
87776>>>>>        Handle hProcess
87776>>>>>        Integer iVoid
87776>>>>>        AboutSHELLEXECUTEINFO sInfo
87776>>>>>        AboutSHELLEXECUTEINFO sInfo
87776>>>>>
87776>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
87777>>>>>
87777>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
87778>>>>>        Move SW_SHOW                 to sInfo.nShow
87779>>>>>
87779>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
87780>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
87781>>>>>        // This will "hide" the DOS box from showing (no flasing box):
87781>>>>>        Move 0                       to sInfo.nShow
87782>>>>>
87782>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
87783>>>>>        Move sInfo.hProcess to hProcess
87784>>>>>        If (hProcess) Begin
87786>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
87787>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
87788>>>>>        End
87788>>>>>>
87788>>>>>    End_Procedure
87789>>>>>
87789>>>>>    Function AddFolderDelimiter String sPath Returns String
87791>>>>>        String sDirSep
87791>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
87792>>>>>        Move (Trim(sPath)) to sPath
87793>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
87795>>>>>            Move (sPath + sDirSep) to sPath
87796>>>>>        End
87796>>>>>>
87796>>>>>        Function_Return sPath
87797>>>>>    End_Function
87798>>>>>
87798>>>>>    // Returns an empty string if the current program is not digitally signed,
87798>>>>>    // or there is a problem with the certificate.
87798>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
87798>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
87798>>>>>    Function IsProgramDigitallySigned Returns String
87800>>>>>        Boolean bExists
87800>>>>>        String sPath sProgram sParams sRetval
87800>>>>>        Integer iCh
87800>>>>>
87800>>>>>        Move "" to sRetval
87801>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
87802>>>>>        Get AddFolderDelimiter sPath to sPath
87803>>>>>        File_Exist (sPath + CS_SignProgram) bExists
87804>>>>>        If (bExists = False) Begin
87806>>>>>            Function_Return "-1"
87807>>>>>        End
87807>>>>>>
87807>>>>>
87807>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
87808>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
87809>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
87810>>>>>        Move (sParams * String("| clip"))    to sParams
87811>>>>>        Get Seq_New_Channel to iCh
87812>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
87814>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
87817>>>>>        Close_Output channel iCh
87819>>>>>        // New ShellExecute based message that waits for the passed process to end.
87819>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
87820>>>>>        Direct_Input channel iCh "CLIPBOARD:"
87822>>>>>            Readln channel iCh sRetval
87824>>>>>            Readln channel iCh sRetval
87826>>>>>            Readln channel iCh sRetval
87828>>>>>            Readln channel iCh sRetval
87830>>>>>        Close_Input channel iCh
87832>>>>>        Send Seq_Release_Channel iCh
87833>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
87835>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
87836>>>>>        End
87836>>>>>>
87836>>>>>        Else Begin
87837>>>>>            Move "" to sRetval
87838>>>>>        End
87838>>>>>>
87838>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
87838>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
87839>>>>>>
87839>>>>>        Function_Return sRetval
87840>>>>>    End_Function
87841>>>>>
87841>>>>>    Procedure Add_LineLn String sValue
87843>>>>>        Send Add_LineLn of oInfoList_Editor sValue
87844>>>>>    End_Procedure
87845>>>>>
87845>>>>>    Procedure Add_Line String sValue
87847>>>>>        Send Add_Line of oInfoList_Editor sValue
87848>>>>>    End_Procedure
87849>>>>>
87849>>>>>    Procedure Set Logo string sLogo
87851>>>>>        // Square bitmaps of 80x80 work best
87851>>>>>        Set Bitmap of oAboutGraphic to sLogo
87852>>>>>    End_Procedure
87853>>>>>
87853>>>>>    Procedure Set LogoDF String sLogo
87855>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
87856>>>>>    End_Procedure
87857>>>>>
87857>>>>>    Procedure Show_Sysinfo
87859>>>>>        Send Popup_Modal of oSysinfoDialog
87860>>>>>    End_Procedure
87861>>>>>
87861>>>>>    Procedure Show_HomePage String sWebpage
87863>>>>>        Handle hWnd
87863>>>>>        Get Window_Handle to hWnd
87864>>>>>        Runprogram Shell Background (Trim(sWebpage))
87865>>>>>    End_Procedure
87866>>>>>
87866>>>>>End_Class
87867>>>
87867>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
87867>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
87867>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
87867>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
87867>>>// decimals you may Get truncation that again may cause problems with finding.
87867>>>//
87867>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
87867>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
87867>>>
87867>>>
87867>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
87867>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
87867>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
87867>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
87867>>>//
87867>>>
87867>>>Class cDbUpdateFunctionLibrary is a cObject
87868>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
87869>>>>
87869>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
87871>>>>    Integer iStart iEnd
87871>>>>    String sRetval
87871>>>>
87871>>>>    Move (Trim(sConnect)) to sConnect
87872>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
87873>>>>    If (iStart = 0) Begin
87875>>>>        Function_Return ""
87876>>>>    End
87876>>>>>
87876>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
87877>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
87878>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
87880>>>>        Move (Pos(",", sRetval))          to iEnd
87881>>>>    End
87881>>>>>
87881>>>>    Else Begin
87882>>>>        Move (Pos(";", sRetval))          to iEnd
87883>>>>    End
87883>>>>>
87883>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87885>>>>        Move (Pos(",", sRetval))          to iEnd
87886>>>>        Decrement iEnd
87887>>>>    End
87887>>>>>
87887>>>>    If (iEnd <> 0) Begin
87889>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87890>>>>    End
87890>>>>>
87890>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87891>>>>
87891>>>>    Function_Return (Trim(sRetval))
87892>>>>End_Function
87893>>>>
87893>>>>
87893>>>
87893>>>    Procedure Construct_Object
87895>>>        Handle ho
87895>>>        Forward Send Construct_Object
87897>>>
87897>>>        Move Self to ghoDbUpdateFunctionLibrary
87898>>>
87898>>>        Send CreateDbUpdateLibraryProperties
87899>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
87899>>>        // we will create one as it is used for all ConnectionID, ConnectionString
87899>>>        // etc settings.
87899>>>        If (ghoSQLConnectionHandler = 0) Begin
87901>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
87902>>>            Set phoSQLConnectionHandler to ho
87903>>>        End   
87903>>>>
87903>>>        
87903>>>        Property String private.psCollation "Latin1_General_CS_AS"
87904>>>
87904>>>    End_Procedure
87905>>>
87905>>>    Procedure End_Construct_Object
87907>>>        Forward Send End_Construct_Object
87909>>>    End_Procedure
87910>>>
87910>>>    // *** SQL Messages for making changes to the SQL back-end ***
87910>>>    //
87910>>>    // * Dummy function for the Studio's Code Explorer *
87910>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
87912>>>        Function_Return False
87913>>>    End_Function
87914>>>
87914>>>    // Function for creating a new *Database*.
87914>>>    // Note: This is for creating SQL DATABASES - not tables!
87914>>>    // Returns True if successful.
87914>>>    // ToDo: Currently only works for MS-SQL...
87914>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
87916>>>        String sSQL sSQL1 sConnectionID sConnectionString
87916>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
87916>>>        Handle hConnection hStmt hoSQLManager
87916>>>        Integer iFetchResult iDbType
87916>>>        Boolean bOK bMertechDriver bExists
87916>>>
87916>>>        Get piDbType to iDbType
87917>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
87917>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
87919>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
87920>>>>
87920>>>            Function_Return False
87921>>>        End
87921>>>>
87921>>>
87921>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
87922>>>        If (bExists = True) Begin
87924>>>            Function_Return True
87925>>>        End
87925>>>>
87925>>>
87925>>>        Get IsMertechDriver sDriverID to bMertechDriver
87926>>>        If (bMertechDriver = False) Begin
87928>>>            Get phoSQLManager to hoSQLManager
87929>>>        End
87929>>>>
87929>>>        Else Begin
87930>>>            Get _MertechSQLManagerHandle to hoSQLManager
87931>>>        End
87931>>>>
87931>>>
87931>>>        Get psConnectionID     to sConnectionID
87932>>>        Get psConnectionString to sConnectionString
87933>>>        Move 0 to LastErr
87934>>>
87934>>>        If (sDriverID = ODBC_DRV_ID) Begin
87936>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
87936>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
87936>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
87936>>>//                Move (Pos(";", sConnectionString)) to iPos
87936>>>//                If (iPos > 0) Begin
87936>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
87936>>>//                    Move (Trim(sConnectionString)) to sConnectionString
87936>>>//                End
87936>>>//            End
87936>>>        End
87936>>>>
87936>>>
87936>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87937>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
87938>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87939>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
87941>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
87942>>>>
87942>>>            Function_Return False
87943>>>        End
87943>>>>
87943>>>
87943>>>        Get SqlOpen of hConnection to hStmt
87944>>>
87944>>>        If (hStmt = 0) Begin
87946>>>            Send SqlDisconnect of hoSQLManager
87947>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
87948>>>>
87948>>>            Function_Return False
87949>>>        End
87949>>>>
87949>>>
87949>>>        Get psCollation to sCollation
87950>>>
87950>>>        Case Begin
87950>>>            Case (sDriverID = MSSQLDRV_ID)
87952>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
87953>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
87954>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
87955>>>
87955>>>                // Check if database exists
87955>>>                Send SqlExecDirect of hStmt sSQL
87956>>>                Get SqlFetch of hStmt to iFetchResult
87957>>>                Send SqlClose of hStmt
87958>>>                Send SqlDisconnect of hConnection
87959>>>                // If database already exists we're out of here!
87959>>>                // Note that we return True as this is not an error.
87959>>>                If (iFetchResult > 0) Begin
87961>>>                    Function_Return True
87962>>>                End
87962>>>>
87962>>>                // Database doesn't exist, create it.
87962>>>                If (iFetchResult = 0) Begin
87964>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
87965>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87966>>>                    If (sCollation <> "") Begin
87968>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
87969>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
87970>>>                    End
87970>>>>
87970>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
87971>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87972>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
87974>>>                        Function_Return False
87975>>>                    End
87975>>>>
87975>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
87975>>>                    Sleep 1
87976>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
87977>>>                End
87977>>>>
87977>>>                Case Break
87978>>>
87978>>>            Case (sDriverID = MDSPgSQL)
87981>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
87981>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
87982>>>                Case Break
87983>>>
87983>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
87986>>>                // ToDo: How should this be set/checked?
87986>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
87986>>>//                    Set psCollation to "utf8"
87986>>>//                End
87986>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
87986>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
87987>>>                Case Break
87988>>>
87988>>>            Case (sDriverID = MDSDB2)
87991>>>                        CompilerWarnings Off
87991>>>                        CREATE_DB2_DATABASE sDatabase "" sCollation ""
88023>>>                        CompilerWarnings Off
88023>>>                Case Break
88024>>>
88024>>>            Case Else
88024>>>                Error DFERR_PROGRAM "Unsupported database type"
88025>>>>
88025>>>        Case End
88025>>>
88025>>>        If (Err = False) Begin
88027>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
88028>>>        End
88028>>>>
88028>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
88028>>>        // the one we just created.
88028>>>        If (bUpdateConnectionString = True and Err = False) Begin
88030>>>            Set psDatabase to sDatabase
88031>>>            //...and perhaps also the SQLConnections.ini file setting.
88031>>>            If (bPermanantly = True) Begin
88033>>>                If (ghoSQLConnectionHandler <> 0) Begin
88035>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
88036>>>                End
88036>>>>
88036>>>            End
88036>>>>
88036>>>        End
88036>>>>
88036>>>
88036>>>        Function_Return (Err = False)
88037>>>    End_Function
88038>>>
88038>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
88038>>>    // will be used.
88038>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
88040>>>        Boolean bOK bExists bShowProgress bErr
88040>>>        String sStatement sDriverID
88040>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88040>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88040>>>        Integer iDbType
88040>>>
88040>>>        If (sDatabase = "") Begin
88042>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
88043>>>>
88043>>>            Function_Return False
88044>>>        End
88044>>>>
88044>>>        If (sBackupName = "") Begin
88046>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
88047>>>>
88047>>>            Function_Return False
88048>>>        End
88048>>>>
88048>>>
88048>>>        // Create backup-folder if it doesn't exist
88048>>>        Get vFolderExists sPath to bExists
88049>>>        If (bExists = False) Begin
88051>>>            Get vCreateDirectory sPath to bErr
88052>>>            If (bErr = True) Begin
88054>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
88055>>>>
88055>>>                Function_Return False
88056>>>            End
88056>>>>
88056>>>        End
88056>>>>
88056>>>        // Make sure the path ends with a back-slash
88056>>>        If (sPath <> "") Begin
88058>>>            Get vFolderFormat sPath to sPath
88059>>>        End
88059>>>>
88059>>>
88059>>>        Get psDriverID to sDriverID
88060>>>        Get piDbType   to iDbType
88061>>>        If (num_arguments > 3) Begin
88063>>>            Move bShowProg to bShowProgress
88064>>>        End
88064>>>>
88064>>>
88064>>>        Case Begin
88064>>>            Case (iDbType = EN_DbTypeMSSQL)
88066>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
88066>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
88066>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
88067>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
88068>>>
88068>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
88069>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
88070>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
88071>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
88072>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
88073>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
88074>>>                Case Break
88075>>>            Case Else
88075>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
88076>>>        Case End
88076>>>
88076>>>        Function_Return bOK
88077>>>    End_Function
88078>>>
88078>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
88080>>>//        Boolean bOK bExists
88080>>>        String sStatement sDriverID sRetval //sPrevious
88080>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88080>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88080>>>        Integer iDbType iRows iFetchResult //iColumn
88080>>>        Handle hoSQLHandler hoSQLConnect hstmt
88080>>>        tSQLConnection SQLConnection
88080>>>        tSQLConnection SQLConnection
88080>>>
88080>>>        If (sDatabase = "") Begin
88082>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
88083>>>>
88083>>>            Function_Return ""
88084>>>        End
88084>>>>
88084>>>
88084>>>        Move "" to sRetval
88085>>>        Get psDriverID to sDriverID
88086>>>        Get piDbType   to iDbType
88087>>>
88087>>>        Case Begin
88087>>>            Case (iDbType = EN_DbTypeMSSQL)
88089>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
88089>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
88090>>>
88090>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
88091>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
88092>>>                Get phoSQLManager to hoSQLHandler
88093>>>
88093>>>                If (hoSQLHandler <> 0) Begin
88095>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88096>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
88097>>>
88097>>>                    If (hoSQLConnect <> 0) Begin
88099>>>                        Get SQLOpen of hoSQLConnect to hstmt
88100>>>                        If (hstmt <> 0) Begin
88102>>>                            Send SqlExecDirect of hstmt sStatement
88103>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
88104>>>                            Get SQLFetch of hstmt to iFetchResult
88105>>>                            If (iFetchResult <> 0) Begin
88107>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
88108>>>                            End
88108>>>>
88108>>>                            Send SQLClose of hstmt
88109>>>                        End
88109>>>>
88109>>>                        Send SQLDisconnect of hoSQLConnect
88110>>>                    End
88110>>>>
88110>>>                End
88110>>>>
88110>>>                Case Break
88111>>>            Case Else
88111>>>                If (bSilent = False) Begin
88113>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
88114>>>                End
88114>>>>
88114>>>        Case End
88114>>>
88114>>>        Function_Return sRetval
88115>>>    End_Function
88116>>>
88116>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
88118>>>        Boolean bMertechDriver // bOK bExists 
88118>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
88118>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
88118>>>        Handle hConnection hStmt hoSQLManager
88118>>>        Integer iDbType // iFetchResult
88118>>>
88118>>>        If (sDatabase = "") Begin
88120>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
88121>>>>
88121>>>            Function_Return False
88122>>>        End
88122>>>>
88122>>>
88122>>>        If (sSQLCollation = "") Begin
88124>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
88125>>>>
88125>>>            Function_Return False
88126>>>        End
88126>>>>
88126>>>
88126>>>        Get psDriverID to sDriverID
88127>>>        Get piDbType   to iDbType
88128>>>
88128>>>        Get IsMertechDriver sDriverID to bMertechDriver
88129>>>        If (bMertechDriver = False) Begin
88131>>>            Get phoSQLManager to hoSQLManager
88132>>>        End
88132>>>>
88132>>>        Else Begin
88133>>>            Get _MertechSQLManagerHandle to hoSQLManager
88134>>>        End
88134>>>>
88134>>>
88134>>>        Get psConnectionID     to sConnectionID
88135>>>        Get psConnectionString to sConnectionString
88136>>>        Move 0 to LastErr
88137>>>
88137>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88138>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
88139>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88140>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
88142>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
88143>>>>
88143>>>            Function_Return False
88144>>>        End
88144>>>>
88144>>>
88144>>>        Get SqlOpen of hConnection to hStmt
88145>>>
88145>>>        If (hStmt = 0) Begin
88147>>>            Send SqlDisconnect of hoSQLManager
88148>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
88149>>>>
88149>>>            Function_Return False
88150>>>        End
88150>>>>
88150>>>
88150>>>        // Check if collation already exists
88150>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
88151>>>        // If the current collate is the same as the new; do nothing.
88151>>>        If (sSQLCollation = sSQLCollationCheck) Begin
88153>>>            Function_Return True
88154>>>        End
88154>>>>
88154>>>
88154>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
88155>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
88156>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
88157>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
88158>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
88159>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
88160>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
88161>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
88162>>>
88162>>>        // MS-SQL Syntax:
88162>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
88162>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
88162>>>        // ALTER DATABASE [database] SET MULTI_USER;
88162>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
88163>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
88164>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
88165>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
88165>>>
88165>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88166>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
88167>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88168>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
88170>>>           Function_Return False
88171>>>        End
88171>>>>
88171>>>
88171>>>        Function_Return (Err = False)
88172>>>    End_Function
88173>>>
88173>>>
88173>>>    // * Dummy function for the Studio's Code Explorer *
88173>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
88175>>>        Function_Return False
88176>>>    End_Function
88177>>>
88177>>>    // Converts from SQL to Embedded (DataFlex .dat files).
88177>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
88177>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
88177>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
88177>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
88177>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
88179>>>        Handle hToTable
88179>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
88179>>>        String sDriverID sPhysicalName sRootName sDisplayName
88179>>>        tSQLConnection SQLConnection
88179>>>        tSQLConnection SQLConnection
88179>>>        Integer iPos iMaxRecords
88179>>>
88179>>>        Get psDriverID to sDriverID
88180>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
88181>>>        If (bExists = False) Begin
88183>>>            Function_Return False
88184>>>        End
88184>>>>
88184>>>
88184>>>        If (num_arguments > 1) Begin
88186>>>            Move bCpyDat to bCopyData
88187>>>        End
88187>>>>
88187>>>        Else Begin
88188>>>            Move False to bCopyData
88189>>>        End
88189>>>>
88189>>>
88189>>>        Open hTable
88191>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88194>>>        If (bOpened = False) Begin
88196>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
88197>>>>
88197>>>            Function_Return False
88198>>>        End
88198>>>>
88198>>>        Move 0 to hToTable
88199>>>
88199>>>        Move 16711679 to iMaxRecords
88200>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
88203>>>        Move (Pos(".", sDisplayName)) to iPos
88204>>>        If (iPos > 0) Begin
88206>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
88207>>>        End
88207>>>>
88207>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
88210>>>        Get _TableNameOnly sRootName                 to sRootName
88211>>>        Move (sRootName + ".dat")                    to sPhysicalName
88212>>>
88212>>>        If (ghoProgressBar <> 0) Begin
88214>>>            Send DoAdvance of ghoProgressBar
88215>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
88216>>>        End
88216>>>>
88216>>>
88216>>>        Move False to Err
88217>>>
88217>>>        Structure_Start hToTable DATAFLEX_ID
88218>>>            Structure_Copy hTable to hToTable
88219>>>
88219>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
88222>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
88225>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
88228>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
88231>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
88234>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88235>>>
88235>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88237>>>
88237>>>        Set Action_Text of ghoStatusPanel to ""
88238>>>        Move (not(Err)) to bOK
88239>>>        If (bOK = True and bCopyData = True) Begin
88241>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
88242>>>        End
88242>>>>
88242>>>
88242>>>        Get IsMertechDriver sDriverID to bMertechDriver
88243>>>        If (bMertechDriver = True) Begin
88245>>>            Open hTable
88247>>>        End
88247>>>>
88247>>>
88247>>>        // This must be after copying data...
88247>>>        If (Err = False) Begin
88249>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
88252>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
88255>>>        End
88255>>>>
88255>>>        Move (not(Err)) to bOK
88256>>>
88256>>>        Function_Return (bOK = True)
88257>>>    End_Function
88258>>>
88258>>>    Function AddFolderDelimiter String sPath Returns String
88260>>>        String sDirSep
88260>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
88261>>>        Move (Trim(sPath)) to sPath
88262>>>        If (Right(sPath, 1) <> sDirSep) Begin
88264>>>            Move (sPath + sDirSep) to sPath
88265>>>        End
88265>>>>
88265>>>        Function_Return sPath
88266>>>    End_Function
88267>>>
88267>>>    // Creates an SQL Table at the SQL end by its filelist number;
88267>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
88267>>>    Function SqlTableCreate Integer hTable Returns Boolean
88269>>>        String sTableName sSQLString sPath sCreateTable sDriverID
88269>>>        Integer iDbType
88269>>>        Boolean bExists
88269>>>
88269>>>        Get psDriverID to sDriverID
88270>>>        Get UtilTableHandleToString hTable to sTableName
88271>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88272>>>        If (bExists = True) Begin
88274>>>            Function_Return False
88275>>>        End
88275>>>>
88275>>>
88275>>>        Get psDataPathFirstPart to sPath
88276>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
88277>>>
88277>>>        Get piDbType to iDbType
88278>>>        Get _SqlProperTableName sTableName to sTableName
88279>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
88280>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
88281>>>
88281>>>        Move False to Err
88282>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88283>>>
88283>>>        Function_Return (Err = False)
88284>>>    End_Function
88285>>>
88285>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
88285>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
88285>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
88287>>>        String sSQLString sPath sCreateTable sDriverID
88287>>>        Integer iDbType
88287>>>        Boolean bExists
88287>>>
88287>>>        Get psDriverID to sDriverID
88288>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88289>>>        If (bExists = True) Begin
88291>>>            Function_Return False
88292>>>        End
88292>>>>
88292>>>
88292>>>        Get psDataPathFirstPart to sPath
88293>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
88294>>>        If (bExists = True) Begin
88296>>>            // ToDo: What should we do if an .int file already exists?
88296>>>        End
88296>>>>
88296>>>
88296>>>        Get piDbType to iDbType
88297>>>        Get _SqlProperTableName sTableName to sTableName
88298>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
88299>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
88300>>>
88300>>>        Move False to Err
88301>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88302>>>
88302>>>        Function_Return (Err = False)
88303>>>    End_Function
88304>>>    
88304>>>    // ToDo: 2019-09-23 This needs to be finilized 
88304>>>    // It resets SQL constraints after a Structure_End, if necessary.
88304>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
88306>>>        Boolean bOK                                                            
88306>>>        String sStatement
88306>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
88307>>>        Function_Return bOK
88308>>>    End_Function
88309>>>    
88309>>>    // First deletes the data cache file and then drops the passed SQL table.
88309>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
88309>>>    //       else try using the SqlTableRemoveByTableName message.
88309>>>    Function SqlTableRemove Handle hTable Returns Boolean
88311>>>        String sSQLString sPath sDropTable sTableName sDriverID
88311>>>        Integer iRetval iDbType
88311>>>        Boolean bExists bMertechDriver bOK
88311>>>
88311>>>        Get psDriverID to sDriverID
88312>>>        Get IsMertechDriver sDriverID to bMertechDriver
88313>>>        Get UtilTableHandleToString hTable to sTableName
88314>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88315>>>        If (bExists = False) Begin
88317>>>            Function_Return False
88318>>>        End
88318>>>>
88318>>>
88318>>>        Get psDataPathFirstPart to sPath
88319>>>        Get UtilDeleteCacheFile sTableName to iRetval
88320>>>
88320>>>        Get piDbType to iDbType
88321>>>        Get _SqlProperTableName sTableName to sTableName
88322>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
88323>>>        Move (sDropTable * String(sTableName)) to sSQLString
88324>>>
88324>>>        Move False to Err
88325>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88326>>>
88326>>>        // We also need to remove the cache-file since the table has been changed
88326>>>        Get UtilDeleteCacheFile sTableName to bOK
88327>>>
88327>>>        Function_Return (Err = False)
88328>>>    End_Function
88329>>>
88329>>>    // First deletes the data cache file and then drops the passed data table.
88329>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
88331>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
88331>>>        Integer iRetval iDbType
88331>>>        Boolean bMertechDriver bOK
88331>>>
88331>>>        Get psDriverID to sDriverID
88332>>>        Get IsMertechDriver sDriverID to bMertechDriver
88333>>>        Get psDataPathFirstPart to sPath
88334>>>        Get UtilDeleteCacheFile sTableName to iRetval
88335>>>
88335>>>        Get piDbType to iDbType
88336>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
88337>>>        Get psSchema to sSchema
88338>>>        If (sSchema = "") Begin
88340>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
88341>>>        End
88341>>>>
88341>>>        Move (Uppercase(sTableName)) to sVal
88342>>>        If (not(sVal contains (sSchema + "."))) Begin
88344>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
88345>>>        End
88345>>>>
88345>>>        Move (sDropTable * String(sTableName)) to sSQLString
88346>>>
88346>>>        Move False to Err
88347>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88348>>>
88348>>>        // We also need to remove the cache-file since the table has been changed
88348>>>        Get UtilDeleteCacheFile sTableName to bOK
88349>>>
88349>>>        Function_Return (Err = False)
88350>>>    End_Function
88351>>>
88351>>>    // *** Sql View Messages ***
88351>>>
88351>>>    // First deletes the data cache file and then drops the passed Sql data view.
88351>>>    Function SqlViewRemove String sDataView Returns Boolean
88353>>>        String sDriverID sSQLString sDropViewKeyWord
88353>>>        Integer iRetval
88353>>>        Boolean bMertechDriver bOK
88353>>>
88353>>>        Get psDriverID to sDriverID
88354>>>        Get IsMertechDriver sDriverID to bMertechDriver
88355>>>        Get UtilDeleteCacheFile sDataView to iRetval
88356>>>
88356>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
88357>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
88358>>>        Set psSQLStatementString to sSQLString
88359>>>
88359>>>        // As we don't check if the view exist or not, it might happen
88359>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
88359>>>        Move False to Err
88360>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88361>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88362>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88363>>>        Move 0 to LastErr
88364>>>
88364>>>        // We also need to remove the cache-file since the table has been changed
88364>>>        Get UtilDeleteCacheFile sDataView to bOK
88365>>>
88365>>>        Function_Return (Err = False)
88366>>>    End_Function
88367>>>
88367>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
88369>>>        Boolean bOK
88369>>>        Integer iDbType
88369>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
88369>>>
88369>>>        Get psDriverID to sDriverID
88370>>>        Get piDbType   to iDbType
88371>>>
88371>>>        Case Begin
88371>>>            Case (iDbType = EN_DbTypeDB2)
88373>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88374>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88375>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88376>>>            Break
88377>>>
88377>>>            Case (iDbType = EN_DbTypeMSSQL)
88380>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88381>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88382>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
88383>>>            Break
88384>>>
88384>>>            Case (iDbType = EN_DbTypeOracle)
88387>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88388>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88389>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88390>>>            Break
88391>>>
88391>>>            Case (iDbType = EN_DbTypePostgre)
88394>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88395>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88396>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88397>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
88398>>>            Break
88399>>>
88399>>>            Case (iDbType = EN_DbTypeMySQL)
88402>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88403>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88404>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
88405>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88406>>>            Break
88407>>>        Case End
88407>>>
88407>>>        Move False to Err
88408>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88409>>>        Move (Err = False) to bOK
88410>>>
88410>>>        Function_Return bOK
88411>>>    End_Function
88412>>>
88412>>>    // * Dummy function for the Studio's Code Explorer *
88412>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
88414>>>        Function_Return False
88415>>>    End_Function
88416>>>
88416>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
88416>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88418>>>        Integer iLength iDecimals
88418>>>        String sColumnValue
88418>>>        String sTableName sDriverID
88418>>>        Boolean bOK bInitializeValue
88418>>>
88418>>>        Get psDriverID to sDriverID
88419>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88420>>>        If (bOK = False) Begin
88422>>>            Function_Return False
88423>>>        End
88423>>>>
88423>>>
88423>>>        Get UtilTableHandleToString hTable to sTableName
88424>>>        If (sTableName = "") Begin
88426>>>            Function_Return False
88427>>>        End
88427>>>>
88427>>>
88427>>>        If (num_arguments > 3) Begin
88429>>>            Move iLen     to iLength
88430>>>            Move iDec     to iDecimals
88431>>>            Move bInitVal to bInitializeValue
88432>>>            Move sColVal  to sColumnValue
88433>>>        End
88433>>>>
88433>>>
88433>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
88434>>>
88434>>>        Function_Return (bOK = True)
88435>>>    End_Function
88436>>>
88436>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
88436>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88438>>>        Integer iDbType iLength iDecimals iDriver
88438>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
88438>>>        String sDriverID sNotNull
88438>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
88438>>>        Handle hTable
88438>>>
88438>>>        Get psDriverID to sDriverID
88439>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88440>>>        If (bOK = False) Begin
88442>>>            Function_Return True
88443>>>        End
88443>>>>
88443>>>
88443>>>        Get UtilTableNameToHandle sTableName to hTable
88444>>>        If (hTable = 0) Begin
88446>>>            Get NextFreeFilelistSlot to hTable
88447>>>        End
88447>>>>
88447>>>
88447>>>        Get piDbType to iDbType
88448>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
88448>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88449>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
88451>>>            Function_Return True
88452>>>        End
88452>>>>
88452>>>
88452>>>        Get DriverIndex sDriverID to iDriver
88453>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
88454>>>        If (bIsMertechDriver = False) Begin
88456>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88459>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88462>>>        End
88462>>>>
88462>>>
88462>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88463>>>        If (num_arguments > 3) Begin
88465>>>            Move iLen     to iLength
88466>>>            Move iDec     to iDecimals
88467>>>            Move bInitVal to bInitializeValue
88468>>>            Move sColVal  to sColumnValue
88469>>>        End
88469>>>>
88469>>>
88469>>>        Get _SqlProperTableName sTableName   to sTableName
88470>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
88471>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
88472>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88473>>>
88473>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88474>>>        If (bFixed = False) Begin
88476>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88477>>>        End
88477>>>>
88477>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88478>>>
88478>>>        Move False to Err
88479>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88480>>>
88480>>>        If (bInitializeValue = True and Err = False) Begin
88482>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
88483>>>        End
88483>>>>
88483>>>
88483>>>        If (Err = False) Begin
88485>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
88486>>>        End
88486>>>>
88486>>>
88486>>>        Move (not(Err)) to bRetval
88487>>>
88487>>>        // We also need to remove the cache-file since the table has been changed
88487>>>        Get UtilDeleteCacheFile sTableName to bOK
88488>>>        If (bIsMertechDriver = False) Begin
88490>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88493>>>        End
88493>>>>
88493>>>        Function_Return bRetval
88494>>>    End_Function
88495>>>
88495>>>    // To update all current rows for a table column with a common value.
88495>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
88497>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
88497>>>        Boolean bRetval bSQLDriver
88497>>>        Integer iCurrErr iDbType
88497>>>
88497>>>        Move False to bRetval
88498>>>        Get piDbType to iDbType
88499>>>        Get psDriverID to sDriverID
88500>>>        Get IsSQLDriver sDriverID to bSQLDriver
88501>>>        If (bSQLDriver = False) Begin
88503>>>            Function_Return bRetval
88504>>>        End
88504>>>>
88504>>>        Get UtilTableHandleToString hTable to sTableName
88505>>>
88505>>>        Move Err to iCurrErr
88506>>>        Move False to Err
88507>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
88508>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
88509>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
88510>>>        If (sDriverID = MDSMySQL) Begin
88512>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
88513>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
88514>>>        End
88514>>>>
88514>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
88514>>>        If (iDbType = EN_DbTypeMySQL) Begin
88516>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
88517>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
88518>>>        End
88518>>>>
88518>>>        Else Begin
88519>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
88520>>>        End
88520>>>>
88520>>>
88520>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88521>>>        Move (Err = False) to bRetval
88522>>>        Move iCurrErr to Err
88523>>>
88523>>>        Function_Return bRetval
88524>>>    End_Function
88525>>>
88525>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88525>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88525>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88527>>>        String sDriverID sTableName
88527>>>        Boolean bOK
88527>>>
88527>>>        Get psDriverID to sDriverID
88528>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88529>>>        If (bOK = False) Begin
88531>>>            Function_Return False
88532>>>        End
88532>>>>
88532>>>
88532>>>        Get UtilTableHandleToString hTable to sTableName
88533>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
88534>>>
88534>>>        Function_Return (Err = False)
88535>>>    End_Function
88536>>>
88536>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
88536>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88536>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88536>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88538>>>        Integer iDbType iLength iDecimals
88538>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
88538>>>        Boolean bExists bOK bFixed
88538>>>        Handle hTable
88538>>>
88538>>>        Get psDriverID to sDriverID
88539>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88540>>>        If (bOK = False) Begin
88542>>>            Function_Return False
88543>>>        End
88543>>>>
88543>>>
88543>>>        Get UtilTableNameToHandle sTableName to hTable
88544>>>        If (hTable = 0) Begin
88546>>>            Get NextFreeFilelistSlot to hTable
88547>>>        End
88547>>>>
88547>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
88548>>>        If (bExists = False) Begin
88550>>>            Function_Return False
88551>>>        End
88551>>>>
88551>>>
88551>>>        If (num_arguments > 3) Begin
88553>>>            Move iLen to iLength
88554>>>        End
88554>>>>
88554>>>        If (num_arguments > 4) Begin
88556>>>            Move iDec to iDecimals
88557>>>        End
88557>>>>
88557>>>
88557>>>        Get piDbType to iDbType
88558>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88559>>>
88559>>>        Move False to Err
88560>>>        Get _SqlProperTableName sTableName    to sTableName
88561>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88562>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
88563>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88564>>>
88564>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88565>>>        If (bFixed = False) Begin
88567>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88568>>>        End
88568>>>>
88568>>>
88568>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88569>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88570>>>
88570>>>        // We also need to remove the cache-file since the table has been changed
88570>>>        Get UtilDeleteCacheFile sTableName to bOK
88571>>>
88571>>>        Function_Return (Err = False)
88572>>>    End_Function
88573>>>
88573>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
88575>>>        Boolean bOK bErr bIsSQLDriver
88575>>>        String sDriverID
88575>>>        Integer iDataType
88575>>>
88575>>>        Get psDriverID to sDriverID
88576>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88577>>>        If (bIsSQLDriver = False) Begin
88579>>>            Function_Return False
88580>>>        End
88580>>>>
88580>>>
88580>>>        Move Err to bErr
88581>>>        Move False to bErr
88582>>>
88582>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
88582>>>        // inserts randomly character(10) and spaces, so we correct from that here:
88582>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
88583>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
88586>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
88588>>>            Move ("[" + String(sValue) + "]") to sValue
88589>>>        End
88589>>>>
88589>>>
88589>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
88592>>>        Move (not(Err)) to bOK
88593>>>        Move bErr to Err
88594>>>
88594>>>        Function_Return bOK
88595>>>    End_Function
88596>>>
88596>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
88598>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
88598>>>        String sDriverID
88598>>>
88598>>>        Get psDriverID to sDriverID
88599>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88600>>>        If (bIsSQLDriver = False) Begin
88602>>>            Function_Return False
88603>>>        End
88603>>>>
88603>>>
88603>>>        Move Err to bErr
88604>>>        Move False to bErr
88605>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
88608>>>        If (bNullable = bCurrentState) Begin
88610>>>            Function_Return True
88611>>>        End
88611>>>>
88611>>>
88611>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88614>>>        If (bOpen = False) Begin
88616>>>            Get AutoConnectionIDLogin to bOK
88617>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88618>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88619>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88620>>>            Open hTable
88622>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88623>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88624>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88625>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88628>>>        End
88628>>>>
88628>>>        If (bOpen = True) Begin
88630>>>            Structure_Start hTable sDriverID
88631>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
88634>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88635>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88637>>>            Set Action_Text of ghoStatusPanel to ""
88638>>>        End
88638>>>>
88638>>>
88638>>>        Move (not(Err)) to bOK
88639>>>        Move bErr to Err
88640>>>
88640>>>        Function_Return bOK
88641>>>    End_Function
88642>>>
88642>>>    // Drop column by its table handle
88642>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
88644>>>        String sDriverID sTableName
88644>>>        Boolean bOK
88644>>>
88644>>>        Get psDriverID to sDriverID
88645>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88646>>>        If (bOK = False) Begin
88648>>>            Function_Return False
88649>>>        End
88649>>>>
88649>>>
88649>>>        Get UtilTableHandleToString hTable to sTableName
88650>>>        If (sTableName = "") Begin
88652>>>            Function_Return False
88653>>>        End
88653>>>>
88653>>>
88653>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
88654>>>
88654>>>        Function_Return (bOK = True)
88655>>>    End_Function
88656>>>
88656>>>    // Drop column by its table name as a string.
88656>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
88658>>>        Integer iDbType iDriver
88658>>>        String sDriverID sStmt sAlterTable sDropColumn
88658>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
88658>>>        Handle hTable
88658>>>
88658>>>        Get psDriverID to sDriverID
88659>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88660>>>        If (bOK = False) Begin
88662>>>            Function_Return False
88663>>>        End
88663>>>>
88663>>>
88663>>>        Get DriverIndex sDriverID to iDriver
88664>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88667>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88670>>>
88670>>>        Get UtilTableNameToHandle sTableName to hTable
88671>>>        If (hTable <> 0) Begin
88673>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
88674>>>            If (bExists = False) Begin
88676>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88679>>>                Function_Return False
88680>>>            End
88680>>>>
88680>>>        End
88680>>>>
88680>>>
88680>>>        Get piDbType to iDbType
88681>>>        If (iDbType = EN_DbTypeMSSQL) Begin
88683>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
88684>>>            Get UtilDeleteCacheFile sTableName to bOK
88685>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88688>>>            Function_Return bOK
88689>>>        End
88689>>>>
88689>>>
88689>>>        Move False to Err
88690>>>        Get _SqlProperTableName sTableName    to sTableName
88691>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88692>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
88693>>>
88693>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
88694>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88695>>>        Move (not(Err)) to bRetval
88696>>>
88696>>>        // We also need to remove the cache-file since the table has been changed
88696>>>        Get UtilDeleteCacheFile sTableName to bOK
88697>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88700>>>
88700>>>        Function_Return bRetval
88701>>>    End_Function
88702>>>
88702>>>    // Rename a field/column by table handle (filelist number)
88702>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
88704>>>        String sDriverID sTableName
88704>>>        Boolean bOK
88704>>>
88704>>>        Get psDriverID to sDriverID
88705>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88706>>>        If (bOK = False) Begin
88708>>>            Function_Return False
88709>>>        End
88709>>>>
88709>>>
88709>>>        Get UtilTableHandleToString hTable to sTableName
88710>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
88711>>>
88711>>>        Function_Return (Err = False)
88712>>>    End_Function
88713>>>
88713>>>    // Rename a field/column by table name.
88713>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
88715>>>        Integer iDbType iDataType
88715>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
88715>>>        Boolean bOK bRetval
88715>>>        Handle hTable
88715>>>
88715>>>        Move sTableName to sOrgTableName
88716>>>        Get psDriverID to sDriverID
88717>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88718>>>        If (bOK = False) Begin
88720>>>            Function_Return False
88721>>>        End
88721>>>>
88721>>>
88721>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88722>>>        If (sVal = "") Begin
88724>>>            Function_Return False
88725>>>        End
88725>>>>
88725>>>
88725>>>        Get piDbType to iDbType
88726>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
88727>>>        Get _SqlProperTableName sTableName     to sTableName
88728>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
88729>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
88730>>>
88730>>>        Case Begin
88730>>>            Case (iDbType = EN_dbTypeMSSQL)
88732>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
88733>>>                Case Break
88734>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
88734>>>            Case (iDbType = EN_dbTypeOracle)
88737>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88738>>>                Case Break
88739>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
88739>>>            Case (iDbType = EN_dbTypeDB2)
88742>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88743>>>                Case Break
88744>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
88744>>>            Case (iDbType = EN_dbTypePostgre)
88747>>>                Move sOrgTableName to sTableName
88748>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88749>>>                Case Break
88750>>>            Case (iDbType = EN_dbTypeMySQL)
88753>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
88753>>>                Move sOrgTableName to sTableName
88754>>>                Get psDatabase to sDatabase
88755>>>                Get UtilTableNameToHandle sTableName to hTable
88756>>>                If (hTable = 0) Begin
88758>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
88759>>>                    If (bOK = False) Begin
88761>>>                        Function_Return False
88762>>>                    End
88762>>>>
88762>>>                    Get NextFreeFilelistSlot to hTable
88763>>>                End
88763>>>>
88763>>>                Else Begin
88764>>>                    Open hTable
88766>>>                End
88766>>>>
88766>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
88767>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
88768>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
88769>>>                Case Break
88770>>>            Case Else
88770>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
88771>>>        Case End
88771>>>
88771>>>        Move False to Err
88772>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88773>>>        Move (Err = False) to bRetval
88774>>>        // We also need to remove the cache-file since the table has been changed
88774>>>        Get UtilDeleteCacheFile sTableName to bOK
88775>>>
88775>>>        Function_Return bRetval
88776>>>    End_Function
88777>>>
88777>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
88779>>>        Handle hoSQLHandler hSQLConnect hStmt
88779>>>        Boolean bMertechDriver
88779>>>        Integer iNumCols iCount iDataType
88779>>>        String sValue
88779>>>
88779>>>        Get IsMertechDriver sDriverID to bMertechDriver
88780>>>        If (bMertechDriver = False) Begin
88782>>>            Get phoSQLManager to hoSQLHandler
88783>>>        End
88783>>>>
88783>>>        Else Begin
88784>>>            Get _MertechSQLManagerHandle to hoSQLHandler
88785>>>        End
88785>>>>
88785>>>
88785>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
88786>>>        If (hSQLConnect <> 0) Begin
88788>>>            Get SQLOpen of hSQLConnect to hStmt
88789>>>            If (hStmt <> 0) Begin
88791>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
88792>>>
88792>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
88793>>>                For iCount from 1 to iNumCols
88799>>>>
88799>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
88800>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
88802>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
88803>>>                        Move iNumCols to iCount // We're out of here
88804>>>                    End
88804>>>>
88804>>>                Loop
88805>>>>
88805>>>
88805>>>                Send SQLClose of hStmt
88806>>>            End
88806>>>>
88806>>>            Send SQLDisconnect of hSQLConnect
88807>>>        End
88807>>>>
88807>>>
88807>>>        Function_Return iDataType
88808>>>    End_Function
88809>>>
88809>>>    // * Dummy function for the Studio's Code Explorer *
88809>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
88811>>>        Function_Return False
88812>>>    End_Function
88813>>>
88813>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
88815>>>        String sMessage // sConnectionString
88815>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
88815>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
88815>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
88818>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
88818>>>        TimeSpan tsQuery tsFetch
88818>>>        tSqlErrorArray aSqlErrorArray
88818>>>        tSqlErrorArray aSqlErrorArray
88818>>>        Boolean bOK bMertechDriver bShowProgress
88818>>>        tSQLConnection SQLConnection
88818>>>        tSQLConnection SQLConnection
88818>>>
88818>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88819>>>        If (bOK = False) Begin
88821>>>            Procedure_Return
88822>>>        End
88822>>>>
88822>>>
88822>>>        If (num_arguments > 2) Begin
88824>>>            Move bShowProgr to bShowProgress
88825>>>        End
88825>>>>
88825>>>
88825>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88826>>>
88826>>>        Get IsMertechDriver sDriverID to bMertechDriver
88827>>>        If (bMertechDriver = True) Begin
88829>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
88830>>>        End
88830>>>>
88830>>>        If (bMertechDriver = False) Begin
88832>>>            Get phoSQLManager to hoSqlHandler
88833>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
88834>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
88835>>>        End
88835>>>>
88835>>>
88835>>>        If (hoSQLConnect <> 0) Begin
88837>>>            Get SqlOpen of hoSQLConnect to hoStmt
88838>>>            If (hoStmt <> 0) Begin
88840>>>                // record starting date/time stamp
88840>>>                Move (CurrentDateTime()) to dtQueryExecStart
88841>>>                // turn on error handling if enabled
88841>>>                If (pbHandleQueryErrors(Self)) Begin
88843>>>                    Set pbSqlError to False
88844>>>                    Set paSqlErrorArray to aSqlErrorArray
88845>>>                    Move Error_Object_Id to hoError
88846>>>                    If (ghoDbUpdateHandler <> 0) Begin
88848>>>                        Move ghoDbUpdateHandler to Error_Object_Id
88849>>>                    End
88849>>>>
88849>>>                    Else Begin
88850>>>                        Move Self to Error_Object_Id
88851>>>                    End
88851>>>>
88851>>>                End
88851>>>>
88851>>>
88851>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
88851>>>                Set psSQLStatementString to sStmt
88852>>>                Send Cursor_Wait of Cursor_Control
88853>>>                Send SqlExecDirect of hoStmt sStmt
88854>>>                Send Cursor_Ready of Cursor_Control
88855>>>
88855>>>                If (pbHandleQueryErrors(Self)) Begin
88857>>>                    Move hoError to Error_Object_Id
88858>>>                End
88858>>>>
88858>>>
88858>>>                Move 0 to iMsgs
88859>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
88859>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
88859>>>                If (bMertechDriver = False) Begin
88861>>>                    Move Err to iErr
88862>>>                    Move LastErr to iLastErr
88863>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
88864>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
88865>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
88866>>>                    Send _SqlColumnInfo hoStmt
88867>>>                    Send Ignore_Error of Error_Object_Id 12289
88868>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88869>>>                    Repeat
88869>>>>
88869>>>                        Get SqlFetch of hoStmt to iFetchResult
88870>>>                        If (iFetchResult <> 0) Begin
88872>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
88873>>>                        End
88873>>>>
88873>>>                    Until (iFetchResult = 0)
88875>>>                    Send Trap_Error of Error_Object_Id 12289
88876>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
88877>>>                    Move iErr to Err
88878>>>                    Move iLastErr to LastErr
88879>>>                    Set paSQLFetchResults to aSQLFetchResults
88880>>>                End
88880>>>>
88880>>>
88880>>>                Set piRows    to iRows
88881>>>                Set piRowType to iRowType
88882>>>                Move (CurrentDateTime()) to dtQueryExecEnd
88883>>>                Move (CurrentDateTime()) to dtFetchStart
88884>>>
88884>>>                If (iMsgs <> 0) Begin
88886>>>                    If (ghoDbUpdateHandler > 0) Begin
88888>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88889>>>                    End
88889>>>>
88889>>>                    For i from 1 to iMsgs
88895>>>>
88895>>>                        Get SqlGetMessage of hoStmt i to sMessage
88896>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
88897>>>                        If (bShowProgress = True) Begin
88899>>>                            If (Active_State(ghoStatusPanel)) Begin
88901>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
88902>>>                            End
88902>>>>
88902>>>                            Else Begin
88903>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
88905>>>                            End
88905>>>>
88905>>>                        End
88905>>>>
88905>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
88906>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
88907>>>                    Loop
88908>>>>
88908>>>                    If (ghoDbUpdateHandler > 0) Begin
88910>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
88911>>>                    End
88911>>>>
88911>>>                    Set paQueryMessages to sMsg
88912>>>                End
88912>>>>
88912>>>                Else Begin
88913>>>                    If (bShowProgress = True) Begin
88915>>>                        Get paSqlErrorArray to aSqlErrorArray
88916>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
88918>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
88919>>>                            Decrement iMsgs
88920>>>                            For i from 0 to iMsgs
88926>>>>
88926>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
88929>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
88932>>>                            Loop
88933>>>>
88933>>>                        End
88933>>>>
88933>>>                    End
88933>>>>
88933>>>                End
88933>>>>
88933>>>                Move (CurrentDateTime()) to dtFetchEnd
88934>>>            End
88934>>>>
88934>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
88935>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
88936>>>            Set ptsQueryExec to tsQuery
88937>>>            Set ptsFetchResults to tsFetch
88938>>>            Send SqlClose of hoStmt
88939>>>        End
88939>>>>
88939>>>
88939>>>        Send SqlDisconnect of hoSQLConnect
88940>>>    End_Procedure
88941>>>
88941>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
88941>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
88941>>>    // Returns False if no error occured.
88941>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
88943>>>        Boolean bOK bShowProgress
88943>>>        tSQLScriptArray SQLScriptArray
88943>>>        tSQLScriptArray SQLScriptArray
88943>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
88943>>>        TimeSpan tsTotalTime
88943>>>
88943>>>        Move (CurrentDateTime()) to dtTotalQueryStart
88944>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
88945>>>        If (SQLScriptArray.bError = True) Begin
88947>>>            Function_Return False
88948>>>        End
88948>>>>
88948>>>
88948>>>        If (num_arguments > 3) Begin
88950>>>            Move bShowProgr to bShowProgress
88951>>>        End
88951>>>>
88951>>>
88951>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88952>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
88953>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88954>>>
88954>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
88955>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
88956>>>        Set ptsTotalQueryTime to tsTotalTime
88957>>>
88957>>>        Function_Return bOK
88958>>>    End_Function
88959>>>
88959>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
88959>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
88959>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
88959>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
88961>>>        Integer iChannel iArgumentSize iCount
88961>>>        Number nByteCount
88961>>>        String sSQLScript
88961>>>        tSQLScriptArray SqlScriptArray
88961>>>        tSQLScriptArray SqlScriptArray
88961>>>        UChar[] uCharData
88962>>>
88962>>>        Move False to Err
88963>>>        Get Seq_New_Channel to iChannel
88964>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88966>>>            Error DFERR_PROGRAM 'No channel available...'
88967>>>>
88967>>>            Move True to SqlScriptArray.bError
88968>>>            Function_Return SqlScriptArray
88969>>>        End
88969>>>>
88969>>>
88969>>>        // First decide the size of the script
88969>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
88971>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
88973>>>        Close_Input channel iChannel
88975>>>
88975>>>        Move (SizeOfArray(uCharData)) to nByteCount
88976>>>        If (nByteCount  < 1) Begin
88978>>>            Send Seq_Release_Channel iChannel
88979>>>            Move True to SqlScriptArray.bError
88980>>>            Function_Return SqlScriptArray
88981>>>        End
88981>>>>
88981>>>
88981>>>        // If necessary change the string argument_size
88981>>>        // Read the script file from memory line-by-line
88981>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
88983>>>            Move 0 to iCount
88984>>>            Repeat
88984>>>>
88984>>>                Readln channel iChannel sSQLScript
88986>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
88987>>>                Increment iCount
88988>>>            Until (SeqEof = True)
88990>>>        Close_Input channel iChannel
88992>>>        Send Seq_Release_Channel iChannel
88993>>>
88993>>>        // Finally "sanitize" the script by removing all comments.
88993>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
88994>>>
88994>>>        Function_Return SqlScriptArray
88995>>>    End_Function
88996>>>
88996>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
88998>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
88998>>>        Handle hoSql hoSQLConnect hoStmt hoError
88998>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
88998>>>        String[] sMsg aSQLQueryMessages
89000>>>        DateTime dtQueryExecStart dtQueryExecEnd
89000>>>        TimeSpan tsQuery
89000>>>        tSqlErrorArray aSqlErrorArray
89000>>>        tSqlErrorArray aSqlErrorArray
89000>>>        tSQLConnection SQLConnection
89000>>>        tSQLConnection SQLConnection
89000>>>        Boolean bMertechDriver bShowProgress
89000>>>
89000>>>        If (num_arguments > 4) Begin
89002>>>            Move bShowProgr to bShowProgress
89003>>>        End
89003>>>>
89003>>>        Get IsMertechDriver sDriverID to bMertechDriver
89004>>>        If (bMertechDriver = False) Begin
89006>>>            Get phoSQLManager to hoSql
89007>>>        End
89007>>>>
89007>>>        Else Begin
89008>>>            Get _MertechSQLManagerHandle to hoSql
89009>>>        End
89009>>>>
89009>>>
89009>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
89010>>>        // There seems to be a problem to pass strings when their value gets really big, aka
89010>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
89010>>>        // or later SqlExecDirect stops working correctly with no error messages!
89010>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
89010>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
89010>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
89010>>>        Get piChunkMax to iChunkMax
89011>>>        Move 0 to iChunkCounter
89012>>>        Move "" to sStmt
89013>>>
89013>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
89014>>>        Move (Character(13) + Character(10)) to sCR
89015>>>
89015>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89016>>>
89016>>>        If (bMertechDriver = True) Begin
89018>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89019>>>        End
89019>>>>
89019>>>        If (bMertechDriver = False) Begin
89021>>>            Get phoSQLManager  to hoSQL
89022>>>            If (sDriverID = ODBC_DRV_ID) Begin
89024>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
89026>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
89027>>>                    If (iPos > 0) Begin
89029>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
89030>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
89031>>>                    End
89031>>>>
89031>>>                End
89031>>>>
89031>>>            End
89031>>>>
89031>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
89032>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
89033>>>        End
89033>>>>
89033>>>
89033>>>        If (hoSQLConnect <> 0) Begin
89035>>>            Move False to Err
89036>>>            Get SqlOpen of hoSQLConnect to hoStmt
89037>>>            If (hoStmt <> 0) Begin
89039>>>
89039>>>                // If the embedded resource should be written as a script file to disk:
89039>>>                If (bCreateScriptFile = True) Begin
89041>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
89042>>>                    Get vFolderFormat sExportFile to sExportFile
89043>>>                    Move (sExportFile + sMemFileName) to sExportFile
89044>>>                    Get Seq_New_Channel to iOut
89045>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89047>>>                        Direct_Output channel iOut sExportFile
89049>>>                    End
89049>>>>
89049>>>                End
89049>>>>
89049>>>
89049>>>                // Record starting date/time stamp
89049>>>                Move (CurrentDateTime()) to dtQueryExecStart
89050>>>                // Turn on error handling if enabled
89050>>>                If (pbHandleQueryErrors(Self)) Begin
89052>>>                    Set pbSqlError to False
89053>>>                    Set paSqlErrorArray to aSqlErrorArray
89054>>>                    Move Error_Object_Id to hoError
89055>>>                    Move Self to Error_Object_Id
89056>>>                End
89056>>>>
89056>>>
89056>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
89057>>>                Decrement iRows
89058>>>                If (sDriverID = MSSQLDRV_ID) Begin
89060>>>                    Move (sNoCountKeyWord + sCR) to sStmt
89061>>>                End
89061>>>>
89061>>>
89061>>>                For iCount from 0 to iRows
89067>>>>
89067>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
89068>>>
89068>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
89070>>>                        If (sSQLVal <> "") Begin
89072>>>                            Move (sSQLVal + sCR) to sSQLVal
89073>>>                        End
89073>>>>
89073>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
89074>>>                    End
89074>>>>
89074>>>
89074>>>                    // - Each time we encounter a "GO" statement we execute it,
89074>>>                    // or if at the very end of the script.
89074>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
89076>>>
89076>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
89076>>>                        // instead of all in one go.
89076>>>                        Send SqlExecDirect of hoStmt sStmt
89077>>>
89077>>>                        If (bCreateScriptFile = True) Begin
89079>>>                            Write channel iOut sStmt
89081>>>                        End
89081>>>>
89081>>>                        Move "" to sStmt
89082>>>                        Move 0 to iChunkCounter
89083>>>                    End
89083>>>>
89083>>>                    Increment iChunkCounter
89084>>>                Loop
89085>>>>
89085>>>
89085>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
89085>>>                //       so not used for now.
89085>>>                If (bMertechDriver = False) Begin
89087>>>                    Repeat
89087>>>>
89087>>>                        If (pbHandleQueryErrors(Self)) Begin
89089>>>                            Move hoError to Error_Object_Id
89090>>>                        End
89090>>>>
89090>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
89091>>>
89091>>>                        Send _SqlColumnInfo hoStmt
89092>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
89093>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
89094>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
89095>>>                        Set piRows    to iRows
89096>>>                        Set piRowType to iRowType
89097>>>
89097>>>                        If (iMsgs <> 0) Begin
89099>>>                            If (ghoDbUpdateHandler > 0) Begin
89101>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89102>>>                            End
89102>>>>
89102>>>                            For i from 1 to iMsgs
89108>>>>
89108>>>                                Get SqlGetMessage of hoStmt i to sMessage
89109>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
89110>>>                                If (bShowProgress = True) Begin
89112>>>                                    If (Active_State(ghoStatusPanel)) Begin
89114>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89115>>>                                    End
89115>>>>
89115>>>                                    Else Begin
89116>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89118>>>                                    End
89118>>>>
89118>>>                                End
89118>>>>
89118>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
89119>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
89120>>>                            Loop
89121>>>>
89121>>>
89121>>>
89121>>>                            If (ghoDbUpdateHandler > 0) Begin
89123>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89124>>>                            End
89124>>>>
89124>>>                            Set paQueryMessages to sMsg
89125>>>                        End
89125>>>>
89125>>>
89125>>>                        Get SQLNextResultSet of hoStmt to iNextSet
89126>>>                    Until (iNextSet = 0)
89128>>>                End
89128>>>>
89128>>>                Move (CurrentDateTime()) to dtQueryExecEnd
89129>>>            End
89129>>>>
89129>>>
89129>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
89130>>>            Set ptsQueryExec to tsQuery
89131>>>            Send SqlClose of hoStmt
89132>>>
89132>>>            If (bCreateScriptFile = True) Begin
89134>>>                Close_Output channel iOut
89136>>>                Send Seq_Release_Channel iOut
89137>>>            End
89137>>>>
89137>>>        End
89137>>>>
89137>>>        Send SqlDisconnect of hoSQLConnect
89138>>>
89138>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
89139>>>    End_Function
89140>>>
89140>>>    // * Dummy function for the Studio's Code Explorer *
89140>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
89142>>>        Function_Return False
89143>>>    End_Function
89144>>>
89144>>>    // Does three things with auxilirary files;
89144>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
89144>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
89144>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
89144>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
89146>>>        String sDataPath sDDSrcPath sDriverID
89146>>>        Boolean bOK bExists bMertechDriver
89146>>>        Integer iCount iCh iPos
89146>>>
89146>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
89146>>>        If (sTableName contains ".") Begin
89148>>>            Move (Pos(".", sTableName)) to iPos
89149>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
89150>>>        End
89150>>>>
89150>>>
89150>>>        Get psDriverID to sDriverID
89151>>>        Get psDataPathFirstPart to sDataPath
89152>>>        Get vFolderExists sDataPath to bOK
89153>>>        If (bOK = False) Begin
89155>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
89156>>>>
89156>>>            Function_Return False
89157>>>        End
89157>>>>
89157>>>
89157>>>        Get IsMertechDriver sDriverID to bMertechDriver
89158>>>        // First delete the cache file:
89158>>>        Get UtilDeleteCacheFile sTableName to bOK
89159>>>
89159>>>        Get Seq_New_Channel to iCh
89160>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89162>>>            Function_Return False
89163>>>        End
89163>>>>
89163>>>
89163>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
89164>>>        If (bExists = False) Begin
89166>>>            Function_Return False
89167>>>        End
89167>>>>
89167>>>
89167>>>        Get SqlUtilUpdateIntFile hTable to bOK
89168>>>        // Add the new column name to the .tag filen (if it doesn't exist):
89168>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
89169>>>
89169>>>        // If in development environment; output new .fd file:
89169>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
89170>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
89171>>>        If (iCount > 1) Begin
89173>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
89174>>>        End
89174>>>>
89174>>>        Get vFolderExists sDDSrcPath to bExists
89175>>>        If (bExists = True) Begin
89177>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
89178>>>            Move False to Err
89179>>>            Get AutoConnectionIDLogin to bOK
89180>>>            If (hTable <> 0) Begin
89182>>>                Open hTable
89184>>>            End
89184>>>>
89184>>>            Else Begin
89185>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
89186>>>            End
89186>>>>
89186>>>
89186>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
89189>>>            If (bOK = True) Begin
89191>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
89193>>>            End
89193>>>>
89193>>>            If (Err = True) Begin
89195>>>                Move False to bOK
89196>>>            End
89196>>>>
89196>>>        End
89196>>>>
89196>>>
89196>>>        Function_Return (bOK = True)
89197>>>    End_Function
89198>>>
89198>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
89200>>>        Integer iChIn iChOut // iCount
89200>>>        Boolean bExists
89200>>>        String sExistingColumn
89200>>>
89200>>>        Move False to bExists
89201>>>        Get Seq_New_Channel to iChIn
89202>>>        Get Seq_New_Channel to iChOut
89203>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89205>>>            Function_Return True
89206>>>        End
89206>>>>
89206>>>
89206>>>        Move False to Err
89207>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
89207>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
89209>>>        While (not(SeqEof))
89213>>>            Readln channel iChIn sExistingColumn
89215>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
89217>>>                Move True to bExists
89218>>>            End
89218>>>>
89218>>>            If (Trim(sExistingColumn) = "") Begin
89220>>>                Move True to SeqEof
89221>>>            End
89221>>>>
89221>>>        Loop
89222>>>>
89222>>>        Close_Input channel iChIn
89224>>>        Send Seq_Release_Channel iChIn
89225>>>
89225>>>        If (bExists = False) Begin
89227>>>            Append_Output channel iChOut sFullTAGFileName
89229>>>            Writeln channel iChOut sColumnName
89232>>>            Close_Output channel iChOut
89234>>>            Send Seq_Release_Channel iChOut
89235>>>        End
89235>>>>
89235>>>
89235>>>        Function_Return (Err = False)
89236>>>    End_Function
89237>>>
89237>>>    // Message for changing .int files to use connection ID's
89237>>>    //
89237>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
89237>>>    // OR changes an existing connection id to a new id.
89237>>>    // Pass the full path to the data folder and the name of the connection id (string value).
89237>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
89237>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
89239>>>        String sFileName sDriverID sDriverFile sConnectionString
89239>>>        String[] sFilesData
89240>>>        Boolean bOK bCancel
89240>>>        Integer iSize iCount
89240>>>
89240>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
89241>>>        Move (SizeOfArray(sFilesData))    to iSize
89242>>>        If (iSize = 0) Begin
89244>>>            If (ghoStatusPanel <> 0) Begin
89246>>>                If (Active_State(ghoStatusPanel)) Begin
89248>>>                    Send Stop_StatusPanel of ghoStatusPanel
89249>>>                End
89249>>>>
89249>>>            End
89249>>>>
89249>>>            Send Info_Box CS_DUF_NoIntFilesFound
89250>>>            Procedure_Return
89251>>>        End
89251>>>>
89251>>>
89251>>>        Move (Trim(sConnectionID)) to sConnectionID
89252>>>        Get vFolderFormat sDataPath to sDataPath
89253>>>        Decrement iSize
89254>>>        For iCount from 0 to iSize
89260>>>>
89260>>>            Move sFilesData[iCount] to sFileName
89261>>>            // This makes sure that we also can change an existing connection id to something new:
89261>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
89262>>>            If (ghoStatusPanel <> 0) Begin
89264>>>                If (Active_State(ghoStatusPanel)) Begin
89266>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89267>>>                    If (bCancel = True) Begin
89269>>>                        Send Deactivate of ghoStatusPanel
89270>>>                        Procedure_Return
89271>>>                    End
89271>>>>
89271>>>                End
89271>>>>
89271>>>            End
89271>>>>
89271>>>        Loop
89272>>>>
89272>>>
89272>>>        Get psDriverID to sDriverID
89273>>>
89273>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
89273>>>        Move "" to sFileName
89274>>>        If (sDriverID = MSSQLDRV_ID) Begin
89276>>>            Move "MSSQLDrv.int" to sFileName
89277>>>        End
89277>>>>
89277>>>        If (sDriverID = DB2_DRV_ID) Begin
89279>>>            Move "DB2_Drv.int" to sFileName
89280>>>        End
89280>>>>
89280>>>        If (sDriverID = ODBC_DRV_ID) Begin
89282>>>            Move "ODBC_Drv.int" to sFileName
89283>>>        End
89283>>>>
89283>>>        If (sFileName <> "") Begin
89285>>>            Move "" to sDriverFile
89286>>>            Get_File_Path sFileName to sDriverFile
89287>>>            If (sDriverFile <> "") Begin
89289>>>                Get psConnectionString to sConnectionString
89290>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
89291>>>            End
89291>>>>
89291>>>        End
89291>>>>
89291>>>    End_Procedure
89292>>>
89292>>>    // Checks if the database exists in SQL. Returns = True if it does.
89292>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
89294>>>        String[] sDatabaseArray
89295>>>        String sVal sServer sDriverID
89295>>>        Integer iCount iSize iPos
89295>>>        Boolean bExists
89295>>>        tSQLConnection SQLConnection
89295>>>        tSQLConnection SQLConnection
89295>>>
89295>>>        Move False to bExists
89296>>>        Get psDriverID to sDriverID
89297>>>        // DB2 doesn't have a "Database" name, so we always return True.
89297>>>        If (sDriverID = DB2_DRV_ID) Begin
89299>>>            Function_Return bExists
89300>>>        End
89300>>>>
89300>>>
89300>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
89301>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
89303>>>            Function_Return False
89304>>>        End
89304>>>>
89304>>>
89304>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89305>>>        Move SQLConnection.sServer to sServer
89306>>>
89306>>>        // Special code to handle a FILEDSN that also can contain "/"
89306>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
89308>>>            Move sDatabaseArray[0] to sVal  // Dummy!
89309>>>        End
89309>>>>
89309>>>        Else If (sServer contains "/") Begin
89312>>>            Move (Pos("/", sServer)) to iPos
89313>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
89314>>>        End
89314>>>>
89314>>>
89314>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
89315>>>        Decrement iSize
89316>>>        For iCount from 0 to iSize
89322>>>>
89322>>>            Move sDatabaseArray[iCount] to sVal
89323>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
89325>>>                Move True to bExists
89326>>>                If (bExists = True) Begin
89328>>>                    Move iSize to iCount // We're done.
89329>>>                End
89329>>>>
89329>>>            End
89329>>>>
89329>>>        Loop
89330>>>>
89330>>>
89330>>>        Function_Return bExists
89331>>>    End_Function
89332>>>
89332>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
89332>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
89334>>>        String sDatabase sSchema sTableName sVal
89334>>>        Boolean bExists
89334>>>        String[] sTablesArray
89335>>>        Integer iSize iCount
89335>>>
89335>>>        Move False to bExists
89336>>>        Get UtilTableHandleToString hTable to sTableName
89337>>>        Get psDatabase to sDatabase
89338>>>        Get psSchema   to sSchema
89339>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89340>>>        Move (SizeOfArray(sTablesArray)) to iSize
89341>>>        Decrement iSize
89342>>>        For iCount from 0 to iSize
89348>>>>
89348>>>            Move sTablesArray[iCount] to sVal
89349>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89351>>>                Move True to bExists
89352>>>                Move iSize to iCount // We're done!
89353>>>            End
89353>>>>
89353>>>        Loop
89354>>>>
89354>>>
89354>>>        Function_Return bExists
89355>>>    End_Function
89356>>>
89356>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
89356>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
89358>>>        String sDatabase sSchema sVal
89358>>>        Boolean bExists
89358>>>        String[] sTablesArray
89359>>>        Integer iSize iCount
89359>>>
89359>>>        Move False to bExists
89360>>>        Get psDatabase to sDatabase
89361>>>        Get psSchema   to sSchema
89362>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89363>>>        Move (SizeOfArray(sTablesArray)) to iSize
89364>>>        Decrement iSize
89365>>>        For iCount from 0 to iSize
89371>>>>
89371>>>            Move sTablesArray[iCount] to sVal
89372>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89374>>>                Move True to bExists
89375>>>                Move iSize to iCount // We're done!
89376>>>            End
89376>>>>
89376>>>        Loop
89377>>>>
89377>>>
89377>>>        Function_Return bExists
89378>>>    End_Function
89379>>>
89379>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
89381>>>        String sVal sTableSpelledCorrectly
89381>>>        Boolean bExists
89381>>>        String[] sTablesArray
89382>>>        Integer iSize iCount
89382>>>
89382>>>        Move False to bExists
89383>>>        Move sTableName to sTableSpelledCorrectly
89384>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89385>>>        Move (SizeOfArray(sTablesArray)) to iSize
89386>>>        Decrement iSize
89387>>>        For iCount from 0 to iSize
89393>>>>
89393>>>            Move sTablesArray[iCount] to sVal
89394>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89396>>>                Move sVal to sTableSpelledCorrectly
89397>>>                Move iSize to iCount // We're done!
89398>>>            End
89398>>>>
89398>>>        Loop
89399>>>>
89399>>>
89399>>>        Function_Return sTableSpelledCorrectly
89400>>>    End_Function
89401>>>
89401>>>    // ToDo: This index name function needs to be finished...
89401>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
89403>>>        String sSchema sTableName sDriverID
89403>>>        Boolean bExists
89403>>>
89403>>>        Get psDriverID to sDriverID
89404>>>        Get psSchema to sSchema
89405>>>        Get UtilTableHandleToString hTable to sTableName
89406>>>
89406>>>        Function_Return bExists
89407>>>    End_Function
89408>>>
89408>>>    // Checks if a column/field name exists in a SQL table definition
89408>>>    // Returns True if it does
89408>>>    // Sample:
89408>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
89408>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
89410>>>        Integer iNumColumns iColumn
89410>>>        String sColumn sDriverID
89410>>>        String[] sColumnsArray
89411>>>        Boolean bExists bOK
89411>>>
89411>>>        Move False to bExists
89412>>>        Get AutoConnectionIDLogin to bOK
89413>>>        Get psDriverID to sDriverID
89414>>>
89414>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
89415>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
89416>>>        Decrement iNumColumns
89417>>>        For iColumn from 0 to iNumColumns
89423>>>>
89423>>>            Move sColumnsArray[iColumn] to sColumn
89424>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
89426>>>                Move True to bExists
89427>>>                Move iNumColumns to iColumn // We're out of here
89428>>>            End
89428>>>>
89428>>>        Loop
89429>>>>
89429>>>
89429>>>        Function_Return bExists
89430>>>    End_Function
89431>>>
89431>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
89433>>>        Integer iNumColumns iColumn iDFType iNativeType
89433>>>        Boolean bOpened bOK
89433>>>        String sColumnName sNativeTypeName
89433>>>
89433>>>        Get AutoConnectionIDLogin to bOK
89434>>>        Get OpenTableExclusive hTable to bOK
89435>>>        If (bOK = False) Begin
89437>>>            Function_Return False
89438>>>        End
89438>>>>
89438>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89441>>>        If (bOpened = False) Begin
89443>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
89444>>>>
89444>>>            Function_Return False
89445>>>        End
89445>>>>
89445>>>
89445>>>        Move False to Err
89446>>>
89446>>>        Structure_Start hTable
89447>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89450>>>
89450>>>            For iColumn from 1 to iNumColumns
89456>>>>
89456>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
89459>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
89462>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
89465>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
89468>>>
89468>>>                Case Begin
89468>>>                    Case (iDFType = DF_DATE)
89470>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
89472>>>                            // Convert datetime to date
89472>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
89475>>>                        End
89475>>>>
89475>>>                        Case Break
89476>>>                    Case (iDFType = DF_DATETIME)
89479>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
89481>>>                            // Convert datetime to datetime2
89481>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
89484>>>                        End
89484>>>>
89484>>>                        Case Break
89485>>>                    Case (iDFType = DF_ASCII)
89488>>>                        If (iNativeType = SQL_CHAR) Begin
89490>>>                            // Convert char to varchar
89490>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89493>>>                        End
89493>>>>
89493>>>                        Case Break
89494>>>                    Case (iDFType = DF_TEXT)
89497>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
89499>>>                            // Convert text to varchar(max)
89499>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89502>>>                        End
89502>>>>
89502>>>                        Case Break
89503>>>                    Case (iDFType = DF_BINARY)
89506>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
89508>>>                            // Convert image to varbinary(max)
89508>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
89511>>>                        End
89511>>>>
89511>>>                        Case Break
89512>>>                Case End
89512>>>            Loop
89513>>>>
89513>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89514>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89516>>>
89516>>>        Set Action_Text of ghoStatusPanel to ""
89517>>>        Function_Return (Err = False)
89518>>>    End_Function
89519>>>
89519>>>
89519>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
89519>>>    // the DbUpdateVersion database revision in.
89519>>>    // Also pass the file number of the current (embedded?) table number used in development.
89519>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
89519>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
89521>>>        Boolean bOK bOpened
89521>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
89521>>>
89521>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89524>>>        Get _TableNameOnly sTableName to sTableName
89525>>>        If (sTableName = "") Begin
89527>>>            Function_Return False
89528>>>        End
89528>>>>
89528>>>
89528>>>        // This just creates the table and a "dummy" column.
89528>>>        Get SqlTableCreate hTable sDriverID to bOK
89529>>>        If (bOK = False) Begin
89531>>>            Function_Return False
89532>>>        End
89532>>>>
89532>>>
89532>>>        Close hTable
89533>>>        Move False to Err
89534>>>
89534>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
89535>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
89536>>>        Move "Decimal" to sDataType
89537>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
89538>>>
89538>>>        // Adds the "sColumnName" passed to the function
89538>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
89539>>>        Send SqlUtilExecuteQuery sStmt sDriverID
89540>>>
89540>>>        // Now we can delete the dummy column:
89540>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
89541>>>
89541>>>        // Finally, we attach to the newly created table.
89541>>>        If (Err = False) Begin
89543>>>            Get ApiTableAttachToSQL hTable True to bOK
89544>>>        End
89544>>>>
89544>>>        Open hTable
89546>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89549>>>
89549>>>        Function_Return (Err = False and bOK = True and bOpened = True)
89550>>>    End_Function
89551>>>
89551>>>    // The table must already exist in the filelist for this function to work.
89551>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
89551>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
89553>>>        Boolean bOK bExists bUseConnectionID bMertech
89553>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
89553>>>        String[] sIndexArray
89554>>>        Integer iCount iCh iSize
89554>>>
89554>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
89555>>>        Get psConnectionString to sConnectionString
89556>>>
89556>>>        Move CS_ANSI_Txt to sANSI_OEM
89557>>>        If (bANSI = False) Begin
89559>>>            Move CS_OEM_Txt to sANSI_OEM
89560>>>        End
89560>>>>
89560>>>
89560>>>        Get psDataPathFirstPart to sDataPath
89561>>>        Get vFolderExists sDataPath to bOK
89562>>>        If (bOK = False) Begin
89564>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
89565>>>>
89565>>>            Function_Return False
89566>>>        End
89566>>>>
89566>>>        Get vFolderFormat sDataPath to sDataPath
89567>>>
89567>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89570>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89573>>>        Get _TableNameOnly sRootName to sDatabaseName
89574>>>        Move sLogicalName  to sPhysicalFileName
89575>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
89576>>>
89576>>>        Get IsMertechDriver sDriverID to bMertech
89577>>>        If (bMertech = True) Begin
89579>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
89579>>>            // Else it will create an error in the error log (although it won't do anything...)
89579>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
89579>>>            Function_Return (bOK = True)
89580>>>        End
89580>>>>
89580>>>
89580>>>        Get psSchema hTable to sSchemaName
89581>>>        If (sSchemaName = "") Begin
89583>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
89584>>>        End
89584>>>>
89584>>>
89584>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
89584>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
89585>>>        If (bExists = True) Begin
89587>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
89588>>>        End
89588>>>>
89588>>>
89588>>>        Get UtilDeleteCacheFile sRootName to bOK
89589>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
89590>>>
89590>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
89591>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
89596>>>            If (bUseConnectionID = True) Begin
89598>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
89605>>>            End
89605>>>>
89605>>>            Else Begin
89606>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
89613>>>            End
89613>>>>
89613>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
89618>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
89623>>>            // There seems to be a new order how these are set from DF19.
89623>>>            If (bSysFile = True) Begin
89625>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
89630>>>            End
89630>>>>
89630>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
89635>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
89640>>>            If (bSysFile = True) Begin
89642>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
89647>>>            End
89647>>>>
89647>>>
89647>>>            If (bSysFile = False) Begin
89649>>>                Move (SizeOfArray(sIndexArray)) to iSize
89650>>>                Move (SortArray(sIndexArray)) to sIndexArray
89651>>>                If (iSize > 0) Begin
89653>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
89656>>>                    Writeln channel iCh // Just an empty line
89658>>>                End
89658>>>>
89658>>>                Decrement iSize
89659>>>                For iCount from 0 to iSize
89665>>>>
89665>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
89668>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
89671>>>                    Writeln channel iCh
89673>>>                Loop
89674>>>>
89674>>>            End
89674>>>>
89674>>>        Send Seq_Close_Channel iCh
89675>>>
89675>>>        // Wait a sec for Windows to finish writing the file:
89675>>>        Sleep 1
89676>>>
89676>>>        Function_Return (bOK = True)
89677>>>    End_Function
89678>>>
89678>>>    // Returns a handle to the SQL server associated with the passed driver ID.
89678>>>    // Pass e.g. the psServer property to determine the current connection server.
89678>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
89678>>>    // This handle can be used to obtain attributes about the server, such as default
89678>>>    // column types.
89678>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
89680>>>        Handle hDatabase
89680>>>        Integer iDriver iServers iCount
89680>>>        String sValue
89680>>>
89680>>>        If (sServer = "") Begin
89682>>>            Function_Return 0
89683>>>        End
89683>>>>
89683>>>
89683>>>        Get DriverIndex sDriverID to iDriver
89684>>>        If (iDriver = 0) Begin
89686>>>            Function_Return 0
89687>>>        End
89687>>>>
89687>>>
89687>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
89690>>>        For iCount from 1 to iServers
89696>>>>
89696>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
89699>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
89701>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
89704>>>            End
89704>>>>
89704>>>        Loop
89705>>>>
89705>>>
89705>>>        Function_Return hDatabase
89706>>>    End_Function
89707>>>
89707>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
89707>>>//        String sRootName
89707>>>//        Boolean bOK
89707>>>//
89707>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89707>>>//        Move (sRootName contains sDriverID) to bOK
89707>>>//
89707>>>//        Function_Return bOK
89707>>>//    End_Function
89707>>>
89707>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
89707>>>//        String sDriverID sRootName sDisplayName sSchema sVal
89707>>>//        Integer iDbType
89707>>>//        Boolean bOK
89707>>>//
89707>>>//        Get UtilIsFilelistEntryDriverBased to bOK
89707>>>//        If (bOK = True) Begin
89707>>>//            Function_Return False
89707>>>//        End
89707>>>//
89707>>>//        Get psDriverID to sDriverID
89707>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89707>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
89707>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89707>>>//
89707>>>//        Get psDriverID to sDriverID
89707>>>//        Get piDbType   to iDbType
89707>>>//        Get psSchema   to sSchema
89707>>>//        If (sSchema = "") Begin
89707>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
89707>>>//        End
89707>>>//
89707>>>//        Move (Uppercase(sDisplayName)) to sVal
89707>>>//        If (not(sVal contains (sSchema + "."))) Begin
89707>>>//            If (iDbType = EN_dbTypeDB2) Begin
89707>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
89707>>>//            End
89707>>>//            Else Begin
89707>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
89707>>>//            End
89707>>>//        End
89707>>>//
89707>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89707>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89707>>>//
89707>>>//        Function_Return True
89707>>>//    End_Function
89707>>>
89707>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
89707>>>    // from the passed filelist.
89707>>>    // Returns the number of tables affected.
89707>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
89709>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
89709>>>        Integer iRetval
89709>>>        Handle hTable
89709>>>
89709>>>        // We first save the current filelist as the passed filelist name
89709>>>        // may come from another workspace, to restore it when we're ready.
89709>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
89712>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
89715>>>        Move 0 to hTable
89716>>>        Move 0 to iRetval
89717>>>
89717>>>        Repeat
89717>>>>
89717>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89720>>>            If (hTable <> 0) Begin
89722>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89725>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89728>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89731>>>                Move (Uppercase(sRootName)) to sVal
89732>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
89734>>>                    // Prefixes:
89734>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
89735>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
89736>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
89737>>>                    // Suffixes:
89737>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
89738>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
89739>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
89740>>>
89740>>>                    // Change Filelist entry:
89740>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
89743>>>
89743>>>                    Move (Lowercase(sDisplayName)) to sVal
89744>>>                    If (sVal contains "dbo.") Begin
89746>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
89747>>>
89747>>>                        // Change Filelist entry:
89747>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
89750>>>                    End
89750>>>>
89750>>>                    Increment iRetval
89751>>>                End
89751>>>>
89751>>>            End
89751>>>>
89751>>>        Until (hTable = 0)
89753>>>
89753>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
89756>>>
89756>>>        Function_Return iRetval
89757>>>    End_Function
89758>>>
89758>>>    // To open all Sql based tables in Filelist.cfg
89758>>>    Procedure SqlUtilOpenAllTables
89760>>>        Handle hTable
89760>>>        String sRoot sDriverID
89760>>>        Boolean bOK
89760>>>
89760>>>        Move 0 to hTable
89761>>>        Move "" to sDriverID
89762>>>        Get AutoConnectionIDLogin to bOK
89763>>>
89763>>>        Repeat
89763>>>>
89763>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89766>>>            If (hTable > 0) Begin
89768>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89771>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
89773>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
89776>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
89778>>>                        Open hTable
89780>>>                    End
89780>>>>
89780>>>                End
89780>>>>
89780>>>            End
89780>>>>
89780>>>
89780>>>        Until (hTable = 0)
89782>>>    End_Procedure
89783>>>
89783>>>//    Function SqlUtilSchemaName Handle hTable Returns String
89783>>>//        String sRetval sDriverID
89783>>>//        String sTableName
89783>>>//        Integer iDbType iIndex
89783>>>//        Boolean bOK
89783>>>//
89783>>>//        Get psDriverID to sDriverID
89783>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
89783>>>//        If (hTable = 0 or bOK = False) Begin
89783>>>//            Function_Return ""
89783>>>//        End
89783>>>//
89783>>>//        Move False to Err
89783>>>//        Get UtilTableHandleToString hTable to sTableName
89783>>>//        Get piDbType to iDbType
89783>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
89783>>>//        If (iIndex = -1) Begin
89783>>>//            Function_Return ""
89783>>>//        End
89783>>>//
89783>>>//        Function_Return sRetval
89783>>>//    End_Function
89783>>>
89783>>>    // Checks if the passed Table;
89783>>>    // 1) Already has a Filelist entry that points to SQL and
89783>>>    // 2) It has an .int file.
89783>>>    // If both is True it should already be connected to SQL
89783>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
89785>>>        Boolean bExists bRootName
89785>>>        String sRootName sDataPath
89785>>>
89785>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89788>>>        Move (sRootName contains sDriverID) to bRootName
89789>>>
89789>>>        Get psDataPathFirstPart to sDataPath
89790>>>        Get vFolderExists sDataPath to bExists
89791>>>        If (bExists = False) Begin
89793>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
89793>>>            Function_Return False
89794>>>        End
89794>>>>
89794>>>
89794>>>        Get vFolderFormat sDataPath to sDataPath
89795>>>        Get _TableNameOnly sRootName to sRootName
89796>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
89797>>>
89797>>>        Function_Return (bRootName = True and bExists = True)
89798>>>    End_Function
89799>>>
89799>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
89801>>>        Boolean bViewTableType bOpen bOK
89801>>>        Integer iTableCount iNumTables
89801>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
89801>>>        Handle hoCliHandler
89801>>>        tSQLConnection SQLConnection
89801>>>        tSQLConnection SQLConnection
89801>>>
89801>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89804>>>        If (bOpen = False) Begin
89806>>>            Get AutoConnectionIDLogin to bOK
89807>>>            Open hTable
89809>>>        End
89809>>>>
89809>>>
89809>>>        Get pSQLConnection to SQLConnection
89810>>>        Get phoCLIHandler to hoCliHandler
89811>>>        Set psDriverID of hoCliHandler to sDriverID
89812>>>
89812>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89815>>>        Get _TableNameOnly sTableName to sTableName
89816>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
89819>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
89820>>>
89820>>>        For iTableCount from 1 to iNumTables
89826>>>>
89826>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
89827>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
89828>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
89830>>>                Get TableType of hoCliHandler iTableCount to sTableType
89831>>>                Move iNumTables to iTableCount // We're done.
89832>>>            End
89832>>>>
89832>>>        Loop
89833>>>>
89833>>>
89833>>>        Move (sTableType = "VIEW") to bViewTableType
89834>>>        If (bOpen = False) Begin
89836>>>            Close hTable
89837>>>        End
89837>>>>
89837>>>
89837>>>        Function_Return bViewTableType
89838>>>    End_Function
89839>>>
89839>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
89839>>>    //
89839>>>    // SQL utility function that returns a database type (string) constant
89839>>>    // corresponding to the passed iDbType.
89839>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
89841>>>        String sRetval
89841>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89842>>>        Function_Return sRetval
89843>>>    End_Function
89844>>>
89844>>>    // SQL utility function that returns a database type constant (integer)
89844>>>    // corresponding to the passed sDbType string constant.
89844>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
89846>>>        Integer iRetval
89846>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
89847>>>        Function_Return iRetval
89848>>>    End_Function
89849>>>
89849>>>    // Pass an integer DbType and function returns the database type integer as a string value.
89849>>>    // Used e.g. when reading a connection ini-file to display the database type in
89849>>>    // the SQL Connection program's grid.
89849>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
89851>>>        String sRetval
89851>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89852>>>        Function_Return sRetval
89853>>>    End_Function
89854>>>
89854>>>    // Pass a driver name as a string and the function will return
89854>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
89854>>>    // quite work and always returns "MS SQL Server"
89854>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
89856>>>        Integer iRetval
89856>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
89857>>>        Function_Return iRetval
89858>>>    End_Function
89859>>>
89859>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
89859>>>    // that "fits" in the max allowed length for table names.
89859>>>    // Max number of characters allowed for table names;
89859>>>    // IBM DB2      = 128
89859>>>    // MS-SQL       = 128
89859>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
89859>>>    // MySQL        = 64
89859>>>    // PostgreSQL   = 64
89859>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
89861>>>        String sGUIDName
89861>>>        Integer iDbType iLength
89861>>>
89861>>>        Get piDbType to iDbType
89862>>>        Move (RandomHexUUID()) to sGUIDName
89863>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
89864>>>        Move (Length(sGUIDName)) to iLength
89865>>>
89865>>>        Case Begin
89865>>>            Case (iDbType = EN_DbTypeDB2)
89867>>>            If (iLength > 128) Begin
89869>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89870>>>            End
89870>>>>
89870>>>            Case Break
89871>>>
89871>>>            Case (iDbType = EN_DbTypeMSSQL)
89874>>>            If (iLength > 128) Begin
89876>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89877>>>            End
89877>>>>
89877>>>            Case Break
89878>>>
89878>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
89881>>>            If (iLength > 128) Begin
89883>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89884>>>            End
89884>>>>
89884>>>            Case Break
89885>>>
89885>>>            Case (iDbType = EN_DbTypeMySQL)
89888>>>            If (iLength > 64) Begin
89890>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89891>>>            End
89891>>>>
89891>>>            Case Break
89892>>>
89892>>>            Case (iDbType = EN_DbTypePostgre)
89895>>>            If (iLength > 64) Begin
89897>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89898>>>            End
89898>>>>
89898>>>        Case End
89898>>>
89898>>>        Function_Return sGUIDName
89899>>>    End_Function
89900>>>
89900>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
89900>>>    // Pass the memory resource file reference and the filename to be created,
89900>>>    // including full path.
89900>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
89902>>>        String sText
89902>>>        Integer iCh iSize iArgSize
89902>>>
89902>>>        Move ("Resource:" + sMemFileName) to sMemFileName
89903>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
89904>>>        Get_Channel_Size iCh to iSize
89905>>>        Read_Block channel iCh sText iSize
89907>>>        Send Seq_Close_Channel iCh
89908>>>
89908>>>        Get Seq_Open_Output_Channel sFileName to iCh
89909>>>            Write channel iCh sText
89911>>>        Send Seq_Close_Channel iCh
89912>>>
89912>>>        // Wait for file to be written to disk.
89912>>>        Sleep 2
89913>>>    End_Procedure
89914>>>
89914>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
89916>>>        String sNotNull sRetval sDefaultValue
89916>>>        Boolean bOK
89916>>>
89916>>>        Get IsSQLDriver sDriverID to bOK
89917>>>        If (bOK = False) Begin
89919>>>            Function_Return ""
89920>>>        End
89920>>>>
89920>>>
89920>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
89921>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
89922>>>
89922>>>        Case Begin
89922>>>            Case (iDbType = EN_dbTypeMSSQL)
89924>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
89925>>>                Case Break
89926>>>            Case (iDbType = EN_dbTypeMySQL)
89929>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89930>>>                Case Break
89931>>>            Case (iDbType = EN_dbTypePostgre)
89934>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89935>>>                Case Break
89936>>>            Case (iDbType = EN_dbTypeDB2)
89939>>>                Move (String(sNotNull))                                     to sRetval
89940>>>                Case Break
89941>>>
89941>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
89941>>>            // ToDo: We need to look deeper into how Oracle handles NULL
89941>>>            Case (iDbType = EN_dbTypeOracle)
89944>>>                Move  ""                                                    to sRetval
89945>>>                Case Break
89946>>>
89946>>>            Case Else
89946>>>                Move  ""                                                    to sRetval
89947>>>        Case End
89947>>>
89947>>>        Function_Return sRetval
89948>>>    End_Function
89949>>>
89949>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
89951>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
89951>>>        Boolean bOpened bOK bMertech
89951>>>
89951>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
89951>>>        // which makes the program unable to run because they can't be opened.
89951>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
89951>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
89951>>>        // proper .int files for the two tables.
89951>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
89953>>>            Function_Return True
89954>>>        End
89954>>>>
89954>>>
89954>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89957>>>        Get _TableNameOnly sRootName to sDatabaseName
89958>>>        Move CS_OEM_Txt  to sOrgFormat
89959>>>        Move CS_ANSI_Txt to sNewFormat
89960>>>        Get AutoConnectionIDLogin to bOK
89961>>>
89961>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
89961>>>        Sleep 1
89962>>>
89962>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89965>>>        If (bOpened = False) Begin
89967>>>            Open hTable
89969>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
89972>>>        End
89972>>>>
89972>>>        If (bOpened = False) Begin
89974>>>            Function_Return False
89975>>>        End
89975>>>>
89975>>>
89975>>>        Get psDriverID to sDriverID
89976>>>        Get IsMertechDriver sDriverID to bMertech
89977>>>        If (bMertech = True) Begin
89979>>>            Get psDataPathFirstPart to sDataPath
89980>>>            Get vFolderExists sDataPath to bOK
89981>>>            If (bOK = False) Begin
89983>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
89984>>>>
89984>>>                Function_Return False
89985>>>            End
89985>>>>
89985>>>            Get vFolderFormat sDataPath to sDataPath
89986>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89989>>>            Get _TableNameOnly sRootName to sDatabaseName
89990>>>            Move sDatabaseName to sPhysicalFileName
89991>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
89992>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
89993>>>            Function_Return (bOK = True)
89994>>>        End
89994>>>>
89994>>>
89994>>>        Move False to Err
89995>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89998>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
89999>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
89999>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
89999>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
90000>>>
90000>>>        Move False to Err
90001>>>
90001>>>        If (hTable > 0) Begin
90003>>>            Structure_Start hTable
90004>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
90007>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
90010>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90012>>>        End
90012>>>>
90012>>>        Else Begin
90013>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
90016>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
90019>>>        End
90019>>>>
90019>>>        Function_Return (Err = False)
90020>>>    End_Function
90021>>>
90021>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
90023>>>        String[] sReturnArray
90024>>>        String sValue // sUserID sPassword
90024>>>        Handle hoSQLHandler hoSQLConnect hStmt
90024>>>        Integer iFetchResult iRetval
90024>>>        tSQLConnection SQLConnection
90024>>>        tSQLConnection SQLConnection
90024>>>
90024>>>        Get _MertechSQLManagerHandle to hoSQLHandler
90025>>>        If (hoSQLHandler <> 0) Begin
90027>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90028>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
90029>>>            If (hoSQLConnect <> 0) Begin
90031>>>                Get SQLOpen of hoSQLConnect to hStmt
90032>>>                If (hStmt <> 0) Begin
90034>>>                    Send SQLSetProcedureName of hStmt sStmt
90035>>>                    If (sArgument <> "") Begin
90037>>>                        Send SqlSetArgument  of hStmt 1 sArgument
90038>>>                    End
90038>>>>
90038>>>                    Send SQLCall of hStmt
90039>>>
90039>>>                    Get SqlReturnValue       of hStmt to iRetval
90040>>>                    If (iRetval = 0) Begin
90042>>>                        Repeat
90042>>>>
90042>>>                            Get SQLFetch of hStmt to iFetchResult
90043>>>                            If (iFetchResult <> 0) Begin
90045>>>                                Get SQLColumnValue of hStmt 1 to sValue
90046>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90047>>>                            End
90047>>>>
90047>>>                        Until (iFetchResult = 0)
90049>>>                        Send SQLClose of hStmt
90050>>>                    End
90050>>>>
90050>>>                End
90050>>>>
90050>>>                Send SQLDisconnect of hoSQLConnect
90051>>>            End
90051>>>>
90051>>>        End
90051>>>>
90051>>>
90051>>>        Function_Return sReturnArray
90052>>>    End_Function
90053>>>
90053>>>    // * Dummy function for the Studio's Code Explorer *
90053>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
90055>>>        Function_Return False
90056>>>    End_Function
90057>>>
90057>>>    // Enumerate SQL Servers.
90057>>>    // Pass a driver id. Returns a string array.
90057>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
90057>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
90057>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
90059>>>        String[] sReturnArray
90060>>>        Handle hoSQLHandler
90060>>>        String sServer
90060>>>        Integer iCount iNumItems iDataSourceType
90060>>>
90060>>>        If (num_arguments > 1) Begin
90062>>>            Move iDatSrcType to iDataSourceType
90063>>>        End
90063>>>>
90063>>>
90063>>>        Case Begin
90063>>>            Case (sDriverID = MSSQLDRV_ID)
90065>>>                Get phoMSSQLHandler to hoSQLHandler
90066>>>                Get EnumerateServers of hoSQLHandler to iNumItems
90067>>>                For iCount from 0 to (iNumItems - 1)
90073>>>>
90073>>>                    Get String_Value of hoSQLHandler iCount to sServer
90074>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
90075>>>                Loop
90076>>>>
90076>>>                Case Break
90077>>>
90077>>>            Case (sDriverID = DB2_DRV_ID)
90080>>>                Get phoDB2SQLHandler to hoSQLHandler
90081>>>                Send SeedDataSources of hoSQLHandler
90082>>>                Move 0 to iCount
90083>>>                Repeat
90083>>>>
90083>>>                    Get DataSources of hoSQLHandler to sServer
90084>>>                    If (sServer <> "") Begin
90086>>>                        Move (Replace(",", sServer, "")) to sServer
90087>>>                        Move sServer to sReturnArray[iCount]
90088>>>                    End
90088>>>>
90088>>>                    Increment iCount
90089>>>                Until (sServer = "")
90091>>>                Case Break
90092>>>
90092>>>            Case (sDriverID = ODBC_DRV_ID)
90095>>>                Get phoODBCSQLHandler to hoSQLHandler
90096>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
90097>>>                Move 0 to iCount
90098>>>                Repeat
90098>>>>
90098>>>                    Get DataSources of hoSQLHandler to sServer
90099>>>                    If (sServer <> "") Begin
90101>>>                        Move (Replace(",", sServer, ", ")) to sServer
90102>>>                        Move sServer to sReturnArray[iCount]
90103>>>                    End
90103>>>>
90103>>>                    Increment iCount
90104>>>                Until (sServer = "")
90106>>>                Case Break
90107>>>
90107>>>            Case (sDriverID = SQLFLEX)
90110>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
90111>>>                Case Break
90112>>>
90112>>>            Case (sDriverID = ORAFLEX)
90115>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
90116>>>                Case Break
90117>>>
90117>>>            // There appearantly is no way to enumerate servers for this backend.
90117>>>            Case (sDriverID = MDSPgSQL)
90120>>>                Move "localhost" to sReturnArray[0]
90121>>>                Case Break
90122>>>
90122>>>            // There appearantly is no way to enumerate servers for this backend.
90122>>>            Case (sDriverID = MDSMySQL)
90125>>>                Move "localhost" to sReturnArray[0]
90126>>>                Case Break
90127>>>
90127>>>            Case Else
90127>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
90128>>>>
90128>>>        Case End
90128>>>
90128>>>        Function_Return sReturnArray
90129>>>    End_Function
90130>>>
90130>>>    // Returns all databases as a string array for the passed driver id.
90130>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
90132>>>        String[] sReturnArray
90133>>>        String sServer sVal
90133>>>        tSQLIntTableInfo[] sReturnStructArray
90133>>>        tSQLIntTableInfo[] sReturnStructArray
90134>>>        tSQLConnection SQLConnection
90134>>>        tSQLConnection SQLConnection
90134>>>        Boolean bOK
90134>>>        Integer iCount iSize
90134>>>
90134>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90135>>>        If (bOK = False) Begin
90137>>>            Function_Return sReturnArray
90138>>>        End
90138>>>>
90138>>>
90138>>>        Case Begin
90138>>>            Case (sDriverID = MSSQLDRV_ID)
90140>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
90141>>>                Case Break
90142>>>            Case (sDriverID = DB2_DRV_ID)
90145>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
90146>>>                Case Break
90147>>>
90147>>>            // This is needed to be able to check if a database exists or not.
90147>>>            Case (sDriverID = ODBC_DRV_ID)
90150>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
90151>>>                If (SizeOfArray(sReturnStructArray)) Begin
90153>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
90155>>>                        // If a FILEDSN: (can only be one database name)
90155>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
90156>>>                    End
90156>>>>
90156>>>                    Else Begin
90157>>>                        // Else the DSN's were read from the registry.
90157>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90158>>>                        Move SQLConnection.sServer to sServer
90159>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
90160>>>                        Decrement iSize
90161>>>                        for iCount from 0 to iSize
90167>>>>
90167>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
90168>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
90170>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
90171>>>                                Move iSize to iCount // We're done.
90172>>>                            End
90172>>>>
90172>>>                        Loop
90173>>>>
90173>>>                    End
90173>>>>
90173>>>                End
90173>>>>
90173>>>                Case Break
90174>>>
90174>>>            Case (sDriverID = SQLFLEX)
90177>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
90178>>>                Case Break
90179>>>
90179>>>            Case (sDriverID = MDSPgSQL)
90182>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
90183>>>                Case Break
90184>>>
90184>>>            Case (sDriverID = MDSMySQL)
90187>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
90188>>>                Case Break
90189>>>
90189>>>            Case (sDriverID = ORAFLEX)
90192>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
90193>>>                Case Break
90194>>>
90194>>>            Case Else
90194>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
90194>>>        Case End
90194>>>
90194>>>        Function_Return sReturnArray
90195>>>    End_Function
90196>>>
90196>>>    // Returns all table spaces as a string array for the passed driver id.
90196>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
90198>>>        String[] sReturnArray
90199>>>        Boolean bOK
90199>>>
90199>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90200>>>        If (bOK = False) Begin
90202>>>            Function_Return sReturnArray
90203>>>        End
90203>>>>
90203>>>
90203>>>        Case Begin
90203>>>            Case (sDriverID = DB2_DRV_ID)
90205>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
90206>>>                Case Break
90207>>>
90207>>>            Case (sDriverID = MDSPgSQL)
90210>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
90211>>>                Case Break
90212>>>
90212>>>            Case (sDriverID = ORAFLEX)
90215>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
90216>>>                Case Break
90217>>>
90217>>>            Case Else
90217>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
90218>>>>
90218>>>                Case Break
90219>>>        Case End
90219>>>
90219>>>        Function_Return sReturnArray
90220>>>    End_Function
90221>>>
90221>>>    // Returns all schemas as a string array for the passed driver id.
90221>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
90223>>>        String[] sReturnArray
90224>>>        Boolean bOK
90224>>>
90224>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90225>>>        If (bOK = False) Begin
90227>>>            Function_Return sReturnArray
90228>>>        End
90228>>>>
90228>>>
90228>>>        Case Begin
90228>>>            Case (sDriverID = DB2_DRV_ID)
90230>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
90231>>>                Case Break
90232>>>
90232>>>            Case (sDriverID = MDSPgSQL)
90235>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
90236>>>                Case Break
90237>>>
90237>>>            Case (sDriverID = ORAFLEX)
90240>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
90241>>>                Case Break
90242>>>
90242>>>            Case Else
90242>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
90243>>>>
90243>>>                Case Break
90244>>>        Case End
90244>>>
90244>>>        Function_Return sReturnArray
90245>>>    End_Function
90246>>>
90246>>>    // Returns a string array with all tables for the current database.
90246>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
90248>>>        String[] sReturnArray sArray
90250>>>        String sConnectionString sSelect
90250>>>        Integer iSize iCount iDbType
90250>>>        Boolean bOK
90250>>>
90250>>>        If (sDriverID = DATAFLEX_ID) Begin
90252>>>            Function_Return sArray
90253>>>        End
90253>>>>
90253>>>
90253>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90254>>>        If (bOK = False) Begin
90256>>>            Function_Return sReturnArray
90257>>>        End
90257>>>>
90257>>>        If (sSchema = "") Begin
90259>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90260>>>        End
90260>>>>
90260>>>
90260>>>        Get psConnectionString to sConnectionString
90261>>>
90261>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
90261>>>        // the dbType.
90261>>>        Get piDbType to iDbType
90262>>>        If (sDriverID = ODBC_DRV_ID) Begin
90264>>>            If (iDbType = EN_DbTypeMySQL) Begin
90266>>>                Move MDSMySQL to sDriverID
90267>>>            End
90267>>>>
90267>>>            If (iDbType = EN_DbTypeMSSQL) Begin
90269>>>                Move MSSQLDRV_ID to sDriverID
90270>>>            End
90270>>>>
90270>>>            If (iDbType = EN_DbTypeDB2) Begin
90272>>>                Move DB2_DRV_ID to sDriverID
90273>>>            End
90273>>>>
90273>>>            If (iDbType = EN_DbTypePostgre) Begin
90275>>>                Move MDSPgSQL to sDriverID
90276>>>            End
90276>>>>
90276>>>        End
90276>>>>
90276>>>
90276>>>        Case Begin
90276>>>            Case (sDriverID = MSSQLDRV_ID)
90278>>>                Get _SqlTableArrayDAW to sReturnArray
90279>>>                Case Break
90280>>>
90280>>>            Case (sDriverID = DB2_DRV_ID)
90283>>>                Get _SqlTableArrayDAW to sReturnArray
90284>>>                Case Break
90285>>>
90285>>>            Case (sDriverID = ODBC_DRV_ID)
90288>>>                Get _SqlTableArrayDAW to sReturnArray
90289>>>                Case Break
90290>>>
90290>>>            Case (sDriverID = SQLFLEX)
90293>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
90294>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90295>>>                Case Break
90296>>>
90296>>>            Case (sDriverID = MDSMySQL)
90299>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
90300>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90301>>>                Case Break
90302>>>
90302>>>            Case (sDriverID = MDSPgSQL)
90305>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
90306>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
90307>>>                Case Break
90308>>>
90308>>>            Case (sDriverID = ORAFLEX)
90311>>>                Move "SELECT table_name from user_tables" to sSelect
90312>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
90313>>>                Move (SizeOfArray(sArray)) to iSize
90314>>>                Decrement iSize
90315>>>                For iCount from 0 to iSize
90321>>>>
90321>>>                    If (not(sArray[iCount] contains "$")) Begin
90323>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
90324>>>                    End
90324>>>>
90324>>>                Loop
90325>>>>
90325>>>                Case Break
90326>>>
90326>>>            Case Else
90326>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
90327>>>>
90327>>>                Case Break
90328>>>        Case End
90328>>>
90328>>>        Function_Return sReturnArray
90329>>>    End_Function
90330>>>
90330>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
90330>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
90332>>>        String[] sReturnArray
90333>>>        String sConnectionString sSelect sSchema
90333>>>        Boolean bOK
90333>>>        Integer iDbType
90333>>>
90333>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90334>>>        If (bOK = False) Begin
90336>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90337>>>>
90337>>>            Function_Return sReturnArray
90338>>>        End
90338>>>>
90338>>>
90338>>>        Get psConnectionString to sConnectionString
90339>>>        Get psSchema to sSchema
90340>>>
90340>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
90340>>>        // the dbType.
90340>>>        Get piDbType to iDbType
90341>>>
90341>>>        Case Begin
90341>>>            Case (sDriverID = ODBC_DRV_ID)
90343>>>                If (iDbType = EN_DbTypeMySQL) Begin
90345>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
90346>>>                End
90346>>>>
90346>>>                If (iDbType = EN_DbTypePostgre) Begin
90348>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
90349>>>                End
90349>>>>
90349>>>                If (iDbType = EN_DbTypeMSSQL) Begin
90351>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90352>>>                End
90352>>>>
90352>>>
90352>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90353>>>                Case Break
90354>>>
90354>>>            Case (sDriverID = MSSQLDRV_ID)
90357>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90358>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90359>>>                Case Break
90360>>>
90360>>>            Case (sDriverID = DB2_DRV_ID)
90363>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
90364>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90365>>>                Case Break
90366>>>
90366>>>            Case (sDriverID = SQLFLEX)
90369>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90370>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90371>>>                Case Break
90372>>>
90372>>>            Case (sDriverID = MDSMySQL)
90375>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
90376>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90377>>>                Case Break
90378>>>
90378>>>            Case (sDriverID = MDSPgSQL)
90381>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
90382>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90383>>>                Case Break
90384>>>
90384>>>            Case (sDriverID = ORAFLEX)
90387>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
90388>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90389>>>                Case Break
90390>>>
90390>>>            Case Else
90390>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
90391>>>>
90391>>>                Case Break
90392>>>        Case End
90392>>>
90392>>>        Function_Return sReturnArray
90393>>>    End_Function
90394>>>
90394>>>
90394>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
90394>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
90396>>>        String[] sReturnArray sReturnArray2
90398>>>        String sConnectionString sSelect sSchema
90398>>>        Boolean bOK
90398>>>        Integer iCount iSize
90398>>>
90398>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90399>>>        If (bOK = False) Begin
90401>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90402>>>>
90402>>>            Function_Return sReturnArray
90403>>>        End
90403>>>>
90403>>>
90403>>>        Get psConnectionString to sConnectionString
90404>>>        Get psSchema to sSchema
90405>>>
90405>>>        Case Begin
90405>>>            Case (sDriverID = MSSQLDRV_ID)
90407>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
90408>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90409>>>                Case Break
90410>>>
90410>>>            Case (sDriverID = DB2_DRV_ID)
90413>>>                Error "Not implemented yet! The select statement has not been finalized."
90414>>>>
90414>>>//                Move () to sSelect
90414>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90414>>>                Case Break
90415>>>
90415>>>            Case (sDriverID = SQLFLEX)
90418>>>                Error "Not implemented yet! The select statement has not been finalized."
90419>>>>
90419>>>//                Move () to sSelect
90419>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90419>>>                Case Break
90420>>>
90420>>>            Case (sDriverID = MDSMySQL)
90423>>>                Error "Not implemented yet! The select statement has not been finalized."
90424>>>>
90424>>>//                Move () to sSelect
90424>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90424>>>                Case Break
90425>>>
90425>>>            Case (sDriverID = MDSPgSQL)
90428>>>                Error "Not implemented yet! The select statement has not been finalized."
90429>>>>
90429>>>//                Move () to sSelect
90429>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90429>>>                Case Break
90430>>>
90430>>>            Case (sDriverID = ORAFLEX)
90433>>>                Error "Not implemented yet! The select statement has not been finalized."
90434>>>>
90434>>>//                Move () to sSelect
90434>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90434>>>                Case Break
90435>>>
90435>>>            Case Else
90435>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
90436>>>>
90436>>>                Case Break
90437>>>        Case End
90437>>>
90437>>>        Move (SizeOfArray(sReturnArray)) to iSize
90438>>>        Decrement iSize
90439>>>        For iCount from 0 to iSize
90445>>>>
90445>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
90447>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
90448>>>            End
90448>>>>
90448>>>        Loop
90449>>>>
90449>>>
90449>>>        Function_Return sReturnArray2
90450>>>    End_Function
90451>>>
90451>>>    // Returns a string array with all table names the passed table handle has relation ships with.
90451>>>    // The format of the array is "TableName.FieldName"
90451>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
90453>>>        String[] sFileNameArray sFieldNameArray
90455>>>        tSQLRelation[] sRelationsArray
90455>>>        tSQLRelation[] sRelationsArray
90456>>>        String sConnectionString sSelect sSchema sFileName sFieldName
90456>>>        Boolean bOK
90456>>>        Integer iCount iSize iLength
90456>>>
90456>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90457>>>        If (bOK = False) Begin
90459>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90460>>>>
90460>>>            Function_Return sRelationsArray
90461>>>        End
90461>>>>
90461>>>
90461>>>        Get psConnectionString to sConnectionString
90462>>>        Get psSchema to sSchema
90463>>>
90463>>>        Case Begin
90463>>>            Case (sDriverID = MSSQLDRV_ID)
90465>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
90466>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
90467>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90468>>>                Case Break
90469>>>
90469>>>            Case (sDriverID = DB2_DRV_ID)
90472>>>                Error "Not implemented yet! The select statement has not been finalized."
90473>>>>
90473>>>//                Move () to sSelect
90473>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90473>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90473>>>                Case Break
90474>>>
90474>>>            Case (sDriverID = SQLFLEX)
90477>>>                Error "Not implemented yet! The select statement has not been finalized."
90478>>>>
90478>>>//                Move () to sSelect
90478>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90478>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90478>>>                Case Break
90479>>>
90479>>>            Case (sDriverID = MDSMySQL)
90482>>>                Error "Not implemented yet! The select statement has not been finalized."
90483>>>>
90483>>>//                Move () to sSelect
90483>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90483>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90483>>>                Case Break
90484>>>
90484>>>            Case (sDriverID = MDSPgSQL)
90487>>>                Error "Not implemented yet! The select statement has not been finalized."
90488>>>>
90488>>>//                Move () to sSelect
90488>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90488>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90488>>>                Case Break
90489>>>
90489>>>            Case (sDriverID = ORAFLEX)
90492>>>                Error "Not implemented yet! The select statement has not been finalized."
90493>>>>
90493>>>//                Move () to sSelect
90493>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90493>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90493>>>                Case Break
90494>>>
90494>>>            Case Else
90494>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
90495>>>>
90495>>>                Case Break
90496>>>        Case End
90496>>>
90496>>>        Move (Length(sTableName)) to iLength
90497>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
90498>>>        Move (SizeOfArray(sFileNameArray)) to iSize
90499>>>        Decrement iSize
90500>>>        For iCount from 0 to iSize
90506>>>>
90506>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
90508>>>                Move sFileNameArray[iCount]         to sFileName
90509>>>                Move sFieldNameArray[iCount]        to sFieldName
90510>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
90511>>>                Move sFileName  to sRelationsArray[iCount].sFileName
90512>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
90513>>>            End
90513>>>>
90513>>>        Loop
90514>>>>
90514>>>
90514>>>        Function_Return sRelationsArray
90515>>>    End_Function
90516>>>
90516>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
90518>>>        tSQLLoggedInUser[] SQLLoggedInUser
90518>>>        tSQLLoggedInUser[] SQLLoggedInUser
90519>>>        String[] sUsers sPrograms
90521>>>        String sSelect
90521>>>        Integer iSize iCount
90521>>>
90521>>>        Case Begin
90521>>>            Case (sDriverID = MSSQLDRV_ID)
90523>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
90524>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
90525>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
90526>>>                Case Break
90527>>>            Case (sDriverID = SQLFLEX)
90530>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
90531>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
90532>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
90533>>>                Case Break
90534>>>            Case Else
90534>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
90535>>>>
90535>>>        Case End
90535>>>
90535>>>        Move (SizeOfArray(sUsers)) to iSize
90536>>>        Decrement iSize
90537>>>        For iCount from 0 to iSize
90543>>>>
90543>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
90544>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
90545>>>        Loop
90546>>>>
90546>>>
90546>>>        Function_Return SQLLoggedInUser
90547>>>    End_Function
90548>>>
90548>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
90548>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
90548>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
90550>>>        String[] sFilesData
90551>>>        Boolean bExists
90551>>>        Integer iCh
90551>>>        String sFileName sExt
90551>>>
90551>>>        Get vFolderExists sDataPath to bExists
90552>>>        If (bExists = True) Begin
90554>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
90555>>>            Move ("dir:" + sDataPath)      to sDataPath
90556>>>            Get Seq_New_Channel to iCh  // get free channel for input
90557>>>            Direct_Input channel iCh sDataPath
90559>>>                Repeat
90559>>>>
90559>>>                    Readln channel iCh sFileName
90561>>>                    Get ParseFileExtension sFileName to sExt
90562>>>                    If (Uppercase(sExt) = "INT") Begin
90564>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
90566>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
90567>>>                        End
90567>>>>
90567>>>                    End
90567>>>>
90567>>>                Until (SeqEof = True)
90569>>>            Close_Input channel iCh
90571>>>            Send Seq_Release_Channel iCh
90572>>>        End
90572>>>>
90572>>>        Function_Return sFilesData
90573>>>    End_Function
90574>>>
90574>>>    // Only done for MSSQLDRV_ID so far...
90574>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
90576>>>        Boolean bMertechDriver
90576>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
90576>>>        String sDescription sFrom sSys sValue sPrevious
90576>>>        Handle hStmt hoSQLManager hoSQLConnect
90576>>>        Integer iFetchResult iRows iColumn iPos
90576>>>        tSQLConnection SQLConnection
90576>>>        tSQLConnection SQLConnection
90576>>>        String[] asCollations
90577>>>        
90577>>>        If (sDriverID = "") Begin
90579>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
90580>>>>
90580>>>            Function_Return asCollations
90581>>>        End
90581>>>>
90581>>>
90581>>>        // Only done for MSSQLDRV_ID so far...
90581>>>        If (sDriverID <> MSSQLDRV_ID) Begin
90583>>>            Function_Return asCollations
90584>>>        End                 
90584>>>>
90584>>>
90584>>>        Get IsMertechDriver sDriverID to bMertechDriver
90585>>>        If (bMertechDriver = False) Begin
90587>>>            Get phoSQLManager to hoSQLManager
90588>>>        End
90588>>>>
90588>>>        Else Begin
90589>>>            Get _MertechSQLManagerHandle to hoSQLManager
90590>>>        End
90590>>>>
90590>>>
90590>>>        Get psConnectionID     to sConnectionID
90591>>>        Get psConnectionString to sConnectionString
90592>>>        Move 0 to LastErr
90593>>>
90593>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90594>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
90595>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90596>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
90598>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
90599>>>>
90599>>>            Function_Return asCollations
90600>>>        End
90600>>>>
90600>>>
90600>>>        Get SqlOpen of hoSQLConnect to hStmt
90601>>>
90601>>>        If (hStmt = 0) Begin
90603>>>            Send SqlDisconnect of hoSQLManager
90604>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
90605>>>>
90605>>>            Function_Return asCollations
90606>>>        End
90606>>>>
90606>>>
90606>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
90607>>>        Get _SqlFindKeyWord CI_SQLName        to sName
90608>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
90609>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
90610>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
90611>>>
90611>>>        // MS-SQL Syntax:  
90611>>>        // SELECT name, description
90611>>>        //   from sys.fn_helpcollations();
90611>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
90612>>>
90612>>>        Move 1 to iColumn
90613>>>        Send SqlExecDirect of hStmt sSQL
90614>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
90615>>>        Repeat
90615>>>>
90615>>>            Get SQLFetch of hStmt to iFetchResult
90616>>>            If (iFetchResult <> 0) Begin
90618>>>                Get SQLColumnValue of hStmt iColumn to sValue 
90619>>>                If (sValue <> sPrevious) Begin         
90621>>>                    // We need to skip all collations starting with "SQL" because they
90621>>>                    // are obsolete and for pre-SQL Server 2000.
90621>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
90622>>>                    If (iPos <> 1) Begin
90624>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
90625>>>                    End
90625>>>>
90625>>>                End
90625>>>>
90625>>>                Move sValue to sPrevious
90626>>>            End
90626>>>>
90626>>>        Until (iFetchResult = 0)
90628>>>        Send SQLClose of hStmt
90629>>>        Send SQLDisconnect of hoSQLConnect
90630>>>
90630>>>        Function_Return asCollations
90631>>>    End_Function
90632>>>
90632>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90632>>>    // for DAW drivers.
90632>>>    // Returns: A string array.
90632>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
90634>>>        String[] sReturnArray
90635>>>        String sValue sPrevious
90635>>>        Handle hoSQLHandler hoSQLConnect hstmt
90635>>>        Integer iFetchResult iRows
90635>>>        tSQLConnection SQLConnection
90635>>>        tSQLConnection SQLConnection
90635>>>
90635>>>        Get phoSQLManager to hoSQLHandler
90636>>>
90636>>>        If (hoSQLHandler <> 0) Begin
90638>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90639>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90640>>>
90640>>>            If (hoSQLConnect <> 0) Begin
90642>>>                Get SQLOpen of hoSQLConnect to hstmt
90643>>>                If (hstmt <> 0) Begin
90645>>>                    Send SqlExecDirect of hstmt sStmt
90646>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
90647>>>                    Repeat
90647>>>>
90647>>>                        Get SQLFetch of hstmt to iFetchResult
90648>>>                        If (iFetchResult <> 0) Begin
90650>>>                            Get SQLColumnValue of hstmt iColumn to sValue
90651>>>                            If (sValue <> sPrevious) Begin
90653>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90654>>>                            End
90654>>>>
90654>>>                            Move sValue to sPrevious
90655>>>                        End
90655>>>>
90655>>>                    Until (iFetchResult = 0)
90657>>>                    Send SQLClose of hstmt
90658>>>                End
90658>>>>
90658>>>                Send SQLDisconnect of hoSQLConnect
90659>>>            End
90659>>>>
90659>>>        End
90659>>>>
90659>>>
90659>>>        Function_Return sReturnArray
90660>>>    End_Function
90661>>>
90661>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90661>>>    // for Mertech drivers.
90661>>>    // Returns: A string array.
90661>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
90663>>>        String[] sReturnArray
90664>>>        String sValue
90664>>>        Handle hoSQLHandler hoSQLConnect hStmt
90664>>>        Integer iFetchResult iRows
90664>>>        tSQLConnection SQLConnection
90664>>>        tSQLConnection SQLConnection
90664>>>
90664>>>        Get _MertechSQLManagerHandle to hoSQLHandler
90665>>>
90665>>>        If (hoSQLHandler <> 0) Begin
90667>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90668>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
90669>>>
90669>>>            If (hoSQLConnect <> 0) Begin
90671>>>                Get SQLOpen of hoSQLConnect to hStmt
90672>>>                If (hStmt <> 0) Begin
90674>>>                    Send SqlExecDirect of hStmt sStmt
90675>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
90676>>>                    Repeat
90676>>>>
90676>>>                        Get SQLFetch of hStmt to iFetchResult
90677>>>                        If (iFetchResult <> 0) Begin
90679>>>                            Get SQLColumnValue of hStmt 1 to sValue
90680>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90681>>>                        End
90681>>>>
90681>>>                    Until (iFetchResult = 0)
90683>>>                    Send SQLClose of hStmt
90684>>>                End
90684>>>>
90684>>>                Send SQLDisconnect of hoSQLConnect
90685>>>            End
90685>>>>
90685>>>        End
90685>>>>
90685>>>
90685>>>        Function_Return sReturnArray
90686>>>    End_Function
90687>>>
90687>>>    // * Dummy function for the Studio's Code Explorer *
90687>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
90689>>>        Function_Return False
90690>>>    End_Function
90691>>>
90691>>>    // Returns the index for the passed sTableName
90691>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
90691>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
90693>>>        Integer iIndex iSize iCount
90693>>>        String[] sTablesArray
90694>>>        String sDatabase sSchema sVal sConnectionString
90694>>>
90694>>>        Move -1 to iIndex
90695>>>        Get psConnectionString to sConnectionString
90696>>>        Get psDatabase to sDatabase
90697>>>        Get psSchema   to sSchema
90698>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
90699>>>        Move (SizeOfArray(sTablesArray)) to iSize
90700>>>        Decrement iSize
90701>>>        For iCount from 0 to iSize
90707>>>>
90707>>>            Move sTablesArray[iCount] to sVal
90708>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
90710>>>                Move iCount to iIndex // We found it!
90711>>>                Move iSize to iCount  // End the loop
90712>>>            End
90712>>>>
90712>>>        Loop
90713>>>>
90713>>>
90713>>>        Function_Return iIndex
90714>>>    End_Function
90715>>>
90715>>>    // Helper function that builds a string like;
90715>>>    // "SELECT name from [Master].[sys].[databases] where name"
90715>>>    Function _SqlSelectFromWhereName Returns String
90717>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
90717>>>
90717>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
90718>>>        Get _SqlFindKeyWord CI_SQLName         to sName
90719>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
90720>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
90721>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
90722>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
90723>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
90724>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
90725>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
90726>>>        Function_Return sRetval
90727>>>    End_Function
90728>>>
90728>>>    // Helper function to create a SQL statement like;
90728>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
90728>>>    // Used for checking if an index exists.
90728>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
90730>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
90730>>>
90730>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
90731>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
90732>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
90733>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
90734>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
90735>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
90736>>>        Get _SqlFindKeyWord CI_SQLName to sName
90737>>>
90737>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
90738>>>
90738>>>        Function_Return sRetval
90739>>>    End_Function
90740>>>
90740>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
90740>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
90740>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
90742>>>        String sRetval
90742>>>        If (iLength <> 0) Begin
90744>>>            Move ("(" + String(iLength)) to sRetval
90745>>>            If (iDecimals <> 0) Begin
90747>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
90748>>>            End
90748>>>>
90748>>>            Move (sRetval + ")") to sRetval
90749>>>        End
90749>>>>
90749>>>        Function_Return sRetval
90750>>>    End_Function
90751>>>
90751>>>    Procedure _SqlColumnInfo Handle hoStmt
90753>>>        Integer i iCols iItem
90753>>>        tSqlColumnNew[] aQueryColumns
90753>>>        tSqlColumnNew[] aQueryColumns
90754>>>
90754>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
90755>>>        For i from 1 to iCols
90761>>>>
90761>>>            Move (SizeOfArray(aQueryColumns)) to iItem
90762>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
90763>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
90764>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
90765>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
90766>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
90767>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
90768>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
90769>>>        Loop
90770>>>>
90770>>>        Set piColumns to iCols
90771>>>        Set paQueryColumns to aQueryColumns
90772>>>    End_Procedure
90773>>>
90773>>>    // Checks that the passed sDriverID is defined.
90773>>>    // Also checks if the driver has been loaded; else it gets loaded.
90773>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
90775>>>        Boolean bOK
90775>>>        Integer iDriver
90775>>>
90775>>>        If (sDriverID = DATAFLEX_ID) Begin
90777>>>            Function_Return False
90778>>>        End
90778>>>>
90778>>>
90778>>>        Get IsDAWSQLDriver sDriverID to bOK
90779>>>
90779>>>        If (bOK = False) Begin
90781>>>            Get IsMertechDriver sDriverID to bOK
90782>>>        End
90782>>>>
90782>>>
90782>>>        If (bOK = False) Begin
90784>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
90785>>>>
90785>>>            Function_Return False
90786>>>        End
90786>>>>
90786>>>
90786>>>        Get DriverIndex sDriverID to iDriver
90787>>>        If (iDriver = 0) Begin
90789>>>            Load_Driver sDriverID
90790>>>        End
90790>>>>
90790>>>
90790>>>        Function_Return True
90791>>>    End_Function
90792>>>
90792>>>    // Checks that the length parameter has been passed correctly.
90792>>>    // This is only of concern for certain SQL data types.
90792>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
90794>>>        Integer iLength
90794>>>        Boolean bOK bCheckTypeLength
90794>>>
90794>>>        If (num_arguments > 1) Begin
90796>>>            Move iLen to iLength
90797>>>        End
90797>>>>
90797>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
90798>>>
90798>>>        If (bCheckTypeLength = True) Begin
90800>>>            Move (iLength > 0) to bOK
90801>>>        End
90801>>>>
90801>>>
90801>>>        Function_Return (bOK = True)
90802>>>    End_Function
90803>>>
90803>>>    Function _SqlProperTableName String sTableName Returns String
90805>>>        String sVal sSchema sDriverID
90805>>>        Integer iDbType
90805>>>
90805>>>        If (Trim(sTableName) = "") Begin
90807>>>            Function_Return ""
90808>>>        End
90808>>>>
90808>>>
90808>>>        Get psDriverID to sDriverID
90809>>>        Get piDbType   to iDbType
90810>>>        If (iDbType = EN_dbTypeOracle) Begin
90812>>>            Get psUserID to sSchema
90813>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
90813>>>            Move (Uppercase(sSchema)) to sSchema
90814>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
90815>>>            Function_Return sTableName
90816>>>        End
90816>>>>
90816>>>        If (iDbType = EN_DbTypeMySQL) Begin
90818>>>            Get psDatabase to sVal
90819>>>            Move (sVal + "." + sTableName) to sTableName
90820>>>            Function_Return sTableName
90821>>>        End
90821>>>>
90821>>>        If (iDbType = EN_DbTypePostgre) Begin
90823>>>            Move ('"' + sTableName + '"') to sTableName
90824>>>            Function_Return sTableName
90825>>>        End
90825>>>>
90825>>>
90825>>>        Get psSchema to sSchema
90826>>>        If (sSchema = "") Begin
90828>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90829>>>        End
90829>>>>
90829>>>
90829>>>        Move (Uppercase(sTableName)) to sVal
90830>>>        If (not(sVal contains (sSchema + "."))) Begin
90832>>>            If (iDbType = EN_dbTypeDB2) Begin
90834>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
90835>>>            End
90835>>>>
90835>>>            Else Begin
90836>>>                Move (sSchema + "." + sTableName) to sTableName
90837>>>            End
90837>>>>
90837>>>        End
90837>>>>
90837>>>
90837>>>        Function_Return sTableName
90838>>>    End_Function
90839>>>
90839>>>    // SQL column names can be case-sensitive. This function is used to check that
90839>>>    // the passed sFieldName has the correct spelling.
90839>>>    // Used with Embedded SQL statement calls.
90839>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
90839>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
90841>>>        String sRetval sValue sDriverID
90841>>>        String[] sColumnNamesArray
90842>>>        Integer iCount iColumns
90842>>>
90842>>>        Move "" to sRetval
90843>>>        Get psDriverID to sDriverID
90844>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
90845>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
90846>>>        Decrement iColumns
90847>>>
90847>>>        For iCount from 0 to iColumns
90853>>>>
90853>>>            Move sColumnNamesArray[iCount] to sValue
90854>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
90856>>>                Move sValue to sRetval
90857>>>                Move iColumns to iCount // We're done.
90858>>>            End
90858>>>>
90858>>>        Loop
90859>>>>
90859>>>
90859>>>        Function_Return sRetval
90860>>>    End_Function
90861>>>
90861>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
90863>>>        String[] sReturnArray
90864>>>        Handle hoSQLHandler
90864>>>        Integer iCount iSize iItem
90864>>>        String sServer
90864>>>        tSQLConnection SQLConnection
90864>>>        tSQLConnection SQLConnection
90864>>>
90864>>>        Get phoMSSQLHandler to hoSQLHandler
90865>>>        Send Delete_Data    of hoSQLHandler
90866>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
90867>>>
90867>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90868>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
90869>>>        Decrement iSize
90870>>>
90870>>>        For iCount from 0 to iSize
90876>>>>
90876>>>            Get String_Value of hoSQLHandler iCount to sServer
90877>>>            Move (Trim(sServer)) to sReturnArray[iItem]
90878>>>            Increment iItem
90879>>>        Loop
90880>>>>
90880>>>
90880>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90881>>>
90881>>>        Function_Return sReturnArray
90882>>>    End_Function
90883>>>
90883>>>    Function _SqlTableArrayDAW Returns String[]
90885>>>        String[] sReturnArray
90886>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
90886>>>        Handle hoSQLHandler
90886>>>        Integer iCount iSize iItem iPos
90886>>>        Boolean bOK
90886>>>        tSQLConnection SQLConnection
90886>>>        tSQLConnection SQLConnection
90886>>>
90886>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90887>>>        If (SQLConnection.sConnectionString = "") Begin
90889>>>            Function_Return sReturnArray
90890>>>        End
90890>>>>
90890>>>
90890>>>        Move SQLConnection.sSchema      to sDefSchema
90891>>>        Move (Uppercase(sDefSchema))    to sDefSchema
90892>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
90893>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
90894>>>
90894>>>        Get phoCLIHandler to hoSQLHandler
90895>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
90896>>>        Send Delete_Data  of hoSQLHandler
90897>>>
90897>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90898>>>        Move SQLConnection.sConnectionString to sConnectionString
90899>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
90899>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
90899>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
90899>>>//                Move (Pos(";", sConnectionString)) to iPos
90899>>>//                If (iPos > 0) Begin
90899>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
90899>>>//                    Move (Trim(sConnectionString)) to sConnectionString
90899>>>//                End
90899>>>//            End
90899>>>//        End
90899>>>
90899>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
90900>>>        Move False to Err
90901>>>        Move 0 to iItem
90902>>>
90902>>>        // Note that the enumeration starts from table no 1. (not zero)
90902>>>        for iCount from 1 to iSize
90908>>>>
90908>>>            Get TableName    of hoSQLHandler iCount to sTable
90909>>>            Get TableType    of hoSQLHandler iCount to sTableType
90910>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
90911>>>            If (sSchema = "") Begin
90913>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
90914>>>            End
90914>>>>
90914>>>            Get TableComment of hoSQLHandler iCount to sComment
90915>>>            Move (Trim(sTable)) to sTable
90916>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
90918>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
90919>>>            End
90919>>>>
90919>>>            Else Begin
90920>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
90921>>>            End
90921>>>>
90921>>>            If (bOK = True) Begin
90923>>>                Move sTable to sReturnArray[iItem]
90924>>>                Increment iItem
90925>>>            End
90925>>>>
90925>>>        Loop
90926>>>>
90926>>>
90926>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90927>>>
90927>>>        Function_Return sReturnArray
90928>>>    End_Function
90929>>>
90929>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
90931>>>        String[] sReturnArray
90932>>>        String sValue
90932>>>        Handle hoSQLHandler hoSQLConnect hStmt
90932>>>        Integer iRetval iCols iFetchResult
90932>>>        tSQLConnection SQLConnection
90932>>>        tSQLConnection SQLConnection
90932>>>
90932>>>        Get phoSQLManager to hoSQLHandler
90933>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90934>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90935>>>
90935>>>        If (hoSQLConnect <> 0) Begin
90937>>>            Get SqlOpen of hoSQLConnect to hStmt
90938>>>            If (hStmt <> 0) Begin
90940>>>                Send SqlSetProcedurename of hStmt sStmt
90941>>>                If (sArgument <> "") Begin
90943>>>                    Send SqlSetArgument  of hStmt 1 sArgument
90944>>>                End
90944>>>>
90944>>>
90944>>>                Send SqlCall             of hStmt
90945>>>                Get SqlReturnValue       of hStmt to iRetval
90946>>>                If (iRetval = 0) Begin
90948>>>                    Repeat
90948>>>>
90948>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
90949>>>                        If (iCols > 0) Begin
90951>>>                            Repeat
90951>>>>
90951>>>                                Get SqlFetch of hStmt to iFetchResult
90952>>>                                If (iFetchResult <> 0) Begin
90954>>>                                    Get SqlColumnValue of hStmt 1 to sValue
90955>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
90956>>>                                End
90956>>>>
90956>>>                            Until (iFetchResult = 0)
90958>>>                        End
90958>>>>
90958>>>                        Get SqlNextResultSet of hStmt to iRetval
90959>>>                    Until (iRetval = 0)
90961>>>                    Send SqlClose of hStmt
90962>>>                End
90962>>>>
90962>>>            End
90962>>>>
90962>>>            Send SqlDisconnect of hoSQLConnect
90963>>>        End
90963>>>>
90963>>>        Function_Return sReturnArray
90964>>>    End_Function
90965>>>
90965>>>    Function _SqlDatabasesArrayDB2 Returns String[]
90967>>>        String[] sReturnArray
90968>>>        String sDataSource
90968>>>        Handle hoSQLHandler
90968>>>        Integer iItem
90968>>>
90968>>>        Get phoDB2SQLHandler to hoSQLHandler
90969>>>        Send SeedDataSources of hoSQLHandler
90970>>>
90970>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90971>>>
90971>>>        Repeat
90971>>>>
90971>>>            Get DataSources of hoSQLHandler to sDataSource
90972>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
90973>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
90974>>>            Increment iItem
90975>>>        Until (sDataSource = "")
90977>>>
90977>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90978>>>
90978>>>        Function_Return sReturnArray
90979>>>    End_Function
90980>>>
90980>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
90982>>>        String[] sReturnArray
90983>>>        String sDataSource
90983>>>        Handle hoSQLHandler
90983>>>        Integer iItem
90983>>>
90983>>>        Get phoODBCSQLHandler to hoSQLHandler
90984>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90985>>>
90985>>>        Send SeedDataSources of hoSQLHandler
90986>>>
90986>>>        Repeat
90986>>>>
90986>>>            Get DataSources of hoSQLHandler to sDataSource
90987>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
90989>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
90990>>>                Increment iItem
90991>>>            End
90991>>>>
90991>>>        Until (sDataSource = "")
90993>>>
90993>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90994>>>
90994>>>        Function_Return sReturnArray
90995>>>    End_Function
90996>>>
90996>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
90998>>>        String[] sDataSources
90999>>>        tSQLConnection SQLConnection
90999>>>        tSQLConnection SQLConnection
90999>>>        tSQLIntTableInfo[] sReturnArray
90999>>>        tSQLIntTableInfo[] sReturnArray
91000>>>        Integer iDataSources iCount iItem
91000>>>        String sConnection sServer sDatabase sKey sSubKey
91000>>>        Handle hoIniFile hoRegistry hoODBCDataSources
91000>>>        Boolean bExists bKeyOpened
91000>>>
91000>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91001>>>        Move SQLConnection.sConnectionString to sConnection
91002>>>        Move SQLConnection.sServer           to sServer
91003>>>
91003>>>        // FileDSN - read DATABASE name from DSN ini-file
91003>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
91005>>>            Get Create (RefClass(cIniFile)) to hoIniFile
91006>>>            Set psFileName of hoIniFile to sServer
91007>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
91008>>>            Move sDatabase to sReturnArray[0].sDatabaseName
91009>>>            Send Destroy of hoIniFile
91010>>>        End
91010>>>>
91010>>>
91010>>>        // DSN - read DATABASE name from the registry
91010>>>        Else Begin
91011>>>            Get Create (RefClass(cRegistry)) to hoRegistry
91012>>>
91012>>>            // We start with checking the "System DNS" area in the registry as it is the
91012>>>            // most probably place the info is kept that we're after.
91012>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91013>>>            Set pfAccessRights of hoRegistry to Key_Read
91014>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
91015>>>            If (bExists = True) Begin
91017>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
91018>>>            End
91018>>>>
91018>>>            Else Begin
91019>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
91020>>>            End
91020>>>>
91020>>>
91020>>>            Get KeyExists of hoRegistry sKey to bExists
91021>>>            If (bExists) Begin
91023>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
91024>>>                If (bKeyOpened) Begin
91026>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
91027>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
91028>>>                    If (iDataSources > 0) Begin
91030>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
91031>>>                        Decrement iDataSources
91032>>>                        for iCount from 0 to iDataSources
91038>>>>
91038>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
91039>>>                        Loop
91040>>>>
91040>>>                        Move 0 to iItem
91041>>>                        for iCount from 0 to iDataSources
91047>>>>
91047>>>                            Move sDataSources[iCount] to sSubKey
91048>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
91049>>>                            If (bKeyOpened = True) Begin
91051>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
91052>>>                                If (bExists = True) Begin
91054>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
91055>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
91056>>>                                    Increment iItem
91057>>>                                End
91057>>>>
91057>>>                            End
91057>>>>
91057>>>                        Loop
91058>>>>
91058>>>                    End
91058>>>>
91058>>>                    Send CloseKey of hoRegistry
91059>>>                    Send Destroy of hoODBCDataSources
91060>>>                End
91060>>>>
91060>>>            End
91060>>>>
91060>>>
91060>>>            // We then check the "User DNS" area in the registry.
91060>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
91061>>>            Set pfAccessRights of hoRegistry to Key_Read
91062>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
91063>>>            Get KeyExists of hoRegistry sKey to bExists
91064>>>
91064>>>            If (bExists) Begin
91066>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
91067>>>                If (bKeyOpened) Begin
91069>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
91070>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
91071>>>                    If (iDataSources > 0) Begin
91073>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
91074>>>                        Decrement iDataSources
91075>>>                        for iCount from 0 to iDataSources
91081>>>>
91081>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
91082>>>                        Loop
91083>>>>
91083>>>                        for iCount from 0 to iDataSources
91089>>>>
91089>>>                            Move sDataSources[iCount] to sSubKey
91090>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
91091>>>                            If (bKeyOpened = True) Begin
91093>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
91094>>>                                If (bExists = True) Begin
91096>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
91097>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
91098>>>                                    Increment iItem
91099>>>                                End
91099>>>>
91099>>>                            End
91099>>>>
91099>>>                        Loop
91100>>>>
91100>>>                    End
91100>>>>
91100>>>                    Send CloseKey of hoRegistry
91101>>>                    Send Destroy of hoODBCDataSources
91102>>>                End
91102>>>>
91102>>>            End
91102>>>>
91102>>>
91102>>>            Send Destroy of hoRegistry
91103>>>        End
91103>>>>
91103>>>
91103>>>        Function_Return sReturnArray
91104>>>    End_Function
91105>>>
91105>>>    // We might have a split Sql script where the info about which database to use is
91105>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
91105>>>    // insert it for scriplets to come after the first one.
91105>>>    Function _SqlFormatStatement String sStmt Returns String
91107>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
91107>>>        Integer iStart iEnd iDbType
91107>>>        Boolean bOK
91107>>>
91107>>>        Get piDbType to iDbType
91108>>>        Get psDriverID to sDriverID
91109>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
91110>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
91111>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
91112>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
91113>>>        Move (Replaces(" ", sStmt, "")) to sTmp
91114>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
91116>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
91117>>>            Move (Pos("]", sTmp)) to iEnd
91118>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
91119>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
91120>>>            Set Private.psUseDatabase to sUseDatabase
91121>>>        End
91121>>>>
91121>>>        Else Begin
91122>>>            Move (Uppercase(sStmt)) to sTmp
91123>>>
91123>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
91123>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
91125>>>                Get Private.psUseDatabase to sUseDatabase
91126>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
91127>>>            End
91127>>>>
91127>>>
91127>>>            // This is a bit special to place here but was done so because it was easier that way.
91127>>>            // We will get an error when trying to create a view if it already exists.
91127>>>            // So to avoid such errors; we first remove it & then recreate it.
91127>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
91130>>>                // Make sure we only have one space between statements/words.
91130>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
91131>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
91132>>>                Move (Trim(sTmp)) to sTmp
91133>>>                Move (Pos(" ", sTmp)) to iEnd
91134>>>                Move (Left(sTmp, iEnd)) to sTmp
91135>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
91137>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
91138>>>                End
91138>>>>
91138>>>                Move (Trim(sTmp)) to sTmp
91139>>>                // Remove data view as it already exists!
91139>>>                Get SqlViewRemove sDriverID sTmp to bOK
91140>>>            End
91140>>>>
91140>>>        End
91140>>>>
91140>>>
91140>>>        Function_Return sStmt
91141>>>    End_Function
91142>>>
91142>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
91142>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
91144>>>        String sRetval
91144>>>        Integer iDbType iIndex
91144>>>        tSQLKeyWords[] SQLKeywordArray
91144>>>        tSQLKeyWords[] SQLKeywordArray
91145>>>        tSQLKeyWords   SQLKeyWords
91145>>>        tSQLKeyWords   SQLKeyWords
91145>>>
91145>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
91145>>>        Move "" to sRetval
91146>>>        Get piDbType to iDbType
91147>>>        Move iDbType             to SQLKeyWords.iSQLDbType
91148>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
91149>>>
91149>>>        Get paSQLKeywordArray to SQLKeywordArray
91150>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
91151>>>        If (iIndex >= 0) Begin
91153>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
91154>>>        End
91154>>>>
91154>>>
91154>>>        Function_Return sRetval
91155>>>    End_Function
91156>>>
91156>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
91156>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
91158>>>        String[] sSQLScriptArray
91159>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
91159>>>        Integer iSize iCount
91159>>>        Boolean bCommentStart bCommentEnd bDashComment
91159>>>
91159>>>        Move False to bCommentStart
91160>>>        Move False to bCommentEnd
91161>>>        Move False to bDashComment
91162>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
91163>>>        Move "*/"  to sCommentEnd
91164>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
91165>>>
91165>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
91166>>>        Decrement iSize
91167>>>        Move "" to sText
91168>>>
91168>>>        For iCount from 0 to iSize
91174>>>>
91174>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
91175>>>            Move (Trim(sLine)) to sTmp
91176>>>            If (sTmp <> "") Begin
91178>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
91179>>>                If (bCommentStart = False) Begin
91181>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
91182>>>                    If (bCommentStart = False) Begin
91184>>>                    End
91184>>>>
91184>>>                End
91184>>>>
91184>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
91185>>>                If (bCommentEnd = True) Begin
91187>>>                    Move False to bCommentStart
91188>>>                End
91188>>>>
91188>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
91190>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
91191>>>                End
91191>>>>
91191>>>            End
91191>>>>
91191>>>        Loop
91192>>>>
91192>>>
91192>>>        // Update the retval struct array:
91192>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
91193>>>        Function_Return SqlScriptArray
91194>>>    End_Function
91195>>>
91195>>>
91195>>>    // *** Database API Functions: ***
91195>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
91195>>>    // make changes/updates to the database.
91195>>>
91195>>>    // * Dummy function for the Studio's Code Explorer *
91195>>>    Function API_TABLE_FUNCTIONS Returns Boolean
91197>>>        Function_Return False
91198>>>    End_Function
91199>>>
91199>>>    // This might not do what you think - Here's what it does:
91199>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
91199>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
91199>>>    // to the SQL table.
91199>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
91199>>>    // already exists in SQL.
91199>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
91199>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
91199>>>    // restructuring an existing table.
91199>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
91201>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
91201>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
91201>>>        Handle hToTable
91201>>>
91201>>>        Move True to bUseConnectionID
91202>>>        If (num_arguments > 1) Begin
91204>>>            Move bUseConnID to bUseConnectionID
91205>>>        End
91205>>>>
91205>>>
91205>>>        Get psDriverID to sDriverID
91206>>>        // If the table doesn't exist on the SQL back-end we do nothing.
91206>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91207>>>        If (bExists = False) Begin
91209>>>            Function_Return False
91210>>>        End
91210>>>>
91210>>>
91210>>>        Get UtilTableIsAlias hTable to bIsAlias
91211>>>
91211>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91212>>>        If (bOK = False) Begin
91214>>>            Function_Return False
91215>>>        End
91215>>>>
91215>>>
91215>>>        // Then we need to check that the function hasn't been called before; which in case
91215>>>        // we do nothing
91215>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
91216>>>        If (bExists = True) Begin
91218>>>            Function_Return False
91219>>>        End
91219>>>>
91219>>>
91219>>>        Get psConnectionID     to sConnectionID
91220>>>        Get psConnectionString to sConnectionString
91221>>>        If (sConnectionID = "" or sConnectionString = "") Begin
91223>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
91224>>>>
91224>>>            Function_Return False
91225>>>        End
91225>>>>
91225>>>
91225>>>        Set Private.phCurrentTable to hTable
91226>>>        Get psSchema to sSchema
91227>>>        If (sSchema = "") Begin
91229>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91230>>>        End
91230>>>>
91230>>>
91230>>>        Get IsMertechDriver sDriverID to bMertechDriver
91231>>>
91231>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
91231>>>        // was a programmer's error and we adjust for it here.
91231>>>        If (bMertechDriver = True) Begin
91233>>>            Move False to bUseConnectionID
91234>>>        End
91234>>>>
91234>>>
91234>>>        // If we should use a connection id we need to check it exists;
91234>>>        // else we create it before attempting creating the table
91234>>>        If (bUseConnectionID = True) Begin
91236>>>            Get AutoConnectionIDLogin to bOK
91237>>>            If (bOk = False) Begin
91239>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
91240>>>>
91240>>>                Function_Return False
91241>>>            End
91241>>>>
91241>>>        End
91241>>>>
91241>>>
91241>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91244>>>        Get _TableNameOnly sRootName to sRootName
91245>>>        If (sRootName = "") Begin
91247>>>            Function_Return False
91248>>>        End
91248>>>>
91248>>>        Move (sRootName + ".int")                    to sPhysicalName
91249>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91252>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91255>>>
91255>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
91255>>>        //
91255>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
91255>>>        // because then the table should not be visible to users.
91255>>>//        Move (Pos("@", sDisplayName)) to iPos
91255>>>//        If (iPos <> 1) Begin
91255>>>//            If (sDisplayName contains ".") Begin
91255>>>//                Move (Pos(".", sDisplayName)) to iPos
91255>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
91255>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
91255>>>//            End
91255>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
91255>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
91255>>>//            End
91255>>>//        End
91255>>>
91255>>>        If (bIsAlias = False) Begin
91257>>>            Get OpenTableExclusive hTable to bOpened
91258>>>            If (bOpened = False) Begin
91260>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
91261>>>>
91261>>>                Function_Return False
91262>>>            End
91262>>>>
91262>>>        End
91262>>>>
91262>>>
91262>>>        If (ghoProgressBar <> 0) Begin
91264>>>            Send DoAdvance of ghoProgressBar
91265>>>            Set Message_Text of ghoStatusPanel to ""
91266>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
91267>>>        End
91267>>>>
91267>>>        // Note: The hToTable will get changed by the Structure_xxx command...
91267>>>        Move hTable to hToTable
91268>>>        Move False to Err
91269>>>
91269>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
91269>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
91269>>>        // a proper and updated .int file.
91269>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
91272>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
91273>>>
91273>>>        If (bIsAlias = False) Begin
91275>>>            Structure_Start hToTable sDriverID
91276>>>                Set Private.phCurrentTable to hTable
91277>>>                If (bUseConnectionID = True) Begin
91279>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
91282>>>                End
91282>>>>
91282>>>                Else Begin
91283>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
91286>>>                End
91286>>>>
91286>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
91289>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
91289>>>                Move False to Err
91290>>>                Move 0 to LastErr
91291>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91292>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91294>>>            Set Action_Text of ghoStatusPanel to ""
91295>>>        End
91295>>>>
91295>>>
91295>>>        Move (not(Err)) to bOK
91296>>>        If (bOK = True) Begin
91298>>>            // The attributes set above will always trigger an error
91298>>>            // We also adjust the Filelist entries
91298>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
91301>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91304>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91307>>>
91307>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
91307>>>            Get SqlUtilUpdateIntFile hTable to bOK
91308>>>        End
91308>>>>
91308>>>
91308>>>        Function_Return (bOK = True)
91309>>>    End_Function
91310>>>
91310>>>    // Sample usage:
91310>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
91310>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
91310>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
91312>>>        Boolean bOK bIsSQLTable
91312>>>
91312>>>        Get AutoConnectionIDLogin to bOK
91313>>>        Move False to Err
91314>>>        Get OpenTableExclusive hTable to bOK
91315>>>        If (bOK = False) Begin
91317>>>            Function_Return False
91318>>>        End
91318>>>>
91318>>>
91318>>>        // ToDo: Add to all table change functions!
91318>>>            Get UtilTableIsSQL hTable to bIsSQLTable
91319>>>            If (bIsSQLTable = True) Begin
91321>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
91324>>>            End
91324>>>>
91324>>>
91324>>>        Set Private.phCurrentTable to hTable
91325>>>        Structure_Start hTable
91326>>>            Set_Attribute iAttribute of hTable to iValue
91329>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91330>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91332>>>
91332>>>        Set Action_Text of ghoStatusPanel to ""
91333>>>        Function_Return (Err = False)
91334>>>    End_Function
91335>>>
91335>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
91337>>>        Boolean bOK
91337>>>        
91337>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
91338>>>        If (bOK = True) Begin
91340>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
91341>>>        End
91341>>>>
91341>>>        
91341>>>        Function_Return (bOK = True)
91342>>>    End_Function
91343>>>    
91343>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
91343>>>    // or to change the filelist slot names.
91343>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
91345>>>        String sFileListName
91345>>>        
91345>>>        Move False to Err
91346>>>
91346>>>        If (ghoProgressBar <> 0) Begin
91348>>>            Send DoAdvance of ghoProgressBar
91349>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
91350>>>        End
91350>>>>
91350>>>        // If all strings are empty it means that we should remove this entry from filelist.
91350>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
91352>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
91355>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
91358>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
91361>>>            Function_Return (Err = False) // And we're done.
91362>>>        End
91362>>>>
91362>>>
91362>>>        If (sDriverID <> DATAFLEX_ID) Begin
91364>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91364>>>            Move (sDriverID + ":" + sRootName) to sRootName
91365>>>        End
91365>>>>
91365>>>//        Else Begin
91365>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91365>>>//        End
91365>>>//
91365>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91365>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91365>>>
91365>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91368>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91371>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91374>>>        
91374>>>        Function_Return (Err = False)
91375>>>    End_Function
91376>>>
91376>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
91378>>>        Boolean bOK
91378>>>
91378>>>        Get AutoConnectionIDLogin to bOK
91379>>>        Move False to Err
91380>>>        Get OpenTableExclusive hTable to bOK
91381>>>        If (bOK = False) Begin
91383>>>            Function_Return False
91384>>>        End
91384>>>>
91384>>>
91384>>>        Set Private.phCurrentTable to hTable
91385>>>        Structure_Start hTable
91386>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
91389>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91390>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91392>>>
91392>>>        Set Action_Text of ghoStatusPanel to ""
91393>>>        Function_Return (Err = False)
91394>>>    End_Function
91395>>>
91395>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
91397>>>        Boolean bOK bIsSQLTable
91397>>>
91397>>>        Move False to Err
91398>>>        Get AutoConnectionIDLogin to bOK
91399>>>        Open hToTable
91401>>>        Get OpenTableExclusive hTable to bOK
91402>>>        If (bOK = False) Begin
91404>>>            Function_Return False
91405>>>        End
91405>>>>
91405>>>
91405>>>            Get UtilTableIsSQL hTable to bIsSQLTable
91406>>>            If (bIsSQLTable = True) Begin
91408>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
91411>>>            End
91411>>>>
91411>>>
91411>>>        Set Private.phCurrentTable to hTable
91412>>>        Structure_Start hTable
91413>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
91416>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
91419>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91420>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91422>>>
91422>>>        Set Action_Text of ghoStatusPanel to ""
91423>>>        Function_Return (Err = False)
91424>>>    End_Function
91425>>>
91425>>>    Procedure ApiTableConvertAllAddException Integer hTable
91427>>>        Integer[] aTableConvertExceptions
91428>>>        Get paTableConvertExceptions to aTableConvertExceptions
91429>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
91430>>>        Set paTableConvertExceptions to aTableConvertExceptions
91431>>>    End_Procedure
91432>>>
91432>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
91434>>>        Integer[] aTableDateCorrectionExceptions
91435>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91436>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
91437>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91438>>>    End_Procedure
91439>>>
91439>>>    Procedure ApiTableConvertALLToSql
91441>>>        Integer[] iTablesArray
91442>>>        Integer iSize iCount
91442>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
91442>>>        String sDriverID
91442>>>
91442>>>        Get psDriverID to sDriverID
91443>>>        Get pbUseConnectionID to bUseConnectionID
91444>>>        Get pbToANSI          to bToANSI
91445>>>        Get pbRecnum          to bRecnum
91446>>>        Get pbCopyData        to bCopyData
91447>>>        If (ghoDbUpdateHandler > 0) Begin
91449>>>            Get pbContinueOnError to bContinueOnError
91450>>>        End
91450>>>>
91450>>>
91450>>>        Get _AllTablesToConvert to iTablesArray
91451>>>        Move (SizeOfArray(iTablesArray)) to iSize
91452>>>        Set pbVisible   of ghoProgressBarOverall to True
91453>>>        Set piPosition  of ghoProgressBarOverall to 0
91454>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
91455>>>        Set piMaximum   of ghoProgressBarOverall to iSize
91456>>>
91456>>>        Decrement iSize
91457>>>        For iCount from 0 to iSize
91463>>>>
91463>>>            Set piPosition of ghoProgressBarOverall to iCount
91464>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
91465>>>            // Probably the right logic here is to just continue trying to convert every table even
91465>>>            // if there was an error converting one table...
91465>>>            //If (bContinueOnError = False and bOK = False) Break
91465>>>        Loop
91466>>>>
91466>>>
91466>>>    End_Procedure
91467>>>
91467>>>    Procedure ApiTableAttachALLToSql
91469>>>        Integer[] iTablesArray
91470>>>        Integer iSize iCount
91470>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
91470>>>        String sDriverID
91470>>>
91470>>>        Get psDriverID to sDriverID
91471>>>        Get pbUseConnectionID to bUseConnectionID
91472>>>        Get pbToANSI          to bToANSI
91473>>>        Get pbRecnum          to bRecnum
91474>>>        Get pbCopyData        to bCopyData
91475>>>        If (ghoDbUpdateHandler > 0) Begin
91477>>>            Get pbContinueOnError to bContinueOnError
91478>>>        End
91478>>>>
91478>>>
91478>>>        Get _AllTablesToConvert to iTablesArray
91479>>>        Move (SizeOfArray(iTablesArray)) to iSize
91480>>>        Decrement iSize
91481>>>        For iCount from 0 to iSize
91487>>>>
91487>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
91488>>>        Loop
91489>>>>
91489>>>
91489>>>    End_Procedure
91490>>>
91490>>>    // Subfunction to the ApiTableUpdate function (et al)
91490>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
91492>>>        Handle hTable
91492>>>        String sConnectionID
91492>>>        Boolean bTableExists bSameTableNames bANSI bOK
91492>>>
91492>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
91493>>>        If (bSameTableNames = True) Begin
91495>>>            Function_Return True
91496>>>        End
91496>>>>
91496>>>
91496>>>        Move True to bOK
91497>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
91498>>>        Set Private.phCurrentTable              to hTable
91499>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
91502>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
91505>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
91508>>>
91508>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
91510>>>            Get psConnectionID to sConnectionID
91511>>>            Get UtilTableExists hTable to bTableExists
91512>>>            If (bTableExists = True) Begin
91514>>>                Get SqlUtilUpdateIntFile hTable to bOK
91515>>>            End
91515>>>>
91515>>>            Else Begin
91516>>>                Get pbToANSI to bANSI
91517>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
91518>>>            End
91518>>>>
91518>>>        End
91518>>>>
91518>>>
91518>>>        Function_Return bOK
91519>>>    End_Function
91520>>>
91520>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
91522>>>        Handle hToTable hoLogFile
91522>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
91522>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
91522>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
91522>>>        tSQLConnection SQLConnection
91522>>>        tSQLConnection SQLConnection
91522>>>
91522>>>        Get UtilTableExists hTable to bExists
91523>>>        If (bExists = False) Begin
91525>>>            Set Private.phCurrentTable to hTable
91526>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
91527>>>>
91527>>>            Function_Return False
91528>>>        End
91528>>>>
91528>>>
91528>>>        Get UtilTableIsAlias hTable to bIsAlias
91529>>>        // If this is an Alias file there is nothing to convert to SQL.
91529>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
91529>>>        If (bIsAlias = True) Begin
91531>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91534>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
91536>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91539>>>                Get psConnectionID to sConnectionID
91540>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
91541>>>            End
91541>>>>
91541>>>            Function_Return True
91542>>>        End
91542>>>>
91542>>>
91542>>>        Set Private.phCurrentTable to hTable
91543>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91546>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91549>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91552>>>
91552>>>        If (ghoProgressBar <> 0) Begin
91554>>>            Send DoAdvance of ghoProgressBar
91555>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
91556>>>            Set Message_Text   of ghoStatusPanel to ""
91557>>>            Set Action_Text    of ghoStatusPanel to ""
91558>>>        End
91558>>>>
91558>>>
91558>>>        // Marco Kuipers suggestion;
91558>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
91558>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
91558>>>        // SQL table.
91558>>>        Get UtilTableIsSQL hTable to bOK
91559>>>        If (bOK = False) Begin
91561>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
91562>>>            If (bExists = True) Begin
91564>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
91564>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
91564>>>                Get phoLogFile to hoLogFile
91565>>>                If (hoLogFile <> 0) Begin          
91567>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
91568>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
91568>>>                    Send LogError sWarning False
91569>>>                End
91569>>>>
91569>>>                Else Begin
91570>>>                    Error DFERR_PROGRAM sWarning
91571>>>>
91571>>>                End                                                       
91571>>>>
91571>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
91572>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
91573>>>            End
91573>>>>
91573>>>        End
91573>>>>
91573>>>
91573>>>        // Does the rootname contain a driver?
91573>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
91575>>>            // Does the table already exist as an SQL table?
91575>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91576>>>            // It can happen that the table is missing from Filelist.cfg but still
91576>>>            // exist on the SQL side, in case we want to search for the table by its name.
91576>>>            If (bExists = False) Begin
91578>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
91579>>>            End
91579>>>>
91579>>>            If (bExists = True) Begin
91581>>>                Set TableName_Text of ghoStatusPanel to ""
91582>>>                Function_Return False
91583>>>            End
91583>>>>
91583>>>        End
91583>>>>
91583>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
91584>>>
91584>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
91585>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
91585>>>        // passed as True, we adjust for that here.
91585>>>        Get IsMertechDriver sDriverID to bMertechDriver
91586>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
91588>>>            Move False to bUseConnectionID
91589>>>        End
91589>>>>
91589>>>
91589>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91590>>>        Move SQLConnection.sSchema           to sSchema
91591>>>        If (sSchema = "") Begin
91593>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
91594>>>            Move (Lowercase(sSchema))        to sSchema
91595>>>        End
91595>>>>
91595>>>
91595>>>        If (sDriverID = ORAFLEX) Begin
91597>>>            Move SQLConnection.sUserID       to sSchema
91598>>>        End
91598>>>>
91598>>>
91598>>>        Move SQLConnection.sDatabase         to sDatabase
91599>>>        Move SQLConnection.sConnectionID     to sConnectionID
91600>>>        Move SQLConnection.sConnectionString to sConnectionString
91601>>>        If (sConnectionID = "" or sConnectionString = "") Begin
91603>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
91604>>>>
91604>>>            Function_Return False
91605>>>        End
91605>>>>
91605>>>
91605>>>        Get AutoConnectionIDLogin to bOK
91606>>>        Open hTable
91608>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91611>>>        If (bOpened = False) Begin
91613>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
91614>>>>
91614>>>            Function_Return False
91615>>>        End
91615>>>>
91615>>>
91615>>>        If (ghoProgressBar <> 0) Begin
91617>>>            Send DoAdvance of ghoProgressBar
91618>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
91619>>>        End
91619>>>>
91619>>>
91619>>>        Move 0 to hToTable
91620>>>        Get _TableNameOnly sRootName                 to sRootName
91621>>>        Move (sRootName + ".int")                    to sPhysicalName
91622>>>
91622>>>        Case Begin
91622>>>            Case (sDriverID = MSSQLDRV_ID)
91624>>>                Case Break
91625>>>            Case (sDriverID = ODBC_DRV_ID)
91628>>>                Case Break
91629>>>            Case (sDriverID = DB2_DRV_ID)
91632>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91633>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
91634>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91635>>>                Case Break
91636>>>            Case (sDriverID = ORAFLEX)
91639>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91640>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91641>>>                Case Break
91642>>>            Case (sDriverID = MDSMySQL)
91645>>>                Case Break
91646>>>            Case (sDriverID = MDSPgSQL)
91649>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91650>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91651>>>                Case Break
91652>>>            Case (sDriverID = DATAFLEX_ID)
91655>>>                Case Break
91656>>>            Case Else
91656>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
91657>>>>
91657>>>                Case Break
91658>>>        Case End
91658>>>
91658>>>        Move False to Err
91659>>>
91659>>>        If (bMertechDriver = True) Begin
91661>>>            // Note: This function also sets the Err flag.
91661>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
91662>>>        End
91662>>>>
91662>>>
91662>>>        If (bMertechDriver = False) Begin
91664>>>            Structure_Start hToTable sDriverID
91665>>>                Structure_Copy hTable to hToTable
91666>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
91669>>>
91669>>>                If (sDriverID <> DATAFLEX_ID) Begin
91671>>>                    If (bUseConnectionID = True) Begin
91673>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
91676>>>                    End
91676>>>>
91676>>>                    Else Begin
91677>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
91680>>>                    End
91680>>>>
91680>>>
91680>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
91683>>>
91683>>>                    If (sSchema <> "") Begin
91685>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
91688>>>                    End
91688>>>>
91688>>>
91688>>>                    If (sDriverID = DB2_DRV_ID) Begin
91690>>>                        If (sLongTableSpace <> "") Begin
91692>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
91695>>>                        End
91695>>>>
91695>>>                        If (sBaseTableSpace <> "") Begin
91697>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
91700>>>                        End
91700>>>>
91700>>>                        If (sIndexTableSpace <> "") Begin
91702>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
91705>>>                        End
91705>>>>
91705>>>                    End
91705>>>>
91705>>>                End
91705>>>>
91705>>>
91705>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91706>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91708>>>            Set Action_Text of ghoStatusPanel to ""
91709>>>        End
91709>>>>
91709>>>
91709>>>        Move (not(Err)) to bOK
91710>>>
91710>>>        If (bOK = True and bCopyData = True) Begin
91712>>>            If (bMertechDriver = False) Begin
91714>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
91715>>>            End
91715>>>>
91715>>>            Else Begin
91716>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
91717>>>            End
91717>>>>
91717>>>
91717>>>            If (ghoDbUpdateHandler > 0) Begin
91719>>>                Get pbContinueOnError to bContinueOnError
91720>>>            End
91720>>>>
91720>>>            // If the data copy failed we will keep the newly created SQL table but
91720>>>            // rename it by adding a GUID to the end of the table name
91720>>>            // - or as much as "fit" because different SQL back-ends have
91720>>>            // different rules how long a table name can be.
91720>>>            // The new table will probably contain data but something went
91720>>>            // wrong while converting the data from embedded to SQL.
91720>>>            If (bOK = False and bContinueOnError = False) Begin
91722>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
91723>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
91724>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
91725>>>>
91725>>>            End
91725>>>>
91725>>>        End
91725>>>>
91725>>>
91725>>>        // This must be after copying data...
91725>>>        If (Err = False) Begin
91727>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91730>>>            // It seems the Studio does not do this any more, so commented out.
91730>>>            // We also adjust the display name by prefixing it by the schema name;
91730>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
91730>>>            //                // The max length for the display_name is 31 characters...
91730>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
91730>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
91730>>>            //                End
91730>>>            //            End
91730>>>        End
91730>>>>
91730>>>
91730>>>        Close hTable
91731>>>        Move (not(Err)) to bOK
91732>>>        Function_Return bOK
91733>>>    End_Function
91734>>>
91734>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
91734>>>    // It will first drop all indicies, copy the data and then recreate indicies.
91734>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
91734>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
91736>>>        Boolean bOpened bOK
91736>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
91736>>>        String sErrorFile sEmpty sPath
91736>>>
91736>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
91739>>>        Get AutoConnectionIDLogin to bOK
91740>>>        If (sDriverID = DATAFLEX_ID) Begin
91742>>>            Send IncreaseSortBufferSize
91743>>>//            Send SetAllIndexesToBatch hToTable
91743>>>        End
91743>>>>
91743>>>
91743>>>        Move False to Err
91744>>>        Open sPhysicalName as hToTable
91746>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
91749>>>        If (bOpened = False) Begin
91751>>>            Function_Return False
91752>>>        End
91752>>>>
91752>>>
91752>>>        If (ghoStatusPanel <> 0) Begin
91754>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
91755>>>            Set piMinimum of ghoProgressBar to 0
91756>>>            Set piMaximum of ghoProgressBar to 100 // 100%
91757>>>        End
91757>>>>
91757>>>
91757>>>        Move "" to sEmpty
91758>>>        Move False to Err
91759>>>        Move True to bOK
91760>>>        Set Private.phCurrentTable to hToTable
91761>>>
91761>>>        // No need to get the record identifier
91761>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
91764>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91767>>>        If (sDriverID <> DATAFLEX_ID) Begin
91769>>>            // Remove all indices to speed up copying of data:
91769>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
91774>>>            If (iRetval <> 0) Begin       
91776>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91777>>>>
91777>>>                Close hToTable
91778>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91781>>>                Function_Return False
91782>>>            End
91782>>>>
91782>>>        End
91782>>>>
91782>>>
91782>>>        Move (sRootName + ".err") to sErrorFile
91783>>>        Move 0 to iIndex
91784>>>        Move False to Err
91785>>>
91785>>>        If (sDriverID = MSSQLDRV_ID) Begin
91787>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
91790>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
91795>>>            If (iRetval <> 0) Begin
91797>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91798>>>>
91798>>>                Close hToTable
91799>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91802>>>                Function_Return False
91803>>>            End
91803>>>>
91803>>>        End
91803>>>>
91803>>>        Else Begin
91804>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
91807>>>        End
91807>>>>
91807>>>
91807>>>        If (Err = False) Begin
91809>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
91810>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
91811>>>        End
91811>>>>
91811>>>
91811>>>        If (sDriverID <> DATAFLEX_ID) Begin
91813>>>            // Recreate indices:
91813>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
91818>>>            If (iRetval <> 0) Begin
91820>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
91821>>>>
91821>>>                Close hToTable
91822>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91825>>>                Function_Return False
91826>>>            End
91826>>>>
91826>>>        End
91826>>>>
91826>>>
91826>>>        Close hToTable
91827>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
91830>>>
91830>>>        If (bOK = True) Begin
91832>>>            Move (not(Err)) to bOK
91833>>>        End
91833>>>>
91833>>>
91833>>>        If (ghoStatusPanel <> 0) Begin
91835>>>            Set TableName_Text of ghoStatusPanel to ""
91836>>>            Set Message_Text   of ghoStatusPanel to ""
91837>>>            Set Action_Text    of ghoStatusPanel to ""
91838>>>        End
91838>>>>
91838>>>
91838>>>        Function_Return (bOK = True)
91839>>>    End_Function
91840>>>
91840>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
91840>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
91840>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
91842>>>        Handle hFile
91842>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
91842>>>        Integer iIdentityType iDataType iDbType iCount iSize
91842>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
91842>>>        tSQLConnection SQLConnection
91842>>>        tSQLConnection SQLConnection
91842>>>        tAPIColumn[] aColumns
91842>>>        tAPIColumn[] aColumns
91843>>>        tColumnType ColumnType
91843>>>        tColumnType ColumnType
91843>>>
91843>>>        // First check if the passed filenumber already exists; in case we do nothing
91843>>>        Get UtilTableExists hTable to bOk
91844>>>        If (bOk = True) Begin
91846>>>            Function_Return False
91847>>>        End
91847>>>>
91847>>>
91847>>>        Set Private.phCurrentTable to hTable
91848>>>        Move sLogicalName to sTableName
91849>>>        If (ghoProgressBar <> 0) Begin
91851>>>            Send DoAdvance of ghoProgressBar
91852>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
91853>>>        End
91853>>>>
91853>>>
91853>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
91854>>>        Get psDriverID to sDriverID
91855>>>        Get IsSQLDriver sDriverID to bSqlDriver
91856>>>        Get piDbType to iDbType
91857>>>
91857>>>        // If no columns passed in, we need to create a "dummy" column
91857>>>        Move False to bDeleteDummy
91858>>>        If (Num_Arguments = 8) Begin
91860>>>            Move aColumnIn to aColumns
91861>>>        End
91861>>>>
91861>>>        If ((SizeOfArray(aColumns)) = 0) Begin
91863>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
91864>>>            Move ColumnType.iSQLType to iDataType
91865>>>            If (bRecnum = False) Begin
91867>>>                Move C_tAPIColumn_Identity to iIdentityType
91868>>>            End
91868>>>>
91868>>>            Else Begin
91869>>>                Move C_tAPIColumn_None     to iIdentityType
91870>>>            End
91870>>>>
91870>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
91871>>>            Move True to bDeleteDummy
91872>>>        End
91872>>>>
91872>>>
91872>>>        // If columns have been passed as an array we need to check if an identity column
91872>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
91872>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
91872>>>        // two identity columns and SQL doesn't like that and throws an error.
91872>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
91874>>>            Move (SizeOfArray(aColumns)) to iSize
91875>>>            Decrement iSize
91876>>>            for iCount from 0 to iSize
91882>>>>
91882>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
91884>>>                    Move False to bRecnum
91885>>>                    Move iSize to iCount
91886>>>                End
91886>>>>
91886>>>            Loop
91887>>>>
91887>>>        End
91887>>>>
91887>>>
91887>>>        // If this is a SQL based driver we also check if the table exists
91887>>>        // in the SQL back end; in case we do nothing.
91887>>>        If (bSqlDriver = True) Begin
91889>>>            // Get all connection properties
91889>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91890>>>            Move SQLConnection.sSchema to sSchema
91891>>>            If (sSchema = "") Begin
91893>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
91894>>>            End
91894>>>>
91894>>>
91894>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91895>>>            // It can happen that the table is missing from Filelist.cfg but still
91895>>>            // exist on the SQL side, in case we want to search for the table by its name.
91895>>>            If (bExists = False) Begin
91897>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91898>>>            End
91898>>>>
91898>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
91898>>>            // we will just add it to Filelist.cfg
91898>>>            If (bExists = True) Begin
91900>>>                If (bExistsInFilelist = False) Begin
91902>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
91904>>>                        Move (sDriverID + ":" + sRootName) to sRootName
91905>>>                    End
91905>>>>
91905>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91908>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91911>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91914>>>                    Move False to bSysFile
91915>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
91916>>>                End
91916>>>>
91916>>>                Function_Return False
91917>>>            End
91917>>>>
91917>>>        End
91917>>>>
91917>>>
91917>>>        Move CS_ANSI_Txt to sANSI_OEM
91918>>>        If (num_arguments > 6) Begin
91920>>>            If (bANSI = False) Begin
91922>>>                Move CS_OEM_Txt to sANSI_OEM
91923>>>            End
91923>>>>
91923>>>        End
91923>>>>
91923>>>
91923>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
91923>>>        // is a programmer's error and we auto-correct for it here.
91923>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
91923>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
91923>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
91923>>>        // set it back and use a Mertech function to convert it to SQL.
91923>>>        Get IsMertechDriver sDriverID to bMertechDriver
91924>>>        If (bMertechDriver = True) Begin
91926>>>            If (bUseConnectionID = True) Begin
91928>>>                Move False to bUseConnectionID
91929>>>            End
91929>>>>
91929>>>            Move sDriverID to sOriginalDriverID
91930>>>            Move DATAFLEX_ID to sDriverID
91931>>>        End
91931>>>>
91931>>>
91931>>>        Move False to Err
91932>>>        If (sDriverID = DATAFLEX_ID) Begin
91934>>>            Move sRootName to sPhysicalFile
91935>>>        End
91935>>>>
91935>>>
91935>>>        If (sDriverID <> DATAFLEX_ID) Begin
91937>>>            Move SQLConnection.sConnectionID to sConnectionID
91938>>>
91938>>>            // If DAW driver and we should use a connection id we need to
91938>>>            // check if the connection ID exists; else we create it before attempting creating the table
91938>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
91940>>>                Get IsConnectionID sConnectionID sDriverID to bExists
91941>>>                If (bExists = False) Begin
91943>>>                    Get AutoSetConnectionID sConnectionID to bOk
91944>>>                    If (bOk = False) Begin
91946>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
91947>>>>
91947>>>                        Function_Return False
91948>>>                    End
91948>>>>
91948>>>                End
91948>>>>
91948>>>            End
91948>>>>
91948>>>
91948>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
91950>>>                Move (sTableName + ".int") to sPhysicalFile
91951>>>            End
91951>>>>
91951>>>            Else Begin
91952>>>                Move (sRootName + ".int") to sPhysicalFile
91953>>>            End
91953>>>>
91953>>>            Move (Uppercase(sDisplayName)) to sVal
91954>>>//            If (not(sVal contains (sSchema + "."))) Begin
91954>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
91954>>>//            End
91954>>>        End
91954>>>>
91954>>>        Move False to Err
91955>>>        Move 0 to hFile
91956>>>
91956>>>        Structure_Start hFile sDriverID
91957>>>            If (sDriverID <> DATAFLEX_ID) Begin
91959>>>                If (bUseConnectionID = True) Begin
91961>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
91964>>>                End
91964>>>>
91964>>>                Else Begin
91965>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
91968>>>                End
91968>>>>
91968>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
91971>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
91974>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
91977>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
91980>>>
91980>>>                If (sSchema <> "") Begin
91982>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
91985>>>                End
91985>>>>
91985>>>
91985>>>                If (sDriverID = DB2_DRV_ID) Begin
91987>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
91989>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
91992>>>                    End
91992>>>>
91992>>>                End
91992>>>>
91992>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
91994>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
91996>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
91999>>>                    End
91999>>>>
91999>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
92001>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
92004>>>                    End
92004>>>>
92004>>>                End
92004>>>>
92004>>>            End
92004>>>>
92004>>>
92004>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
92007>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
92008>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92009>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92011>>>        Set Action_Text of ghoStatusPanel to ""
92012>>>
92012>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
92012>>>        If (bMertechDriver = True) Begin
92014>>>            Move sOriginalDriverID to sDriverID
92015>>>            If (not(sVal contains (sSchema + "."))) Begin
92017>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
92018>>>            End
92018>>>>
92018>>>            // Note: This function also sets the Err flag.
92018>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
92018>>>        End
92018>>>>
92018>>>
92018>>>        Move (not(Err)) to bOK
92019>>>        If (bOk = True) Begin
92021>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
92023>>>                Move (sDriverID + ":" + sRootName) to sRootName
92024>>>            End
92024>>>>
92024>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
92027>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92030>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92033>>>
92033>>>            // Lastly we remove the temporary column we created above, if all went well.
92033>>>            If (bDeleteDummy) Begin
92035>>>                Get ApiColumnRemove hTable "temp" to bOk
92036>>>            End
92036>>>>
92036>>>        End
92036>>>>
92036>>>
92036>>>        Set TableName_Text of ghoStatusPanel to ""
92037>>>        Close hTable
92038>>>        Function_Return (bOK = True)
92039>>>    End_Function
92040>>>
92040>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
92042>>>        Move False to Err
92043>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
92046>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
92049>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
92052>>>
92052>>>        Function_Return (Err = False)
92053>>>    End_Function
92054>>>
92054>>>    // ToDo: Needs to be revised
92054>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
92056>>>        Handle hTable
92056>>>        String sDEFName sDataPath
92056>>>        Boolean bExists
92056>>>
92056>>>        // Do nothing if MSSQL Driver.
92056>>>//        Get IsMSSQLDriver to bExists
92056>>>//        If (bExists = True) Begin
92056>>>//            Procedure_Return
92056>>>//        End
92056>>>
92056>>>        Get psDataPathFirstPart to sDataPath
92057>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
92058>>>        If (bExists = True) Begin
92060>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
92060>>>            // still be missing from the filelist and needs to be added.
92060>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
92061>>>            If (bExists = True) Begin
92063>>>                Procedure_Return
92064>>>            End
92064>>>>
92064>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
92064>>>            Else Begin
92065>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
92068>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
92071>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
92074>>>                Procedure_Return
92075>>>            End
92075>>>>
92075>>>        End
92075>>>>
92075>>>
92075>>>        Move (sPath + sFileName + ".def") to sDEFName
92076>>>        Move 0 to hTable
92077>>>        Move False to Err
92078>>>
92078>>>        Structure_Start hTable DATAFLEX_ID
92079>>>            Load_Def sDEFName Onto hTable
92080>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
92083>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92084>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92086>>>        Set Action_Text of ghoStatusPanel to ""
92087>>>
92087>>>        Move iFilelistSlot to hTable
92088>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
92091>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92094>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92097>>>
92097>>>    End_Procedure
92098>>>
92098>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
92100>>>        Boolean bTmp bErr bOK
92100>>>        String sTableName sDisplayName sFileName
92100>>>
92100>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
92100>>>        Move Err to bTmp
92101>>>        Move False to Err
92102>>>
92102>>>        Get AutoConnectionIDLogin to bOK
92103>>>        // First get the info for the current filelist slot:
92103>>>        Open iFromFileSlot
92105>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
92108>>>        If (bOK = True) Begin
92110>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
92113>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
92116>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
92119>>>
92119>>>            //...then move it.
92119>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
92122>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
92125>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
92128>>>
92128>>>            //...and finally remove the old filelist values.
92128>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
92131>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
92134>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
92137>>>        End
92137>>>>
92137>>>        Close iFromFileSlot
92138>>>
92138>>>        Move Err to bErr
92139>>>        Move bTmp to Err
92140>>>        Function_Return (bErr = False)
92141>>>    End_Function
92142>>>
92142>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
92144>>>        Handle hTable
92144>>>        Boolean bOK
92144>>>        String sDriverID
92144>>>
92144>>>        Get UtilTableExists hTableFrom to bOK
92145>>>        If (bOK = False) Begin
92147>>>            Set Private.phCurrentTable to hTableFrom
92148>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
92149>>>>
92149>>>            Function_Return False
92150>>>        End
92150>>>>
92150>>>
92150>>>        Get UtilTableExists hTableTo to bOK
92151>>>        If (bOK = False) Begin
92153>>>            Set Private.phCurrentTable to hTableTo
92154>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
92155>>>>
92155>>>            Function_Return False
92156>>>        End
92156>>>>
92156>>>
92156>>>        Get AutoConnectionIDLogin to bOK
92157>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
92158>>>        If (bOK = False) Begin
92160>>>            Function_Return False
92161>>>        End
92161>>>>
92161>>>
92161>>>        Move False to Err
92162>>>        Open hTableTo
92164>>>
92164>>>        Move hTableFrom to hTable
92165>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92168>>>        Set Private.phCurrentTable to hTable
92169>>>
92169>>>        Structure_Start hTable sDriverID
92170>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
92173>>>            If (iColumnTo <> 0) Begin
92175>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
92178>>>            End
92178>>>>
92178>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92179>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92181>>>        Set Action_Text of ghoStatusPanel to ""
92182>>>
92182>>>        If (hTableTo > 0) Begin
92184>>>            Close hTableTo
92185>>>        End
92185>>>>
92185>>>
92185>>>        Function_Return (Err = False)
92186>>>    End_Function
92187>>>
92187>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
92187>>>    Function ApiTableRemove Handle hTable Returns Boolean
92189>>>        String sTableName sDriverID
92189>>>        Boolean bOk
92189>>>        String sDataPath
92189>>>
92189>>>        Get AutoConnectionIDLogin to bOK
92190>>>        Move False to Err
92191>>>        Get psDriverID to sDriverID
92192>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
92193>>>        If (sTableName = "") Begin
92195>>>            Function_Return False
92196>>>        End
92196>>>>
92196>>>
92196>>>        Set Private.phCurrentTable to hTable
92197>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
92198>>>        Delete_db sTableName
92199>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
92200>>>
92200>>>        If (sDriverID <> DATAFLEX_ID) Begin
92202>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
92202>>>            Get psDataPathFirstPart to sDataPath
92203>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
92204>>>        End
92204>>>>
92204>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
92204>>>        If (hTable <> 0) Begin
92206>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
92209>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
92212>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
92215>>>        End
92215>>>>
92215>>>
92215>>>        Close hTable
92216>>>        Function_Return (hTable <> 0)
92217>>>    End_Function
92218>>>
92218>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
92220>>>        Handle hTable
92220>>>        Boolean bOK
92220>>>
92220>>>        Get AutoConnectionIDLogin to bOK
92221>>>        Move False to Err
92222>>>        Open hTableFrom Mode DF_EXCLUSIVE
92224>>>        Move hTableFrom to hTable
92225>>>
92225>>>        Structure_Start hTable
92226>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
92229>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92230>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92232>>>        Set Action_Text of ghoStatusPanel to ""
92233>>>
92233>>>        Close hTableFrom
92234>>>        Function_Return (Err = False)
92235>>>    End_Function
92236>>>
92236>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
92238>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
92238>>>        Boolean bOK bExists bOpened
92238>>>        tAPITableNameInfo APITableNameInfo
92238>>>        tAPITableNameInfo APITableNameInfo
92238>>>
92238>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92241>>>        If (bOpened = False) Begin
92243>>>            Get OpenTableExclusive hTable to bOpened
92244>>>            If (bOpened = False) Begin
92246>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
92247>>>                Function_Return False
92248>>>            End
92248>>>>
92248>>>        End
92248>>>>
92248>>>
92248>>>        Set Private.phCurrentTable to hTable
92249>>>        Move hTable         to APITableNameInfo.iTableNumber
92250>>>        Move sRootName      to APITableNameInfo.sRootName
92251>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
92252>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
92253>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
92254>>>        If (bExists = True) Begin
92256>>>            Function_Return True
92257>>>        End
92257>>>>
92257>>>
92257>>>        Set Private.phCurrentTable to hTable
92258>>>        Move False to Err
92259>>>        Get psDataPathFirstPart to sDataPath
92260>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
92263>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
92266>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
92269>>>
92269>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92272>>>        Close hTable
92273>>>        If (sDriverID = DATAFLEX_ID) Begin
92275>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
92276>>>            If (bExists = True) Begin
92278>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
92280>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
92283>>>                    // We need a short break here before attempting to delete the physical old files or Windows
92283>>>                    // might report "File in use..." and the deletion will fail.
92283>>>                    Sleep 2
92284>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
92285>>>                End
92285>>>>
92285>>>            End
92285>>>>
92285>>>        End
92285>>>>
92285>>>
92285>>>        If (sDriverID <> DATAFLEX_ID) Begin
92287>>>            If (not(sPhysicalName contains ".")) Begin
92289>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
92290>>>            End
92290>>>>
92290>>>
92290>>>            // Change the table name in the .int file to the new table new:
92290>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
92291>>>            If (bOK = False) Begin
92293>>>                Function_Return False
92294>>>            End
92294>>>>
92294>>>
92294>>>            // Change table name at the SQL side:
92294>>>            Get psSchema to sSchema
92295>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
92296>>>
92296>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
92297>>>            // Remove cache file and Rename the physical file names:
92297>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
92298>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
92299>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
92300>>>            Move (sDriverID + ":" + sRootName) to sRootName
92301>>>
92301>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
92301>>>//            If (not(sDisplayName contains ".")) Begin
92301>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
92301>>>//            End
92301>>>        End
92301>>>>
92301>>>
92301>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
92304>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92307>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92310>>>
92310>>>        Function_Return (Err = False)
92311>>>    End_Function
92312>>>
92312>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
92314>>>        Move False to Err
92315>>>        Set Private.phCurrentTable to hTable
92316>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92319>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92322>>>
92322>>>        Function_Return (Err = False)
92323>>>    End_Function
92324>>>
92324>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
92324>>>    // Note that it first removes any driver prefixes in the rootname.
92324>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
92326>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
92326>>>        Handle hTable
92326>>>        Boolean bIsSame
92326>>>
92326>>>        Move APITableInfo.iTableNumber      to hTable
92327>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
92328>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
92331>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
92332>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
92335>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
92338>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
92339>>>
92339>>>        If (bCompareFilelistUppercase = True) Begin
92341>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
92342>>>        End
92342>>>>
92342>>>        Else Begin
92343>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
92344>>>        End
92344>>>>
92344>>>
92344>>>        Function_Return bIsSame
92345>>>    End_Function
92346>>>
92346>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
92346>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
92348>>>        Handle hTable
92348>>>        String sTableName
92348>>>        String sDriverIDFrom sDriverIDTo
92348>>>        Integer iDbType
92348>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
92348>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
92348>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
92348>>>        tSQLConnection SQLConnection
92348>>>        tSQLConnection SQLConnection
92348>>>        tAPITable      APITableFrom APITableTo
92348>>>        tAPITable      APITableFrom APITableTo
92348>>>        tColumnType    ColumnType
92348>>>        tColumnType    ColumnType
92348>>>        tAPIColumnCompare[]   aAPIColumnCompare
92348>>>        tAPIColumnCompare[]   aAPIColumnCompare
92349>>>        tAPIIndexCompare[]    aAPIIndexCompare
92349>>>        tAPIIndexCompare[]    aAPIIndexCompare
92350>>>        tAPIRelationCompare[] aAPIRelationCompare
92350>>>        tAPIRelationCompare[] aAPIRelationCompare
92351>>>
92351>>>        // We don't allow changes to the framework's DbVersion table.
92351>>>        If (Lowercase(sTableName) = "dbversion") Begin
92353>>>            Function_Return False
92354>>>        End
92354>>>>
92354>>>
92354>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
92355>>>        Get piDbType                            to iDbType
92356>>>        Get pbRecnum                            to bRecnum
92357>>>        Get pbToANSI                            to bToANSI
92358>>>        Get pbCopyData                          to bCopyData
92359>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
92360>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
92361>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
92362>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
92363>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
92364>>>        Get pbUseConnectionID                   to bUseConnectionID
92365>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
92367>>>            Move False                          to bUseConnectionID
92368>>>        End
92368>>>>
92368>>>
92368>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
92369>>>        Set Private.phCurrentTable              to hTable
92370>>>        Get UtilTableExists  hTable             to bTableExists
92371>>>
92371>>>        If (ghoProgressBar <> 0) Begin
92373>>>            Send DoAdvance of ghoProgressBar
92374>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
92375>>>            Set Message_Text   of ghoStatusPanel to ""
92376>>>            Set Action_Text    of ghoStatusPanel to ""
92377>>>        End
92377>>>>
92377>>>
92377>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
92378>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
92379>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
92380>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
92381>>>        Move True                               to APITableFrom.bFromTable
92382>>>        Move hTable                             to APITableFrom.hTable
92383>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
92384>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
92385>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
92386>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
92387>>>
92387>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92389>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
92390>>>            If (bOk = True) Begin
92392>>>                Get ApiTableAttachToSql hTable True to bOk
92393>>>                Function_Return bOk
92394>>>            End 
92394>>>>
92394>>>        End
92394>>>>
92394>>>
92394>>>        If (bTableExists = True) Begin
92396>>>            If (bIsSQLTableTo = True) Begin
92398>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
92399>>>            End
92399>>>>
92399>>>
92399>>>            Get OpenTableExclusive hTable to bOpened
92400>>>            If (bOpened = False) Begin
92402>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
92403>>>                Function_Return False
92404>>>            End
92404>>>>
92404>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
92405>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
92406>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
92407>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
92408>>>        End
92408>>>>
92408>>>
92408>>>        Move False to Err
92409>>>        Case Begin
92409>>>            // Alias table:
92409>>>            Case (bIsAliasFrom = True)
92411>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
92412>>>                Case Break
92413>>>
92413>>>            // New Table:
92413>>>            Case (bTableExists = False)
92416>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
92417>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
92417>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
92419>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
92420>>>                End                                                                 
92420>>>>
92420>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
92421>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
92422>>>                Case Break
92423>>>
92423>>>            // Update table:
92423>>>            Case (bTableExists = True)
92426>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
92427>>>                If (bIsSame = True) Begin
92429>>>                    Case Break
92430>>>                End
92430>>>>
92430>>>                If (bFilelistError = True) Begin
92432>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
92433>>>                    If (bOk = False) Begin
92435>>>                        Case Break
92436>>>                    End
92436>>>>
92436>>>                End
92436>>>>
92436>>>
92436>>>                If (ghoProgressBar <> 0) Begin
92438>>>                    Send DoAdvance of ghoProgressBar
92439>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
92440>>>                End
92440>>>>
92440>>>
92440>>>                // Columns:
92440>>>                Move True to bOk
92441>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
92442>>>                If (bIsSame = False) Begin
92444>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
92445>>>                End
92445>>>>
92445>>>                If (bOk = False) Begin
92447>>>                    Case Break
92448>>>                End
92448>>>>
92448>>>
92448>>>                // Indexes:
92448>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
92449>>>                If (bIsSame = False) Begin
92451>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
92452>>>                End
92452>>>>
92452>>>
92452>>>                // Relations:
92452>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
92453>>>                If (bIsSame = False) Begin
92455>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
92456>>>                    If (bOk = False) Begin
92458>>>                        Case Break
92459>>>                    End
92459>>>>
92459>>>                End
92459>>>>
92459>>>
92459>>>                Case Break
92460>>>
92460>>>            Case Else
92460>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
92461>>>>
92461>>>                Move False to bOk
92462>>>        Case End
92462>>>        
92462>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
92462>>>        // or convert an embedded table to SQL
92462>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92464>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
92465>>>            If (bOk = False) Begin
92467>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
92468>>>            End
92468>>>>
92468>>>        End
92468>>>>
92468>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
92471>>>            Get SqlTableConvertToEmbedded hTable True to bOk
92472>>>        End
92472>>>>
92472>>>        
92472>>>        // Filelist Names:
92472>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
92473>>>        Close hTable
92474>>>        Set TableName_Text of ghoStatusPanel to ""
92475>>>
92475>>>        Function_Return (bOK = True)
92476>>>    End_Function
92477>>>
92477>>>    // * Dummy function for the Studio's Code Explorer *
92477>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
92479>>>        Function_Return False
92480>>>    End_Function
92481>>>
92481>>>    // Adds a column name to the passed table number.
92481>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
92483>>>        Integer iColumn iCount iFile iPrecision iLastErr
92483>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
92483>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
92483>>>
92483>>>        Get UtilColumnExists hTable sFieldName to bExists
92484>>>        If (bExists = True) Begin
92486>>>            Function_Return False
92487>>>        End
92487>>>>
92487>>>
92487>>>        Move False to Err
92488>>>        If (num_arguments > 4) Begin
92490>>>            Move iPrec to iPrecision
92491>>>        End
92491>>>>
92491>>>        If (num_arguments > 6) Begin
92493>>>            Move bInitVal to bInitializeValue
92494>>>            Move sColVal  to sColumnValue
92495>>>        End
92495>>>>
92495>>>        If (iType < -1490) Begin
92497>>>            Move (iType + 1500) to iType
92498>>>        End
92498>>>>
92498>>>
92498>>>        Move hTable to iFile
92499>>>        Get psDriverID to sDriverID
92500>>>        Get IsMertechDriver sDriverID to bMertechDriver
92501>>>        Get AutoConnectionIDLogin to bOK
92502>>>        Move False to Err
92503>>>        Move LastErr to iLastErr
92504>>>        Get OpenTableExclusive iFile to bOK
92505>>>//        Open iFile Mode DF_EXCLUSIVE
92505>>>        Set Private.phCurrentTable to hTable
92506>>>            MERTECH_WARNING_MESSAGE Disabled
92539>>>>
92539>>>        Structure_Start iFile sDriverID
92540>>>            Move 0 to iColumn
92541>>>            Set Private.piCurrentField to iColumn
92542>>>            Create_Field hTable At iColumn
92543>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
92546>>>            If (bMertechDriver = True) Begin
92548>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92549>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
92550>>>            End
92550>>>>
92550>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
92553>>>            If (bMertechDriver = True) Begin
92555>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92556>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
92557>>>                Move False to Err
92558>>>                Move iLastErr to LastErr
92559>>>            End
92559>>>>
92559>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
92562>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
92565>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92566>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92568>>>            MERTECH_WARNING_MESSAGE Enabled
92601>>>>
92601>>>
92601>>>        Set Action_Text of ghoStatusPanel to ""
92602>>>
92602>>>        // If in development environment; create .fd file:
92602>>>        Open hTable
92604>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
92605>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92606>>>        If (iCount > 1) Begin
92608>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92609>>>        End
92609>>>>
92609>>>        Get vFolderExists sDDSrcPath to bExists
92610>>>        If (bExists = True) Begin
92612>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92613>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92616>>>            Get _TableNameOnly sTableName to sTableName
92617>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92619>>>        End
92619>>>>
92619>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
92621>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
92622>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
92623>>>            If (iCount > 1) Begin
92625>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
92626>>>            End
92626>>>>
92626>>>            Get vFolderFormat sDataPath to sDataPath
92627>>>            // Add the new column name to the .tag filen (if it doesn't exist):
92627>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
92627>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
92627>>>        End
92627>>>>
92627>>>        // Check for a default value
92627>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
92629>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
92630>>>        End
92630>>>>
92630>>>        Close hTable
92631>>>
92631>>>        Function_Return (Err = False)
92632>>>    End_Function
92633>>>
92633>>>    // Adds a column name to the passed table number.
92633>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
92635>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
92635>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
92635>>>        String sDdSrcPath sTableName
92635>>>
92635>>>        Get UtilColumnExists hTable sFieldName to bExists
92636>>>        Move False to Err
92637>>>        If (bExists = True) Begin
92639>>>            Function_Return False
92640>>>        End
92640>>>>
92640>>>        If (num_arguments > 4) Begin
92642>>>            Move iPrec to iPrecision
92643>>>        End
92643>>>>
92643>>>        If (iType < -1490) Begin
92645>>>            Move (iType + 1500) to iType
92646>>>        End
92646>>>>
92646>>>
92646>>>        Get AutoConnectionIDLogin to bOK
92647>>>        Move False to Err
92648>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
92649>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
92649>>>        // data types between Embedded and SQL, else we can't compare the data types. 
92649>>>        Get piDbType to iDbType
92650>>>        If (bIsSQLTypeTo = False) Begin
92652>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
92653>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
92655>>>                Move DF_DATE to iType
92656>>>            End
92656>>>>
92656>>>        End
92656>>>>
92656>>>
92656>>>        // Structure_start will change the value of hTable...
92656>>>        Move hTable to iFile
92657>>>        Get OpenTableExclusive iFile to bOK
92658>>>        If (bOK = False) Begin
92660>>>            Function_Return False
92661>>>        End
92661>>>>
92661>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
92664>>>
92664>>>        // If the passed column number is higher than the current number of fields
92664>>>        // in the table, this means we should _not_ insert a field but rather add
92664>>>        // a new field to the end:
92664>>>        If (iColumn > iNumberOfFields) Begin
92666>>>            Move 0 to iColumn
92667>>>        End
92667>>>>
92667>>>
92667>>>        Set Private.phCurrentTable to hTable
92668>>>        Set Private.piCurrentField to iColumn
92669>>>
92669>>>        Structure_Start iFile
92670>>>            Create_Field iFile At iColumn
92671>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
92674>>>            If (bIsSQLTypeTo = False) Begin
92676>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
92679>>>            End
92679>>>>
92679>>>            Else Begin
92680>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
92683>>>            End
92683>>>>
92683>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
92684>>>            If (bIsDateType = False) Begin
92686>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
92689>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
92692>>>            End
92692>>>>
92692>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92693>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92695>>>
92695>>>        Set Action_Text of ghoStatusPanel to ""
92696>>>        // If in development environment; create .fd file:
92696>>>        Open hTable
92698>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92699>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92700>>>        If (iCount > 1) Begin
92702>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92703>>>        End
92703>>>>
92703>>>        Get vFolderExists sDDSrcPath to bExists
92704>>>        If (bExists = True) Begin
92706>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92707>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92710>>>            Get _TableNameOnly sTableName to sTableName
92711>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92713>>>        End
92713>>>>
92713>>>
92713>>>        // Check for a default value
92713>>>        Close hTable
92714>>>
92714>>>        Function_Return (Err = False)
92715>>>    End_Function
92716>>>
92716>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
92716>>>//        Integer iColumn iCount iFile
92716>>>//        Boolean bExists bOK
92716>>>//        String sDdSrcPath sTableName
92716>>>//
92716>>>//        Get AutoConnectionIDLogin to bOK
92716>>>//        Move False to Err
92716>>>//
92716>>>//        // Structure_start will change the value of hTable...
92716>>>//        Move hTable to iFile
92716>>>//        Open iFile Mode DF_EXCLUSIVE
92716>>>//
92716>>>//        Structure_Start iFile
92716>>>//            Send ApiColumnsAddToTable iFile aColumns False
92716>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92716>>>//
92716>>>//        // If in development environment; create .fd file:
92716>>>//        Open hTable
92716>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92716>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92716>>>//        If (iCount > 1) Begin
92716>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92716>>>//        End
92716>>>//        Get vFolderExists sDDSrcPath to bExists
92716>>>//        If (bExists = True) Begin
92716>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
92716>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92716>>>//            Get _TableNameOnly sTableName to sTableName
92716>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92716>>>//        End
92716>>>//        Close hTable
92716>>>//
92716>>>//        Function_Return (Err = False)
92716>>>//    End_Function
92716>>>
92716>>>    // To update all records for a table column with a fixed value.
92716>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
92718>>>        Integer iRecs iCurrErr iField iRecord
92718>>>        Boolean bRetval bOpen
92718>>>
92718>>>        Move 0 to iRecs
92719>>>        Move False to bRetval
92720>>>        Move Err to iCurrErr
92721>>>        Move False to Err
92722>>>
92722>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92725>>>        If (bOpen = False) Begin
92727>>>            Open hTable
92729>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92732>>>            If (bOpen = False) Begin
92734>>>                Function_Return bRetval
92735>>>            End
92735>>>>
92735>>>        End
92735>>>>
92735>>>
92735>>>        Field_Map hTable sFieldName to iField
92737>>>        If (iField <> 0) Begin
92739>>>            Set Private.phCurrentTable to hTable
92740>>>            Set Private.piCurrentField to iField
92741>>>            Clear hTable
92742>>>            Repeat
92742>>>>
92742>>>                Vfind hTable 0 GT
92744>>>                If (Found) Begin
92746>>>                    If (ghoStatusPanel <> 0) Begin
92748>>>                        Get_Field_Value hTable 0 to iRecord
92751>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
92752>>>                    End
92752>>>>
92752>>>                    Reread hTable
92756>>>                        Set_Field_Value hTable iField to sColumnValue
92759>>>                        SaveRecord hTable
92760>>>                    Unlock
92761>>>>
92761>>>                End
92761>>>>
92761>>>           Until (not(Found))
92763>>>        End
92763>>>>
92763>>>
92763>>>        Move (Err = False) to bRetval
92764>>>        Move iCurrErr to Err
92765>>>
92765>>>        Function_Return bRetval
92766>>>    End_Function
92767>>>
92767>>>    // Note: This can only be used from within a Structure_Start/End construct.
92767>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
92769>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
92769>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
92769>>>        String sFieldName sDriverID sTableName sDefaultValue
92769>>>
92769>>>//        Set Private.phCurrentTable to hTable
92769>>>        Get psDriverID to sDriverID
92770>>>        Get piDbType to iDbType
92771>>>        Get UtilTableHandleToString hTable to sTableName
92772>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
92773>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
92774>>>        Get UtilTableIsSQL hTable to bIsSqlTable
92775>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
92777>>>            Move True to bIsSqlTable
92778>>>        End
92778>>>>
92778>>>        Move False to bIsOpen
92779>>>        If (hTable > 0) Begin
92781>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
92784>>>        End
92784>>>>
92784>>>        If (bIsOpen = True) Begin
92786>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
92789>>>        End
92789>>>>
92789>>>        Else Begin
92790>>>            Get pbRecnum to bRecnumTable
92791>>>        End
92791>>>>
92791>>>
92791>>>        Move False to Err
92792>>>        Move (SizeOfArray(aColumns)) to iSize
92793>>>        Decrement iSize
92794>>>        for iCount from 0 to iSize
92800>>>>
92800>>>            Move aColumns[iCount].sFieldName to sFieldName
92801>>>            If (hTable > 0) Begin
92803>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92804>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92805>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
92808>>>                Move (Trim(sFieldName) <> "") to bFieldExists
92809>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92810>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92811>>>            End
92811>>>>
92811>>>            Else Begin
92812>>>                Move False to bFieldExists
92813>>>            End
92813>>>>
92813>>>
92813>>>            If (bFieldExists = False) Begin
92815>>>                Move 0 to iColumn
92816>>>                Create_Field hTable At iColumn
92817>>>            End
92817>>>>
92817>>>            Else Begin
92818>>>                Move iCount to iColumn
92819>>>            End
92819>>>>
92819>>>
92819>>>            Set Private.piCurrentField to iColumn
92820>>>
92820>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
92821>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
92824>>>
92824>>>            Move aColumns[iCount].iType to iType
92825>>>            Move (not(iType < -1490)) to bNativeType
92826>>>            If (iType < -1490) Begin
92828>>>                Move (iType + 1500) to iType
92829>>>            End
92829>>>>
92829>>>
92829>>>            If (bIsSqlTable = True) Begin
92831>>>                If (aColumns[iCount].bIsSQLType = True) Begin
92833>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
92834>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
92837>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
92840>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
92843>>>
92843>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
92844>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
92846>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
92847>>>                    End
92847>>>>
92847>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
92850>>>
92850>>>                End
92850>>>>
92850>>>                Else Begin
92851>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
92854>>>                End
92854>>>>
92854>>>            End
92854>>>>
92854>>>            Else Begin
92855>>>                If (bCreating = False) Begin
92857>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
92858>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
92860>>>                        Move DF_DATE to iType
92861>>>                    End
92861>>>>
92861>>>                End
92861>>>>
92861>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92864>>>            End
92864>>>>
92864>>>
92864>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
92865>>>            If (bIsDateType = False) Begin
92867>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
92870>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
92873>>>            End
92873>>>>
92873>>>
92873>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
92875>>>                Move 0 to iIndex
92876>>>                Create_Index hTable at iIndex
92877>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
92880>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
92883>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
92886>>>
92886>>>                // If we have an identity table - we must create a primary_key table.
92886>>>                If (bIsSqlTable = True) Begin
92888>>>                End
92888>>>>
92888>>>            End
92888>>>>
92888>>>        Loop
92889>>>>
92889>>>
92889>>>        Function_Return (Err = False)
92890>>>    End_Function
92891>>>
92891>>>    // Changes a field type, length and precision for the passed table number and field name
92891>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
92893>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
92893>>>        Boolean bOK bIsSqlTable
92893>>>        String sFieldNameTo
92893>>>
92893>>>        If (num_arguments > 4) Begin
92895>>>            Move iPrec to iPrecFrom
92896>>>        End
92896>>>>
92896>>>        If (iTypeFrom < -1490) Begin
92898>>>            Move (iTypeFrom + 1500) to iTypeFrom
92899>>>        End
92899>>>>
92899>>>
92899>>>        Get AutoConnectionIDLogin to bOK
92900>>>        Move False to Err
92901>>>        Get OpenTableExclusive hTable to bOK
92902>>>        If (bOK = False) Begin
92904>>>            Function_Return False
92905>>>        End
92905>>>>
92905>>>
92905>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92906>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92907>>>        Field_Map hTable sFieldNameFrom to iColumn
92909>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92910>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92911>>>        If (Err = True) Begin
92913>>>            Function_Return False
92914>>>        End
92914>>>>
92914>>>
92914>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
92917>>>        Get UtilTableIsSQL hTable to bIsSqlTable
92918>>>        If (bIsSqlTable = False) Begin
92920>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
92923>>>        End
92923>>>>
92923>>>        Else Begin
92924>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
92927>>>        End
92927>>>>
92927>>>        // Let the driver decide the other values;
92927>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
92930>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
92933>>>
92933>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
92935>>>            Function_Return False
92936>>>        End
92936>>>>
92936>>>
92936>>>        Set Private.phCurrentTable to hTable
92937>>>        Set Private.piCurrentField to iColumn
92938>>>
92938>>>        Structure_Start hTable
92939>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
92942>>>//            If (bIsSqlTable = False) Begin
92942>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
92945>>>//            End
92945>>>//            Else Begin
92945>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
92945>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
92945>>>//            End
92945>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
92948>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
92951>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92952>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92954>>>
92954>>>        Set Action_Text of ghoStatusPanel to ""
92955>>>        Function_Return (Err = False)
92956>>>    End_Function
92957>>>
92957>>>    // Changes a field type, length and precision for the passed table number and field name
92957>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
92959>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
92959>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
92959>>>        String sFieldNameTo sDriverIDTo
92959>>>        tColumnType ColumnType
92959>>>        tColumnType ColumnType
92959>>>
92959>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
92960>>>        Get piDbType to iDbType
92961>>>        If (num_arguments > 4) Begin
92963>>>            Move iPrec to iPrecFrom
92964>>>            Move iOpt  to iOptionFrom
92965>>>        End
92965>>>>
92965>>>        If (iTypeFrom < -1490) Begin
92967>>>            Move (iTypeFrom + 1500) to iTypeFrom
92968>>>        End
92968>>>>
92968>>>
92968>>>        Get AutoConnectionIDLogin to bOK
92969>>>        Move False to Err
92970>>>        Close hTable
92971>>>        Get OpenTableExclusive hTable to bOK
92972>>>        If (bOK = False) Begin
92974>>>            Function_Return False
92975>>>        End
92975>>>>
92975>>>
92975>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
92978>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
92981>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
92982>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
92984>>>            Move DF_DATE to iDataFlexType
92985>>>        End
92985>>>>
92985>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
92988>>>
92988>>>        If (bIsSQLTableTo = True) Begin
92990>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
92993>>>        End
92993>>>>
92993>>>        Else Begin
92994>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
92997>>>        End
92997>>>>
92997>>>
92997>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
93000>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
93003>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
93006>>>
93006>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
93006>>>        // data types between Embedded and SQL, else we can't compare the data types.
93006>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
93008>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
93009>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93011>>>                Move DF_DATE to iTypeTo  
93012>>>            End
93012>>>>
93012>>>        End
93012>>>>
93012>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
93015>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
93016>>>        End
93016>>>>
93016>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
93017>>>
93017>>>        If (bCompareDate_DateTime = False) Begin
93019>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
93020>>>            If (bSkip = True) Begin
93022>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
93024>>>                    Function_Return True
93025>>>                End
93025>>>>
93025>>>            End
93025>>>>
93025>>>        End
93025>>>>
93025>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
93028>>>            Function_Return True
93029>>>        End
93029>>>>
93029>>>
93029>>>        Set Private.phCurrentTable to hTable
93030>>>        Set Private.piCurrentField to iColumn
93031>>>
93031>>>        Structure_Start hTable
93032>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
93034>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
93037>>>            End
93037>>>>
93037>>>
93037>>>            If (bIsSameDataType = False) Begin
93039>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
93042>>>                If (bIsSQLTableTo = True) Begin
93044>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
93047>>>                End
93047>>>>
93047>>>            End
93047>>>>
93047>>>
93047>>>            If (iLengthFrom <> iLengthTo) Begin
93049>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
93052>>>            End
93052>>>>
93052>>>            If (iPrecFrom <> iPrecTo) Begin
93054>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
93057>>>            End
93057>>>>
93057>>>
93057>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
93059>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
93059>>>                If (bRecnumTable = True) Begin
93061>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
93064>>>                End
93064>>>>
93064>>>
93064>>>                // We might need to create an index here.
93064>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
93064>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
93064>>>                // index update checking logic.
93064>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
93067>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
93069>>>                    Create_Index hTable At iIndex
93070>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
93073>>>                End
93073>>>>
93073>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
93076>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
93079>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
93082>>>                If (bIsSQLTableTo = True) Begin
93084>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
93087>>>                End
93087>>>>
93087>>>            End
93087>>>>
93087>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93088>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93090>>>
93090>>>        Set Action_Text of ghoStatusPanel to ""
93091>>>        Function_Return (Err = False)
93092>>>    End_Function
93093>>>
93093>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
93095>>>        Boolean bOK
93095>>>
93095>>>        Get AutoConnectionIDLogin to bOK
93096>>>        Move False to Err
93097>>>        Get OpenTableExclusive hTable to bOK
93098>>>        If (bOK = False) Begin
93100>>>            Function_Return False
93101>>>        End
93101>>>>
93101>>>
93101>>>        Structure_Start hTable
93102>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
93105>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93106>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93108>>>
93108>>>        Set Action_Text of ghoStatusPanel to ""
93109>>>        Function_Return (Err = False)
93110>>>    End_Function
93111>>>
93111>>>    // To move an existing field to another position in a table.
93111>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
93113>>>        String sColumn sDriverID
93113>>>        Integer iType
93113>>>        Boolean bOK bIsDate
93113>>>
93113>>>        Close hTable
93114>>>        Get AutoConnectionIDLogin to bOK
93115>>>        Get OpenTableExclusive hTable to bOK
93116>>>        If (bOK = False) Begin
93118>>>            Function_Return False
93119>>>        End
93119>>>>
93119>>>
93119>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93122>>>        If (sDriverID = DFBTRDRV_ID) Begin
93124>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
93125>>>>
93125>>>            Function_Return False
93126>>>        End
93126>>>>
93126>>>
93126>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
93129>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
93132>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
93133>>>
93133>>>        Set Private.phCurrentTable to hTable
93134>>>        Set Private.piCurrentField to iOld
93135>>>
93135>>>//        If (bIsDate = False) Begin
93135>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
93135>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
93135>>>//        End
93135>>>//        Else Begin
93135>>>//            Move 6 to iLength
93135>>>//            Move 0 to iPrecision
93135>>>//        End
93135>>>
93135>>>        Move False to Err
93136>>>
93136>>>        Structure_Start hTable
93137>>>            Delete_Field hTable iOld
93138>>>            Create_Field hTable At iNew
93139>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
93142>>>
93142>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
93145>>>            If (bIsSQLType = False) Begin
93147>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
93150>>>            End
93150>>>>
93150>>>            Else Begin
93151>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
93154>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
93154>>>            End
93154>>>>
93154>>>
93154>>>            If (bIsDate = False) Begin
93156>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
93159>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
93162>>>            End
93162>>>>
93162>>>
93162>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93163>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93165>>>
93165>>>        Set Action_Text of ghoStatusPanel to ""
93166>>>        Function_Return (Err = False)
93167>>>    End_Function
93168>>>
93168>>>    // Deletes a column name for the passed table number (and column number).
93168>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
93170>>>        Integer iColumn
93170>>>        Boolean bOK
93170>>>
93170>>>        Get AutoConnectionIDLogin to bOK
93171>>>        Move False to Err
93172>>>        Close hTable
93173>>>        Get OpenTableExclusive hTable to bOK
93174>>>        If (bOK = False) Begin
93176>>>            Function_Return False
93177>>>        End
93177>>>>
93177>>>
93177>>>        If (not(Err)) Begin
93179>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93180>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93181>>>            Field_Map hTable sFieldName to iColumn
93183>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93184>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93185>>>            If (iColumn = 0) Begin
93187>>>                Move 0 to LastErr
93188>>>                Function_Return False
93189>>>            End
93189>>>>
93189>>>            Move False to Err
93190>>>
93190>>>            Set Private.phCurrentTable to hTable
93191>>>            Set Private.piCurrentField to iColumn
93192>>>
93192>>>            Structure_Start hTable
93193>>>                Delete_Field hTable iColumn
93194>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93195>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93197>>>            Set Action_Text of ghoStatusPanel to ""
93198>>>        End
93198>>>>
93198>>>        Else Begin
93199>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
93200>>>>
93200>>>        End
93200>>>>
93200>>>
93200>>>        Function_Return (Err = False)
93201>>>    End_Function
93202>>>
93202>>>    // Renames a field for the passed table number & old field name & new field name
93202>>>    // Returns True if no errors occured.
93202>>>    // Sample usage:
93202>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
93202>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
93204>>>        Integer iField
93204>>>        Boolean bOK bExists bIsOpen
93204>>>
93204>>>        Get UtilColumnExists hTable sNewFieldName to bExists
93205>>>        If (bExists = True) Begin
93207>>>            Function_Return False
93208>>>        End
93208>>>>
93208>>>
93208>>>        // Note: The Field_Map command does _not_ work if the table has been
93208>>>        //       opened exclusively, so we first open it in normal mode.
93208>>>        Close hTable
93209>>>        Open hTable
93211>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93214>>>        If (bIsOpen = False) Begin
93216>>>            Function_Return False
93217>>>        End
93217>>>>
93217>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93218>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93219>>>        Field_Map hTable sOldFieldName to iField
93221>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93222>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93223>>>
93223>>>        Get AutoConnectionIDLogin to bOK
93224>>>        Get OpenTableExclusive hTable to bOK
93225>>>        If (bOK = False) Begin
93227>>>            Function_Return False
93228>>>        End
93228>>>>
93228>>>
93228>>>        Move False to Err
93229>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
93230>>>        Set Private.phCurrentTable to hTable
93231>>>        Set Private.piCurrentField to iField
93232>>>
93232>>>        If (iField > 0) Begin
93234>>>            Structure_Start hTable
93235>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
93238>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93239>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93241>>>        End
93241>>>>
93241>>>        Else Begin
93242>>>            Move 0 to LastErr
93243>>>            Move False to Err
93244>>>        End
93244>>>>
93244>>>
93244>>>        Set Action_Text of ghoStatusPanel to ""
93245>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
93246>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93247>>>
93247>>>        Function_Return (Err = False)
93248>>>    End_Function
93249>>>
93249>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93251>>>        tAPIColumnCompare[] aAPIColumnsToInsert
93251>>>        tAPIColumnCompare[] aAPIColumnsToInsert
93252>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
93252>>>        Boolean bRenameField
93252>>>
93252>>>        Open hTable
93254>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93255>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93256>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93257>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
93260>>>        Move (iSize max iNumberOfFieldsTo) to iSize
93261>>>        Decrement iSize
93262>>>        for iCount from 0 to iSize
93268>>>>
93268>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93270>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93271>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93272>>>
93272>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
93274>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
93276>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
93277>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
93278>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
93280>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
93281>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
93282>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
93283>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
93284>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
93285>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
93286>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
93287>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
93288>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
93289>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
93290>>>                        Increment iItem
93291>>>                    End
93291>>>>
93291>>>                End
93291>>>>
93291>>>            End
93291>>>>
93291>>>        Loop
93292>>>>
93292>>>
93292>>>        Move False to Err
93293>>>        Move 0 to LastErr
93294>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93295>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93296>>>        Function_Return aAPIColumnsToInsert
93297>>>    End_Function
93298>>>
93298>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
93300>>>        Integer iSize iCount
93300>>>        Boolean bOK
93300>>>        tAPIColumn[] aColumnsTo
93300>>>        tAPIColumn[] aColumnsTo
93301>>>        tAPIColumnCompare[] aAPIColumnCompare
93301>>>        tAPIColumnCompare[] aAPIColumnCompare
93302>>>
93302>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
93303>>>        If (iSize = 0) Begin
93305>>>            Function_Return True
93306>>>        End
93306>>>>
93306>>>
93306>>>        Move False to Err
93307>>>        Decrement iSize
93308>>>        for iCount from 0 to iSize
93314>>>>
93314>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
93315>>>        Loop
93316>>>>
93316>>>
93316>>>        Function_Return bOK
93317>>>    End_Function
93318>>>
93318>>>    // Returns a struct array with fields that has the same names but different field numbers.
93318>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93320>>>        tAPIColumnCompare[] aAPIColumnsToMove
93320>>>        tAPIColumnCompare[] aAPIColumnsToMove
93321>>>        Integer iSize iCount iItem iShouldMove
93321>>>
93321>>>        Move 0 to iItem
93322>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93323>>>        Decrement iSize
93324>>>        for iCount from 0 to iSize
93330>>>>
93330>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93332>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
93333>>>                If (iShouldMove <> -1) Begin
93335>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
93336>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
93337>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
93338>>>                    Increment iItem
93339>>>                End
93339>>>>
93339>>>            End
93339>>>>
93339>>>        Loop
93340>>>>
93340>>>
93340>>>        Move False to Err
93341>>>        Move 0 to LastErr
93342>>>        Function_Return aAPIColumnsToMove
93343>>>    End_Function
93344>>>
93344>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
93346>>>        Integer iSize iCount
93346>>>        Boolean bOK
93346>>>        tAPIColumnCompare[] aAPIColumnCompare
93346>>>        tAPIColumnCompare[] aAPIColumnCompare
93347>>>
93347>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
93348>>>        If (iSize = 0) Begin
93350>>>            Function_Return True
93351>>>        End
93351>>>>
93351>>>
93351>>>        Move False to Err
93352>>>        Decrement iSize
93353>>>        for iCount from 0 to iSize
93359>>>>
93359>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93360>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
93361>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
93363>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
93364>>>                Get UtilColumnsStructFill hTable to aColumnsTo
93365>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93366>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
93367>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
93369>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
93370>>>                    Decrement iSize
93371>>>                    Move 0 to iCount
93372>>>                End
93372>>>>
93372>>>            End
93372>>>>
93372>>>        Loop
93373>>>>
93373>>>
93373>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93374>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
93375>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
93377>>>            Move 0 to LastErr
93378>>>        End
93378>>>>
93378>>>        Function_Return bOK
93379>>>    End_Function
93380>>>
93380>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
93380>>>    // We then assume this field should be renamed.
93380>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
93380>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
93380>>>//
93380>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93380>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
93380>>>//
93380>>>//        If (bDifferentFieldNames = True) Begin
93380>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
93380>>>//            If (bShouldBeRenamed = False) Begin
93380>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93380>>>//                Function_Return False
93380>>>//            End
93380>>>//
93380>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
93380>>>//            If (bShouldBeRenamed = False) Begin
93380>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93380>>>//                Function_Return False
93380>>>//            End
93380>>>//
93380>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
93380>>>//            If (bShouldBeRenamed = False) Begin
93380>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93380>>>//                Function_Return False
93380>>>//            End
93380>>>//
93380>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
93380>>>//            If (bShouldBeRenamed = False) Begin
93380>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93380>>>//                Function_Return False
93380>>>//            End
93380>>>//        End
93380>>>//
93380>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
93380>>>//        Function_Return True
93380>>>//    End_Function
93380>>>
93380>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
93380>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
93380>>>    // - The "FROM" field name is <> "TO" field name
93380>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
93380>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
93380>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
93382>>>        Boolean bShouldRename
93382>>>        String sFieldNameFrom sFieldNameTo
93382>>>
93382>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
93383>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
93384>>>        If (sFieldNameFrom = sFieldNameTo) Begin
93386>>>            Function_Return False
93387>>>        End
93387>>>>
93387>>>
93387>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
93388>>>//        If (bShouldRename = False) Begin
93388>>>//            Function_Return False
93388>>>//        End
93388>>>//
93388>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
93388>>>//            Function_Return True
93388>>>//        End
93388>>>
93388>>>        Function_Return bShouldRename
93389>>>    End_Function
93390>>>
93390>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
93390>>>    // Else it returns the column/field number of the field that exists in another position.
93390>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
93392>>>        Integer iCount iSize iRetval
93392>>>        String sFieldNameFrom
93392>>>
93392>>>        Move -1 to iRetval
93393>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
93395>>>            Function_Return iRetval
93396>>>        End
93396>>>>
93396>>>
93396>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
93397>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93398>>>        Decrement iSize
93399>>>        for iCount from 0 to iSize
93405>>>>
93405>>>            // We're only interested in fields other than the passed field/column number:
93405>>>            If (iCount <> iColumn) Begin
93407>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
93409>>>                    Move (iCount + 1) to iRetval
93410>>>                End
93410>>>>
93410>>>            End
93410>>>>
93410>>>        Loop
93411>>>>
93411>>>
93411>>>        Move 0 to LastErr
93412>>>        Function_Return iRetval
93413>>>    End_Function
93414>>>
93414>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93416>>>        tAPIColumnCompare[] aAPIColumnsToRename
93416>>>        tAPIColumnCompare[] aAPIColumnsToRename
93417>>>        Integer iSize iCount iItem iFieldTo iShouldMove
93417>>>        Boolean bRenameField
93417>>>
93417>>>        Open hTable
93419>>>        Move 0 to iItem
93420>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93421>>>        Decrement iSize
93422>>>        for iCount from 0 to iSize
93428>>>>
93428>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93430>>>                // Check if the field exists in another position (other field number)
93430>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
93431>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
93432>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
93434>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
93435>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
93436>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
93437>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
93438>>>                    Increment iItem
93439>>>                End
93439>>>>
93439>>>            End
93439>>>>
93439>>>        Loop
93440>>>>
93440>>>
93440>>>        Move False to Err
93441>>>        Move 0 to LastErr
93442>>>        Function_Return aAPIColumnsToRename
93443>>>    End_Function
93444>>>
93444>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
93446>>>        Integer iSize iCount
93446>>>        Boolean bOK
93446>>>        tAPIColumn[] aColumnsTo
93446>>>        tAPIColumn[] aColumnsTo
93447>>>        tAPIColumnCompare[] aAPIColumnCompare
93447>>>        tAPIColumnCompare[] aAPIColumnCompare
93448>>>
93448>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
93449>>>        If (iSize = 0) Begin
93451>>>            Function_Return True
93452>>>        End
93452>>>>
93452>>>
93452>>>        Move False to Err
93453>>>        Decrement iSize
93454>>>        For iCount from 0 to iSize
93460>>>>
93460>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93461>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
93462>>>        Loop
93463>>>>
93463>>>
93463>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93464>>>        Function_Return bOK
93465>>>    End_Function
93466>>>
93466>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
93468>>>        Boolean bDateType
93468>>>
93468>>>        If (bIsSQLTableTo = True) Begin
93470>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
93471>>>        End
93471>>>>
93471>>>        Else Begin
93472>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
93473>>>        End
93473>>>>
93473>>>
93473>>>        Function_Return bDateType
93474>>>    End_Function
93475>>>
93475>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
93477>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
93477>>>        Integer iCount2 iColumn2
93477>>>        Handle hFile
93477>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
93477>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
93477>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
93477>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
93477>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
93482>>>        tColumnType ColumnType
93482>>>        tColumnType ColumnType
93482>>>
93482>>>        Move False to Err
93483>>>        Close hTable
93484>>>        Get OpenTableExclusive hTable to bIsOpen
93485>>>        If (bIsOpen = False) Begin
93487>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
93488>>>>
93488>>>            Function_Return False
93489>>>        End 
93489>>>>
93489>>>        
93489>>>        Get piDbType to iDbType
93490>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
93493>>>        Move bIsSQLTableFrom to bIsSQLDriver
93494>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
93495>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
93498>>>
93498>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93499>>>
93499>>>        // Before we start to change the table we need to do three things;
93499>>>        // 1) Insert any new fields
93499>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
93500>>>        If (SizeOfArray(aApiInsertColumns)) Begin
93502>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
93503>>>            If (bOK = False) Begin
93505>>>                Function_Return False
93506>>>            End
93506>>>>
93506>>>            // Update info with changes made.
93506>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93507>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93508>>>        End
93508>>>>
93508>>>
93508>>>        // 2) Move fields with same names
93508>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
93509>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
93511>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
93512>>>            If (bOK = False) Begin
93514>>>                Function_Return False
93515>>>            End
93515>>>>
93515>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93516>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93517>>>        End
93517>>>>
93517>>>        
93517>>>        // 3) Rename fields
93517>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
93518>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
93520>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
93521>>>            If (bOK = False) Begin
93523>>>                Function_Return False
93524>>>            End
93524>>>>
93524>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93525>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93526>>>        End
93526>>>>
93526>>>
93526>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
93526>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
93526>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
93526>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
93526>>>//            If (bOK = False) Begin
93526>>>//                Function_Return False
93526>>>//            End
93526>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
93526>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93526>>>//        End
93526>>>
93526>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
93526>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
93528>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
93529>>>            If (bIsSame = True) Begin
93531>>>                Function_Return True
93532>>>            End
93532>>>>
93532>>>        End
93532>>>>
93532>>>
93532>>>        // We can now continue to make standard field changes:
93532>>>        Get OpenTableExclusive hTable to bIsOpen
93533>>>        Set Private.phCurrentTable to hTable
93534>>>        Move hTable to hFile
93535>>>        Structure_Start hFile sDriverIDTo
93536>>>
93536>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
93537>>>            Decrement iColumns
93538>>>            for iCount from 0 to iColumns
93544>>>>
93544>>>                Send DoAdvance of ghoProgressBar
93545>>>
93545>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
93546>>>                Set Private.piCurrentField                  to iColumn
93547>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
93548>>>                If (bIsSame = False) Begin
93550>>>
93550>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
93551>>>                    If (bFieldExistsFrom = True) Begin
93553>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
93554>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
93555>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
93556>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
93557>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
93558>>>
93558>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
93559>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
93560>>>                        If (iTypeFrom < -1490) Begin
93562>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
93563>>>                        End
93563>>>>
93563>>>
93563>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
93563>>>                        // data types between Embedded and SQL, else we can't compare the data types.
93563>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
93565>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
93566>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93568>>>                                Move DF_DATE to iTypeFrom
93569>>>                            End
93569>>>>
93569>>>                        End
93569>>>>
93569>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
93572>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
93573>>>                        End
93573>>>>
93573>>>
93573>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
93574>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
93575>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
93576>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
93577>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
93578>>>
93578>>>                        Move False to bSkipTypeChange
93579>>>                        If (bCompareDate_DateTime = False) Begin
93581>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
93582>>>                        End
93582>>>>
93582>>>
93582>>>                        If (bFieldExistsTo = False) Begin
93584>>>                            Move 0 to iColumn
93585>>>                            Create_Field hFile At iColumn
93586>>>                            Set Private.piCurrentField to iColumn
93587>>>                        End
93587>>>>
93587>>>
93587>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
93589>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
93592>>>                        End
93592>>>>
93592>>>
93592>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
93594>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
93597>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
93598>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
93600>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
93601>>>                            End
93601>>>>
93601>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
93604>>>                        End
93604>>>>
93604>>>
93604>>>                        If (bSkipTypeChange = False) Begin
93606>>>                            If (iTypeFrom <> iTypeTo) Begin
93608>>>                                If (bIsSQLTableTo = True) Begin
93610>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
93613>>>                                End
93613>>>>
93613>>>                                Else Begin                                                   
93614>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93616>>>                                        Move DF_DATE to iDataFlexType  // Date
93617>>>                                    End
93617>>>>
93617>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
93620>>>                                End
93620>>>>
93620>>>                            End
93620>>>>
93620>>>                        End
93620>>>>
93620>>>
93620>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
93621>>>                        // We can't set the length or precision for Date type columns (they are fixed).
93621>>>                        If (bIsDateType = False) Begin
93623>>>                            If (iLengthFrom <> iLengthTo) Begin
93625>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
93628>>>                            End
93628>>>>
93628>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
93630>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
93633>>>                            End
93633>>>>
93633>>>                        End
93633>>>>
93633>>>
93633>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
93635>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
93635>>>                            If (bRecnumTable = True) Begin
93637>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
93640>>>                            End
93640>>>>
93640>>>
93640>>>                            // We might need to create an index here.
93640>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
93640>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
93640>>>                            // index update checking logic.
93640>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
93643>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
93645>>>                                Create_Index hFile at iIndex
93646>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
93649>>>                            End
93649>>>>
93649>>>
93649>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
93652>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
93655>>>                                // Note: The order of these two are crucial!
93655>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
93658>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
93661>>>                        End
93661>>>>
93661>>>                    End
93661>>>>
93661>>>                    Else Begin
93662>>>                        Delete_Field hFile iColumn
93663>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
93664>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
93665>>>                        Decrement iCount2
93666>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
93666>>>                        // starting with the array number we just deleted the field for.
93666>>>                        for iColumn2 from iCount to iCount2
93672>>>>
93672>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
93673>>>                        Loop
93674>>>>
93674>>>                        Decrement iCount
93675>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93676>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
93677>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
93679>>>                            Move iColumns to iCount 
93680>>>                        End
93680>>>>
93680>>>                    End
93680>>>>
93680>>>                End
93680>>>>
93680>>>            Loop
93681>>>>
93681>>>
93681>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93682>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93684>>>
93684>>>        Set Action_Text of ghoStatusPanel to ""
93685>>>        Function_Return (Err = False)
93686>>>    End_Function
93687>>>
93687>>>    // * Dummy function for the Studio's Code Explorer *
93687>>>    Function API_INDEX_FUNCTIONS Returns Boolean
93689>>>        Function_Return False
93690>>>    End_Function
93691>>>
93691>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
93691>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
93691>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
93691>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
93693>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
93693>>>        String sDriverID
93693>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
93693>>>
93693>>>        Get AutoConnectionIDLogin to bOK
93694>>>        Get OpenTableExclusive hTable to bOK
93695>>>        If (bOK = False) Begin
93697>>>            Function_Return False
93698>>>        End
93698>>>>
93698>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93701>>>
93701>>>            Get UtilTableIsSQL hTable to bIsSQLTable
93702>>>            If (bIsSQLTable = True) Begin
93704>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
93707>>>            End
93707>>>>
93707>>>
93707>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
93708>>>            If (bIsMertechDriver = True) Begin
93710>>>                Get_Attribute DF_INDEX_NATIVE_CREATED of hTable iIndex to bExists
93713>>>            End
93713>>>>
93713>>>            Else Begin
93714>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
93717>>>                Move (iIndexSegments > 0) to bExists
93718>>>            End
93718>>>>
93718>>>        If (bExists = True) Begin
93720>>>            Function_Return True
93721>>>        End
93721>>>>
93721>>>
93721>>>        Move -1 to iSegment1
93722>>>        Move -1 to iSegment2
93723>>>        Move -1 to iSegment3
93724>>>        Move -1 to iSegment4
93725>>>        Move -1 to iSegment5
93726>>>        Move -1 to iSegment6
93727>>>        Move -1 to iSegment7
93728>>>        Move -1 to iSegment8
93729>>>        Move -1 to iSegment9
93730>>>        Move -1 to iSegment10
93731>>>
93731>>>        If (num_arguments > 3) Begin
93733>>>            Move iSgmnt1 to iSegment1
93734>>>        End
93734>>>>
93734>>>        If (num_arguments > 4) Begin
93736>>>            Move iSgmnt2 to iSegment2
93737>>>        End
93737>>>>
93737>>>        If (num_arguments > 5) Begin
93739>>>            Move iSgmnt3 to iSegment3
93740>>>        End
93740>>>>
93740>>>        If (num_arguments > 6) Begin
93742>>>            Move iSgmnt4 to iSegment4
93743>>>        End
93743>>>>
93743>>>        If (num_arguments > 7) Begin
93745>>>            Move iSgmnt5 to iSegment5
93746>>>        End
93746>>>>
93746>>>        If (num_arguments > 8) Begin
93748>>>            Move iSgmnt6 to iSegment6
93749>>>        End
93749>>>>
93749>>>        If (num_arguments > 9) Begin
93751>>>            Move iSgmnt7 to iSegment7
93752>>>        End
93752>>>>
93752>>>        If (num_arguments > 10) Begin
93754>>>            Move iSgmnt8 to iSegment8
93755>>>        End
93755>>>>
93755>>>        If (num_arguments > 11) Begin
93757>>>            Move iSgmnt9 to iSegment9
93758>>>        End
93758>>>>
93758>>>        If (num_arguments > 12) Begin
93760>>>            Move iSgmnt10 to iSegment10
93761>>>        End
93761>>>>
93761>>>
93761>>>        Move False to Err
93762>>>        Move hTable to iTableNo
93763>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93764>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
93765>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
93766>>>
93766>>>        // We start by deleting the index, if it exists.
93766>>>        If (bExists = True) Begin
93768>>>            Structure_Start hTable sDriverID
93769>>>                Delete_Index iTableNo iIndex
93770>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93771>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93773>>>        End
93773>>>>
93773>>>
93773>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93774>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
93775>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
93776>>>        Set Action_Text of ghoStatusPanel to ""
93777>>>        Move False to Err
93778>>>        Move 0 to LastErr
93779>>>
93779>>>        // Need to re-open if index deleted.
93779>>>        Move iTableNo to hTable
93780>>>        Get OpenTableExclusive hTable to bOK
93781>>>        If (bOK = False) Begin
93783>>>            Function_Return False
93784>>>        End
93784>>>>
93784>>>
93784>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93785>>>        Structure_Start hTable sDriverID
93786>>>            Create_Index hTable At iIndex
93787>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
93790>>>
93790>>>            If (iSgmnt1 <> -1) Begin
93792>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
93795>>>            End
93795>>>>
93795>>>            If (iSegment2 <> -1) Begin
93797>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
93800>>>            End
93800>>>>
93800>>>            If (iSegment3 <> -1) Begin
93802>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
93805>>>            End
93805>>>>
93805>>>            If (iSegment4 <> -1) Begin
93807>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
93810>>>            End
93810>>>>
93810>>>            If (iSegment5 <> -1) Begin
93812>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
93815>>>            End
93815>>>>
93815>>>            If (iSegment6 <> -1) Begin
93817>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
93820>>>            End
93820>>>>
93820>>>            If (iSegment7 <> -1) Begin
93822>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
93825>>>            End
93825>>>>
93825>>>            If (iSegment8 <> -1) Begin
93827>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
93830>>>            End
93830>>>>
93830>>>            If (iSegment9 <> -1) Begin
93832>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
93835>>>            End
93835>>>>
93835>>>            If (iSegment10 <> -1) Begin
93837>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
93840>>>            End
93840>>>>
93840>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93841>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93843>>>
93843>>>        Set Action_Text of ghoStatusPanel to ""
93844>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93845>>>
93845>>>        Function_Return (Err = False)
93846>>>    End_Function
93847>>>
93847>>>    // Example:
93847>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
93847>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
93847>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
93849>>>        Integer iTableNo iNumSgmnt iNumSgmnts
93849>>>        String sDriverID
93849>>>        Boolean bOK bIsSQLTable
93849>>>
93849>>>        Get AutoConnectionIDLogin to bOK
93850>>>
93850>>>        Move False to Err
93851>>>        Move hTable to iTableNo
93852>>>        Get OpenTableExclusive hTable to bOK
93853>>>        If (bOK = False) Begin
93855>>>            Function_Return False
93856>>>        End
93856>>>>
93856>>>
93856>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93859>>>            Get UtilTableIsSQL hTable to bIsSQLTable
93860>>>            If (bIsSQLTable = True) Begin
93862>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
93865>>>            End
93865>>>>
93865>>>
93865>>>        // We start by deleting the index
93865>>>        Structure_Start hTable sDriverID
93866>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93867>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
93868>>>            Delete_Index iTableNo iIndex
93869>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93870>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
93871>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
93873>>>
93873>>>        Move False to Err
93874>>>        Move iTableNo to hTable
93875>>>        Get OpenTableExclusive hTable to bOK
93876>>>        If (bOK = False) Begin
93878>>>            Function_Return False
93879>>>        End
93879>>>>
93879>>>
93879>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93880>>>        Structure_Start hTable sDriverID
93881>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
93882>>>
93882>>>            Create_Index hTable at iIndex
93883>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
93886>>>
93886>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
93892>>>>
93892>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
93895>>>            Loop
93896>>>>
93896>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
93898>>>
93898>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93899>>>
93899>>>        Function_Return (Err = False)
93900>>>    End_Function
93901>>>
93901>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
93903>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
93903>>>        String sDriverID sSQLIndexName
93903>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
93903>>>
93903>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
93904>>>        If (iSegmentsFrom = 0) Begin
93906>>>            Function_Return False
93907>>>        End
93907>>>>
93907>>>
93907>>>        Get AutoConnectionIDLogin to bOK
93908>>>        Move False to Err
93909>>>        Get OpenTableExclusive hTable to bIsOpen
93910>>>        If (bIsOpen = False) Begin
93912>>>            Function_Return False
93913>>>        End
93913>>>>
93913>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93916>>>        Get UtilTableIsSql hTable to bIsSQLTable
93917>>>            If (bIsSQLTable = True) Begin
93919>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
93922>>>            End
93922>>>>
93922>>>
93922>>>        Move 0     to iSegmentsTo
93923>>>        Move 0     to iSQLIndexType
93924>>>        Move ""    to sSQLIndexName
93925>>>        Move False to bIsSQLTemporaryIndex
93926>>>        Move False to bIsSQLPrimaryKey
93927>>>        Move False to bIsSQLClustered
93928>>>
93928>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
93929>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
93932>>>        Move (iSegmentsTo > 0) to bExists
93933>>>        If (bExists = True) Begin
93935>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
93937>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
93940>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
93943>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
93944>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
93947>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
93950>>>            End
93950>>>>
93950>>>        End
93950>>>>
93950>>>
93950>>>        Move hTable to iTableNo
93951>>>        Move False to Err
93952>>>        Move 0 to LastErr
93953>>>
93953>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
93953>>>        //       _outside_ the Structure_Start/End construct.
93953>>>//        Move False to bIsSQLTemporaryIndex
93953>>>//        #IF (!@ > 170)
93953>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
93953>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
93953>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
93953>>>//                End
93953>>>//            End
93953>>>//        #ENDIF
93953>>>
93953>>>        Structure_Start hTable sDriverID
93954>>>            If (bExists = True) Begin
93956>>>                Delete_Index iTableNo APIIndex.iIndexNumber
93957>>>            End
93957>>>>
93957>>>
93957>>>            Create_Index hTable At APIIndex.iIndexNumber
93958>>>
93958>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
93960>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
93963>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
93966>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
93969>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
93972>>>            End
93972>>>>
93972>>>
93972>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
93975>>>
93975>>>            for iCount from 0 to (iSegmentsFrom -1)
93981>>>>
93981>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
93982>>>                If (iFieldFrom <> -1 ) Begin
93984>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
93987>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
93990>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
93993>>>                End
93993>>>>
93993>>>            Loop
93994>>>>
93994>>>
93994>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93995>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93997>>>
93997>>>        Set Action_Text of ghoStatusPanel to ""
93998>>>
93998>>>        Function_Return (Err = False)
93999>>>    End_Function
94000>>>
94000>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
94000>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
94000>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
94002>>>        Integer iLastIndex iCount iTableNo iSegments
94002>>>        String sSQLIndexNameCompare sTmpIndexName
94002>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
94002>>>
94002>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
94002>>>        // so we can then not rename the index.
94002>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
94003>>>        If (bIsMertechDriver = True) Begin
94005>>>            Function_Return False
94006>>>        End    
94006>>>>
94006>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
94007>>>        
94007>>>        If (bIsSQLDriver = False) Begin
94009>>>            Function_Return False
94010>>>        End
94010>>>>
94010>>>
94010>>>        Move False to Err
94011>>>        Move hTable to iTableNo
94012>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
94015>>>        for iCount from 0 to iLastIndex
94021>>>>
94021>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
94024>>>            Move (iSegments > 0) to bExists
94025>>>            If (bExists = True) Begin
94027>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
94030>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
94032>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
94033>>>                    Structure_Start iTableNo sDriverID
94034>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
94037>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94039>>>                    Open hTable
94041>>>                End
94041>>>>
94041>>>            End
94041>>>>
94041>>>        Loop
94042>>>>
94042>>>
94042>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94045>>>        If (bIsOpen = False) Begin
94047>>>            Get OpenTableExclusive hTable to bIsOpen
94048>>>        End
94048>>>>
94048>>>        If (bIsOpen = False) Begin
94050>>>            Function_Return False
94051>>>        End
94051>>>>
94051>>>
94051>>>        Function_Return (Err = False)
94052>>>    End_Function
94053>>>
94053>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
94053>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
94053>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
94055>>>        Integer iSize iCount
94055>>>        Integer iRetVal
94055>>>
94055>>>        Move 0 to iRetVal
94056>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
94059>>>        If (iRetVal = 0) Begin
94061>>>            Function_Return 0
94062>>>        End
94062>>>>
94062>>>        Move (SizeOfArray(APIIndexTo)) to iSize
94063>>>        Decrement iSize
94064>>>        for iCount from 0 to iSize
94070>>>>
94070>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
94072>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
94074>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
94075>>>                End
94075>>>>
94075>>>            End
94075>>>>
94075>>>        Loop
94076>>>>
94076>>>
94076>>>        Function_Return iRetVal
94077>>>    End_Function
94078>>>
94078>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
94080>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
94080>>>        Boolean bIsSQLTable
94080>>>        
94080>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94081>>>            If (bIsSQLTable = True) Begin
94083>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94086>>>            End
94086>>>>
94086>>>
94086>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94089>>>        If (iSegment = iNumSegments) Begin
94091>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94091>>>        End
94091>>>>
94091>>>
94091>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94094>>>            for iCurSegment from iSegment to (iNumSegments - 1)
94100>>>>
94100>>>                //*** Move index segment attributes
94100>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94103>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94106>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94109>>>
94109>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
94112>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
94115>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
94118>>>            Loop
94119>>>>
94119>>>
94119>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94122>>>        End
94122>>>>
94122>>>
94122>>>        Function_Return (Err = False)
94123>>>    End_Function
94124>>>
94124>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
94126>>>        Integer iCount iSize iIndex
94126>>>        String sDriverID
94126>>>        Boolean bOK bIsSQLTable bIsOpen
94126>>>
94126>>>        Move (SizeOfArray(APIIndex)) to iSize
94127>>>        If (iSize = 0) Begin
94129>>>            Function_Return True
94130>>>        End
94130>>>>
94130>>>
94130>>>        Get AutoConnectionIDLogin to bOK
94131>>>        Move False to Err
94132>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94135>>>        If (bIsOpen = False) Begin
94137>>>            Get OpenTableExclusive hTable to bIsOpen
94138>>>            If (bIsOpen = False) Begin
94140>>>                Function_Return False
94141>>>            End
94141>>>>
94141>>>        End
94141>>>>
94141>>>
94141>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94144>>>        Get UtilTableIsSql hTable to bIsSQLTable
94145>>>            If (bIsSQLTable = True) Begin
94147>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94150>>>            End
94150>>>>
94150>>>
94150>>>        Move False to Err
94151>>>        Move 0 to LastErr
94152>>>        Decrement iSize
94153>>>
94153>>>        Structure_Start hTable sDriverID
94154>>>            for iCount from 0 to iSize
94160>>>>
94160>>>//                Move False to bIsSQLPrimaryKey
94160>>>//                #IF (!@ > 180)   // DF 18.1 and up
94160>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94160>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
94160>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
94160>>>//                #ENDIF
94160>>>                // We can't delete if this is a primary key index:
94160>>>//                If (bIsSQLPrimaryKey = False) Begin
94160>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
94161>>>                    Delete_Index hTable iIndex
94162>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
94162>>>//                End
94162>>>            Loop
94163>>>>
94163>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94164>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94166>>>//        Move False to Err
94166>>>        Move 0 to LastErr
94167>>>
94167>>>        Set Action_Text of ghoStatusPanel to ""
94168>>>        Function_Return (Err = False)
94169>>>    End_Function
94170>>>
94170>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
94172>>>        Boolean bOK
94172>>>
94172>>>        Get AutoConnectionIDLogin to bOK
94173>>>        Move False to Err
94174>>>        Get OpenTableExclusive hTable to bOK
94175>>>        If (bOK = False) Begin
94177>>>            Function_Return False
94178>>>        End
94178>>>>
94178>>>        Structure_Start hTable
94179>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
94182>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94183>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94185>>>
94185>>>        Set Action_Text of ghoStatusPanel to ""
94186>>>        Function_Return (Err = False)
94187>>>    End_Function
94188>>>
94188>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
94190>>>        Integer iCase
94190>>>        Boolean bOK
94190>>>
94190>>>        If (bUppercase = True) Begin
94192>>>            Move DF_CASE_IGNORED to iCase
94193>>>        End
94193>>>>
94193>>>        Else Begin
94194>>>            Move DF_CASE_USED to iCase
94195>>>        End
94195>>>>
94195>>>
94195>>>        Get AutoConnectionIDLogin to bOK
94196>>>        Move False to Err
94197>>>        Get OpenTableExclusive hTable to bOK
94198>>>        If (bOK = False) Begin
94200>>>            Function_Return False
94201>>>        End
94201>>>>
94201>>>        Structure_Start hTable
94202>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
94205>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94206>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94208>>>
94208>>>        Set Action_Text of ghoStatusPanel to ""
94209>>>        Function_Return (Err = False)
94210>>>    End_Function
94211>>>
94211>>>    // To delete an index
94211>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
94213>>>        Integer iTableNo iNumSegments
94213>>>        String sDriverID
94213>>>        Boolean bOK bIsSQLTable
94213>>>
94213>>>        Get AutoConnectionIDLogin to bOK
94214>>>        Move False to Err
94215>>>        Move hTable to iTableNo
94216>>>        Get OpenTableExclusive hTable to bOK
94217>>>        If (bOK = False) Begin
94219>>>            Function_Return False
94220>>>        End
94220>>>>
94220>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94223>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94224>>>            If (bIsSQLTable = True) Begin
94226>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94229>>>            End
94229>>>>
94229>>>
94229>>>        // Check to see if the index exists or not...
94229>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94232>>>        If (iNumSegments = 0) Begin
94234>>>            Function_Return True // Then nothing to do.
94235>>>        End
94235>>>>
94235>>>
94235>>>        Structure_Start hTable sDriverID
94236>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
94237>>>            Delete_Index iTableNo iIndex
94238>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
94239>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94240>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94242>>>
94242>>>        Set Action_Text of ghoStatusPanel to ""
94243>>>        Function_Return (Err = False)
94244>>>    End_Function
94245>>>
94245>>>    // Delete an Index Segment
94245>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
94247>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
94247>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
94247>>>        Integer iIndexType
94247>>>        String sDriverID
94247>>>
94247>>>        Get AutoConnectionIDLogin to bOK
94248>>>        Move False to Err
94249>>>
94249>>>        Get OpenTableExclusive hTable to bOK
94250>>>        If (bOK = False) Begin
94252>>>            Function_Return False
94253>>>        End
94253>>>>
94253>>>
94253>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94254>>>            If (bIsSQLTable = True) Begin
94256>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94259>>>            End
94259>>>>
94259>>>
94259>>>        // Check to see if the index exists or not...
94259>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94262>>>        If (iNumSegments = 0) Begin
94264>>>            Function_Return False
94265>>>        End
94265>>>>
94265>>>
94265>>>        Move False to bIndexTemporary
94266>>>        Get psDriverID to sDriverID
94267>>>        Get IsSQLDriver sDriverID to bSQLDriver
94268>>>        If (bSQLDriver) Begin
94270>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
94273>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
94276>>>                Move True to bIndexTemporary
94277>>>        End
94277>>>>
94277>>>
94277>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
94277>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
94279>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94282>>>            If (iSegment = iNumSegments) Begin
94284>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94287>>>            End
94287>>>>
94287>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94290>>>                For iCurSegment from iSegment to (iNumSegments - 1)
94296>>>>
94296>>>                    //*** Move index segment attributes
94296>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94299>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94302>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94305>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94308>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94311>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94314>>>                Loop
94315>>>>
94315>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94318>>>            End
94318>>>>
94318>>>        End
94318>>>>
94318>>>
94318>>>        Else Begin
94319>>>           Structure_Start hTable
94320>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94323>>>               If (iSegment = iNumSegments) Begin
94325>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94328>>>               End
94328>>>>
94328>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94331>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
94337>>>>
94337>>>                       //*** Move index segment attributes
94337>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94340>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94343>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94346>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94349>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94352>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94355>>>                   Loop
94356>>>>
94356>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94359>>>               End
94359>>>>
94359>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
94360>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94362>>>            Set Action_Text of ghoStatusPanel to ""
94363>>>        End
94363>>>>
94363>>>
94363>>>        Function_Return (Err = False)
94364>>>    End_Function
94365>>>
94365>>>    // Add/Insert an Index Segment
94365>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
94367>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
94367>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
94367>>>        Integer iIndexType
94367>>>        String sDriverId
94367>>>
94367>>>        Get AutoConnectionIDLogin to bOK
94368>>>        Move False to Err
94369>>>
94369>>>        Get OpenTableExclusive hTable to bOK
94370>>>        If (bOK = False) Begin
94372>>>            Function_Return False
94373>>>        End
94373>>>>
94373>>>
94373>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94374>>>            If (bIsSQLTable = True) Begin
94376>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94379>>>            End
94379>>>>
94379>>>
94379>>>        Move False to bIndexTemporary
94380>>>        // Check to see if the index exists or not...
94380>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94383>>>        If (iNumSegments = 0) Begin
94385>>>            Function_Return False
94386>>>        End
94386>>>>
94386>>>
94386>>>        Get psDriverID to sDriverID
94387>>>        Get IsSQLDriver sDriverID to bSQLDriver
94388>>>        If (bSQLDriver) Begin
94390>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
94393>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
94396>>>                Move True to bIndexTemporary
94397>>>        End
94397>>>>
94397>>>
94397>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
94397>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
94399>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94402>>>
94402>>>           If (iSegment > iNumSegments) Begin
94404>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94407>>>               Move (iNumSegments + 1) to iCurSegment
94408>>>           End
94408>>>>
94408>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
94411>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94414>>>               Move iNumSegments to iCurSegment
94415>>>
94415>>>               While (iCurSegment > iSegment)
94419>>>                   //*** Move index segment attributes
94419>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
94422>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
94425>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
94428>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
94431>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
94434>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
94437>>>                   Decrement iCurSegment
94438>>>               Loop
94439>>>>
94439>>>
94439>>>               //*** Now set new segment attributes
94439>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
94442>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
94445>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
94448>>>           End
94448>>>>
94448>>>        End
94448>>>>
94448>>>
94448>>>        Else Begin
94449>>>        Structure_Start hTable
94450>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94453>>>
94453>>>            If (iSegment > iNumSegments) Begin
94455>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94458>>>                Move (iNumSegments + 1) to iCurSegment
94459>>>            End
94459>>>>
94459>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
94462>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94465>>>                Move iNumSegments to iCurSegment
94466>>>
94466>>>                While (iCurSegment > iSegment)
94470>>>                    //*** Move index segment attributes
94470>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
94473>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
94476>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
94479>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94482>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94485>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94488>>>                    Decrement iCurSegment
94489>>>                Loop
94490>>>>
94490>>>
94490>>>                //*** Now set new segment attributes
94490>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
94493>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
94496>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
94499>>>            End
94499>>>>
94499>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94500>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94502>>>            Set Action_Text of ghoStatusPanel to ""
94503>>>        End
94503>>>>
94503>>>
94503>>>        Function_Return (Err = False)
94504>>>    End_Function
94505>>>
94505>>>    // * Dummy function for the Studio's Code Explorer *
94505>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
94507>>>        Function_Return False
94508>>>    End_Function  
94509>>>    
94509>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
94509>>>    // for an SQL conversion.
94509>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
94511>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
94511>>>        
94511>>>        Move True to bConvertTo30FormatbOK
94512>>>        Move True to bRepairAndReindexOK
94513>>>        Move True to bFixBogusDatesOK
94514>>>        Move True to bMoveMiscFilesToBackupOK
94515>>>        
94515>>>        If (bMoveMiscFilesToBackup = True) Begin   
94517>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
94518>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
94519>>>        End                                                                                
94519>>>>
94519>>>        If (bFixALLBogusFilelistEntries = True) Begin
94521>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
94522>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
94523>>>        End
94523>>>>
94523>>>        If (bConvertTo30Format = True) Begin
94525>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
94526>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
94527>>>        End                                                 
94527>>>>
94527>>>        If (bRepairAndReindex = True) Begin
94529>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
94530>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
94531>>>        End  
94531>>>>
94531>>>        If (bFixBogusDates = True) Begin
94533>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
94534>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
94535>>>        End                                    
94535>>>>
94535>>>        
94535>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
94536>>>    End_Function
94537>>>
94537>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
94539>>>        Boolean bOK bFlexErrs bTemp
94539>>>        Handle hTable
94539>>>        String sTableName
94539>>>        Integer iCount iSize
94539>>>        
94539>>>        Move True to bOK
94540>>>        Move 0 to hTable    
94541>>>
94541>>>        Get UtilFilelistNoOfTables to iSize
94542>>>        Set pbVisible    of ghoProgressBarOverall to True
94543>>>        Set piPosition   of ghoProgressBarOverall to 0
94544>>>        Set piMaximum    of ghoProgressBarOverall to iSize
94545>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
94546>>>
94546>>>        Repeat
94546>>>>
94546>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
94547>>>            Set piPosition of ghoProgressBarOverall to iCount  
94548>>>            Increment iCount
94549>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94552>>>            If (hTable > 0) Begin
94554>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94557>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94558>>>                If (bFlexErrs = False) Begin
94560>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
94561>>>                    If (bTemp = False) Begin
94563>>>                        Move False to bOK
94564>>>                    End
94564>>>>
94564>>>                End
94564>>>>
94564>>>            End
94564>>>>
94564>>>        Until (hTable = 0)
94566>>>        
94566>>>        Set Action_Text of ghoStatusPanel to ""
94567>>>        Function_Return bOK
94568>>>    End_Function
94569>>>    
94569>>>    // Converts an embedded table from 2.3 -> 3.0.
94569>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
94569>>>    // It will return a TRUE if successful or the table is an SQL table.
94569>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
94571>>>        Boolean bOK bIsEmbedded bIsAlias
94571>>>        String sRevision
94571>>>        
94571>>>        Get AutoConnectionIDLogin to bOK
94572>>>        If (bOK = False) Begin
94574>>>            Function_Return True
94575>>>        End
94575>>>>
94575>>>        Get OpenTableExclusive hTable to bOK
94576>>>        If (bOK = False) Begin
94578>>>            Function_Return True
94579>>>        End
94579>>>>
94579>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
94580>>>        If (bIsEmbedded = False) Begin
94582>>>            Function_Return True
94583>>>        End                             
94583>>>>
94583>>>        Get UtilTableIsAlias hTable to bIsAlias
94584>>>        If (bIsAlias = True) Begin
94586>>>            Function_Return True
94587>>>        End                     
94587>>>>
94587>>>        
94587>>>        Move False to Err
94588>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
94591>>>        If (sRevision contains "2.3") Begin
94593>>>            Move False to Err
94594>>>            Set Private.phCurrentTable to hTable
94595>>>            Structure_Start hTable    
94596>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
94599>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
94600>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
94602>>>            Set Action_Text of ghoStatusPanel to ""
94603>>>        End
94603>>>>
94603>>>        
94603>>>        Function_Return (Err = False)
94604>>>    End_Function
94605>>>
94605>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
94607>>>        Boolean bIgnore bExists bOK bResponse
94607>>>        Handle hTable   
94607>>>        String sTableName
94607>>>        
94607>>>        Move False to Err 
94608>>>        Move True to bOK
94609>>>        Move 0 to hTable
94610>>>        Repeat
94610>>>>
94610>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94613>>>            If (hTable > 0) Begin
94615>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94618>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
94619>>>                If (bIgnore = False) Begin
94621>>>                    Get UtilTableExists hTable to bExists
94622>>>                    If (bExists = False) Begin
94624>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
94625>>>                        If (bResponse = False) Begin
94627>>>                            Move False to bOK
94628>>>                        End
94628>>>>
94628>>>                        
94628>>>                    End
94628>>>>
94628>>>                End
94628>>>>
94628>>>            End
94628>>>>
94628>>>        Until (hTable = 0)                     
94630>>>        
94630>>>        Set Action_Text of ghoStatusPanel to "" 
94631>>>        Function_Return bOK
94632>>>    End_Function
94633>>>    
94633>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
94633>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
94633>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
94633>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
94633>>>    //
94633>>>    // The root of the problem is the following:
94633>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
94633>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
94633>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
94633>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
94633>>>    // an SQL error will be thrown;
94633>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
94633>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
94635>>>        Boolean bOK bIsAlias bIsSQL
94635>>>        Integer iCount iSize iDateSize
94635>>>        Handle hTable
94635>>>        String sLogicalName
94635>>>        Integer[] aTablesToCheck aDateFields
94637>>>
94637>>>        Get _AllTablesDateCorrections to aTablesToCheck
94638>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
94639>>>        Set pbVisible    of ghoProgressBarOverall to True
94640>>>        Set piPosition   of ghoProgressBarOverall to 0
94641>>>        Set piMaximum    of ghoProgressBarOverall to iSize
94642>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
94643>>>
94643>>>        Move True to bOK
94644>>>        Decrement iSize
94645>>>        for iCount from 0 to iSize
94651>>>>
94651>>>            Move aTablesToCheck[iCount] to hTable
94652>>>            Set piPosition of ghoProgressBarOverall to iCount
94653>>>            Get UtilTableIsAlias hTable to bIsAlias
94654>>>            Get UtilTableIsSql   hTable to bIsSQL
94655>>>
94655>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94658>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
94659>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
94660>>>
94660>>>            If (bIsAlias = False and bIsSQL = False) Begin
94662>>>                Get UtilCheckForDateFields hTable to aDateFields
94663>>>                Move (SizeOfArray(aDateFields)) to iDateSize
94664>>>                If (iDateSize > 0) Begin
94666>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
94667>>>                    Close hTable
94668>>>                End
94668>>>>
94668>>>            End
94668>>>>
94668>>>        Loop
94669>>>>
94669>>>
94669>>>        Close DF_ALL
94670>>>        Function_Return bOK
94671>>>    End_Function
94672>>>
94672>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
94672>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
94674>>>        Integer[] aDateFields aDateFieldsEmpty
94676>>>        Integer iSize iCount iType
94676>>>        Boolean bOpen bOK
94676>>>        
94676>>>        Get UtilTableExists hTable to bOK
94677>>>        If (bOK = False) Begin
94679>>>            Set Private.phCurrentTable to hTable
94680>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
94681>>>>
94681>>>            Function_Return aDateFieldsEmpty
94682>>>        End
94682>>>>
94682>>>        Set Private.phCurrentTable to hTable
94683>>>        Set Private.piCurrentField to 0
94684>>>
94684>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94684>>>        Open hTable
94686>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94689>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
94689>>>        If (bOpen = False) Begin
94691>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
94691>>>            Function_Return aDateFieldsEmpty
94692>>>        End
94692>>>>
94692>>>
94692>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
94695>>>        For iCount from 1 to iSize
94701>>>>
94701>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
94704>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
94706>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
94707>>>            End
94707>>>>
94707>>>        Loop
94708>>>>
94708>>>
94708>>>        Function_Return aDateFields
94709>>>    End_Function
94710>>>
94710>>>    // Loops through all records for the passed hTable, and checks that all Date values
94710>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
94710>>>    // and the record is saved
94710>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
94710>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
94710>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
94712>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
94712>>>        String sDriverID sDateMin
94712>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
94712>>>        Date dDate dDateMin
94712>>>        Integer[] iaChangeField
94713>>>
94713>>>        Get UtilTableExists hTable to bOK
94714>>>        // I believe we should just skip files not found and not report an error.
94714>>>        // This is because a filelist may have entries but no files/tables on disk, but
94714>>>        // this may be adjusted by other calls to DUF in a later update package. 
94714>>>        // Especially considering that this call is probably done at the very
94714>>>        // beginning of a DUF update.
94714>>>        If (bOK = False) Begin
94716>>>//            Set Private.phCurrentTable to hTable
94716>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
94716>>>//            Function_Return False
94716>>>            Function_Return True
94717>>>        End
94717>>>>
94717>>>
94717>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
94717>>>        // date format to "USA" = "MM/DD/YYYY"
94717>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
94720>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
94723>>>
94723>>>//        Send SetAllIndexesToBatch hTable True
94723>>>        Open hTable
94725>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94728>>>        If (bOpened = False) Begin
94730>>>            Function_Return False
94731>>>        End
94731>>>>
94731>>>        
94731>>>        Set Private.phCurrentTable to hTable
94732>>>        Move 0 to iRecord
94733>>>        Move (SizeOfArray(aDateFields)) to iSize
94734>>>        Decrement iSize
94735>>>
94735>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94738>>>        Get DriverIndex sDriverID to iDriverIndex
94739>>>        If (iDriverIndex <> 0) Begin
94741>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
94744>>>            If (sDateMin = "") Begin
94746>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
94747>>>            End
94747>>>>
94747>>>            Else Begin
94748>>>                If (IsDate(sDateMin)) Begin
94750>>>                    Move sDateMin to dDateMin
94751>>>                End
94751>>>>
94751>>>                Else Begin
94752>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
94753>>>                End
94753>>>>
94753>>>            End
94753>>>>
94753>>>        End
94753>>>>
94753>>>        Else Begin
94754>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
94755>>>        End
94755>>>>
94755>>>
94755>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
94758>>>        Set piPosition   of ghoProgressBar to 0
94759>>>        Set piAdvanceBy  of ghoProgressBar to 100
94760>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
94761>>>        Move False to Err
94762>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94763>>>
94763>>>        Clear hTable
94764>>>        Repeat
94764>>>>
94764>>>            Vfind hTable 0 GT
94766>>>            Move Found to bFound
94767>>>            If (bFound = True) Begin
94769>>>                Move False to bSaveChanges
94770>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
94771>>>                Move (SizeOfArray(aDateFields)) to iSize
94772>>>                Decrement iSize
94773>>>                For iCount from 0 to iSize
94779>>>>
94779>>>                    Move aDateFields[iCount] to iField
94780>>>                    Get_Field_Value hTable iField to dDate
94783>>>                    If (bFixZeroDates = True) Begin
94785>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
94786>>>                    End
94786>>>>
94786>>>                    Else Begin
94787>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
94788>>>                    End
94788>>>>
94788>>>                    If (bChange = True) Begin
94790>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
94791>>>                    End
94791>>>>
94791>>>                Loop
94792>>>>
94792>>>
94792>>>                // Only change Date fields that needs to be changed.
94792>>>                If (SizeOfArray(iaChangeField)) Begin
94794>>>                    Reread hTable
94798>>>                        Move (SizeOfArray(iaChangeField)) to iSize
94799>>>                        Decrement iSize
94800>>>                        For iCount from 0 to iSize
94806>>>>
94806>>>                            Move iaChangeField[iCount] to iField
94807>>>                            Set Private.piCurrentField to iField
94808>>>                            Set_Field_Value hTable iField to dDateMin
94811>>>                        Loop
94812>>>>
94812>>>                        Move False to Err
94813>>>                        SaveRecord hTable
94814>>>                    Unlock
94815>>>>
94815>>>                End
94815>>>>
94815>>>
94815>>>                Increment iRecord
94816>>>                // Increment the StatusPanel counter and check the
94816>>>                // cancel status every 100 records rather than every
94816>>>                // record, it's way faster.
94816>>>                If (Mod(iRecord, 100) = 0) Begin
94818>>>                    Send DoAdvance of ghoProgressBar
94819>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
94820>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
94821>>>                End
94821>>>>
94821>>>            End
94821>>>>
94821>>>        Until (bFound = False)
94823>>>
94823>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
94826>>>        If (bResetIndexesToOnLine = True) Begin
94828>>>            Send SetAllIndexesToBatch hTable False
94829>>>        End
94829>>>>
94829>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94830>>>
94830>>>        Function_Return (Err = False)
94831>>>    End_Function
94832>>>
94832>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
94832>>>    // Note that it first removes any driver prefixes in the rootname.
94832>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
94834>>>        Boolean bIsSame
94834>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
94834>>>
94834>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
94835>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
94836>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
94837>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
94838>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
94839>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
94840>>>
94840>>>        If (bCompareFilelistUppercase = True) Begin
94842>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
94843>>>        End
94843>>>>
94843>>>        Else Begin
94844>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
94845>>>        End
94845>>>>
94845>>>        If (bIsSame = False) Begin
94847>>>            Function_Return False
94848>>>        End
94848>>>>
94848>>>
94848>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
94849>>>        If (bIsSame = False) Begin
94851>>>            Function_Return False
94852>>>        End
94852>>>>
94852>>>
94852>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
94853>>>        If (bIsSame = False) Begin
94855>>>            Function_Return False
94856>>>        End
94856>>>>
94856>>>
94856>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
94857>>>        If (bIsSame = False) Begin
94859>>>            Function_Return False
94860>>>        End
94860>>>>
94860>>>
94860>>>        Function_Return bIsSame
94861>>>    End_Function
94862>>>
94862>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
94864>>>        Handle hTableFrom hTableTo
94864>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
94864>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
94864>>>        String sRootName sDriverIDFrom sDriverIDTo
94864>>>        tAPIColumnCompare[]   aAPIColumnCompare
94864>>>        tAPIColumnCompare[]   aAPIColumnCompare
94865>>>        tAPIIndexCompare[]    aAPIIndexCompare
94865>>>        tAPIIndexCompare[]    aAPIIndexCompare
94866>>>        tAPIRelationCompare[] aAPIRelationCompare
94866>>>        tAPIRelationCompare[] aAPIRelationCompare
94867>>>
94867>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
94868>>>        If (bIsSame = True) Begin
94870>>>            Function_Return True
94871>>>        End
94871>>>>
94871>>>
94871>>>        Move False to bFilelistError
94872>>>        Move True to bIsSame
94873>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
94874>>>        Get pbCompareIndexAscending to bCompareIndexAscending
94875>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
94876>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
94877>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
94878>>>
94878>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
94879>>>        Get _TableNameOnly sRootName             to sRootName
94880>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
94881>>>
94881>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
94881>>>        // bCodeGenerateMode = True = Code Generation mode.
94881>>>        If (bCodeGenerateMode = True) Begin
94883>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
94883>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
94885>>>                Function_Return False
94886>>>            End
94886>>>>
94886>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
94887>>>            If (bIsSame = False) Begin
94889>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
94890>>>                Move True to bFilelistError
94891>>>                Function_Return False
94892>>>            End
94892>>>>
94892>>>        End
94892>>>>
94892>>>
94892>>>        If (bCodeGenerateMode = False) Begin
94894>>>            // Then we want to create this table
94894>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
94896>>>                Function_Return False
94897>>>            End
94897>>>>
94897>>>
94897>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
94898>>>            If (bIsSame = False) Begin
94900>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
94901>>>>
94901>>>                Move True to bFilelistError
94902>>>                Function_Return False
94903>>>            End
94903>>>>
94903>>>        End
94903>>>>
94903>>>
94903>>>        // Check columns:
94903>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
94904>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
94905>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
94906>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
94907>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
94908>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
94909>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
94910>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
94911>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
94912>>>        If (bIsSame = False) Begin
94914>>>            Function_Return False
94915>>>        End
94915>>>>
94915>>>
94915>>>        // ...then check indexes:
94915>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
94916>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
94917>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
94918>>>        If (bIsSame = False) Begin
94920>>>            Function_Return False
94921>>>        End
94921>>>>
94921>>>
94921>>>        // ...and finally relationships:
94921>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
94922>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
94923>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
94924>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
94925>>>
94925>>>        Function_Return (bIsSame = True)
94926>>>    End_Function
94927>>>
94927>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
94927>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
94929>>>        Handle hTable
94929>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
94929>>>        String sRootName sDriverIDFrom sDriverIDTo
94929>>>
94929>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
94931>>>            Move True to bFilelistError
94932>>>            Function_Return False
94933>>>        End
94933>>>>
94933>>>
94933>>>        Move APITableCompare.hTable to hTable
94934>>>        Move True  to bIsSame
94935>>>        Move False to bFilelistError
94936>>>
94936>>>        If (APITableCompare.bExistsFrom = True) Begin
94938>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
94939>>>        End
94939>>>>
94939>>>        Else Begin
94940>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
94941>>>        End
94941>>>>
94941>>>        Get _TableNameOnly sRootName                                   to sRootName
94942>>>
94942>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
94943>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
94944>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
94945>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
94946>>>
94946>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
94946>>>        // bCodeGenerateMode = True = Code Generation mode.
94946>>>        If (bCodeGenerateMode = True) Begin
94948>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
94948>>>            If (APITableCompare.bExistsTo = False) Begin
94950>>>                Function_Return False
94951>>>            End
94951>>>>
94951>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
94952>>>            If (bIsSame = False) Begin
94954>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
94955>>>                Move True to bFilelistError
94956>>>                Function_Return False
94957>>>            End
94957>>>>
94957>>>        End
94957>>>>
94957>>>
94957>>>        If (bCodeGenerateMode = False) Begin
94959>>>            If (APITableCompare.bExistsTo = False) Begin
94961>>>                // Then we might want to create this table
94961>>>                Function_Return False
94962>>>            End
94962>>>>
94962>>>
94962>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
94963>>>            If (bIsSame = False) Begin
94965>>>                Function_Return False
94966>>>            End
94966>>>>
94966>>>
94966>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
94967>>>            If (bIsSame = False) Begin
94969>>>                Function_Return False
94970>>>            End
94970>>>>
94970>>>
94970>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
94971>>>            If (bIsSame = False) Begin
94973>>>                Function_Return False
94974>>>            End
94974>>>>
94974>>>
94974>>>            // Check table names et al.
94974>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
94975>>>            If (bIsSame = False) Begin
94977>>>                Function_Return False
94978>>>            End
94978>>>>
94978>>>        End
94978>>>>
94978>>>
94978>>>        // Check Columns:
94978>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
94979>>>        If (bIsSame = False) Begin
94981>>>            Function_Return False
94982>>>        End
94982>>>>
94982>>>
94982>>>        // ...then check Indexes:
94982>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
94983>>>        If (bIsSame = False) Begin
94985>>>            Function_Return False
94986>>>        End
94986>>>>
94986>>>
94986>>>        // ...and finally Relationships:
94986>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
94987>>>
94987>>>        Function_Return (bIsSame = True)
94988>>>    End_Function
94989>>>
94989>>>    // To fill a complete Table array structure (tAPITable[]) with data.
94989>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
94989>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
94989>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
94989>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
94991>>>        tAPITableNameInfo ApiTableNameInfo
94991>>>        tAPITableNameInfo ApiTableNameInfo
94991>>>        tAPITable[]     aApiTables aApiTablesEmpty
94991>>>        tAPITable[]     aApiTables aApiTablesEmpty
94993>>>        tAPIColumn[]    aApiColumns
94993>>>        tAPIColumn[]    aApiColumns
94994>>>        tAPIIndex[]     aApiIndexes
94994>>>        tAPIIndex[]     aApiIndexes
94995>>>        tAPIRelation[]  aApiRelations
94995>>>        tAPIRelation[]  aApiRelations
94996>>>        Handle hTable
94996>>>        Integer iCount
94996>>>        Boolean bUserCancel bOK
94996>>>        String sLogicalName sMessageText
94996>>>
94996>>>        Get AutoConnectionIDLogin to bOK
94997>>>        Move 0 to hTable
94998>>>        If (bFromTables = True) Begin
95000>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
95001>>>            If (bCompareUtil = True) Begin
95003>>>                Move (sMessageText * "(1 of 3)") to sMessageText
95004>>>            End
95004>>>>
95004>>>        End
95004>>>>
95004>>>        Else Begin
95005>>>            Move "Reading 'TO' Table Structure:" to sMessageText
95006>>>            If (bCompareUtil = True) Begin
95008>>>                Move (sMessageText * "(2 of 3)") to sMessageText
95009>>>            End
95009>>>>
95009>>>        End
95009>>>>
95009>>>        Set Message_Text of ghoStatusPanel to sMessageText
95010>>>
95010>>>        Get UtilFilelistNoOfTables to iCount
95011>>>        Set piMaximum of ghoProgressBar to iCount
95012>>>        Move 0 to iCount
95013>>>
95013>>>        Repeat
95013>>>>
95013>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95016>>>            If (hTable > 0 and hTable <> 50) Begin
95018>>>
95018>>>                Open hTable
95020>>>                // ToDo: Needs to be revised
95020>>>                // For some reason tables may be reported as "unopened", while in
95020>>>                // fact the open was successful (!)
95020>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95020>>>//                If (bIsOpen = False) Begin
95020>>>//                    Move True to aApiTablesEmpty[0].bError
95020>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
95020>>>//                    Function_Return aApiTablesEmpty
95020>>>//                End
95020>>>
95020>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95023>>>                Set piPosition of ghoProgressBar to iCount
95024>>>                Send DoAdvance of ghoProgressBarOverall
95025>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
95026>>>
95026>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
95027>>>//                Close hTable DF_PERMANENT
95027>>>                Increment iCount
95028>>>            End
95028>>>>
95028>>>
95028>>>            If (bStatusPanel = True) Begin
95030>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
95031>>>                If (bUserCancel = True) Begin
95033>>>                    Move True to aApiTablesEmpty[0].bCancel
95034>>>                    Function_Return aApiTablesEmpty
95035>>>                End
95035>>>>
95035>>>            End
95035>>>>
95035>>>
95035>>>        Until (hTable = 0)
95037>>>
95037>>>        Function_Return aApiTables
95038>>>    End_Function
95039>>>
95039>>>    // Returns a 'single' table APITable struct.
95039>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
95041>>>        tAPITableNameInfo ApiTableNameInfo
95041>>>        tAPITableNameInfo ApiTableNameInfo
95041>>>        tAPITable         ApiTable ApiTableEmpty
95041>>>        tAPITable         ApiTable ApiTableEmpty
95041>>>        tAPIColumn[]     aApiColumns
95041>>>        tAPIColumn[]     aApiColumns
95042>>>        tAPIIndex[]      aApiIndexes
95042>>>        tAPIIndex[]      aApiIndexes
95043>>>        tAPIRelation[]   aApiRelations
95043>>>        tAPIRelation[]   aApiRelations
95044>>>        Boolean bIsOpen
95044>>>
95044>>>        Open hTable
95046>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95049>>>        If (bIsOpen = False) Begin
95051>>>            Move True to ApiTableEmpty.bError
95052>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95053>>>            Function_Return ApiTableEmpty
95054>>>        End
95054>>>>
95054>>>
95054>>>        // Fill Table Name Info
95054>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
95055>>>
95055>>>        // Fill columns
95055>>>        Get UtilColumnsStructFill hTable to aApiColumns
95056>>>        If (SizeOfArray(aApiColumns)) Begin
95058>>>            If (aApiColumns[0].bCancel = True) Begin
95060>>>                Move True to ApiTableEmpty.bError
95061>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95062>>>                Function_Return ApiTableEmpty
95063>>>            End
95063>>>>
95063>>>        End
95063>>>>
95063>>>
95063>>>        // Fill indexes
95063>>>        Get UtilIndexesStructFill hTable to aApiIndexes
95064>>>        If (SizeOfArray(aApiIndexes)) Begin
95066>>>            If (aApiIndexes[0].bCancel = True) Begin
95068>>>                Move True to ApiTableEmpty.bError
95069>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95070>>>                Function_Return ApiTableEmpty
95071>>>            End
95071>>>>
95071>>>        End
95071>>>>
95071>>>
95071>>>        // Fill relationships
95071>>>        Get UtilRelationsStructFill hTable to aApiRelations
95072>>>        If (SizeOfArray(aApiRelations)) Begin
95074>>>            If (aApiRelations[0].bCancel = True) Begin
95076>>>                Move True to ApiTableEmpty.bError
95077>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95078>>>                Function_Return ApiTableEmpty
95079>>>            End
95079>>>>
95079>>>        End
95079>>>>
95079>>>
95079>>>        Move hTable             to ApiTable.hTable
95080>>>        Move bFromTables        to ApiTable.bFromTable
95081>>>        Move (not(bFromTables)) to ApiTable.bToTable
95082>>>
95082>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
95083>>>        Move aApiColumns        to ApiTable.aApiColumns
95084>>>        Move aApiIndexes        to ApiTable.aApiIndexes
95085>>>        Move aApiRelations      to ApiTable.aApiRelations
95086>>>
95086>>>        Function_Return ApiTable
95087>>>    End_Function
95088>>>
95088>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
95090>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
95090>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
95090>>>        Boolean bIsOpen
95090>>>
95090>>>        Open hTable
95092>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95095>>>        If (bIsOpen = False) Begin
95097>>>            Move True   to APITableNameInfoEmpty.bError
95098>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
95099>>>            Function_Return APITableNameInfoEmpty
95100>>>        End
95100>>>>
95100>>>
95100>>>        Move hTable                                  to APITableNameInfo.iTableNumber
95101>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
95104>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
95107>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
95110>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
95113>>>
95113>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
95114>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
95115>>>
95115>>>        Function_Return APITableNameInfo
95116>>>    End_Function
95117>>>
95117>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
95119>>>        Integer iSize iCount iItem
95119>>>        tAPITableNameInfo ApiTableNameInfo
95119>>>        tAPITableNameInfo ApiTableNameInfo
95119>>>
95119>>>        Move -1 to iItem
95120>>>        Move (SizeOfArray(aTableStructure)) to iSize
95121>>>        Decrement iSize
95122>>>        for iCount from 0 to iSize
95128>>>>
95128>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
95129>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
95131>>>                Move iCount to iItem
95132>>>                Move iSize  to iCount // We're done.
95133>>>            End
95133>>>>
95133>>>        Loop
95134>>>>
95134>>>
95134>>>        Function_Return iItem
95135>>>    End_Function
95136>>>
95136>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
95138>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
95141>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
95144>>>
95144>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
95147>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
95150>>>
95150>>>        Function_Return (EQ)
95151>>>    End_Function
95152>>>
95152>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
95154>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
95154>>>        Handle hTable
95154>>>        tAPITable[] aAPITableFromAndTo
95154>>>        tAPITable[] aAPITableFromAndTo
95155>>>        tAPITable   APITableFrom APITableTo APITableEmpty
95155>>>        tAPITable   APITableFrom APITableTo APITableEmpty
95155>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95155>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95155>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
95155>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
95156>>>        tAPIColumnCompare[]   aAPIColumnCompare
95156>>>        tAPIColumnCompare[]   aAPIColumnCompare
95157>>>        tAPIIndexCompare[]    aAPIIndexCompare
95157>>>        tAPIIndexCompare[]    aAPIIndexCompare
95158>>>        tAPIRelationCompare[] aAPIRelationCompare
95158>>>        tAPIRelationCompare[] aAPIRelationCompare
95159>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
95159>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
95159>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
95159>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
95162>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
95162>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
95165>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
95165>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
95168>>>
95168>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
95169>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
95170>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
95172>>>            Function_Return aAPITableCompare
95173>>>        End
95173>>>>
95173>>>
95173>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
95174>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
95175>>>
95175>>>        Move 0 to iItem
95176>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
95177>>>        Decrement iSize
95178>>>        for iCount from 0 to iSize
95184>>>>
95184>>>
95184>>>            Move iCount to iItemFrom
95185>>>            Move iCount to iItemTo
95186>>>            Move APITableEmpty to APITableFrom
95187>>>            Move APITableEmpty to APITableTo
95188>>>
95188>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
95190>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
95191>>>            End
95191>>>>
95191>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
95193>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
95194>>>            End
95194>>>>
95194>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
95196>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
95197>>>                Move (iCount + 1) to iItemTo
95198>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
95199>>>            End
95199>>>>
95199>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
95201>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
95202>>>                If (iItemTo <> -1) Begin
95204>>>                    Move aAPITableTo[iItemTo] to APITableTo
95205>>>                End
95205>>>>
95205>>>                Else Begin
95206>>>                    Move APITableEmpty to APITableTo
95207>>>                End
95207>>>>
95207>>>            End
95207>>>>
95207>>>
95207>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
95208>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
95209>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
95210>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
95211>>>
95211>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
95212>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
95213>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
95214>>>            Move APITableTo.aApiRelations   to aApiRelationTo
95215>>>
95215>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
95216>>>
95216>>>            If (hTable > 0) Begin
95218>>>
95218>>>                // Table info:
95218>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
95219>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
95220>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
95221>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
95222>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
95223>>>
95223>>>                // Column info:
95223>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
95224>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
95225>>>
95225>>>                // Index info:
95225>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
95226>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
95227>>>
95227>>>                // Relation info:
95227>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
95228>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
95229>>>
95229>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
95230>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
95231>>>                Move False                                                              to aAPITableCompare[iItem].bError
95232>>>                If (iItemTo > iItemFrom) Begin
95234>>>                    Increment iCount
95235>>>                End
95235>>>>
95235>>>                Increment iItem
95236>>>            End
95236>>>>
95236>>>
95236>>>        Loop
95237>>>>
95237>>>
95237>>>        Function_Return aAPITableCompare
95238>>>    End_Function
95239>>>
95239>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
95241>>>        Integer iSize iCount iItem
95241>>>        tAPITableNameInfo ApiTableNameInfo
95241>>>        tAPITableNameInfo ApiTableNameInfo
95241>>>
95241>>>        Move -1 to iItem
95242>>>        Move (SizeOfArray(aTableStructure)) to iSize
95243>>>        Decrement iSize
95244>>>        For iCount from 0 to iSize
95250>>>>
95250>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
95251>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
95253>>>                Move iCount to iItem
95254>>>                Move iSize  to iCount // We're done.
95255>>>            End
95255>>>>
95255>>>        Loop
95256>>>>
95256>>>
95256>>>        Function_Return iItem
95257>>>    End_Function
95258>>>
95258>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
95260>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95260>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95260>>>
95260>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
95262>>>            Function_Return APITableNameInfoCompare
95263>>>        End
95263>>>>
95263>>>
95263>>>        // FROM database info:
95263>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
95265>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
95266>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
95267>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
95268>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
95269>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
95270>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
95271>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
95272>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
95273>>>        End
95273>>>>
95273>>>
95273>>>        // TO database info:
95273>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
95275>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
95276>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
95277>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
95278>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
95279>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
95280>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
95281>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
95282>>>            Move True                               to APITableNameInfoCompare.bExistsTo
95283>>>        End
95283>>>>
95283>>>
95283>>>        Function_Return APITableNameInfoCompare
95284>>>    End_Function
95285>>>
95285>>>    // Note:
95285>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
95285>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
95285>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
95285>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
95285>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
95285>>>    Function UtilTableHandleToString Handle hTable Returns String
95287>>>        String sTableName
95287>>>        Boolean bOpen bExists bOK
95287>>>
95287>>>        Get UtilTableNumberIsInUse hTable to bExists
95288>>>        If (bExists = False) Begin
95290>>>            Function_Return ""
95291>>>        End
95291>>>>
95291>>>
95291>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95292>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95295>>>        If (bOpen = False) Begin
95297>>>            Get AutoConnectionIDLogin to bOK
95298>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95299>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
95300>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95301>>>            Open hTable
95303>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95304>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
95305>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95306>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
95309>>>        End
95309>>>>
95309>>>        If (bOpen = True) Begin
95311>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95312>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
95315>>>            // If blank it is an embedded table:
95315>>>            If (sTableName = "") Begin
95317>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95320>>>                Move 0 to LastErr
95321>>>                Move False to Err
95322>>>            End
95322>>>>
95322>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95323>>>        End
95323>>>>
95323>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95324>>>        Move 0 to LastErr
95325>>>
95325>>>        Function_Return sTableName
95326>>>    End_Function
95327>>>
95327>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
95327>>>    // Returns 0 if unsuccessful.
95327>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
95327>>>    Function UtilTableNameToHandle String sTableName Returns Integer
95329>>>        String sValue sPrefixTableName sDriverID
95329>>>        Handle hTable hRetval
95329>>>
95329>>>        Get psDriverID to sDriverID
95330>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
95332>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
95333>>>        End
95333>>>>
95333>>>        Move 0 to hTable
95334>>>        Move 0 to hRetval
95335>>>        Repeat
95335>>>>
95335>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95338>>>            If (hTable <> 0) Begin
95340>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
95343>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
95345>>>                    Move hTable to hRetval
95346>>>                    Move 0 to hTable
95347>>>                End
95347>>>>
95347>>>            End
95347>>>>
95347>>>        Until (hTable = 0)
95349>>>
95349>>>        Function_Return hRetval
95350>>>    End_Function
95351>>>
95351>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
95351>>>    // _after_ all tables have successfully been converted to SQL (.int files)
95351>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
95353>>>        Boolean bOK bExists
95353>>>        String sDataPath sBackupFolder
95353>>>
95353>>>        Close DF_ALL DF_PERMANENT
95354>>>        Send DoAdvance of ghoProgressBar
95355>>>
95355>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
95356>>>        Move CS_DUFBackupDataFolder to sBackupFolder
95357>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95358>>>        Get vFolderFormat sDataPath to sDataPath
95359>>>
95359>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
95360>>>        If (bExists = False) Begin
95362>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
95363>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
95364>>>            If (bExists = False) Begin
95366>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
95367>>>>
95367>>>                Function_Return False
95368>>>            End
95368>>>>
95368>>>        End
95368>>>>
95368>>>
95368>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
95369>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
95370>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
95371>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
95372>>>        // We need to wait for Windows before we can copy files back
95372>>>        Sleep 2  
95373>>>        
95373>>>        //...except for these files that needs to be copied back to the Data folder:
95373>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
95374>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
95375>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
95376>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
95377>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
95378>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
95379>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
95379>>>        
95379>>>
95379>>>        Set Message_Text of ghoStatusPanel to ""
95380>>>        Function_Return True
95381>>>    End_Function
95382>>>    
95382>>>    Function UtilTableRepairAndReindexALL Returns Boolean
95384>>>        Boolean bOK bRetval
95384>>>        Handle hTable
95384>>>        Integer iSize iCount
95384>>>        
95384>>>        Move True to bOK
95385>>>        Get UtilFilelistNoOfTables to iSize
95386>>>        Set pbVisible    of ghoProgressBarOverall to True
95387>>>        Set piPosition   of ghoProgressBarOverall to 0
95388>>>        Set piMaximum    of ghoProgressBarOverall to iSize
95389>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
95390>>>
95390>>>        Repeat
95390>>>>
95390>>>            Set piPosition of ghoProgressBarOverall to iCount
95391>>>            Increment iCount
95392>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95395>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
95397>>>                Get UtilTableRepairAndReindex hTable to bRetval
95398>>>                If (bRetval = False) Begin
95400>>>                    Move False to bOK
95401>>>                End
95401>>>>
95401>>>            End
95401>>>>
95401>>>        Until (hTable = 0)
95403>>>                
95403>>>        Function_Return bOK
95404>>>    End_Function           
95405>>>    
95405>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
95405>>>    // After the header has been repaired - also makes a re-index.  
95405>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
95405>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
95407>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
95407>>>        Integer iRetval
95407>>>        String sRootName sFileName sDataPath
95407>>>        
95407>>>        Move False to Err
95408>>>        Move 0 to LastErr 
95409>>>        Move True to bOK
95410>>>        
95410>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
95411>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
95413>>>            Function_Return True
95414>>>        End
95414>>>>
95414>>>        Get UtilTableIsAlias hTable to bIsAlias 
95415>>>        If (bIsAlias = True) Begin
95417>>>            Function_Return True
95418>>>        End
95418>>>>
95418>>>        
95418>>>        // Check for bad file and remove if exists
95418>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95421>>>        Set private.phCurrentTable to hTable  
95422>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
95423>>>        
95423>>>        // This is important! Else it can happen that the table can't be opened,
95423>>>        // with a "4077 - File in use" error.
95423>>>        Close DF_ALL DF_PERMANENT    
95424>>>        Open hTable
95426>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95429>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95430>>>        If (bIsOpen = False) Begin
95432>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
95433>>>>
95433>>>            Function_Return False        
95434>>>        End
95434>>>>
95434>>>
95434>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
95435>>>        If (bBadExists = True) Begin
95437>>>            Get_File_Path (sRootName + ".BAD") to sFileName
95438>>>            Get vDeleteFile sFileName to iRetval
95439>>>        End
95439>>>>
95439>>>        
95439>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
95440>>>        
95440>>>        Move False to Err
95441>>>        // **** Repair and reindex the table. ****
95441>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
95442>>>
95442>>>        // Check for bad file: if it exists, something went wrong
95442>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95443>>>        Get vFolderFormat sDataPath to sDataPath
95444>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
95445>>>        If (bBadExists = True) Begin
95447>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
95448>>>>
95448>>>            Move False to bOK
95449>>>        End
95449>>>>
95449>>>        Close hTable
95450>>>
95450>>>        Function_Return bOK
95451>>>    End_Function
95452>>>
95452>>>    // Repair and reindex the named DataFlex data-table.
95452>>>    // No checks are done if the passed table name is an embedded or SQL,
95452>>>    // so use with care (make sure you only pass embedded table names).
95452>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
95454>>>        String sMode
95454>>>        Integer iVoid
95454>>>
95454>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
95455>>>        Move "0" to sMode   // 0=Reindex after repair!    
95456>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
95457>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
95462>>>        Set Message_Text of ghoStatusPanel to ""
95463>>>        Function_Return (iVoid = 0)
95464>>>    End_Function
95465>>>
95465>>>    // Returns _two_ arrays.
95465>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
95465>>>    // Also returns all files that are Alias files in a second array.
95465>>>    // IMPORTANT: All master & alias files _must_ have been included into
95465>>>    //            the DoSetAllMasterAndAlias message.
95465>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
95467>>>        Integer[] iaFileIsAlias
95468>>>        Integer hTable iFileAlias iSize
95468>>>        Boolean bOpen
95468>>>
95468>>>        Move 0 to hTable
95469>>>        Repeat
95469>>>>
95469>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95472>>>            If (hTable <> 0) Begin
95474>>>                Open hTable
95476>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95479>>>                If (bOpen = True) Begin
95481>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
95484>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95486>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
95487>>>                        Move hTable to iaFileIsMaster[iSize]
95488>>>                    End
95488>>>>
95488>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95491>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
95492>>>                        Move hTable to iaFileIsAlias[iSize]
95493>>>                    End
95493>>>>
95493>>>                End
95493>>>>
95493>>>            End
95493>>>>
95493>>>        Until (hTable = 0)
95495>>>
95495>>>        Function_Return iaFileIsAlias
95496>>>    End_Function  
95497>>>    
95497>>>    // Is a repair of the data-header necessary? (Embedded tables only)
95497>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
95499>>>        String sMode
95499>>>        Integer iRepairNeeded bIsOpen
95499>>>
95499>>>        Move "0" to sMode
95500>>>        Set private.phCurrentTable to hTable 
95501>>>        Close hTable
95502>>>        Open hTable
95504>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95507>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
95512>>>
95512>>>        Function_Return iRepairNeeded
95513>>>    End_Function
95514>>>
95514>>>
95514>>>    // Helper function
95514>>>    // Takes two params:
95514>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
95514>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
95514>>>    // Returns:
95514>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
95514>>>    //  DF_FILE_IS_MASTER if master
95514>>>    //  DF_FILE_IS_ALIAS if alias
95514>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
95516>>>        Integer i iSize
95516>>>
95516>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
95517>>>        Decrement iSize
95518>>>        for i from 0 to iSize
95524>>>>
95524>>>            If (hTable = iaFileIsMaster[i]) Begin
95526>>>                Function_Return DF_FILE_IS_MASTER
95527>>>            End
95527>>>>
95527>>>        Loop
95528>>>>
95528>>>
95528>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
95529>>>        Decrement iSize
95530>>>        for i from 0 to iSize
95536>>>>
95536>>>            If (hTable = iaFileIsAlias[i]) Begin
95538>>>                Function_Return DF_FILE_IS_ALIAS
95539>>>            End
95539>>>>
95539>>>        Loop
95540>>>>
95540>>>
95540>>>        Function_Return DF_FILE_ALIAS_DEFAULT
95541>>>    End_Function
95542>>>
95542>>>    // Determine the available indexes of a table.
95542>>>    //
95542>>>    // Arguments:
95542>>>    //   Handle hTable - The number of the table
95542>>>    //
95542>>>    // Returns:
95542>>>    //   String - A string to be used with the sort command
95542>>>    //   to re-index all indexes of a table.
95542>>>    Function UtilTableIndexString Handle hTable Returns String
95544>>>        String  sSortString
95544>>>        Integer iLastIndex iNumSegments iCount
95544>>>
95544>>>        Move "" to sSortString
95545>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
95548>>>
95548>>>        for iCount from 1 to iLastIndex
95554>>>>
95554>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
95557>>>            If iNumSegments Begin
95559>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
95562>>>                Move (Append(sSortString, iCount)) to sSortString
95563>>>            End
95563>>>>
95563>>>        Loop
95564>>>>
95564>>>
95564>>>        Function_Return sSortString
95565>>>    End_Function
95566>>>
95566>>>    
95566>>>    // * Dummy function for the Studio's Code Explorer *
95566>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
95568>>>        Function_Return False
95569>>>    End_Function
95570>>>
95570>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
95570>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
95572>>>        Boolean bIsSame
95572>>>        Integer iCount iColumns iColumn
95572>>>
95572>>>        Move True to bIsSame
95573>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
95574>>>        Set piMaximum of ghoProgressBar  to iColumns
95575>>>        Decrement iColumns
95576>>>
95576>>>        for iCount from 0 to iColumns
95582>>>>
95582>>>            Set piPosition of ghoProgressBar to iCount
95583>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
95584>>>            If (bIsSame = False) Begin
95586>>>                Function_Return False
95587>>>            End
95587>>>>
95587>>>        Loop
95588>>>>
95588>>>
95588>>>        Function_Return (bIsSame = True)
95589>>>    End_Function
95590>>>
95590>>>    // Compares a single column (For 'FROM' & 'TO' tables)
95590>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
95592>>>        Integer iFromType iToType iDbType
95592>>>        tColumnType ColumnType
95592>>>        tColumnType ColumnType
95592>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
95592>>>
95592>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
95594>>>            Function_Return False
95595>>>        End
95595>>>>
95595>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
95597>>>            Function_Return False
95598>>>        End
95598>>>>
95598>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
95600>>>            Function_Return False
95601>>>        End                                                                
95601>>>>
95601>>>
95601>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
95603>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
95605>>>                Function_Return False
95606>>>            End
95606>>>>
95606>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
95608>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
95610>>>                    End
95610>>>>
95610>>>                Else Begin
95611>>>                    Function_Return False
95612>>>                End
95612>>>>
95612>>>            End
95612>>>>
95612>>>        End
95612>>>>
95612>>>
95612>>>        Get piDbType                       to iDbType
95613>>>        Move APIColumnCompare.iTypeFrom    to iFromType
95614>>>        Move APIColumnCompare.iTypeTo      to iToType
95615>>>
95615>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
95615>>>        // data types between Embedded and SQL.
95615>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
95617>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
95618>>>        End
95618>>>>
95618>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
95620>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
95621>>>        End
95621>>>>
95621>>>
95621>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
95622>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
95623>>>
95623>>>        // Make Date and DateTime comparison?
95623>>>        If (bCompareDate_DataTime = True) Begin
95625>>>            If (iFromType <> iToType) Begin
95627>>>                Function_Return False
95628>>>            End
95628>>>>
95628>>>        End
95628>>>>
95628>>>
95628>>>        // This is when not checking for Date/DateTime differences but all other other field types...
95628>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
95630>>>            If (iFromType <> iToType) Begin
95632>>>                Function_Return False
95633>>>            End
95633>>>>
95633>>>        End
95633>>>>
95633>>>
95633>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
95633>>>        If (bIsDateTypeFrom = False) Begin
95635>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
95637>>>                Function_Return False
95638>>>            End
95638>>>>
95638>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
95640>>>                Function_Return False
95641>>>            End
95641>>>>
95641>>>        End
95641>>>>
95641>>>
95641>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
95643>>>            Function_Return False
95644>>>        End
95644>>>>
95644>>>
95644>>>        Function_Return True
95645>>>    End_Function
95646>>>
95646>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
95648>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
95648>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
95648>>>        tAPIColumn[] APIColumns APIColumnsEmpty
95648>>>        tAPIColumn[] APIColumns APIColumnsEmpty
95650>>>        String sDriverID sRootName sLogicalName
95650>>>
95650>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95651>>>        Get piDbType to iDbType
95652>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95655>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
95658>>>
95658>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95661>>>        If (bIsOpen = False) Begin
95663>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95664>>>            Open hTable
95666>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95667>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95670>>>            If (bIsOpen = False) Begin
95672>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95673>>>                Move True to APIColumnsEmpty[0].bError
95674>>>                Function_Return APIColumnsEmpty
95675>>>            End
95675>>>>
95675>>>        End
95675>>>>
95675>>>
95675>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95678>>>        Get IsSQLDriver    sDriverID to bSqlDriver
95679>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
95680>>>
95680>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
95681>>>        If (bIsSqlTable = True) Begin
95683>>>            Get UtilTableExists hTable to bExists
95684>>>            If (bExists = False) Begin
95686>>>                Move True to APIColumnsEmpty[0].bError
95687>>>                Function_Return APIColumnsEmpty
95688>>>            End
95688>>>>
95688>>>        End
95688>>>>
95688>>>
95688>>>        Move 0 to iCount
95689>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
95692>>>        Set piMaximum of ghoProgressBar to iNumColumns
95693>>>
95693>>>        for iColumn from 1 to iNumColumns
95699>>>>
95699>>>            Move 0 to iOptions
95700>>>            Move False to bIdentityKey
95701>>>            Move False to Err
95702>>>            Move 0     to LastErr
95703>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
95704>>>            Set piPosition of ghoProgressBar to iColumn
95705>>>            If (bDawSqlDriver = True) Begin
95707>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95708>>>                If (bIsSqlTable = True) Begin
95710>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
95713>>>                    Move iType                                                to APIColumns[iCount].iType
95714>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
95717>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
95720>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
95723>>>                End
95723>>>>
95723>>>                Else Begin
95724>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
95727>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
95728>>>                End
95728>>>>
95728>>>
95728>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
95728>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
95731>>>                Move (iCheckFieldNumber >= 0) to bExists
95732>>>                If (bExists = False) Begin
95734>>>                    Move 0 to APIColumns[iCount].iType
95735>>>                End
95735>>>>
95735>>>                If (bExists = True) Begin
95737>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
95740>>>                End
95740>>>>
95740>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95741>>>                If (bIdentityKey = True) Begin
95743>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
95744>>>                End
95744>>>>
95744>>>            End
95744>>>>
95744>>>            Else Begin
95745>>>                Move False to Err
95746>>>                Move 0     to LastErr
95747>>>                If (bIsSqlTable = True) Begin
95749>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
95752>>>                End
95752>>>>
95752>>>                Else Begin
95753>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
95756>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
95757>>>                End
95757>>>>
95757>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
95757>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
95758>>>                If (bExists = False) Begin
95760>>>                    Move 0 to APIColumns[iCount].iType
95761>>>                End
95761>>>>
95761>>>            End
95761>>>>
95761>>>
95761>>>            If (bExists = True) Begin
95763>>>                Move iColumn to APIColumns[iCount].iFieldNumber
95764>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
95767>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
95767>>>//                If (bIsSqlTable = True) Begin
95767>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
95767>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
95767>>>//                End
95767>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
95770>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
95773>>>
95773>>>                // If the length was zero we might have an Overlap(!) field.
95773>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
95773>>>                If (APIColumns[iCount].iLength = 0) Begin
95775>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
95778>>>                    If (iType = DF_OVERLAP) Begin
95780>>>                        Move 0 to APIColumns[iCount].iFieldNumber
95781>>>                        Move 0 to APIColumns[iCount].iLength
95782>>>                        Move 0 to APIColumns[iCount].iOptions
95783>>>                        Move 0 to APIColumns[iCount].iPrecision
95784>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
95785>>>                        Move "" to APIColumns[iCount].sFieldName
95786>>>                        Decrement iCount
95787>>>                    End
95787>>>>
95787>>>                End
95787>>>>
95787>>>            End
95787>>>>
95787>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
95788>>>            If (bUserCancel = True) Begin
95790>>>                Move True to APIColumnsEmpty[0].bCancel
95791>>>                Function_Return APIColumnsEmpty
95792>>>            End
95792>>>>
95792>>>            Increment iCount
95793>>>        Loop
95794>>>>
95794>>>
95794>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95795>>>        Function_Return APIColumns
95796>>>    End_Function
95797>>>
95797>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
95797>>>    // The combined data will be sorted on the first struct member: iIndexNumber
95797>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
95797>>>    // have "holes" in the series of index numbers.
95797>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
95799>>>        tAPIColumnCompare[] aAPIColumnCompare
95799>>>        tAPIColumnCompare[] aAPIColumnCompare
95800>>>        tAPIColumnCompare   APIColumnCompare
95800>>>        tAPIColumnCompare   APIColumnCompare
95800>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
95800>>>
95800>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
95801>>>        Decrement iSizeFrom
95802>>>        for iCount from 0 to iSizeFrom
95808>>>>
95808>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
95809>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
95810>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
95811>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
95812>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
95813>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
95814>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
95815>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
95816>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
95817>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
95818>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
95819>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
95820>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
95821>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
95822>>>        Loop
95823>>>>
95823>>>
95823>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
95824>>>        Decrement iSizeTo
95825>>>        for iCount from 0 to iSizeTo
95831>>>>
95831>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
95832>>>            // Search if the field number already exists in the array; else add it.
95832>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
95833>>>            If (iItem = -1) Begin
95835>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
95836>>>            End
95836>>>>
95836>>>
95836>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
95837>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
95838>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
95839>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
95840>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
95841>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
95842>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
95843>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
95844>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
95845>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
95846>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
95847>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
95848>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
95849>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
95850>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
95851>>>        Loop
95852>>>>
95852>>>
95852>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
95853>>>
95853>>>        Function_Return aAPIColumnCompare
95854>>>    End_Function
95855>>>
95855>>>    // Checks if a field name exists in a table definition
95855>>>    // Returns True if it does
95855>>>    // Sample:
95855>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
95855>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
95857>>>        Integer iNumColumns iColumn
95857>>>        String sColumn
95857>>>        Boolean bExists bOK bOpen
95857>>>
95857>>>        Get AutoConnectionIDLogin to bOK
95858>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95859>>>        Open hTable
95861>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95862>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95865>>>        If (bOpen = False) Begin
95867>>>            Function_Return False
95868>>>        End
95868>>>>
95868>>>
95868>>>        Move False to bExists
95869>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
95872>>>        for iColumn from 1 to iNumColumns
95878>>>>
95878>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
95881>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
95883>>>                Move iNumColumns to iColumn
95884>>>                Move True to bExists
95885>>>            End
95885>>>>
95885>>>        Loop
95886>>>>
95886>>>        Close hTable
95887>>>
95887>>>        Function_Return bExists
95888>>>    End_Function
95889>>>
95889>>>    // Returns the field/column number for the passed FieldName as an integer.
95889>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
95891>>>        Integer iNumColumns iColumn iRetval
95891>>>        String sColumn
95891>>>        Boolean bOK bOpen
95891>>>
95891>>>        Get AutoConnectionIDLogin to bOK
95892>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95893>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95894>>>        Open hTable
95896>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95897>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95900>>>        If (bOpen = False) Begin
95902>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
95903>>>            Function_Return False
95904>>>        End
95904>>>>
95904>>>
95904>>>        Move 0 to iColumn
95905>>>        Move 0 to iRetval
95906>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
95909>>>        for iColumn from 1 to iNumColumns
95915>>>>
95915>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
95918>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
95920>>>                Move iColumn to iRetval
95921>>>                Move iNumColumns to iColumn
95922>>>            End
95922>>>>
95922>>>        Loop
95923>>>>
95923>>>        Close hTable
95924>>>
95924>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95925>>>        Function_Return iRetval
95926>>>    End_Function
95927>>>
95927>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
95927>>>    // The reciprocal function is UtilColumnTypeToInteger.
95927>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
95929>>>        tColumnType RetvalType
95929>>>        tColumnType RetvalType
95929>>>
95929>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
95930>>>        Function_Return RetvalType.iSQLType
95931>>>    End_Function
95932>>>
95932>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
95932>>>    // The reciprocal function is UtilColumnTypeToString.
95932>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
95934>>>        tColumnType RetvalType
95934>>>        tColumnType RetvalType
95934>>>
95934>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95935>>>        Function_Return RetvalType.sSQLType
95936>>>    End_Function
95937>>>
95937>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
95939>>>        tColumnType RetvalType
95939>>>        tColumnType RetvalType
95939>>>
95939>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95940>>>        Function_Return RetvalType.sPrecision
95941>>>    End_Function
95942>>>
95942>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
95944>>>        tColumnType RetvalType
95944>>>        tColumnType RetvalType
95944>>>
95944>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95945>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
95945>>>        // if the column type length is _not_ fixed.
95945>>>        Function_Return (RetvalType.bCanEditSize = False)
95946>>>    End_Function
95947>>>
95947>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
95949>>>        tColumnType RetvalType
95949>>>        tColumnType RetvalType
95949>>>        String sValue
95949>>>        Integer iRetval iPos
95949>>>
95949>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95950>>>        Move RetvalType.sPrecision to sValue
95951>>>        Move (Pos(".", sValue)) to iPos
95952>>>        If (iPos <> 0) Begin
95954>>>            Move (Left(sValue, (iPos -1))) to iRetval
95955>>>        End
95955>>>>
95955>>>        Else Begin
95956>>>            Move sValue to iRetval
95957>>>        End
95957>>>>
95957>>>        Function_Return iRetval
95958>>>    End_Function
95959>>>
95959>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
95961>>>        tColumnType RetvalType
95961>>>        tColumnType RetvalType
95961>>>        String sValue
95961>>>        Integer iRetval iPos
95961>>>
95961>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
95962>>>        Move RetvalType.sPrecision to sValue
95963>>>        Move (Pos(".", sValue)) to iPos
95964>>>        If (iPos = 0) Begin
95966>>>            Function_Return 0
95967>>>        End
95967>>>>
95967>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
95968>>>
95968>>>        Function_Return iRetval
95969>>>    End_Function
95970>>>
95970>>>    // * Dummy function for the Studio's Code Explorer *
95970>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
95972>>>        Function_Return False
95973>>>    End_Function
95974>>>
95974>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
95974>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
95976>>>        Boolean bIsSame
95976>>>        Integer iCount iSize
95976>>>
95976>>>        Move True to bIsSame
95977>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
95978>>>        Decrement iSize
95979>>>        For iCount from 0 to iSize
95985>>>>
95985>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95986>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
95987>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
95988>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
95989>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
95990>>>            If (bIsSame = False) Begin
95992>>>                Function_Return False
95993>>>            End
95993>>>>
95993>>>        Loop
95994>>>>
95994>>>
95994>>>        Function_Return bIsSame
95995>>>    End_Function
95996>>>
95996>>>    // Compares a single index for a 'FROM' and a 'TO' table.
95996>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
95998>>>        Boolean bIsSame
95998>>>        Integer iSegment
95998>>>
95998>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
95999>>>        If (bIsSame = False) Begin
96001>>>            Function_Return False
96002>>>        End
96002>>>>
96002>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
96003>>>        If (bIsSame = False) Begin
96005>>>            Function_Return False
96006>>>        End
96006>>>>
96006>>>
96006>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
96008>>>            // * We should probably not compare SQL index names?
96008>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
96008>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
96008>>>            //     Function_Return False
96008>>>            // End
96008>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
96009>>>            If (bIsSame = False) Begin
96011>>>                Function_Return False
96012>>>            End
96012>>>>
96012>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
96013>>>            If (bIsSame = False) Begin
96015>>>                Function_Return False
96016>>>            End
96016>>>>
96016>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
96017>>>            If (bIsSame = False) Begin
96019>>>                Function_Return False
96020>>>            End
96020>>>>
96020>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
96021>>>            If (bIsSame = False) Begin
96023>>>                Function_Return False
96024>>>            End
96024>>>>
96024>>>        End
96024>>>>
96024>>>
96024>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
96025>>>        Move (iSegment = -1) to bIsSame
96026>>>
96026>>>        Function_Return (bIsSame = True)
96027>>>    End_Function
96028>>>
96028>>>    // Compares each segment for the passed index.
96028>>>    // Returns -1 if same; else returns the index segment that differs.
96028>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96030>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
96030>>>        Boolean bIsSame
96030>>>
96030>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96031>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96032>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
96033>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
96034>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
96035>>>
96035>>>        Decrement iNumSegments
96036>>>        for iSegment from 0 to iNumSegments
96042>>>>
96042>>>            Move False to bIsSame
96043>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
96045>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96046>>>            End
96046>>>>
96046>>>            If (bIsSame = False) Begin
96048>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96049>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96050>>>                Function_Return iSegment
96051>>>            End
96051>>>>
96051>>>        Loop
96052>>>>
96052>>>
96052>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96053>>>        Function_Return -1 // This means bIsSame = True
96054>>>    End_Function
96055>>>
96055>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96057>>>        Boolean bIsSame
96057>>>
96057>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
96058>>>        If (bIsSame = False) Begin
96060>>>            Function_Return False
96061>>>        End
96061>>>>
96061>>>        If (bCompareIndexUppercase = True) Begin
96063>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
96064>>>            If (bIsSame = False) Begin
96066>>>                Function_Return False
96067>>>            End
96067>>>>
96067>>>        End
96067>>>>
96067>>>        If (bCompareIndexAscending = True) Begin
96069>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
96070>>>            If (bIsSame = False) Begin
96072>>>                Function_Return False
96073>>>            End
96073>>>>
96073>>>        End
96073>>>>
96073>>>
96073>>>        Function_Return True
96074>>>    End_Function
96075>>>
96075>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96077>>>        Boolean bIsSame bOK
96077>>>        Integer iSize iSizeTo iCount
96077>>>        tAPIIndexCompare[] aAPIIndexCompare
96077>>>        tAPIIndexCompare[] aAPIIndexCompare
96078>>>
96078>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
96079>>>        If (iSize = 0) Begin
96081>>>            Function_Return True
96082>>>        End
96082>>>>
96082>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
96083>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
96084>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
96085>>>
96085>>>        for iCount from 0 to (iSize - 1)
96091>>>>
96091>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96092>>>            If (bIsSame = False) Begin
96094>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
96095>>>            End
96095>>>>
96095>>>        Loop
96096>>>>
96096>>>
96096>>>        // We probably should delete other indexes if they exists.
96096>>>        for iCount from (iSize +1) to iSizeTo
96102>>>>
96102>>>            Get ApiIndexRemove hTable iCount to bOK
96103>>>        Loop
96104>>>>
96104>>>
96104>>>        Function_Return bOK
96105>>>    End_Function
96106>>>
96106>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
96106>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
96106>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
96106>>>//        String sFieldName sDriverID
96106>>>//
96106>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96106>>>//        If (bIsOpen = False) Begin
96106>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96106>>>//            Open hTable
96106>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96106>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96106>>>//            If (bIsOpen = False) Begin
96106>>>//                Function_Return False
96106>>>//            End
96106>>>//        End
96106>>>//
96106>>>//        Move True to bEqual
96106>>>//        Get psDriverID to sDriverID
96106>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
96106>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
96106>>>//        Move (SizeOfArray(aColumns)) to iSize
96106>>>//        Decrement iSize
96106>>>//
96106>>>//        For iCount from 0 to iSize
96106>>>//            Move 0 to iOptions
96106>>>//            Move False to bIdentityKey
96106>>>//            Move aColumns[iCount].sFieldName to sFieldName
96106>>>//
96106>>>//            // We need to use the column name - not the column integer as
96106>>>//            // the order does not need to be the same, and the logic should still work.
96106>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
96106>>>//            If (iColumn > 0) Begin
96106>>>//                If (bDawSqlDriver = True) Begin
96106>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96106>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
96106>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
96106>>>//                        Move False to bEqual
96106>>>//                    End
96106>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
96106>>>//                    If (bIdentityKey = True) Begin
96106>>>//                        Move C_tAPIColumn_Identity to iOptions
96106>>>//                    End
96106>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
96106>>>//                        Move False to bEqual
96106>>>//                    End
96106>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96106>>>//                End
96106>>>//                Else Begin
96106>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
96106>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
96106>>>//                        Move False to bEqual
96106>>>//                    End
96106>>>//                End
96106>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
96106>>>//                If (iLength <> aColumns[iCount].iLength) Begin
96106>>>//                    Move False to bEqual
96106>>>//                End
96106>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
96106>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
96106>>>//                    Move False to bEqual
96106>>>//                End
96106>>>//                If (bEqual = False) Begin
96106>>>//                    Function_Return False
96106>>>//                End
96106>>>//            End
96106>>>//
96106>>>//            Else Begin
96106>>>//                Function_Return False
96106>>>//            End
96106>>>//        Loop
96106>>>//
96106>>>//        Function_Return bEqual
96106>>>//    End_Function
96106>>>
96106>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
96108>>>        tAPIIndex[] APIIndexes
96108>>>        tAPIIndex[] APIIndexes
96109>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
96109>>>        String sDriverID
96109>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
96109>>>
96109>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96110>>>        Get psDriverID to sDriverID
96111>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96112>>>        Get UtilTableIsSQL hTable to bIsSQLTable
96113>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96116>>>        If (bIsOpen = False) Begin
96118>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96119>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96120>>>            Open hTable
96122>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96123>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96124>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96127>>>            If (bIsOpen = False) Begin
96129>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96130>>>                Move True to APIIndexes[0].bError
96131>>>                Function_Return APIIndexes
96132>>>            End
96132>>>>
96132>>>        End
96132>>>>
96132>>>
96132>>>        Move 0 to iCount
96133>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
96136>>>        for iIndex from 1 to iIndexes
96142>>>>
96142>>>            // This is a test that the index exists as there might be "holes" aka the index
96142>>>            // numbers doesn't not need to be consequitive:
96142>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96145>>>            If (iNumSegments > 0) Begin
96147>>>
96147>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
96148>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
96151>>>                If (bIsSQLTable = True) Begin
96153>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
96156>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
96159>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
96162>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
96165>>>                End
96165>>>>
96165>>>
96165>>>                Move 0 to iSegmentCount
96166>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96169>>>                For iSegment from 1 to iNumSegments
96175>>>>
96175>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
96178>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
96179>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
96182>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
96185>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
96188>>>                    Increment iSegmentCount
96189>>>                Loop
96190>>>>
96190>>>                Increment iCount
96191>>>            End
96191>>>>
96191>>>        Loop
96192>>>>
96192>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96193>>>
96193>>>        Function_Return APIIndexes
96194>>>    End_Function
96195>>>
96195>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
96195>>>    // The combined data will be sorted on the first struct member: iIndexNumber
96195>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
96195>>>    // have "holes" in the series of index numbers.
96195>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
96197>>>        tAPIIndexCompare[] aAPIIndexCompare
96197>>>        tAPIIndexCompare[] aAPIIndexCompare
96198>>>        tAPIIndexCompare   APIIndexCompare
96198>>>        tAPIIndexCompare   APIIndexCompare
96198>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
96198>>>
96198>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
96199>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
96200>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
96202>>>            Function_Return aAPIIndexCompare
96203>>>        End
96203>>>>
96203>>>
96203>>>        Decrement iSizeFrom
96204>>>        for iCount from 0 to iSizeFrom
96210>>>>
96210>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
96211>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
96212>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
96213>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
96214>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
96215>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
96216>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
96217>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
96218>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
96219>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
96220>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
96221>>>        Loop
96222>>>>
96222>>>
96222>>>        Decrement iSizeTo
96223>>>        for iCount from 0 to iSizeTo
96229>>>>
96229>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
96230>>>            // Search if the Index number already exists in the array; else add it.
96230>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
96231>>>            If (iItem = -1) Begin
96233>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
96234>>>            End
96234>>>>
96234>>>
96234>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
96235>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
96236>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
96237>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
96238>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
96239>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
96240>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
96241>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
96242>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
96243>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
96244>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
96245>>>        Loop
96246>>>>
96246>>>
96246>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
96247>>>
96247>>>        Function_Return aAPIIndexCompare
96248>>>    End_Function
96249>>>
96249>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
96249>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
96251>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
96251>>>        String sDriverID
96251>>>
96251>>>        Get psDriverID to sDriverID
96252>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96253>>>        Get IsSQLDriver sDriverID to bIsSqlTable
96254>>>        If (bIsSqlTable = True) Begin
96256>>>            Get UtilTableIsSQL hTable to bIsSqlTable
96257>>>        End
96257>>>>
96257>>>
96257>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
96258>>>        If (bIsSame = False) Begin
96260>>>            Function_Return False
96261>>>        End
96261>>>>
96261>>>
96261>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
96263>>>            // Don't think we should do this. Or should we?
96263>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
96263>>>
96263>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
96264>>>            If (bIsSame = False) Begin
96266>>>                Function_Return False
96267>>>            End
96267>>>>
96267>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
96268>>>            If (bIsSame = False) Begin
96270>>>                Function_Return False
96271>>>            End
96271>>>>
96271>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
96272>>>            If (bIsSame = False) Begin
96274>>>                Function_Return False
96275>>>            End
96275>>>>
96275>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
96276>>>            If (bIsSame = False) Begin
96278>>>                Function_Return False
96279>>>            End
96279>>>>
96279>>>        End
96279>>>>
96279>>>
96279>>>        Function_Return bIsSame
96280>>>    End_Function
96281>>>
96281>>>    // DF_INDEX_SQL_TYPE values
96281>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
96281>>>    // returns a string with the name.
96281>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
96283>>>        String sRetval
96283>>>        Case Begin
96283>>>            Case (iIndexType = DF_INDEX_CLIENT)
96285>>>                Move "DF_INDEX_CLIENT" to sRetval
96286>>>                Case Break
96287>>>            Case (iIndexType = DF_INDEX_SERVER)
96290>>>                Move "DF_INDEX_SERVER" to sRetval
96291>>>                Case Break
96292>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
96295>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
96296>>>                Case Break
96297>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
96300>>>                Move "DF_INDEX_TEMPORARY" to sRetval
96301>>>                Case Break
96302>>>            Case Else
96302>>>                Move "UNKNOWN INDEX TYPE" to sRetval
96303>>>        Case End
96303>>>        Function_Return sRetval
96304>>>    End_Function
96305>>>
96305>>>    // * Dummy function for the Studio's Code Explorer *
96305>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
96307>>>        Function_Return False
96308>>>    End_Function
96309>>>
96309>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
96309>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
96311>>>        Boolean bIsSame
96311>>>        Integer iSize iCount
96311>>>
96311>>>        Move True to bIsSame
96312>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
96313>>>        Decrement iSize
96314>>>        For iCount from 0 to iSize
96320>>>>
96320>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
96321>>>            If (bIsSame = False) Begin
96323>>>                Function_Return False
96324>>>            End
96324>>>>
96324>>>        Loop
96325>>>>
96325>>>
96325>>>        Function_Return bIsSame
96326>>>    End_Function
96327>>>
96327>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
96327>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
96329>>>        Boolean bIsSame
96329>>>
96329>>>        Move True to bIsSame
96330>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
96332>>>            Function_Return False
96333>>>        End
96333>>>>
96333>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
96335>>>            Function_Return False
96336>>>        End
96336>>>>
96336>>>
96336>>>        // We could also compare field names, but I don't think that is necessary...
96336>>>
96336>>>        Function_Return bIsSame
96337>>>    End_Function
96338>>>
96338>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
96338>>>    // already exists.
96338>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
96340>>>        Boolean bOK
96340>>>        Integer iSizeTo iSize iCount iColumn
96340>>>        String sDriverID
96340>>>
96340>>>        Move True to bOK
96341>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
96342>>>        If (iSizeTo > 0) Begin
96344>>>            Get AutoConnectionIDLogin to bOK
96345>>>            Move False to Err
96346>>>            Open hTable Mode DF_EXCLUSIVE
96348>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96351>>>            Decrement iSizeTo
96352>>>
96352>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
96352>>>            // for the "TO" database. But start by deleting all current "TO" relations:
96352>>>            Structure_Start hTable sDriverID
96353>>>                for iCount from 0 to iSizeTo
96359>>>>
96359>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
96360>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
96363>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
96366>>>                Loop
96367>>>>
96367>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
96368>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96370>>>            Set Action_Text of ghoStatusPanel to ""
96371>>>        End
96371>>>>
96371>>>
96371>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
96372>>>        Decrement iSize
96373>>>        for iCount from 0 to iSize
96379>>>>
96379>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
96380>>>        Loop
96381>>>>
96381>>>
96381>>>        Function_Return bOK
96382>>>    End_Function
96383>>>
96383>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
96385>>>        tAPIRelation[] APIRelations
96385>>>        tAPIRelation[] APIRelations
96386>>>        Integer iColumn iColumnTo iNumColumns iCount
96386>>>        Handle hParent
96386>>>        Boolean bIsOpen
96386>>>
96386>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96387>>>        Move 0 to iCount
96388>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96391>>>        If (bIsOpen = False) Begin
96393>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96394>>>            Open hTable
96396>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96397>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96400>>>            If (bIsOpen = False) Begin
96402>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96403>>>                Move True to APIRelations[0].bError
96404>>>                Function_Return APIRelations
96405>>>            End
96405>>>>
96405>>>        End
96405>>>>
96405>>>
96405>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
96408>>>        For iColumn from 1 to iNumColumns
96414>>>>
96414>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
96417>>>            If (hParent <> 0) Begin
96419>>>                Open hParent
96421>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
96422>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
96425>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
96426>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
96429>>>
96429>>>                Move hParent                                            to APIRelations[iCount].hTableTo
96430>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
96433>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
96436>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
96437>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
96440>>>                Move False                                              to APIRelations[iCount].bShouldChange
96441>>>                Move False                                              to APIRelations[iCount].bCancel
96442>>>                Move False                                              to APIRelations[iCount].bError
96443>>>                Close hParent
96444>>>                Increment iCount
96445>>>            End
96445>>>>
96445>>>        Loop
96446>>>>
96446>>>
96446>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96447>>>        Function_Return APIRelations
96448>>>    End_Function
96449>>>
96449>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
96451>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
96453>>>            Function_Return (EQ)
96454>>>        End
96454>>>>
96454>>>
96454>>>        Function_Return (GT)
96455>>>    End_Function
96456>>>
96456>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
96458>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
96461>>>
96461>>>        Function_Return (GT)
96462>>>    End_Function
96463>>>
96463>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
96463>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
96463>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
96465>>>        tAPIRelation[] aAPIRelationFromAndTo
96465>>>        tAPIRelation[] aAPIRelationFromAndTo
96466>>>        tAPIRelationCompare[] aAPIRelationCompare
96466>>>        tAPIRelationCompare[] aAPIRelationCompare
96467>>>        tAPIRelationCompare   APIRelationCompare
96467>>>        tAPIRelationCompare   APIRelationCompare
96467>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
96467>>>
96467>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
96468>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
96469>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
96471>>>            Function_Return aAPIRelationCompare
96472>>>        End
96472>>>>
96472>>>
96472>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
96473>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
96474>>>
96474>>>        Decrement iSizeFrom
96475>>>        for iCount from 0 to iSizeFrom
96481>>>>
96481>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
96482>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
96483>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
96484>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
96485>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
96486>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
96487>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
96488>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
96489>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
96490>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
96491>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
96492>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
96493>>>        Loop
96494>>>>
96494>>>
96494>>>        Decrement iSizeTo
96495>>>        for iCount from 0 to iSizeTo
96501>>>>
96501>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
96502>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
96503>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
96504>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
96505>>>
96505>>>            // Search if the relation already exists in the array; else add it.
96505>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
96506>>>            If (iItem = -1) Begin
96508>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
96509>>>            End
96509>>>>
96509>>>
96509>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
96510>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
96511>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
96512>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
96513>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
96514>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
96515>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
96516>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
96517>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
96518>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
96519>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
96520>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
96521>>>        Loop
96522>>>>
96522>>>
96522>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
96523>>>
96523>>>        Function_Return aAPIRelationCompare
96524>>>    End_Function
96525>>>
96525>>>    // * Dummy function for the Studio's Code Explorer *
96525>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
96527>>>        Function_Return False
96528>>>    End_Function
96529>>>
96529>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
96529>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
96529>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
96529>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
96531>>>        Boolean bFound
96531>>>
96531>>>        Move False to Err
96532>>>        Open CodeMast
96534>>>        Open CodeType
96536>>>
96536>>>        If (bCodeType = True) Begin
96538>>>            Set Private.phCurrentTable to CODETYPE.File_Number
96539>>>            Clear CodeType
96540>>>            Move sTypeValue to CODETYPE.Type
96541>>>            Find eq CODETYPE by 1
96542>>>>
96542>>>            Move Found to bFound
96543>>>            If (bFound = True) Begin
96545>>>                Reread CodeType
96549>>>            End
96549>>>>
96549>>>            Else Begin
96550>>>                Clear CodeType
96551>>>            End
96551>>>>
96551>>>
96551>>>            Move sTypeValue to CODETYPE.Type
96552>>>            Move sValue2    to CODETYPE.Description
96553>>>            Move sValue3    to CODETYPE.Comment
96554>>>            SaveRecord CODETYPE
96555>>>
96555>>>            If (bFound = True) Begin
96557>>>                Unlock
96558>>>>
96558>>>            End
96558>>>>
96558>>>        End
96558>>>>
96558>>>
96558>>>        If (bCodeType = False) Begin
96560>>>            Set Private.phCurrentTable to CODEMAST.File_Number
96561>>>            Clear CODEMAST
96562>>>            Move sTypeValue to CODEMAST.Type
96563>>>            Move sValue2    to CODEMAST.Code
96564>>>            Find eq CODEMAST by 1
96565>>>>
96565>>>            Move Found to bFound
96566>>>            If (bFound = True) Begin
96568>>>                Reread CODEMAST
96572>>>            End
96572>>>>
96572>>>            Else Begin
96573>>>                Clear CODEMAST
96574>>>            End
96574>>>>
96574>>>
96574>>>            Move sTypeValue to CODEMAST.Type
96575>>>            Move sValue2    to CODEMAST.Code
96576>>>            Move sValue3    to CODEMAST.Description
96577>>>            SaveRecord CODEMAST
96578>>>
96578>>>            If (bFound = True) Begin
96580>>>                Unlock
96581>>>>
96581>>>            End
96581>>>>
96581>>>        End
96581>>>>
96581>>>
96581>>>        Close CodeMast
96582>>>        Close CodeType
96583>>>
96583>>>        Function_Return (Err = False)
96584>>>    End_Function
96585>>>
96585>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
96585>>>    // CodeType and then spins through all CodeMast records to change all related records.
96585>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
96587>>>        Boolean bFound
96587>>>
96587>>>        Move False to Err
96588>>>        Open CodeMast
96590>>>        Open CodeType
96592>>>
96592>>>        Clear CodeType
96593>>>        Move sFromValue to CODETYPE.Type
96594>>>        Find eq CODETYPE.Type
96595>>>>
96595>>>        If (Found = True) Begin
96597>>>            Reread CODETYPE
96601>>>                Move sToValue to CODETYPE.Type
96602>>>                SaveRecord CODETYPE
96603>>>            Unlock
96604>>>>
96604>>>        End
96604>>>>
96604>>>
96604>>>        Clear CODEMAST
96605>>>        Find gt CODEMAST by Recnum
96606>>>>
96606>>>        While (Found = True)
96610>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
96611>>>            If (bFound = True) Begin
96613>>>                Reread CODEMAST
96617>>>                    Move sToValue to CODEMAST.Type
96618>>>                    SaveRecord CODEMAST
96619>>>                Unlock
96620>>>>
96620>>>            End
96620>>>>
96620>>>            Find gt CODEMAST by Recnum
96621>>>>
96621>>>        Loop
96622>>>>
96622>>>
96622>>>        Close CodeMast
96623>>>        Close CodeType
96624>>>
96624>>>        Function_Return (Err = False)
96625>>>    End_Function
96626>>>
96626>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
96626>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
96628>>>        Boolean bFound
96628>>>
96628>>>        Move False to Err
96629>>>        Open CodeMast
96631>>>
96631>>>        Clear CODEMAST
96632>>>        Move sTypeValue to CODEMAST.Type
96633>>>        Move sValue2    to CODEMAST.Code
96634>>>        Find eq CODEMAST.Code
96635>>>>
96635>>>        Move Found to bFound
96636>>>        If (bFound = True) Begin
96638>>>            Delete CODEMAST
96639>>>        End
96639>>>>
96639>>>
96639>>>        Close CodeMast
96640>>>
96640>>>        Function_Return (Err = False)
96641>>>    End_Function
96642>>>
96642>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
96644>>>        Boolean bRecnum bToAnsi
96644>>>        Integer iCh
96644>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
96644>>>
96644>>>        If (Trim(sDataPath) = "") Begin
96646>>>            Function_Return False
96647>>>        End
96647>>>>
96647>>>
96647>>>        Move False to Err
96648>>>        Get psDriverID     to sDriverID
96649>>>        Get psConnectionID to sConnectionID
96650>>>        Get psSchema       to sSchemaName
96651>>>        Get True           to bRecnum
96652>>>        Get pbToANSI       to bToAnsi
96653>>>        Move CS_ANSI_Txt to sANSI_OEM
96654>>>        If (bToAnsi = False) Begin
96656>>>            Move CS_OEM_Txt to sANSI_OEM
96657>>>        End
96657>>>>
96657>>>
96657>>>        Get vFolderFormat sDataPath to sDataPath
96658>>>        Move "CodeMast.int"         to sFileName
96659>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
96660>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
96663>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
96666>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
96669>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
96672>>>            Writeln channel iCh ("")
96675>>>            Writeln channel iCh ("RECNUM_TABLE YES")
96678>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
96681>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
96684>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
96687>>>            Writeln channel iCh ("")
96690>>>            Writeln channel iCh ("INDEX_NUMBER 1")
96693>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
96696>>>            Writeln channel iCh ("")
96699>>>        Send Seq_Close_Channel iCh
96700>>>
96700>>>        Get vFolderFormat sDataPath to sDataPath
96701>>>        Move "CodeType.int"         to sFileName
96702>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
96703>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
96706>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
96709>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
96712>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
96715>>>            Writeln channel iCh ("")
96718>>>            Writeln channel iCh ("RECNUM_TABLE YES")
96721>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
96724>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
96727>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
96730>>>            Writeln channel iCh ("")
96733>>>            Writeln channel iCh ("INDEX_NUMBER 0")
96736>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
96739>>>            Writeln channel iCh ("")
96742>>>            Writeln channel iCh ("INDEX_NUMBER 1")
96745>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
96748>>>            Writeln channel iCh ("")
96751>>>        Send Seq_Close_Channel iCh
96752>>>
96752>>>        Function_Return (Err = False)
96753>>>    End_Function
96754>>>
96754>>>    // * Dummy function for the Studio's Code Explorer *
96754>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
96756>>>        Function_Return False
96757>>>    End_Function
96758>>>
96758>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
96758>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
96758>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
96760>>>        Boolean bOK bExists
96760>>>        String sDataPath sBackupFolder
96760>>>
96760>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
96761>>>        Move CS_DUFBackupDataFolder to sBackupFolder
96762>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96763>>>        Get vFolderFormat sDataPath to sDataPath
96764>>>
96764>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96765>>>        If (bExists = False) Begin
96767>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
96768>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96769>>>            If (bExists = False) Begin
96771>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
96772>>>>
96772>>>                Function_Return False
96773>>>            End
96773>>>>
96773>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
96774>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
96775>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
96776>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
96777>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
96778>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
96779>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
96780>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
96781>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
96782>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
96783>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
96784>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
96785>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
96786>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
96787>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
96788>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
96789>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
96790>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
96791>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
96792>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
96793>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
96794>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
96795>>>        End
96795>>>>
96795>>>
96795>>>        Set Message_Text of ghoStatusPanel to ""
96796>>>        Function_Return True
96797>>>    End_Function
96798>>>    
96798>>>    // Check if the file exists in the Data folder,
96798>>>    // else creates it from memory as it has been compiled into the program as a resource:
96798>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
96800>>>        String sPath
96800>>>        Boolean bExists
96800>>>
96800>>>        Get psDataPathFirstPart to sPath
96801>>>        Move (sPath + sFileName) to sFileName
96802>>>        Get vFilePathExists sFileName to bExists
96803>>>
96803>>>        If (bExists = False) Begin
96805>>>            // Read from memory & create file on disk.
96805>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
96806>>>            Get vFilePathExists sFileName to bExists
96807>>>        End
96807>>>>
96807>>>        Function_Return bExists
96808>>>    End_Function
96809>>>
96809>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
96811>>>        tColumnType RetvalType
96811>>>        tColumnType RetvalType
96811>>>        Integer iRetval
96811>>>
96811>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96812>>>        Move RetvalType.iDataFlexType to iRetval
96813>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
96815>>>            If (iLength <= 255) Begin
96817>>>                Move DF_ASCII to iRetval
96818>>>            End
96818>>>>
96818>>>        End
96818>>>>
96818>>>        Function_Return iRetval
96819>>>    End_Function
96820>>>
96820>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
96822>>>        String sRetval
96822>>>
96822>>>        Case Begin
96822>>>            Case (iDataType = DF_ASCII)
96824>>>                Move "DF_ASCII" to sRetval
96825>>>                Case Break
96826>>>            Case (iDataType = DF_BCD)
96829>>>                Move "DF_BCD" to sRetval
96830>>>                Case Break
96831>>>            Case (iDataType = DF_BINARY)
96834>>>                Move "DF_BINARY" to sRetval
96835>>>                Case Break
96836>>>            Case (iDataType = DF_DATE)
96839>>>                Move "DF_DATE" to sRetval
96840>>>                Case Break
96841>>>            Case (iDataType = DF_DATETIME)
96844>>>                Move "DF_DATETIME" to sRetval
96845>>>                Case Break
96846>>>            Case (iDataType = DF_TEXT)
96849>>>                Move "DF_TEXT" to sRetval
96850>>>                Case Break
96851>>>            Case Else
96851>>>                Move "" to sRetval
96852>>>        Case End
96852>>>
96852>>>        Function_Return sRetval
96853>>>    End_Function
96854>>>
96854>>>    // The default value used for a datatype as specified in the driver int file.
96854>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
96856>>>        String sRetval sServer
96856>>>        tColumnType RetvalType
96856>>>        tColumnType RetvalType
96856>>>        Integer iDriver iDataFlexType
96856>>>        Handle hDatabase
96856>>>
96856>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96857>>>        Move RetvalType.iDataFlexType to iDataFlexType
96858>>>        Get DriverIndex sDriverID to iDriver
96859>>>        Get psServer to sServer
96860>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
96861>>>        If (hDatabase = 0) Begin
96863>>>            Function_Return ""
96864>>>        End
96864>>>>
96864>>>
96864>>>        Case Begin
96864>>>            Case (iDataFlexType = DF_ASCII)
96866>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
96869>>>                Case Break
96870>>>            Case (iDataFlexType = DF_BCD)
96873>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
96876>>>                Case Break
96877>>>            Case (iDataFlexType = DF_BINARY)
96880>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
96883>>>                Case Break
96884>>>            Case (iDataFlexType = DF_DATE)
96887>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
96890>>>                Case Break
96891>>>            Case (iDataFlexType = DF_DATETIME)
96894>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
96897>>>                Case Break
96898>>>            Case (iDataFlexType = DF_TEXT)
96901>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
96904>>>                Case Break
96905>>>            Case Else
96905>>>                Move "" to sRetval
96906>>>        Case End
96906>>>
96906>>>        Function_Return sRetval
96907>>>    End_Function
96908>>>
96908>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
96910>>>        String sDriverID sServer
96910>>>        tColumnType RetvalType
96910>>>        tColumnType RetvalType
96910>>>        Integer iDbType iDriver
96910>>>        Handle hDatabase
96910>>>
96910>>>        Get psDriverID to sDriverID
96911>>>        Get piDbType   to iDbType
96912>>>        Get DriverIndex sDriverID to iDriver
96913>>>        Get psServer to sServer
96914>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
96915>>>        If (hDatabase = 0) Begin
96917>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
96918>>>>
96918>>>            Procedure_Return
96919>>>        End
96919>>>>
96919>>>
96919>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
96922>>>
96922>>>    End_Procedure
96923>>>
96923>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
96925>>>        String sDriverID sServer
96925>>>        tColumnType RetvalType
96925>>>        tColumnType RetvalType
96925>>>        Integer iDbType iDriver
96925>>>        Handle hDatabase
96925>>>
96925>>>        Get psDriverID to sDriverID
96926>>>        Get piDbType   to iDbType
96927>>>        Get DriverIndex sDriverID to iDriver
96928>>>        Get psServer to sServer
96929>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
96930>>>        If (hDatabase = 0) Begin
96932>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
96933>>>>
96933>>>            Procedure_Return
96934>>>        End
96934>>>>
96934>>>
96934>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
96937>>>
96937>>>    End_Procedure
96938>>>
96938>>>    // Returns a struct array with the default column types for the SQL back-end and how they
96938>>>    // are mapped to the standard DataFlex data types.
96938>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
96938>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
96940>>>        tColumnType[] ColumnTypeArray EmptyArray
96940>>>        tColumnType[] ColumnTypeArray EmptyArray
96942>>>        String sDataType
96942>>>        Integer iDataType iDriverID iCount
96942>>>        Boolean bSQLDriver
96942>>>
96942>>>        Move 0 to iCount
96943>>>        Get DriverIndex sDriverID to iDriverID
96944>>>        Get IsSQLDriver sDriverID to bSQLDriver
96945>>>        If (bSQLDriver = False) Begin
96947>>>            Function_Return EmptyArray
96948>>>        End
96948>>>>
96948>>>
96948>>>        // DF_ASCII
96948>>>        If (sDriverID = ODBC_DRV_ID) Begin
96950>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
96953>>>        End
96953>>>>
96953>>>        Else Begin
96954>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
96957>>>        End
96957>>>>
96957>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
96958>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
96959>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
96960>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
96961>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
96962>>>        Increment iCount
96963>>>
96963>>>        // DF_BINARY
96963>>>        If (sDriverID = ODBC_DRV_ID) Begin
96965>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
96968>>>        End
96968>>>>
96968>>>        Else Begin
96969>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
96972>>>        End
96972>>>>
96972>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
96973>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
96974>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
96975>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
96976>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
96977>>>        Increment iCount
96978>>>
96978>>>        // DF_DATE
96978>>>        If (sDriverID = ODBC_DRV_ID) Begin
96980>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
96983>>>        End
96983>>>>
96983>>>        Else Begin
96984>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
96987>>>        End
96987>>>>
96987>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
96988>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
96989>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
96990>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
96991>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
96992>>>        Increment iCount
96993>>>
96993>>>        // DF_DATETIME
96993>>>        If (sDriverID = ODBC_DRV_ID) Begin
96995>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
96998>>>        End
96998>>>>
96998>>>        Else Begin
96999>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97002>>>        End
97002>>>>
97002>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97003>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
97004>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
97005>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97006>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97007>>>        Increment iCount
97008>>>
97008>>>        // DF_NUMERIC
97008>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97008>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97008>>>        // we make them here all "Numeric"...
97008>>>        Case Begin
97008>>>            Case (sDriverID = MSSQLDRV_ID)
97010>>>                Move SQL_NUMERIC to iDataType
97011>>>                Move "numeric"   to sDataType
97012>>>                Case Break
97013>>>            Case (sDriverID = DB2_DRV_ID)
97016>>>                Move SQL_NUMERIC to iDataType
97017>>>                Move "NUMERIC"   to sDataType
97018>>>                Case Break
97019>>>            Case (sDriverID = SQLFLEX)
97022>>>                Move eSQLServer_NUMERIC to iDataType
97023>>>                Move "numeric"   to sDataType
97024>>>                Case Break
97025>>>            Case (sDriverID = MDSMySQL)
97028>>>                Move eMySQL_DECIMAL to iDataType
97029>>>                Move "decimal"   to sDataType
97030>>>                Case Break
97031>>>            Case (sDriverID = ORAFLEX)
97034>>>                Move eOracle_NUMBER to iDataType
97035>>>                Move "NUMBER"   to sDataType
97036>>>                Case Break
97037>>>            Case (sDriverID = MDSPgSQL)
97040>>>                Move ePgSQL_FLOAT4 to iDataType
97041>>>                Move "decimal"   to sDataType
97042>>>                Case Break
97043>>>            Case Else
97043>>>                Move DF_BCD      to iDataType
97044>>>                Move "Numeric"   to sDataType
97045>>>        Case End
97045>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
97046>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
97047>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97048>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97049>>>        Increment iCount
97050>>>
97050>>>        // DF_TEXT
97050>>>        If (sDriverID = ODBC_DRV_ID) Begin
97052>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97055>>>        End
97055>>>>
97055>>>        Else Begin
97056>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97059>>>        End
97059>>>>
97059>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97060>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
97061>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
97062>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97063>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97064>>>
97064>>>        Function_Return ColumnTypeArray
97065>>>    End_Function
97066>>>
97066>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97068>>>        tColumnType[] ColumnTypeArray
97068>>>        tColumnType[] ColumnTypeArray
97069>>>        tColumnType   ColumnType
97069>>>        tColumnType   ColumnType
97069>>>        Integer iCount iSize
97069>>>
97069>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
97070>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
97071>>>        Decrement iSize
97072>>>
97072>>>        for iCount from 0 to iSize
97078>>>>
97078>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
97080>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
97081>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
97082>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
97083>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
97084>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
97085>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
97086>>>                Move iSize to iCount
97087>>>            End
97087>>>>
97087>>>        Loop
97088>>>>
97088>>>
97088>>>        Function_Return ColumnType
97089>>>    End_Function
97090>>>
97090>>>    // Returns a struct with the default column types for the SQL back-end and how they
97090>>>    // are mapped to a DUF data type.
97090>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97092>>>        tColumnType ColumnType
97092>>>        tColumnType ColumnType
97092>>>        String sDataType
97092>>>        Integer iDriverID iCount
97092>>>
97092>>>        Move 0 to iCount
97093>>>        Get DriverIndex sDriverID to iDriverID
97094>>>
97094>>>        Case Begin
97094>>>            // DF_ASCII
97094>>>            Case (iType = DF_ASCII_DUF)
97096>>>                If (sDriverID = ODBC_DRV_ID) Begin
97098>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
97101>>>                End
97101>>>>
97101>>>                Else Begin
97102>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
97105>>>                End
97105>>>>
97105>>>                Move DF_ASCII    to ColumnType.iDataFlexType
97106>>>                Move "ASCII"     to ColumnType.sDataFlexType
97107>>>                Move sDataType   to ColumnType.sSQLType
97108>>>                Move DF_ASCII    to ColumnType.iSQLType
97109>>>                Move False       to ColumnType.bCanEditSize
97110>>>                Case Break
97111>>>
97111>>>            // DF_BINARY
97111>>>            Case (iType = DF_BINARY_DUF)
97114>>>                If (sDriverID = ODBC_DRV_ID) Begin
97116>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
97119>>>                End
97119>>>>
97119>>>                Else Begin
97120>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
97123>>>                End
97123>>>>
97123>>>                Move DF_BINARY   to ColumnType.iDataFlexType
97124>>>                Move "Binary"    to ColumnType.sDataFlexType
97125>>>                Move sDataType   to ColumnType.sSQLType
97126>>>                Move DF_BINARY   to ColumnType.iSQLType
97127>>>                Move False       to ColumnType.bCanEditSize
97128>>>                Case Break
97129>>>
97129>>>            // DF_DATE
97129>>>            Case (iType = DF_DATE_DUF)
97132>>>                If (sDriverID = ODBC_DRV_ID) Begin
97134>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97137>>>                End
97137>>>>
97137>>>                Else Begin
97138>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97141>>>                End
97141>>>>
97141>>>                Move DF_DATE     to ColumnType.iDataFlexType
97142>>>                Move "Date"      to ColumnType.sDataFlexType
97143>>>                Move sDataType   to ColumnType.sSQLType
97144>>>                Move DF_DATE     to ColumnType.iSQLType
97145>>>                Move True        to ColumnType.bCanEditSize
97146>>>                Case Break
97147>>>
97147>>>            // DF_DATETIME
97147>>>            Case (iType = DF_DATETIME_DUF)
97150>>>                If (sDriverID = ODBC_DRV_ID) Begin
97152>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
97155>>>                End
97155>>>>
97155>>>                Else Begin
97156>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97159>>>                End
97159>>>>
97159>>>                Move DF_DATETIME to ColumnType.iDataFlexType
97160>>>                Move "DateTime"  to ColumnType.sDataFlexType
97161>>>                Move sDataType   to ColumnType.sSQLType
97162>>>                Move DF_DATETIME to ColumnType.iSQLType
97163>>>                Move True        to ColumnType.bCanEditSize
97164>>>                Case Break
97165>>>
97165>>>            // DF_NUMERIC
97165>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97165>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97165>>>            // we make them here all "Numeric"...
97165>>>            // If (sDriverID = ODBC_DRV_ID) Begin
97165>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97165>>>            // End
97165>>>            // Else Begin
97165>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97165>>>            // End
97165>>>            // ToDo: How should we find the best "Numeric" data type here?
97165>>>            Case (iType = DF_BCD_DUF)
97168>>>                Move DF_BCD      to ColumnType.iDataFlexType
97169>>>                Move "Numeric"   to ColumnType.sDataFlexType
97170>>>                Move "Numeric"   to ColumnType.sSQLType
97171>>>                Move SQL_NUMERIC to ColumnType.iSQLType
97172>>>                Move False       to ColumnType.bCanEditSize
97173>>>                Case Break
97174>>>
97174>>>            // DF_TEXT
97174>>>            Case (iType = DF_TEXT_DUF)
97177>>>                If (sDriverID = ODBC_DRV_ID) Begin
97179>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97182>>>                End
97182>>>>
97182>>>                Else Begin
97183>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97186>>>                End
97186>>>>
97186>>>                Move DF_TEXT     to ColumnType.iDataFlexType
97187>>>                Move "Text"      to ColumnType.sDataFlexType
97188>>>                Move sDataType   to ColumnType.sSQLType
97189>>>                Move DF_TEXT     to ColumnType.iSQLType
97190>>>                Move False       to ColumnType.bCanEditSize
97191>>>                Case Break
97192>>>
97192>>>            Case Else
97192>>>                Move -1999       to ColumnType.iDataFlexType
97193>>>                Move "Undefined" to ColumnType.sDataFlexType
97194>>>                Move "Undefined" to ColumnType.sSQLType
97195>>>                Move -1999       to ColumnType.iSQLType
97196>>>                Move True        to ColumnType.bCanEditSize
97197>>>
97197>>>        Case End
97197>>>
97197>>>        Function_Return ColumnType
97198>>>    End_Function
97199>>>
97199>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
97201>>>        String sDataPath sDriverID
97201>>>        Boolean bMertechDriver bOK
97201>>>        Integer iPos
97201>>>
97201>>>        If (sTableName contains ".") Begin
97203>>>            Move (Pos(".", sTableName)) to iPos
97204>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
97205>>>        End
97205>>>>
97205>>>
97205>>>        Get psDriverID to sDriverID
97206>>>        Get psDataPathFirstPart to sDataPath
97207>>>        Get IsMertechDriver sDriverID to bMertechDriver
97208>>>        // First delete the cache file:
97208>>>        If (bMertechDriver = False) Begin
97210>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
97211>>>        End
97211>>>>
97211>>>        Else Begin
97212>>>            Get _MertechDeleteTDFile sTableName to bOK
97213>>>        End
97213>>>>
97213>>>
97213>>>        Function_Return bOK
97214>>>    End_Function
97215>>>
97215>>>    // Changes source code files.
97215>>>    // Pass a file name with full path and a value to search for, together with the value
97215>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
97215>>>    // to use a Connection ID.
97215>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
97215>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
97215>>>    // Returns True if no errors occured.
97215>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
97217>>>        Integer iCh iRow iItems iCount
97217>>>        String sValue sRow
97217>>>        String[] sFileArray
97218>>>        Boolean bExists bIsActive
97218>>>
97218>>>        Move False to Err
97219>>>        Move 0 to iRow
97220>>>
97220>>>        If (ghoStatusPanel <> 0) Begin
97222>>>            Get Active_state of ghoStatusPanel to bIsActive
97223>>>        End
97223>>>>
97223>>>
97223>>>        Get vFilePathExists sFileName to bExists
97224>>>        If (bExists = False) Begin
97226>>>            If (bShowResult = True) Begin
97228>>>                If (bIsActive = True) Begin
97230>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
97231>>>                End
97231>>>>
97231>>>                Else Begin
97232>>>                    Showln "File does not exist: " sFileName
97235>>>                End
97235>>>>
97235>>>            End
97235>>>>
97235>>>            Function_Return False
97236>>>        End
97236>>>>
97236>>>
97236>>>        Get Seq_Open_Input_Channel sFileName to iCh
97237>>>        If (iCh < 1) Begin
97239>>>            Function_Return False
97240>>>        End
97240>>>>
97240>>>
97240>>>        If (bShowResult = True) Begin
97242>>>            If (ghoStatusPanel <> 0) Begin
97244>>>                Get Active_state of ghoStatusPanel to bIsActive
97245>>>                If (bIsActive = True) Begin
97247>>>                    Set Message_Text of ghoStatusPanel to sFileName
97248>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
97249>>>                    Send DoAdvance of ghoProgressBar
97250>>>                End
97250>>>>
97250>>>            End
97250>>>>
97250>>>            Else Begin
97251>>>                Showln ""
97253>>>                Showln "sFileName = " sFileName
97256>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
97261>>>            End
97261>>>>
97261>>>        End
97261>>>>
97261>>>
97261>>>        While (not(SeqEof))
97265>>>            Readln channel iCh sRow
97267>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
97269>>>//                If (bShowResult = True) Begin
97269>>>//                    If (bIsActive = True) Begin
97269>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
97269>>>//                    End
97269>>>//                    Else Begin
97269>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
97269>>>//                    End
97269>>>//                End
97269>>>                // Change the whole line to the new connection id:
97269>>>                Move sChangeTo to sRow
97270>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
97270>>>            End
97270>>>>
97270>>>            Move sRow to sFileArray[iRow]
97271>>>            Increment iRow
97272>>>        Loop
97273>>>>
97273>>>        Send Seq_Close_Channel iCh
97274>>>
97274>>>        Sleep 1 // Wait for Windows to close the file
97275>>>
97275>>>        Get Seq_Open_Output_Channel sFileName to iCh
97276>>>        If (iCh < 1) Begin
97278>>>            Function_Return False
97279>>>        End
97279>>>>
97279>>>        Move (SizeOfArray(sFileArray)) to iItems
97280>>>        Decrement iItems
97281>>>
97281>>>        For iCount from 0 to iItems
97287>>>>
97287>>>            Move sFileArray[iCount] to sValue
97288>>>            Writeln channel iCh sValue
97291>>>        Loop
97292>>>>
97292>>>        Send Seq_Close_Channel iCh
97293>>>
97293>>>        Function_Return (Err = False)
97294>>>    End_Function
97295>>>
97295>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
97297>>>        Integer iRetval
97297>>>        Move 1 to iRetval
97298>>>        If (ghoSQLConnectionHandler <> 0) Begin
97300>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
97301>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
97302>>>        End
97302>>>>
97302>>>        Function_Return (iRetval = 0)
97303>>>    End_Function
97304>>>
97304>>>    // *** DEPRECIATED ***
97304>>>    // Use the AutoSetConnectionID function instead.
97304>>>    // This might be needed by API-methods when a connection id is to be used and
97304>>>    // the connection ID hasn't been established with the driver's CLI interface.
97304>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
97304>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
97304>>>//        String sConnectionString sDriverID
97304>>>//        Boolean bOK bSilent bDawDriver
97304>>>//        Handle hoCLI
97304>>>//
97304>>>//        Move False to bOK
97304>>>//        Get psDriverID to sDriverID
97304>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
97304>>>//        If (bDawDriver = False) Begin
97304>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
97304>>>//            Function_Return False
97304>>>//        End
97304>>>//
97304>>>//        Get psConnectionString to sConnectionString
97304>>>//        Get pbSilentLogin      to bSilent
97304>>>//
97304>>>//        Get phoCLIHandler to hoCLI
97304>>>//        If (hoCLI <> 0) Begin
97304>>>//            Set psDriverID of hoCLI to sDriverID
97304>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
97304>>>//        End
97304>>>//
97304>>>//        Function_Return (bOK = False)
97304>>>//    End_Function
97304>>>
97304>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
97304>>>    // and opens it in "notepad.exe".
97304>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
97304>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
97304>>>    Procedure UtilShowErrorList
97306>>>        tSqlErrorArray aSqlErrorArray
97306>>>        tSqlErrorArray aSqlErrorArray
97306>>>        Integer iRows iCount iCh iErrorNum
97306>>>        String sPath sFileName sErrorTxt sStatement
97306>>>
97306>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
97307>>>        Get vFolderFormat sPath to sPath
97308>>>        Move "SQLErrorLog.txt"  to sFileName
97309>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
97310>>>            Get paSqlErrorArray to aSqlErrorArray
97311>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
97312>>>            If (iRows > 0) Begin
97314>>>                Decrement iRows
97315>>>                for iCount from 0 to iRows
97321>>>>
97321>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
97322>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
97323>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
97324>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
97330>>>                    Writeln channel iCh "SQL Statement: " sStatement
97334>>>                Loop
97335>>>>
97335>>>            End
97335>>>>
97335>>>        Send Seq_Close_Channel iCh
97336>>>
97336>>>        If (iRows > 0) Begin
97338>>>            Runprogram Shell Background (sPath + sFileName)
97339>>>        End
97339>>>>
97339>>>    End_Procedure
97340>>>
97340>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
97340>>>    // and the table needs to exist as an SQL table.
97340>>>    Function UtilTableIsSql Handle hTable Returns Boolean
97342>>>        String sRootName sDriverID
97342>>>        Boolean bIsSQL
97342>>>
97342>>>        Move False to bIsSQL
97343>>>        If (hTable > 0) Begin
97345>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97348>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
97349>>>            If (bIsSQL = True) Begin
97351>>>                Get psDriverID to sDriverID
97352>>>                Get _TableNameOnly sRootName to sRootName
97353>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
97354>>>            End
97354>>>>
97354>>>        End
97354>>>>
97354>>>
97354>>>        Function_Return bIsSQL
97355>>>    End_Function
97356>>>
97356>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
97358>>>        Boolean bIsSQL
97358>>>        Move (sRootName contains ":") to bIsSQL
97359>>>        Function_Return bIsSQL
97360>>>    End_Function
97361>>>
97361>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
97361>>>    // that the embedded .dat file exists on disk.
97361>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
97363>>>        Boolean bExists bIsEmbedded
97363>>>        String sDataPath sRootName
97363>>>
97363>>>        Get UtilTableNumberIsInUse hTable to bExists
97364>>>        If (bExists = False) Begin
97366>>>            Function_Return False
97367>>>        End
97367>>>>
97367>>>
97367>>>        Move False to bIsEmbedded
97368>>>        If (hTable > 0) Begin
97370>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97373>>>            Move (not(sRootName contains ":")) to bIsEmbedded
97374>>>        End
97374>>>>
97374>>>        If (bIsEmbedded = True) Begin
97376>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97377>>>            Get vFolderFormat sDataPath to sDataPath
97378>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
97379>>>        End
97379>>>>
97379>>>
97379>>>        Function_Return bIsEmbedded
97380>>>    End_Function
97381>>>
97381>>>
97381>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
97381>>>    // An Alias file/table is a filelist number that share the same Physical filename
97381>>>    // but the Logical name is different.
97381>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
97381>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
97383>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
97383>>>        Handle hInTable hMasterTable 
97383>>>        Boolean bIsAlias
97383>>>        
97383>>>        Move hTable to hInTable
97384>>>        Move False to bIsAlias
97385>>>        Move 0 to hMasterTable
97386>>>        
97386>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97389>>>        // Remove any prefix with a driver name.
97389>>>        Get _TableNameOnly sRootName to sRootName     
97390>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
97393>>>        Get _TableNameOnly sLogicalName to sLogicalName     
97394>>>        
97394>>>        // If the table has the same root and logical name it can't be an alias,
97394>>>        // so we can safely return a "False".
97394>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
97396>>>            Function_Return False
97397>>>        End
97397>>>>
97397>>>        
97397>>>        // Now we need to find a master table with the same root name (sRootName above),
97397>>>        // as the passed hTable root name.
97397>>>        // A master table always has the same root and logical name.
97397>>>        Move 0 to hTable
97398>>>        Repeat
97398>>>>
97398>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97401>>>            If (hTable > 0 and hTable <> 50) Begin
97403>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
97406>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
97407>>>                // If we found another table with the same root and logical name
97407>>>                // we have found a master table.
97407>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
97409>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
97412>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
97413>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
97415>>>                        Move hTable to hMasterTable   
97416>>>                        Move 0 to hTable // To end the loop.
97417>>>                    End
97417>>>>
97417>>>                End
97417>>>>
97417>>>            End
97417>>>>
97417>>>        Until (hTable = 0)
97419>>>        
97419>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
97421>>>            Move True to bIsAlias
97422>>>        End
97422>>>>
97422>>>        
97422>>>        Function_Return bIsAlias
97423>>>    End_Function
97424>>>
97424>>>    // To Open a table with any driver.
97424>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
97424>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
97424>>>    //
97424>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
97424>>>    // The found flag is still used to indicate if the open was successful or not. The function
97424>>>    // returns a True if successful (table could be opened).
97424>>>    //
97424>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
97424>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
97424>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
97424>>>    // set properly we can open the table.
97424>>>    //
97424>>>    // DAW Driver Syntax:
97424>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
97424>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
97424>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
97424>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
97424>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
97424>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
97424>>>    //
97424>>>    // DAW Driver Sample:
97424>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
97424>>>    //
97424>>>    // Mertech Driver Samples:
97424>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
97424>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
97424>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
97424>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
97424>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
97426>>>        String sTableNameOrg
97426>>>        Boolean bOpen bOK
97426>>>        tSQLConnection SQLConnection
97426>>>        tSQLConnection SQLConnection
97426>>>        
97426>>>        Move False to bOpen
97427>>>        Move sTableName to sTableNameOrg
97428>>>        If (hTable > 0) Begin
97430>>>            Send Ignore_Error of Error_Object_Id 20529
97431>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97432>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
97433>>>            Send Ignore_Error of Error_Object_Id 10
97434>>>            Open hTable Mode iMode
97436>>>            Send Trap_Error of Error_Object_Id 20529
97437>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97438>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
97439>>>            Send Trap_Error of Error_Object_Id 10
97440>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97443>>>            If (bOpen = True) Begin
97445>>>                Function_Return True
97446>>>            End
97446>>>>
97446>>>        End
97446>>>>
97446>>>
97446>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
97447>>>        If (hTable > 0) Begin
97449>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97452>>>        End
97452>>>>
97452>>>
97452>>>        Function_Return bOpen
97453>>>    End_Function
97454>>>
97454>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
97456>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
97456>>>        Boolean bOpen bMertechDriver bOK
97456>>>        tSQLConnection SQLConnection
97456>>>        tSQLConnection SQLConnection
97456>>>
97456>>>        If (hTable < 1) Begin
97458>>>            Function_Return False
97459>>>        End
97459>>>>
97459>>>
97459>>>        Move sTableName to sTableNameOrg
97460>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97461>>>        Move SQLConnection.sDriverID to sDriverID
97462>>>        Get IsMertechDriver sDriverID to bMertechDriver
97463>>>        Move SQLConnection.sConnectionString to sConnection
97464>>>        Move SQLConnection.sSchema to sSchema
97465>>>        If (sSchema = "") Begin
97467>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
97468>>>        End
97468>>>>
97468>>>
97468>>>        // We need to remove the ".int" part of the table name because
97468>>>        // the table name after the "#" in the connection syntax below wants the
97468>>>        // "bare" table name without any extension.
97468>>>        If (sDriverID <> DATAFLEX_ID) Begin
97470>>>            If (Lowercase(sTableName) contains ".int") Begin
97472>>>                Get ParseFileExtension sTableName to sExt
97473>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
97474>>>            End
97474>>>>
97474>>>            Else Begin
97475>>>                Move sTableName to sTableNameShort
97476>>>                Move (Append(sTableName, ".int")) to sTableName
97477>>>            End
97477>>>>
97477>>>            If (bMertechDriver = False) Begin
97479>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
97480>>>                Move sConnection to sTableName
97481>>>            End
97481>>>>
97481>>>        End
97481>>>>
97481>>>
97481>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97482>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
97483>>>        If (hTable = 0) Begin
97485>>>            Get NextFreeFilelistSlot to hTable
97486>>>        End
97486>>>>
97486>>>
97486>>>        Case Begin
97486>>>            Case (sDriverID = MSSQLDRV_ID)
97488>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97488>>>                If (iMode <> DF_EXCLUSIVE) Begin
97490>>>                    Close hTable
97491>>>                    Open sTableName as hTable
97493>>>                End
97493>>>>
97493>>>                Else Begin
97494>>>                    Get OpenTableExclusive hTable to bOK
97495>>>                    If (bOK = False) Begin
97497>>>                        Function_Return False
97498>>>                    End
97498>>>>
97498>>>                End
97498>>>>
97498>>>                Case Break
97499>>>
97499>>>            Case (sDriverID = DB2_DRV_ID)
97502>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97502>>>                If (iMode <> DF_EXCLUSIVE) Begin
97504>>>                    Close hTable
97505>>>                    Open sTableName as hTable
97507>>>                End
97507>>>>
97507>>>                Else Begin
97508>>>                    Get OpenTableExclusive hTable to bOK
97509>>>                    If (bOK = False) Begin
97511>>>                        Function_Return False
97512>>>                    End
97512>>>>
97512>>>                End
97512>>>>
97512>>>                Case Break
97513>>>
97513>>>            Case (sDriverID = ODBC_DRV_ID)
97516>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97516>>>                If (iMode = DF_SHARE) Begin
97518>>>                    Close hTable
97519>>>                    Open sTableName as hTable
97521>>>                End
97521>>>>
97521>>>                Else Begin
97522>>>                    Get OpenTableExclusive hTable to bOK
97523>>>                    If (bOK = False) Begin
97525>>>                        Function_Return False
97526>>>                    End
97526>>>>
97526>>>                End
97526>>>>
97526>>>                Case Break
97527>>>
97527>>>            Case (sDriverID = SQLFLEX)
97530>>>                // ToDo: What is the <owner>? Same as Schema?
97530>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
97530>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
97531>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97531>>>                If (iMode <> DF_EXCLUSIVE) Begin
97533>>>                    Close hTable
97534>>>                    Open sTableName as hTable
97536>>>                End
97536>>>>
97536>>>                Else Begin
97537>>>                    Get OpenTableExclusive hTable to bOK
97538>>>                    If (bOK = False) Begin
97540>>>                        Function_Return False
97541>>>                    End
97541>>>>
97541>>>                End
97541>>>>
97541>>>                Case Break
97542>>>
97542>>>            Case (sDriverID = MDSMySQL)
97545>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
97545>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
97546>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97546>>>                If (iMode <> DF_EXCLUSIVE) Begin
97548>>>                    Close hTable
97549>>>                    Open sTableName as hTable
97551>>>                End
97551>>>>
97551>>>                Else Begin
97552>>>                    Get OpenTableExclusive hTable to bOK
97553>>>                    If (bOK = False) Begin
97555>>>                        Function_Return False
97556>>>                    End
97556>>>>
97556>>>                End
97556>>>>
97556>>>                Case Break
97557>>>
97557>>>            Case (sDriverID = MDSPgSQL)
97560>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
97560>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
97561>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97561>>>                If (iMode <> DF_EXCLUSIVE) Begin
97563>>>                    Close hTable
97564>>>                    Open sTableName as hTable
97566>>>                End
97566>>>>
97566>>>                Else Begin
97567>>>                    Get OpenTableExclusive hTable to bOK
97568>>>                    If (bOK = False) Begin
97570>>>                        Function_Return False
97571>>>                    End
97571>>>>
97571>>>                End
97571>>>>
97571>>>                Case Break
97572>>>
97572>>>            Case (sDriverID = ORAFLEX)
97575>>>                // ToDo: What is the <owner>? Same as Schema?
97575>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
97575>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
97576>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97576>>>                If (iMode <> DF_EXCLUSIVE) Begin
97578>>>                    Close hTable
97579>>>                    Open sTableName as hTable
97581>>>                End
97581>>>>
97581>>>                Else Begin
97582>>>                    Get OpenTableExclusive hTable to bOK
97583>>>                    If (bOK = False) Begin
97585>>>                        Function_Return False
97586>>>                    End
97586>>>>
97586>>>                End
97586>>>>
97586>>>                Case Break
97587>>>
97587>>>            Case (sDriverID = DATAFLEX_ID)
97590>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
97592>>>                    Close hTable
97593>>>                    Open sTableName as hTable
97595>>>                End
97595>>>>
97595>>>                Else If (iMode = DF_EXCLUSIVE) Begin
97598>>>                    Get OpenTableExclusive hTable to bOK
97599>>>                    If (bOK = False) Begin
97601>>>                        Function_Return False
97602>>>                    End
97602>>>>
97602>>>                End
97602>>>>
97602>>>                Else Begin
97603>>>                    Open hTable
97605>>>                End
97605>>>>
97605>>>                Case Break
97606>>>
97606>>>            Case Else
97606>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
97607>>>>
97607>>>        Case End
97607>>>
97607>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97608>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
97609>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
97611>>>            Move False to Found
97612>>>        End
97612>>>>
97612>>>        // If open failed, the Err is set to true,
97612>>>        // but we don't want that because it could end our loop.
97612>>>        Move False to Err
97613>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97616>>>
97616>>>        Function_Return bOpen
97617>>>    End_Function
97618>>>
97618>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
97618>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
97618>>>    // if it is an SQL table
97618>>>    Function UtilTableExists Handle hTable Returns Boolean
97620>>>        Boolean bExists bIsSQLTable
97620>>>        String sDataPath sRootName
97620>>>
97620>>>        Get UtilTableNumberIsInUse hTable to bExists
97621>>>        If (bExists = False) Begin
97623>>>            Function_Return False
97624>>>        End
97624>>>>
97624>>>
97624>>>        Move False to bIsSQLTable
97625>>>        If (hTable > 0) Begin
97627>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97630>>>            Move (sRootName contains ":") to bIsSQLTable
97631>>>        End
97631>>>>
97631>>>        If (bIsSQLTable = True) Begin
97633>>>            Get UtilTableIsSQL hTable to bExists
97634>>>            Function_Return bExists
97635>>>        End
97635>>>>
97635>>>        Else Begin
97636>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97637>>>            Get vFolderFormat sDataPath to sDataPath
97638>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
97639>>>        End
97639>>>>
97639>>>
97639>>>        Function_Return bExists
97640>>>    End_Function
97641>>>
97641>>>    // Pass a table handle
97641>>>    // Returns True if the table exists in filelist.cfg.
97641>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
97643>>>        Handle hTable
97643>>>        Boolean bFound
97643>>>
97643>>>        Move False to bFound
97644>>>        Move 0 to hTable
97645>>>        Repeat
97645>>>>
97645>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97648>>>            If (hTable > 0) Begin
97650>>>                If (hTable = hCheckTable) Begin
97652>>>                    Move True to bFound
97653>>>                End
97653>>>>
97653>>>            End
97653>>>>
97653>>>            If (bFound = True) ;                Break
97656>>>        Until (hTable = 0)
97658>>>
97658>>>        Function_Return (bFound = True)
97659>>>    End_Function
97660>>>
97660>>>    // Pass a table's logical name
97660>>>    // Returns True if the table exists in filelist.cfg.
97660>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
97662>>>        Handle hTable
97662>>>        Boolean bFound
97662>>>        String sCompareTable
97662>>>
97662>>>        Move False to bFound
97663>>>        Move 0 to hTable
97664>>>        Repeat
97664>>>>
97664>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97667>>>            If (hTable > 0) Begin
97669>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
97672>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
97674>>>                    Move True to bFound
97675>>>                End
97675>>>>
97675>>>            End
97675>>>>
97675>>>            If (bFound = True) ;                Break
97678>>>        Until (hTable = 0)
97680>>>
97680>>>        Function_Return (bFound = True)
97681>>>    End_Function
97682>>>
97682>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
97682>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
97684>>>        Boolean bOK bExists
97684>>>        String sDriverID
97684>>>
97684>>>        Get UtilTableExists hTable to bExists
97685>>>        If (bExists = False) Begin
97687>>>            Function_Return DATAFLEX_ID
97688>>>        End
97688>>>>
97688>>>        Get OpenTableExclusive hTable to bOK
97689>>>        If (bOK = False) Begin
97691>>>            Function_Return DATAFLEX_ID
97692>>>        End
97692>>>>
97692>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
97695>>>        Function_Return sDriverID
97696>>>    End_Function
97697>>>
97697>>>    // Number of tables in Filelist.cfg. Returns integger
97697>>>    Function UtilFilelistNoOfTables Returns Integer
97699>>>        Handle hTable
97699>>>        Integer iRetval
97699>>>
97699>>>        Move 0 to hTable
97700>>>        Move 0 to iRetval
97701>>>
97701>>>        Repeat
97701>>>>
97701>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97704>>>            If (hTable > 0) Begin
97706>>>                Increment iRetval
97707>>>            End
97707>>>>
97707>>>        Until (hTable = 0)
97709>>>
97709>>>        Function_Return iRetval
97710>>>    End_Function
97711>>>
97711>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
97711>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
97713>>>        Handle hTable
97713>>>        String sRoot sDriverID
97713>>>        Boolean bIsSQLTable
97713>>>        Integer iPos
97713>>>
97713>>>        Move 0 to hTable
97714>>>        Move "" to sDriverID
97715>>>        Move False to bIsSQLTable
97716>>>
97716>>>        Repeat
97716>>>>
97716>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97719>>>            If (hTable > 0) Begin
97721>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
97724>>>                If (sRoot contains ":") Begin
97726>>>                    Move (Pos(":", sRoot)) to iPos
97727>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
97728>>>                End
97728>>>>
97728>>>                Get IsSQLDriver sDriverID to bIsSQLTable
97729>>>            End
97729>>>>
97729>>>
97729>>>        Until (hTable = 0 or bIsSQLTable = True)
97731>>>
97731>>>        Function_Return sDriverID
97732>>>    End_Function
97733>>>
97733>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
97735>>>        String sRootName
97735>>>        Boolean bIsSQL
97735>>>        Handle hTable
97735>>>
97735>>>        Move False to bIsSQL
97736>>>        Move 0 to hTable
97737>>>        Repeat
97737>>>>
97737>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97740>>>            If (hTable > 0) Begin
97742>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97745>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
97746>>>                If (bIsSQL = True) Begin
97748>>>                    Move 0 to hTable
97749>>>                End
97749>>>>
97749>>>            End
97749>>>>
97749>>>        Until (hTable = 0)
97751>>>
97751>>>        Function_Return (bIsSQL = False)
97752>>>    End_Function
97753>>>
97753>>>    // * Dummy function for the Studio's Code Explorer *
97753>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
97755>>>        Function_Return False
97756>>>    End_Function
97757>>>
97757>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
97759>>>        String  sRetval
97759>>>        String[] sOverlapFieldsArray
97760>>>        Integer iType iColumn iColumns
97760>>>        Boolean bOpen bOverlap
97760>>>
97760>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97763>>>        If (bOpen = False) Begin
97765>>>            Open hTable
97767>>>        End
97767>>>>
97767>>>
97767>>>        Move "" to sRetval
97768>>>
97768>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
97771>>>
97771>>>        for iColumn from 0 to iColumns
97777>>>>
97777>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
97780>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
97782>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
97785>>>                If (bOverlap) Begin
97787>>>                    If (sRetval <> "") Begin
97789>>>                        Append sRetval ","
97790>>>                    End
97790>>>>
97790>>>                    Append sRetval iColumn
97791>>>                End
97791>>>>
97791>>>            End
97791>>>>
97791>>>        Loop
97792>>>>
97792>>>
97792>>>        If (bOpen = False) Begin
97794>>>            Close hTable
97795>>>        End
97795>>>>
97795>>>
97795>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
97796>>>
97796>>>        Function_Return sOverlapFieldsArray
97797>>>    End_Function
97798>>>
97798>>>    // Returns a struct array with all data types for the passed driver & dbtype.
97798>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
97800>>>        tColumnType[] ColumnType
97800>>>        tColumnType[] ColumnType
97801>>>
97801>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
97801>>>        // the dbType.
97801>>>        If (sDriverID = ODBC_DRV_ID) Begin
97803>>>            If (iDbType = EN_DbTypeMySQL) Begin
97805>>>                Move MDSMySQL to sDriverID
97806>>>            End
97806>>>>
97806>>>            If (iDbType = EN_DbTypeMSSQL) Begin
97808>>>                Move MSSQLDRV_ID to sDriverID
97809>>>            End
97809>>>>
97809>>>            If (iDbType = EN_DbTypeDB2) Begin
97811>>>                Move DB2_DRV_ID to sDriverID
97812>>>            End
97812>>>>
97812>>>            If (iDbType = EN_DbTypePostgre) Begin
97814>>>                Move MDSPgSQL to sDriverID
97815>>>            End
97815>>>>
97815>>>        End
97815>>>>
97815>>>
97815>>>        Case Begin
97815>>>            Case (iDbType = EN_dbTypeDataFlex)
97817>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
97818>>>                Case Break
97819>>>
97819>>>            Case (iDbType = EN_DbTypeDB2)
97822>>>                Get _UtilEnumerateDB2Types to ColumnType
97823>>>                Case Break
97824>>>
97824>>>            Case (iDbType = EN_DbTypeMSSQL)
97827>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
97828>>>                Case Break
97829>>>
97829>>>            Case (sDriverID = MDSMySQL)
97832>>>                Get _UtilEnumerateMySQLTypes to ColumnType
97833>>>                Case Break
97834>>>
97834>>>            Case (sDriverID = ORAFLEX)
97837>>>                Get _UtilEnumerateOracleTypes to ColumnType
97838>>>                Case Break
97839>>>
97839>>>            Case (sDriverID = MDSPgSQL)
97842>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
97843>>>                Case Break
97844>>>        Case End
97844>>>
97844>>>        Function_Return ColumnType
97845>>>    End_Function
97846>>>
97846>>>    Function UtilEnumerateODBCDrivers Returns String
97848>>>        Handle hoRegistry hoODBCDriverNames
97848>>>        Boolean bExists bKeyOpened
97848>>>        String sKey
97848>>>        String[] sDrivers
97849>>>        Integer iDriverNames iDriverName
97849>>>
97849>>>        Get Create (RefClass (cRegistry)) to hoRegistry
97850>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
97851>>>        Set pfAccessRights of hoRegistry to Key_Read
97852>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
97853>>>        Get KeyExists of hoRegistry sKey to bExists
97854>>>        If (bExists) Begin
97856>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
97857>>>            If (bKeyOpened) Begin
97859>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
97860>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
97861>>>                If (iDriverNames > 0) Begin
97863>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
97864>>>                    Decrement iDriverNames
97865>>>                    for iDriverName from 0 to iDriverNames
97871>>>>
97871>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
97872>>>                    Loop
97873>>>>
97873>>>                End
97873>>>>
97873>>>                Send CloseKey of hoRegistry
97874>>>            End
97874>>>>
97874>>>        End
97874>>>>
97874>>>        Send Destroy of hoRegistry
97875>>>
97875>>>        Function_Return sDrivers
97876>>>    End_Function
97877>>>
97877>>>    // DataFlex Embedded Database Data Types:
97877>>>    // Helper function for UtilEnumerateColumnTypes
97877>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
97879>>>        tColumnType[] ColumnType
97879>>>        tColumnType[] ColumnType
97880>>>        Integer i
97880>>>
97880>>>        Move DF_ASCII           to ColumnType[i].iSQLType
97881>>>        Move "ASCII"            to ColumnType[i].sSQLType
97882>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
97883>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
97884>>>        Move "254"              to ColumnType[i].sPrecision
97885>>>        Increment i
97886>>>
97886>>>        Move DF_BCD             to ColumnType[i].iSQLType
97887>>>        Move "Numeric"          to ColumnType[i].sSQLType
97888>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
97889>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
97890>>>        Move "14.8"             to ColumnType[i].sPrecision
97891>>>        Increment i
97892>>>
97892>>>        Move DF_DATE            to ColumnType[i].iSQLType
97893>>>        Move "Date"             to ColumnType[i].sSQLType
97894>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
97895>>>        Move "Date"             to ColumnType[i].sDataFlexType
97896>>>        Move "6.0"              to ColumnType[i].sPrecision
97897>>>        Move True               to ColumnType[i].bCanEditSize
97898>>>        Increment i
97899>>>
97899>>>        Move DF_TEXT            to ColumnType[i].iSQLType
97900>>>        Move "Text"             to ColumnType[i].sSQLType
97901>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
97902>>>        Move "Text"             to ColumnType[i].sDataFlexType
97903>>>        Move "16384"            to ColumnType[i].sPrecision
97904>>>        Increment i
97905>>>
97905>>>        Move DF_BINARY          to ColumnType[i].iSQLType
97906>>>        Move "Binary"           to ColumnType[i].sSQLType
97907>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
97908>>>        Move "Binary"           to ColumnType[i].sDataFlexType
97909>>>        Move "16384"            to ColumnType[i].sPrecision
97910>>>        Increment i
97911>>>
97911>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
97912>>>        Move "DateTime"         to ColumnType[i].sSQLType
97913>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
97914>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
97915>>>        Move "23"               to ColumnType[i].sPrecision
97916>>>        Move True               to ColumnType[i].bCanEditSize
97917>>>        Increment i
97918>>>
97918>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
97919>>>        Move "Overlap"          to ColumnType[i].sSQLType
97920>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
97921>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
97922>>>        Move "0.0"              to ColumnType[i].sPrecision
97923>>>
97923>>>        Function_Return ColumnType
97924>>>    End_Function
97925>>>
97925>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
97927>>>        tColumnType[] aColumnType
97927>>>        tColumnType[] aColumnType
97928>>>        Integer i
97928>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
97928>>>>// Generated By The Database Update Framework
97928>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
97928>>>>// Driver COLUMN DATA TYPES
97928>>>>//
97928>>>>// Created: 2019-07-18 18:57:13.935
97928>>>>
97928>>>>            Move "bigint"                                to aColumnType[i].sSQLType
97929>>>>            Move -5                                      to aColumnType[i].iSQLType
97930>>>>            Move True                                    to aColumnType[i].bCanEditSize
97931>>>>            Move True                                    to aColumnType[i].bNativeDataType
97932>>>>            Move 14                                      to aColumnType[i].iDefaultSize
97933>>>>            Move 1                                       to aColumnType[i].iMinSize
97934>>>>            Move 14                                      to aColumnType[i].nMaxSize
97935>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
97936>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
97937>>>>            Move 14                                      to aColumnType[i].sPrecision
97938>>>>            Increment i
97939>>>>
97939>>>>            Move "binary"                                to aColumnType[i].sSQLType
97940>>>>            Move -2                                      to aColumnType[i].iSQLType
97941>>>>            Move True                                    to aColumnType[i].bCanEditSize
97942>>>>            Move True                                    to aColumnType[i].bNativeDataType
97943>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97944>>>>            Move 1                                       to aColumnType[i].iMinSize
97945>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97946>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97947>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97948>>>>            Move 8000                                    to aColumnType[i].sPrecision
97949>>>>            Increment i
97950>>>>
97950>>>>            Move "bit"                                   to aColumnType[i].sSQLType
97951>>>>            Move -7                                      to aColumnType[i].iSQLType
97952>>>>            Move False                                   to aColumnType[i].bCanEditSize
97953>>>>            Move True                                    to aColumnType[i].bNativeDataType
97954>>>>            Move 0                                       to aColumnType[i].iDefaultSize
97955>>>>            Move 0                                       to aColumnType[i].iMinSize
97956>>>>            Move 0                                       to aColumnType[i].nMaxSize
97957>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97958>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97959>>>>            Move 1                                       to aColumnType[i].sPrecision
97960>>>>            Increment i
97961>>>>
97961>>>>            Move "char"                                  to aColumnType[i].sSQLType
97962>>>>            Move 1                                       to aColumnType[i].iSQLType
97963>>>>            Move True                                    to aColumnType[i].bCanEditSize
97964>>>>            Move True                                    to aColumnType[i].bNativeDataType
97965>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97966>>>>            Move 1                                       to aColumnType[i].iMinSize
97967>>>>            Move 8000                                    to aColumnType[i].nMaxSize
97968>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97969>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97970>>>>            Move 8000                                    to aColumnType[i].sPrecision
97971>>>>            Increment i
97972>>>>
97972>>>>            Move "date"                                  to aColumnType[i].sSQLType
97973>>>>            Move 91                                      to aColumnType[i].iSQLType
97974>>>>            Move False                                   to aColumnType[i].bCanEditSize
97975>>>>            Move True                                    to aColumnType[i].bNativeDataType
97976>>>>            Move 0                                       to aColumnType[i].iDefaultSize
97977>>>>            Move 0                                       to aColumnType[i].iMinSize
97978>>>>            Move 0                                       to aColumnType[i].nMaxSize
97979>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97980>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97981>>>>            Move 1                                       to aColumnType[i].sPrecision
97982>>>>            Increment i
97983>>>>
97983>>>>            Move "datetime"                              to aColumnType[i].sSQLType
97984>>>>            Move 93                                      to aColumnType[i].iSQLType
97985>>>>            Move False                                   to aColumnType[i].bCanEditSize
97986>>>>            Move True                                    to aColumnType[i].bNativeDataType
97987>>>>            Move -1                                      to aColumnType[i].iDefaultSize
97988>>>>            Move -1                                      to aColumnType[i].iMinSize
97989>>>>            Move -1                                      to aColumnType[i].nMaxSize
97990>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
97991>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
97992>>>>            Move 23                                      to aColumnType[i].sPrecision
97993>>>>            Increment i
97994>>>>
97994>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
97995>>>>            Move -200                                    to aColumnType[i].iSQLType
97996>>>>            Move True                                    to aColumnType[i].bCanEditSize
97997>>>>            Move True                                    to aColumnType[i].bNativeDataType
97998>>>>            Move 23                                      to aColumnType[i].iDefaultSize
97999>>>>            Move 23                                      to aColumnType[i].iMinSize
98000>>>>            Move 23                                      to aColumnType[i].nMaxSize
98001>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98002>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98003>>>>            Move 23                                      to aColumnType[i].sPrecision
98004>>>>            Increment i
98005>>>>
98005>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98006>>>>            Move -155                                    to aColumnType[i].iSQLType
98007>>>>            Move True                                    to aColumnType[i].bCanEditSize
98008>>>>            Move True                                    to aColumnType[i].bNativeDataType
98009>>>>            Move 34                                      to aColumnType[i].iDefaultSize
98010>>>>            Move 34                                      to aColumnType[i].iMinSize
98011>>>>            Move 34                                      to aColumnType[i].nMaxSize
98012>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98013>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98014>>>>            Move 34                                      to aColumnType[i].sPrecision
98015>>>>            Increment i
98016>>>>
98016>>>>            Move "decimal"                               to aColumnType[i].sSQLType
98017>>>>            Move 3                                       to aColumnType[i].iSQLType
98018>>>>            Move True                                    to aColumnType[i].bCanEditSize
98019>>>>            Move True                                    to aColumnType[i].bNativeDataType
98020>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98021>>>>            Move 1                                       to aColumnType[i].iMinSize
98022>>>>            Move 14                                      to aColumnType[i].nMaxSize
98023>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98024>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98025>>>>            Move 14                                      to aColumnType[i].sPrecision
98026>>>>            Increment i
98027>>>>
98027>>>>            Move "float"                                 to aColumnType[i].sSQLType
98028>>>>            Move 6                                       to aColumnType[i].iSQLType
98029>>>>            Move True                                    to aColumnType[i].bCanEditSize
98030>>>>            Move True                                    to aColumnType[i].bNativeDataType
98031>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98032>>>>            Move 1                                       to aColumnType[i].iMinSize
98033>>>>            Move 14                                      to aColumnType[i].nMaxSize
98034>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98035>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98036>>>>            Move 14                                      to aColumnType[i].sPrecision
98037>>>>            Increment i
98038>>>>
98038>>>>            Move "image"                                 to aColumnType[i].sSQLType
98039>>>>            Move -4                                      to aColumnType[i].iSQLType
98040>>>>            Move True                                    to aColumnType[i].bCanEditSize
98041>>>>            Move True                                    to aColumnType[i].bNativeDataType
98042>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98043>>>>            Move 1                                       to aColumnType[i].iMinSize
98044>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98045>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98046>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98047>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98048>>>>            Increment i
98049>>>>
98049>>>>            Move "int"                                   to aColumnType[i].sSQLType
98050>>>>            Move 4                                       to aColumnType[i].iSQLType
98051>>>>            Move True                                    to aColumnType[i].bCanEditSize
98052>>>>            Move True                                    to aColumnType[i].bNativeDataType
98053>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98054>>>>            Move 1                                       to aColumnType[i].iMinSize
98055>>>>            Move 10                                      to aColumnType[i].nMaxSize
98056>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98057>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98058>>>>            Move 10                                      to aColumnType[i].sPrecision
98059>>>>            Increment i
98060>>>>
98060>>>>            Move "money"                                 to aColumnType[i].sSQLType
98061>>>>            Move -204                                    to aColumnType[i].iSQLType
98062>>>>            Move False                                   to aColumnType[i].bCanEditSize
98063>>>>            Move True                                    to aColumnType[i].bNativeDataType
98064>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98065>>>>            Move 0                                       to aColumnType[i].iMinSize
98066>>>>            Move 0                                       to aColumnType[i].nMaxSize
98067>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98068>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98069>>>>            Move 1                                       to aColumnType[i].sPrecision
98070>>>>            Increment i
98071>>>>
98071>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
98072>>>>            Move -8                                      to aColumnType[i].iSQLType
98073>>>>            Move True                                    to aColumnType[i].bCanEditSize
98074>>>>            Move True                                    to aColumnType[i].bNativeDataType
98075>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98076>>>>            Move 1                                       to aColumnType[i].iMinSize
98077>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98078>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98079>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98080>>>>            Move 4000                                    to aColumnType[i].sPrecision
98081>>>>            Increment i
98082>>>>
98082>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
98083>>>>            Move -10                                     to aColumnType[i].iSQLType
98084>>>>            Move True                                    to aColumnType[i].bCanEditSize
98085>>>>            Move True                                    to aColumnType[i].bNativeDataType
98086>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98087>>>>            Move 1                                       to aColumnType[i].iMinSize
98088>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98089>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98090>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98091>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98092>>>>            Increment i
98093>>>>
98093>>>>            Move "numeric"                               to aColumnType[i].sSQLType
98094>>>>            Move 2                                       to aColumnType[i].iSQLType
98095>>>>            Move True                                    to aColumnType[i].bCanEditSize
98096>>>>            Move True                                    to aColumnType[i].bNativeDataType
98097>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98098>>>>            Move 1                                       to aColumnType[i].iMinSize
98099>>>>            Move 14                                      to aColumnType[i].nMaxSize
98100>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
98101>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
98102>>>>            Move 6                                       to aColumnType[i].sPrecision
98103>>>>            Increment i
98104>>>>
98104>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
98105>>>>            Move -9                                      to aColumnType[i].iSQLType
98106>>>>            Move True                                    to aColumnType[i].bCanEditSize
98107>>>>            Move True                                    to aColumnType[i].bNativeDataType
98108>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98109>>>>            Move 1                                       to aColumnType[i].iMinSize
98110>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98111>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98112>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98113>>>>            Move 4000                                    to aColumnType[i].sPrecision
98114>>>>            Increment i
98115>>>>
98115>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
98116>>>>            Move -202                                    to aColumnType[i].iSQLType
98117>>>>            Move True                                    to aColumnType[i].bCanEditSize
98118>>>>            Move True                                    to aColumnType[i].bNativeDataType
98119>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98120>>>>            Move 1                                       to aColumnType[i].iMinSize
98121>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98122>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98123>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98124>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98125>>>>            Increment i
98126>>>>
98126>>>>            Move "real"                                  to aColumnType[i].sSQLType
98127>>>>            Move 7                                       to aColumnType[i].iSQLType
98128>>>>            Move True                                    to aColumnType[i].bCanEditSize
98129>>>>            Move True                                    to aColumnType[i].bNativeDataType
98130>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98131>>>>            Move 1                                       to aColumnType[i].iMinSize
98132>>>>            Move 14                                      to aColumnType[i].nMaxSize
98133>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98134>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98135>>>>            Move 14                                      to aColumnType[i].sPrecision
98136>>>>            Increment i
98137>>>>
98137>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
98138>>>>            Move -206                                    to aColumnType[i].iSQLType
98139>>>>            Move False                                   to aColumnType[i].bCanEditSize
98140>>>>            Move True                                    to aColumnType[i].bNativeDataType
98141>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98142>>>>            Move 0                                       to aColumnType[i].iMinSize
98143>>>>            Move 0                                       to aColumnType[i].nMaxSize
98144>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98145>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98146>>>>            Move 1                                       to aColumnType[i].sPrecision
98147>>>>            Increment i
98148>>>>
98148>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98149>>>>            Move 5                                       to aColumnType[i].iSQLType
98150>>>>            Move True                                    to aColumnType[i].bCanEditSize
98151>>>>            Move True                                    to aColumnType[i].bNativeDataType
98152>>>>            Move 5                                       to aColumnType[i].iDefaultSize
98153>>>>            Move 1                                       to aColumnType[i].iMinSize
98154>>>>            Move 5                                       to aColumnType[i].nMaxSize
98155>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98156>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98157>>>>            Move 5                                       to aColumnType[i].sPrecision
98158>>>>            Increment i
98159>>>>
98159>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
98160>>>>            Move -205                                    to aColumnType[i].iSQLType
98161>>>>            Move False                                   to aColumnType[i].bCanEditSize
98162>>>>            Move True                                    to aColumnType[i].bNativeDataType
98163>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98164>>>>            Move 0                                       to aColumnType[i].iMinSize
98165>>>>            Move 0                                       to aColumnType[i].nMaxSize
98166>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98167>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98168>>>>            Move 1                                       to aColumnType[i].sPrecision
98169>>>>            Increment i
98170>>>>
98170>>>>            Move "text"                                  to aColumnType[i].sSQLType
98171>>>>            Move -1                                      to aColumnType[i].iSQLType
98172>>>>            Move True                                    to aColumnType[i].bCanEditSize
98173>>>>            Move True                                    to aColumnType[i].bNativeDataType
98174>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98175>>>>            Move 1                                       to aColumnType[i].iMinSize
98176>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98177>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98178>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98179>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98180>>>>            Increment i
98181>>>>
98181>>>>            Move "time"                                  to aColumnType[i].sSQLType
98182>>>>            Move -154                                    to aColumnType[i].iSQLType
98183>>>>            Move True                                    to aColumnType[i].bCanEditSize
98184>>>>            Move True                                    to aColumnType[i].bNativeDataType
98185>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98186>>>>            Move 10                                      to aColumnType[i].iMinSize
98187>>>>            Move 19                                      to aColumnType[i].nMaxSize
98188>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98189>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98190>>>>            Move 19                                      to aColumnType[i].sPrecision
98191>>>>            Increment i
98192>>>>
98192>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
98193>>>>            Move -6                                      to aColumnType[i].iSQLType
98194>>>>            Move True                                    to aColumnType[i].bCanEditSize
98195>>>>            Move True                                    to aColumnType[i].bNativeDataType
98196>>>>            Move 3                                       to aColumnType[i].iDefaultSize
98197>>>>            Move 1                                       to aColumnType[i].iMinSize
98198>>>>            Move 3                                       to aColumnType[i].nMaxSize
98199>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98200>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98201>>>>            Move 3                                       to aColumnType[i].sPrecision
98202>>>>            Increment i
98203>>>>
98203>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
98204>>>>            Move -11                                     to aColumnType[i].iSQLType
98205>>>>            Move False                                   to aColumnType[i].bCanEditSize
98206>>>>            Move True                                    to aColumnType[i].bNativeDataType
98207>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98208>>>>            Move 0                                       to aColumnType[i].iMinSize
98209>>>>            Move 0                                       to aColumnType[i].nMaxSize
98210>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98211>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98212>>>>            Move 1                                       to aColumnType[i].sPrecision
98213>>>>            Increment i
98214>>>>
98214>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
98215>>>>            Move -3                                      to aColumnType[i].iSQLType
98216>>>>            Move True                                    to aColumnType[i].bCanEditSize
98217>>>>            Move True                                    to aColumnType[i].bNativeDataType
98218>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
98219>>>>            Move 1                                       to aColumnType[i].iMinSize
98220>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98221>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98222>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98223>>>>            Move 8000                                    to aColumnType[i].sPrecision
98224>>>>            Increment i
98225>>>>
98225>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
98226>>>>            Move -203                                    to aColumnType[i].iSQLType
98227>>>>            Move True                                    to aColumnType[i].bCanEditSize
98228>>>>            Move True                                    to aColumnType[i].bNativeDataType
98229>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98230>>>>            Move 1                                       to aColumnType[i].iMinSize
98231>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98232>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98233>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98234>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98235>>>>            Increment i
98236>>>>
98236>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98237>>>>            Move 12                                      to aColumnType[i].iSQLType
98238>>>>            Move True                                    to aColumnType[i].bCanEditSize
98239>>>>            Move True                                    to aColumnType[i].bNativeDataType
98240>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98241>>>>            Move 1                                       to aColumnType[i].iMinSize
98242>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98243>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98244>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98245>>>>            Move 8000                                    to aColumnType[i].sPrecision
98246>>>>            Increment i
98247>>>>
98247>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
98248>>>>            Move -201                                    to aColumnType[i].iSQLType
98249>>>>            Move True                                    to aColumnType[i].bCanEditSize
98250>>>>            Move True                                    to aColumnType[i].bNativeDataType
98251>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98252>>>>            Move 1                                       to aColumnType[i].iMinSize
98253>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98254>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98255>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98256>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98257>>>>            Increment i
98258>>>>
98258>>>>            Move "xml"                                   to aColumnType[i].sSQLType
98259>>>>            Move -152                                    to aColumnType[i].iSQLType
98260>>>>            Move True                                    to aColumnType[i].bCanEditSize
98261>>>>            Move True                                    to aColumnType[i].bNativeDataType
98262>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98263>>>>            Move 1                                       to aColumnType[i].iMinSize
98264>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98265>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98266>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98267>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98268>>>>            Increment i
98269>>>>
98269>>>>
98269>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
98269>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "Text"             to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
98269>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.0"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
98269>>>//        Move "BLOB"             to ColumnType[i].sSQLType
98269>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
98269>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
98269>>>//        Move "CHAR"             to ColumnType[i].sSQLType
98269>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98269>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98269>>>//        Move "254"              to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        // ToDo: We need to change the sType when using this!
98269>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
98269>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
98269>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
98269>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
98269>>>//        Move "254"                  to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
98269>>>//        Move "DATE"             to ColumnType[i].sSQLType
98269>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
98269>>>//        Move "Date"             to ColumnType[i].sDataFlexType
98269>>>//        Move "6.0"              to ColumnType[i].sPrecision
98269>>>//        Move True               to ColumnType[i].bCanEditSize
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
98269>>>//        Move "CLOB"             to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "Text"             to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
98269>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.8"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
98269>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.8"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
98269>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.8"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
98269>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
98269>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98269>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98269>>>//        Move "255"              to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
98269>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "9.0"              to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
98269>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "32000"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
98269>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "32000"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
98269>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "32000"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
98269>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.8"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
98269>>>//        Move "REAL"             to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98269>>>//        Move "14.8"             to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
98269>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
98269>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98269>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
98269>>>//        Move "5.0"              to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
98269>>>//        Move "TIME"             to ColumnType[i].sSQLType
98269>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98269>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98269>>>//        Move "19.0"             to ColumnType[i].sPrecision
98269>>>//        Move True               to ColumnType[i].bCanEditSize
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
98269>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
98269>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98269>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
98269>>>//        Move "23.6"             to ColumnType[i].sPrecision
98269>>>//        Move True               to ColumnType[i].bCanEditSize
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
98269>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        // ToDo: We need to change the sType when using this!
98269>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
98269>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"                to ColumnType[i].sPrecision
98269>>>//        Increment i
98269>>>//
98269>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
98269>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>//
98269>>>//        Move SQL_XML            to ColumnType[i].iSQLType
98269>>>//        Move "XML"              to ColumnType[i].sSQLType
98269>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98269>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98269>>>//        Move "16384"            to ColumnType[i].sPrecision
98269>>>
98269>>>        Function_Return aColumnType
98270>>>    End_Function
98271>>>
98271>>>    // Microsoft SQL Server Database Data Types:
98271>>>    // Helper function for UtilEnumerateColumnTypes
98271>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
98273>>>        tColumnType[] aColumnType
98273>>>        tColumnType[] aColumnType
98274>>>        Integer i
98274>>>
98274>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
98276>>>>// Generated By The Database Update Framework
98276>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
98276>>>>// Driver COLUMN DATA TYPES
98276>>>>//
98276>>>>// Created: 2019-11-15 21:57:51.001
98276>>>>
98276>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98277>>>>            Move -5                                      to aColumnType[i].iSQLType
98278>>>>            Move True                                    to aColumnType[i].bCanEditSize
98279>>>>            Move True                                    to aColumnType[i].bNativeDataType
98280>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98281>>>>            Move 1                                       to aColumnType[i].iMinSize
98282>>>>            Move 14                                      to aColumnType[i].nMaxSize
98283>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98284>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98285>>>>            Move 14                                      to aColumnType[i].sPrecision
98286>>>>            Increment i
98287>>>>
98287>>>>            Move "binary"                                to aColumnType[i].sSQLType
98288>>>>            Move -2                                      to aColumnType[i].iSQLType
98289>>>>            Move True                                    to aColumnType[i].bCanEditSize
98290>>>>            Move True                                    to aColumnType[i].bNativeDataType
98291>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98292>>>>            Move 1                                       to aColumnType[i].iMinSize
98293>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98294>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98295>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98296>>>>            Move 8000                                    to aColumnType[i].sPrecision
98297>>>>            Increment i
98298>>>>
98298>>>>            Move "bit"                                   to aColumnType[i].sSQLType
98299>>>>            Move -7                                      to aColumnType[i].iSQLType
98300>>>>            Move False                                   to aColumnType[i].bCanEditSize
98301>>>>            Move True                                    to aColumnType[i].bNativeDataType
98302>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98303>>>>            Move 0                                       to aColumnType[i].iMinSize
98304>>>>            Move 0                                       to aColumnType[i].nMaxSize
98305>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98306>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98307>>>>            Move 1                                       to aColumnType[i].sPrecision
98308>>>>            Increment i
98309>>>>
98309>>>>            Move "char"                                  to aColumnType[i].sSQLType
98310>>>>            Move 1                                       to aColumnType[i].iSQLType
98311>>>>            Move True                                    to aColumnType[i].bCanEditSize
98312>>>>            Move True                                    to aColumnType[i].bNativeDataType
98313>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98314>>>>            Move 1                                       to aColumnType[i].iMinSize
98315>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98316>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98317>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98318>>>>            Move 8000                                    to aColumnType[i].sPrecision
98319>>>>            Increment i
98320>>>>
98320>>>>            Move "date"                                  to aColumnType[i].sSQLType
98321>>>>            Move 91                                      to aColumnType[i].iSQLType
98322>>>>            Move False                                   to aColumnType[i].bCanEditSize
98323>>>>            Move True                                    to aColumnType[i].bNativeDataType
98324>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98325>>>>            Move 0                                       to aColumnType[i].iMinSize
98326>>>>            Move 0                                       to aColumnType[i].nMaxSize
98327>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
98328>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
98329>>>>            Move 6                                       to aColumnType[i].sPrecision
98330>>>>            Increment i
98331>>>>
98331>>>>            Move "datetime"                              to aColumnType[i].sSQLType
98332>>>>            Move 93                                      to aColumnType[i].iSQLType
98333>>>>            Move False                                   to aColumnType[i].bCanEditSize
98334>>>>            Move True                                    to aColumnType[i].bNativeDataType
98335>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98336>>>>            Move -1                                      to aColumnType[i].iMinSize
98337>>>>            Move -1                                      to aColumnType[i].nMaxSize
98338>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98339>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98340>>>>            Move 23                                      to aColumnType[i].sPrecision
98341>>>>            Increment i
98342>>>>
98342>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
98343>>>>            Move -200                                    to aColumnType[i].iSQLType
98344>>>>            Move True                                    to aColumnType[i].bCanEditSize
98345>>>>            Move True                                    to aColumnType[i].bNativeDataType
98346>>>>            Move 23                                      to aColumnType[i].iDefaultSize
98347>>>>            Move 23                                      to aColumnType[i].iMinSize
98348>>>>            Move 23                                      to aColumnType[i].nMaxSize
98349>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98350>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98351>>>>            Move 23                                      to aColumnType[i].sPrecision
98352>>>>            Increment i
98353>>>>
98353>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98354>>>>            Move -155                                    to aColumnType[i].iSQLType
98355>>>>            Move True                                    to aColumnType[i].bCanEditSize
98356>>>>            Move True                                    to aColumnType[i].bNativeDataType
98357>>>>            Move 34                                      to aColumnType[i].iDefaultSize
98358>>>>            Move 34                                      to aColumnType[i].iMinSize
98359>>>>            Move 34                                      to aColumnType[i].nMaxSize
98360>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98361>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98362>>>>            Move 34                                      to aColumnType[i].sPrecision
98363>>>>            Increment i
98364>>>>
98364>>>>            Move "decimal"                               to aColumnType[i].sSQLType
98365>>>>            Move 3                                       to aColumnType[i].iSQLType
98366>>>>            Move True                                    to aColumnType[i].bCanEditSize
98367>>>>            Move True                                    to aColumnType[i].bNativeDataType
98368>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98369>>>>            Move 1                                       to aColumnType[i].iMinSize
98370>>>>            Move 14                                      to aColumnType[i].nMaxSize
98371>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98372>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98373>>>>            Move 14                                      to aColumnType[i].sPrecision
98374>>>>            Increment i
98375>>>>
98375>>>>            Move "float"                                 to aColumnType[i].sSQLType
98376>>>>            Move 6                                       to aColumnType[i].iSQLType
98377>>>>            Move True                                    to aColumnType[i].bCanEditSize
98378>>>>            Move True                                    to aColumnType[i].bNativeDataType
98379>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98380>>>>            Move 1                                       to aColumnType[i].iMinSize
98381>>>>            Move 14                                      to aColumnType[i].nMaxSize
98382>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98383>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98384>>>>            Move 14                                      to aColumnType[i].sPrecision
98385>>>>            Increment i
98386>>>>
98386>>>>            Move "image"                                 to aColumnType[i].sSQLType
98387>>>>            Move -4                                      to aColumnType[i].iSQLType
98388>>>>            Move True                                    to aColumnType[i].bCanEditSize
98389>>>>            Move True                                    to aColumnType[i].bNativeDataType
98390>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98391>>>>            Move 1                                       to aColumnType[i].iMinSize
98392>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98393>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98394>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98395>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98396>>>>            Increment i
98397>>>>
98397>>>>            Move "int"                                   to aColumnType[i].sSQLType
98398>>>>            Move 4                                       to aColumnType[i].iSQLType
98399>>>>            Move True                                    to aColumnType[i].bCanEditSize
98400>>>>            Move True                                    to aColumnType[i].bNativeDataType
98401>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98402>>>>            Move 1                                       to aColumnType[i].iMinSize
98403>>>>            Move 10                                      to aColumnType[i].nMaxSize
98404>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98405>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98406>>>>            Move 10                                      to aColumnType[i].sPrecision
98407>>>>            Increment i
98408>>>>
98408>>>>            Move "money"                                 to aColumnType[i].sSQLType
98409>>>>            Move -204                                    to aColumnType[i].iSQLType
98410>>>>            Move False                                   to aColumnType[i].bCanEditSize
98411>>>>            Move True                                    to aColumnType[i].bNativeDataType
98412>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98413>>>>            Move 0                                       to aColumnType[i].iMinSize
98414>>>>            Move 0                                       to aColumnType[i].nMaxSize
98415>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98416>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98417>>>>            Move 1                                       to aColumnType[i].sPrecision
98418>>>>            Increment i
98419>>>>
98419>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
98420>>>>            Move -8                                      to aColumnType[i].iSQLType
98421>>>>            Move True                                    to aColumnType[i].bCanEditSize
98422>>>>            Move True                                    to aColumnType[i].bNativeDataType
98423>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98424>>>>            Move 1                                       to aColumnType[i].iMinSize
98425>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98426>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98427>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98428>>>>            Move 4000                                    to aColumnType[i].sPrecision
98429>>>>            Increment i
98430>>>>
98430>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
98431>>>>            Move -10                                     to aColumnType[i].iSQLType
98432>>>>            Move True                                    to aColumnType[i].bCanEditSize
98433>>>>            Move True                                    to aColumnType[i].bNativeDataType
98434>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98435>>>>            Move 1                                       to aColumnType[i].iMinSize
98436>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98437>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98438>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98439>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98440>>>>            Increment i
98441>>>>
98441>>>>            Move "numeric"                               to aColumnType[i].sSQLType
98442>>>>            Move 2                                       to aColumnType[i].iSQLType
98443>>>>            Move True                                    to aColumnType[i].bCanEditSize
98444>>>>            Move True                                    to aColumnType[i].bNativeDataType
98445>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98446>>>>            Move 1                                       to aColumnType[i].iMinSize
98447>>>>            Move 14                                      to aColumnType[i].nMaxSize
98448>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98449>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98450>>>>            Move 14                                      to aColumnType[i].sPrecision
98451>>>>            Increment i
98452>>>>
98452>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
98453>>>>            Move -9                                      to aColumnType[i].iSQLType
98454>>>>            Move True                                    to aColumnType[i].bCanEditSize
98455>>>>            Move True                                    to aColumnType[i].bNativeDataType
98456>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98457>>>>            Move 1                                       to aColumnType[i].iMinSize
98458>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98459>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98460>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98461>>>>            Move 4000                                    to aColumnType[i].sPrecision
98462>>>>            Increment i
98463>>>>
98463>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
98464>>>>            Move -202                                    to aColumnType[i].iSQLType
98465>>>>            Move True                                    to aColumnType[i].bCanEditSize
98466>>>>            Move True                                    to aColumnType[i].bNativeDataType
98467>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98468>>>>            Move 1                                       to aColumnType[i].iMinSize
98469>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98470>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98471>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98472>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98473>>>>            Increment i
98474>>>>
98474>>>>            Move "real"                                  to aColumnType[i].sSQLType
98475>>>>            Move 7                                       to aColumnType[i].iSQLType
98476>>>>            Move True                                    to aColumnType[i].bCanEditSize
98477>>>>            Move True                                    to aColumnType[i].bNativeDataType
98478>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98479>>>>            Move 1                                       to aColumnType[i].iMinSize
98480>>>>            Move 14                                      to aColumnType[i].nMaxSize
98481>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98482>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98483>>>>            Move 14                                      to aColumnType[i].sPrecision
98484>>>>            Increment i
98485>>>>
98485>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
98486>>>>            Move -206                                    to aColumnType[i].iSQLType
98487>>>>            Move False                                   to aColumnType[i].bCanEditSize
98488>>>>            Move True                                    to aColumnType[i].bNativeDataType
98489>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98490>>>>            Move 0                                       to aColumnType[i].iMinSize
98491>>>>            Move 0                                       to aColumnType[i].nMaxSize
98492>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98493>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98494>>>>            Move 1                                       to aColumnType[i].sPrecision
98495>>>>            Increment i
98496>>>>
98496>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98497>>>>            Move 5                                       to aColumnType[i].iSQLType
98498>>>>            Move True                                    to aColumnType[i].bCanEditSize
98499>>>>            Move True                                    to aColumnType[i].bNativeDataType
98500>>>>            Move 5                                       to aColumnType[i].iDefaultSize
98501>>>>            Move 1                                       to aColumnType[i].iMinSize
98502>>>>            Move 5                                       to aColumnType[i].nMaxSize
98503>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98504>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98505>>>>            Move 5                                       to aColumnType[i].sPrecision
98506>>>>            Increment i
98507>>>>
98507>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
98508>>>>            Move -205                                    to aColumnType[i].iSQLType
98509>>>>            Move False                                   to aColumnType[i].bCanEditSize
98510>>>>            Move True                                    to aColumnType[i].bNativeDataType
98511>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98512>>>>            Move 0                                       to aColumnType[i].iMinSize
98513>>>>            Move 0                                       to aColumnType[i].nMaxSize
98514>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98515>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98516>>>>            Move 1                                       to aColumnType[i].sPrecision
98517>>>>            Increment i
98518>>>>
98518>>>>            Move "text"                                  to aColumnType[i].sSQLType
98519>>>>            Move -1                                      to aColumnType[i].iSQLType
98520>>>>            Move True                                    to aColumnType[i].bCanEditSize
98521>>>>            Move True                                    to aColumnType[i].bNativeDataType
98522>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98523>>>>            Move 1                                       to aColumnType[i].iMinSize
98524>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98525>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98526>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98527>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98528>>>>            Increment i
98529>>>>
98529>>>>            Move "time"                                  to aColumnType[i].sSQLType
98530>>>>            Move -154                                    to aColumnType[i].iSQLType
98531>>>>            Move True                                    to aColumnType[i].bCanEditSize
98532>>>>            Move True                                    to aColumnType[i].bNativeDataType
98533>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98534>>>>            Move 10                                      to aColumnType[i].iMinSize
98535>>>>            Move 19                                      to aColumnType[i].nMaxSize
98536>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98537>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98538>>>>            Move 19                                      to aColumnType[i].sPrecision
98539>>>>            Increment i
98540>>>>
98540>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
98541>>>>            Move -6                                      to aColumnType[i].iSQLType
98542>>>>            Move True                                    to aColumnType[i].bCanEditSize
98543>>>>            Move True                                    to aColumnType[i].bNativeDataType
98544>>>>            Move 3                                       to aColumnType[i].iDefaultSize
98545>>>>            Move 1                                       to aColumnType[i].iMinSize
98546>>>>            Move 3                                       to aColumnType[i].nMaxSize
98547>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98548>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98549>>>>            Move 3                                       to aColumnType[i].sPrecision
98550>>>>            Increment i
98551>>>>
98551>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
98552>>>>            Move -11                                     to aColumnType[i].iSQLType
98553>>>>            Move False                                   to aColumnType[i].bCanEditSize
98554>>>>            Move True                                    to aColumnType[i].bNativeDataType
98555>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98556>>>>            Move 0                                       to aColumnType[i].iMinSize
98557>>>>            Move 0                                       to aColumnType[i].nMaxSize
98558>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98559>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98560>>>>            Move 1                                       to aColumnType[i].sPrecision
98561>>>>            Increment i
98562>>>>
98562>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
98563>>>>            Move -3                                      to aColumnType[i].iSQLType
98564>>>>            Move True                                    to aColumnType[i].bCanEditSize
98565>>>>            Move True                                    to aColumnType[i].bNativeDataType
98566>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
98567>>>>            Move 1                                       to aColumnType[i].iMinSize
98568>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98569>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98570>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98571>>>>            Move 8000                                    to aColumnType[i].sPrecision
98572>>>>            Increment i
98573>>>>
98573>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
98574>>>>            Move -203                                    to aColumnType[i].iSQLType
98575>>>>            Move True                                    to aColumnType[i].bCanEditSize
98576>>>>            Move True                                    to aColumnType[i].bNativeDataType
98577>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98578>>>>            Move 1                                       to aColumnType[i].iMinSize
98579>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98580>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98581>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98582>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98583>>>>            Increment i
98584>>>>
98584>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98585>>>>            Move 12                                      to aColumnType[i].iSQLType
98586>>>>            Move True                                    to aColumnType[i].bCanEditSize
98587>>>>            Move True                                    to aColumnType[i].bNativeDataType
98588>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98589>>>>            Move 1                                       to aColumnType[i].iMinSize
98590>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98591>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98592>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98593>>>>            Move 8000                                    to aColumnType[i].sPrecision
98594>>>>            Increment i
98595>>>>
98595>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
98596>>>>            Move -201                                    to aColumnType[i].iSQLType
98597>>>>            Move True                                    to aColumnType[i].bCanEditSize
98598>>>>            Move True                                    to aColumnType[i].bNativeDataType
98599>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98600>>>>            Move 1                                       to aColumnType[i].iMinSize
98601>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98602>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98603>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98604>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98605>>>>            Increment i
98606>>>>
98606>>>>            Move "xml"                                   to aColumnType[i].sSQLType
98607>>>>            Move -152                                    to aColumnType[i].iSQLType
98608>>>>            Move True                                    to aColumnType[i].bCanEditSize
98609>>>>            Move True                                    to aColumnType[i].bNativeDataType
98610>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98611>>>>            Move 1                                       to aColumnType[i].iMinSize
98612>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98613>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98614>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98615>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98616>>>>            Increment i
98617>>>>
98617>>>>
98617>>>
98617>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
98617>>>//            Move "bigint"           to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "14.0"             to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
98617>>>//            Move "binary"           to ColumnType[i].sSQLType
98617>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98617>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
98617>>>//            Move "8000"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
98617>>>//            Move "bit"              to ColumnType[i].sSQLType
98617>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98617>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98617>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
98617>>>//            Move "char"             to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "8000"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
98617>>>//            Move "date"             to ColumnType[i].sSQLType
98617>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
98617>>>//            Move "Date"             to ColumnType[i].sDataFlexType
98617>>>//            Move "6.0"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
98617>>>//            Move "datetime"         to ColumnType[i].sSQLType
98617>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98617>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
98617>>>//            Move "23.3"             to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
98617>>>//            Move "datetime2"         to ColumnType[i].sSQLType
98617>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
98617>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
98617>>>//            Move "23.6"              to ColumnType[i].sPrecision
98617>>>//            Move True                to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
98617>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
98617>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98617>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
98617>>>//            Move "34.0"                 to ColumnType[i].sPrecision
98617>>>//            Move True                   to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
98617>>>//            Move "decimal"          to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "14.8"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
98617>>>//            Move "float"            to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "14.8"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
98617>>>//            Move "int"              to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "8.0"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
98617>>>//            Move "money"            to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
98617>>>//            Move "nchar"            to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "4000"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
98617>>>//            Move "ntext"            to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
98617>>>//            Move "numeric"          to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98617>>>//            Move "14.8"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
98617>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "Text"             to ColumnType[i].sDataFlexType
98617>>>//            Move "4000"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
98617>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
98617>>>//            Move "real"             to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98617>>>//            Move "14.8"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
98617>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
98617>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98617>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
98617>>>//            Move "23.0"                 to ColumnType[i].sPrecision
98617>>>//            Move True                   to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
98617>>>//            Move "smallint"         to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98617>>>//            Move "4.0"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
98617>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
98617>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
98617>>>//            Move "10.0"              to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
98617>>>//            Move "text"             to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "8000"             to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
98617>>>//            Move "time"             to ColumnType[i].sSQLType
98617>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98617>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98617>>>//            Move "19.0"             to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
98617>>>//            Move "tinyint"          to ColumnType[i].sSQLType
98617>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98617>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98617>>>//            Move "2.0"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
98617>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
98617>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98617>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98617>>>//            Move "36"               to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
98617>>>//            Move "varbinary"        to ColumnType[i].sSQLType
98617>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98617>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
98617>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
98617>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98617>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
98617>>>//            Move "varchar"          to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "8000"             to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
98617>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
98617>>>//            Move "xml"              to ColumnType[i].sSQLType
98617>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98617>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98617>>>//            Move "16384"            to ColumnType[i].sPrecision
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
98617>>>//            Move "DATE"             to ColumnType[i].sSQLType
98617>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
98617>>>//            Move "date"             to ColumnType[i].sDataFlexType
98617>>>//            Move "6.0"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
98617>>>//            Move "time"             to ColumnType[i].sSQLType
98617>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98617>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98617>>>//            Move "8.7"              to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>//
98617>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
98617>>>//            Move "datetime"         to ColumnType[i].sSQLType
98617>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98617>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
98617>>>//            Move "23.6"             to ColumnType[i].sPrecision
98617>>>//            Move True               to ColumnType[i].bCanEditSize
98617>>>//            Increment i
98617>>>
98617>>>        End
98617>>>>
98617>>>
98617>>>        // Mertech SQLFlex driver
98617>>>        If (sDriverID = SQLFLEX) Begin
98619>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
98619>>>>// Generated By The Database Update Framework
98619>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
98619>>>>// Driver COLUMN DATA TYPES
98619>>>>//
98619>>>>// Created: 2018-03-14 23:47:46.885
98619>>>>
98619>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98620>>>>            Move -5                                      to aColumnType[i].iSQLType
98621>>>>            Move True                                    to aColumnType[i].bCanEditSize
98622>>>>            Move True                                    to aColumnType[i].bNativeDataType
98623>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98624>>>>            Move 1                                       to aColumnType[i].iMinSize
98625>>>>            Move 14                                      to aColumnType[i].nMaxSize
98626>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98627>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98628>>>>            Move 14                                      to aColumnType[i].sPrecision
98629>>>>            Increment i
98630>>>>
98630>>>>            Move "binary"                                to aColumnType[i].sSQLType
98631>>>>            Move -2                                      to aColumnType[i].iSQLType
98632>>>>            Move True                                    to aColumnType[i].bCanEditSize
98633>>>>            Move True                                    to aColumnType[i].bNativeDataType
98634>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98635>>>>            Move 1                                       to aColumnType[i].iMinSize
98636>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98637>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98638>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98639>>>>            Move 8000                                    to aColumnType[i].sPrecision
98640>>>>            Increment i
98641>>>>
98641>>>>            Move "bit"                                   to aColumnType[i].sSQLType
98642>>>>            Move -7                                      to aColumnType[i].iSQLType
98643>>>>            Move False                                   to aColumnType[i].bCanEditSize
98644>>>>            Move True                                    to aColumnType[i].bNativeDataType
98645>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98646>>>>            Move -1                                      to aColumnType[i].iMinSize
98647>>>>            Move -1                                      to aColumnType[i].nMaxSize
98648>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98649>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98650>>>>            Move -1                                      to aColumnType[i].sPrecision
98651>>>>            Increment i
98652>>>>
98652>>>>            Move "char"                                  to aColumnType[i].sSQLType
98653>>>>            Move 1                                       to aColumnType[i].iSQLType
98654>>>>            Move True                                    to aColumnType[i].bCanEditSize
98655>>>>            Move True                                    to aColumnType[i].bNativeDataType
98656>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98657>>>>            Move 1                                       to aColumnType[i].iMinSize
98658>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98659>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98660>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98661>>>>            Move 8000                                    to aColumnType[i].sPrecision
98662>>>>            Increment i
98663>>>>
98663>>>>            Move "date"                                  to aColumnType[i].sSQLType
98664>>>>            Move 40                                      to aColumnType[i].iSQLType
98665>>>>            Move False                                   to aColumnType[i].bCanEditSize
98666>>>>            Move True                                    to aColumnType[i].bNativeDataType
98667>>>>            Move 12                                      to aColumnType[i].iDefaultSize
98668>>>>            Move -1                                      to aColumnType[i].iMinSize
98669>>>>            Move -1                                      to aColumnType[i].nMaxSize
98670>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98671>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98672>>>>            Move -1                                      to aColumnType[i].sPrecision
98673>>>>            Increment i
98674>>>>
98674>>>>            Move "datetime"                              to aColumnType[i].sSQLType
98675>>>>            Move 11                                      to aColumnType[i].iSQLType
98676>>>>            Move True                                    to aColumnType[i].bCanEditSize
98677>>>>            Move True                                    to aColumnType[i].bNativeDataType
98678>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98679>>>>            Move 6                                       to aColumnType[i].iMinSize
98680>>>>            Move 23                                      to aColumnType[i].nMaxSize
98681>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98682>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98683>>>>            Move 23                                      to aColumnType[i].sPrecision
98684>>>>            Increment i
98685>>>>
98685>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
98686>>>>            Move 42                                      to aColumnType[i].iSQLType
98687>>>>            Move True                                    to aColumnType[i].bCanEditSize
98688>>>>            Move True                                    to aColumnType[i].bNativeDataType
98689>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98690>>>>            Move 6                                       to aColumnType[i].iMinSize
98691>>>>            Move 23                                      to aColumnType[i].nMaxSize
98692>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98693>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98694>>>>            Move 23                                      to aColumnType[i].sPrecision
98695>>>>            Increment i
98696>>>>
98696>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98697>>>>            Move 43                                      to aColumnType[i].iSQLType
98698>>>>            Move True                                    to aColumnType[i].bCanEditSize
98699>>>>            Move True                                    to aColumnType[i].bNativeDataType
98700>>>>            Move 12                                      to aColumnType[i].iDefaultSize
98701>>>>            Move 12                                      to aColumnType[i].iMinSize
98702>>>>            Move 23                                      to aColumnType[i].nMaxSize
98703>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98704>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98705>>>>            Move 23                                      to aColumnType[i].sPrecision
98706>>>>            Increment i
98707>>>>
98707>>>>            Move "decimal"                               to aColumnType[i].sSQLType
98708>>>>            Move 3                                       to aColumnType[i].iSQLType
98709>>>>            Move True                                    to aColumnType[i].bCanEditSize
98710>>>>            Move True                                    to aColumnType[i].bNativeDataType
98711>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98712>>>>            Move 1                                       to aColumnType[i].iMinSize
98713>>>>            Move 14                                      to aColumnType[i].nMaxSize
98714>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98715>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98716>>>>            Move 14                                      to aColumnType[i].sPrecision
98717>>>>            Increment i
98718>>>>
98718>>>>            Move "float"                                 to aColumnType[i].sSQLType
98719>>>>            Move 6                                       to aColumnType[i].iSQLType
98720>>>>            Move True                                    to aColumnType[i].bCanEditSize
98721>>>>            Move True                                    to aColumnType[i].bNativeDataType
98722>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98723>>>>            Move 1                                       to aColumnType[i].iMinSize
98724>>>>            Move 14                                      to aColumnType[i].nMaxSize
98725>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98726>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98727>>>>            Move 14                                      to aColumnType[i].sPrecision
98728>>>>            Increment i
98729>>>>
98729>>>>            Move "geography"                             to aColumnType[i].sSQLType
98730>>>>            Move 130                                     to aColumnType[i].iSQLType
98731>>>>            Move False                                   to aColumnType[i].bCanEditSize
98732>>>>            Move True                                    to aColumnType[i].bNativeDataType
98733>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98734>>>>            Move -1                                      to aColumnType[i].iMinSize
98735>>>>            Move -1                                      to aColumnType[i].nMaxSize
98736>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98737>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98738>>>>            Move -1                                      to aColumnType[i].sPrecision
98739>>>>            Increment i
98740>>>>
98740>>>>            Move "geometry"                              to aColumnType[i].sSQLType
98741>>>>            Move 129                                     to aColumnType[i].iSQLType
98742>>>>            Move False                                   to aColumnType[i].bCanEditSize
98743>>>>            Move True                                    to aColumnType[i].bNativeDataType
98744>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98745>>>>            Move -1                                      to aColumnType[i].iMinSize
98746>>>>            Move -1                                      to aColumnType[i].nMaxSize
98747>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98748>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98749>>>>            Move -1                                      to aColumnType[i].sPrecision
98750>>>>            Increment i
98751>>>>
98751>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
98752>>>>            Move 128                                     to aColumnType[i].iSQLType
98753>>>>            Move False                                   to aColumnType[i].bCanEditSize
98754>>>>            Move True                                    to aColumnType[i].bNativeDataType
98755>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98756>>>>            Move -1                                      to aColumnType[i].iMinSize
98757>>>>            Move -1                                      to aColumnType[i].nMaxSize
98758>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98759>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98760>>>>            Move -1                                      to aColumnType[i].sPrecision
98761>>>>            Increment i
98762>>>>
98762>>>>            Move "image"                                 to aColumnType[i].sSQLType
98763>>>>            Move -4                                      to aColumnType[i].iSQLType
98764>>>>            Move True                                    to aColumnType[i].bCanEditSize
98765>>>>            Move True                                    to aColumnType[i].bNativeDataType
98766>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98767>>>>            Move 1                                       to aColumnType[i].iMinSize
98768>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98769>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98770>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98771>>>>            Move 16384                                   to aColumnType[i].sPrecision
98772>>>>            Increment i
98773>>>>
98773>>>>            Move "int"                                   to aColumnType[i].sSQLType
98774>>>>            Move 4                                       to aColumnType[i].iSQLType
98775>>>>            Move True                                    to aColumnType[i].bCanEditSize
98776>>>>            Move True                                    to aColumnType[i].bNativeDataType
98777>>>>            Move 11                                      to aColumnType[i].iDefaultSize
98778>>>>            Move 1                                       to aColumnType[i].iMinSize
98779>>>>            Move 11                                      to aColumnType[i].nMaxSize
98780>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98781>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98782>>>>            Move 11                                      to aColumnType[i].sPrecision
98783>>>>            Increment i
98784>>>>
98784>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
98785>>>>            Move -8                                      to aColumnType[i].iSQLType
98786>>>>            Move True                                    to aColumnType[i].bCanEditSize
98787>>>>            Move True                                    to aColumnType[i].bNativeDataType
98788>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98789>>>>            Move 1                                       to aColumnType[i].iMinSize
98790>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98791>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98792>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98793>>>>            Move 4000                                    to aColumnType[i].sPrecision
98794>>>>            Increment i
98795>>>>
98795>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
98796>>>>            Move -10                                     to aColumnType[i].iSQLType
98797>>>>            Move True                                    to aColumnType[i].bCanEditSize
98798>>>>            Move True                                    to aColumnType[i].bNativeDataType
98799>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98800>>>>            Move 1                                       to aColumnType[i].iMinSize
98801>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98802>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98803>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98804>>>>            Move 16384                                   to aColumnType[i].sPrecision
98805>>>>            Increment i
98806>>>>
98806>>>>            Move "numeric"                               to aColumnType[i].sSQLType
98807>>>>            Move 2                                       to aColumnType[i].iSQLType
98808>>>>            Move True                                    to aColumnType[i].bCanEditSize
98809>>>>            Move True                                    to aColumnType[i].bNativeDataType
98810>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98811>>>>            Move 1                                       to aColumnType[i].iMinSize
98812>>>>            Move 14                                      to aColumnType[i].nMaxSize
98813>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98814>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98815>>>>            Move 14                                      to aColumnType[i].sPrecision
98816>>>>            Increment i
98817>>>>
98817>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
98818>>>>            Move -9                                      to aColumnType[i].iSQLType
98819>>>>            Move True                                    to aColumnType[i].bCanEditSize
98820>>>>            Move True                                    to aColumnType[i].bNativeDataType
98821>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98822>>>>            Move 1                                       to aColumnType[i].iMinSize
98823>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98824>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98825>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98826>>>>            Move 4000                                    to aColumnType[i].sPrecision
98827>>>>            Increment i
98828>>>>
98828>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
98829>>>>            Move -100                                    to aColumnType[i].iSQLType
98830>>>>            Move True                                    to aColumnType[i].bCanEditSize
98831>>>>            Move True                                    to aColumnType[i].bNativeDataType
98832>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98833>>>>            Move 1                                       to aColumnType[i].iMinSize
98834>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98835>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98836>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98837>>>>            Move 16384                                   to aColumnType[i].sPrecision
98838>>>>            Increment i
98839>>>>
98839>>>>            Move "real"                                  to aColumnType[i].sSQLType
98840>>>>            Move 7                                       to aColumnType[i].iSQLType
98841>>>>            Move True                                    to aColumnType[i].bCanEditSize
98842>>>>            Move True                                    to aColumnType[i].bNativeDataType
98843>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98844>>>>            Move 1                                       to aColumnType[i].iMinSize
98845>>>>            Move 14                                      to aColumnType[i].nMaxSize
98846>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98847>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98848>>>>            Move 14                                      to aColumnType[i].sPrecision
98849>>>>            Increment i
98850>>>>
98850>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
98851>>>>            Move 58                                      to aColumnType[i].iSQLType
98852>>>>            Move True                                    to aColumnType[i].bCanEditSize
98853>>>>            Move True                                    to aColumnType[i].bNativeDataType
98854>>>>            Move 12                                      to aColumnType[i].iDefaultSize
98855>>>>            Move 12                                      to aColumnType[i].iMinSize
98856>>>>            Move 23                                      to aColumnType[i].nMaxSize
98857>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98858>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98859>>>>            Move 23                                      to aColumnType[i].sPrecision
98860>>>>            Increment i
98861>>>>
98861>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98862>>>>            Move 5                                       to aColumnType[i].iSQLType
98863>>>>            Move True                                    to aColumnType[i].bCanEditSize
98864>>>>            Move True                                    to aColumnType[i].bNativeDataType
98865>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98866>>>>            Move -1                                      to aColumnType[i].iMinSize
98867>>>>            Move 6                                       to aColumnType[i].nMaxSize
98868>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98869>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98870>>>>            Move 6                                       to aColumnType[i].sPrecision
98871>>>>            Increment i
98872>>>>
98872>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
98873>>>>            Move -150                                    to aColumnType[i].iSQLType
98874>>>>            Move False                                   to aColumnType[i].bCanEditSize
98875>>>>            Move True                                    to aColumnType[i].bNativeDataType
98876>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
98877>>>>            Move -1                                      to aColumnType[i].iMinSize
98878>>>>            Move -1                                      to aColumnType[i].nMaxSize
98879>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98880>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98881>>>>            Move -1                                      to aColumnType[i].sPrecision
98882>>>>            Increment i
98883>>>>
98883>>>>            Move "text"                                  to aColumnType[i].sSQLType
98884>>>>            Move -1                                      to aColumnType[i].iSQLType
98885>>>>            Move True                                    to aColumnType[i].bCanEditSize
98886>>>>            Move True                                    to aColumnType[i].bNativeDataType
98887>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98888>>>>            Move 1                                       to aColumnType[i].iMinSize
98889>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98890>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98891>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98892>>>>            Move 16384                                   to aColumnType[i].sPrecision
98893>>>>            Increment i
98894>>>>
98894>>>>            Move "time"                                  to aColumnType[i].sSQLType
98895>>>>            Move 41                                      to aColumnType[i].iSQLType
98896>>>>            Move True                                    to aColumnType[i].bCanEditSize
98897>>>>            Move True                                    to aColumnType[i].bNativeDataType
98898>>>>            Move 8                                       to aColumnType[i].iDefaultSize
98899>>>>            Move 8                                       to aColumnType[i].iMinSize
98900>>>>            Move 16                                      to aColumnType[i].nMaxSize
98901>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98902>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98903>>>>            Move 16                                      to aColumnType[i].sPrecision
98904>>>>            Increment i
98905>>>>
98905>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
98906>>>>            Move 93                                      to aColumnType[i].iSQLType
98907>>>>            Move False                                   to aColumnType[i].bCanEditSize
98908>>>>            Move True                                    to aColumnType[i].bNativeDataType
98909>>>>            Move 8                                       to aColumnType[i].iDefaultSize
98910>>>>            Move -1                                      to aColumnType[i].iMinSize
98911>>>>            Move -1                                      to aColumnType[i].nMaxSize
98912>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98913>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98914>>>>            Move -1                                      to aColumnType[i].sPrecision
98915>>>>            Increment i
98916>>>>
98916>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
98917>>>>            Move -6                                      to aColumnType[i].iSQLType
98918>>>>            Move True                                    to aColumnType[i].bCanEditSize
98919>>>>            Move True                                    to aColumnType[i].bNativeDataType
98920>>>>            Move 3                                       to aColumnType[i].iDefaultSize
98921>>>>            Move -1                                      to aColumnType[i].iMinSize
98922>>>>            Move 3                                       to aColumnType[i].nMaxSize
98923>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98924>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98925>>>>            Move 3                                       to aColumnType[i].sPrecision
98926>>>>            Increment i
98927>>>>
98927>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
98928>>>>            Move -11                                     to aColumnType[i].iSQLType
98929>>>>            Move False                                   to aColumnType[i].bCanEditSize
98930>>>>            Move True                                    to aColumnType[i].bNativeDataType
98931>>>>            Move 38                                      to aColumnType[i].iDefaultSize
98932>>>>            Move -1                                      to aColumnType[i].iMinSize
98933>>>>            Move -1                                      to aColumnType[i].nMaxSize
98934>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98935>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98936>>>>            Move -1                                      to aColumnType[i].sPrecision
98937>>>>            Increment i
98938>>>>
98938>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
98939>>>>            Move -3                                      to aColumnType[i].iSQLType
98940>>>>            Move True                                    to aColumnType[i].bCanEditSize
98941>>>>            Move True                                    to aColumnType[i].bNativeDataType
98942>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
98943>>>>            Move 1                                       to aColumnType[i].iMinSize
98944>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98945>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98946>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98947>>>>            Move 8000                                    to aColumnType[i].sPrecision
98948>>>>            Increment i
98949>>>>
98949>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
98950>>>>            Move -98                                     to aColumnType[i].iSQLType
98951>>>>            Move True                                    to aColumnType[i].bCanEditSize
98952>>>>            Move True                                    to aColumnType[i].bNativeDataType
98953>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98954>>>>            Move 1                                       to aColumnType[i].iMinSize
98955>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98956>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98957>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98958>>>>            Move 16384                                   to aColumnType[i].sPrecision
98959>>>>            Increment i
98960>>>>
98960>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98961>>>>            Move 12                                      to aColumnType[i].iSQLType
98962>>>>            Move True                                    to aColumnType[i].bCanEditSize
98963>>>>            Move True                                    to aColumnType[i].bNativeDataType
98964>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98965>>>>            Move 1                                       to aColumnType[i].iMinSize
98966>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98967>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98968>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98969>>>>            Move 8000                                    to aColumnType[i].sPrecision
98970>>>>            Increment i
98971>>>>
98971>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
98972>>>>            Move -99                                     to aColumnType[i].iSQLType
98973>>>>            Move True                                    to aColumnType[i].bCanEditSize
98974>>>>            Move True                                    to aColumnType[i].bNativeDataType
98975>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98976>>>>            Move 1                                       to aColumnType[i].iMinSize
98977>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98978>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98979>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98980>>>>            Move 16384                                   to aColumnType[i].sPrecision
98981>>>>            Increment i
98982>>>>
98982>>>>            Move "xml"                                   to aColumnType[i].sSQLType
98983>>>>            Move -370                                    to aColumnType[i].iSQLType
98984>>>>            Move True                                    to aColumnType[i].bCanEditSize
98985>>>>            Move True                                    to aColumnType[i].bNativeDataType
98986>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
98987>>>>            Move 1                                       to aColumnType[i].iMinSize
98988>>>>            Move 16384                                   to aColumnType[i].nMaxSize
98989>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98990>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98991>>>>            Move 16384                                   to aColumnType[i].sPrecision
98992>>>>            Increment i
98993>>>>
98993>>>>
98993>>>
98993>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
98993>>>//            Move "BigInt"           to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.0"             to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
98993>>>//            Move "Binary"           to ColumnType[i].sSQLType
98993>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98993>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
98993>>>//            Move "8000"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
98993>>>//            Move "Bit"              to ColumnType[i].sSQLType
98993>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98993>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98993>>>//            Move "1.0"              to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
98993>>>//            Move "Char"             to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98993>>>//            Move "Text"             to ColumnType[i].sDataFlexType
98993>>>//            Move "8000"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
98993>>>//            Move "Date"             to ColumnType[i].sSQLType
98993>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
98993>>>//            Move "Date"             to ColumnType[i].sDataFlexType
98993>>>//            Move "6.0"              to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
98993>>>//            Move "DateTime"             to ColumnType[i].sSQLType
98993>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98993>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
98993>>>//            Move "23.3"                 to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
98993>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
98993>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98993>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
98993>>>//            Move "23.6"                 to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
98993>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
98993>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
98993>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
98993>>>//            Move "23.0"                     to ColumnType[i].sPrecision
98993>>>//            Move True                       to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
98993>>>//            Move "Decimal"          to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.8"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
98993>>>//            Move "Double"           to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.8"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
98993>>>//            Move "Float"            to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.8"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
98993>>>//            Move "Int"              to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "11.0"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
98993>>>//            Move "Nchar"            to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98993>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98993>>>//            Move "4000"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
98993>>>//            Move "Ntext"            to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98993>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98993>>>//            Move "16384"            to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
98993>>>//            Move "Numeric"          to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.8"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
98993>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
98993>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
98993>>>//            Move "4000"                 to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
98993>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
98993>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
98993>>>//            Move "16384"                to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
98993>>>//            Move "Real"             to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98993>>>//            Move "14.8"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
98993>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
98993>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
98993>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
98993>>>//            Move "23.0"                     to ColumnType[i].sPrecision
98993>>>//            Move True                       to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
98993>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
98993>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
98993>>>//            Move "6.0"                  to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
98993>>>//            Move "Text"             to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98993>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98993>>>//            Move "8000"             to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
98993>>>//            Move "Time"             to ColumnType[i].sSQLType
98993>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98993>>>//            Move "Date"             to ColumnType[i].sDataFlexType
98993>>>//            Move "16.0"             to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
98993>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
98993>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
98993>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
98993>>>//            Move "8.0"                  to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
98993>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
98993>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98993>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98993>>>//            Move "3.0"              to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
98993>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
98993>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98993>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98993>>>//            Move "38"               to ColumnType[i].sPrecision
98993>>>//            Move True               to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
98993>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
98993>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
98993>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
98993>>>//            Move "8000"                 to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
98993>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
98993>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
98993>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
98993>>>//            Move "16384"                 to ColumnType[i].sPrecision
98993>>>//            Move True                    to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
98993>>>//            Move "VarChar"          to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
98993>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98993>>>//            Move "8000"             to ColumnType[i].sPrecision
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
98993>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
98993>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
98993>>>//            Move "16384"                to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
98993>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
98993>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
98993>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
98993>>>//            Move "8016"                 to ColumnType[i].sPrecision
98993>>>//            Move True                   to ColumnType[i].bCanEditSize
98993>>>//            Increment i
98993>>>//
98993>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
98993>>>//            Move "XML"              to ColumnType[i].sSQLType
98993>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98993>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98993>>>//            Move "16384"            to ColumnType[i].sPrecision
98993>>>        End
98993>>>>
98993>>>
98993>>>        Function_Return aColumnType
98994>>>    End_Function
98995>>>
98995>>>    // MySQL Data Types
98995>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
98997>>>        tColumnType[] aColumnType
98997>>>        tColumnType[] aColumnType
98998>>>        Integer i
98998>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
98998>>>>// Generated By The Database Update Framework
98998>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
98998>>>>// Driver COLUMN DATA TYPES
98998>>>>//
98998>>>>// Created: 2018-03-14 23:46:49.593
98998>>>>
98998>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98999>>>>            Move 8                                       to aColumnType[i].iSQLType
99000>>>>            Move True                                    to aColumnType[i].bCanEditSize
99001>>>>            Move True                                    to aColumnType[i].bNativeDataType
99002>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99003>>>>            Move 1                                       to aColumnType[i].iMinSize
99004>>>>            Move 14                                      to aColumnType[i].nMaxSize
99005>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99006>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99007>>>>            Move 14                                      to aColumnType[i].sPrecision
99008>>>>            Increment i
99009>>>>
99009>>>>            Move "bit"                                   to aColumnType[i].sSQLType
99010>>>>            Move 16                                      to aColumnType[i].iSQLType
99011>>>>            Move True                                    to aColumnType[i].bCanEditSize
99012>>>>            Move True                                    to aColumnType[i].bNativeDataType
99013>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99014>>>>            Move -1                                      to aColumnType[i].iMinSize
99015>>>>            Move 64                                      to aColumnType[i].nMaxSize
99016>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99017>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99018>>>>            Move 64                                      to aColumnType[i].sPrecision
99019>>>>            Increment i
99020>>>>
99020>>>>            Move "blob"                                  to aColumnType[i].sSQLType
99021>>>>            Move 252                                     to aColumnType[i].iSQLType
99022>>>>            Move True                                    to aColumnType[i].bCanEditSize
99023>>>>            Move True                                    to aColumnType[i].bNativeDataType
99024>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99025>>>>            Move 1                                       to aColumnType[i].iMinSize
99026>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99027>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99028>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99029>>>>            Move 16384                                   to aColumnType[i].sPrecision
99030>>>>            Increment i
99031>>>>
99031>>>>            Move "char"                                  to aColumnType[i].sSQLType
99032>>>>            Move 254                                     to aColumnType[i].iSQLType
99033>>>>            Move True                                    to aColumnType[i].bCanEditSize
99034>>>>            Move True                                    to aColumnType[i].bNativeDataType
99035>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99036>>>>            Move 1                                       to aColumnType[i].iMinSize
99037>>>>            Move 255                                     to aColumnType[i].nMaxSize
99038>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99039>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99040>>>>            Move 255                                     to aColumnType[i].sPrecision
99041>>>>            Increment i
99042>>>>
99042>>>>            Move "date"                                  to aColumnType[i].sSQLType
99043>>>>            Move 10                                      to aColumnType[i].iSQLType
99044>>>>            Move False                                   to aColumnType[i].bCanEditSize
99045>>>>            Move True                                    to aColumnType[i].bNativeDataType
99046>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99047>>>>            Move -1                                      to aColumnType[i].iMinSize
99048>>>>            Move -1                                      to aColumnType[i].nMaxSize
99049>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99050>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99051>>>>            Move 6                                       to aColumnType[i].sPrecision
99052>>>>            Increment i
99053>>>>
99053>>>>            Move "datetime"                              to aColumnType[i].sSQLType
99054>>>>            Move 12                                      to aColumnType[i].iSQLType
99055>>>>            Move True                                    to aColumnType[i].bCanEditSize
99056>>>>            Move True                                    to aColumnType[i].bNativeDataType
99057>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99058>>>>            Move 6                                       to aColumnType[i].iMinSize
99059>>>>            Move 23                                      to aColumnType[i].nMaxSize
99060>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99061>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99062>>>>            Move 23                                      to aColumnType[i].sPrecision
99063>>>>            Increment i
99064>>>>
99064>>>>            Move "decimal"                               to aColumnType[i].sSQLType
99065>>>>            Move 246                                     to aColumnType[i].iSQLType
99066>>>>            Move True                                    to aColumnType[i].bCanEditSize
99067>>>>            Move True                                    to aColumnType[i].bNativeDataType
99068>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99069>>>>            Move -1                                      to aColumnType[i].iMinSize
99070>>>>            Move 14                                      to aColumnType[i].nMaxSize
99071>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99072>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99073>>>>            Move 14                                      to aColumnType[i].sPrecision
99074>>>>            Increment i
99075>>>>
99075>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
99076>>>>            Move 0                                       to aColumnType[i].iSQLType
99077>>>>            Move True                                    to aColumnType[i].bCanEditSize
99078>>>>            Move True                                    to aColumnType[i].bNativeDataType
99079>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99080>>>>            Move -1                                      to aColumnType[i].iMinSize
99081>>>>            Move 14                                      to aColumnType[i].nMaxSize
99082>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99083>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99084>>>>            Move 14                                      to aColumnType[i].sPrecision
99085>>>>            Increment i
99086>>>>
99086>>>>            Move "double"                                to aColumnType[i].sSQLType
99087>>>>            Move 5                                       to aColumnType[i].iSQLType
99088>>>>            Move True                                    to aColumnType[i].bCanEditSize
99089>>>>            Move True                                    to aColumnType[i].bNativeDataType
99090>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99091>>>>            Move -1                                      to aColumnType[i].iMinSize
99092>>>>            Move 14                                      to aColumnType[i].nMaxSize
99093>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99094>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99095>>>>            Move 14                                      to aColumnType[i].sPrecision
99096>>>>            Increment i
99097>>>>
99097>>>>            Move "enum"                                  to aColumnType[i].sSQLType
99098>>>>            Move 247                                     to aColumnType[i].iSQLType
99099>>>>            Move True                                    to aColumnType[i].bCanEditSize
99100>>>>            Move True                                    to aColumnType[i].bNativeDataType
99101>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99102>>>>            Move -1                                      to aColumnType[i].iMinSize
99103>>>>            Move 255                                     to aColumnType[i].nMaxSize
99104>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99105>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99106>>>>            Move 255                                     to aColumnType[i].sPrecision
99107>>>>            Increment i
99108>>>>
99108>>>>            Move "float"                                 to aColumnType[i].sSQLType
99109>>>>            Move 4                                       to aColumnType[i].iSQLType
99110>>>>            Move True                                    to aColumnType[i].bCanEditSize
99111>>>>            Move True                                    to aColumnType[i].bNativeDataType
99112>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99113>>>>            Move -1                                      to aColumnType[i].iMinSize
99114>>>>            Move 14                                      to aColumnType[i].nMaxSize
99115>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99116>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99117>>>>            Move 14                                      to aColumnType[i].sPrecision
99118>>>>            Increment i
99119>>>>
99119>>>>            Move "int"                                   to aColumnType[i].sSQLType
99120>>>>            Move 3                                       to aColumnType[i].iSQLType
99121>>>>            Move True                                    to aColumnType[i].bCanEditSize
99122>>>>            Move True                                    to aColumnType[i].bNativeDataType
99123>>>>            Move 10                                      to aColumnType[i].iDefaultSize
99124>>>>            Move -1                                      to aColumnType[i].iMinSize
99125>>>>            Move 11                                      to aColumnType[i].nMaxSize
99126>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99127>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99128>>>>            Move 11                                      to aColumnType[i].sPrecision
99129>>>>            Increment i
99130>>>>
99130>>>>            Move "longblob"                              to aColumnType[i].sSQLType
99131>>>>            Move 251                                     to aColumnType[i].iSQLType
99132>>>>            Move True                                    to aColumnType[i].bCanEditSize
99133>>>>            Move True                                    to aColumnType[i].bNativeDataType
99134>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99135>>>>            Move 1                                       to aColumnType[i].iMinSize
99136>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99137>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99138>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99139>>>>            Move 16384                                   to aColumnType[i].sPrecision
99140>>>>            Increment i
99141>>>>
99141>>>>            Move "longtext"                              to aColumnType[i].sSQLType
99142>>>>            Move -251                                    to aColumnType[i].iSQLType
99143>>>>            Move True                                    to aColumnType[i].bCanEditSize
99144>>>>            Move True                                    to aColumnType[i].bNativeDataType
99145>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99146>>>>            Move 1                                       to aColumnType[i].iMinSize
99147>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99148>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99149>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99150>>>>            Move 16384                                   to aColumnType[i].sPrecision
99151>>>>            Increment i
99152>>>>
99152>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
99153>>>>            Move 250                                     to aColumnType[i].iSQLType
99154>>>>            Move True                                    to aColumnType[i].bCanEditSize
99155>>>>            Move True                                    to aColumnType[i].bNativeDataType
99156>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99157>>>>            Move 1                                       to aColumnType[i].iMinSize
99158>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99159>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99160>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99161>>>>            Move 16384                                   to aColumnType[i].sPrecision
99162>>>>            Increment i
99163>>>>
99163>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
99164>>>>            Move 9                                       to aColumnType[i].iSQLType
99165>>>>            Move True                                    to aColumnType[i].bCanEditSize
99166>>>>            Move True                                    to aColumnType[i].bNativeDataType
99167>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99168>>>>            Move 1                                       to aColumnType[i].iMinSize
99169>>>>            Move 9                                       to aColumnType[i].nMaxSize
99170>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99171>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99172>>>>            Move 9                                       to aColumnType[i].sPrecision
99173>>>>            Increment i
99174>>>>
99174>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
99175>>>>            Move -250                                    to aColumnType[i].iSQLType
99176>>>>            Move True                                    to aColumnType[i].bCanEditSize
99177>>>>            Move True                                    to aColumnType[i].bNativeDataType
99178>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99179>>>>            Move 1                                       to aColumnType[i].iMinSize
99180>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99181>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99182>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99183>>>>            Move 16384                                   to aColumnType[i].sPrecision
99184>>>>            Increment i
99185>>>>
99185>>>>            Move "set"                                   to aColumnType[i].sSQLType
99186>>>>            Move 248                                     to aColumnType[i].iSQLType
99187>>>>            Move True                                    to aColumnType[i].bCanEditSize
99188>>>>            Move True                                    to aColumnType[i].bNativeDataType
99189>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99190>>>>            Move -1                                      to aColumnType[i].iMinSize
99191>>>>            Move 255                                     to aColumnType[i].nMaxSize
99192>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99193>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99194>>>>            Move 255                                     to aColumnType[i].sPrecision
99195>>>>            Increment i
99196>>>>
99196>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99197>>>>            Move 2                                       to aColumnType[i].iSQLType
99198>>>>            Move True                                    to aColumnType[i].bCanEditSize
99199>>>>            Move True                                    to aColumnType[i].bNativeDataType
99200>>>>            Move 5                                       to aColumnType[i].iDefaultSize
99201>>>>            Move 1                                       to aColumnType[i].iMinSize
99202>>>>            Move 6                                       to aColumnType[i].nMaxSize
99203>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99204>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99205>>>>            Move 6                                       to aColumnType[i].sPrecision
99206>>>>            Increment i
99207>>>>
99207>>>>            Move "text"                                  to aColumnType[i].sSQLType
99208>>>>            Move -252                                    to aColumnType[i].iSQLType
99209>>>>            Move True                                    to aColumnType[i].bCanEditSize
99210>>>>            Move True                                    to aColumnType[i].bNativeDataType
99211>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99212>>>>            Move 1                                       to aColumnType[i].iMinSize
99213>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99214>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99215>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99216>>>>            Move 16384                                   to aColumnType[i].sPrecision
99217>>>>            Increment i
99218>>>>
99218>>>>            Move "time"                                  to aColumnType[i].sSQLType
99219>>>>            Move 11                                      to aColumnType[i].iSQLType
99220>>>>            Move False                                   to aColumnType[i].bCanEditSize
99221>>>>            Move True                                    to aColumnType[i].bNativeDataType
99222>>>>            Move 10                                      to aColumnType[i].iDefaultSize
99223>>>>            Move -1                                      to aColumnType[i].iMinSize
99224>>>>            Move -1                                      to aColumnType[i].nMaxSize
99225>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99226>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99227>>>>            Move -1                                      to aColumnType[i].sPrecision
99228>>>>            Increment i
99229>>>>
99229>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99230>>>>            Move 7                                       to aColumnType[i].iSQLType
99231>>>>            Move True                                    to aColumnType[i].bCanEditSize
99232>>>>            Move True                                    to aColumnType[i].bNativeDataType
99233>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99234>>>>            Move 6                                       to aColumnType[i].iMinSize
99235>>>>            Move 23                                      to aColumnType[i].nMaxSize
99236>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99237>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99238>>>>            Move 23                                      to aColumnType[i].sPrecision
99239>>>>            Increment i
99240>>>>
99240>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
99241>>>>            Move 249                                     to aColumnType[i].iSQLType
99242>>>>            Move True                                    to aColumnType[i].bCanEditSize
99243>>>>            Move True                                    to aColumnType[i].bNativeDataType
99244>>>>            Move 255                                     to aColumnType[i].iDefaultSize
99245>>>>            Move 1                                       to aColumnType[i].iMinSize
99246>>>>            Move 255                                     to aColumnType[i].nMaxSize
99247>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99248>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99249>>>>            Move 255                                     to aColumnType[i].sPrecision
99250>>>>            Increment i
99251>>>>
99251>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
99252>>>>            Move 1                                       to aColumnType[i].iSQLType
99253>>>>            Move True                                    to aColumnType[i].bCanEditSize
99254>>>>            Move True                                    to aColumnType[i].bNativeDataType
99255>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99256>>>>            Move 1                                       to aColumnType[i].iMinSize
99257>>>>            Move 4                                       to aColumnType[i].nMaxSize
99258>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99259>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99260>>>>            Move 4                                       to aColumnType[i].sPrecision
99261>>>>            Increment i
99262>>>>
99262>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
99263>>>>            Move -249                                    to aColumnType[i].iSQLType
99264>>>>            Move True                                    to aColumnType[i].bCanEditSize
99265>>>>            Move True                                    to aColumnType[i].bNativeDataType
99266>>>>            Move 255                                     to aColumnType[i].iDefaultSize
99267>>>>            Move 1                                       to aColumnType[i].iMinSize
99268>>>>            Move 255                                     to aColumnType[i].nMaxSize
99269>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99270>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99271>>>>            Move 255                                     to aColumnType[i].sPrecision
99272>>>>            Increment i
99273>>>>
99273>>>>            Move "varchar"                               to aColumnType[i].sSQLType
99274>>>>            Move 253                                     to aColumnType[i].iSQLType
99275>>>>            Move True                                    to aColumnType[i].bCanEditSize
99276>>>>            Move True                                    to aColumnType[i].bNativeDataType
99277>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99278>>>>            Move -1                                      to aColumnType[i].iMinSize
99279>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99280>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99281>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99282>>>>            Move 16384                                   to aColumnType[i].sPrecision
99283>>>>            Increment i
99284>>>>
99284>>>>            Move "year"                                  to aColumnType[i].sSQLType
99285>>>>            Move 13                                      to aColumnType[i].iSQLType
99286>>>>            Move False                                   to aColumnType[i].bCanEditSize
99287>>>>            Move True                                    to aColumnType[i].bNativeDataType
99288>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99289>>>>            Move -1                                      to aColumnType[i].iMinSize
99290>>>>            Move -1                                      to aColumnType[i].nMaxSize
99291>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99292>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99293>>>>            Move -1                                      to aColumnType[i].sPrecision
99294>>>>            Increment i
99295>>>>
99295>>>>
99295>>>
99295>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
99295>>>//        Move "bigint"           to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "14.0"             to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
99295>>>//        Move "bit"              to ColumnType[i].sSQLType
99295>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99295>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99295>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
99295>>>//        Move "blob"             to ColumnType[i].sSQLType
99295>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99295>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
99295>>>//        Move "char"             to ColumnType[i].sSQLType
99295>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99295>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99295>>>//        Move "254"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
99295>>>//        Move "date"             to ColumnType[i].sSQLType
99295>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
99295>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99295>>>//        Move "6.0"              to ColumnType[i].sPrecision
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
99295>>>//        Move "datetime"         to ColumnType[i].sSQLType
99295>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99295>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99295>>>//        Move "23.0"             to ColumnType[i].sPrecision
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
99295>>>//        Move "decimal"          to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "14.8"             to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
99295>>>//        Move "double"           to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "14.8"             to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
99295>>>//        Move "enum"             to ColumnType[i].sSQLType
99295>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99295>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99295>>>//        Move "254"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
99295>>>//        Move "float"            to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "14.8"             to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
99295>>>//        Move "int"              to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99295>>>//        Move "11.0"             to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
99295>>>//        Move "longblob"         to ColumnType[i].sSQLType
99295>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99295>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
99295>>>//        Move "longtext"         to ColumnType[i].sSQLType
99295>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99295>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
99295>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
99295>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99295>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
99295>>>//        Move "mediumint"        to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "9.0"              to ColumnType[i].sPrecision
99295>>>//
99295>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
99295>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
99295>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99295>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
99295>>>//        Move "set"              to ColumnType[i].sSQLType
99295>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99295>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99295>>>//        Move "254"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
99295>>>//        Move "smallint"         to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "6.0"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
99295>>>//        Move "text"             to ColumnType[i].sSQLType
99295>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99295>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
99295>>>//        Move "time"             to ColumnType[i].sSQLType
99295>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99295>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99295>>>//        Move "10.0"             to ColumnType[i].sPrecision
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
99295>>>//        Move "timestamp"        to ColumnType[i].sSQLType
99295>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99295>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99295>>>//        Move "23.0"             to ColumnType[i].sPrecision
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
99295>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
99295>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99295>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99295>>>//        Move "254"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
99295>>>//        Move "tinyint"          to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99295>>>//        Move "4.0"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
99295>>>//        Move "tinytext"         to ColumnType[i].sSQLType
99295>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99295>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99295>>>//        Move "254"              to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
99295>>>//        Move "varchar"          to ColumnType[i].sSQLType
99295>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99295>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99295>>>//        Move "16384"            to ColumnType[i].sPrecision
99295>>>//        Increment i
99295>>>//
99295>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
99295>>>//        Move "year"             to ColumnType[i].sSQLType
99295>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99295>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99295>>>//        Move "4.0"              to ColumnType[i].sPrecision
99295>>>//        Move True               to ColumnType[i].bCanEditSize
99295>>>//        Increment i
99295>>>
99295>>>        Function_Return aColumnType
99296>>>    End_Function
99297>>>
99297>>>    // Oracle Data Types
99297>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
99299>>>        tColumnType[] aColumnType
99299>>>        tColumnType[] aColumnType
99300>>>        Integer i
99300>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
99300>>>>// Generated By The Database Update Framework
99300>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
99300>>>>// Driver COLUMN DATA TYPES
99300>>>>//
99300>>>>// Created: 2018-03-14 23:47:34.82
99300>>>>
99300>>>>            Move "blob"                                  to aColumnType[i].sSQLType
99301>>>>            Move 113                                     to aColumnType[i].iSQLType
99302>>>>            Move True                                    to aColumnType[i].bCanEditSize
99303>>>>            Move True                                    to aColumnType[i].bNativeDataType
99304>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99305>>>>            Move 1                                       to aColumnType[i].iMinSize
99306>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99307>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99308>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99309>>>>            Move 16384                                   to aColumnType[i].sPrecision
99310>>>>            Increment i
99311>>>>
99311>>>>            Move "char"                                  to aColumnType[i].sSQLType
99312>>>>            Move 96                                      to aColumnType[i].iSQLType
99313>>>>            Move True                                    to aColumnType[i].bCanEditSize
99314>>>>            Move True                                    to aColumnType[i].bNativeDataType
99315>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99316>>>>            Move 1                                       to aColumnType[i].iMinSize
99317>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99318>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99319>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99320>>>>            Move 2000                                    to aColumnType[i].sPrecision
99321>>>>            Increment i
99322>>>>
99322>>>>            Move "clob"                                  to aColumnType[i].sSQLType
99323>>>>            Move 112                                     to aColumnType[i].iSQLType
99324>>>>            Move True                                    to aColumnType[i].bCanEditSize
99325>>>>            Move True                                    to aColumnType[i].bNativeDataType
99326>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99327>>>>            Move 1                                       to aColumnType[i].iMinSize
99328>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99329>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99330>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99331>>>>            Move 16384                                   to aColumnType[i].sPrecision
99332>>>>            Increment i
99333>>>>
99333>>>>            Move "date"                                  to aColumnType[i].sSQLType
99334>>>>            Move 12                                      to aColumnType[i].iSQLType
99335>>>>            Move True                                    to aColumnType[i].bCanEditSize
99336>>>>            Move True                                    to aColumnType[i].bNativeDataType
99337>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99338>>>>            Move 6                                       to aColumnType[i].iMinSize
99339>>>>            Move 23                                      to aColumnType[i].nMaxSize
99340>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99341>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99342>>>>            Move 6                                       to aColumnType[i].sPrecision
99343>>>>            Increment i
99344>>>>
99344>>>>            Move "float"                                 to aColumnType[i].sSQLType
99345>>>>            Move 4                                       to aColumnType[i].iSQLType
99346>>>>            Move True                                    to aColumnType[i].bCanEditSize
99347>>>>            Move True                                    to aColumnType[i].bNativeDataType
99348>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99349>>>>            Move 1                                       to aColumnType[i].iMinSize
99350>>>>            Move 14                                      to aColumnType[i].nMaxSize
99351>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99352>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99353>>>>            Move 14                                      to aColumnType[i].sPrecision
99354>>>>            Increment i
99355>>>>
99355>>>>            Move "int"                                   to aColumnType[i].sSQLType
99356>>>>            Move 3                                       to aColumnType[i].iSQLType
99357>>>>            Move True                                    to aColumnType[i].bCanEditSize
99358>>>>            Move True                                    to aColumnType[i].bNativeDataType
99359>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99360>>>>            Move 1                                       to aColumnType[i].iMinSize
99361>>>>            Move 14                                      to aColumnType[i].nMaxSize
99362>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99363>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99364>>>>            Move 14                                      to aColumnType[i].sPrecision
99365>>>>            Increment i
99366>>>>
99366>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
99367>>>>            Move 190                                     to aColumnType[i].iSQLType
99368>>>>            Move False                                   to aColumnType[i].bCanEditSize
99369>>>>            Move True                                    to aColumnType[i].bNativeDataType
99370>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99371>>>>            Move -1                                      to aColumnType[i].iMinSize
99372>>>>            Move -1                                      to aColumnType[i].nMaxSize
99373>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99374>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99375>>>>            Move -1                                      to aColumnType[i].sPrecision
99376>>>>            Increment i
99377>>>>
99377>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
99378>>>>            Move 189                                     to aColumnType[i].iSQLType
99379>>>>            Move False                                   to aColumnType[i].bCanEditSize
99380>>>>            Move True                                    to aColumnType[i].bNativeDataType
99381>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99382>>>>            Move -1                                      to aColumnType[i].iMinSize
99383>>>>            Move -1                                      to aColumnType[i].nMaxSize
99384>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99385>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99386>>>>            Move -1                                      to aColumnType[i].sPrecision
99387>>>>            Increment i
99388>>>>
99388>>>>            Move "long"                                  to aColumnType[i].sSQLType
99389>>>>            Move 8                                       to aColumnType[i].iSQLType
99390>>>>            Move True                                    to aColumnType[i].bCanEditSize
99391>>>>            Move True                                    to aColumnType[i].bNativeDataType
99392>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99393>>>>            Move 1                                       to aColumnType[i].iMinSize
99394>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99395>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99396>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99397>>>>            Move 16384                                   to aColumnType[i].sPrecision
99398>>>>            Increment i
99399>>>>
99399>>>>            Move "longraw"                               to aColumnType[i].sSQLType
99400>>>>            Move 24                                      to aColumnType[i].iSQLType
99401>>>>            Move True                                    to aColumnType[i].bCanEditSize
99402>>>>            Move True                                    to aColumnType[i].bNativeDataType
99403>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99404>>>>            Move 1                                       to aColumnType[i].iMinSize
99405>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99406>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99407>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99408>>>>            Move 16384                                   to aColumnType[i].sPrecision
99409>>>>            Increment i
99410>>>>
99410>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
99411>>>>            Move 286                                     to aColumnType[i].iSQLType
99412>>>>            Move True                                    to aColumnType[i].bCanEditSize
99413>>>>            Move True                                    to aColumnType[i].bNativeDataType
99414>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99415>>>>            Move 1                                       to aColumnType[i].iMinSize
99416>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99417>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99418>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99419>>>>            Move 2000                                    to aColumnType[i].sPrecision
99420>>>>            Increment i
99421>>>>
99421>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
99422>>>>            Move 288                                     to aColumnType[i].iSQLType
99423>>>>            Move True                                    to aColumnType[i].bCanEditSize
99424>>>>            Move True                                    to aColumnType[i].bNativeDataType
99425>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99426>>>>            Move 1                                       to aColumnType[i].iMinSize
99427>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99428>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99429>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99430>>>>            Move 16384                                   to aColumnType[i].sPrecision
99431>>>>            Increment i
99432>>>>
99432>>>>            Move "number"                                to aColumnType[i].sSQLType
99433>>>>            Move 2                                       to aColumnType[i].iSQLType
99434>>>>            Move True                                    to aColumnType[i].bCanEditSize
99435>>>>            Move True                                    to aColumnType[i].bNativeDataType
99436>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99437>>>>            Move 1                                       to aColumnType[i].iMinSize
99438>>>>            Move 14                                      to aColumnType[i].nMaxSize
99439>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99440>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99441>>>>            Move 14                                      to aColumnType[i].sPrecision
99442>>>>            Increment i
99443>>>>
99443>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
99444>>>>            Move 287                                     to aColumnType[i].iSQLType
99445>>>>            Move True                                    to aColumnType[i].bCanEditSize
99446>>>>            Move True                                    to aColumnType[i].bNativeDataType
99447>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99448>>>>            Move 1                                       to aColumnType[i].iMinSize
99449>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99450>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99451>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99452>>>>            Move 4000                                    to aColumnType[i].sPrecision
99453>>>>            Increment i
99454>>>>
99454>>>>            Move "raw"                                   to aColumnType[i].sSQLType
99455>>>>            Move 23                                      to aColumnType[i].iSQLType
99456>>>>            Move True                                    to aColumnType[i].bCanEditSize
99457>>>>            Move True                                    to aColumnType[i].bNativeDataType
99458>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99459>>>>            Move 1                                       to aColumnType[i].iMinSize
99460>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99461>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99462>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99463>>>>            Move 2000                                    to aColumnType[i].sPrecision
99464>>>>            Increment i
99465>>>>
99465>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99466>>>>            Move 187                                     to aColumnType[i].iSQLType
99467>>>>            Move False                                   to aColumnType[i].bCanEditSize
99468>>>>            Move True                                    to aColumnType[i].bNativeDataType
99469>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99470>>>>            Move -1                                      to aColumnType[i].iMinSize
99471>>>>            Move -1                                      to aColumnType[i].nMaxSize
99472>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99473>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99474>>>>            Move -1                                      to aColumnType[i].sPrecision
99475>>>>            Increment i
99476>>>>
99476>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
99477>>>>            Move 232                                     to aColumnType[i].iSQLType
99478>>>>            Move False                                   to aColumnType[i].bCanEditSize
99479>>>>            Move True                                    to aColumnType[i].bNativeDataType
99480>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99481>>>>            Move -1                                      to aColumnType[i].iMinSize
99482>>>>            Move -1                                      to aColumnType[i].nMaxSize
99483>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99484>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99485>>>>            Move -1                                      to aColumnType[i].sPrecision
99486>>>>            Increment i
99487>>>>
99487>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
99488>>>>            Move 188                                     to aColumnType[i].iSQLType
99489>>>>            Move False                                   to aColumnType[i].bCanEditSize
99490>>>>            Move True                                    to aColumnType[i].bNativeDataType
99491>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99492>>>>            Move -1                                      to aColumnType[i].iMinSize
99493>>>>            Move -1                                      to aColumnType[i].nMaxSize
99494>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99495>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99496>>>>            Move -1                                      to aColumnType[i].sPrecision
99497>>>>            Increment i
99498>>>>
99498>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
99499>>>>            Move 1                                       to aColumnType[i].iSQLType
99500>>>>            Move True                                    to aColumnType[i].bCanEditSize
99501>>>>            Move True                                    to aColumnType[i].bNativeDataType
99502>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99503>>>>            Move 1                                       to aColumnType[i].iMinSize
99504>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99505>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99506>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99507>>>>            Move 4000                                    to aColumnType[i].sPrecision
99508>>>>            Increment i
99509>>>>
99509>>>>
99509>>>
99509>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
99509>>>//        Move "BLOB"             to ColumnType[i].sSQLType
99509>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99509>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
99509>>>//        Move "CHAR"             to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "2000"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
99509>>>//        Move "CLOB"             to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
99509>>>//        Move "DATE"             to ColumnType[i].sSQLType
99509>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
99509>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99509>>>//        Move "6.0"              to ColumnType[i].sPrecision
99509>>>//        Move True               to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
99509>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
99509>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99509>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99509>>>//        Move "14.8"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
99509>>>//        Move "INT"              to ColumnType[i].sSQLType
99509>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99509>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99509>>>//        Move "14.0"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
99509>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
99509>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99509>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99509>>>//        Move "23.0"             to ColumnType[i].sPrecision
99509>>>//        Move True               to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
99509>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
99509>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
99509>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
99509>>>//        Move "23.0"              to ColumnType[i].sPrecision
99509>>>//        Move True                to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
99509>>>//        Move "LONG"             to ColumnType[i].sSQLType
99509>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99509>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
99509>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
99509>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99509>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
99509>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "2000"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
99509>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
99509>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
99509>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99509>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99509>>>//        Move "14.8"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
99509>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "4000"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
99509>>>//        Move "RAW"              to ColumnType[i].sSQLType
99509>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99509>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99509>>>//        Move "2000"             to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
99509>>>//        Move "ROWID"            to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
99509>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
99509>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99509>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99509>>>//        Move "11.0"             to ColumnType[i].sPrecision
99509>>>//        Move True               to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
99509>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
99509>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99509>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
99509>>>//        Move "13.0"                 to ColumnType[i].sPrecision
99509>>>//        Move True                   to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
99509>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
99509>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99509>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
99509>>>//        Move "11.0"                 to ColumnType[i].sPrecision
99509>>>//        Move True                   to ColumnType[i].bCanEditSize
99509>>>//        Increment i
99509>>>//
99509>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
99509>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
99509>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99509>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99509>>>//        Move "16384"            to ColumnType[i].sPrecision
99509>>>
99509>>>        Function_Return aColumnType
99510>>>    End_Function
99511>>>
99511>>>    // PostgreSQL Data Types
99511>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
99513>>>        tColumnType[] aColumnType
99513>>>        tColumnType[] aColumnType
99514>>>        Integer i
99514>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
99514>>>>// Generated By The Database Update Framework
99514>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
99514>>>>// Driver COLUMN DATA TYPES
99514>>>>//
99514>>>>// Created: 2018-03-14 23:47:02.984
99514>>>>
99514>>>>            Move "bigint"                                to aColumnType[i].sSQLType
99515>>>>            Move 20                                      to aColumnType[i].iSQLType
99516>>>>            Move True                                    to aColumnType[i].bCanEditSize
99517>>>>            Move True                                    to aColumnType[i].bNativeDataType
99518>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99519>>>>            Move 1                                       to aColumnType[i].iMinSize
99520>>>>            Move 14                                      to aColumnType[i].nMaxSize
99521>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99522>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99523>>>>            Move 14                                      to aColumnType[i].sPrecision
99524>>>>            Increment i
99525>>>>
99525>>>>            Move "bit"                                   to aColumnType[i].sSQLType
99526>>>>            Move 1560                                    to aColumnType[i].iSQLType
99527>>>>            Move True                                    to aColumnType[i].bCanEditSize
99528>>>>            Move True                                    to aColumnType[i].bNativeDataType
99529>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99530>>>>            Move 1                                       to aColumnType[i].iMinSize
99531>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99532>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99533>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99534>>>>            Move 16384                                   to aColumnType[i].sPrecision
99535>>>>            Increment i
99536>>>>
99536>>>>            Move "boolean"                               to aColumnType[i].sSQLType
99537>>>>            Move 16                                      to aColumnType[i].iSQLType
99538>>>>            Move False                                   to aColumnType[i].bCanEditSize
99539>>>>            Move True                                    to aColumnType[i].bNativeDataType
99540>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99541>>>>            Move -1                                      to aColumnType[i].iMinSize
99542>>>>            Move -1                                      to aColumnType[i].nMaxSize
99543>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99544>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99545>>>>            Move -1                                      to aColumnType[i].sPrecision
99546>>>>            Increment i
99547>>>>
99547>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
99548>>>>            Move 17                                      to aColumnType[i].iSQLType
99549>>>>            Move True                                    to aColumnType[i].bCanEditSize
99550>>>>            Move True                                    to aColumnType[i].bNativeDataType
99551>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99552>>>>            Move 1                                       to aColumnType[i].iMinSize
99553>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99554>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99555>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99556>>>>            Move 16384                                   to aColumnType[i].sPrecision
99557>>>>            Increment i
99558>>>>
99558>>>>            Move "char"                                  to aColumnType[i].sSQLType
99559>>>>            Move 18                                      to aColumnType[i].iSQLType
99560>>>>            Move True                                    to aColumnType[i].bCanEditSize
99561>>>>            Move True                                    to aColumnType[i].bNativeDataType
99562>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99563>>>>            Move 1                                       to aColumnType[i].iMinSize
99564>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99565>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99566>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99567>>>>            Move 16384                                   to aColumnType[i].sPrecision
99568>>>>            Increment i
99569>>>>
99569>>>>            Move "citext"                                to aColumnType[i].sSQLType
99570>>>>            Move -25                                     to aColumnType[i].iSQLType
99571>>>>            Move True                                    to aColumnType[i].bCanEditSize
99572>>>>            Move True                                    to aColumnType[i].bNativeDataType
99573>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99574>>>>            Move 1                                       to aColumnType[i].iMinSize
99575>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99576>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99577>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99578>>>>            Move 16384                                   to aColumnType[i].sPrecision
99579>>>>            Increment i
99580>>>>
99580>>>>            Move "date"                                  to aColumnType[i].sSQLType
99581>>>>            Move 1082                                    to aColumnType[i].iSQLType
99582>>>>            Move False                                   to aColumnType[i].bCanEditSize
99583>>>>            Move True                                    to aColumnType[i].bNativeDataType
99584>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99585>>>>            Move -1                                      to aColumnType[i].iMinSize
99586>>>>            Move -1                                      to aColumnType[i].nMaxSize
99587>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99588>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99589>>>>            Move 6                                       to aColumnType[i].sPrecision
99590>>>>            Increment i
99591>>>>
99591>>>>            Move "double"                                to aColumnType[i].sSQLType
99592>>>>            Move 701                                     to aColumnType[i].iSQLType
99593>>>>            Move True                                    to aColumnType[i].bCanEditSize
99594>>>>            Move True                                    to aColumnType[i].bNativeDataType
99595>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99596>>>>            Move 1                                       to aColumnType[i].iMinSize
99597>>>>            Move 14                                      to aColumnType[i].nMaxSize
99598>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99599>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99600>>>>            Move 14                                      to aColumnType[i].sPrecision
99601>>>>            Increment i
99602>>>>
99602>>>>            Move "integer"                               to aColumnType[i].sSQLType
99603>>>>            Move 23                                      to aColumnType[i].iSQLType
99604>>>>            Move True                                    to aColumnType[i].bCanEditSize
99605>>>>            Move True                                    to aColumnType[i].bNativeDataType
99606>>>>            Move 11                                      to aColumnType[i].iDefaultSize
99607>>>>            Move 1                                       to aColumnType[i].iMinSize
99608>>>>            Move 11                                      to aColumnType[i].nMaxSize
99609>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99610>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99611>>>>            Move 11                                      to aColumnType[i].sPrecision
99612>>>>            Increment i
99613>>>>
99613>>>>            Move "money"                                 to aColumnType[i].sSQLType
99614>>>>            Move 790                                     to aColumnType[i].iSQLType
99615>>>>            Move True                                    to aColumnType[i].bCanEditSize
99616>>>>            Move True                                    to aColumnType[i].bNativeDataType
99617>>>>            Move 30                                      to aColumnType[i].iDefaultSize
99618>>>>            Move 1                                       to aColumnType[i].iMinSize
99619>>>>            Move 30                                      to aColumnType[i].nMaxSize
99620>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99621>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99622>>>>            Move 30                                      to aColumnType[i].sPrecision
99623>>>>            Increment i
99624>>>>
99624>>>>            Move "numeric"                               to aColumnType[i].sSQLType
99625>>>>            Move 1700                                    to aColumnType[i].iSQLType
99626>>>>            Move True                                    to aColumnType[i].bCanEditSize
99627>>>>            Move True                                    to aColumnType[i].bNativeDataType
99628>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99629>>>>            Move 1                                       to aColumnType[i].iMinSize
99630>>>>            Move 14                                      to aColumnType[i].nMaxSize
99631>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99632>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99633>>>>            Move 14                                      to aColumnType[i].sPrecision
99634>>>>            Increment i
99635>>>>
99635>>>>            Move "oid"                                   to aColumnType[i].sSQLType
99636>>>>            Move 26                                      to aColumnType[i].iSQLType
99637>>>>            Move False                                   to aColumnType[i].bCanEditSize
99638>>>>            Move True                                    to aColumnType[i].bNativeDataType
99639>>>>            Move 20                                      to aColumnType[i].iDefaultSize
99640>>>>            Move -1                                      to aColumnType[i].iMinSize
99641>>>>            Move -1                                      to aColumnType[i].nMaxSize
99642>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99643>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99644>>>>            Move -1                                      to aColumnType[i].sPrecision
99645>>>>            Increment i
99646>>>>
99646>>>>            Move "real"                                  to aColumnType[i].sSQLType
99647>>>>            Move 700                                     to aColumnType[i].iSQLType
99648>>>>            Move True                                    to aColumnType[i].bCanEditSize
99649>>>>            Move True                                    to aColumnType[i].bNativeDataType
99650>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99651>>>>            Move 1                                       to aColumnType[i].iMinSize
99652>>>>            Move 6                                       to aColumnType[i].nMaxSize
99653>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99654>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99655>>>>            Move 6                                       to aColumnType[i].sPrecision
99656>>>>            Increment i
99657>>>>
99657>>>>            Move "regproc"                               to aColumnType[i].sSQLType
99658>>>>            Move 24                                      to aColumnType[i].iSQLType
99659>>>>            Move False                                   to aColumnType[i].bCanEditSize
99660>>>>            Move True                                    to aColumnType[i].bNativeDataType
99661>>>>            Move 64                                      to aColumnType[i].iDefaultSize
99662>>>>            Move -1                                      to aColumnType[i].iMinSize
99663>>>>            Move -1                                      to aColumnType[i].nMaxSize
99664>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99665>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99666>>>>            Move -1                                      to aColumnType[i].sPrecision
99667>>>>            Increment i
99668>>>>
99668>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99669>>>>            Move 21                                      to aColumnType[i].iSQLType
99670>>>>            Move True                                    to aColumnType[i].bCanEditSize
99671>>>>            Move True                                    to aColumnType[i].bNativeDataType
99672>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99673>>>>            Move 1                                       to aColumnType[i].iMinSize
99674>>>>            Move 6                                       to aColumnType[i].nMaxSize
99675>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99676>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99677>>>>            Move 6                                       to aColumnType[i].sPrecision
99678>>>>            Increment i
99679>>>>
99679>>>>            Move "text"                                  to aColumnType[i].sSQLType
99680>>>>            Move 25                                      to aColumnType[i].iSQLType
99681>>>>            Move True                                    to aColumnType[i].bCanEditSize
99682>>>>            Move True                                    to aColumnType[i].bNativeDataType
99683>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99684>>>>            Move 1                                       to aColumnType[i].iMinSize
99685>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99686>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99687>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99688>>>>            Move 16384                                   to aColumnType[i].sPrecision
99689>>>>            Increment i
99690>>>>
99690>>>>            Move "time"                                  to aColumnType[i].sSQLType
99691>>>>            Move 1083                                    to aColumnType[i].iSQLType
99692>>>>            Move True                                    to aColumnType[i].bCanEditSize
99693>>>>            Move True                                    to aColumnType[i].bNativeDataType
99694>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99695>>>>            Move 8                                       to aColumnType[i].iMinSize
99696>>>>            Move 15                                      to aColumnType[i].nMaxSize
99697>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99698>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99699>>>>            Move 15                                      to aColumnType[i].sPrecision
99700>>>>            Increment i
99701>>>>
99701>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99702>>>>            Move 1114                                    to aColumnType[i].iSQLType
99703>>>>            Move False                                   to aColumnType[i].bCanEditSize
99704>>>>            Move True                                    to aColumnType[i].bNativeDataType
99705>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99706>>>>            Move -1                                      to aColumnType[i].iMinSize
99707>>>>            Move -1                                      to aColumnType[i].nMaxSize
99708>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99709>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99710>>>>            Move -1                                      to aColumnType[i].sPrecision
99711>>>>            Increment i
99712>>>>
99712>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
99713>>>>            Move 1184                                    to aColumnType[i].iSQLType
99714>>>>            Move False                                   to aColumnType[i].bCanEditSize
99715>>>>            Move True                                    to aColumnType[i].bNativeDataType
99716>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99717>>>>            Move -1                                      to aColumnType[i].iMinSize
99718>>>>            Move -1                                      to aColumnType[i].nMaxSize
99719>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99720>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99721>>>>            Move -1                                      to aColumnType[i].sPrecision
99722>>>>            Increment i
99723>>>>
99723>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
99724>>>>            Move 2950                                    to aColumnType[i].iSQLType
99725>>>>            Move False                                   to aColumnType[i].bCanEditSize
99726>>>>            Move True                                    to aColumnType[i].bNativeDataType
99727>>>>            Move 40                                      to aColumnType[i].iDefaultSize
99728>>>>            Move -1                                      to aColumnType[i].iMinSize
99729>>>>            Move -1                                      to aColumnType[i].nMaxSize
99730>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99731>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99732>>>>            Move -1                                      to aColumnType[i].sPrecision
99733>>>>            Increment i
99734>>>>
99734>>>>            Move "varbit"                                to aColumnType[i].sSQLType
99735>>>>            Move 1562                                    to aColumnType[i].iSQLType
99736>>>>            Move True                                    to aColumnType[i].bCanEditSize
99737>>>>            Move True                                    to aColumnType[i].bNativeDataType
99738>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99739>>>>            Move 1                                       to aColumnType[i].iMinSize
99740>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99741>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99742>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99743>>>>            Move 16384                                   to aColumnType[i].sPrecision
99744>>>>            Increment i
99745>>>>
99745>>>>            Move "varchar"                               to aColumnType[i].sSQLType
99746>>>>            Move 1043                                    to aColumnType[i].iSQLType
99747>>>>            Move True                                    to aColumnType[i].bCanEditSize
99748>>>>            Move True                                    to aColumnType[i].bNativeDataType
99749>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99750>>>>            Move 1                                       to aColumnType[i].iMinSize
99751>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99752>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99753>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99754>>>>            Move 16384                                   to aColumnType[i].sPrecision
99755>>>>            Increment i
99756>>>>
99756>>>>
99756>>>
99756>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
99756>>>//        Move "bigint"           to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99756>>>//        Move "14.0"             to ColumnType[i].sPrecision
99756>>>//        Move True               to ColumnType[i].bCanEditSize
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
99756>>>//        Move "bit"              to ColumnType[i].sSQLType
99756>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99756>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99756>>>//        Move "16384"            to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
99756>>>//        Move "boolean"          to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "1"                to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
99756>>>//        Move "bytea"            to ColumnType[i].sSQLType
99756>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99756>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99756>>>//        Move "16384"            to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
99756>>>//        Move "char"             to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "2000"             to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
99756>>>//        Move "citext"           to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "254"              to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
99756>>>//        Move "date"             to ColumnType[i].sSQLType
99756>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
99756>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99756>>>//        Move "6.0"              to ColumnType[i].sPrecision
99756>>>//        Move True               to ColumnType[i].bCanEditSize
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
99756>>>//        Move "decimal"          to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
99756>>>//        Move "14.8"             to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
99756>>>//        Move "double"           to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "22"               to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
99756>>>//        Move "integer"          to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99756>>>//        Move "8.0"              to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
99756>>>//        Move "money"            to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99756>>>//        Move "8.0"              to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
99756>>>//        Move "oid"              to ColumnType[i].sSQLType
99756>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99756>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99756>>>//        Move "16384"            to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
99756>>>//        Move "real"             to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Real"             to ColumnType[i].sDataFlexType
99756>>>//        Move "6.6"              to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
99756>>>//        Move "regproc"          to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "64"               to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
99756>>>//        Move "smallint"         to ColumnType[i].sSQLType
99756>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99756>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99756>>>//        Move "6.0"              to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
99756>>>//        Move "text"             to ColumnType[i].sSQLType
99756>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99756>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99756>>>//        Move "16384"            to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
99756>>>//        Move "time"             to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99756>>>//        Move "15.0"             to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
99756>>>//        Move "timestamp"        to ColumnType[i].sSQLType
99756>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99756>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99756>>>//        Move "23.0"             to ColumnType[i].sPrecision
99756>>>//        Move True               to ColumnType[i].bCanEditSize
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
99756>>>//        Move "uuid"             to ColumnType[i].sSQLType
99756>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99756>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99756>>>//        Move "40"               to ColumnType[i].sPrecision
99756>>>//        Move True               to ColumnType[i].bCanEditSize
99756>>>//        Increment i
99756>>>//
99756>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
99756>>>//        Move "varchar"          to ColumnType[i].sSQLType
99756>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99756>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
99756>>>//        Move "16384"            to ColumnType[i].sPrecision
99756>>>//        Increment i
99756>>>
99756>>>        Function_Return aColumnType
99757>>>    End_Function
99758>>>
99758>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
99758>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
99760>>>        Integer iValue iSize iCount iStart
99760>>>        tColumnType[] ColumnTypeArray
99760>>>        tColumnType[] ColumnTypeArray
99761>>>        tColumnType RetvalType
99761>>>        tColumnType RetvalType
99761>>>        String sValue
99761>>>        Boolean bFrameworkDataFlexType
99761>>>
99761>>>        Move "Undefined" to RetvalType.sSQLType
99762>>>        Move -1999       to RetvalType.iSQLType
99763>>>
99763>>>        Move 0 to iStart
99764>>>        Move (Uppercase(sType)) to sType
99765>>>        Move (iType <= -1490) to bFrameworkDataFlexType
99766>>>        If (bFrameworkDataFlexType = True) Begin
99768>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
99769>>>            Function_Return RetvalType
99770>>>        End
99770>>>>
99770>>>
99770>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
99771>>>
99771>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
99772>>>        Decrement iSize
99773>>>
99773>>>        for iCount from iStart to iSize
99779>>>>
99779>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
99780>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
99781>>>            If (bIntegerInputType = True) Begin
99783>>>                If (iValue = iType) Begin
99785>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
99786>>>                    Move iType                                  to RetvalType.iSQLType
99787>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99788>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99789>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99790>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
99791>>>                    Move iSize to iCount // We're done!
99792>>>                End
99792>>>>
99792>>>            End
99792>>>>
99792>>>            Else Begin
99793>>>                Move (Uppercase(sValue)) to sValue
99794>>>                If (sValue = sType) Begin
99796>>>                    Move sType                                  to RetvalType.sSQLType
99797>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
99798>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99799>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99800>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99801>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
99802>>>                    Move iSize to iCount // We're done!
99803>>>                End
99803>>>>
99803>>>            End
99803>>>>
99803>>>        Loop
99804>>>>
99804>>>
99804>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
99804>>>        // In which case we search for a match in DataFlex standard types:
99804>>>        If (RetvalType.sSQLType = "Undefined") Begin
99806>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
99807>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
99808>>>            Decrement iSize
99809>>>
99809>>>            for iCount from iStart to iSize
99815>>>>
99815>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
99816>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
99817>>>                If (iValue = iType) Begin
99819>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
99820>>>                    Move iType                                  to RetvalType.iSQLType
99821>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99822>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99823>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99824>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
99825>>>                    Move iSize to iCount // We're done!
99826>>>                End
99826>>>>
99826>>>            Loop
99827>>>>
99827>>>        End
99827>>>>
99827>>>
99827>>>        Function_Return RetvalType
99828>>>    End_Function
99829>>>
99829>>>    Function _AllTablesToConvert Returns Integer[]
99831>>>        Integer[] aTableConvertExceptions iTablesArray
99833>>>        Handle hTable
99833>>>        Integer iIndex
99833>>>        String sTableName
99833>>>        Boolean bFlexErrs
99833>>>
99833>>>        // a) Get the exception table array the developer has specified
99833>>>        Get paTableConvertExceptions to aTableConvertExceptions
99834>>>
99834>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
99834>>>        Repeat
99834>>>>
99834>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99837>>>            If (hTable <> 0) Begin
99839>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99842>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
99843>>>                If (bFlexErrs = False) Begin
99845>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
99847>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
99848>>>                        If (iIndex = -1) Begin
99850>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
99851>>>                        End
99851>>>>
99851>>>                    End
99851>>>>
99851>>>                End
99851>>>>
99851>>>            End
99851>>>>
99851>>>        Until (hTable = 0)
99853>>>
99853>>>        Move 0 to hTable
99854>>>
99854>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
99854>>>        Repeat
99854>>>>
99854>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99857>>>            If (hTable > 0) Begin
99859>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99862>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
99863>>>                If (bFlexErrs = False) Begin
99865>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
99866>>>                    If (iIndex = -1) Begin
99868>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
99869>>>                    End
99869>>>>
99869>>>                End
99869>>>>
99869>>>            End
99869>>>>
99869>>>        Until (hTable = 0)
99871>>>
99871>>>        Function_Return iTablesArray
99872>>>    End_Function
99873>>>
99873>>>    Function _AllTablesDateCorrections Returns Integer[]
99875>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
99877>>>        Handle hTable
99877>>>        Integer iIndex
99877>>>        String sTableName
99877>>>        Boolean bFlexErrs
99877>>>
99877>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
99878>>>        Move 0 to hTable
99879>>>
99879>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
99879>>>        Repeat
99879>>>>
99879>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99882>>>            If (hTable > 0) Begin
99884>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99887>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
99888>>>                If (bFlexErrs = False) Begin
99890>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
99891>>>                    If (iIndex = -1) Begin
99893>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
99894>>>                    End
99894>>>>
99894>>>                End
99894>>>>
99894>>>            End
99894>>>>
99894>>>        Until (hTable = 0)
99896>>>
99896>>>        Function_Return iTablesArray
99897>>>    End_Function
99898>>>
99898>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
99900>>>        tAPIColumn NewAPIColumn
99900>>>        tAPIColumn NewAPIColumn
99900>>>
99900>>>        Move sFieldName to NewAPIColumn.sFieldName
99901>>>        Move iType      to NewAPIColumn.iType
99902>>>        Move iLength    to NewAPIColumn.iLength
99903>>>        Move iPrecision to NewAPIColumn.iPrecision
99904>>>        Move iOptions   to NewAPIColumn.iOptions
99905>>>
99905>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
99906>>>
99906>>>        Function_Return aCurrent
99907>>>    End_Function
99908>>>
99908>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
99910>>>        String sRetval sFieldName
99910>>>        Integer iCount iSize
99910>>>
99910>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
99911>>>        Decrement iSize
99912>>>        for iCount from 0 to iSize
99918>>>>
99918>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
99919>>>            Move (sRetval * (String(sFieldName))) to sRetval
99920>>>        Loop
99921>>>>
99921>>>        Move (Trim(sRetval)) to sRetval
99922>>>
99922>>>        Function_Return sRetval
99923>>>    End_Function
99924>>>
99924>>>    // *** Miscellaneous other functions ***
99924>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
99924>>>    //
99924>>>
99924>>>    // Callback functionality used when e.g. calling driver functions directly.
99924>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
99926>>>        Integer iPerc
99926>>>        Number nReady nTotal
99926>>>
99926>>>        Send DoAdvance of ghoProgressBar
99927>>>
99927>>>        If (sCallback_Text contains "Copy records") Begin
99929>>>            Move CS_DUF_CopyingData to sCallback_Text
99930>>>        End
99930>>>>
99930>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
99932>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
99933>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
99934>>>        End
99934>>>>
99934>>>        If (sCallback_Text contains "Creating index") Begin
99936>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
99937>>>        End
99937>>>>
99937>>>
99937>>>        Case Begin
99937>>>            Case (iCallback_Type = DF_Message_Text)
99939>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99940>>>                Set Action_Text  of ghoStatusPanel to ""
99941>>>                Case Break
99942>>>            Case (iCallback_Type = DF_Message_Heading_1)
99945>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99946>>>                Set Action_Text  of ghoStatusPanel to ""
99947>>>                Case Break
99948>>>            Case (iCallback_Type = DF_Message_Heading_2)
99951>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99952>>>                Set Action_Text  of ghoStatusPanel to ""
99953>>>                Case Break
99954>>>            Case (iCallback_Type = DF_Message_Heading_3)
99957>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99958>>>                Set Action_Text  of ghoStatusPanel to ""
99959>>>                Case Break
99960>>>            Case (iCallback_Type = DF_Message_Heading_4)
99963>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99964>>>                Set Action_Text  of ghoStatusPanel to ""
99965>>>                Case Break
99966>>>            Case (iCallback_Type = DF_Message_Heading_5)
99969>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99970>>>                Set Action_Text  of ghoStatusPanel to ""
99971>>>                Case Break
99972>>>            Case (iCallback_Type = DF_Message_Warning)
99975>>>                Send None
99976>>>                Case Break
99977>>>            Case (iCallback_Type = DF_Message_Progress_Title)
99980>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99981>>>                Set Action_Text  of ghoStatusPanel to ""
99982>>>                Case Break
99983>>>            Case (iCallback_Type = DF_Message_Progress_Value)
99986>>>                //*** Interpret numbers
99986>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
99987>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
99988>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
99989>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
99990>>>                Case Break
99991>>>            Case Else
99991>>>                Set Message_Text to ""
99992>>>                Set Action_Text  to ""
99993>>>        Case End
99993>>>
99993>>>        Send ProcessEvents of ghoStatusPanel
99994>>>        Function_Return False
99995>>>    End_Function
99996>>>
99996>>>    Procedure IncreaseSortBufferSize
99998>>>        String sNull
99998>>>        Integer iSortBufferSize
99998>>>        Boolean bBufferSet
99998>>>
99998>>>        Move "" to sNull
99999>>>        Move (1024 * 128) to iSortBufferSize
100000>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
100005>>>
100005>>>    End_Procedure
100006>>>
100006>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
100008>>>        Integer iLastIndex iIndex iNumSegments
100008>>>        Boolean bOK
100008>>>        String sDriverID
100008>>>
100008>>>        If (hTable > 0) Begin
100010>>>            Get UtilDriverFromTableNumber hTable to sDriverID
100011>>>            Close hTable
100012>>>            Get OpenTableExclusive hTable to bOK
100013>>>            If (bOK = False) Begin
100015>>>                Procedure_Return
100016>>>            End
100016>>>>
100016>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
100019>>>            Structure_Start hTable sDriverID
100020>>>                for iIndex from 1 to iLastIndex
100026>>>>
100026>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
100029>>>                    If (iNumSegments > 0) Begin
100031>>>                        If (bSetToBatch = True) Begin
100033>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
100036>>>                        End
100036>>>>
100036>>>                        Else Begin
100037>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
100040>>>                        End
100040>>>>
100040>>>                    End
100040>>>>
100040>>>                Loop
100041>>>>
100041>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
100043>>>        End
100043>>>>
100043>>>    End_Procedure
100044>>>
100044>>>    Function NextFreeFilelistSlot Returns Handle
100046>>>        Handle hTable
100046>>>
100046>>>        Move 0 to hTable
100047>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
100050>>>
100050>>>        Function_Return hTable
100051>>>    End_Function
100052>>>
100052>>>    // For debugging purposes. To print Sql statements as they are build...
100052>>>    Procedure DebugPrint String sStmt String sFileName
100054>>>        Integer iCh
100054>>>        Get Seq_Append_Output_Channel sFileName to iCh
100055>>>            Write channel iCh sStmt
100057>>>        Send Seq_Close_Channel iCh
100058>>>    End_Procedure
100059>>>
100059>>>    // Returns the integer number for the passed Driver ID that is
100059>>>    // needed by some database API calls.
100059>>>    Function DriverIndex String sDriverID Returns Integer
100061>>>        String  sCurrentDriver
100061>>>        Integer iNumberOfDrivers iDriver iCount
100061>>>
100061>>>        Move 0 to iDriver
100062>>>
100062>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100065>>>        for iCount from 1 to iNumberOfDrivers
100071>>>>
100071>>>
100071>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
100074>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
100076>>>                Move iCount to iDriver
100077>>>            End
100077>>>>
100077>>>        Loop
100078>>>>
100078>>>
100078>>>        // In case it was not found, it wasn't loaded so we do that now.
100078>>>        If (iDriver = 0) Begin
100080>>>            Move False to Err
100081>>>            Load_Driver sDriverID
100082>>>            If (Err = False) Begin
100084>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
100087>>>            End
100087>>>>
100087>>>        End
100087>>>>
100087>>>
100087>>>        Function_Return iDriver
100088>>>    End_Function
100089>>>
100089>>>    
100089>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
100091>>>        String sDriverID sVersion sClient sClientLowest sRetval
100091>>>        Integer iNumberOfDrivers iDriver iClient
100091>>>        Handle hoCLIHandler hoMSSQLHandler   
100091>>>        Boolean bOK
100091>>>        
100091>>>        Move "" to sRetval
100092>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
100093>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
100094>>>        Load_Driver MSSQLDRV_ID
100095>>>
100095>>>        // Loop through all loaded drivers.
100095>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100098>>>        For iDriver from 1 to iNumberOfDrivers
100104>>>>
100104>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
100107>>>            If (sDriverID = MSSQLDRV_ID) Begin
100109>>>                Set psDriverID of hoCLIHandler to sDriverID
100110>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
100113>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
100114>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
100115>>>                Get CKRevision of hoCLIHandler to sVersion
100116>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
100117>>>                If (sClient <> "" and sRetval <> "") Begin
100119>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
100120>>>                End                                
100120>>>>
100120>>>                Else Begin
100121>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
100122>>>                End
100122>>>>
100122>>>            End
100122>>>>
100122>>>        Loop
100123>>>>
100123>>>        Send Destroy of hoCLIHandler  
100124>>>        Send Destroy of hoMSSQLHandler  
100125>>>        If (bShowErrorDialog = True) Begin
100127>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
100128>>>            If (bOK = False or (iClient < iClientVersion)) Begin
100130>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
100131>>>                If (bExitProgram = True) Begin
100133>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
100134>>>                End
100134>>>>
100134>>>                Send Stop_Box sRetval  
100135>>>                If (bExitProgram = True) Begin
100137>>>                    Send Exit_Application
100138>>>                End
100138>>>>
100138>>>            End
100138>>>>
100138>>>        End
100138>>>>
100138>>>        
100138>>>        Function_Return sRetval
100139>>>    End_Function  
100140>>>    
100140>>>    // Returns True if first "." separated string is greater than the second.
100140>>>    // It checks from left to right, one part of the string at a time.
100140>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
100140>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
100142>>>        String[] asVersion asSQLVersion          
100144>>>        Integer iSize iCount iVersion iSQLVersion
100144>>>        
100144>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
100145>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
100146>>>        Move (SizeOfArray(asVersion)) to iSize
100147>>>        // Make sure the two arrays are of the same size:
100147>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
100149>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
100150>>>        End
100150>>>>
100150>>>        Decrement iSize
100151>>>        for iCount from 0 to iSize
100157>>>>
100157>>>            Move asVersion[iCount]    to iVersion
100158>>>            Move asSQLVersion[iCount] to iSQLVersion
100159>>>            CompilerWarnings Off
100159>>>            If (iVersion > iSQLVersion) Break
100162>>>            CompilerWarnings On
100162>>>        Loop
100163>>>>
100163>>>        
100163>>>        Function_Return (iVersion > iSQLVersion)
100164>>>    End_Function
100165>>>
100165>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
100165>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
100165>>>    //       so in that case we "cheat" and report those tables were opened OK.
100165>>>    Function OpenTableExclusive Handle hTable Returns Boolean
100167>>>        Integer iMode
100167>>>        Boolean bOpened
100167>>>        String sTableName
100167>>>
100167>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100168>>>        // Can't open a table properly if run through the Debugger/Studio,
100168>>>        // so we generate an error here:
100168>>>        If (IsDebuggerPresent()) Begin
100170>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
100171>>>>
100171>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
100172>>>            Function_Return False
100173>>>        End
100173>>>>
100173>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
100176>>>        If (bOpened) Begin
100178>>>            If (IsDebuggerPresent()) Begin
100180>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100183>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
100185>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100186>>>                    Function_Return True
100187>>>                End
100187>>>>
100187>>>            End
100187>>>>
100187>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
100190>>>            If (iMode=DF_EXCLUSIVE) Begin
100192>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100193>>>                Function_Return True
100194>>>            End
100194>>>>
100194>>>            Close hTable
100195>>>        End
100195>>>>
100195>>>        Else Begin
100196>>>            Open hTable
100198>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
100201>>>            If (bOpened and IsDebuggerPresent()) Begin
100203>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100206>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
100208>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100209>>>                    Function_Return True
100210>>>                End
100210>>>>
100210>>>            End
100210>>>>
100210>>>
100210>>>        End
100210>>>>
100210>>>
100210>>>        Close hTable
100211>>>        Open hTable Mode DF_EXCLUSIVE
100213>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
100216>>>
100216>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
100217>>>        Function_Return bOpened
100218>>>    End_Function
100219>>>
100219>>>    Function AutoConnectionIDLogin Returns Boolean
100221>>>        String sConnectionID sConnectionString sDriverID
100221>>>        Boolean bExists bOK bSQLDriver bMertech
100221>>>        Handle hoCLI hoDriver
100221>>>        Integer iRetval
100221>>>        tSQLConnection SQLConnection
100221>>>        tSQLConnection SQLConnection
100221>>>
100221>>>        Get psDriverID to sDriverID
100222>>>        Get IsSQLDriver sDriverID to bSQLDriver
100223>>>        If (bSQLDriver = False) Begin
100225>>>            Function_Return True
100226>>>        End
100226>>>>
100226>>>
100226>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100227>>>        Move SQLConnection.sDriverID                  to sDriverID
100228>>>        Move SQLConnection.sConnectionString          to sConnectionString
100229>>>        Get IsMertechDriver sDriverID to bMertech
100230>>>        If (bMertech = True) Begin
100232>>>            Get _MertechSQLManagerHandle to hoCLI
100233>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100234>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
100235>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
100236>>>            Send Destroy of hoDriver
100237>>>            Function_Return bOK
100238>>>        End
100238>>>>
100238>>>
100238>>>        Move SQLConnection.sConnectionID to sConnectionID
100239>>>
100239>>>        Get IsConnectionID sConnectionID sDriverID to bExists
100240>>>        If (bExists = False) Begin
100242>>>            // We always start by deleting the current connection - if any - because the
100242>>>            // login details my have changed.
100242>>>            Get phoCLIHandler to hoCLI
100243>>>            Set psDriverID    of hoCLI to sDriverID
100244>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
100245>>>            Get AutoSetConnectionID sConnectionID to bOk
100246>>>            If (bOk = False) Begin
100248>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
100249>>>>
100249>>>                Function_Return False
100250>>>            End
100250>>>>
100250>>>            Move bOK to bExists
100251>>>        End
100251>>>>
100251>>>
100251>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100252>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
100253>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
100254>>>        Send Destroy of hoDriver
100255>>>
100255>>>        Function_Return (bExists = True)
100256>>>    End_Function
100257>>>
100257>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
100257>>>    // Returns: False if nobody else is running
100257>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
100257>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
100257>>>    //      tables are not locked as DataFlex tables are.
100257>>>    Function IsDatabaseInUse Returns Boolean
100259>>>        Handle  hTable
100259>>>        String  sRootName
100259>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
100259>>>        Integer iCount iTables
100259>>>
100259>>>        Move 0 to iTables
100260>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
100261>>>        Get AutoConnectionIDLogin to bOK
100262>>>        Get UtilFilelistNoOfTables to iTables
100263>>>        Set piPosition   of ghoProgressBar to 0
100264>>>        Set piAdvanceBy  of ghoProgressBar to 1
100265>>>        Set piMaximum    of ghoProgressBar to iTables
100266>>>        Move 0 to hTable
100267>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100270>>>        Move False to bErr
100271>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
100272>>>
100272>>>        Repeat
100272>>>>
100272>>>            Set piPosition of ghoProgressBar to iCount
100273>>>            Increment iCount
100274>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
100277>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
100278>>>
100278>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
100278>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
100279>>>            Move False to bOpen
100280>>>            Get UtilTableExists hTable to bExists
100281>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
100281>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
100283>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100284>>>                Open hTable
100286>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
100289>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
100290>>>                If (bOpen = True) Begin
100292>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
100292>>>                    Get UtilTableIsAlias hTable to bAlias
100293>>>                    If (bAlias = False) Begin
100295>>>                        Close hTable
100296>>>                        Get OpenTableExclusive hTable to bOpen
100297>>>                        If (bOpen = False) Begin
100299>>>                            Move True to bErr
100300>>>                        End
100300>>>>
100300>>>                    End
100300>>>>
100300>>>                End
100300>>>>
100300>>>                Close hTable
100301>>>            End
100301>>>>
100301>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100304>>>            If (bErr = True ) ;                Break
100307>>>        Until (not(hTable))
100309>>>
100309>>>        Set Action_Text of ghoStatusPanel to ""
100310>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
100311>>>        Move False to Err
100312>>>
100312>>>        Function_Return bErr
100313>>>    End_Function
100314>>>
100314>>>    // Checks if the passed connection id exists in the CLI interface.
100314>>>    // This might be needed by API-methods when a connection id is to be used and
100314>>>    // the connection id hasn't been established with the driver's CLI interface.
100314>>>    // NOTE: Only applicable for DAW drivers.
100314>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
100316>>>        String sID sConnString
100316>>>        Integer iDriver iNumConn iCount
100316>>>        Handle hoCLI
100316>>>        Boolean bOK
100316>>>
100316>>>        Get IsDAWSQLDriver sDriverID to bOK
100317>>>        If (bOK = False) Begin
100319>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
100320>>>>
100320>>>            Function_Return False
100321>>>        End
100321>>>>
100321>>>
100321>>>        Move False to bOK
100322>>>        Get phoCLIHandler to hoCLI
100323>>>        If (hoCLI <> 0) Begin
100325>>>            Set psDriverID of hoCLI to sDriverID
100326>>>            Get DriverIndex of hoCLI sDriverID to iDriver
100327>>>
100327>>>            // If driver not loaded; load it.
100327>>>            If (iDriver = 0) Begin
100329>>>                Load_Driver sDriverID
100330>>>                Get DriverIndex sDriverID to iDriver
100331>>>            End
100331>>>>
100331>>>            If (iDriver <> 0) Begin
100333>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
100336>>>                Decrement iNumConn
100337>>>                for iCount from 0 to iNumConn
100343>>>>
100343>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
100346>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
100349>>>                    If (sID = sConnectionID) Begin
100351>>>                        Move True to bOK
100352>>>                    End
100352>>>>
100352>>>                Loop
100353>>>>
100353>>>            End
100353>>>>
100353>>>        End
100353>>>>
100353>>>
100353>>>        Function_Return bOK
100354>>>    End_Function
100355>>>
100355>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
100357>>>        Boolean bOK
100357>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
100358>>>        Function_Return bOK
100359>>>    End_Function
100360>>>
100360>>>    Function IsMertechDriver String sDriverID Returns Boolean
100362>>>        Boolean bOK
100362>>>        Move False to bOK
100363>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
100364>>>        Function_Return bOK
100365>>>    End_Function
100366>>>
100366>>>    Function IsMSSQLDriver Returns Boolean
100368>>>        Integer iDriverIndex
100368>>>
100368>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
100369>>>
100369>>>        Function_Return (iDriverIndex <> 0)
100370>>>    End_Function
100371>>>
100371>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
100371>>>    // attempt to load the driver.
100371>>>    // Returns true if the passed driver is SQL based.
100371>>>    Function IsSQLDriver String sDriverID Returns Boolean
100373>>>        Boolean bOK
100373>>>
100373>>>        Get IsDAWSQLDriver sDriverID to bOK
100374>>>
100374>>>        If (bOK = False) Begin
100376>>>            Get IsMertechDriver sDriverID to bOK
100377>>>        End
100377>>>>
100377>>>
100377>>>        Function_Return bOK
100378>>>    End_Function
100379>>>
100379>>>    // *** Error Handler ***
100379>>>    //
100379>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
100379>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
100379>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
100381>>>        Integer iSize iErrorMode
100381>>>        tSqlErrorArray aSqlErrorArray
100381>>>        tSqlErrorArray aSqlErrorArray
100381>>>
100381>>>        If (pbProcessingError(Self)) Begin
100383>>>            Procedure_Return
100384>>>        End
100384>>>>
100384>>>
100384>>>        Get Error_Report_Mode to iErrorMode
100385>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
100387>>>            Procedure_Return
100388>>>        End
100388>>>>
100388>>>
100388>>>        Set pbProcessingError to True
100389>>>        Set pbSqlError to True
100390>>>        Get paSqlErrorArray      to aSqlErrorArray
100391>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
100392>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
100393>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
100394>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
100395>>>        Set paSqlErrorArray      to aSqlErrorArray
100396>>>        Set pbProcessingError to False
100397>>>    End_Procedure
100398>>>
100398>>>    // *** Miscellanous Helper Functions ***
100398>>>    //
100398>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
100398>>>    // returns the table name only; stripped of any path or filename extension.
100398>>>    Function _TableNameOnly String sName Returns String
100400>>>        String sPath sExt
100400>>>
100400>>>        Get ParseFolderName sName to sPath
100401>>>        If (sPath <> "") Begin
100403>>>            Move (Replace(sPath, sName, "")) to sName
100404>>>        End
100404>>>>
100404>>>        Get ParseFileExtension sName to sExt
100405>>>        If (sExt <> "") Begin
100407>>>            Move (Replace(("." + sExt), sName, "")) to sName
100408>>>        End
100408>>>>
100408>>>
100408>>>        Function_Return sName
100409>>>    End_Function
100410>>>
100410>>>    // Removes any prefix to a table name.
100410>>>    // Example mssqldrv:mytable returns mytable
100410>>>    //         dbo.mytable returns mytable
100410>>>    Function _TableNoPrefix String sName Returns String
100412>>>        Integer iPos
100412>>>
100412>>>        Move (Pos(":", sName)) to iPos
100413>>>        If (iPos <> 0) Begin
100415>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
100416>>>        End
100416>>>>
100416>>>        Move (Pos(".", sName)) to iPos
100417>>>        If (iPos <> 0) Begin
100419>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
100420>>>        End
100420>>>>
100420>>>
100420>>>        Function_Return sName
100421>>>    End_Function
100422>>>
100422>>>    // Returns the first datapath found in the psDataPath property.
100422>>>    // The returned path always ends with a "\"
100422>>>    Function psDataPathFirstPart Returns String
100424>>>        String sDataPath
100424>>>        Integer iCount
100424>>>
100424>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
100425>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
100426>>>        If (iCount > 1) Begin
100428>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
100429>>>        End
100429>>>>
100429>>>        If (sDataPath <> "") Begin
100431>>>            Get vFolderFormat sDataPath to sDataPath
100432>>>        End
100432>>>>
100432>>>
100432>>>        Function_Return sDataPath
100433>>>    End_Function
100434>>>
100434>>>    Function psLogTextFileWithPath Returns String
100436>>>        String sFileName
100436>>>        Handle hoLogFile
100436>>>        Get phoLogFile to hoLogFile
100437>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
100438>>>        Function_Return sFileName
100439>>>    End_Function
100440>>>
100440>>>    // *** Property Messages ***
100440>>>    //
100440>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
100440>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
100440>>>    //
100440>>>
100440>>>    Function pSQLConnection Returns tSQLConnection
100442>>>        tSQLConnection SQLConnection
100442>>>        tSQLConnection SQLConnection
100442>>>        If (ghoSQLConnectionHandler = 0) Begin
100444>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100444>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100445>>>>
100445>>>            Function_Return
100446>>>        End
100446>>>>
100446>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100447>>>        Function_Return SQLConnection
100448>>>    End_Function
100449>>>
100449>>>    // * Dummy function for the Studio's Code Explorer *
100449>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
100451>>>        Function_Return False
100452>>>    End_Function
100453>>>
100453>>>    Procedure Set psServer String sValue
100455>>>        If (ghoSQLConnectionHandler = 0) Begin
100457>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100457>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100458>>>>
100458>>>            Procedure_Return
100459>>>        End
100459>>>>
100459>>>        Set psServer of ghoSQLConnectionHandler to sValue
100460>>>    End_Procedure
100461>>>
100461>>>    Function psServer Returns String
100463>>>        String sValue
100463>>>        If (ghoSQLConnectionHandler = 0) Begin
100465>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100466>>>>
100466>>>            Function_Return
100467>>>        End
100467>>>>
100467>>>        Get psServer of ghoSQLConnectionHandler to sValue
100468>>>        Function_Return sValue
100469>>>    End_Function
100470>>>
100470>>>    Procedure Set psDatabase String sValue
100472>>>        If (ghoSQLConnectionHandler = 0) Begin
100474>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100475>>>>
100475>>>            Procedure_Return
100476>>>        End
100476>>>>
100476>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
100477>>>    End_Procedure
100478>>>
100478>>>    Function psDatabase Returns String
100480>>>        String sValue
100480>>>        If (ghoSQLConnectionHandler = 0) Begin
100482>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100483>>>>
100483>>>            Function_Return
100484>>>        End
100484>>>>
100484>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
100485>>>        Function_Return sValue
100486>>>    End_Function
100487>>>
100487>>>    Procedure Set psUserID String sValue
100489>>>        If (ghoSQLConnectionHandler = 0) Begin
100491>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100492>>>>
100492>>>            Procedure_Return
100493>>>        End
100493>>>>
100493>>>        Set psUserID of ghoSQLConnectionHandler to sValue
100494>>>    End_Procedure
100495>>>
100495>>>    Function psUserID Returns String
100497>>>        String sValue
100497>>>        If (ghoSQLConnectionHandler = 0) Begin
100499>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100500>>>>
100500>>>            Function_Return
100501>>>        End
100501>>>>
100501>>>        Get psUserID of ghoSQLConnectionHandler to sValue
100502>>>        Function_Return sValue
100503>>>    End_Function
100504>>>
100504>>>    Procedure Set psPassword String sValue
100506>>>        If (ghoSQLConnectionHandler = 0) Begin
100508>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100509>>>>
100509>>>            Procedure_Return
100510>>>        End
100510>>>>
100510>>>        Set psPassword of ghoSQLConnectionHandler to sValue
100511>>>    End_Procedure
100512>>>
100512>>>    Function psPassword Returns String
100514>>>        String sValue
100514>>>        If (ghoSQLConnectionHandler = 0) Begin
100516>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100517>>>>
100517>>>            Function_Return
100518>>>        End
100518>>>>
100518>>>        Get psPassword of ghoSQLConnectionHandler to sValue
100519>>>        Function_Return sValue
100520>>>    End_Function
100521>>>
100521>>>    Procedure Set pbTrusted Boolean bValue
100523>>>        If (ghoSQLConnectionHandler = 0) Begin
100525>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100526>>>>
100526>>>            Procedure_Return
100527>>>        End
100527>>>>
100527>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
100528>>>    End_Procedure
100529>>>
100529>>>    Function pbTrusted Returns Boolean
100531>>>        Boolean bValue
100531>>>        If (ghoSQLConnectionHandler = 0) Begin
100533>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100534>>>>
100534>>>            Function_Return
100535>>>        End
100535>>>>
100535>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
100536>>>        Function_Return bValue
100537>>>    End_Function
100538>>>
100538>>>    Procedure Set pbSilentLogin Boolean bValue
100540>>>        If (ghoSQLConnectionHandler = 0) Begin
100542>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100543>>>>
100543>>>            Procedure_Return
100544>>>        End
100544>>>>
100544>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
100545>>>    End_Procedure
100546>>>
100546>>>    Function pbSilentLogin Returns Boolean
100548>>>        Boolean bValue
100548>>>        If (ghoSQLConnectionHandler = 0) Begin
100550>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100551>>>>
100551>>>            Function_Return
100552>>>        End
100552>>>>
100552>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
100553>>>        Function_Return bValue
100554>>>    End_Function
100555>>>
100555>>>    Procedure Set psConnectionID String sValue
100557>>>        If (ghoSQLConnectionHandler = 0) Begin
100559>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100560>>>>
100560>>>            Procedure_Return
100561>>>        End
100561>>>>
100561>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
100562>>>    End_Procedure
100563>>>
100563>>>    Function psConnectionID Returns String
100565>>>        String sValue
100565>>>        If (ghoSQLConnectionHandler = 0) Begin
100567>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100568>>>>
100568>>>            Function_Return
100569>>>        End
100569>>>>
100569>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
100570>>>        Function_Return sValue
100571>>>    End_Function
100572>>>
100572>>>    Procedure Set psConnectionString String sValue
100574>>>        If (ghoSQLConnectionHandler = 0) Begin
100576>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100577>>>>
100577>>>            Procedure_Return
100578>>>        End
100578>>>>
100578>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
100579>>>    End_Procedure
100580>>>
100580>>>    Function psConnectionString Returns String
100582>>>        String sValue
100582>>>        If (ghoSQLConnectionHandler = 0) Begin
100584>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100585>>>>
100585>>>            Function_Return
100586>>>        End
100586>>>>
100586>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
100587>>>        Function_Return sValue
100588>>>    End_Function
100589>>>
100589>>>    // The normal connection string looks something like this;
100589>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100589>>>    // ...and the full connection string looks like this;
100589>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100589>>>    Function psFullConnectionString Returns String
100591>>>        String sConnectionID sConnectionString
100591>>>        If (ghoSQLConnectionHandler = 0) Begin
100593>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100594>>>>
100594>>>            Function_Return
100595>>>        End
100595>>>>
100595>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
100596>>>        Move (Trim(sConnectionID)) to sConnectionID
100597>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
100598>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
100599>>>    End_Function
100600>>>
100600>>>    Function piConnectionOptions Returns Integer
100602>>>        Integer iValue
100602>>>        If (ghoSQLConnectionHandler = 0) Begin
100604>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100605>>>>
100605>>>            Function_Return
100606>>>        End
100606>>>>
100606>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
100607>>>        Function_Return iValue
100608>>>    End_Function
100609>>>
100609>>>    Procedure Set psSchema String sValue
100611>>>        tSQLConnection SQLConnection
100611>>>        tSQLConnection SQLConnection
100611>>>        If (ghoSQLConnectionHandler = 0) Begin
100613>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100614>>>>
100614>>>            Procedure_Return
100615>>>        End
100615>>>>
100615>>>        Set psSchema of ghoSQLConnectionHandler to sValue
100616>>>    End_Procedure
100617>>>
100617>>>    Function psSchema Returns String
100619>>>        String sRetval
100619>>>        If (ghoSQLConnectionHandler = 0) Begin
100621>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100622>>>>
100622>>>            Function_Return
100623>>>        End
100623>>>>
100623>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
100624>>>        Function_Return sRetval
100625>>>    End_Function
100626>>>
100626>>>    Procedure Set psBaseTableSpace String sValue
100628>>>        If (ghoSQLConnectionHandler = 0) Begin
100630>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100631>>>>
100631>>>            Procedure_Return
100632>>>        End
100632>>>>
100632>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
100633>>>    End_Procedure
100634>>>
100634>>>    Function psBaseTableSpace Returns String
100636>>>        String sRetval
100636>>>        If (ghoSQLConnectionHandler = 0) Begin
100638>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100639>>>>
100639>>>            Function_Return
100640>>>        End
100640>>>>
100640>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
100641>>>        Function_Return sRetval
100642>>>    End_Function
100643>>>
100643>>>    Procedure Set psLongTableSpace String sValue
100645>>>        If (ghoSQLConnectionHandler = 0) Begin
100647>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100648>>>>
100648>>>            Procedure_Return
100649>>>        End
100649>>>>
100649>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
100650>>>    End_Procedure
100651>>>
100651>>>    Function psLongTableSpace Returns String
100653>>>        String sRetval
100653>>>        If (ghoSQLConnectionHandler = 0) Begin
100655>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100656>>>>
100656>>>            Function_Return
100657>>>        End
100657>>>>
100657>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
100658>>>        Function_Return sRetval
100659>>>    End_Function
100660>>>
100660>>>    Procedure Set psIndexTableSpace String sValue
100662>>>        If (ghoSQLConnectionHandler = 0) Begin
100664>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100665>>>>
100665>>>            Procedure_Return
100666>>>        End
100666>>>>
100666>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
100667>>>    End_Procedure
100668>>>
100668>>>    Function psIndexTableSpace Returns String
100670>>>        String sRetval
100670>>>        If (ghoSQLConnectionHandler = 0) Begin
100672>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100673>>>>
100673>>>            Function_Return
100674>>>        End
100674>>>>
100674>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
100675>>>        Function_Return sRetval
100676>>>    End_Function
100677>>>
100677>>>    Procedure Set pbUseConnectionID Boolean bState
100679>>>        If (ghoSQLConnectionHandler = 0) Begin
100681>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100682>>>>
100682>>>            Procedure_Return
100683>>>        End
100683>>>>
100683>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
100684>>>    End_Procedure
100685>>>
100685>>>    Function pbUseConnectionID Returns Boolean
100687>>>        Boolean bState
100687>>>        If (ghoSQLConnectionHandler = 0) Begin
100689>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100690>>>>
100690>>>            Function_Return
100691>>>        End
100691>>>>
100691>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
100692>>>        Function_Return bState
100693>>>    End_Function
100694>>>
100694>>>    Procedure Set pbToANSI Boolean bState
100696>>>        If (ghoSQLConnectionHandler = 0) Begin
100698>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100699>>>>
100699>>>            Procedure_Return
100700>>>        End
100700>>>>
100700>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
100701>>>    End_Procedure
100702>>>
100702>>>    Function pbToANSI Returns Boolean
100704>>>        Boolean bState
100704>>>        If (ghoSQLConnectionHandler = 0) Begin
100706>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100707>>>>
100707>>>            Function_Return
100708>>>        End
100708>>>>
100708>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
100709>>>        Function_Return bState
100710>>>    End_Function
100711>>>
100711>>>    Procedure Set pbRecnum Boolean bState
100713>>>        If (ghoSQLConnectionHandler = 0) Begin
100715>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100716>>>>
100716>>>            Procedure_Return
100717>>>        End
100717>>>>
100717>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
100718>>>    End_Procedure
100719>>>
100719>>>    Function pbRecnum Returns Boolean
100721>>>        Boolean bState
100721>>>        If (ghoSQLConnectionHandler = 0) Begin
100723>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100724>>>>
100724>>>            Function_Return
100725>>>        End
100725>>>>
100725>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
100726>>>        Function_Return bState
100727>>>    End_Function
100728>>>
100728>>>    Procedure Set pbCopyData Boolean bState
100730>>>        If (ghoSQLConnectionHandler = 0) Begin
100732>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100733>>>>
100733>>>            Procedure_Return
100734>>>        End
100734>>>>
100734>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
100735>>>    End_Procedure
100736>>>
100736>>>    Function pbCopyData Returns Boolean
100738>>>        Boolean bState
100738>>>        If (ghoSQLConnectionHandler = 0) Begin
100740>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100741>>>>
100741>>>            Function_Return
100742>>>        End
100742>>>>
100742>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
100743>>>        Function_Return bState
100744>>>    End_Function
100745>>>
100745>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
100747>>>        If (ghoSQLConnectionHandler = 0) Begin
100749>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100750>>>>
100750>>>            Procedure_Return
100751>>>        End
100751>>>>
100751>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
100752>>>    End_Procedure
100753>>>
100753>>>    Function pbApiTableUpdateAuto Returns Boolean
100755>>>        Boolean bState
100755>>>        If (ghoSQLConnectionHandler = 0) Begin
100757>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100758>>>>
100758>>>            Function_Return
100759>>>        End
100759>>>>
100759>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
100760>>>        Function_Return bState
100761>>>    End_Function
100762>>>
100762>>>    Procedure Set pbCompareDate_DateTime Boolean bState
100764>>>        If (ghoSQLConnectionHandler = 0) Begin
100766>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100767>>>>
100767>>>            Procedure_Return
100768>>>        End
100768>>>>
100768>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
100769>>>    End_Procedure
100770>>>
100770>>>    Function pbCompareDate_DateTime Returns Boolean
100772>>>        Boolean bState
100772>>>        If (ghoSQLConnectionHandler = 0) Begin
100774>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100775>>>>
100775>>>            Function_Return
100776>>>        End
100776>>>>
100776>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
100777>>>        Function_Return bState
100778>>>    End_Function
100779>>>
100779>>>    Procedure Set pbCompareIndexAscending Boolean bState
100781>>>        If (ghoSQLConnectionHandler = 0) Begin
100783>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100784>>>>
100784>>>            Procedure_Return
100785>>>        End
100785>>>>
100785>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
100786>>>    End_Procedure
100787>>>
100787>>>    Function pbCompareIndexAscending Returns Boolean
100789>>>        Boolean bState
100789>>>        If (ghoSQLConnectionHandler = 0) Begin
100791>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100792>>>>
100792>>>            Function_Return
100793>>>        End
100793>>>>
100793>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
100794>>>        Function_Return bState
100795>>>    End_Function
100796>>>
100796>>>    Procedure Set pbCompareIndexUppercase Boolean bState
100798>>>        If (ghoSQLConnectionHandler = 0) Begin
100800>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100801>>>>
100801>>>            Procedure_Return
100802>>>        End
100802>>>>
100802>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
100803>>>    End_Procedure
100804>>>
100804>>>    Function pbCompareIndexUppercase Returns Boolean
100806>>>        Boolean bState
100806>>>        If (ghoSQLConnectionHandler = 0) Begin
100808>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100809>>>>
100809>>>            Function_Return
100810>>>        End
100810>>>>
100810>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
100811>>>        Function_Return bState
100812>>>    End_Function
100813>>>
100813>>>    Procedure Set psDriverDefaultValueASCII String sValue
100815>>>        If (ghoSQLConnectionHandler = 0) Begin
100817>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100818>>>>
100818>>>            Procedure_Return
100819>>>        End
100819>>>>
100819>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
100820>>>    End_Procedure
100821>>>
100821>>>    Function psDriverDefaultValueASCII Returns String
100823>>>        String sRetval
100823>>>        If (ghoSQLConnectionHandler = 0) Begin
100825>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100826>>>>
100826>>>            Function_Return
100827>>>        End
100827>>>>
100827>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
100828>>>        Function_Return sRetval
100829>>>    End_Function
100830>>>
100830>>>    Procedure Set psDriverDefaultValueBinary String sValue
100832>>>        If (ghoSQLConnectionHandler = 0) Begin
100834>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100835>>>>
100835>>>            Procedure_Return
100836>>>        End
100836>>>>
100836>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
100837>>>    End_Procedure
100838>>>
100838>>>    Function psDriverDefaultValueBinary Returns String
100840>>>        String sRetval
100840>>>        If (ghoSQLConnectionHandler = 0) Begin
100842>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100843>>>>
100843>>>            Function_Return
100844>>>        End
100844>>>>
100844>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
100845>>>        Function_Return sRetval
100846>>>    End_Function
100847>>>
100847>>>    Procedure Set psDriverDefaultValueDate String sValue
100849>>>        If (ghoSQLConnectionHandler = 0) Begin
100851>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100852>>>>
100852>>>            Procedure_Return
100853>>>        End
100853>>>>
100853>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
100854>>>    End_Procedure
100855>>>
100855>>>    Function psDriverDefaultValueDate Returns String
100857>>>        String sRetval
100857>>>        If (ghoSQLConnectionHandler = 0) Begin
100859>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100860>>>>
100860>>>            Function_Return
100861>>>        End
100861>>>>
100861>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
100862>>>        Function_Return sRetval
100863>>>    End_Function
100864>>>
100864>>>    Procedure Set psDriverDefaultValueDateTime String sValue
100866>>>        If (ghoSQLConnectionHandler = 0) Begin
100868>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100869>>>>
100869>>>            Procedure_Return
100870>>>        End
100870>>>>
100870>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
100871>>>    End_Procedure
100872>>>
100872>>>    Function psDriverDefaultValueDateTime Returns String
100874>>>        String sRetval
100874>>>        If (ghoSQLConnectionHandler = 0) Begin
100876>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100877>>>>
100877>>>            Function_Return
100878>>>        End
100878>>>>
100878>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
100879>>>        Function_Return sRetval
100880>>>    End_Function
100881>>>
100881>>>    Procedure Set psDriverDefaultValueNumeric String sValue
100883>>>        If (ghoSQLConnectionHandler = 0) Begin
100885>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100886>>>>
100886>>>            Procedure_Return
100887>>>        End
100887>>>>
100887>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
100888>>>    End_Procedure
100889>>>
100889>>>    Function psDriverDefaultValueNumeric Returns String
100891>>>        String sRetval
100891>>>        If (ghoSQLConnectionHandler = 0) Begin
100893>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100894>>>>
100894>>>            Function_Return
100895>>>        End
100895>>>>
100895>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
100896>>>        Function_Return sRetval
100897>>>    End_Function
100898>>>
100898>>>    Procedure Set psDriverDefaultValueText String sValue
100900>>>        If (ghoSQLConnectionHandler = 0) Begin
100902>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100903>>>>
100903>>>            Procedure_Return
100904>>>        End
100904>>>>
100904>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
100905>>>    End_Procedure
100906>>>
100906>>>    Function psDriverDefaultValueText Returns String
100908>>>        String sRetval
100908>>>        If (ghoSQLConnectionHandler = 0) Begin
100910>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100911>>>>
100911>>>            Function_Return
100912>>>        End
100912>>>>
100912>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
100913>>>        Function_Return sRetval
100914>>>    End_Function
100915>>>
100915>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
100917>>>        If (ghoSQLConnectionHandler = 0) Begin
100919>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100920>>>>
100920>>>            Procedure_Return
100921>>>        End
100921>>>>
100921>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
100922>>>    End_Procedure
100923>>>
100923>>>    Function pbDriverDefaultNullableASCII Returns Boolean
100925>>>        Boolean bState
100925>>>        If (ghoSQLConnectionHandler = 0) Begin
100927>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100928>>>>
100928>>>            Function_Return
100929>>>        End
100929>>>>
100929>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
100930>>>        Function_Return bState
100931>>>    End_Function
100932>>>
100932>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
100934>>>        If (ghoSQLConnectionHandler = 0) Begin
100936>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100937>>>>
100937>>>            Procedure_Return
100938>>>        End
100938>>>>
100938>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
100939>>>    End_Procedure
100940>>>
100940>>>    Function pbDriverDefaultNullableBinary Returns Boolean
100942>>>        Boolean bState
100942>>>        If (ghoSQLConnectionHandler = 0) Begin
100944>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100945>>>>
100945>>>            Function_Return
100946>>>        End
100946>>>>
100946>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
100947>>>        Function_Return bState
100948>>>    End_Function
100949>>>
100949>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
100951>>>        If (ghoSQLConnectionHandler = 0) Begin
100953>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100954>>>>
100954>>>            Procedure_Return
100955>>>        End
100955>>>>
100955>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
100956>>>    End_Procedure
100957>>>
100957>>>    Function pbDriverDefaultNullableDate Returns Boolean
100959>>>        Boolean bState
100959>>>        If (ghoSQLConnectionHandler = 0) Begin
100961>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100962>>>>
100962>>>            Function_Return
100963>>>        End
100963>>>>
100963>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
100964>>>        Function_Return bState
100965>>>    End_Function
100966>>>
100966>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
100968>>>        If (ghoSQLConnectionHandler = 0) Begin
100970>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100971>>>>
100971>>>            Procedure_Return
100972>>>        End
100972>>>>
100972>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
100973>>>    End_Procedure
100974>>>
100974>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
100976>>>        Boolean bState
100976>>>        If (ghoSQLConnectionHandler = 0) Begin
100978>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100979>>>>
100979>>>            Function_Return
100980>>>        End
100980>>>>
100980>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
100981>>>        Function_Return bState
100982>>>    End_Function
100983>>>
100983>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
100985>>>        If (ghoSQLConnectionHandler = 0) Begin
100987>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100988>>>>
100988>>>            Procedure_Return
100989>>>        End
100989>>>>
100989>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
100990>>>    End_Procedure
100991>>>
100991>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
100993>>>        Boolean bState
100993>>>        If (ghoSQLConnectionHandler = 0) Begin
100995>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100996>>>>
100996>>>            Function_Return
100997>>>        End
100997>>>>
100997>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
100998>>>        Function_Return bState
100999>>>    End_Function
101000>>>
101000>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
101002>>>        If (ghoSQLConnectionHandler = 0) Begin
101004>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101005>>>>
101005>>>            Procedure_Return
101006>>>        End
101006>>>>
101006>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
101007>>>    End_Procedure
101008>>>
101008>>>    Function pbDriverDefaultNullableText Returns Boolean
101010>>>        Boolean bState
101010>>>        If (ghoSQLConnectionHandler = 0) Begin
101012>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101013>>>>
101013>>>            Function_Return
101014>>>        End
101014>>>>
101014>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
101015>>>        Function_Return bState
101016>>>    End_Function
101017>>>
101017>>>    // Note: If the psDriverID + other connection properties are to be changed,
101017>>>    //       the psDriverID *must* be the first property that gets changed!
101017>>>    //       Otherwise errors might be raised by the driver when e.g. the format
101017>>>    //       for a connection string has the wrong format for that driver.
101017>>>    Procedure Set psDriverID String sValue
101019>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101020>>>        Delegate Set psDriverID to sValue
101022>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101023>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
101024>>>    End_Procedure
101025>>>
101025>>>    Function psDriverID Returns String
101027>>>        String sDriverID
101027>>>
101027>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101028>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
101028>>>        Delegate Get psDriverID to sDriverID
101030>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101031>>>        Move False to Err
101032>>>
101032>>>        // ...and in case it didn't use property of this class. Then the library is
101032>>>        // probably used as "utilites" from a special made program and
101032>>>        // the ghoSQLConnectionHandler must have been setup
101032>>>        If (sDriverID = "") Begin
101034>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
101035>>>        End
101035>>>>
101035>>>        Function_Return sDriverID
101036>>>    End_Function
101037>>>
101037>>>    Procedure Set piDbType Integer iValue
101039>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101040>>>        Delegate Set piDbType to iValue
101042>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101043>>>        Set piDbType of ghoSQLConnectionHandler to iValue
101044>>>    End_Procedure
101045>>>
101045>>>    Function piDbType Returns Integer
101047>>>        Integer iRetval
101047>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
101048>>>        Function_Return iRetval
101049>>>    End_Function
101050>>>
101050>>>    Function phoLogFile Returns Handle
101052>>>        Handle hoLogFile   
101052>>>        Boolean bErr
101052>>>        
101052>>>        Move Err to bErr
101053>>>        Move 0 to hoLogFile
101054>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
101055>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101056>>>        Delegate Get phoLogFile to hoLogFile
101058>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101059>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101060>>>        Move bErr to Err
101061>>>        
101061>>>        Function_Return hoLogFile
101062>>>    End_Function
101063>>>
101063>>>    Function pnCurrentVersionUpdate Returns Number
101065>>>        Number nCurrentVersionUpdate
101065>>>
101065>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101066>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
101068>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101069>>>
101069>>>        Function_Return nCurrentVersionUpdate
101070>>>    End_Function
101071>>>
101071>>>    Procedure LogError String sText Boolean bError
101073>>>        Handle hoLogFile
101073>>>        Number nCurrentVersionUpdate
101073>>>
101073>>>        Get phoLogFile to hoLogFile
101074>>>        If (hoLogFile = 0) Begin
101076>>>            Procedure_Return
101077>>>        End
101077>>>>
101077>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
101078>>>
101078>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101079>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
101080>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101081>>>    End_Procedure
101082>>>
101082>>>    Function pbContinueOnError Returns Boolean
101084>>>        Boolean bContinueOnError
101084>>>        If (ghoDbUpdateHandler > 0) Begin
101086>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
101087>>>        End
101087>>>>
101087>>>        Function_Return bContinueOnError
101088>>>    End_Function
101089>>>
101089>>>    // Latin1_General_CI_AS = General Insensitive collation
101089>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
101089>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
101089>>>    // Good read about which collation to select:
101089>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
101089>>>    Procedure Set psCollation String sCollation
101091>>>        Set private.psCollation to sCollation
101092>>>        If (ghoDbUpdateHandler > 0) Begin
101094>>>            Set psCollation of ghoDbUpdateHandler to sCollation
101095>>>        End
101095>>>>
101095>>>    End_Procedure
101096>>>
101096>>>    Function psCollation Returns String
101098>>>        String sCollation
101098>>>        If (ghoDbUpdateHandler > 0) Begin
101100>>>            Get psCollation of ghoDbUpdateHandler to sCollation
101101>>>        End   
101101>>>>
101101>>>        Else Begin
101102>>>            Get private.psCollation to sCollation
101103>>>        End
101103>>>>
101103>>>        Function_Return sCollation
101104>>>    End_Function
101105>>>
101105>>>
101105>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
101107>>>        Integer iMax iPos
101107>>>        String sName
101107>>>
101107>>>        Move (Lowercase(sField)) to sField
101108>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
101111>>>        for iPos from 0 to iMax
101117>>>>
101117>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
101120>>>            Move (Lowercase(sName)) to sName
101121>>>            If (sName = sField) Begin
101123>>>                Function_Return iPos
101124>>>            End
101124>>>>
101124>>>        Loop
101125>>>>
101125>>>        Function_Return -1
101126>>>    End_Function
101127>>>
101127>>>
101127>>>    // * Dummy function for the Studio's Code Explorer *
101127>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
101129>>>        Function_Return False
101130>>>    End_Function
101131>>>
101131>>>    // *** Helper functions with compiled sql script code ***
101131>>>    //
101131>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
101131>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
101131>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
101131>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
101131>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
101131>>>    //   ALTER TABLE MyTable
101131>>>    //       REBUILD
101131>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
101133>>>        Boolean bOK
101133>>>
101133>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
101135>>>            Function_Return False
101136>>>        End
101136>>>>
101136>>>
101136>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
101136>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
101137>>>
101137>>>        Function_Return (bOK = True)
101138>>>    End_Function
101139>>>
101139>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
101139>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
101139>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
101139>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
101139>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
101139>>>    //   ALTER TABLE MyTable
101139>>>    //       REBUILD
101139>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
101141>>>        tSQLScriptArray SQLScriptArray
101141>>>        tSQLScriptArray SQLScriptArray
101141>>>        String sDriverID
101141>>>        Boolean bOK
101141>>>        Integer iSize iCount
101141>>>
101141>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
101143>>>            Function_Return False
101144>>>        End
101144>>>>
101144>>>
101144>>>        Get psDriverID to sDriverID
101145>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101146>>>        If (SQLScriptArray.bError = True) Begin
101148>>>            Function_Return False
101149>>>        End
101149>>>>
101149>>>
101149>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101150>>>        Decrement iSize
101151>>>
101151>>>        for iCount from 0 to iSize
101157>>>>
101157>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
101159>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
101160>>>            End
101160>>>>
101160>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
101162>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
101163>>>            End
101163>>>>
101163>>>        Loop
101164>>>>
101164>>>
101164>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101165>>>
101165>>>        Function_Return (bOK = True)
101166>>>    End_Function
101167>>>
101167>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
101169>>>        tSQLScriptArray SQLScriptArray
101169>>>        tSQLScriptArray SQLScriptArray
101169>>>        String sDriverID sCollation
101169>>>        Boolean bOK
101169>>>        Integer iSize iCount
101169>>>
101169>>>        If (Trim(sDatabaseName) = "") Begin
101171>>>            Function_Return False
101172>>>        End
101172>>>>
101172>>>
101172>>>        Get psDriverID  to sDriverID
101173>>>        Get psCollation to sCollation
101174>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101175>>>        If (SQLScriptArray.bError = True) Begin
101177>>>            Function_Return False
101178>>>        End
101178>>>>
101178>>>
101178>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101179>>>        Decrement iSize
101180>>>
101180>>>        for iCount from 0 to iSize
101186>>>>
101186>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
101188>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
101189>>>            End
101189>>>>
101189>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
101191>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
101192>>>            End
101192>>>>
101192>>>        Loop
101193>>>>
101193>>>
101193>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101194>>>
101194>>>        Function_Return (bOK = True)
101195>>>    End_Function
101196>>>
101196>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
101198>>>        tSQLScriptArray SQLScriptArray
101198>>>        tSQLScriptArray SQLScriptArray
101198>>>        String sDriverID sCollation
101198>>>        Boolean bOK
101198>>>        Integer iSize iCount
101198>>>
101198>>>        If (Trim(sDatabaseName) = "") Begin
101200>>>            Function_Return False
101201>>>        End
101201>>>>
101201>>>
101201>>>        Get psDriverID  to sDriverID
101202>>>        Get psCollation to sCollation
101203>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101204>>>        If (SQLScriptArray.bError = True) Begin
101206>>>            Function_Return False
101207>>>        End
101207>>>>
101207>>>
101207>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101208>>>        Decrement iSize
101209>>>
101209>>>        for iCount from 0 to iSize
101215>>>>
101215>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
101217>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
101218>>>            End
101218>>>>
101218>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
101220>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
101221>>>            End
101221>>>>
101221>>>        Loop
101222>>>>
101222>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
101222>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101223>>>
101223>>>        Function_Return (bOK = True)
101224>>>    End_Function
101225>>>
101225>>>    // *** Helper functions for Mertech Drivers ***
101225>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
101225>>>    // and commands that the Studio editor knows nothing about.
101225>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
101227>>>        Integer iRetval
101227>>>        String sPath
101227>>>
101227>>>            SQL_GET_LOCAL_TD_PATH to sPath
101265>>>>
101265>>>        If (sPath = "" or sTableName = "") Begin
101267>>>            Function_Return True
101268>>>        End
101268>>>>
101268>>>
101268>>>        Get vFolderFormat sPath to sPath
101269>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
101270>>>        Function_Return (iRetval = 0)
101271>>>    End_Function
101272>>>
101272>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
101274>>>        Boolean bOpen bOK
101274>>>        Move False to Err
101275>>>            Close hTable
101276>>>            Get UtilTableOpenAsIntFile hTable sTableName DF_SHARE to bOpen
101277>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to True
101280>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to True
101283>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to True
101286>>>            Get UtilDeleteCacheFile sTableName to bOK
101287>>>            CLEAR_INT_CACHE
101323>>>>
101323>>>            Move (sDataPath + sPhysicalFileName) to sTableName
101324>>>            OUTPUT_INT_FILE for hTable to sTableName
101369>>>>
101369>>>        Function_Return (Err = False)
101370>>>    End_Function
101371>>>
101371>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
101373>>>        Integer iNumItems iCount
101373>>>        String[] sReturnArray
101374>>>        String sServer
101374>>>
101374>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
101375>>>        For iCount from 1 to iNumItems
101381>>>>
101381>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
101382>>>            Move sServer to sReturnArray[iCount -1]
101383>>>        Loop
101384>>>>
101384>>>
101384>>>        Function_Return sReturnArray
101385>>>    End_Function
101386>>>
101386>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
101388>>>        String[] sReturnArray
101389>>>        String sServer
101389>>>
101389>>>        GET_CURRENT_SQL_SERVER to sServer
101433>>>>
101433>>>        Move sServer to sReturnArray[0]
101434>>>
101434>>>        Function_Return sReturnArray
101435>>>    End_Function
101436>>>
101436>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
101438>>>        Handle hoSQLHandler hoSQLConnect
101438>>>
101438>>>        Move 0 to hoSQLConnect
101439>>>            Get _MertechSQLManagerHandle to hoSQLHandler
101440>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
101441>>>
101441>>>        Function_Return hoSQLConnect
101442>>>    End_Function
101443>>>
101443>>>    // Returns the handle of the Mertech SQL handler.
101443>>>    // It also ensures that the correct Server & Database attributes are set both for
101443>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
101443>>>    Function _MertechSQLManagerHandle Returns Handle
101445>>>        Handle hoSQLHandler
101445>>>        String sDriverID sServer sDatabase
101445>>>
101445>>>        Move 0 to hoSQLHandler
101446>>>        Get psDriverID to sDriverID
101447>>>        Get psServer   to sServer
101448>>>        Get psDatabase to sDatabase
101449>>>        // This command is used to set the server to be used when opening tables
101449>>>        SET_CURRENT_SQL_SERVER            to sServer
101492>>>>
101492>>>        // This command is used to specify which server to use for embedded SQL statements,
101492>>>        // but it has been constructed rather studidly as only constants and not variables
101492>>>        // are allowed...
101492>>>        If (sDriverID = MDSPgSQL) Begin
101494>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
101510>>>        End
101510>>>>
101510>>>        If (sDriverID = MDSMySQL) Begin
101512>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
101528>>>        End
101528>>>>
101528>>>        If (sDriverID = ORAFLEX) Begin
101530>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
101546>>>        End
101546>>>>
101546>>>        If (sDriverID = SQLFLEX) Begin
101548>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
101564>>>        End
101564>>>>
101564>>>
101564>>>        // This command is used to specify which database is used for SQL statements only.
101564>>>        SQL_USE_DATABASE sDatabase
101602>>>>
101602>>>        SET_DATABASE_NAME to sDatabase
101640>>>>
101640>>>
101640>>>        Get phoSQLManagerMT to hoSQLHandler
101641>>>
101641>>>        Function_Return hoSQLHandler
101642>>>    End_Function
101643>>>
101643>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
101643>>>    // macro-commands <sigh!>
101643>>>    // Note: The function sets the Err flag.
101643>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
101645>>>
101645>>>        Move False to Err
101646>>>            SET_DATABASE_NAME to sDatabase
101684>>>>
101684>>>            If (sBaseTableSpace <> "") Begin
101686>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
101723>>>>
101723>>>            End
101723>>>>
101723>>>            If (sIndexTableSpace <> "") Begin
101725>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
101762>>>>
101762>>>            End
101762>>>>
101762>>>
101762>>>            MERTECH_WARNING_MESSAGE Disabled
101795>>>>
101795>>>            CONVERT_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_INVK sRootName
101833>>>>
101833>>>            MERTECH_WARNING_MESSAGE Enabled
101866>>>>
101866>>>
101866>>>//            Move hTable to iFile
101866>>>//            Structure_Start iFile sDriverID
101866>>>//                Set_Attribute DF_FILE_OEM_TRANSLATION of iFile to (bToAnsi = True)
101866>>>//            Structure_End iFile
101866>>>
101866>>>
101866>>>        Function_Return (Err = False)
101867>>>    End_Function
101868>>>
101868>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
101870>>>        Move False to Err
101871>>>            MERTECH_WARNING_MESSAGE Disabled
101904>>>>
101904>>>            COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
101943>>>>
101943>>>            MERTECH_WARNING_MESSAGE Enabled
101976>>>>
101976>>>        Function_Return (Err = False)
101977>>>    End_Function
101978>>>
101978>>>End_Class
101979>// Needs to be after the cSQLConnectionHandler object
101979>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
101981>End_Object
101982>
101982>Object oToolTipController is a cToolTipController
101984>    Move Self to ghoToolTipController
101985>    Set pbBalloonStyle to False
101986>    Set piIcon to TTI_INFO
101987>    Set psTitle to "Information"
101988>    Set piMaxWidth to 400
101989>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
101990>End_Object
101991>
101991>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oEditContextMenu.pkg)
101991>>>Use cCJStandardMenuItemClasses.pkg
101991>>>
101991>>>Object oEditContextMenu is a cCJContextMenu
101993>>>    
101993>>>    Move Self to Default_Form_Floating_Menu_ID
101994>>>    
101994>>>    Object oUndoMenuItem is a cCJUndoMenuItem
101996>>>    End_Object
101997>>>    
101997>>>    Object oCutMenuItem is a cCJCutMenuItem
101999>>>        Set pbControlBeginGroup to True
102000>>>    End_Object
102001>>>    
102001>>>    Object oCopyMenuItem is a cCJCopyMenuItem
102003>>>    End_Object
102004>>>
102004>>>    Object oPasteMenuItem is a cCJPasteMenuItem
102006>>>    End_Object
102007>>>
102007>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
102009>>>    End_Object
102010>>>
102010>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
102012>>>        Set pbControlBeginGroup to True
102013>>>    End_Object
102014>>>
102014>>>End_Object
102015>>>
102015>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oDEOEditContextMenu17.pkg)
102015>>>Use Windows.pkg
102015>>>Use cCJStandardMenuItemClasses.pkg
102015>>>Use cCJDeoMenuItemClasses.pkg
102015>>>
102015>>>
102015>>>Object oDEOEditContextMenu17 is a cCJContextMenu
102017>>>    
102017>>>    Move Self to Default_dbFloating_Menu_ID
102018>>>    
102018>>>    Object oUndoMenuItem is a cCJUndoMenuItem
102020>>>    End_Object
102021>>>    
102021>>>    Object oCutMenuItem is a cCJCutMenuItem
102023>>>        Set pbControlBeginGroup to True
102024>>>    End_Object
102025>>>    
102025>>>    Object oCopyMenuItem is a cCJCopyMenuItem
102027>>>    End_Object
102028>>>
102028>>>    Object oPasteMenuItem is a cCJPasteMenuItem
102030>>>    End_Object
102031>>>
102031>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
102033>>>    End_Object
102034>>>
102034>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
102036>>>        Set pbControlBeginGroup to True
102037>>>    End_Object
102038>>>
102038>>>    Object oPromptMenuItem is a cCJPromptMenuItem
102040>>>        Set pbControlBeginGroup to True
102041>>>    End_Object
102042>>>
102042>>>    Object oFindNextMenu is a cCJFindNextMenuItem
102044>>>        Set pbControlBeginGroup to True
102045>>>    End_Object
102046>>>
102046>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
102048>>>    End_Object
102049>>>
102049>>>    Object oClearMenuItem is a cCJClearMenuItem
102051>>>        Set pbControlBeginGroup to True
102052>>>    End_Object
102053>>>
102053>>>    Object oClearAllMenu is a cCJClearAllMenuItem
102055>>>    End_Object
102056>>>
102056>>>    Object oSaveMenu is a cCJSaveMenuItem
102058>>>    End_Object
102059>>>    
102059>>>    Object oDeleteMenu is a cCJDeleteMenuItem
102061>>>    End_Object
102062>>>
102062>>>    Object oRememberitem is a cCJRememberFieldMenuItem
102064>>>        Set pbControlBeginGroup to True
102065>>>    End_Object
102066>>>
102066>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
102068>>>    End_Object
102069>>>
102069>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
102071>>>    End_Object
102072>>>
102072>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
102074>>>    End_Object
102075>>>
102075>>>End_Object
102076>
102076>Object oMain is a Panel
102078>    Set Label to (psProduct(ghoApplication))
102079>    Set Location to 30 17
102080>    Set Size to 190 450
102081>    Set Icon to "SQLConnections1.ico"
102082>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
102083>
102083>    Object oCommandBarSystem is a cCJCommandBarSystem
102085>        Set pbTimerUpdate to True
102086>        Set pbShowTextBelowIcons to True
102087>            Set pbAutoResizeIcons to True
102088>        Set pbLargeIcons to True
102089>
102089>        Procedure OnCreateCommandBars
102092>            Handle hoOptions
102092>            Integer iSize
102092>
102092>            Send DoChangeToolTipFormat
102093>
102093>            Get OptionsObject to hoOptions
102094>            Move 32 to iSize
102095>            Send ComSetIconSize of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
102096>            Forward Send OnCreateCommandBars
102098>        End_Procedure
102099>
102099>        Procedure DoChangeToolTipFormat
102102>            Variant vToolTip
102102>            Handle  hoObject
102102>            Integer eTheme iToolTipStyle
102102>            Boolean bIsBalloonStyleSupported
102102>
102102>            Get ComToolTipContext to vTooltip
102103>            Get Create (RefClass(cCJToolTipContext)) to hoObject
102104>            Set pvComObject of hoObject to vTooltip
102105>            Move xtpToolTipStandard to iToolTipStyle
102106>            If (iToolTipStyle = -1) Begin
102108>                Get peVisualTheme to eTheme
102109>                Set ComStyle of hoObject to eTheme
102110>            End
102110>            Else Begin
102111>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
102111>                // The ComShowTitleAndDescription also requires IE 5.0.
102111>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
102112>                If (bIsBalloonStyleSupported = False) Begin
102114>                    // If not supported we cannot show baloon tooltip; use standard style instead.
102114>                    If (iToolTipStyle = xtpToolTipBalloon) Begin
102116>                        Move xtpToolTipStandard to iToolTipStyle
102117>                    End
102117>                End
102117>                Set ComStyle of hoObject to iToolTipStyle
102118>                If (bIsBalloonStyleSupported = True) Begin
102120>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
102121>                End
102121>            End
102121>            Set  ComShowOfficeBorder        of hoObject to True
102122>            Set  ComShowShadow              of hoObject to True
102123>            // Set the max width for a tooltip. 250 just seems to be a good
102123>            // compromise. After 250 pixels the text will wrap to the next line automatically.
102123>            Set  ComMaxTipWidth             of hoObject to 250 // In pixels
102124>            Send Destroy of hoObject
102125>            If (phoStatusBar(ghoCommandBars)) Begin
102127>                Send DoChangeToolTipFormat of (phoStatusBar(Self))
102128>            End
102128>
102128>        End_Procedure
102129>
102129>        Object oOpen_Toolbar is a cCJToolbar     
102131>
102131>            Object oOpen_MenuItem is a cCJMenuItem
102133>                Set psTooltip to "&Open"
102134>                Set psDescription to "Open connection ini-file (Ctrl+O)"
102135>                Set psImage to "ActionOpen1.ico"
102136>                Set pbActiveUpdate to True
102137>                Procedure OnExecute Variant vCommandBarControl
102140>                    Forward Send OnExecute vCommandBarControl
102142>                    Send ActivateOpenDialog of (phoMainView(ghoApplication))
102143>                End_Procedure
102144>            End_Object
102145>
102145>            Object oRefreshMenuItem is a cCJMenuItem
102147>                Set psTooltip to "&Refresh"
102148>                Set psDescription to "Refresh grid - re-read values from ini-file (Alt+R)"
102149>                Set psImage to "ActionRefresh1.ico"
102150>                Set pbActiveUpdate to True
102151>               
102151>                Procedure OnExecute Variant vCommandBarControl
102154>                    Forward Send OnExecute vCommandBarControl
102156>                    Send RefreshIniFile of (phoMainView(ghoApplication))
102157>                End_Procedure
102158>
102158>                Function IsEnabled Returns Boolean
102161>                    Boolean bSave
102161>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
102162>                    Function_Return (bSave = True)
102163>                End_Function
102164>                
102164>            End_Object
102165>
102165>        End_Object
102166>
102166>        Object oEdit_Toolbar is a cCJToolbar     
102168>        
102168>            Object oAddMenuItem is a cCJMenuItem
102170>                Set psTooltip to "&Add"
102171>                Set psDescription to "Add new connection (Alt+A)"
102172>                Set psImage to "ActionAdd1.ico"
102173>                Set pbActiveUpdate to True
102174>                Procedure OnExecute Variant vCommandBarControl
102177>                    Forward Send OnExecute vCommandBarControl
102179>                    Send AddItem of (phoMainView(ghoApplication))
102180>                End_Procedure
102181>            End_Object
102182>
102182>            Object oEditMenuItem is a cCJMenuItem
102184>                Set psTooltip to "&Edit"
102185>                Set psDescription to "Edit selected connection (Alt+E)"
102186>                Set psImage to "ActionEdit1.ico"
102187>                Set pbActiveUpdate to True
102188>
102188>                Procedure OnExecute Variant vCommandBarControl
102191>                    Forward Send OnExecute vCommandBarControl
102193>                    Send EditItem of (phoMainView(ghoApplication))
102194>                End_Procedure
102195>
102195>                Function IsEnabled Returns Boolean
102198>                    Handle ho              
102198>                    Boolean bRecord
102198>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
102199>                    Send ChangeHeaderText of ho
102200>                    Get HasRecord of ho to bRecord
102201>                    Function_Return (bRecord = True)
102202>                End_Function
102203>
102203>            End_Object
102204>
102204>            Object oSaveMenuItem is a cCJMenuItem
102206>                Set psTooltip to "Save"
102207>                Set psDescription to "Save changes (Ctrl+S)"
102208>                Set psImage to "ActionSave1.ico"
102209>                Set pbActiveUpdate to True
102210>                Set peControlType to xtpControlSplitButtonPopup
102211>
102211>                Procedure OnExecute Variant vCommandBarControl
102214>                    Forward Send OnExecute vCommandBarControl
102216>                    Send SaveIniFile of (phoMainView(ghoApplication))
102217>                End_Procedure
102218>
102218>                Function IsEnabled Returns Boolean
102221>                    Boolean bSave
102221>                    Get Should_Save of (oSQLConnections_grd(phoMainView(ghoApplication))) to bSave
102222>                    Function_Return (bSave = True)
102223>                End_Function
102224>
102224>                Object oSaveAsMenuItem is a cCJMenuItem
102226>                    Set psTooltip to "Save As"
102227>                    Set psDescription to "Save configuration file as..."  
102228>                    Set psImage to "ActionSaveAs1.ico"
102229>                    
102229>                    Procedure OnExecute Variant vCommandBarControl  
102232>                        String sPath sIniFileName sFileName
102232>
102232>                        Forward Send OnExecute vCommandBarControl
102234>                        
102234>                        Get psIniFilePath of ghoSQLConnectionHandler to sPath
102235>                        Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
102236>                        Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
102237>                        If (sFileName <> "") Begin
102239>                            Get ParseFolderName sFileName to sPath
102240>                            Get ParseFileName   sFileName to sIniFileName
102241>                            Set psIniFilePath of ghoSQLConnectionHandler to sPath
102242>                            Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
102243>                            Send SaveIniFile  of (phoMainView(ghoApplication))
102244>                        End
102244>                    End_Procedure
102245>
102245>                End_Object   
102246>                
102246>            End_Object
102247>
102247>            Object oClearMenuItem is a cCJMenuItem 
102249>                Set psTooltip to "Clear All"
102250>                Set psDescription to "Clear ini-file (Ctrl+F5)"
102251>                Set psImage to "ActionClear1.ico"
102252>                Set pbActiveUpdate to True
102253>                
102253>                Procedure OnExecute Variant vCommandBarControl
102256>                    Forward Send OnExecute vCommandBarControl   
102258>                    Send ClearIniFile of (phoMainView(ghoApplication))
102259>                End_Procedure   
102260>                
102260>                Function IsEnabled Returns Boolean
102263>                    Handle ho              
102263>                    Boolean bRecord
102263>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
102264>                    Send ChangeHeaderText of ho
102265>                    Get HasRecord of ho to bRecord
102266>                    Function_Return (bRecord = True)
102267>                End_Function
102268>
102268>            End_Object
102269>    
102269>            Object oDeleteMenuItem is a cCJMenuItem
102271>                Set psTooltip to "Delete"
102272>                Set psDescription to "Delete selected connection (Alt+D)"
102273>                Set psImage to "ActionDelete1.ico"
102274>                Set pbActiveUpdate to True
102275>
102275>                Procedure OnExecute Variant vCommandBarControl
102278>                    Forward Send OnExecute vCommandBarControl
102280>                    Send DeleteItem of (phoMainView(ghoApplication))
102281>                End_Procedure   
102282>                
102282>                Function IsEnabled Returns Boolean
102285>                    Handle ho              
102285>                    Boolean bRecord
102285>                    Move (oSQLConnections_grd(phoMainView(ghoApplication))) to ho
102286>                    Send ChangeHeaderText of ho
102287>                    Get HasRecord of ho to bRecord
102288>                    Function_Return (bRecord = True)
102289>                End_Function
102290>
102290>            End_Object
102291>
102291>        End_Object      
102292>        
102292>        Object oExit_Toolbar is a cCJToolbar
102294>            Set peStretched to stStretchShared
102295>
102295>            Object oAddToStudioMenuItem is a cCJMenuItem
102297>                Set psTooltip to "Add to Studio"
102298>                Set psDescription to "Add program to the Studio's toolbar menu"
102299>                Set psImage to "ActionAddStudio1.ico"
102300>                
102300>                Procedure OnExecute Variant vCommandBarControl
102303>                    Forward Send OnExecute vCommandBarControl
102305>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
102306>                End_Procedure
102307>            
102307>            End_Object
102308>
102308>            Object oAbout_MenuItem is a cCJMenuItem
102310>                Set psTooltip to C_$About
102311>                Set psDescription to "Info about the program..."
102312>                Set psImage to "ActionAbout1.ico"
102313>        
102313>                Procedure OnExecute Variant vCommandBarControl
102316>                    Send ChangeStatusRowText of (phoMainView(ghoApplication)) ""
102317>                    Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
102318>                End_Procedure
102319>        
102319>            End_Object     
102320>            
102320>            Object oHelpMenuItem is a cCJHelpMenuItem
102322>                Set peControlType to xtpControlSplitButtonPopup
102323>                Set psToolTip to C_$Help
102324>                Set psDescription to "Local HTML Help"
102325>                Set psImage to "ActionHelp1.ico"
102326>
102326>                Procedure OnExecute Variant vCommandBarControl
102329>                    Send ShowProgramHelp
102330>                End_Procedure
102331>
102331>                Object oHelpMenuItemLocal is a cCJMenuItem
102333>                    Set psToolTip to C_$Help
102334>                    Set psCaption to "Local HTML Help"
102335>                    Set psDescription to "Local HTML Help"
102336>                    Set psImage to "ActionHelp1.ico"
102337>                    Procedure OnExecute Variant vCommandBarControl
102340>                        Send ShowProgramHelp
102341>                    End_Procedure
102342>                End_Object
102343>
102343>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
102345>                    Set psToolTip to C_$Help
102346>                    Set psCaption to "Online HTML Help"
102347>                    Set psDescription to "Online HTML Help"
102348>                    Set psImage to "ActionHelpInternet1.ico"
102349>                    Procedure OnExecute Variant vCommandBarControl
102352>                        Runprogram Shell Background "https://www.rdctools.com/HTMLHelpDUF/DUFSQLConnectionsTool.html"
102353>                    End_Procedure
102354>                End_Object
102355>
102355>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
102357>                    Set psToolTip to "Updates"
102358>                    Set psCaption to "Check for Updates..."
102359>                    Set psDescription to "Check for Updates..."
102360>                    Set psImage to "InternetUpdate1.ico"
102361>                    Set pbControlBeginGroup to True
102362>                    
102362>                    Procedure OnExecute Variant vCommandBarControl
102365>                        String sPath sUpdateProgram sParam
102365>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
102366>                        Get vFolderFormat sPath to sPath
102367>                        Move "updater.exe" to sUpdateProgram
102368>                        Move "/checknow"   to sParam
102369>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
102370>                    End_Procedure
102371>                
102371>                End_Object
102372>                
102372>            End_Object
102373>
102373>            Object oExit_MenuItem is a cCJExitMenuItem
102375>                Set psToolTip to "Exit"
102376>                Set psDescription to "Exit application (Alt+F4)"   
102377>                Set psImage to "ActionExit1.ico"
102378>            End_Object
102379>
102379>        End_Object
102380>        
102380>        Object oStatusBar is a cCJStatusBar
102382>
102382>            Object oStatusPane1 is a cCJStatusBarPane
102384>                Set pbStyleStretch to True
102385>            End_Object
102386>
102386>            Object oStatusPane2 is a cCJStatusBarPane
102388>                Set phoViewPane to Self
102389>                Set pbStyleStretch to True
102390>                Set piTextColor to clRed
102391>            End_Object
102392>
102392>        End_Object
102393>
102393>    End_Object
102394>
102394>    Object oClientArea is a ClientArea
102396>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
102396>>>//************************************************************************
102396>>>// Confidential Trade Secret.
102396>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
102396>>>// as an unpublished work.  All rights reserved.
102396>>>// DataFlex is a registered trademark of Data Access Corporation.
102396>>>//
102396>>>//************************************************************************
102396>>>//************************************************************************
102396>>>//
102396>>>// $File name  : StdAbout.pkg
102396>>>// $File title : Standard about object package for VDF
102396>>>// Notice      :
102396>>>// $Author(s)  : John Tuohy
102396>>>//
102396>>>// $Rev History
102396>>>//
102396>>>// JT 06/27/97   File created
102396>>>//************************************************************************
102396>>>
102396>>>// This provides a quick and simple way to create an about package for a program.
102396>>>// You need to create a message inside you client area called Activate_About.
102396>>>// Within this message you should send the message DoAbout passing needed
102396>>>// string information.
102396>>>//
102396>>>//       Procedure Activate_About
102396>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
102396>>>//       End_Procedure
102396>>>//    where: sTitle =     Name of application. If none provided, uses caption
102396>>>//                        bar title
102396>>>//           sVersion   = Version Line. If none provided, will be blank
102396>>>//           sCopyRight = Copyright Line. If none provided, will be blank
102396>>>//           sAuthor    = Author name, blank if none provided
102396>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
102396>>>//                        is used.
102396>>>// It is expected that you will place this in your own object package. For
102396>>>// example an order about package may look like this:
102396>>>//
102396>>>//   // OrderAbout.pkg
102396>>>//   Use StdAbout.pkg
102396>>>//   Procedure Activate_About
102396>>>//      String sTitle sCopyright sVersion sAuthor
102396>>>//      Move "My Order Entry System" to sTitle
102396>>>//      Move "Version 2.1" to sVersion
102396>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
102396>>>//      Move "John Smith"  to sAuthor
102396>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
102396>>>//   end_procedure
102396>>>//   // end of file.
102396>>>
102396>>>Use DfAbout.pkg
102396>>>
102396>>>// *************************************************************************
102396>>>//  Public message. This is the default message. It is expected that you will
102396>>>//   create your own message to override this
102396>>>// *************************************************************************
102396>>>
102396>>>Procedure Activate_About
102399>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
102400>>>End_Procedure
102401>>>
102401>>>// *************************************************************************
102401>>>//  Public message. It is expected that you will send this message (most
102401>>>//  likely from Activate_About. This creates an about object, activates it
102401>>>//  and destroys it when done. It is not exepected that you will augment this.
102401>>>// *************************************************************************
102401>>>// Sample usage:
102401>>>//   The first two params will automatically be filled from the application settings if not provided.
102401>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
102401>>>
102401>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
102404>>>    Integer hoObj hoMain iArgs
102404>>>    String sValue
102404>>>
102404>>>    // Create object
102404>>>    Object About is an AboutDialog
102406>>>    // Uncomment these two lines if you would like to have a resizable About object.
102406>>>    //            Set Border_Style to Border_Thick
102406>>>    //            Set peAnchors to anAll
102406>>>
102406>>>    // Add checking for the number of arguments passed to avoid runtime errors
102406>>>    // if one of them is not passed. This makes the interface
102406>>>    // more flexible.
102406>>>        Move num_arguments to iArgs
102407>>>
102407>>>        // If no title is passed use the label of the main panel (if a main panel exists).
102407>>>        If (iArgs > 0 and sTitle = "") Begin
102409>>>            Get Main_Window of Desktop to hoMain
102410>>>            If hoMain Begin
102412>>>                Get Label of hoMain to sValue
102413>>>            End
102413>>>>
102413>>>        End
102413>>>>
102413>>>        Else If (iArgs > 0 and sTitle <> "") Begin
102416>>>            Move sTitle to sValue
102417>>>        End
102417>>>>
102417>>>        Else If (iArgs = 0) Begin
102420>>>            Get Main_Window of Desktop to hoMain
102421>>>            If hoMain Begin
102423>>>                Get Label of hoMain to sValue
102424>>>            End
102424>>>>
102424>>>        End
102424>>>>
102424>>>
102424>>>        If (sValue <> "") Begin
102426>>>            Send Add_LineLn sValue
102427>>>        End
102427>>>>
102427>>>        Move "" to sValue
102428>>>
102428>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
102428>>>        // For this to work the Project Properties Version must have been set in the Studio.
102428>>>        If (iArgs < 2) Begin
102430>>>            Move "" to sValue
102431>>>        End
102431>>>>
102431>>>        Else Begin
102432>>>            Move sVersion to sValue
102433>>>        End
102433>>>>
102433>>>        Set Version to sValue
102434>>>
102434>>>        If (iArgs > 2 and sCopyRight <> "") Begin
102436>>>            Send Add_LineLn sCopyRight
102437>>>        End
102437>>>>
102437>>>
102437>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
102437>>>        // else we do.
102437>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
102439>>>            Send Add_Line sAuthor
102440>>>        End
102440>>>>
102440>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
102443>>>            Send Add_LineLn sAuthor
102444>>>        End
102444>>>>
102444>>>
102444>>>        // Square bitmaps of 80x80 works best
102444>>>        If (iArgs > 4 and sBitmap <> "") Begin
102446>>>            Set Logo to sBitMap
102447>>>        End
102447>>>>
102447>>>
102447>>>        // Here starts handling of the five optional params:
102447>>>        If (iArgs = 6 and sParam6  <> "") Begin
102449>>>            Send Add_Line sParam6
102450>>>        End
102450>>>>
102450>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
102453>>>            Send Add_LineLn sParam6
102454>>>        End
102454>>>>
102454>>>
102454>>>        If (iArgs = 7 and sParam7  <> "") Begin
102456>>>            Send Add_Line sParam7
102457>>>        End
102457>>>>
102457>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
102460>>>            Send Add_LineLn sParam7
102461>>>        End
102461>>>>
102461>>>
102461>>>        If (iArgs = 8 and sParam8  <> "") Begin
102463>>>            Send Add_Line sParam8
102464>>>        End
102464>>>>
102464>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
102467>>>            Send Add_LineLn sParam8
102468>>>        End
102468>>>>
102468>>>
102468>>>        If (iArgs = 9 and sParam9  <> "") Begin
102470>>>            Send Add_Line sParam9
102471>>>        End
102471>>>>
102471>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
102474>>>            Send Add_LineLn sParam9
102475>>>        End
102475>>>>
102475>>>
102475>>>        If (iArgs = 10 and sParam10 <> "") Begin
102477>>>            Send Add_Line sParam10
102478>>>        End
102478>>>>
102478>>>
102478>>>        Move Self to hoObj
102479>>>    End_Object
102480>>>
102480>>>    Send Popup   of hoObj // Popup the about object
102481>>>    Send Destroy of hoObj // When done, it will be destroyed
102482>>>End_Procedure
102483>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
102483>>>Use DFClient.pkg
102483>>>Use cCJCommandBarSystem.pkg
102483>>>Use cCJGrid.pkg
102483>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJGridColumnRowIndicator.pkg)
102483>>>>>Use cCJGridColumn.pkg
102483>>>>>
102483>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
102484>>>>>    
102484>>>>>    Procedure Construct_Object
102486>>>>>        Forward Send Construct_Object
102488>>>>>        
102488>>>>>        Property Integer piImage 0
102489>>>>>        
102489>>>>>        Set psCaption to ""
102490>>>>>        Set piWidth to 20
102491>>>>>        Set pbResizable to False
102492>>>>>        Set pbEditable to False
102493>>>>>        Set pbFocusable to False
102494>>>>>        Set pbAllowDrag to False
102495>>>>>        Set psToolTip to "Row Indicator"
102496>>>>>    End_Procedure
102497>>>>>    
102497>>>>>    Procedure OnCreateColumn
102499>>>>>        Integer iImage
102499>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
102501>>>>>        Set piImage to iImage
102502>>>>>    End_Procedure
102503>>>>>    
102503>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
102505>>>>>        Integer iImage iFocusedRow
102505>>>>>        Handle hoDataSource
102505>>>>>        
102505>>>>>        Get phoDataSource to hoDataSource
102506>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
102507>>>>>        Move -1 to iImage
102508>>>>>        If (iRow = iFocusedRow) Begin
102510>>>>>            Get piImage to iImage
102511>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
102512>>>>>        End
102512>>>>>>
102512>>>>>    End_Procedure
102513>>>>>    
102513>>>>>End_Class
102514>>>Use cCJGridColumn.pkg
102514>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
102514>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
102514>>>>>>>//****************************************************************************
102514>>>>>>>// $Module type: Package
102514>>>>>>>// $Module name: cRDCButtonDPI.pkg
102514>>>>>>>//
102514>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
102514>>>>>>>// Copyright (c) 2013 RDC Tools International
102514>>>>>>>// E-mail      : support@rdctools.com
102514>>>>>>>// Web-site    : http://www.rdctools.com
102514>>>>>>>//
102514>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
102514>>>>>>>//
102514>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
102514>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
102514>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
102514>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
102514>>>>>>>// in the help folder for more details.
102514>>>>>>>//
102514>>>>>>>//****************************************************************************
102514>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
102514>>>>>>>>>//****************************************************************************
102514>>>>>>>>>// $Module type: Package
102514>>>>>>>>>// $Module name: cRDCButton.pkg
102514>>>>>>>>>//
102514>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
102514>>>>>>>>>// Copyright (c) 2013 RDC Tools International
102514>>>>>>>>>// E-mail      : support@rdctools.com
102514>>>>>>>>>// Web-site    : http://www.rdctools.com
102514>>>>>>>>>//
102514>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
102514>>>>>>>>>//
102514>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
102514>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
102514>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
102514>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
102514>>>>>>>>>// in the help folder for more details.
102514>>>>>>>>>//
102514>>>>>>>>>//****************************************************************************
102514>>>>>>>>>Use Windows.pkg
102514>>>>>>>>>Use Enclient.pkg
102514>>>>>>>>>Use errornum.inc
102514>>>>>>>>>
102514>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
102515>>>>>>>>>    Procedure Construct_Object
102517>>>>>>>>>        Forward Send Construct_Object
102519>>>>>>>>>
102519>>>>>>>>>    End_Procedure
102520>>>>>>>>>
102520>>>>>>>>>    Procedure OnIdle
102522>>>>>>>>>        Delegate Send DoUpdate
102524>>>>>>>>>    End_Procedure
102525>>>>>>>>>
102525>>>>>>>>>End_Class
102526>>>>>>>>>
102526>>>>>>>>>Class cRDCButton is a Button
102527>>>>>>>>>
102527>>>>>>>>>    Procedure Construct_Object
102529>>>>>>>>>        Forward Send Construct_Object
102531>>>>>>>>>
102531>>>>>>>>>        Property Boolean pbAutoEnable False
102532>>>>>>>>>
102532>>>>>>>>>        Property Boolean pbEnabled True
102533>>>>>>>>>
102533>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
102534>>>>>>>>>
102534>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
102535>>>>>>>>>    End_Procedure
102536>>>>>>>>>
102536>>>>>>>>>    Procedure CancelIfPopupObject
102538>>>>>>>>>        Boolean bIsInPopupObject
102538>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
102540>>>>>>>>>        If (bIsInPopupObject = True) Begin
102542>>>>>>>>>            Send Close_Panel
102543>>>>>>>>>        End
102543>>>>>>>>>>
102543>>>>>>>>>    End_Procedure
102544>>>>>>>>>
102544>>>>>>>>>    Procedure End_Construct_Object
102546>>>>>>>>>        String sTooltip sStatus_Help
102546>>>>>>>>>
102546>>>>>>>>>        Forward Send End_Construct_Object
102548>>>>>>>>>
102548>>>>>>>>>        Get psToolTip   to sTooltip
102549>>>>>>>>>        Get Status_Help to sStatus_Help
102550>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
102552>>>>>>>>>            Set psToolTip to sStatus_Help
102553>>>>>>>>>        End
102553>>>>>>>>>>
102553>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
102555>>>>>>>>>            Set Status_Help to sToolTip
102556>>>>>>>>>        End
102556>>>>>>>>>>
102556>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
102557>>>>>>>>>    End_Procedure
102558>>>>>>>>>
102558>>>>>>>>>    Procedure DoUpdate
102560>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
102562>>>>>>>>>            Procedure_Return
102563>>>>>>>>>        End
102563>>>>>>>>>>
102563>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
102564>>>>>>>>>    End_Procedure
102565>>>>>>>>>
102565>>>>>>>>>    Function IsEnabled Returns Boolean
102567>>>>>>>>>        Boolean bEnabled
102567>>>>>>>>>        Get pbEnabled to bEnabled
102568>>>>>>>>>        Function_Return bEnabled
102569>>>>>>>>>    End_Function
102570>>>>>>>>>
102570>>>>>>>>>    // Enable the idle handler timer when the button is activated
102570>>>>>>>>>    Procedure Activating
102572>>>>>>>>>        Forward Send Activating
102574>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
102575>>>>>>>>>    End_Procedure
102576>>>>>>>>>
102576>>>>>>>>>    // Disable the idle handler when the button is deactivated
102576>>>>>>>>>    Procedure Deactivating
102578>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
102579>>>>>>>>>        Forward Send Deactivating
102581>>>>>>>>>    End_Procedure
102582>>>>>>>>>
102582>>>>>>>>>End_Class
102583>>>>>>>
102583>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
102583>>>>>>>Class cRDCButtonDPI is a cRDCButton
102584>>>>>>>    Procedure Construct_Object
102586>>>>>>>        Integer iIconSize
102586>>>>>>>        Forward Send Construct_Object
102588>>>>>>>        Set piImageMarginLeft to 10
102589>>>>>>>    End_Procedure
102590>>>>>>>
102590>>>>>>>    // Returns: DPI setting as an integer.
102590>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
102590>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
102590>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
102590>>>>>>>    Function GetCurrentDPI Returns Integer
102592>>>>>>>        Handle hDC
102592>>>>>>>        Integer iPixelsX
102592>>>>>>>        Move (GetDC(0)) to hDC
102593>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
102594>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
102595>>>>>>>        Function_Return iPixelsX
102596>>>>>>>    End_Function
102597>>>>>>>
102597>>>>>>>    Function GetCorrectIconSize Returns Integer
102599>>>>>>>        Integer iPixelsX iIndex iSize
102599>>>>>>>        Integer[] iaSizes
102600>>>>>>>
102600>>>>>>>        Move 16 to iaSizes[0]
102601>>>>>>>        Move 24 to iaSizes[1]
102602>>>>>>>        Move 32 to iaSizes[2]
102603>>>>>>>        Move 48 to iaSizes[3]
102604>>>>>>>        Move 64 to iaSizes[4]
102605>>>>>>>
102605>>>>>>>        Get piImageSize to iSize  // the "100%" size
102606>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
102607>>>>>>>        Move (0 max iIndex) to iIndex
102608>>>>>>>        Get GetCurrentDPI to iPixelsX
102609>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
102609>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
102609>>>>>>>        // will increment iIndex as many times as we need here.
102609>>>>>>>        Case Begin
102609>>>>>>>            Case (iPixelsX > 144)
102611>>>>>>>                Increment iIndex
102612>>>>>>>            Case (iPixelsX = 144)
102615>>>>>>>                Increment iIndex
102616>>>>>>>            Case (iPixelsX = 120)
102619>>>>>>>                Increment iIndex
102620>>>>>>>        Case End
102620>>>>>>>        Move (iIndex min 4) to iIndex
102621>>>>>>>        Function_Return iaSizes[iIndex]
102622>>>>>>>    End_Function
102623>>>>>>>
102623>>>>>>>    Procedure Set psToolTip String sToolTip
102625>>>>>>>        String sStatusHelp
102625>>>>>>>
102625>>>>>>>        Get Status_Help to sStatusHelp
102626>>>>>>>        If (sStatusHelp = "") Begin
102628>>>>>>>            Set Status_Help to sToolTip
102629>>>>>>>        End
102629>>>>>>>>
102629>>>>>>>
102629>>>>>>>        Forward Set psToolTip to sToolTip
102631>>>>>>>    End_Procedure
102632>>>>>>>
102632>>>>>>>End_Class
102633>>>>>
102633>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
102633>>>>>Class cSQLConnectionButton is a cRDCButtonDPI
102634>>>>>    Procedure Construct_Object
102636>>>>>        Forward Send Construct_Object
102638>>>>>    End_Procedure
102639>>>>>
102639>>>>>    Procedure End_Construct_Object
102641>>>>>        String sLabel sImage
102641>>>>>        Forward Send End_Construct_Object
102643>>>>>        Get psImage to sImage
102644>>>>>        If (sImage = "") Begin
102646>>>>>            Get Label to sLabel
102647>>>>>            Move (Replace("&", sLabel, "")) to sLabel
102648>>>>>            Move (Replace("...", sLabel, "")) to sLabel
102649>>>>>            Set psImage to ("Action" + sLabel + "1.ico")
102650>>>>>        End
102650>>>>>>
102650>>>>>    End_Procedure
102651>>>>>
102651>>>>>    Function Status_Help String Item# Returns String
102653>>>>>        String sRetval
102653>>>>>        Get IniFileName to sRetval
102654>>>>>        Function_Return sRetval
102655>>>>>    End_Function
102656>>>>>
102656>>>>>End_Class
102657>>>
102657>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
102657>>>>>Use Windows.pkg
102657>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJGridPromptList.pkg)
102657>>>>>>>Use Windows.pkg
102657>>>>>>>Use cCJGrid.pkg
102657>>>>>>>
102657>>>>>>>
102657>>>>>>>
102657>>>>>>>Class cCJGridPromptList is a cCJGrid
102658>>>>>>>    
102658>>>>>>>    Procedure Construct_Object
102660>>>>>>>        Forward Send Construct_Object
102662>>>>>>>        
102662>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
102663>>>>>>>        Property Boolean Private_pbAutoOrdering True
102664>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
102665>>>>>>>        Property Integer peUpdateMode umPromptValue
102666>>>>>>>        Property Integer piUpdateColumn 0
102667>>>>>>>        Property Integer piInitialColumn -1
102668>>>>>>>        Property String  psSeedValue ''
102669>>>>>>>        Property Handle phmPromptUpdateCallback 0
102670>>>>>>>        Property Integer phoInvokingObject
102671>>>>>>>        
102671>>>>>>>        Property Boolean pbStoredAutoSeed
102672>>>>>>>        Property Boolean pbStoredAutoOrdering
102673>>>>>>>        Property Boolean pbStoredAutoSearch
102674>>>>>>>        Property Integer peStoredUpdateMode
102675>>>>>>>        Property Integer piStoredUpdateColumn
102676>>>>>>>        Property Integer piStoredInitialColumn
102677>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
102678>>>>>>>        Property Boolean pbStoredSelectionEnable
102679>>>>>>>        Property Boolean pbStoredMultipleSelection
102680>>>>>>>        
102680>>>>>>>        // internally set by list
102680>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
102680>>>>>>>        Property Boolean pbCanceled
102681>>>>>>>        Property Integer[] pSelectedRows
102682>>>>>>>        
102682>>>>>>>        Property Boolean pbNeedsNewOrdering
102683>>>>>>>        Property Boolean pbRequestSearch
102684>>>>>>>        Property tGridKeyPair[] pSearchKeys
102685>>>>>>>        
102685>>>>>>>        // these properties makes a prompt list a prompt list
102685>>>>>>>        // and should not be changed.
102685>>>>>>>        Set pbEditOnKeyNavigation to False
102686>>>>>>>        Set pbEditOnClick to False
102687>>>>>>>        Set pbReadOnly to True
102688>>>>>>>        Set pbFocusSubItems to True
102689>>>>>>>        
102689>>>>>>>        // these could maybe be changed
102689>>>>>>>        Set pbShadeSortColumn to True
102690>>>>>>>        Set pbHeaderReorders to True
102691>>>>>>>        Set pbHeaderTogglesDirection to True
102692>>>>>>>        Set pbHeaderSelectsColumn to True
102693>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
102694>>>>>>>        Set piFocusCellBackColor to clNone
102695>>>>>>>        Set piFocusCellForeColor to clNone
102696>>>>>>>        Set piFocusCellRectangleColor to clBlack
102697>>>>>>>        Set pbUseFocusCellRectangle to False
102698>>>>>>>        Set pbSelectionEnable to True
102699>>>>>>>        
102699>>>>>>>        On_Key kEnter Send Ok
102700>>>>>>>        On_Key kCancel Send Cancel
102701>>>>>>>        
102701>>>>>>>    End_Procedure
102702>>>>>>>    
102702>>>>>>>    // reorder list automatically on column change
102702>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
102702>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
102704>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
102705>>>>>>>        Set pbFocusSubItems to bAutoOrder
102706>>>>>>>    End_Procedure
102707>>>>>>>    
102707>>>>>>>    Function pbAutoOrdering Returns Boolean
102709>>>>>>>        Boolean bAutoOrder
102709>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
102710>>>>>>>        Function_Return bAutoOrder
102711>>>>>>>    End_Function
102712>>>>>>>    
102712>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
102712>>>>>>>    Procedure OnIdle
102714>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
102714>>>>>>>        Handle hoCol
102714>>>>>>>        Integer iKy1 iKy2 iCol
102714>>>>>>>        
102714>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
102715>>>>>>>        If bNeedsReorder Begin
102717>>>>>>>            Get SelectedColumn to iCol
102718>>>>>>>            If (iCol<>-1) Begin
102720>>>>>>>                
102720>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
102721>>>>>>>                Set pbHeaderTogglesDirection to False
102722>>>>>>>                Send HeaderReorder iCol
102723>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
102724>>>>>>>                
102724>>>>>>>                Set pbNeedsNewOrdering to False
102725>>>>>>>            End
102725>>>>>>>>
102725>>>>>>>        End
102725>>>>>>>>
102725>>>>>>>        
102725>>>>>>>        Get pbRequestSearch to bSearch
102726>>>>>>>        If bSearch Begin
102728>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
102729>>>>>>>        End
102729>>>>>>>>
102729>>>>>>>        
102729>>>>>>>        Forward Send OnIdle
102731>>>>>>>    End_Procedure
102732>>>>>>>    
102732>>>>>>>    Procedure OnStoreDefaults
102734>>>>>>>        Integer iVal
102734>>>>>>>        Boolean bVal
102734>>>>>>>        
102734>>>>>>>        Get pbAutoSeed to bVal
102735>>>>>>>        Set pbStoredAutoSeed to bVal
102736>>>>>>>        
102736>>>>>>>        Get pbAutoOrdering to bVal
102737>>>>>>>        Set pbStoredAutoOrdering to bVal
102738>>>>>>>        
102738>>>>>>>        Get pbAutoSearch to bVal
102739>>>>>>>        Set pbStoredAutoSearch to bVal
102740>>>>>>>        
102740>>>>>>>        Get peUpdateMode to iVal
102741>>>>>>>        Set peStoredUpdateMode to iVal
102742>>>>>>>        
102742>>>>>>>        Get piUpdateColumn to iVal
102743>>>>>>>        Set piStoredUpdateColumn to iVal
102744>>>>>>>        
102744>>>>>>>        Get piInitialColumn to iVal
102745>>>>>>>        Set piStoredInitialColumn to iVal
102746>>>>>>>        
102746>>>>>>>        Get phmPromptUpdateCallback to iVal
102747>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
102748>>>>>>>        
102748>>>>>>>        Get pbSelectionEnable to bVal
102749>>>>>>>        Set pbStoredSelectionEnable to bVal
102750>>>>>>>        
102750>>>>>>>        Get pbMultipleSelection to bVal
102751>>>>>>>        Set pbStoredMultipleSelection to bVal
102752>>>>>>>        
102752>>>>>>>    End_Procedure
102753>>>>>>>    
102753>>>>>>>    Procedure OnRestoreDefaults
102755>>>>>>>        Integer iVal
102755>>>>>>>        Boolean bVal
102755>>>>>>>        
102755>>>>>>>        Get pbStoredAutoSeed to bVal
102756>>>>>>>        Set pbAutoSeed to bVal
102757>>>>>>>        
102757>>>>>>>        Get pbStoredAutoOrdering to bVal
102758>>>>>>>        Set pbAutoOrdering to bVal
102759>>>>>>>        
102759>>>>>>>        Get pbStoredAutoSearch to bVal
102760>>>>>>>        Set pbAutoSearch to bVal
102761>>>>>>>        
102761>>>>>>>        Get peStoredUpdateMode to iVal
102762>>>>>>>        Set peUpdateMode to iVal
102763>>>>>>>        
102763>>>>>>>        Get piStoredInitialColumn to iVal
102764>>>>>>>        Set piInitialColumn to iVal
102765>>>>>>>        
102765>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
102766>>>>>>>        Set phmPromptUpdateCallback to iVal
102767>>>>>>>        
102767>>>>>>>        Get pbStoredSelectionEnable to bVal
102768>>>>>>>        Set pbSelectionEnable to bVal
102769>>>>>>>        
102769>>>>>>>        Get pbStoredMultipleSelection to bVal
102770>>>>>>>        Set pbMultipleSelection to bVal
102771>>>>>>>        
102771>>>>>>>    End_Procedure
102772>>>>>>>    
102772>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
102772>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
102772>>>>>>>    // Suitable for augmentation
102772>>>>>>>    Procedure OnSeedData
102774>>>>>>>        Integer iUpdateColumn iSortColumn
102774>>>>>>>        Boolean bSeed bAuto
102774>>>>>>>        String sValue
102774>>>>>>>        Handle hoCol
102774>>>>>>>        
102774>>>>>>>        Get piUpdateColumn to iUpdateColumn
102775>>>>>>>        Get psSeedValue to sValue
102776>>>>>>>        Get pbAutoSeed to bSeed
102777>>>>>>>        Get piSortColumn to iSortColumn
102778>>>>>>>        Get pbAutoOrdering to bAuto
102779>>>>>>>        // if not yet sorted and this is auto ordering we will
102779>>>>>>>        // sort the data for the search column. We do this to make the
102779>>>>>>>        // column search GE logic work properly.
102779>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
102781>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
102782>>>>>>>            Send SortGridByColumn hoCol False
102783>>>>>>>        End
102783>>>>>>>>
102783>>>>>>>        
102783>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
102785>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
102786>>>>>>>        End
102786>>>>>>>>
102786>>>>>>>        Else Begin
102787>>>>>>>            Send MovetoFirstRow
102788>>>>>>>        End
102788>>>>>>>>
102788>>>>>>>        
102788>>>>>>>    End_Procedure
102789>>>>>>>    
102789>>>>>>>    Procedure OnMoveValueOutByValue
102791>>>>>>>        String sValue
102791>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
102791>>>>>>>        Integer iRow iCol
102791>>>>>>>        Integer[] SelRowsIndexes
102792>>>>>>>        
102792>>>>>>>        Get phoInvokingObject to hoInvokingObject
102793>>>>>>>        Get pSelectedRows to SelRowsIndexes
102794>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
102796>>>>>>>            Get piUpdateColumn to iCol
102797>>>>>>>            Get ColumnObject iCol to hoCol
102798>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
102799>>>>>>>            Set Value of hoInvokingObject to sValue
102800>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
102801>>>>>>>        End
102801>>>>>>>>
102801>>>>>>>    End_Procedure
102802>>>>>>>    
102802>>>>>>>    Procedure OnMoveValueOutByCustom
102804>>>>>>>    End_Procedure
102805>>>>>>>    
102805>>>>>>>    // augment to popup a search window when allowed
102805>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
102807>>>>>>>        Boolean bSubFocus bAutoSearch bChar
102807>>>>>>>        Integer iVal
102807>>>>>>>        
102807>>>>>>>        Get pbFocusSubItems to bSubFocus
102808>>>>>>>        Get pbAutoSearch to bAutoSearch
102809>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
102811>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
102813>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
102815>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
102816>>>>>>>                Move (iVal<>0) to bChar
102817>>>>>>>            End
102817>>>>>>>>
102817>>>>>>>            If bChar Begin
102819>>>>>>>                // this can get called multiple times before a search dialog pops up
102819>>>>>>>                Send AddToSearchKeys llKeyCode llShift
102820>>>>>>>            End
102820>>>>>>>>
102820>>>>>>>        End
102820>>>>>>>>
102820>>>>>>>    End_Procedure
102821>>>>>>>    
102821>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
102823>>>>>>>        Boolean bAutoSearch
102823>>>>>>>        Integer iKeyCode iShiftCode
102823>>>>>>>        Get pbAutoSearch to bAutoSearch
102824>>>>>>>        If bAutoSearch Begin
102826>>>>>>>            // this can get called multiple times before a search dialog pops up
102826>>>>>>>            Get piLastKey to iKeyCode
102827>>>>>>>            Get piLastKey2 to iShiftCode
102828>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
102829>>>>>>>        End
102829>>>>>>>>
102829>>>>>>>        Move True to llCancel
102830>>>>>>>    End_Procedure
102831>>>>>>>    
102831>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
102833>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
102834>>>>>>>        Forward Send OnComRowDblClick llRow llItem
102836>>>>>>>    End_Procedure
102837>>>>>>>    
102837>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
102839>>>>>>>        Send Ok
102840>>>>>>>    End_Procedure
102841>>>>>>>    
102841>>>>>>>    
102841>>>>>>>    // we don't want a menu for prompt lists
102841>>>>>>>    Function CreateContextMenu Returns Handle
102843>>>>>>>        Function_Return 0
102844>>>>>>>    End_Function
102845>>>>>>>    
102845>>>>>>>    // if we use auto-ordering, change the order when the column changes
102845>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
102847>>>>>>>        Boolean bAutoOrder
102847>>>>>>>        Forward Send ColumnChanged iOld iNew
102849>>>>>>>        Get pbAutoOrdering to bAutoOrder
102850>>>>>>>        If bAutoOrder Begin
102852>>>>>>>            // will be reordered in idle event
102852>>>>>>>            Set pbNeedsNewOrdering to True
102853>>>>>>>        End
102853>>>>>>>>
102853>>>>>>>    End_Procedure
102854>>>>>>>    
102854>>>>>>>    
102854>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
102856>>>>>>>        Integer eMode
102856>>>>>>>        Integer[] SelRowsIndexes
102857>>>>>>>        Set pbCanceled to True // assume cancel unless changed
102858>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
102859>>>>>>>        Get peUpdateMode to eMode
102860>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
102862>>>>>>>            Send OnStoreDefaults
102863>>>>>>>        End
102863>>>>>>>>
102863>>>>>>>        Send InitializePromptList
102864>>>>>>>        Forward Send Add_Focus hoParent
102866>>>>>>>        Send LoadData
102867>>>>>>>        Set psSeedValue to ""
102868>>>>>>>    End_Procedure
102869>>>>>>>    
102869>>>>>>>    // called before the list is activated.
102869>>>>>>>    Procedure InitializePromptList
102871>>>>>>>        Integer hoInvokingObject
102871>>>>>>>        Boolean bAutoColumn bAutoSeed
102871>>>>>>>        Integer i iOldMode eUpdateMode
102871>>>>>>>        String sValue
102871>>>>>>>        
102871>>>>>>>        Get peUpdateMode to eUpdateMode
102872>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
102874>>>>>>>            Get Focus of Desktop to hoInvokingObject
102875>>>>>>>            If (hoInvokingObject<=Desktop) Begin
102877>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
102878>>>>>>>>
102878>>>>>>>                Procedure_Return
102879>>>>>>>            End
102879>>>>>>>>
102879>>>>>>>            
102879>>>>>>>            Set phoInvokingObject to hoInvokingObject
102880>>>>>>>            
102880>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
102881>>>>>>>            Get peUpdateMode to eUpdateMode
102882>>>>>>>        End
102882>>>>>>>>
102882>>>>>>>        
102882>>>>>>>        Send ClearSearchRequest // clear the search keys
102883>>>>>>>        Set pbNeedsNewOrdering to False
102884>>>>>>>        
102884>>>>>>>        Get pbAutoSeed to bAutoSeed
102885>>>>>>>        
102885>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
102887>>>>>>>            Get Value of hoInvokingObject to sValue
102888>>>>>>>            Set psSeedValue to sValue
102889>>>>>>>        End
102889>>>>>>>>
102889>>>>>>>        
102889>>>>>>>    End_Procedure
102890>>>>>>>    
102890>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
102890>>>>>>>    Procedure LoadData
102892>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
102892>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
102892>>>>>>>        Integer eUpdateMode
102892>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
102892>>>>>>>        
102892>>>>>>>        Get phoDataSource to hoDataSource
102893>>>>>>>        Get peUpdateMode to eUpdateMode
102894>>>>>>>        Get phoInvokingObject to hoInvokingObject
102895>>>>>>>        Get pbAutoSeed to bAutoSeed
102896>>>>>>>        Get piInitialColumn to iInitialColumn
102897>>>>>>>        Get piUpdateColumn to iUpdateColumn
102898>>>>>>>        Get RowCount of hoDataSource to iRows
102899>>>>>>>        
102899>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
102899>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
102899>>>>>>>        If (iInitialColumn=-1) Begin
102901>>>>>>>            Move iUpdateColumn to iInitialColumn
102902>>>>>>>        End
102902>>>>>>>>
102902>>>>>>>        If (iInitialColumn>=0) Begin
102904>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
102905>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
102906>>>>>>>        End
102906>>>>>>>>
102906>>>>>>>        Send OnSeedData // find a good starting place for the row
102907>>>>>>>        Get pbFocusSubItems to bSubFocus
102908>>>>>>>        If bSubFocus Begin
102910>>>>>>>            // if column focus, which is normal, go to initialcolumn
102910>>>>>>>            If hoInitialColumn Begin
102912>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
102913>>>>>>>            End
102913>>>>>>>>
102913>>>>>>>            Else Begin
102914>>>>>>>                Send MoveToFirstEnterableColumn
102915>>>>>>>            End
102915>>>>>>>>
102915>>>>>>>        End
102915>>>>>>>>
102915>>>>>>>        
102915>>>>>>>    End_Procedure
102916>>>>>>>    
102916>>>>>>>    // This is only called in a successful close
102916>>>>>>>    Procedure ClosePromptList
102918>>>>>>>        Handle hoDataSource hoInvokingObject
102918>>>>>>>        Handle hmCallBack
102918>>>>>>>        Integer iRow eUpdateMode
102918>>>>>>>        Integer[] SelRowsIndexes
102919>>>>>>>        
102919>>>>>>>        Get phoDataSource to hoDataSource
102920>>>>>>>        Get phoInvokingObject to hoInvokingObject
102921>>>>>>>        
102921>>>>>>>        If (pbMultipleSelection(Self)) Begin
102923>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
102924>>>>>>>        End
102924>>>>>>>>
102924>>>>>>>        Else Begin
102925>>>>>>>            Get SelectedRow of hoDataSource to iRow
102926>>>>>>>            If (iRow<>-1) Begin
102928>>>>>>>                Move iRow to SelRowsIndexes[0]
102929>>>>>>>            End
102929>>>>>>>>
102929>>>>>>>        End
102929>>>>>>>>
102929>>>>>>>        
102929>>>>>>>        Set pbCanceled to False
102930>>>>>>>        Set pSelectedRows to SelRowsIndexes
102931>>>>>>>        
102931>>>>>>>        Get peUpdateMode to eUpdateMode
102932>>>>>>>        // if non-invoking there is by definition, no move value out
102932>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
102934>>>>>>>            
102934>>>>>>>            If (eUpdateMode=umPromptValue) Begin
102936>>>>>>>                Send OnMoveValueOutByValue
102937>>>>>>>            End
102937>>>>>>>>
102937>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
102940>>>>>>>                Send OnMoveValueOutByCustom
102941>>>>>>>            End
102941>>>>>>>>
102941>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
102942>>>>>>>            If hmCallBack Begin
102944>>>>>>>                Send hmCallBack of hoInvokingObject Self
102945>>>>>>>            End
102945>>>>>>>>
102945>>>>>>>        End
102945>>>>>>>>
102945>>>>>>>        
102945>>>>>>>        Send Close_Panel
102946>>>>>>>    End_Procedure
102947>>>>>>>    
102947>>>>>>>    // augment to send OnRestoreDefaults.
102947>>>>>>>    Procedure Release_Focus
102949>>>>>>>        Integer eUpdateMode
102949>>>>>>>        Get peUpdateMode to eUpdateMode
102950>>>>>>>        Forward Send Release_Focus
102952>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
102954>>>>>>>            Send OnRestoreDefaults
102955>>>>>>>        End
102955>>>>>>>>
102955>>>>>>>    End_Procedure
102956>>>>>>>    
102956>>>>>>>    Function SelectedRowIds Returns RowID[]
102958>>>>>>>        RowID[] SelectedRowids
102959>>>>>>>        Integer[] SelectedRows
102960>>>>>>>        Integer i iRows
102960>>>>>>>        Handle hoDataSource
102960>>>>>>>        Get phoDataSource to hoDataSource
102961>>>>>>>        Get pSelectedRows to SelectedRows
102962>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
102963>>>>>>>        For i from 0 to (iRows-1)
102969>>>>>>>>
102969>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
102970>>>>>>>        Loop
102971>>>>>>>>
102971>>>>>>>        Function_Return SelectedRowids
102972>>>>>>>    End_Function
102973>>>>>>>    
102973>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
102975>>>>>>>        String[] SelectedValues
102976>>>>>>>        Integer[] SelectedRows
102977>>>>>>>        Integer i iRows
102977>>>>>>>        Handle hoCol
102977>>>>>>>        Get ColumnObject iCol to hoCol
102978>>>>>>>        Get pSelectedRows to SelectedRows
102979>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
102980>>>>>>>        For i from 0 to (iRows-1)
102986>>>>>>>>
102986>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
102987>>>>>>>        Loop
102988>>>>>>>>
102988>>>>>>>        Function_Return SelectedValues
102989>>>>>>>    End_Function
102990>>>>>>>    
102990>>>>>>>    Procedure Ok Returns Integer
102992>>>>>>>        Send ClosePromptList
102993>>>>>>>    End_Procedure
102994>>>>>>>    
102994>>>>>>>    Procedure Cancel Returns Integer
102996>>>>>>>        Send Close_Panel
102997>>>>>>>    End_Procedure
102998>>>>>>>    
102998>>>>>>>    Procedure Search
103000>>>>>>>        Send Activate // give focus back to list so focus things are correct
103001>>>>>>>        Send Request_Search 0 0
103002>>>>>>>    End_Procedure
103003>>>>>>>    
103003>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
103003>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
103003>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
103003>>>>>>>    Procedure Request_SearchEx
103005>>>>>>>        tGridKeyPair[] Keys
103005>>>>>>>        tGridKeyPair[] Keys
103006>>>>>>>        Integer iCol
103006>>>>>>>        Handle hoCol hoSearchDialog
103006>>>>>>>        Boolean bOk
103006>>>>>>>        String sValue
103006>>>>>>>        
103006>>>>>>>        Get piSortColumn to iCol
103007>>>>>>>        If (iCol<>-1) Begin
103009>>>>>>>            Get ColumnObject iCol to hoCol
103010>>>>>>>            Get pSearchKeys to Keys
103011>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
103012>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
103013>>>>>>>            If bOk Begin
103015>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
103016>>>>>>>            End
103016>>>>>>>>
103016>>>>>>>            Send Destroy of hoSearchDialog
103017>>>>>>>        End
103017>>>>>>>>
103017>>>>>>>        Send ClearSearchRequest // clear the search keys
103018>>>>>>>    End_Procedure
103019>>>>>>>    
103019>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
103019>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
103021>>>>>>>        tGridKeyPair[] Keys
103021>>>>>>>        tGridKeyPair[] Keys
103022>>>>>>>        tGridKeyPair KeyPair
103022>>>>>>>        tGridKeyPair KeyPair
103022>>>>>>>        Set pbRequestSearch to True
103023>>>>>>>        Move iKeyCode to KeyPair.KeyCode
103024>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
103025>>>>>>>        Get pSearchKeys to Keys
103026>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
103027>>>>>>>        Set pSearchKeys to Keys
103028>>>>>>>    End_Procedure
103029>>>>>>>    
103029>>>>>>>    Procedure ClearSearchRequest
103031>>>>>>>        tGridKeyPair[] SearchKeys
103031>>>>>>>        tGridKeyPair[] SearchKeys
103032>>>>>>>        Set pSearchKeys to SearchKeys
103033>>>>>>>        Set pbRequestSearch to False
103034>>>>>>>    End_Procedure
103035>>>>>>>    
103035>>>>>>>End_Class
103036>>>>>>>
103036>>>>>Use cDbUpdateFunctionLibrary.pkg
103036>>>>>Use MSSqldrv.pkg
103036>>>>>Use db2_drv.pkg
103036>>>>>Use odbc_drv.pkg
103036>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
103036>>>>>>>//****************************************************************************
103036>>>>>>>// $Module type: Class
103036>>>>>>>// $Module name: cRDCModalPanel
103036>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
103036>>>>>>>// Created     : 2014-03-17 @ 12:33
103036>>>>>>>//
103036>>>>>>>// Description :
103036>>>>>>>//
103036>>>>>>>// $Rev History:
103036>>>>>>>//    2014-03-17  Module header created
103036>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
103036>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
103036>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
103036>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
103036>>>>>>>// in the help folder for more details.
103036>>>>>>>//
103036>>>>>>>//****************************************************************************
103036>>>>>>>Use Windows.pkg
103036>>>>>>>Use cCJCommandBarSystem.pkg   
103036>>>>>>>Use cCJSkinFramework.pkg
103036>>>>>>>
103036>>>>>>>Class cRDCModalPanel is a ModalPanel
103037>>>>>>>
103037>>>>>>>    Procedure Construct_Object
103039>>>>>>>        Forward Send Construct_Object
103041>>>>>>>
103041>>>>>>>        Set Maximize_Icon to True
103042>>>>>>>        Set Minimize_Icon to False
103043>>>>>>>        Set Border_Style to Border_Thick
103044>>>>>>>        Set Locate_Mode to Center_On_Parent
103045>>>>>>>
103045>>>>>>>        Property String Private_Icon
103046>>>>>>>        Property Handle phoDialogCommandbar
103047>>>>>>>    End_Procedure
103048>>>>>>>
103048>>>>>>>    Procedure Set Icon String sIcon
103050>>>>>>>        Forward Set Icon to sIcon
103052>>>>>>>        Set Private_Icon to sIcon
103053>>>>>>>    End_Procedure
103054>>>>>>>
103054>>>>>>>    Function Icon Returns String
103056>>>>>>>        String sIcon
103056>>>>>>>        Get Private_Icon to sIcon
103057>>>>>>>        Function_Return sIcon
103058>>>>>>>    End_Function
103059>>>>>>>
103059>>>>>>>    Procedure Page Integer iPageObject
103061>>>>>>>        String sIcon
103061>>>>>>>        Integer hWnd
103061>>>>>>>        
103061>>>>>>>        Forward Send Page iPageObject
103063>>>>>>>        Get Private_Icon to sIcon
103064>>>>>>>        If (sIcon <> "") Begin
103066>>>>>>>            Set Icon to sIcon
103067>>>>>>>        End
103067>>>>>>>>
103067>>>>>>>
103067>>>>>>>        Get Window_Handle to hWnd
103068>>>>>>>
103068>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
103070>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
103071>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
103072>>>>>>>        End
103072>>>>>>>>
103072>>>>>>>    End_Procedure
103073>>>>>>>
103073>>>>>>>    // Put a status bar at the bottom of the panel, which makes
103073>>>>>>>    // status_help work and puts a gripper in the lower right corner.
103073>>>>>>>    Procedure End_Construct_Object
103075>>>>>>>        Integer iStyle iSize iOffset
103075>>>>>>>
103075>>>>>>>        Forward Send End_Construct_Object
103077>>>>>>>
103077>>>>>>>        Get Border_Style to iStyle
103078>>>>>>>        Move 8 to iOffset
103079>>>>>>>        If (iStyle = Border_Thick) Begin
103081>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
103083>>>>>>>                Object oStatusBar is a cCJStatusBar
103085>>>>>>>                    Set phoDialogCommandbar to Self
103086>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
103088>>>>>>>                        Set piId to sbpIDIdlePane
103089>>>>>>>                        Set pbStyleStretch to True
103090>>>>>>>                    End_Object
103091>>>>>>>                End_Object
103092>>>>>>>            End_Object
103093>>>>>>>            Get Size to iSize
103094>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
103095>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
103096>>>>>>>        End
103096>>>>>>>>
103096>>>>>>>
103096>>>>>>>    End_Procedure
103097>>>>>>>
103097>>>>>>>    Procedure Popup
103099>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
103100>>>>>>>        Forward Send Popup
103102>>>>>>>    End_Procedure
103103>>>>>>>
103103>>>>>>>End_Class
103104>>>>>
103104>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
103106>>>>>    Set Label to "SQL Database Selection"
103107>>>>>    Set Size to 119 183
103108>>>>>    Set piMinSize to 89 170
103109>>>>>    Set Location to 2 2
103110>>>>>    Set Border_Style to Border_Thick
103111>>>>>    Set Icon to "DatabaseLookup1.ico"
103112>>>>>
103112>>>>>    Property String[] psTheData
103114>>>>>
103114>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
103116>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
103118>>>>>        End_Object
103119>>>>>    End
103119>>>>>>
103119>>>>>
103119>>>>>    Object oSelList is a cCJGridPromptList
103121>>>>>        Set Size to 89 167
103122>>>>>        Set Location to 6 6
103123>>>>>        Set peAnchors to anAll
103124>>>>>        Set pbAllowColumnRemove to False
103125>>>>>        Set pbUseAlternateRowBackgroundColor to True
103126>>>>>        Set pbGrayIfDisable to False
103127>>>>>        Set pbHeaderReorders to False
103128>>>>>        Set pbHeaderSelectsColumn to False
103129>>>>>        Set pbHeaderTogglesDirection to False
103130>>>>>        Set pbShadeSortColumn to False
103131>>>>>        Set piFocusCellBackColor to clDkGray
103132>>>>>
103132>>>>>        Object oName is a cCJGridColumn
103134>>>>>            Set piWidth to 334
103135>>>>>            Set psCaption to "Database Name"
103136>>>>>        End_Object
103137>>>>>
103137>>>>>        Procedure Activating
103140>>>>>            tDataSourceRow[] MyData
103140>>>>>            tDataSourceRow[] MyData
103141>>>>>            Handle hoDataSource
103141>>>>>            String[] sTheData
103142>>>>>            Integer iCount iSize
103142>>>>>
103142>>>>>            Send Cursor_Wait of Cursor_Control
103143>>>>>            Forward Send Activating
103145>>>>>
103145>>>>>            Get psTheData to sTheData
103146>>>>>            Move (SizeOfArray(sTheData)) to iSize
103147>>>>>            Decrement iSize
103148>>>>>            For iCount from 0 to iSize
103154>>>>>>
103154>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
103155>>>>>            Loop
103156>>>>>>
103156>>>>>
103156>>>>>            Get phoDataSource to hoDataSource
103157>>>>>            Send InitializeData of hoDataSource MyData
103158>>>>>            Send Cursor_Ready of Cursor_Control
103159>>>>>        End_Procedure
103160>>>>>
103160>>>>>    End_Object
103161>>>>>
103161>>>>>    Object oOK_Btn is a Button
103163>>>>>        Set Size to 14 50
103164>>>>>        Set Label    to "&OK"
103165>>>>>        Set Location to 98 68
103166>>>>>        Set peAnchors To anBottomRight
103167>>>>>
103167>>>>>        Procedure OnClick
103170>>>>>            Send Ok of oSelList
103171>>>>>        End_Procedure
103172>>>>>
103172>>>>>    End_Object
103173>>>>>
103173>>>>>    Object oCancel_Btn is a Button
103175>>>>>        Set Size to 14 50
103176>>>>>        Set Label    to "&Cancel"
103177>>>>>        Set Location to 98 123
103178>>>>>        Set peAnchors to anBottomRight
103179>>>>>
103179>>>>>        Procedure OnClick
103182>>>>>            Send Close_Panel
103183>>>>>        End_Procedure
103184>>>>>
103184>>>>>    End_Object
103185>>>>>
103185>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103186>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103187>>>>>End_Object
103188>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
103188>>>>>Use Windows.pkg
103188>>>>>Use cCJGridPromptList.pkg
103188>>>>>Use MSSqldrv.pkg
103188>>>>>Use db2_drv.pkg
103188>>>>>Use odbc_drv.pkg    
103188>>>>>Use cRDCModalPanel.pkg
103188>>>>>Use cDbUpdateFunctionLibrary.pkg
103188>>>>>
103188>>>>>Object oServerSelection_sl is a cRDCModalPanel
103190>>>>>    Set Size to 105 225
103191>>>>>    Set Label to "Database Server/DSN Selection"
103192>>>>>    Set piMinSize to 89 211
103193>>>>>    Set Location to 2 2
103194>>>>>    Set Icon to "ServerLookup1.ico"
103195>>>>>
103195>>>>>    Property String[] psTheData
103197>>>>>
103197>>>>>    Object oSelList is a cCJGridPromptList
103199>>>>>        Set Size to 72 215
103200>>>>>        Set Location to 6 6
103201>>>>>        Set peAnchors to anAll
103202>>>>>        Set pbAllowColumnRemove to False
103203>>>>>        Set pbUseAlternateRowBackgroundColor to True
103204>>>>>        Set pbGrayIfDisable to False
103205>>>>>        Set pbHeaderReorders to False
103206>>>>>        Set pbHeaderSelectsColumn to False
103207>>>>>        Set pbHeaderTogglesDirection to False
103208>>>>>        Set pbShadeSortColumn to False
103209>>>>>        Set piFocusCellBackColor to clDkGray
103210>>>>>
103210>>>>>        Object oName is a cCJGridColumn
103212>>>>>            Set piWidth to 358
103213>>>>>            Set psCaption to "Name"
103214>>>>>        End_Object
103215>>>>>
103215>>>>>        Procedure Activating
103218>>>>>            tDataSourceRow[] MyData
103218>>>>>            tDataSourceRow[] MyData
103219>>>>>            Handle hoDataSource
103219>>>>>            String[] sTheData
103220>>>>>            Integer iCount iSize
103220>>>>>
103220>>>>>            Send Cursor_Wait of Cursor_Control
103221>>>>>            Get psTheData to sTheData
103222>>>>>            Move (SizeOfArray(sTheData)) to iSize
103223>>>>>            Decrement iSize
103224>>>>>            For iCount from 0 to iSize
103230>>>>>>
103230>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
103231>>>>>            Loop
103232>>>>>>
103232>>>>>
103232>>>>>            Forward Send Activating
103234>>>>>
103234>>>>>            Get phoDataSource to hoDataSource
103235>>>>>            Send InitializeData of hoDataSource MyData
103236>>>>>            Send Cursor_Ready of Cursor_Control
103237>>>>>        End_Procedure
103238>>>>>
103238>>>>>    End_Object
103239>>>>>
103239>>>>>    Object oOK_Btn is a Button
103241>>>>>        Set Size to 14 50
103242>>>>>        Set Label    to "&OK"
103243>>>>>        Set Location to 85 116
103244>>>>>        Set peAnchors To anBottomRight
103245>>>>>
103245>>>>>        Procedure OnClick
103248>>>>>            Send Ok of oSelList
103249>>>>>        End_Procedure
103250>>>>>
103250>>>>>    End_Object
103251>>>>>
103251>>>>>    Object oCancel_Btn is a Button
103253>>>>>        Set Size to 14 50
103254>>>>>        Set Label    to "&Cancel"
103255>>>>>        Set Location to 85 171
103256>>>>>        Set peAnchors to anBottomRight
103257>>>>>
103257>>>>>        Procedure OnClick
103260>>>>>            Send Close_Panel
103261>>>>>        End_Procedure
103262>>>>>
103262>>>>>    End_Object
103263>>>>>
103263>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103264>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103265>>>>>End_Object
103266>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
103266>>>>>Use Windows.pkg
103266>>>>>Use Cursor.pkg
103266>>>>>Use cCJCommandBarSystem.pkg
103266>>>>>Use cRDCButtonDPI.pkg
103266>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
103266>>>>>>>Use Windows.pkg
103266>>>>>>>
103266>>>>>>>// Used by the "Page" message below to show
103266>>>>>>>// a rectangle around ComboForm and Checkbox objects.
103266>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
103266>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
103266>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
103266>>>>>>>    Define UIS_SET          for 1
103266>>>>>>>    Define UIS_CLEAR        for 2
103266>>>>>>>    Define UIS_INITIALIZE   for 3
103266>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
103266>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
103266>>>>>>>    Define UISF_ACTIVE      for |CI$4
103266>>>>>>>
103266>>>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
103266>>>>>>>Class cSQLCheckBox is a CheckBox
103267>>>>>>>    Procedure Construct_Object
103269>>>>>>>        Forward Send Construct_Object
103271>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
103271>>>>>>>        Property Integer piItem
103272>>>>>>>    End_Procedure
103273>>>>>>>
103273>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
103275>>>>>>>    End_Procedure
103276>>>>>>>
103276>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
103278>>>>>>>        Integer iItem
103278>>>>>>>        Get piItem to iItem
103279>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
103280>>>>>>>    End_Procedure
103281>>>>>>>
103281>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
103283>>>>>>>        Boolean bState
103283>>>>>>>        Integer iItem
103283>>>>>>>        Get piItem to iItem
103284>>>>>>>        Get Checked_State to bState
103285>>>>>>>        Move bState to sConnectionData[iItem]
103286>>>>>>>    End_Procedure
103287>>>>>>>
103287>>>>>>>    Procedure Set psToolTip String sToolTip
103289>>>>>>>        String sStatusHelp
103289>>>>>>>
103289>>>>>>>        Get Status_Help to sStatusHelp
103290>>>>>>>        If (sStatusHelp = "") Begin
103292>>>>>>>            Set Status_Help to sToolTip
103293>>>>>>>        End
103293>>>>>>>>
103293>>>>>>>
103293>>>>>>>        Forward Set psToolTip to sToolTip
103295>>>>>>>    End_Procedure
103296>>>>>>>
103296>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
103296>>>>>>>    // The bug being that the focus rectangle doesn't show.
103296>>>>>>>    Procedure Page Integer iPageObject
103298>>>>>>>        Handle hWnd
103298>>>>>>>        Integer iRet iState
103298>>>>>>>
103298>>>>>>>        Forward Send Page iPageObject
103300>>>>>>>
103300>>>>>>>        If (iPageObject) Begin
103302>>>>>>>            Get Window_Handle to hWnd
103303>>>>>>>            If (hWnd) Begin
103305>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
103306>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
103308>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
103309>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
103310>>>>>>>                End
103310>>>>>>>>
103310>>>>>>>            End
103310>>>>>>>>
103310>>>>>>>        End
103310>>>>>>>>
103310>>>>>>>    End_Procedure
103311>>>>>>>
103311>>>>>>>End_Class
103312>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
103312>>>>>>>Use Windows.pkg
103312>>>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
103312>>>>>>>>>//****************************************************************************
103312>>>>>>>>>// $Module type: Package
103312>>>>>>>>>// $Module name: cRDCComboform.pkg
103312>>>>>>>>>//
103312>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
103312>>>>>>>>>// Copyright (c) 2014 RDC Tools International
103312>>>>>>>>>// E-mail      : support@rdctools.com
103312>>>>>>>>>// Web-site    : http://www.rdctools.com
103312>>>>>>>>>//
103312>>>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
103312>>>>>>>>>//
103312>>>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
103312>>>>>>>>>//               The auto-size combo width logic was developed by Raveen.
103312>>>>>>>>>//
103312>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
103312>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
103312>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
103312>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
103312>>>>>>>>>// in the help folder for more details.
103312>>>>>>>>>//
103312>>>>>>>>>//****************************************************************************
103312>>>>>>>>>Use Windows.pkg
103312>>>>>>>>>
103312>>>>>>>>>// Used by the "Page" message below to show
103312>>>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
103312>>>>>>>>>
103312>>>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
103313>>>>>>>>>    Procedure Construct_Object
103315>>>>>>>>>        Forward Send Construct_Object
103317>>>>>>>>>
103317>>>>>>>>>    End_Procedure
103318>>>>>>>>>
103318>>>>>>>>>    Procedure OnIdle
103320>>>>>>>>>        Delegate Send DoUpdate
103322>>>>>>>>>    End_Procedure
103323>>>>>>>>>
103323>>>>>>>>>End_Class
103324>>>>>>>>>
103324>>>>>>>>>Class cRDCComboForm is a ComboForm
103325>>>>>>>>>    Procedure Construct_Object
103327>>>>>>>>>        Forward Send Construct_Object
103329>>>>>>>>>
103329>>>>>>>>>        Property Boolean pbAutoListWidth True
103330>>>>>>>>>
103330>>>>>>>>>        Property Boolean pbAutoShadowLabelObject True
103331>>>>>>>>>
103331>>>>>>>>>        Property Boolean pbAutoEnable False
103332>>>>>>>>>        Set Label_Col_Offset to 2
103333>>>>>>>>>        Property Boolean pbEnabled True
103334>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
103335>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
103336>>>>>>>>>
103336>>>>>>>>>    End_Procedure
103337>>>>>>>>>
103337>>>>>>>>>    Procedure End_Construct_Object
103339>>>>>>>>>        Boolean bAutoShadowLabelObject
103339>>>>>>>>>        String sTooltip sStatus_Help
103339>>>>>>>>>
103339>>>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
103340>>>>>>>>>        If (bAutoShadowLabelObject = True) Begin
103342>>>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
103343>>>>>>>>>        End
103343>>>>>>>>>>
103343>>>>>>>>>
103343>>>>>>>>>        Forward Send End_Construct_Object
103345>>>>>>>>>
103345>>>>>>>>>        Get psToolTip   to sTooltip
103346>>>>>>>>>        Get Status_Help to sStatus_Help
103347>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
103349>>>>>>>>>            Set psToolTip to sStatus_Help
103350>>>>>>>>>        End
103350>>>>>>>>>>
103350>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
103353>>>>>>>>>            Set Status_Help to sTooltip
103354>>>>>>>>>        End
103354>>>>>>>>>>
103354>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
103355>>>>>>>>>
103355>>>>>>>>>    End_Procedure
103356>>>>>>>>>
103356>>>>>>>>>    Procedure DoUpdate
103358>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
103360>>>>>>>>>            Procedure_Return
103361>>>>>>>>>        End
103361>>>>>>>>>>
103361>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
103362>>>>>>>>>    End_Procedure
103363>>>>>>>>>
103363>>>>>>>>>    Function IsEnabled Returns Boolean
103365>>>>>>>>>        Boolean bEnabled
103365>>>>>>>>>        Get pbEnabled to bEnabled
103366>>>>>>>>>        Function_Return bEnabled
103367>>>>>>>>>    End_Function
103368>>>>>>>>>
103368>>>>>>>>>    // Enable the idle handler timer when the object is activated
103368>>>>>>>>>    Procedure Activating
103370>>>>>>>>>        Forward Send Activating
103372>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
103373>>>>>>>>>    End_Procedure
103374>>>>>>>>>
103374>>>>>>>>>    // Disable the idle handler when the object is deactivated
103374>>>>>>>>>    Procedure Deactivating
103376>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
103377>>>>>>>>>        Forward Send Deactivating
103379>>>>>>>>>    End_Procedure
103380>>>>>>>>>
103380>>>>>>>>>    // To "un-select" the text in the comboform on startup
103380>>>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
103382>>>>>>>>>        Integer iStart iEnd
103382>>>>>>>>>
103382>>>>>>>>>        If (Focus(Desktop)=Self) Begin
103384>>>>>>>>>            Get SelStart to iStart
103385>>>>>>>>>            Get SelEnd   to iEnd
103386>>>>>>>>>        End
103386>>>>>>>>>>
103386>>>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
103388>>>>>>>>>        Send SetSel iStart iEnd
103389>>>>>>>>>    End_Procedure
103390>>>>>>>>>
103390>>>>>>>>>    // Message that will drop down the list without the user clicking it,
103390>>>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
103390>>>>>>>>>    Procedure DropDownList
103392>>>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
103393>>>>>>>>>    End_Procedure
103394>>>>>>>>>
103394>>>>>>>>>    Procedure SizeComboWidth
103396>>>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
103396>>>>>>>>>        String sVal
103396>>>>>>>>>
103396>>>>>>>>>        // Initialise Width
103396>>>>>>>>>        Set ListWidth to 0
103397>>>>>>>>>        Send DoSetListWidth
103398>>>>>>>>>
103398>>>>>>>>>        Get ListRowCount     to iRows
103399>>>>>>>>>        Get Combo_Item_Count to iCount
103400>>>>>>>>>
103400>>>>>>>>>        // Vertical scroll-bar adjustment is needed
103400>>>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
103401>>>>>>>>>        If (iVertAdj) Begin
103403>>>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
103404>>>>>>>>>        End
103404>>>>>>>>>>
103404>>>>>>>>>        Else Begin
103405>>>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
103406>>>>>>>>>        End
103406>>>>>>>>>>
103406>>>>>>>>>
103406>>>>>>>>>        // Calculate New Width
103406>>>>>>>>>        Decrement iCount
103407>>>>>>>>>        For iItem from 0 to iCount
103413>>>>>>>>>>
103413>>>>>>>>>            Get Combo_Value iItem to sVal
103414>>>>>>>>>            If (sVal <> "") Begin
103416>>>>>>>>>                Get Text_Extent sVal to iTextExt
103417>>>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
103418>>>>>>>>>                If (iWd > iNewWd) Begin
103420>>>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
103421>>>>>>>>>                End
103421>>>>>>>>>>
103421>>>>>>>>>            End
103421>>>>>>>>>>
103421>>>>>>>>>        Loop
103422>>>>>>>>>>
103422>>>>>>>>>
103422>>>>>>>>>        // Set New Width
103422>>>>>>>>>        Set ListWidth to iNewWd
103423>>>>>>>>>        Send DoSetListWidth
103424>>>>>>>>>    End_Procedure
103425>>>>>>>>>
103425>>>>>>>>>    Procedure Combo_Add_Item String sValue
103427>>>>>>>>>        Forward Send Combo_Add_Item sValue
103429>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
103431>>>>>>>>>            Send SizeComboWidth
103432>>>>>>>>>        End
103432>>>>>>>>>>
103432>>>>>>>>>    End_Procedure
103433>>>>>>>>>
103433>>>>>>>>>    Procedure Combo_Fill_List
103435>>>>>>>>>        Forward Send Combo_Fill_List
103437>>>>>>>>>        If (pbAutoListWidth(Self)) Begin
103439>>>>>>>>>            Send SizeComboWidth
103440>>>>>>>>>        End
103440>>>>>>>>>>
103440>>>>>>>>>    End_Procedure
103441>>>>>>>>>
103441>>>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
103441>>>>>>>>>    // The bug being that the focus rectangle doesn't show.
103441>>>>>>>>>    Procedure Page Integer iPageObject
103443>>>>>>>>>        Handle hWnd
103443>>>>>>>>>        Integer iRet iState
103443>>>>>>>>>
103443>>>>>>>>>        Forward Send Page iPageObject
103445>>>>>>>>>
103445>>>>>>>>>        If (iPageObject) Begin
103447>>>>>>>>>            Get Window_Handle to hWnd
103448>>>>>>>>>            If (hWnd) Begin
103450>>>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
103451>>>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
103453>>>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
103454>>>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
103455>>>>>>>>>                End
103455>>>>>>>>>>
103455>>>>>>>>>            End
103455>>>>>>>>>>
103455>>>>>>>>>        End
103455>>>>>>>>>>
103455>>>>>>>>>
103455>>>>>>>>>        // To "un-select" the text in the comboform
103455>>>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
103457>>>>>>>>>            Send SetSel 0 0
103458>>>>>>>>>        End
103458>>>>>>>>>>
103458>>>>>>>>>    End_Procedure
103459>>>>>>>>>
103459>>>>>>>>>End_Class
103460>>>>>>>
103460>>>>>>>// Used by the "Page" message below to show
103460>>>>>>>// a rectangle around ComboForm and Checkbox objects.
103460>>>>>>>//#IFNDEF WM_CHANGEUISTATE
103460>>>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
103460>>>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
103460>>>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
103460>>>>>>>//    Define UIS_SET          for 1
103460>>>>>>>//    Define UIS_CLEAR        for 2
103460>>>>>>>//    Define UIS_INITIALIZE   for 3
103460>>>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
103460>>>>>>>//    Define UISF_HIDEACCEL   for |CI$2
103460>>>>>>>//    Define UISF_ACTIVE      for |CI$4
103460>>>>>>>//#ENDIF
103460>>>>>>>
103460>>>>>>>Class cSQLComboForm is a cRDCComboForm
103461>>>>>>>    Procedure Construct_Object
103463>>>>>>>        Forward Send Construct_Object
103465>>>>>>>
103465>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
103465>>>>>>>//        Property Boolean pbAutoShadowLabelObject True
103465>>>>>>>
103465>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
103465>>>>>>>        Property Integer piItem
103466>>>>>>>
103466>>>>>>>//        Set Label_Col_Offset to 2
103466>>>>>>>//        Set Label_Justification_Mode to JMode_Right
103466>>>>>>>    End_Procedure
103467>>>>>>>
103467>>>>>>>    Procedure End_Construct_Object
103469>>>>>>>//        Boolean bAutoShadowLabelObject
103469>>>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
103469>>>>>>>//        If (bAutoShadowLabelObject = True) Begin
103469>>>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
103469>>>>>>>//        End
103469>>>>>>>        Forward Send End_Construct_Object
103471>>>>>>>    End_Procedure
103472>>>>>>>
103472>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
103474>>>>>>>    End_Procedure
103475>>>>>>>
103475>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
103477>>>>>>>        Integer iItem
103477>>>>>>>        Get piItem to iItem
103478>>>>>>>        Set Value to sConnectionData[iItem]
103479>>>>>>>    End_Procedure
103480>>>>>>>
103480>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
103482>>>>>>>        String sValue
103482>>>>>>>        Integer iItem
103482>>>>>>>        Get piItem to iItem
103483>>>>>>>        Get Value to sValue
103484>>>>>>>        Move sValue to sConnectionData[iItem]
103485>>>>>>>    End_Procedure
103486>>>>>>>
103486>>>>>>>//    Procedure Set psToolTip String sToolTip
103486>>>>>>>//        String sStatusHelp
103486>>>>>>>//
103486>>>>>>>//        Get Status_Help to sStatusHelp
103486>>>>>>>//        If (sStatusHelp = "") Begin
103486>>>>>>>//            Set Status_Help to sToolTip
103486>>>>>>>//        End
103486>>>>>>>//
103486>>>>>>>//        Forward Set psToolTip to sToolTip
103486>>>>>>>//    End_Procedure
103486>>>>>>>//
103486>>>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
103486>>>>>>>//    // The bug being that the focus rectangle doesn't show.
103486>>>>>>>//    Procedure Page Integer iPageObject
103486>>>>>>>//        Handle hWnd
103486>>>>>>>//        Integer iRet iState
103486>>>>>>>//
103486>>>>>>>//        Forward Send Page iPageObject
103486>>>>>>>//
103486>>>>>>>//        If (iPageObject) Begin
103486>>>>>>>//            Get Window_Handle to hWnd
103486>>>>>>>//            If (hWnd) Begin
103486>>>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
103486>>>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
103486>>>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
103486>>>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
103486>>>>>>>//                End
103486>>>>>>>//            End
103486>>>>>>>//        End
103486>>>>>>>//    End_Procedure
103486>>>>>>>
103486>>>>>>>End_Class
103487>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
103487>>>>>>>Use Windows.pkg
103487>>>>>>>
103487>>>>>>>Class cSQLForm is a Form
103488>>>>>>>    Procedure Construct_Object
103490>>>>>>>        Forward Send Construct_Object
103492>>>>>>>
103492>>>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
103492>>>>>>>        Property Boolean pbAutoShadowLabelObject True
103493>>>>>>>
103493>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
103493>>>>>>>        Property Integer piItem
103494>>>>>>>
103494>>>>>>>        Set Label_Justification_Mode to JMode_Right
103495>>>>>>>        Set Label_Col_Offset to 2
103496>>>>>>>    End_Procedure
103497>>>>>>>
103497>>>>>>>    Procedure End_Construct_Object
103499>>>>>>>        Boolean bAutoShadowLabelObject
103499>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
103500>>>>>>>        If (bAutoShadowLabelObject = True) Begin
103502>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
103503>>>>>>>        End
103503>>>>>>>>
103503>>>>>>>        Forward Send End_Construct_Object
103505>>>>>>>    End_Procedure
103506>>>>>>>
103506>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
103508>>>>>>>    End_Procedure
103509>>>>>>>
103509>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
103511>>>>>>>        Integer iItem
103511>>>>>>>        Get piItem to iItem
103512>>>>>>>        Set Value to sConnectionData[iItem]
103513>>>>>>>    End_Procedure
103514>>>>>>>
103514>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
103516>>>>>>>        String sValue
103516>>>>>>>        Integer iItem
103516>>>>>>>        Get piItem to iItem
103517>>>>>>>        Get Value to sValue
103518>>>>>>>        Move sValue to sConnectionData[iItem]
103519>>>>>>>    End_Procedure
103520>>>>>>>
103520>>>>>>>    Procedure Set psToolTip String sToolTip
103522>>>>>>>        String sStatusHelp
103522>>>>>>>
103522>>>>>>>        Get Status_Help to sStatusHelp
103523>>>>>>>        If (sStatusHelp = "") Begin
103525>>>>>>>            Set Status_Help to sToolTip
103526>>>>>>>        End
103526>>>>>>>>
103526>>>>>>>
103526>>>>>>>        Forward Set psToolTip to sToolTip
103528>>>>>>>    End_Procedure
103529>>>>>>>
103529>>>>>>>End_Class
103530>>>>>Use cSQLConnectionHandler.pkg
103530>>>>>Use cDbUpdateFunctionLibrary.pkg
103530>>>>>Use cDbUpdateDatabaseDriver.pkg
103530>>>>>Use DatabaseSelection.dg
103530>>>>>Use ServerSelection.dg
103530>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
103530>>>>>>>Use Windows.pkg
103530>>>>>>>Use cCJGridPromptList.pkg     
103530>>>>>>>Use cRDCModalPanel.pkg
103530>>>>>>>Use cDbUpdateFunctionLibrary.pkg
103530>>>>>>>
103530>>>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
103532>>>>>>>    Set Size to 118 177
103533>>>>>>>    Set Label to "SQL Tablespace Selection"
103534>>>>>>>    Set piMinSize to 89 177
103535>>>>>>>    Set Location to 2 2
103536>>>>>>>    Set Icon to "DatabaseLookup1.ico"
103537>>>>>>>
103537>>>>>>>    Property String[] psTheData
103539>>>>>>>
103539>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
103541>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
103543>>>>>>>        End_Object
103544>>>>>>>    End
103544>>>>>>>>
103544>>>>>>>
103544>>>>>>>    Object oSelList is a cCJGridPromptList
103546>>>>>>>        Set Size to 89 167
103547>>>>>>>        Set Location to 6 6
103548>>>>>>>        Set peAnchors to anAll
103549>>>>>>>        Set pbAllowColumnRemove to False
103550>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
103551>>>>>>>        Set pbGrayIfDisable to False
103552>>>>>>>        Set pbHeaderReorders to False
103553>>>>>>>        Set pbHeaderSelectsColumn to False
103554>>>>>>>        Set pbHeaderTogglesDirection to False
103555>>>>>>>        Set pbShadeSortColumn to False
103556>>>>>>>        Set piFocusCellBackColor to clDkGray
103557>>>>>>>
103557>>>>>>>        Object oName is a cCJGridColumn
103559>>>>>>>            Set piWidth to 334
103560>>>>>>>            Set psCaption to "Table Space Name"
103561>>>>>>>        End_Object
103562>>>>>>>
103562>>>>>>>        Procedure Activating
103565>>>>>>>            tDataSourceRow[] MyData
103565>>>>>>>            tDataSourceRow[] MyData
103566>>>>>>>            Handle hoDataSource
103566>>>>>>>            String[] sTheData
103567>>>>>>>            Integer iCount iSize
103567>>>>>>>
103567>>>>>>>            Send Cursor_Wait of Cursor_Control
103568>>>>>>>            Forward Send Activating
103570>>>>>>>
103570>>>>>>>            Get psTheData to sTheData
103571>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
103572>>>>>>>            Decrement iSize
103573>>>>>>>            For iCount from 0 to iSize
103579>>>>>>>>
103579>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
103580>>>>>>>            Loop
103581>>>>>>>>
103581>>>>>>>
103581>>>>>>>            Get phoDataSource to hoDataSource
103582>>>>>>>            Send InitializeData of hoDataSource MyData
103583>>>>>>>            Send Cursor_Ready of Cursor_Control
103584>>>>>>>        End_Procedure
103585>>>>>>>
103585>>>>>>>    End_Object
103586>>>>>>>
103586>>>>>>>    Object oOK_Btn is a Button
103588>>>>>>>        Set Size to 14 50
103589>>>>>>>        Set Label    to "&OK"
103590>>>>>>>        Set Location to 98 68
103591>>>>>>>        Set peAnchors To anBottomRight
103592>>>>>>>
103592>>>>>>>        Procedure OnClick
103595>>>>>>>            Send Ok of oSelList
103596>>>>>>>        End_Procedure
103597>>>>>>>
103597>>>>>>>    End_Object
103598>>>>>>>
103598>>>>>>>    Object oCancel_Btn is a Button
103600>>>>>>>        Set Size to 14 50
103601>>>>>>>        Set Label    to "&Cancel"
103602>>>>>>>        Set Location to 98 123
103603>>>>>>>        Set peAnchors to anBottomRight
103604>>>>>>>
103604>>>>>>>        Procedure OnClick
103607>>>>>>>            Send Close_Panel
103608>>>>>>>        End_Procedure
103609>>>>>>>
103609>>>>>>>    End_Object
103610>>>>>>>
103610>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103611>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103612>>>>>>>End_Object
103613>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
103613>>>>>>>Use Windows.pkg
103613>>>>>>>Use cCJGridPromptList.pkg  
103613>>>>>>>Use cRDCModalPanel.pkg
103613>>>>>>>Use cDbUpdateFunctionLibrary.pkg
103613>>>>>>>
103613>>>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
103615>>>>>>>    Set Size to 118 177
103616>>>>>>>    Set Label to "SQL Schemas Selection"
103617>>>>>>>    Set piMinSize to 89 177
103618>>>>>>>    Set Location to 2 2
103619>>>>>>>    Set Icon to "DatabaseLookup1.ico"
103620>>>>>>>
103620>>>>>>>    Property String[] psTheData
103622>>>>>>>
103622>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
103624>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
103626>>>>>>>        End_Object
103627>>>>>>>    End
103627>>>>>>>>
103627>>>>>>>
103627>>>>>>>    Object oSelList is a cCJGridPromptList
103629>>>>>>>        Set Size to 89 167
103630>>>>>>>        Set Location to 6 6
103631>>>>>>>        Set peAnchors to anAll
103632>>>>>>>        Set pbAllowColumnRemove to False
103633>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
103634>>>>>>>        Set pbGrayIfDisable to False
103635>>>>>>>        Set pbHeaderReorders to False
103636>>>>>>>        Set pbHeaderSelectsColumn to False
103637>>>>>>>        Set pbHeaderTogglesDirection to False
103638>>>>>>>        Set pbShadeSortColumn to False
103639>>>>>>>        Set piFocusCellBackColor to clDkGray
103640>>>>>>>
103640>>>>>>>        Object oName is a cCJGridColumn
103642>>>>>>>            Set piWidth to 334
103643>>>>>>>            Set psCaption to "Schema Name"
103644>>>>>>>        End_Object
103645>>>>>>>
103645>>>>>>>        Procedure Activating
103648>>>>>>>            tDataSourceRow[] MyData
103648>>>>>>>            tDataSourceRow[] MyData
103649>>>>>>>            Handle hoDataSource
103649>>>>>>>            String[] sTheData
103650>>>>>>>            Integer iCount iSize
103650>>>>>>>
103650>>>>>>>            Send Cursor_Wait of Cursor_Control
103651>>>>>>>            Forward Send Activating
103653>>>>>>>
103653>>>>>>>            Get psTheData to sTheData
103654>>>>>>>
103654>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
103655>>>>>>>            Decrement iSize
103656>>>>>>>            For iCount from 0 to iSize
103662>>>>>>>>
103662>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
103663>>>>>>>            Loop
103664>>>>>>>>
103664>>>>>>>
103664>>>>>>>            Get phoDataSource to hoDataSource
103665>>>>>>>            Send InitializeData of hoDataSource MyData
103666>>>>>>>            Send Cursor_Ready of Cursor_Control
103667>>>>>>>        End_Procedure
103668>>>>>>>
103668>>>>>>>    End_Object
103669>>>>>>>
103669>>>>>>>    Object oOK_Btn is a Button
103671>>>>>>>        Set Size to 14 50
103672>>>>>>>        Set Label    to "&OK"
103673>>>>>>>        Set Location to 98 68
103674>>>>>>>        Set peAnchors To anBottomRight
103675>>>>>>>
103675>>>>>>>        Procedure OnClick
103678>>>>>>>            Send Ok of oSelList
103679>>>>>>>        End_Procedure
103680>>>>>>>
103680>>>>>>>    End_Object
103681>>>>>>>
103681>>>>>>>    Object oCancel_Btn is a Button
103683>>>>>>>        Set Size to 14 50
103684>>>>>>>        Set Label    to "&Cancel"
103685>>>>>>>        Set Location to 98 123
103686>>>>>>>        Set peAnchors to anBottomRight
103687>>>>>>>
103687>>>>>>>        Procedure OnClick
103690>>>>>>>            Send Close_Panel
103691>>>>>>>        End_Procedure
103692>>>>>>>
103692>>>>>>>    End_Object
103693>>>>>>>
103693>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103694>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103695>>>>>>>End_Object
103696>>>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
103696>>>>>>>//****************************************************************************
103696>>>>>>>// $Module type: Package
103696>>>>>>>// $Module name: cRDCHeaderGroup.pkg
103696>>>>>>>//
103696>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
103696>>>>>>>// Copyright (c) 2017 RDC Tools International
103696>>>>>>>// E-mail      : support@rdctools.com
103696>>>>>>>// Web-site    : http://www.rdctools.com
103696>>>>>>>//
103696>>>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
103696>>>>>>>//
103696>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
103696>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
103696>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
103696>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
103696>>>>>>>// in the help folder for more details.
103696>>>>>>>//
103696>>>>>>>//****************************************************************************
103696>>>>>>>Use Windows.pkg
103696>>>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCommandLinkButton.pkg)
103696>>>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
103696>>>>>>>>>// older versions you will just get a regular great big button.
103696>>>>>>>>>
103696>>>>>>>>>Use Windows.pkg
103696>>>>>>>>>Use CharTranslate.pkg
103696>>>>>>>>>
103696>>>>>>>>>Class cCommandLinkButton is a Button
103697>>>>>>>>>    
103697>>>>>>>>>    Procedure Construct_Object
103699>>>>>>>>>        Forward Send Construct_Object
103701>>>>>>>>>        Property String psPrivateNote
103702>>>>>>>>>    End_Procedure
103703>>>>>>>>>    
103703>>>>>>>>>    Procedure Set psNote String sNote
103705>>>>>>>>>        Boolean bSupported
103705>>>>>>>>>        Set psPrivateNote to sNote
103706>>>>>>>>>        Get IsExControlSupported to bSupported
103707>>>>>>>>>        If bSupported Begin
103709>>>>>>>>>            Send SetWinNote
103710>>>>>>>>>        End
103710>>>>>>>>>>
103710>>>>>>>>>    End_Procedure
103711>>>>>>>>>    
103711>>>>>>>>>    Procedure SetWinNote
103713>>>>>>>>>        WString wNote
103713>>>>>>>>>        Handle hWnd
103713>>>>>>>>>        Integer i
103713>>>>>>>>>        Pointer pVar
103713>>>>>>>>>        Get Form_Window_Handle 0 to hWnd
103714>>>>>>>>>        If hWnd Begin
103716>>>>>>>>>            Get psNote to wNote
103717>>>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
103718>>>>>>>>>        End
103718>>>>>>>>>>
103718>>>>>>>>>    End_Procedure
103719>>>>>>>>>    
103719>>>>>>>>>    
103719>>>>>>>>>    Function psNote Returns String
103721>>>>>>>>>        Function_Return (psPrivateNote(Self))
103722>>>>>>>>>    End_Function
103723>>>>>>>>>    
103723>>>>>>>>>    
103723>>>>>>>>>    Procedure Page Integer iState
103725>>>>>>>>>        Integer i hWnd
103725>>>>>>>>>        Boolean bSupported
103725>>>>>>>>>        Get IsExControlSupported to bSupported
103726>>>>>>>>>        If (iState=1 and bSupported) Begin
103728>>>>>>>>>            Get form_style i to i
103729>>>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
103730>>>>>>>>>            Forward Send Page iState
103732>>>>>>>>>            Send SetWinNote
103733>>>>>>>>>        End
103733>>>>>>>>>>
103733>>>>>>>>>        Else Begin
103734>>>>>>>>>            Forward Send Page iState
103736>>>>>>>>>        End
103736>>>>>>>>>>
103736>>>>>>>>>    End_Procedure
103737>>>>>>>>>    
103737>>>>>>>>>End_Class
103738>>>>>>>
103738>>>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
103738>>>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
103738>>>>>>>
103738>>>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
103739>>>>>>>    Procedure Construct_Object
103741>>>>>>>        Forward Send Construct_Object
103743>>>>>>>
103743>>>>>>>        Set Size to 18 19
103744>>>>>>>        Set Focus_Mode to NonFocusable
103745>>>>>>>        Set peImageAlign to Button_ImageList_Align_Top
103746>>>>>>>        Set pbAutoResizeIcons to True
103747>>>>>>>    End_Procedure
103748>>>>>>>
103748>>>>>>>    Procedure OnClick
103750>>>>>>>        Broadcast Send Prompt of (Parent(Self))
103752>>>>>>>    End_Procedure
103753>>>>>>>
103753>>>>>>>    Procedure Set Bitmap String sBitmapName
103755>>>>>>>        Forward Set psImage to sBitmapName
103757>>>>>>>    End_Procedure
103758>>>>>>>
103758>>>>>>>    Procedure End_Construct_Object
103760>>>>>>>        Set pbShield to False
103761>>>>>>>        Forward Send End_Construct_Object
103763>>>>>>>    End_Procedure
103764>>>>>>>
103764>>>>>>>End_Class
103765>>>>>>>
103765>>>>>>>// Intermediate class - don't use.
103765>>>>>>>Class _cRDCHeaderGroup is a Container3d
103766>>>>>>>
103766>>>>>>>    Procedure Construct_Object
103768>>>>>>>        Forward Send Construct_Object
103770>>>>>>>
103770>>>>>>>        Property String private.psImage
103771>>>>>>>        Property String private.psLabel
103772>>>>>>>
103772>>>>>>>    End_Procedure
103773>>>>>>>
103773>>>>>>>    Procedure Set psImage String sImage
103775>>>>>>>        Set private.psImage to sImage
103776>>>>>>>    End_Procedure
103777>>>>>>>
103777>>>>>>>    Function psImage Returns String
103779>>>>>>>        Function_Return (private.psImage(Self))
103780>>>>>>>    End_Function
103781>>>>>>>
103781>>>>>>>    Procedure Set psLabel String sLabel
103783>>>>>>>        Set private.psLabel to sLabel
103784>>>>>>>    End_Procedure
103785>>>>>>>
103785>>>>>>>    Function psLabel Returns String
103787>>>>>>>        Function_Return (private.psLabel(Self))
103788>>>>>>>    End_Function
103789>>>>>>>
103789>>>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
103789>>>>>>>    Procedure Set Label String sLabel
103791>>>>>>>        Set psLabel to sLabel
103792>>>>>>>    End_Procedure
103793>>>>>>>
103793>>>>>>>    Function Label Returns String
103795>>>>>>>        Function_Return (private.psLabel(Self))
103796>>>>>>>    End_Function
103797>>>>>>>
103797>>>>>>>End_Class
103798>>>>>>>
103798>>>>>>>Register_Procedure NavigatePrevious
103798>>>>>>>Register_Procedure NavigateNext
103798>>>>>>>
103798>>>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
103799>>>>>>>
103799>>>>>>>    Procedure Construct_Object
103801>>>>>>>        Forward Send Construct_Object
103803>>>>>>>
103803>>>>>>>        Set peAnchors to anTopLeftRight
103804>>>>>>>        Set pbAcceptDropFiles to True
103805>>>>>>>        Set Border_Style to Border_Normal
103806>>>>>>>
103806>>>>>>>        Property Integer private.piColorOrg
103807>>>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
103808>>>>>>>        Property String private.psToolTip ""
103809>>>>>>>
103809>>>>>>>        Property Integer piImageColOffset 4
103810>>>>>>>        Property Integer piImageRowOffset 0
103811>>>>>>>        Property String psNote ""
103812>>>>>>>        Property Boolean pbLargeImageSize True
103813>>>>>>>        Property Integer private.piLargeImageSize 24
103814>>>>>>>        Property Integer private.piSmallImageSize 16
103815>>>>>>>        Property Boolean pbUseHotspotColor False
103816>>>>>>>        Property Integer piHeaderHotspotColor clAqua
103817>>>>>>>        Property String private.psLabel ""
103818>>>>>>>        Property Integer piLabelColor clGreenGrey
103819>>>>>>>        Property Boolean pbLabelFontItalics False
103820>>>>>>>        Property Integer piLabelLargeFontHeight 12
103821>>>>>>>        Property Integer piLabelSmallFontHeight 10
103822>>>>>>>        Property Boolean pbUseLargeFontHeight False
103823>>>>>>>
103823>>>>>>>        Property Integer piLabelFontPointWeight fw_Bold
103824>>>>>>>        Property Integer piLabelColOffset 28
103825>>>>>>>        Property Integer piLabelRowOffset 4
103826>>>>>>>        Property Boolean pbCreateTooltipItem True
103827>>>>>>>
103827>>>>>>>        Set pbAcceptDropFiles to True
103828>>>>>>>
103828>>>>>>>        Send Define_ToolTip_Support_Mixin
103829>>>>>>>
103829>>>>>>>        // For the Studio to render the header image
103829>>>>>>>        Set Bitmap to "Default32x32.bmp"
103830>>>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
103830>>>>>>>        // to render some text in the header when in design mode?
103830>>>>>>>        Set Label to "HEADER TEXT"
103831>>>>>>>
103831>>>>>>>        On_Key kLeftArrow  Send NavigatePrevious
103832>>>>>>>        On_Key kUpArrow    Send NavigatePrevious
103833>>>>>>>        On_Key kRightArrow Send NavigateNext
103834>>>>>>>        On_Key kDownArrow  Send NavigateNext
103835>>>>>>>        On_Key kSwitch     Send Switch_Next_Area
103836>>>>>>>    End_Procedure
103837>>>>>>>
103837>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
103838>>>>>>>
103838>>>>>>>    Procedure Set psImage String sImage
103840>>>>>>>        Set Bitmap to ""
103841>>>>>>>        Forward Set psImage to sImage
103843>>>>>>>    End_Procedure
103844>>>>>>>
103844>>>>>>>    Function psImage Returns String
103846>>>>>>>        Function_Return (psImage(Self))
103847>>>>>>>    End_Function
103848>>>>>>>
103848>>>>>>>    Procedure Set Label String sLabel
103850>>>>>>>        Forward Set psLabel to sLabel
103852>>>>>>>    End_Procedure
103853>>>>>>>
103853>>>>>>>    Procedure Set psToolTip String sToolTip
103855>>>>>>>        Set private.psToolTip to sToolTip
103856>>>>>>>    End_Procedure
103857>>>>>>>
103857>>>>>>>    Function psToolTip Returns String
103859>>>>>>>        Function_Return (private.psToolTip(Self))
103860>>>>>>>    End_Function
103861>>>>>>>
103861>>>>>>>    Procedure End_Construct_Object
103863>>>>>>>        String sNote sLabel
103863>>>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
103863>>>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
103863>>>>>>>
103863>>>>>>>        Forward Send End_Construct_Object
103865>>>>>>>
103865>>>>>>>        Get piLabelColOffset to iLabelColOffset
103866>>>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
103867>>>>>>>        If (bUseLargeFontHeight = True) Begin
103869>>>>>>>            Get piLabelLargeFontHeight to iFontHeight
103870>>>>>>>            Move 8 to iLabelRowOffset
103871>>>>>>>        End
103871>>>>>>>>
103871>>>>>>>        Else Begin
103872>>>>>>>            Get piLabelSmallFontHeight to iFontHeight
103873>>>>>>>            Move 6 to iLabelRowOffset
103874>>>>>>>        End
103874>>>>>>>>
103874>>>>>>>
103874>>>>>>>        Get pbLargeImageSize to bLargeImageSize
103875>>>>>>>        If (bLargeImageSize = True) Begin
103877>>>>>>>            Get private.piLargeImageSize to iImageSize
103878>>>>>>>        End
103878>>>>>>>>
103878>>>>>>>        Else Begin
103879>>>>>>>            Get private.piSmallImageSize to iImageSize
103880>>>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
103881>>>>>>>        End
103881>>>>>>>>
103881>>>>>>>
103881>>>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
103883>>>>>>>            Set piImageSize to iImageSize
103884>>>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
103885>>>>>>>            Set psImage to (private.psImage(Self))
103886>>>>>>>            Set peImageAlign to Button_ImageList_Align_Center
103887>>>>>>>            Set psToolTip to (private.psToolTip(Self))
103888>>>>>>>        End_Object
103889>>>>>>>
103889>>>>>>>        Object oHeaderGroupInfo_tb is a TextBox
103891>>>>>>>            Set Size to 12 100
103892>>>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
103893>>>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
103894>>>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
103895>>>>>>>            Set FontPointHeight to iFontHeight
103896>>>>>>>            Set Label to (private.psLabel(Self))
103897>>>>>>>            Set TextColor to (piLabelColor(Self))
103898>>>>>>>            Set psToolTip to (private.psToolTip(Self))
103899>>>>>>>            Get Size to iSize
103900>>>>>>>        End_Object
103901>>>>>>>
103901>>>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
103901>>>>>>>        // How can it be improved?
103901>>>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
103902>>>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
103904>>>>>>>            Get private.psLabel to sLabel
103905>>>>>>>            Get Text_Extent sLabel to iTextOffset
103906>>>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
103907>>>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
103909>>>>>>>                Set Size to 10 10
103910>>>>>>>                If (bUseLargeFontHeight = True) Begin
103912>>>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
103912>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
103913>>>>>>>                End
103913>>>>>>>>
103913>>>>>>>                Else Begin
103914>>>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset
103914>>>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
103915>>>>>>>                End
103915>>>>>>>>
103915>>>>>>>                Set psToolTip to (private.psToolTip(Self))
103916>>>>>>>                Set Bitmap to "ActionAbout.bmp"
103917>>>>>>>            End_Object
103918>>>>>>>        End
103918>>>>>>>>
103918>>>>>>>
103918>>>>>>>        Get psNote to sNote
103919>>>>>>>        If (Trim(sNote) <> "") Begin
103921>>>>>>>            Object oHeaderGroupNote_tb is a TextBox
103923>>>>>>>                Set Size to 12 100
103924>>>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
103925>>>>>>>                Set Label to ("-" * String(sNote))
103926>>>>>>>                Set TextColor to (piLabelColor(Self))
103927>>>>>>>                Set FontPointHeight to 9
103928>>>>>>>                Set psToolTip to (private.psToolTip(Self))
103929>>>>>>>            End_Object
103930>>>>>>>        End
103930>>>>>>>>
103930>>>>>>>
103930>>>>>>>    End_Procedure
103931>>>>>>>
103931>>>>>>>    Function Popup_State Returns Boolean
103933>>>>>>>        Boolean bIsPopup
103933>>>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
103934>>>>>>>        Function_Return bIsPopup
103935>>>>>>>    End_Function
103936>>>>>>>
103936>>>>>>>    Procedure OnEnterArea Handle hoFrom
103938>>>>>>>        Integer iColor
103938>>>>>>>        Forward Send OnEnterArea hoFrom
103940>>>>>>>        // Not ideal, but works most of the time.
103940>>>>>>>        //       When navigating to i.e a popup we don't want
103940>>>>>>>        //       the coloring to appear. Else there will be 2
103940>>>>>>>        //       cRDCHeaderGroup's with the highlight color...
103940>>>>>>>        // Is there a better way?
103940>>>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
103942>>>>>>>            Procedure_Return
103943>>>>>>>        End
103943>>>>>>>>
103943>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
103945>>>>>>>            Get Color to iColor
103946>>>>>>>            Set private.piColorOrg to iColor
103947>>>>>>>            Get piHeaderHotspotColor to iColor
103948>>>>>>>            Set Color to iColor
103949>>>>>>>            Broadcast Recursive Set Color to iColor
103951>>>>>>>        End
103951>>>>>>>>
103951>>>>>>>    End_Procedure
103952>>>>>>>
103952>>>>>>>    Procedure OnExitArea Handle hoFrom
103954>>>>>>>        Integer iColor
103954>>>>>>>        Forward Send OnExitArea hoFrom
103956>>>>>>>        If (pbUseHotspotColor(Self) = True) Begin
103958>>>>>>>            Get private.piColorOrg to iColor
103959>>>>>>>            Set Color to iColor
103960>>>>>>>            Broadcast Recursive Set Color to iColor
103962>>>>>>>        End
103962>>>>>>>>
103962>>>>>>>    End_Procedure
103963>>>>>>>
103963>>>>>>>    // Public access message to change the group header text color at runtime.
103963>>>>>>>    Procedure Set Label_Color Integer iColor
103965>>>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
103966>>>>>>>    End_Procedure
103967>>>>>>>
103967>>>>>>>    Procedure NavigatePrevious
103969>>>>>>>        Integer iMulti ivoid iLastErr
103969>>>>>>>        Handle hWnd
103969>>>>>>>        Boolean bErr
103969>>>>>>>
103969>>>>>>>        Move Err to bErr
103970>>>>>>>        Move LastErr to iLastErr
103971>>>>>>>
103971>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
103972>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
103973>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
103974>>>>>>>        If (Err) Begin
103976>>>>>>>            Move bErr to Err
103977>>>>>>>            Move iLastErr to LastErr
103978>>>>>>>            Procedure_Return
103979>>>>>>>        End
103979>>>>>>>>
103979>>>>>>>
103979>>>>>>>        Move bErr to Err
103980>>>>>>>        Move iLastErr to LastErr
103981>>>>>>>        If (iMulti = Multi_Select) Begin
103983>>>>>>>            Send Previous
103984>>>>>>>        End
103984>>>>>>>>
103984>>>>>>>        Else Begin
103985>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
103986>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
103987>>>>>>>        End
103987>>>>>>>>
103987>>>>>>>    End_Procedure
103988>>>>>>>
103988>>>>>>>    Procedure NavigateNext
103990>>>>>>>        Integer iMulti iVoid iLastErr
103990>>>>>>>        Handle hWnd
103990>>>>>>>        Boolean bErr
103990>>>>>>>
103990>>>>>>>        Move Err to bErr
103991>>>>>>>        Move LastErr to iLastErr
103992>>>>>>>
103992>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
103993>>>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
103994>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
103995>>>>>>>        If (Err) Begin
103997>>>>>>>            Move bErr to Err
103998>>>>>>>            Move iLastErr to LastErr
103999>>>>>>>            Procedure_Return
104000>>>>>>>        End
104000>>>>>>>>
104000>>>>>>>
104000>>>>>>>        Move bErr to Err
104001>>>>>>>        Move iLastErr to LastErr
104002>>>>>>>        If (iMulti = Multi_Select) Begin
104004>>>>>>>            Send Next
104005>>>>>>>        End
104005>>>>>>>>
104005>>>>>>>        Else Begin
104006>>>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
104007>>>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
104008>>>>>>>        End
104008>>>>>>>>
104008>>>>>>>
104008>>>>>>>    End_Procedure
104009>>>>>>>
104009>>>>>>>    Procedure Enable_Window Integer iState
104011>>>>>>>        Handle hWnd
104011>>>>>>>        Get Window_Handle to hWnd
104012>>>>>>>        If hWnd Begin
104014>>>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
104015>>>>>>>        End
104015>>>>>>>>
104015>>>>>>>    End_Procedure
104016>>>>>>>
104016>>>>>>>    Procedure Page_Object Integer iState
104018>>>>>>>        Handle hWnd
104018>>>>>>>        Get Window_Handle to hWnd
104019>>>>>>>        Forward Send Page_Object iState
104021>>>>>>>        If (hWnd = 0 and iState) Begin
104023>>>>>>>            Send Shadow_Display
104024>>>>>>>        End
104024>>>>>>>>
104024>>>>>>>    End_Procedure
104025>>>>>>>
104025>>>>>>>    Procedure Shadow_Display
104027>>>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
104028>>>>>>>    End_Procedure
104029>>>>>>>
104029>>>>>>>    Function Explicit_Shadow_State Returns Boolean
104031>>>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
104032>>>>>>>    End_Function
104033>>>>>>>
104033>>>>>>>    // For some reason we need to augment this event to allow
104033>>>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
104033>>>>>>>    // happen.
104033>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
104035>>>>>>>        Delegate Send OnFileDropped sFilename bLast
104037>>>>>>>    End_Procedure
104038>>>>>>>
104038>>>>>>>End_Class
104039>>>>>>>
104039>>>>>>>// We don't want the broadcast of setting color to set the background
104039>>>>>>>// color for forms that are within a cRDCHeaderGroup object.
104039>>>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
104039>>>>>>>// behave as it always has. But if you don't like this; just comment
104039>>>>>>>// it out.
104039>>>>>>>//Procedure Set Color for Form Integer eColor
104039>>>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
104039>>>>>>>//    Integer iLastErr
104039>>>>>>>//
104039>>>>>>>//    Move Err to bErr
104039>>>>>>>//    Move LastErr to iLastErr
104039>>>>>>>//
104039>>>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
104039>>>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
104039>>>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
104039>>>>>>>//    Move bErr to Err
104039>>>>>>>//    Move iLastErr to LastErr
104039>>>>>>>//    If (bIsHeaderGroup = False) Begin
104039>>>>>>>//        Forward Set Color to eColor
104039>>>>>>>//    End
104039>>>>>>>//End_Procedure
104039>>>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
104039>>>>>>>Use cApplication.pkg
104039>>>>>>>Use Dfline.pkg
104039>>>>>>>Use cRichEdit.pkg
104039>>>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cScrollingContainer.pkg)
104039>>>>>>>>>// Provides support for scrolling containers.
104039>>>>>>>>>// Scrolling containers is provided by creating two objects,
104039>>>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
104039>>>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
104039>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
104039>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
104039>>>>>>>>>
104039>>>>>>>>>Use Windows.pkg
104039>>>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cScrollingContainerMixin.pkg)
104039>>>>>>>>>>>// Mixin classes for scrolling container support:
104039>>>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
104039>>>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
104039>>>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
104039>>>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
104039>>>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
104039>>>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
104039>>>>>>>>>>>
104039>>>>>>>>>>>Use Windows.pkg
104039>>>>>>>>>>>Use Winuser.pkg
104039>>>>>>>>>>>Use tWinStructs.pkg
104039>>>>>>>>>>>
104039>>>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
104039>>>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
104039>>>>>>>>>>>// support for the scrolling client area mixin object.
104039>>>>>>>>>>>
104039>>>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
104040>>>>>>>>>>>    
104040>>>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
104042>>>>>>>>>>>        
104042>>>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
104043>>>>>>>>>>>        Set Border_Style to Border_None
104044>>>>>>>>>>>        
104044>>>>>>>>>>>        Property Boolean pbAutoScroll True
104045>>>>>>>>>>>        Property Boolean pbAutoScrollFocus True
104046>>>>>>>>>>>        Property Integer piAutoScrollMarginX 5
104047>>>>>>>>>>>        Property Integer piAutoScrollMarginY 5
104048>>>>>>>>>>>        Property Integer piAutoScrollMinX 0
104049>>>>>>>>>>>        Property Integer piAutoScrollMinY 0
104050>>>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
104051>>>>>>>>>>>        
104051>>>>>>>>>>>        
104051>>>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
104052>>>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
104053>>>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
104054>>>>>>>>>>>        // keeps track of scrolling
104054>>>>>>>>>>>        Property Integer piCurrentVertScrolled 0
104055>>>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
104056>>>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
104057>>>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
104059>>>>>>>>>>>        
104059>>>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
104059>>>>>>>>>>>        Property Boolean pbTabWorkspaceView False
104060>>>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
104060>>>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
104061>>>>>>>>>>>    End_Procedure
104062>>>>>>>>>>>    
104062>>>>>>>>>>>    // low level event sent from windows.
104062>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
104064>>>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
104064>>>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
104065>>>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
104066>>>>>>>>>>>        If (wParam<0) Begin
104068>>>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
104069>>>>>>>>>>>        End
104069>>>>>>>>>>>>
104069>>>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
104070>>>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
104071>>>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
104071>>>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
104072>>>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
104073>>>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
104073>>>>>>>>>>>        If (iClicks<>0) Begin
104075>>>>>>>>>>>            Send OnMouseWheel iClicks iKeys
104076>>>>>>>>>>>        End
104076>>>>>>>>>>>>
104076>>>>>>>>>>>        // tell windows that we've handled the event.
104076>>>>>>>>>>>        Set Windows_Override_State to True
104077>>>>>>>>>>>    End_Procedure
104078>>>>>>>>>>>    
104078>>>>>>>>>>>    
104078>>>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
104078>>>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
104080>>>>>>>>>>>        Integer iLineScrollUnit
104080>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
104081>>>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
104082>>>>>>>>>>>    End_Procedure
104083>>>>>>>>>>>    
104083>>>>>>>>>>>    // should be sent by WM_VSCROLL
104083>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
104085>>>>>>>>>>>        Boolean bOk
104085>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104085>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104085>>>>>>>>>>>        Integer iLineScrollUnit
104085>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
104086>>>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
104087>>>>>>>>>>>        If bOk Begin
104089>>>>>>>>>>>            
104089>>>>>>>>>>>            Case Begin
104089>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
104091>>>>>>>>>>>                    Send VScroll ScrollInfo.nPage
104092>>>>>>>>>>>                    Case Break
104093>>>>>>>>>>>                
104093>>>>>>>>>>>                Case (iType=SB_PAGEUP)
104096>>>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
104097>>>>>>>>>>>                    Case Break
104098>>>>>>>>>>>                
104098>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
104101>>>>>>>>>>>                    Send VScroll iLineScrollUnit
104102>>>>>>>>>>>                    Case Break
104103>>>>>>>>>>>                
104103>>>>>>>>>>>                Case (iType=SB_LINEUP)
104106>>>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
104107>>>>>>>>>>>                    Case Break
104108>>>>>>>>>>>                
104108>>>>>>>>>>>                Case (iType=SB_BOTTOM)
104111>>>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
104112>>>>>>>>>>>                    Case Break
104113>>>>>>>>>>>                
104113>>>>>>>>>>>                Case (iType=SB_Top)
104116>>>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
104117>>>>>>>>>>>                    Case Break
104118>>>>>>>>>>>                
104118>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
104121>>>>>>>>>>>                    Case Break
104122>>>>>>>>>>>                
104122>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
104125>>>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
104126>>>>>>>>>>>                    Case Break
104127>>>>>>>>>>>            Case End
104127>>>>>>>>>>>        End
104127>>>>>>>>>>>>
104127>>>>>>>>>>>    End_Procedure
104128>>>>>>>>>>>    
104128>>>>>>>>>>>    // should be sent by WM_HSCROLL
104128>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
104130>>>>>>>>>>>        Boolean bOk
104130>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104130>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104130>>>>>>>>>>>        Integer iLineScrollUnit
104130>>>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
104131>>>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
104132>>>>>>>>>>>        If bOk Begin
104134>>>>>>>>>>>            
104134>>>>>>>>>>>            Case Begin
104134>>>>>>>>>>>                Case (iType=SB_PAGEDOWN)
104136>>>>>>>>>>>                    Send hScroll ScrollInfo.nPage
104137>>>>>>>>>>>                    Case Break
104138>>>>>>>>>>>                
104138>>>>>>>>>>>                Case (iType=SB_PAGEUP)
104141>>>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
104142>>>>>>>>>>>                    Case Break
104143>>>>>>>>>>>                
104143>>>>>>>>>>>                Case (iType=SB_LINEDOWN)
104146>>>>>>>>>>>                    Send hScroll iLineScrollUnit
104147>>>>>>>>>>>                    Case Break
104148>>>>>>>>>>>                
104148>>>>>>>>>>>                Case (iType=SB_LINEUP)
104151>>>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
104152>>>>>>>>>>>                    Case Break
104153>>>>>>>>>>>                
104153>>>>>>>>>>>                Case (iType=SB_BOTTOM)
104156>>>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
104157>>>>>>>>>>>                    Case Break
104158>>>>>>>>>>>                
104158>>>>>>>>>>>                Case (iType=SB_Top)
104161>>>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
104162>>>>>>>>>>>                    Case Break
104163>>>>>>>>>>>                
104163>>>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
104166>>>>>>>>>>>                    Case Break
104167>>>>>>>>>>>                
104167>>>>>>>>>>>                Case (iType=SB_THUMBTRACK)
104170>>>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
104171>>>>>>>>>>>                    Case Break
104172>>>>>>>>>>>            Case End
104172>>>>>>>>>>>        End
104172>>>>>>>>>>>>
104172>>>>>>>>>>>    End_Procedure
104173>>>>>>>>>>>    
104173>>>>>>>>>>>    
104173>>>>>>>>>>>    // this calls SetScrollInfo with proper info
104173>>>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
104175>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104175>>>>>>>>>>>        tWinScrollInfo ScrollInfo
104175>>>>>>>>>>>        Integer iVoid
104175>>>>>>>>>>>        Handle hWnd
104175>>>>>>>>>>>        Boolean bShow
104175>>>>>>>>>>>        
104175>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
104177>>>>>>>>>>>        If (hWnd <> 0) Begin
104179>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
104180>>>>>>>>>>>            
104180>>>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
104181>>>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
104182>>>>>>>>>>>            If bShow Begin
104184>>>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
104185>>>>>>>>>>>            End
104185>>>>>>>>>>>>
104185>>>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
104186>>>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
104187>>>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
104188>>>>>>>>>>>            Move 0 to ScrollInfo.nPos
104189>>>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
104190>>>>>>>>>>>            
104190>>>>>>>>>>>        End
104190>>>>>>>>>>>>
104190>>>>>>>>>>>    End_Procedure
104191>>>>>>>>>>>    
104191>>>>>>>>>>>    // this wraps GetScrollInfo
104191>>>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
104193>>>>>>>>>>>        Boolean bOk
104193>>>>>>>>>>>        Handle hWnd
104193>>>>>>>>>>>        
104193>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
104195>>>>>>>>>>>        If (hWnd <> 0) Begin
104197>>>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
104198>>>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
104199>>>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
104200>>>>>>>>>>>        End
104200>>>>>>>>>>>>
104200>>>>>>>>>>>        Function_Return bOk
104201>>>>>>>>>>>    End_Function
104202>>>>>>>>>>>    
104202>>>>>>>>>>>    // this wraps SetScrollPos
104202>>>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
104204>>>>>>>>>>>        Integer iVoid
104204>>>>>>>>>>>        Handle hWnd
104204>>>>>>>>>>>        
104204>>>>>>>>>>>        Delegate Get Window_Handle to hWnd
104206>>>>>>>>>>>        If (hWnd <> 0) Begin
104208>>>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
104209>>>>>>>>>>>        End
104209>>>>>>>>>>>>
104209>>>>>>>>>>>    End_Procedure
104210>>>>>>>>>>>    
104210>>>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
104210>>>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
104210>>>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
104212>>>>>>>>>>>        Send ScrollClientArea
104213>>>>>>>>>>>    End_Procedure
104214>>>>>>>>>>>    
104214>>>>>>>>>>>    // augment to handle the scrolling area initialization.
104214>>>>>>>>>>>    Procedure Add_Focus Handle hoParent
104216>>>>>>>>>>>        Forward Send Add_Focus hoParent
104218>>>>>>>>>>>        // at this the scrolling container and client area should both be paged.
104218>>>>>>>>>>>        // child objects ae also paged with initial anchors applied
104218>>>>>>>>>>>        Send CalculateAutoScrollMinimums
104219>>>>>>>>>>>    End_Procedure
104220>>>>>>>>>>>    
104220>>>>>>>>>>>    Procedure Page Integer iPage
104222>>>>>>>>>>>        Forward Send Page iPage
104224>>>>>>>>>>>        If iPage Begin
104226>>>>>>>>>>>            // at this the scrolling container and client area should both be paged
104226>>>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
104226>>>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
104226>>>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
104226>>>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
104226>>>>>>>>>>>            // before they were really needed. This should be more accurate
104226>>>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
104227>>>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
104228>>>>>>>>>>>        End
104228>>>>>>>>>>>>
104228>>>>>>>>>>>    End_Procedure
104229>>>>>>>>>>>    
104229>>>>>>>>>>>    // determine scrolling minimums and set the client area as required.
104229>>>>>>>>>>>    
104229>>>>>>>>>>>    Procedure CalculateAutoScrollMinimums
104231>>>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
104231>>>>>>>>>>>        Integer iAutoMinX iAutoMinY
104231>>>>>>>>>>>        Boolean bAutoScroll
104231>>>>>>>>>>>        Handle hoNext hoFirst
104231>>>>>>>>>>>        
104231>>>>>>>>>>>        Get pbAutoScroll to bAutoScroll
104232>>>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
104233>>>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
104234>>>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
104235>>>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
104236>>>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
104237>>>>>>>>>>>        Set piMinimumHeight to iAutoMinY
104238>>>>>>>>>>>        Set piMinimumWidth to iAutoMinX
104239>>>>>>>>>>>        
104239>>>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
104241>>>>>>>>>>>            
104241>>>>>>>>>>>            Get Next_Level to hoFirst
104242>>>>>>>>>>>            Move hoFirst to hoNext
104243>>>>>>>>>>>            If (hoFirst) Begin
104245>>>>>>>>>>>                Repeat
104245>>>>>>>>>>>>
104245>>>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
104246>>>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
104247>>>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
104248>>>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
104249>>>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
104250>>>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
104252>>>>>>>>>>>                
104252>>>>>>>>>>>                If (iAutoMinY=0) Begin
104254>>>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
104255>>>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
104256>>>>>>>>>>>                End
104256>>>>>>>>>>>>
104256>>>>>>>>>>>                
104256>>>>>>>>>>>                If (iAutoMinX=0) Begin
104258>>>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
104259>>>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
104260>>>>>>>>>>>                    
104260>>>>>>>>>>>                End
104260>>>>>>>>>>>>
104260>>>>>>>>>>>            End
104260>>>>>>>>>>>>
104260>>>>>>>>>>>        End
104260>>>>>>>>>>>>
104260>>>>>>>>>>>        
104260>>>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
104260>>>>>>>>>>>        Broadcast Set pbAnchorCreated to False
104262>>>>>>>>>>>        Send ScrollClientArea
104263>>>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
104263>>>>>>>>>>>        Broadcast Send DoCreateAnchors
104265>>>>>>>>>>>    End_Procedure
104266>>>>>>>>>>>    
104266>>>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
104266>>>>>>>>>>>    // work of scrolling.
104266>>>>>>>>>>>    
104266>>>>>>>>>>>    Procedure ScrollClientArea
104268>>>>>>>>>>>        Integer iSiz
104268>>>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
104268>>>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
104268>>>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
104268>>>>>>>>>>>        
104268>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
104270>>>>>>>>>>>        Move (Hi(iSiz)) to iHeight
104271>>>>>>>>>>>        Move (Low(iSiz)) to iWidth
104272>>>>>>>>>>>        
104272>>>>>>>>>>>        // Vertical scrolling
104272>>>>>>>>>>>        
104272>>>>>>>>>>>        Get piMinimumHeight to iOrig
104273>>>>>>>>>>>        Get piMinimumWidth to iWOrig
104274>>>>>>>>>>>        
104274>>>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
104276>>>>>>>>>>>            
104276>>>>>>>>>>>            If (iOrig<>0) Begin
104278>>>>>>>>>>>                Get piCurrentVertScrolled to iHCur
104279>>>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
104279>>>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
104281>>>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
104282>>>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
104283>>>>>>>>>>>                End
104283>>>>>>>>>>>>
104283>>>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
104285>>>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
104286>>>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
104287>>>>>>>>>>>                End
104287>>>>>>>>>>>>
104287>>>>>>>>>>>                Else Begin
104288>>>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
104289>>>>>>>>>>>                End
104289>>>>>>>>>>>>
104289>>>>>>>>>>>            End
104289>>>>>>>>>>>>
104289>>>>>>>>>>>            
104289>>>>>>>>>>>            // Horiz scrolling
104289>>>>>>>>>>>            
104289>>>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
104290>>>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
104290>>>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
104292>>>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
104293>>>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
104294>>>>>>>>>>>            End
104294>>>>>>>>>>>>
104294>>>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
104296>>>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
104297>>>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
104298>>>>>>>>>>>            End
104298>>>>>>>>>>>>
104298>>>>>>>>>>>            Else Begin
104299>>>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
104300>>>>>>>>>>>            End
104300>>>>>>>>>>>>
104300>>>>>>>>>>>        End
104300>>>>>>>>>>>>
104300>>>>>>>>>>>        
104300>>>>>>>>>>>        // this could change depending on scrollbars appearing or not
104300>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
104302>>>>>>>>>>>        
104302>>>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
104302>>>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
104302>>>>>>>>>>>        // This is required to make anchors work sensibly
104302>>>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
104303>>>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
104304>>>>>>>>>>>        Move (-iHCur) to iLocY
104305>>>>>>>>>>>        Move (-iWCur) to iLocX
104306>>>>>>>>>>>        
104306>>>>>>>>>>>        // Allow chance to make modifications
104306>>>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
104307>>>>>>>>>>>        
104307>>>>>>>>>>>        Set GuiSize to iSzY iSzX
104308>>>>>>>>>>>        // if we've scrolled, we need to reposition the container
104308>>>>>>>>>>>        Set GuiLocation to iLocY iLocX
104309>>>>>>>>>>>    End_Procedure
104310>>>>>>>>>>>    
104310>>>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
104310>>>>>>>>>>>    // this way, it does not interfere with anchors.
104310>>>>>>>>>>>    
104310>>>>>>>>>>>    Procedure VScroll Integer iDelta
104312>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
104312>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
104314>>>>>>>>>>>        Move (hi(iSiz)) to iHeight
104315>>>>>>>>>>>        Get piCurrentVertScrolled to iCur
104316>>>>>>>>>>>        Get piMinimumHeight to iOrig
104317>>>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
104319>>>>>>>>>>>            Procedure_Return
104320>>>>>>>>>>>        End
104320>>>>>>>>>>>>
104320>>>>>>>>>>>        // make sure delta is within range
104320>>>>>>>>>>>        If (iDelta+iCur<0) Begin
104322>>>>>>>>>>>            Move (-iCur) to iDelta
104323>>>>>>>>>>>        End
104323>>>>>>>>>>>>
104323>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
104326>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
104327>>>>>>>>>>>        End
104327>>>>>>>>>>>>
104327>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
104330>>>>>>>>>>>        
104330>>>>>>>>>>>        Move (iCur + iDelta) to iCur
104331>>>>>>>>>>>        Set piCurrentVertScrolled to iCur
104332>>>>>>>>>>>        Send SetScrollBarPosInfo True iCur
104333>>>>>>>>>>>        Get GuiLocation to iSiz
104334>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
104335>>>>>>>>>>>        Send ScrollClientArea
104336>>>>>>>>>>>    End_Procedure
104337>>>>>>>>>>>    
104337>>>>>>>>>>>    
104337>>>>>>>>>>>    Procedure HScroll Integer iDelta
104339>>>>>>>>>>>        Integer iHeight iCur iOrig iSiz
104339>>>>>>>>>>>        Delegate Get GuiClientSize to iSiz
104341>>>>>>>>>>>        Move (low(iSiz)) to iHeight
104342>>>>>>>>>>>        Get piCurrentHorzScrolled to iCur
104343>>>>>>>>>>>        Get piMinimumWidth to iOrig
104344>>>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
104346>>>>>>>>>>>            Procedure_Return
104347>>>>>>>>>>>        End
104347>>>>>>>>>>>>
104347>>>>>>>>>>>        If (iDelta+iCur<0) Begin
104349>>>>>>>>>>>            Move (-iCur) to iDelta
104350>>>>>>>>>>>        End
104350>>>>>>>>>>>>
104350>>>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
104353>>>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
104354>>>>>>>>>>>        End
104354>>>>>>>>>>>>
104354>>>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
104357>>>>>>>>>>>        
104357>>>>>>>>>>>        Move (iCur + iDelta) to iCur
104358>>>>>>>>>>>        Set piCurrentHorzScrolled to iCur
104359>>>>>>>>>>>        Send SetScrollBarPosInfo False iCur
104360>>>>>>>>>>>        Get GuiLocation to iSiz
104361>>>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
104362>>>>>>>>>>>        Send ScrollClientArea
104363>>>>>>>>>>>    End_Procedure
104364>>>>>>>>>>>    
104364>>>>>>>>>>>    // make sure client is a 0,0
104364>>>>>>>>>>>    Procedure ScrollHome
104366>>>>>>>>>>>        Send SetVScrollbox SB_TOP 0
104367>>>>>>>>>>>        Send SetHScrollbox SB_TOP 0
104368>>>>>>>>>>>    End_Procedure
104369>>>>>>>>>>>    
104369>>>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
104369>>>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
104371>>>>>>>>>>>        Integer ivoid
104371>>>>>>>>>>>        tWinRect Rect0 Rect1
104371>>>>>>>>>>>        tWinRect Rect0 Rect1
104371>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
104372>>>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
104373>>>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
104374>>>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
104375>>>>>>>>>>>    End_Procedure
104376>>>>>>>>>>>    
104376>>>>>>>>>>>    // This scrolls this object into visual range.
104376>>>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
104378>>>>>>>>>>>        Handle hoScrollingContainer
104378>>>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
104378>>>>>>>>>>>        Integer iViewHeight iViewWidth
104378>>>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
104378>>>>>>>>>>>        Integer iSize iControlHeight iControlWidth
104378>>>>>>>>>>>        Integer iScroll
104378>>>>>>>>>>>        Integer iMarginX iMarginY
104378>>>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
104378>>>>>>>>>>>        
104378>>>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
104379>>>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
104380>>>>>>>>>>>        
104380>>>>>>>>>>>        // the scrolling container
104380>>>>>>>>>>>        Move Self to hoScrollingContainer
104381>>>>>>>>>>>        // the amount the SC is currently scrolled
104381>>>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
104382>>>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
104383>>>>>>>>>>>        
104383>>>>>>>>>>>        // size of view's client area (this is the viewport area)
104383>>>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
104384>>>>>>>>>>>        Move (hi(iSize)) to iViewHeight
104385>>>>>>>>>>>        Move (low(iSize)) to iViewWidth
104386>>>>>>>>>>>        
104386>>>>>>>>>>>        // get this object's location relative to the scrolling container
104386>>>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
104387>>>>>>>>>>>        
104387>>>>>>>>>>>        // we expect that the client size is the window size but just in case
104387>>>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
104388>>>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
104389>>>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
104390>>>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
104391>>>>>>>>>>>        
104391>>>>>>>>>>>        // the outer size of the control object
104391>>>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
104392>>>>>>>>>>>        Move (hi(iSize)) to iControlHeight
104393>>>>>>>>>>>        Move (low(iSize)) to iControlWidth
104394>>>>>>>>>>>        
104394>>>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
104394>>>>>>>>>>>        
104394>>>>>>>>>>>        // Vertical Scroll
104394>>>>>>>>>>>        
104394>>>>>>>>>>>        // Vertical Scroll down
104394>>>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
104394>>>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
104396>>>>>>>>>>>            
104396>>>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
104396>>>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
104397>>>>>>>>>>>            
104397>>>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
104397>>>>>>>>>>>            // top of the object appears at the bottom
104397>>>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
104399>>>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
104400>>>>>>>>>>>            End
104400>>>>>>>>>>>>
104400>>>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
104400>>>>>>>>>>>            If (iScroll>0) Begin
104402>>>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
104403>>>>>>>>>>>            End
104403>>>>>>>>>>>>
104403>>>>>>>>>>>        End
104403>>>>>>>>>>>>
104403>>>>>>>>>>>        // else vertical scroll up
104403>>>>>>>>>>>        // We scroll if the top of the object is not visible.
104403>>>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
104406>>>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
104406>>>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
104407>>>>>>>>>>>            If (iScroll<0) Begin
104409>>>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
104410>>>>>>>>>>>            End
104410>>>>>>>>>>>>
104410>>>>>>>>>>>        End
104410>>>>>>>>>>>>
104410>>>>>>>>>>>        
104410>>>>>>>>>>>        // Horizonal Scroll
104410>>>>>>>>>>>        
104410>>>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
104410>>>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
104412>>>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
104413>>>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
104415>>>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
104416>>>>>>>>>>>            End
104416>>>>>>>>>>>>
104416>>>>>>>>>>>            If (iScroll>0) Begin
104418>>>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
104419>>>>>>>>>>>            End
104419>>>>>>>>>>>>
104419>>>>>>>>>>>        End
104419>>>>>>>>>>>>
104419>>>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
104421>>>>>>>>>>>            // if this can fit by moving all the way to left, do so.
104421>>>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
104423>>>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
104424>>>>>>>>>>>            End
104424>>>>>>>>>>>>
104424>>>>>>>>>>>            Else Begin
104425>>>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
104426>>>>>>>>>>>            End
104426>>>>>>>>>>>>
104426>>>>>>>>>>>            If (iScroll<0) Begin
104428>>>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
104429>>>>>>>>>>>            End
104429>>>>>>>>>>>>
104429>>>>>>>>>>>        End
104429>>>>>>>>>>>>
104429>>>>>>>>>>>        
104429>>>>>>>>>>>        
104429>>>>>>>>>>>    End_Procedure
104430>>>>>>>>>>>    
104430>>>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
104430>>>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
104432>>>>>>>>>>>        Boolean bScrollOnFocus
104432>>>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
104433>>>>>>>>>>>        If bScrollOnFocus Begin
104435>>>>>>>>>>>            Send ScrollObjectInRange hoControl
104436>>>>>>>>>>>        End
104436>>>>>>>>>>>>
104436>>>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
104438>>>>>>>>>>>    End_Procedure
104439>>>>>>>>>>>    
104439>>>>>>>>>>>    
104439>>>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
104441>>>>>>>>>>>        Boolean bCenter
104441>>>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
104442>>>>>>>>>>>        Function_Return bCenter
104443>>>>>>>>>>>    End_Function
104444>>>>>>>>>>>    
104444>>>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
104446>>>>>>>>>>>        Boolean bTabWorkspaceView
104446>>>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
104447>>>>>>>>>>>        If bTabWorkspaceView Begin
104449>>>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
104450>>>>>>>>>>>        End
104450>>>>>>>>>>>>
104450>>>>>>>>>>>    End_Procedure
104451>>>>>>>>>>>    
104451>>>>>>>>>>>    Function ParentView Returns Handle
104453>>>>>>>>>>>        Function_Return (Parent(Parent(Self)))
104454>>>>>>>>>>>    End_Function
104455>>>>>>>>>>>    
104455>>>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
104457>>>>>>>>>>>        Integer iSize iMax iDiff
104457>>>>>>>>>>>        Handle hoView
104457>>>>>>>>>>>        Boolean bCenter bModal
104457>>>>>>>>>>>        Get ParentView to hoView
104458>>>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
104459>>>>>>>>>>>        If not bModal Begin
104461>>>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
104462>>>>>>>>>>>            Get GuiSize of hoView to iSize
104463>>>>>>>>>>>            Get piMaxSize of hoView to iMax
104464>>>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
104465>>>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
104467>>>>>>>>>>>                If bCenter Begin
104469>>>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
104470>>>>>>>>>>>                End
104470>>>>>>>>>>>>
104470>>>>>>>>>>>                Move (Low(iMax)) to iWidth
104471>>>>>>>>>>>            End
104471>>>>>>>>>>>>
104471>>>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
104473>>>>>>>>>>>                If bCenter Begin
104475>>>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
104476>>>>>>>>>>>                    Move (iLocy min 25) to  iLocY
104477>>>>>>>>>>>                End
104477>>>>>>>>>>>>
104477>>>>>>>>>>>                Move (Hi(imax)) to iHeight
104478>>>>>>>>>>>            End
104478>>>>>>>>>>>>
104478>>>>>>>>>>>        End
104478>>>>>>>>>>>>
104478>>>>>>>>>>>    End_Procedure
104479>>>>>>>>>>>    
104479>>>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
104479>>>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
104479>>>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
104479>>>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
104479>>>>>>>>>>>    // This should almost always yield the right answer.
104479>>>>>>>>>>>    // This is called by the scrolling container's end_constructor
104479>>>>>>>>>>>    Procedure AutoSetTabWorkspaceView
104481>>>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
104481>>>>>>>>>>>        Handle hoParent
104481>>>>>>>>>>>        Integer iSize
104481>>>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
104482>>>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
104484>>>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
104485>>>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
104485>>>>>>>>>>>            // change this after the commandbar is paged.
104485>>>>>>>>>>>            If (bTabView) Begin
104487>>>>>>>>>>>                Get ParentView to hoParent
104488>>>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
104489>>>>>>>>>>>                If (bIsView) Begin
104491>>>>>>>>>>>                    // set this as a tab workspace view
104491>>>>>>>>>>>                    Set pbTabWorkspaceView to True
104492>>>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
104492>>>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
104492>>>>>>>>>>>                    Set pbAutoScroll to True
104493>>>>>>>>>>>                    
104493>>>>>>>>>>>                End
104493>>>>>>>>>>>>
104493>>>>>>>>>>>            End
104493>>>>>>>>>>>>
104493>>>>>>>>>>>        End
104493>>>>>>>>>>>>
104493>>>>>>>>>>>    End_Procedure
104494>>>>>>>>>>>    
104494>>>>>>>>>>>End_Class
104495>>>>>>>>>>>
104495>>>>>>>>>>>// Container scrolling class support. Nothing in here is public
104495>>>>>>>>>>>Class cScrollingContainerMixin is a Mixin
104496>>>>>>>>>>>    
104496>>>>>>>>>>>    Procedure Define_cScrollingContainerMixin
104498>>>>>>>>>>>        Forward Set Border_Style to Border_None
104500>>>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
104501>>>>>>>>>>>        Forward Set peAnchors to anAll
104503>>>>>>>>>>>        
104503>>>>>>>>>>>        // forcing scrollbars right away seems to make painting better
104503>>>>>>>>>>>        Set Window_Style WS_HSCROLL to True
104504>>>>>>>>>>>        Set Window_Style WS_VSCROLL to True
104505>>>>>>>>>>>        
104505>>>>>>>>>>>        Property Handle phoScrollingClientArea 0
104506>>>>>>>>>>>    End_Procedure
104507>>>>>>>>>>>    
104507>>>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
104507>>>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
104509>>>>>>>>>>>    End_Procedure
104510>>>>>>>>>>>    
104510>>>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
104510>>>>>>>>>>>    Procedure Set Border_Style Integer eStyle
104512>>>>>>>>>>>    End_Procedure
104513>>>>>>>>>>>    
104513>>>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
104513>>>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
104515>>>>>>>>>>>        Handle hoClient
104515>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
104516>>>>>>>>>>>        If hoClient Begin
104518>>>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
104519>>>>>>>>>>>        End
104519>>>>>>>>>>>>
104519>>>>>>>>>>>    End_Procedure
104520>>>>>>>>>>>    
104520>>>>>>>>>>>    // should be sent by WM_VSCROLL
104520>>>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
104522>>>>>>>>>>>        Handle hoClient
104522>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
104523>>>>>>>>>>>        If hoClient Begin
104525>>>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
104526>>>>>>>>>>>        End
104526>>>>>>>>>>>>
104526>>>>>>>>>>>    End_Procedure
104527>>>>>>>>>>>    
104527>>>>>>>>>>>    // should be sent by WM_HSCROLL
104527>>>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
104529>>>>>>>>>>>        Handle hoClient
104529>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
104530>>>>>>>>>>>        If hoClient Begin
104532>>>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
104533>>>>>>>>>>>        End
104533>>>>>>>>>>>>
104533>>>>>>>>>>>    End_Procedure
104534>>>>>>>>>>>    
104534>>>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
104534>>>>>>>>>>>    // After this is set, anchors will handle any further resizing.
104534>>>>>>>>>>>    Procedure Page Integer iState
104536>>>>>>>>>>>        Integer iSiz iHeight iWidth
104536>>>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
104536>>>>>>>>>>>        Boolean bGroup
104536>>>>>>>>>>>        Handle hoClient
104536>>>>>>>>>>>        If (iState =1) Begin
104538>>>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
104540>>>>>>>>>>>            // We have special code to support groups because they
104540>>>>>>>>>>>            // draw a border inside of the client rectangle
104540>>>>>>>>>>>            If bGroup Begin
104542>>>>>>>>>>>                Get Physical_FontSize to iFontSize
104543>>>>>>>>>>>                Move (Hi(iFontSize)) to iTop
104544>>>>>>>>>>>                Move 2 to iLeft
104545>>>>>>>>>>>                Move 2 to iRight
104546>>>>>>>>>>>                Move 2 to iBottom
104547>>>>>>>>>>>            End
104547>>>>>>>>>>>>
104547>>>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
104547>>>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
104547>>>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
104547>>>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
104549>>>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
104550>>>>>>>>>>>            Set GuiLocation to iTop iLeft
104551>>>>>>>>>>>            Send Adjust_Logicals
104552>>>>>>>>>>>        End
104552>>>>>>>>>>>>
104552>>>>>>>>>>>        Forward Send Page iState
104554>>>>>>>>>>>    End_Procedure
104555>>>>>>>>>>>    
104555>>>>>>>>>>>    Procedure End_Construct_Object
104557>>>>>>>>>>>        Handle hoClient
104557>>>>>>>>>>>        Forward Send End_Construct_Object
104559>>>>>>>>>>>        Get phoScrollingClientArea to hoClient
104560>>>>>>>>>>>        If (hoClient) Begin
104562>>>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
104563>>>>>>>>>>>        End
104563>>>>>>>>>>>>
104563>>>>>>>>>>>    End_Procedure
104564>>>>>>>>>>>    
104564>>>>>>>>>>>End_Class
104565>>>>>>>>>
104565>>>>>>>>>Class cScrollingClientArea is a Container3d
104566>>>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
104567>>>>>>>>>    Procedure Construct_Object
104569>>>>>>>>>        Forward Send Construct_Object
104571>>>>>>>>>        Send Define_cScrollingClientAreaMixin
104572>>>>>>>>>    End_Procedure
104573>>>>>>>>>End_Class
104574>>>>>>>>>
104574>>>>>>>>>
104574>>>>>>>>>
104574>>>>>>>>>Class cScrollingContainer is a Container3d
104575>>>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
104576>>>>>>>>>    Procedure Construct_Object
104578>>>>>>>>>        Forward Send Construct_Object
104580>>>>>>>>>        Send Define_cScrollingContainerMixin
104581>>>>>>>>>    End_Procedure
104582>>>>>>>>>End_Class
104583>>>>>>>Use cRDCModalPanel.pkg
104583>>>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCForm.pkg)
104583>>>>>>>>>//****************************************************************************
104583>>>>>>>>>// $Module type: Class
104583>>>>>>>>>// $Module name: cForm
104583>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
104583>>>>>>>>>// Created     : 2014-03-17 @ 12:34
104583>>>>>>>>>//
104583>>>>>>>>>// Description :
104583>>>>>>>>>//
104583>>>>>>>>>// $Rev History:
104583>>>>>>>>>//    2014-03-17  Module header created
104583>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
104583>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
104583>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
104583>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
104583>>>>>>>>>// in the help folder for more details.
104583>>>>>>>>>//
104583>>>>>>>>>//****************************************************************************
104583>>>>>>>>>Use Windows.pkg
104583>>>>>>>>>
104583>>>>>>>>>Class cFormIdleHandler is a cIdleHandler
104584>>>>>>>>>    Procedure Construct_Object
104586>>>>>>>>>        Forward Send Construct_Object
104588>>>>>>>>>
104588>>>>>>>>>    End_Procedure
104589>>>>>>>>>
104589>>>>>>>>>    Procedure OnIdle
104591>>>>>>>>>        Delegate Send DoUpdate
104593>>>>>>>>>    End_Procedure
104594>>>>>>>>>
104594>>>>>>>>>End_Class
104595>>>>>>>>>
104595>>>>>>>>>Class cRDCForm is a Form
104596>>>>>>>>>
104596>>>>>>>>>    Procedure Construct_Object
104598>>>>>>>>>        Forward Send Construct_Object
104600>>>>>>>>>
104600>>>>>>>>>        Property Boolean pbAutoEnable False
104601>>>>>>>>>
104601>>>>>>>>>        Property Boolean pbEnabled True
104602>>>>>>>>>
104602>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
104603>>>>>>>>>
104603>>>>>>>>>        Set Label_Justification_mode to JMode_Right
104604>>>>>>>>>        Set Label_Col_Offset to 2
104605>>>>>>>>>        Set Label_Row_Offset to 0
104606>>>>>>>>>    End_Procedure
104607>>>>>>>>>
104607>>>>>>>>>    Procedure End_Construct_Object
104609>>>>>>>>>        String sTooltip sStatus_Help
104609>>>>>>>>>
104609>>>>>>>>>        Forward Send End_Construct_Object
104611>>>>>>>>>
104611>>>>>>>>>        Get psToolTip   to sTooltip
104612>>>>>>>>>        Get Status_Help to sStatus_Help
104613>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
104615>>>>>>>>>            Set psToolTip to sStatus_Help
104616>>>>>>>>>        End
104616>>>>>>>>>>
104616>>>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
104619>>>>>>>>>            Set Status_Help to sTooltip
104620>>>>>>>>>        End
104620>>>>>>>>>>
104620>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
104621>>>>>>>>>    End_Procedure
104622>>>>>>>>>
104622>>>>>>>>>    Procedure DoUpdate
104624>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
104626>>>>>>>>>            Procedure_Return
104627>>>>>>>>>        End
104627>>>>>>>>>>
104627>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
104628>>>>>>>>>    End_Procedure
104629>>>>>>>>>
104629>>>>>>>>>    Function IsEnabled Returns Boolean
104631>>>>>>>>>        Boolean bEnabled
104631>>>>>>>>>        Get pbEnabled to bEnabled
104632>>>>>>>>>        Function_Return bEnabled
104633>>>>>>>>>    End_Function
104634>>>>>>>>>
104634>>>>>>>>>    // Enable the idle handler timer when the object is activated
104634>>>>>>>>>    Procedure Activating
104636>>>>>>>>>        Forward Send Activating
104638>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
104639>>>>>>>>>    End_Procedure
104640>>>>>>>>>
104640>>>>>>>>>    // Disable the idle handler when the object is deactivated
104640>>>>>>>>>    Procedure Deactivating
104642>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
104643>>>>>>>>>        Forward Send Deactivating
104645>>>>>>>>>    End_Procedure
104646>>>>>>>>>
104646>>>>>>>>>End_Class
104647>>>>>>>Use cRDCComboForm.pkg
104647>>>>>>>Use cRDCButton.pkg
104647>>>>>>>Use cRDCHeaderGroup.pkg
104647>>>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
104647>>>>>>>>>//****************************************************************************
104647>>>>>>>>>// $Module type: Class
104647>>>>>>>>>// $Module name: cDbDriverSettingsForm
104647>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
104647>>>>>>>>>// Created     : 2014-03-17 @ 12:34
104647>>>>>>>>>//
104647>>>>>>>>>// Description :
104647>>>>>>>>>//
104647>>>>>>>>>// $Rev History:
104647>>>>>>>>>//    2014-03-17  Module header created
104647>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
104647>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
104647>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
104647>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
104647>>>>>>>>>// in the help folder for more details.
104647>>>>>>>>>//
104647>>>>>>>>>//****************************************************************************
104647>>>>>>>>>Use Windows.pkg
104647>>>>>>>>>Use seq_chnl.pkg
104647>>>>>>>>>
104647>>>>>>>>>Class cDbDriverSettingsForm is a Form
104648>>>>>>>>>
104648>>>>>>>>>    Procedure Construct_Object
104650>>>>>>>>>        Forward Send Construct_Object
104652>>>>>>>>>
104652>>>>>>>>>        Property Boolean private.pbDriverLoadingError False
104653>>>>>>>>>        
104653>>>>>>>>>        Set Label_Col_Offset to 2
104654>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
104655>>>>>>>>>        Set Size to 11 125 
104656>>>>>>>>>        // We use these settings and not enabled_state to be able
104656>>>>>>>>>        // to show tooltips.
104656>>>>>>>>>        Set Color to clBtnFace
104657>>>>>>>>>        Set Focus_Mode to NonFocusable
104658>>>>>>>>>        Set peAnchors to anTopLeftRight
104659>>>>>>>>>
104659>>>>>>>>>        Property String psDriverIniFile ""
104660>>>>>>>>>    End_Procedure
104661>>>>>>>>>
104661>>>>>>>>>    Procedure Set psToolTip String sText
104663>>>>>>>>>        If (Trim(sText) = "") Begin
104665>>>>>>>>>            Move "No info available" to sText
104666>>>>>>>>>        End
104666>>>>>>>>>>
104666>>>>>>>>>        Forward Set psToolTip to sText
104668>>>>>>>>>    End_Procedure
104669>>>>>>>>>
104669>>>>>>>>>    Function psToolTip Returns String
104671>>>>>>>>>        String sTooltip sSearchValue
104671>>>>>>>>>
104671>>>>>>>>>        Get Label to sSearchValue
104672>>>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
104673>>>>>>>>>
104673>>>>>>>>>        Function_Return sTooltip
104674>>>>>>>>>    End_Function
104675>>>>>>>>>
104675>>>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
104677>>>>>>>>>        Integer iDriver
104677>>>>>>>>>        String sValue
104677>>>>>>>>>
104677>>>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
104677>>>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
104677>>>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
104679>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
104680>>>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
104681>>>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
104682>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
104683>>>>>>>>>            If (iDriver <= 0) Begin
104685>>>>>>>>>                Procedure_Return
104686>>>>>>>>>            End
104686>>>>>>>>>>
104686>>>>>>>>>            // Set indicator to false prior asking for the driver attribute.
104686>>>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
104686>>>>>>>>>            Move False to Err
104687>>>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
104690>>>>>>>>>            If (sValue = "0") Begin
104692>>>>>>>>>                Move "0 (False)" to sValue
104693>>>>>>>>>            End
104693>>>>>>>>>>
104693>>>>>>>>>            If (sValue = "1") Begin
104695>>>>>>>>>                Move "1 (True)"  to sValue
104696>>>>>>>>>            End
104696>>>>>>>>>>
104696>>>>>>>>>            Set Value to sValue
104697>>>>>>>>>
104697>>>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
104698>>>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
104698>>>>>>>>>            // all labels (DF_DRIVER_XXX values).
104698>>>>>>>>>            Get Propercase sLabel to sLabel
104699>>>>>>>>>            Set Label to sLabel
104700>>>>>>>>>
104700>>>>>>>>>            Get ExtractIniFileComment sLabel to sValue
104701>>>>>>>>>            Set Status_Help to sValue
104702>>>>>>>>>            Set psToolTip to sValue
104703>>>>>>>>>        End
104703>>>>>>>>>>
104703>>>>>>>>>    End_Procedure
104704>>>>>>>>>
104704>>>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
104704>>>>>>>>>    // Returns: The comments in the file as a string.
104704>>>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
104706>>>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
104706>>>>>>>>>        Boolean bCommentRow bStart
104706>>>>>>>>>        Integer iCh
104706>>>>>>>>>
104706>>>>>>>>>        Get psDriverIniFile to sIniFile
104707>>>>>>>>>        Move ";" to sCommentMarker
104708>>>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
104709>>>>>>>>>        While (SeqEof = False)
104713>>>>>>>>>            Readln channel iCh sValue
104715>>>>>>>>>            Move (Trim(sValue)) to sValue
104716>>>>>>>>>
104716>>>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
104716>>>>>>>>>            Move (Left(sValue, 1)) to sComment
104717>>>>>>>>>            If (bStart = False) Begin
104719>>>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
104720>>>>>>>>>            End
104720>>>>>>>>>>
104720>>>>>>>>>            If (bStart = True) Begin
104722>>>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
104722>>>>>>>>>                If (sComment <> sCommentMarker) Begin
104724>>>>>>>>>                    Move True to SeqEof
104725>>>>>>>>>                End
104725>>>>>>>>>>
104725>>>>>>>>>                Else Begin
104726>>>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
104727>>>>>>>>>                    If (bCommentRow = True) Begin
104729>>>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
104730>>>>>>>>>
104730>>>>>>>>>                        // Replace all double spaces with a single space character.
104730>>>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
104731>>>>>>>>>
104731>>>>>>>>>                        If (sRetval = "") Begin
104733>>>>>>>>>                            Move sValue to sRetval
104734>>>>>>>>>                        End
104734>>>>>>>>>>
104734>>>>>>>>>                        Else Begin
104735>>>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
104736>>>>>>>>>                        End
104736>>>>>>>>>>
104736>>>>>>>>>                    End
104736>>>>>>>>>>
104736>>>>>>>>>                End
104736>>>>>>>>>>
104736>>>>>>>>>            End
104736>>>>>>>>>>
104736>>>>>>>>>        Loop
104737>>>>>>>>>>
104737>>>>>>>>>        Send Seq_Close_Channel iCh
104738>>>>>>>>>
104738>>>>>>>>>CompilerWarnings Off
104738>>>>>>>>>        // Replaces all double spaces with a single space character.
104738>>>>>>>>>        // The Replaces function doesn't quite work for this.
104738>>>>>>>>>        Repeat
104738>>>>>>>>>>
104738>>>>>>>>>            Replace "  " in sRetval with " "
104742>>>>>>>>>        Until (FindErr)
104744>>>>>>>>>        
104744>>>>>>>>>        Function_Return sRetval
104745>>>>>>>>>    End_Function
104746>>>>>>>>>CompilerWarnings On
104746>>>>>>>>>
104746>>>>>>>>>    Function Propercase String sText Returns String 
104748>>>>>>>>>        String[] sDelimiters
104749>>>>>>>>>        Integer iPos
104749>>>>>>>>>        
104749>>>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
104749>>>>>>>>>        Move (Lowercase(sText)) to sText
104750>>>>>>>>>        
104750>>>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
104751>>>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
104752>>>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
104753>>>>>>>>>        
104753>>>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
104759>>>>>>>>>>
104759>>>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
104759>>>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
104762>>>>>>>>>        Loop
104763>>>>>>>>>>
104763>>>>>>>>>        
104763>>>>>>>>>        Function_Return sText
104764>>>>>>>>>    End_Function
104765>>>>>>>>>
104765>>>>>>>>>End_Class
104766>>>>>>>Use cDbUpdateFunctionLibrary.pkg
104766>>>>>>>
104766>>>>>>>Register_Procedure psOrgToolTip String sTooltip
104766>>>>>>>
104766>>>>>>>Object oDriverSettings_dg is a cRDCModalPanel
104768>>>>>>>    Set Size to 291 345
104769>>>>>>>    Set Label to "Driver Configuration File Info"
104770>>>>>>>    Set Location to 2 2
104771>>>>>>>    Set Maximize_Icon to False
104772>>>>>>>    Set Locate_Mode to CENTER_ON_PARENT
104773>>>>>>>    Set Icon to "DriverSettings1.ico"
104774>>>>>>>    
104774>>>>>>>    Property String psDriverID MSSQLDRV_ID
104776>>>>>>>    Property Boolean pbDriverLoadingError False
104778>>>>>>>    
104778>>>>>>>    Object oCancel_Btn is a cRDCButton
104780>>>>>>>        Set Label    to "&Close"
104781>>>>>>>        Set Location to 269 287
104782>>>>>>>        Set peAnchors to anBottomRight
104783>>>>>>>
104783>>>>>>>        Procedure OnClick
104786>>>>>>>            Send Close_Panel
104787>>>>>>>        End_Procedure
104788>>>>>>>
104788>>>>>>>    End_Object
104789>>>>>>>
104789>>>>>>>    Object oDriver_cf is a cRDCComboForm
104791>>>>>>>        Set Label to "Database Driver"
104792>>>>>>>        Set Size to 13 80
104793>>>>>>>        Set Location to 8 90
104794>>>>>>>        Set Form_Border to 0
104795>>>>>>>        Set Label_Col_Offset to 2
104796>>>>>>>        Set Label_Justification_Mode to JMode_Right
104797>>>>>>>        Set Status_Help to "Database driver."
104798>>>>>>>        Set Enabled_State to False
104799>>>>>>>        Set Skip_State to True
104800>>>>>>>
104800>>>>>>>        Procedure Combo_Fill_List
104803>>>>>>>            Send Combo_Add_Item DATAFLEX_ID
104804>>>>>>>            Send Combo_Add_Item DFBTRDRV_ID
104805>>>>>>>            Send Combo_Add_Item ODBC_DRV_ID
104806>>>>>>>            Send Combo_Add_Item MSSQLDRV_ID
104807>>>>>>>            Send Combo_Add_Item DB2_DRV_ID
104808>>>>>>>        End_Procedure
104809>>>>>>>
104809>>>>>>>    End_Object
104810>>>>>>>
104810>>>>>>>    Object oDriverFileName_cf is a cRDCForm
104812>>>>>>>        Set Label to "Database Driver File"
104813>>>>>>>        Set Size to 12 193
104814>>>>>>>        Set Location to 24 90
104815>>>>>>>        Set Label_Col_Offset to 2
104816>>>>>>>        Set Label_Justification_Mode to JMode_Right
104817>>>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
104818>>>>>>>        Set Color to clBtnFace
104819>>>>>>>        Set Focus_Mode to NonFocusable
104820>>>>>>>        Set peAnchors to anTopLeftRight
104821>>>>>>>
104821>>>>>>>        Procedure OnChange
104824>>>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
104824>>>>>>>
104824>>>>>>>            Forward Send OnChange
104826>>>>>>>            Get Value to sValue
104827>>>>>>>            Set Status_Help to sValue
104828>>>>>>>
104828>>>>>>>            Get psDriverID to sDriverID
104829>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
104831>>>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
104832>>>>>>>                If (sPath <> "") Begin
104834>>>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
104835>>>>>>>                End
104835>>>>>>>>
104835>>>>>>>            End
104835>>>>>>>>
104835>>>>>>>            Else Begin
104836>>>>>>>                Move sDriverID to sDriverIntFileName
104837>>>>>>>            End
104837>>>>>>>>
104837>>>>>>>
104837>>>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
104838>>>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
104839>>>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
104840>>>>>>>
104840>>>>>>>            // In case driver attribute objects already exists; destroy them
104840>>>>>>>            Broadcast Send Destroy    of oScrollingClientArea
104842>>>>>>>            // Then recreate them to show driver attributes
104842>>>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
104843>>>>>>>        End_Procedure  
104844>>>>>>>        
104844>>>>>>>    End_Object
104845>>>>>>>
104845>>>>>>>    Object oDriverInfo_btn is a cRDCButton
104847>>>>>>>        Set Size to 13 50
104848>>>>>>>        Set Location to 24 287
104849>>>>>>>        Set Label to "Version Info"
104850>>>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
104851>>>>>>>        Set peAnchors to anTopRight
104852>>>>>>>
104852>>>>>>>        Procedure OnClick
104855>>>>>>>            Object oSysInfoDialog is a SysInfoDialog
104857>>>>>>>            End_Object
104858>>>>>>>
104858>>>>>>>            Send Popup of oSysInfoDialog
104859>>>>>>>        End_Procedure
104860>>>>>>>    End_Object
104861>>>>>>>
104861>>>>>>>    Object oDriverIniFile_fm is a cRDCForm
104863>>>>>>>        Set Size to 13 193
104864>>>>>>>        Set Location to 39 90
104865>>>>>>>        Set Label_Col_Offset to 2
104866>>>>>>>        Set Label_Justification_Mode to JMode_Right
104867>>>>>>>        Set Label to "Driver Configuration File"
104868>>>>>>>        Set peAnchors to anTopLeftRight
104869>>>>>>>        Set Color to clBtnFace
104870>>>>>>>        Set Focus_Mode to NonFocusable
104871>>>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
104873>>>>>>>        Set Status_Help to (psOrgToolTip(Self))
104874>>>>>>>    End_Object
104875>>>>>>>
104875>>>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
104877>>>>>>>        Set Size to 13 50
104878>>>>>>>        Set Label to "Edit File"
104879>>>>>>>        Set Location to 39 287
104880>>>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
104881>>>>>>>        Set psImage to "ActionEdit1.ico"
104882>>>>>>>        Set peAnchors to anTopRight
104883>>>>>>>        Set pbAutoEnable to True
104884>>>>>>>
104884>>>>>>>        Procedure OnClick
104887>>>>>>>            String sFileName
104887>>>>>>>            Get Value of oDriverIniFile_fm to sFileName
104888>>>>>>>            If (sFileName <> DATAFLEX_ID) Begin
104890>>>>>>>                Runprogram Background "Notepad.exe" sFileName
104891>>>>>>>            End
104891>>>>>>>>
104891>>>>>>>            Else Begin
104892>>>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
104893>>>>>>>            End
104893>>>>>>>>
104893>>>>>>>        End_Procedure   
104894>>>>>>>        
104894>>>>>>>        Function IsEnabled Returns Boolean
104897>>>>>>>            String sFileName
104897>>>>>>>            Get Value of oDriverFileName_cf to sFileName
104898>>>>>>>            Function_Return (sFileName <> "")
104899>>>>>>>        End_Function
104900>>>>>>>
104900>>>>>>>    End_Object
104901>>>>>>>
104901>>>>>>>    Object oDumpDriverData_Btn is a cRDCButton
104903>>>>>>>        Set Size to 13 50
104904>>>>>>>        Set Label to "Dump"
104905>>>>>>>        Set Location to 54 233
104906>>>>>>>        Set peAnchors to anTopRight
104907>>>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
104908>>>>>>>        Set psImage to "ActionExport1.ico"
104909>>>>>>>        Set pbAutoEnable to True
104910>>>>>>>        
104910>>>>>>>        Procedure OnClick
104913>>>>>>>            Handle hoCLI
104913>>>>>>>            String sDriver sPath sFileName
104913>>>>>>>            Integer iRetval
104913>>>>>>>
104913>>>>>>>            Get psDriverID to sDriver
104914>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
104915>>>>>>>            Set psDriverID of hoCLI  to sDriver
104916>>>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
104918>>>>>>>                Send Destroy of hoCLI
104919>>>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
104920>>>>>>>                Procedure_Return
104921>>>>>>>            End
104921>>>>>>>>
104921>>>>>>>
104921>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
104922>>>>>>>            Get vFolderFormat sPath to sPath
104923>>>>>>>            Move (sDriver + "dump.txt") to sFileName
104924>>>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
104925>>>>>>>            Send Destroy of hoCLI
104926>>>>>>>
104926>>>>>>>            Send vShellExecute "open" sFileName "" sPath
104927>>>>>>>            Sleep 1
104928>>>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
104929>>>>>>>        End_Procedure
104930>>>>>>>
104930>>>>>>>        Function IsEnabled Returns Boolean
104933>>>>>>>            String sFileName
104933>>>>>>>            Boolean bDriverLoadingError 
104933>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
104934>>>>>>>            Get Value of oDriverFileName_cf to sFileName
104935>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
104936>>>>>>>        End_Function
104937>>>>>>>
104937>>>>>>>    End_Object
104938>>>>>>>
104938>>>>>>>    Object oReset_Btn is a cRDCButton
104940>>>>>>>        Set Size to 13 50
104941>>>>>>>        Set Label to "Refresh"
104942>>>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
104943>>>>>>>        Set Location to 54 287
104944>>>>>>>        Set psImage to "ActionRefresh1.ico"
104945>>>>>>>        Set peAnchors to anTopRight
104946>>>>>>>        Set pbAutoEnable to True
104947>>>>>>>
104947>>>>>>>        Procedure OnClick
104950>>>>>>>            String sDriver
104950>>>>>>>            Get psDriverID to sDriver
104951>>>>>>>            Unload_Driver sDriver
104952>>>>>>>            Load_Driver sDriver
104953>>>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
104954>>>>>>>            Send Close_Panel
104955>>>>>>>        End_Procedure
104956>>>>>>>
104956>>>>>>>        Function IsEnabled Returns Boolean
104959>>>>>>>            String sFileName
104959>>>>>>>            Boolean bDriverLoadingError 
104959>>>>>>>            Get pbDriverLoadingError to bDriverLoadingError
104960>>>>>>>            Get Value of oDriverFileName_cf to sFileName
104961>>>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
104962>>>>>>>        End_Function
104963>>>>>>>
104963>>>>>>>    End_Object
104964>>>>>>>
104964>>>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
104966>>>>>>>        Set Size to 125 328
104967>>>>>>>        Set Location to 74 9
104968>>>>>>>        Set psImage to "DriverSettings1.ico"
104969>>>>>>>        Set Label to "Driver Configuration File Settings"   
104970>>>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
104971>>>>>>>        Set peAnchors to anAll
104972>>>>>>>
104972>>>>>>>        Object oInvisible_Container is a Container3d
104974>>>>>>>            Set Size to 100 327
104975>>>>>>>            Set Location to 24 0
104976>>>>>>>            Set Border_Style to Border_None
104977>>>>>>>            Set peAnchors to anAll
104978>>>>>>>    
104978>>>>>>>            Object oScrollingContainer is a cScrollingContainer
104980>>>>>>>               
104980>>>>>>>                Object oScrollingClientArea is a cScrollingClientArea
104982>>>>>>>
104982>>>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
104982>>>>>>>                    // and one object will automatically be created for each attribute
104982>>>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
104982>>>>>>>                    Function GeneralDriverAttributes Returns String[]
104985>>>>>>>                        String[] sAttributesArray
104986>>>>>>>    
104986>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
104987>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
104988>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
104989>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
104990>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
104991>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
104992>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
104993>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
104994>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
104995>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
104996>>>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
104997>>>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
104998>>>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
104999>>>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
105000>>>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
105001>>>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
105002>>>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
105003>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
105004>>>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
105005>>>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
105006>>>>>>>    
105006>>>>>>>                        // Exception to the rule!
105006>>>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
105006>>>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
105006>>>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
105006>>>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
105007>>>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
105008>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
105009>>>>>>>    
105009>>>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
105010>>>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
105011>>>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
105012>>>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
105013>>>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
105014>>>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
105015>>>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
105016>>>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
105017>>>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
105018>>>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
105019>>>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
105020>>>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
105021>>>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
105022>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
105023>>>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
105024>>>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
105025>>>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
105026>>>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
105027>>>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
105028>>>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
105029>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
105030>>>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
105031>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
105032>>>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
105033>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
105034>>>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
105035>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
105036>>>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
105037>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
105038>>>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
105039>>>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
105040>>>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
105041>>>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
105042>>>>>>>    
105042>>>>>>>                        // Sort items alphabetically
105042>>>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
105043>>>>>>>                        Function_Return sAttributesArray
105044>>>>>>>                    End_Function
105045>>>>>>>    
105045>>>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
105048>>>>>>>                        String sAttribute sTmp
105048>>>>>>>                        Integer iPos
105048>>>>>>>    
105048>>>>>>>                        Move (Pos("|", sValue)) to iPos
105049>>>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
105050>>>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
105051>>>>>>>                        Move (Trim(sAttribute)) to sAttribute
105052>>>>>>>                        Move (Eval(sTmp)) to iAttribute
105053>>>>>>>    
105053>>>>>>>                        Function_Return sAttribute
105054>>>>>>>                    End_Function
105055>>>>>>>    
105055>>>>>>>                    // Note: Creates dynamic objects.
105055>>>>>>>                    // They are not being destroyed by this method.
105055>>>>>>>                    // It is the reponsibility of the calling method to do that,
105055>>>>>>>                    // prior calling this method.
105055>>>>>>>                    Procedure DoReadDriverSettings String sDriver
105058>>>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
105058>>>>>>>                        Handle ho hoParent
105058>>>>>>>                        String[] sAttributesArray
105059>>>>>>>                        String sValue sAttribute sDriverIniFile 
105059>>>>>>>                        Boolean bDriverLoadingError
105059>>>>>>>    
105059>>>>>>>                        Move (Self) to hoParent
105060>>>>>>>                        Move 13  to iHfactor // Height offset between form
105061>>>>>>>                        Move 120 to iLocW
105062>>>>>>>                        Move 10  to iLocH                            
105063>>>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
105064>>>>>>>    
105064>>>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
105065>>>>>>>                        If (Trim(sDriverIniFile) = "") Begin
105067>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
105068>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
105069>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
105070>>>>>>>                            Set Label of ho to "No Driver Configuration File found!"
105071>>>>>>>                            Set Value of ho to "No attributes to display..."   
105072>>>>>>>                            Procedure_Return
105073>>>>>>>                        End
105073>>>>>>>>
105073>>>>>>>                            
105073>>>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
105073>>>>>>>                        // so notify and quite.
105073>>>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
105075>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
105076>>>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
105077>>>>>>>                            Set Location of ho to iLocH (iLocW + 30)
105078>>>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
105079>>>>>>>                            Set Value of ho to "Sorry, no attributes to display"
105080>>>>>>>                            Procedure_Return
105081>>>>>>>                        End
105081>>>>>>>>
105081>>>>>>>    
105081>>>>>>>                        Get GeneralDriverAttributes to sAttributesArray
105082>>>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
105083>>>>>>>                        Decrement iItems
105084>>>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
105085>>>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
105086>>>>>>>    
105086>>>>>>>                        For iCount from 0 to iItems
105092>>>>>>>>
105092>>>>>>>                            Move sAttributesArray[iCount] to sValue
105093>>>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
105094>>>>>>>    
105094>>>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
105095>>>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
105096>>>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
105097>>>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
105098>>>>>>>                            If (bDriverLoadingError = True) Begin
105100>>>>>>>                                Set Label of ho to "Driver could not be loaded!"   
105101>>>>>>>                                If (Trim(sDriverIniFile) = "") Begin
105103>>>>>>>                                    Set Value of ho to "Driver .dll file not found!"
105104>>>>>>>                                End
105104>>>>>>>>
105104>>>>>>>                                Else Begin
105105>>>>>>>                                    Set Value of ho to "No attributes to display..."   
105106>>>>>>>                                End
105106>>>>>>>>
105106>>>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
105107>>>>>>>                                Delegate Set pbDriverLoadingError to True
105109>>>>>>>                                Move iItems to iCount // We're out of here.   
105110>>>>>>>                                Move False to Err
105111>>>>>>>                            End
105111>>>>>>>>
105111>>>>>>>                            If (Err = True) Begin
105113>>>>>>>                                Send Destroy of ho
105114>>>>>>>                            End
105114>>>>>>>>
105114>>>>>>>                            Else Begin
105115>>>>>>>                                If (iCount = 0) Begin
105117>>>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
105118>>>>>>>                                End
105118>>>>>>>>
105118>>>>>>>                                Set Location of ho to iLocH (iLocW + 30)
105119>>>>>>>                                Move (iLocH + iHfactor) to iLocH
105120>>>>>>>                            End
105120>>>>>>>>
105120>>>>>>>                        Loop
105121>>>>>>>>
105121>>>>>>>    
105121>>>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
105122>>>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
105123>>>>>>>                    End_Procedure
105124>>>>>>>    
105124>>>>>>>                End_Object
105125>>>>>>>
105125>>>>>>>            End_Object
105126>>>>>>>    
105126>>>>>>>        End_Object
105127>>>>>>>
105127>>>>>>>    End_Object
105128>>>>>>>
105128>>>>>>>    Object oInfo_edt is a cRichEdit
105130>>>>>>>        Set Size to 49 328
105131>>>>>>>        Set Location to 213 9
105132>>>>>>>        Set Label to "General Connectivity Kit Information:"
105133>>>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
105134>>>>>>>        Set Skip_State to True
105135>>>>>>>        Set Read_Only_State to True
105136>>>>>>>        Set pbItalics to True
105137>>>>>>>        Set peAnchors to anBottomLeftRight
105138>>>>>>>
105138>>>>>>>        Procedure DoIndent
105141>>>>>>>            Integer iTwipsPerInch iCurrentIndent
105141>>>>>>>        
105141>>>>>>>            // number of twips per inch
105141>>>>>>>            Move 1440 to iTwipsPerInch
105142>>>>>>>        
105142>>>>>>>            Set piSpacingBefore to (1440 * 0.05)
105143>>>>>>>            // indent 0.1 inches from current indentation
105143>>>>>>>            Get piParagraphIndent to iCurrentIndent
105144>>>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
105145>>>>>>>        End_Procedure
105146>>>>>>>        Send DoIndent
105147>>>>>>>
105147>>>>>>>    End_Object
105148>>>>>>>
105148>>>>>>>    Procedure Activating
105151>>>>>>>        Forward Send Activating
105153>>>>>>>        Send Cursor_Ready of Cursor_Control
105154>>>>>>>    End_Procedure
105155>>>>>>>
105155>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
105156>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
105157>>>>>>>End_Object
105158>>>>>>>
105158>>>>>>>// General purpose access method for the dialog above:
105158>>>>>>>Procedure PopupDriverSettings String sDriverID 
105161>>>>>>>    Handle ho
105161>>>>>>>    String sDriverFile sPath
105161>>>>>>>
105161>>>>>>>    Send Cursor_Wait of Cursor_Control
105162>>>>>>>    Move (oDriverSettings_dg(Self)) to ho
105163>>>>>>>    Set psDriverID of ho to sDriverID
105164>>>>>>>    Set pbDriverLoadingError of ho to False
105165>>>>>>>
105165>>>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
105166>>>>>>>    Get DatabaseDriverPath sDriverID to sPath
105167>>>>>>>    If (sPath <> "") Begin
105169>>>>>>>        Move (sDriverID + ".dll")  to sDriverFile
105170>>>>>>>    End
105170>>>>>>>>
105170>>>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
105171>>>>>>>    Send Cursor_Ready of Cursor_Control
105172>>>>>>>
105172>>>>>>>    Send Popup of ho
105173>>>>>>>End_Procedure
105174>>>>>>>
105174>>>>>>>Function DatabaseDriverPath String sDriverID Returns String
105177>>>>>>>    String sPath sDriverFileName
105177>>>>>>>
105177>>>>>>>    Move "" to sPath
105178>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
105180>>>>>>>        Function_Return sPath
105181>>>>>>>    End                   
105181>>>>>>>>
105181>>>>>>>    
105181>>>>>>>    Move (sDriverID + ".dll") to sDriverFileName
105182>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
105183>>>>>>>    
105183>>>>>>>    Function_Return sPath
105184>>>>>>>End_Function      
105185>>>>>>>
105185>>>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
105188>>>>>>>    String sPath sDriverFileName
105188>>>>>>>
105188>>>>>>>    Move "" to sPath
105189>>>>>>>    If (sDriverID = DATAFLEX_ID) Begin
105191>>>>>>>        Function_Return sPath
105192>>>>>>>    End                   
105192>>>>>>>>
105192>>>>>>>    
105192>>>>>>>    Move (sDriverID + ".int") to sDriverFileName
105193>>>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
105194>>>>>>>    
105194>>>>>>>    Function_Return sPath
105195>>>>>>>End_Function      
105196>>>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
105196>>>>>>>Use Windows.pkg
105196>>>>>>>Use cRDCModalPanel.pkg
105196>>>>>>>Use cRDCForm.pkg 
105196>>>>>>>Use cRDCComboForm.pkg
105196>>>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSuggestionIniForm.pkg)
105196>>>>>>>>>//****************************************************************************
105196>>>>>>>>>// $Module type: Class
105196>>>>>>>>>// $Module name: cRDCSuggestionIniForm
105196>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
105196>>>>>>>>>// Web-site    : http://www.rdctools.com
105196>>>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
105196>>>>>>>>>//
105196>>>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
105196>>>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
105196>>>>>>>>>//
105196>>>>>>>>>// $Rev History:
105196>>>>>>>>>//    2018-09-05  Module header created
105196>>>>>>>>>//
105196>>>>>>>>>//****************************************************************************
105196>>>>>>>>>Use Windows.pkg
105196>>>>>>>>>Use Windows.pkg
105196>>>>>>>>>Use WinSuggestion.pkg
105196>>>>>>>>>Use cIniFile.pkg            
105196>>>>>>>>>Use cRDCForm.pkg
105196>>>>>>>>>Use vWin32fh.pkg
105196>>>>>>>>>
105196>>>>>>>>>    Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
105196>>>>>>>>>    Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
105196>>>>>>>>>    Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
105196>>>>>>>>>
105196>>>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
105197>>>>>>>>>
105197>>>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
105199>>>>>>>>>
105199>>>>>>>>>        Property Integer piTimeOutTicks 0
105200>>>>>>>>>
105200>>>>>>>>>        On_Key kEnter            Send SelectSuggestion
105201>>>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
105202>>>>>>>>>        On_Key Key_Up_Arrow      Send Up
105203>>>>>>>>>        On_Key Key_Down_Arrow    Send Down
105204>>>>>>>>>
105204>>>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
105204>>>>>>>>>        On_Key Key_Home          Send Home
105205>>>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
105206>>>>>>>>>        On_Key Key_End           Send End
105207>>>>>>>>>        On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
105208>>>>>>>>>
105208>>>>>>>>>        // Just can't seem to get the popup of the suggestion list with F4 to work.
105208>>>>>>>>>        On_Key kPrompt           Send Prompt
105209>>>>>>>>>    End_Procedure
105210>>>>>>>>>
105210>>>>>>>>>    Import_Class_Protocol cSuggestionControl_mixin
105211>>>>>>>>>    Import_Class_Protocol cSuggestion_mixin
105212>>>>>>>>>
105212>>>>>>>>>    Procedure Construct_Object
105214>>>>>>>>>        Forward Send Construct_Object
105216>>>>>>>>>        Send Define_cRDCSuggestionControl_mixin
105217>>>>>>>>>        Send Define_cSuggestion_mixin
105218>>>>>>>>>
105218>>>>>>>>>        Set peSuggestionMode to smCustom
105219>>>>>>>>>        Set pbFullText to True
105220>>>>>>>>>        Set piStartAtChar to 1
105221>>>>>>>>>
105221>>>>>>>>>        Property String[] psSavedFormValues
105222>>>>>>>>>        Property String psIniFileSection
105223>>>>>>>>>        Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
105224>>>>>>>>>        Property Boolean pbUseWorkspaceIniFile True
105225>>>>>>>>>        Property Boolean pbAutoCheckValueExistsAsFile True
105226>>>>>>>>>        Property Boolean pbAskToRemoveMissingFile True
105227>>>>>>>>>        // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
105227>>>>>>>>>        //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
105227>>>>>>>>>        //       worspace .ws file on program startup.
105227>>>>>>>>>        Property String psIniFileName "RDCSuggestionForm.ini"
105228>>>>>>>>>    End_Procedure
105229>>>>>>>>>
105229>>>>>>>>>    Procedure ShowSuggestions
105231>>>>>>>>>        tSuggestion[] aResults
105231>>>>>>>>>        tSuggestion[] aResults
105232>>>>>>>>>        Integer i iLines
105232>>>>>>>>>        String sSearch
105232>>>>>>>>>
105232>>>>>>>>>
105232>>>>>>>>>        Get pSearchResults to aResults
105233>>>>>>>>>        Get Value to sSearch
105234>>>>>>>>>
105234>>>>>>>>>        If (ghoSuggestionList <> 0) Begin
105236>>>>>>>>>            Send Delete_Data of ghoSuggestionList
105237>>>>>>>>>            Move (SizeOfArray(aResults)) to iLines
105238>>>>>>>>>            For i from 0 to (iLines-1)
105244>>>>>>>>>>
105244>>>>>>>>>                Send ShowSuggestion aResults[i] sSearch
105245>>>>>>>>>                If ((iLines-1)<>i) Begin
105247>>>>>>>>>                    Send AppendTextLn of ghoSuggestionList ""
105248>>>>>>>>>                End
105248>>>>>>>>>>
105248>>>>>>>>>            Loop
105249>>>>>>>>>>
105249>>>>>>>>>            Send AdjustSuggestionListSize iLines
105250>>>>>>>>>        End
105250>>>>>>>>>>
105250>>>>>>>>>
105250>>>>>>>>>        Set Cursor of Cursor_Control to IDC_ARROW
105251>>>>>>>>>        Send Activate of (Self)
105252>>>>>>>>>        Send Release_Mouse_Capture
105253>>>>>>>>>    End_Procedure
105254>>>>>>>>>
105254>>>>>>>>>    Procedure Home
105256>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
105258>>>>>>>>>           Send ScrollHome
105259>>>>>>>>>        End
105259>>>>>>>>>>
105259>>>>>>>>>        Else Begin
105260>>>>>>>>>            Send Key VK_HOME
105261>>>>>>>>>        End
105261>>>>>>>>>>
105261>>>>>>>>>    End_Procedure
105262>>>>>>>>>
105262>>>>>>>>>    Procedure ScrollHome
105264>>>>>>>>>        Send SelectRow of ghoSuggestionList 0
105265>>>>>>>>>    End_Procedure
105266>>>>>>>>>
105266>>>>>>>>>    Procedure End
105268>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
105270>>>>>>>>>           Send ScrollEnd
105271>>>>>>>>>        End
105271>>>>>>>>>>
105271>>>>>>>>>        Else Begin
105272>>>>>>>>>            Send Key VK_END
105273>>>>>>>>>        End
105273>>>>>>>>>>
105273>>>>>>>>>    End_Procedure
105274>>>>>>>>>
105274>>>>>>>>>    Procedure ScrollEnd
105276>>>>>>>>>        Integer iLine iLines
105276>>>>>>>>>        Get Line_Count of ghoSuggestionList  to iLines
105277>>>>>>>>>        Get SelectedRow of ghoSuggestionList to iLine
105278>>>>>>>>>        // there can be an extra line at the end
105278>>>>>>>>>        If (iLine < iLines - 1) Begin
105280>>>>>>>>>            Send SelectRow of ghoSuggestionList (iLines - 1)
105281>>>>>>>>>        End
105281>>>>>>>>>>
105281>>>>>>>>>    End_Procedure
105282>>>>>>>>>
105282>>>>>>>>>    Procedure Activating
105284>>>>>>>>>        String[] sSavedFormValues
105285>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = True) Begin
105287>>>>>>>>>            Get ReadWorkspaceIniFile to sSavedFormValues
105288>>>>>>>>>            Set psSavedFormValues    to sSavedFormValues
105289>>>>>>>>>        End
105289>>>>>>>>>>
105289>>>>>>>>>    End_Procedure
105290>>>>>>>>>
105290>>>>>>>>>    Procedure Set psToolTip String sToolTip
105292>>>>>>>>>        String sStatusHelp
105292>>>>>>>>>
105292>>>>>>>>>        Get Status_Help to sStatusHelp
105293>>>>>>>>>        If (sStatusHelp = "") Begin
105295>>>>>>>>>            Set Status_Help to sToolTip
105296>>>>>>>>>        End
105296>>>>>>>>>>
105296>>>>>>>>>
105296>>>>>>>>>        Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
105297>>>>>>>>>        Forward Set psToolTip to sToolTip
105299>>>>>>>>>    End_Procedure
105300>>>>>>>>>
105300>>>>>>>>>    Function ReadWorkspaceIniFile Returns String[]
105302>>>>>>>>>        String sWorkspaceFile sObjectName sValue
105302>>>>>>>>>        String[] sSavedFormValues
105303>>>>>>>>>        Handle hoIniFile
105303>>>>>>>>>        Integer iItem iCount iSize
105303>>>>>>>>>        Boolean bExists
105303>>>>>>>>>
105303>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
105305>>>>>>>>>            Function_Return sSavedFormValues
105306>>>>>>>>>        End
105306>>>>>>>>>>
105306>>>>>>>>>
105306>>>>>>>>>        Move 0 to iItem
105307>>>>>>>>>        Get Object_Label to sObjectName
105308>>>>>>>>>        Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
105309>>>>>>>>>        Set psIniFileName to sWorkspaceFile
105310>>>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
105311>>>>>>>>>        Set psFileName of hoIniFile to sWorkspaceFile
105312>>>>>>>>>        Get piSuggestionListMaxItems to iSize
105313>>>>>>>>>
105313>>>>>>>>>        For iCount from 0 to iSize
105319>>>>>>>>>>
105319>>>>>>>>>            Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
105320>>>>>>>>>            // We need to loop through all possible values because the list of items may not start at zero.
105320>>>>>>>>>            Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
105321>>>>>>>>>            If (Trim(sValue) <> "") Begin
105323>>>>>>>>>                Move sValue to sSavedFormValues[iItem]
105324>>>>>>>>>                Increment iItem
105325>>>>>>>>>            End
105325>>>>>>>>>>
105325>>>>>>>>>        Loop
105326>>>>>>>>>>
105326>>>>>>>>>
105326>>>>>>>>>        Send Destroy of hoIniFile
105327>>>>>>>>>        Function_Return sSavedFormValues
105328>>>>>>>>>    End_Function
105329>>>>>>>>>
105329>>>>>>>>>    Procedure WriteWorkspaceIniFile
105331>>>>>>>>>        String sWorkspaceFile sObjectName sValue
105331>>>>>>>>>        String[] sSavedFormValues
105332>>>>>>>>>        Handle hoIniFile
105332>>>>>>>>>        Integer iSize iCount
105332>>>>>>>>>        Boolean bExists
105332>>>>>>>>>
105332>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
105334>>>>>>>>>            Procedure_Return
105335>>>>>>>>>        End
105335>>>>>>>>>>
105335>>>>>>>>>
105335>>>>>>>>>        Get Object_Label  to sObjectName
105336>>>>>>>>>        Get psIniFileName to sWorkspaceFile
105337>>>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
105338>>>>>>>>>        Set psFileName    of hoIniFile to sWorkspaceFile
105339>>>>>>>>>        Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
105340>>>>>>>>>        If (bExists = True) Begin
105342>>>>>>>>>            Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
105343>>>>>>>>>        End
105343>>>>>>>>>>
105343>>>>>>>>>
105343>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
105344>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
105345>>>>>>>>>        Decrement iSize
105346>>>>>>>>>
105346>>>>>>>>>        For iCount from 0 to iSize
105352>>>>>>>>>>
105352>>>>>>>>>            Move sSavedFormValues[iCount] to sValue
105353>>>>>>>>>            Move (Trim(sValue)) to sValue
105354>>>>>>>>>            Get vFilePathExists sValue to bExists
105355>>>>>>>>>            If (bExists = True) Begin
105357>>>>>>>>>                Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
105358>>>>>>>>>            End
105358>>>>>>>>>>
105358>>>>>>>>>        Loop
105359>>>>>>>>>>
105359>>>>>>>>>
105359>>>>>>>>>        Send Destroy of hoIniFile
105360>>>>>>>>>    End_Procedure
105361>>>>>>>>>
105361>>>>>>>>>    Procedure Prompt      
105363>>>>>>>>>        If (ghoSuggestionTimer=0) Begin
105365>>>>>>>>>            Send CreateSuggestionTimer
105366>>>>>>>>>        End
105366>>>>>>>>>>
105366>>>>>>>>>        Send ActivateSuggestionList
105367>>>>>>>>>        Send FindSuggestions
105368>>>>>>>>>        Set Visible_State of ghoSuggestionList to True
105369>>>>>>>>>    End_Procedure 
105370>>>>>>>>>    
105370>>>>>>>>>    Procedure OnExitObject
105372>>>>>>>>>        String sValue
105372>>>>>>>>>        Boolean bExists
105372>>>>>>>>>        String[] sSavedFormValues
105373>>>>>>>>>        Integer iSize iIndex
105373>>>>>>>>>
105373>>>>>>>>>        Forward Send OnExitObject
105375>>>>>>>>>
105375>>>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
105377>>>>>>>>>            Procedure_Return
105378>>>>>>>>>        End
105378>>>>>>>>>>
105378>>>>>>>>>
105378>>>>>>>>>        Get Value to sValue
105379>>>>>>>>>        Move (Trim(sValue)) to sValue
105380>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
105381>>>>>>>>>        Move (SearchArray(sValue, sSavedFormValues)) to iIndex
105382>>>>>>>>>        // Does it exist in the array already?
105382>>>>>>>>>        If (iIndex <> -1) Begin
105384>>>>>>>>>            Procedure_Return
105385>>>>>>>>>        End
105385>>>>>>>>>>
105385>>>>>>>>>        Get vFilePathExists sValue to bExists
105386>>>>>>>>>        If (bExists = False) Begin
105388>>>>>>>>>            Procedure_Return
105389>>>>>>>>>        End
105389>>>>>>>>>>
105389>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
105390>>>>>>>>>        Move sValue to sSavedFormValues[iSize]
105391>>>>>>>>>        Set psSavedFormValues to sSavedFormValues
105392>>>>>>>>>        Send WriteWorkspaceIniFile
105393>>>>>>>>>    End_Procedure
105394>>>>>>>>>
105394>>>>>>>>>    // Custom code to find all matches for the search
105394>>>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
105396>>>>>>>>>        String[] sSavedFormValues
105397>>>>>>>>>        Integer i iLen iSize iCount
105397>>>>>>>>>
105397>>>>>>>>>        Move (Lowercase(sSearch)) to sSearch
105398>>>>>>>>>        Move (Length(sSearch)) to iLen
105399>>>>>>>>>        Get psSavedFormValues to sSavedFormValues
105400>>>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
105401>>>>>>>>>        Decrement iSize
105402>>>>>>>>>        For i from 0 to iSize
105408>>>>>>>>>>
105408>>>>>>>>>            If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
105410>>>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
105411>>>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
105412>>>>>>>>>                Increment iCount
105413>>>>>>>>>            End
105413>>>>>>>>>>
105413>>>>>>>>>        Loop
105414>>>>>>>>>>
105414>>>>>>>>>    End_Procedure
105415>>>>>>>>>
105415>>>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
105417>>>>>>>>>        Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
105417>>>>>>>>>        Integer iRetval iIndex
105417>>>>>>>>>        String[] sSavedFormValues
105418>>>>>>>>>        String sValue
105418>>>>>>>>>
105418>>>>>>>>>//        Send Release_Mouse_Capture
105418>>>>>>>>>        Move Suggestion.sRowId to sValue
105419>>>>>>>>>        Move (Trim(sValue)) to sValue
105420>>>>>>>>>        Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
105421>>>>>>>>>
105421>>>>>>>>>        If (bAutoCheckValueExistsAsFile = True) Begin
105423>>>>>>>>>            Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
105424>>>>>>>>>            Get vFilePathExists sValue to bExists
105425>>>>>>>>>            If (bExists = False) Begin
105427>>>>>>>>>                If (bAskToRemoveMissingFile = True) Begin
105429>>>>>>>>>                    Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
105430>>>>>>>>>                End
105430>>>>>>>>>>
105430>>>>>>>>>                // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
105430>>>>>>>>>                // Then the missing file will just be removed from the saved list.
105430>>>>>>>>>                Else Begin
105431>>>>>>>>>                    Move MBR_Yes to iRetval
105432>>>>>>>>>                End
105432>>>>>>>>>>
105432>>>>>>>>>
105432>>>>>>>>>                If (iRetval = MBR_Yes) Begin
105434>>>>>>>>>                    Get psSavedFormValues to sSavedFormValues
105435>>>>>>>>>                    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
105436>>>>>>>>>                    If (iIndex <> -1) Begin
105438>>>>>>>>>                        Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
105439>>>>>>>>>                        Set psSavedFormValues to sSavedFormValues
105440>>>>>>>>>                        Send WriteWorkspaceIniFile
105441>>>>>>>>>                        Set Value to ""
105442>>>>>>>>>                        Procedure_Return
105443>>>>>>>>>                    End
105443>>>>>>>>>>
105443>>>>>>>>>                End
105443>>>>>>>>>>
105443>>>>>>>>>            End
105443>>>>>>>>>>
105443>>>>>>>>>        End
105443>>>>>>>>>>
105443>>>>>>>>>
105443>>>>>>>>>        Set Value to Suggestion.sRowId
105444>>>>>>>>>        Set Item_Changed_State to False
105445>>>>>>>>>    End_Procedure
105446>>>>>>>>>
105446>>>>>>>>>//    { MethodType=Event  NoDoc=True }
105446>>>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
105446>>>>>>>>>//        Send Release_Mouse_Capture
105446>>>>>>>>>//        Forward Send Mouse_click i1 i2
105446>>>>>>>>>//    End_Procedure
105446>>>>>>>>>
105446>>>>>>>>>End_Class
105447>>>>>>>>>
105447>>>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
105447>>>>>>>>>//        Handle hoObj
105447>>>>>>>>>//        Send Release_Mouse_Capture
105447>>>>>>>>>//        Get phoOwner to hoObj
105447>>>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
105447>>>>>>>>>//        Send SelectSuggestion of hoObj
105447>>>>>>>>>//    End_Procedure // Mouse_Up
105447>>>>>>>>>
105447>>>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
105447>>>>>>>>>//        tWinMouseHookStruct MouseHook
105447>>>>>>>>>//        Integer ivoid hObj
105447>>>>>>>>>//        Handle hoOwner hoParent
105447>>>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
105447>>>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
105447>>>>>>>>>//            Send Release_Mouse_Capture
105447>>>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
105447>>>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
105447>>>>>>>>>//            If (hObj = Cursor_Control) Begin
105447>>>>>>>>>//                Move (Focus(Desktop)) to hObj
105447>>>>>>>>>//            End
105447>>>>>>>>>//            Get Parent to hoParent
105447>>>>>>>>>//            Get phoOwner of hoParent to hoOwner
105447>>>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
105447>>>>>>>>>//                Send DisableWindowsHook
105447>>>>>>>>>//                Send DeActivateSuggestionList of hoOwner
105447>>>>>>>>>//            End
105447>>>>>>>>>//        End
105447>>>>>>>>>//    End_Function
105447>>>>>>>>>
105447>>>>>>>Use cDbUpdateFunctionLibrary.pkg
105447>>>>>>>Use cRDCHeaderGroup.pkg
105447>>>>>>>Use cCommandLinkButton.pkg
105447>>>>>>>
105447>>>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
105449>>>>>>>    Set Size to 151 312
105450>>>>>>>    Set Label to "Create New Database"
105451>>>>>>>    Set piMinSize to 53 211
105452>>>>>>>    Set Location to 2 2
105453>>>>>>>    Set Icon to "ActionCreateDatabase1.ico"
105454>>>>>>>    
105454>>>>>>>    Property String psDriverID                   
105456>>>>>>>    Property String psCollation 
105458>>>>>>>    Property String psDatabaseName 
105460>>>>>>>
105460>>>>>>>//    Object oCollate_cf is a cRDCComboForm
105460>>>>>>>//        Set Size to 13 216
105460>>>>>>>//        Set Location to 42 63
105460>>>>>>>//        Set Label to "Use Collation:"  
105460>>>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
105460>>>>>>>//        // This must be set to False; else the filling takes for ever.
105460>>>>>>>//        Set pbAutoListWidth to False
105460>>>>>>>//        
105460>>>>>>>//        Procedure Combo_Fill_List
105460>>>>>>>//            String[] asCollations   
105460>>>>>>>//            Integer iCount iSize      
105460>>>>>>>//            String sDriverID sCollation
105460>>>>>>>//            
105460>>>>>>>//            Get psDriverID to sDriverID      
105460>>>>>>>//            
105460>>>>>>>//            // The SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
105460>>>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
105460>>>>>>>//                Send Cursor_Wait of Cursor_Control
105460>>>>>>>//                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
105460>>>>>>>//                Move (SizeOfArray(asCollations)) to iSize
105460>>>>>>>//                Decrement iSize
105460>>>>>>>//                For iCount from 0 to iSize
105460>>>>>>>//                    Send Combo_Add_Item asCollations[iCount]
105460>>>>>>>//                Loop
105460>>>>>>>//                
105460>>>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
105460>>>>>>>//                Set Value to sCollation
105460>>>>>>>//                Send Cursor_Ready of Cursor_Control
105460>>>>>>>//            End
105460>>>>>>>//        End_Procedure
105460>>>>>>>//    
105460>>>>>>>//        Procedure OnChange
105460>>>>>>>//            String sValue
105460>>>>>>>//            Get Value to sValue
105460>>>>>>>//            Set psCollation to sValue
105460>>>>>>>//        End_Procedure
105460>>>>>>>//     
105460>>>>>>>//    End_Object
105460>>>>>>>
105460>>>>>>>    Object oInfo_tb is a TextBox
105462>>>>>>>        Set Auto_Size_State to False
105463>>>>>>>        Set Size to 8 50
105464>>>>>>>        Set Location to 133 120
105465>>>>>>>        Set TextColor to clGreen
105466>>>>>>>        Set Justification_Mode to JMode_Right
105467>>>>>>>        Set peAnchors to anBottomRight
105468>>>>>>>    End_Object
105469>>>>>>>
105469>>>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
105471>>>>>>>        Set Size to 108 293
105472>>>>>>>        Set Location to 8 10
105473>>>>>>>        Set psImage to "ActionCreateDatabase1.ico"
105474>>>>>>>        Set Label to "Create Database"
105475>>>>>>>        Set psNote to "Enter collation and database name"
105476>>>>>>>        Set peAnchors to anTopBottom
105477>>>>>>>
105477>>>>>>>        Object oDriver_fm is a cRDCForm
105479>>>>>>>            Set Size to 13 100
105480>>>>>>>            Set Location to 34 63
105481>>>>>>>            Set Label to "Driver"
105482>>>>>>>            Set Enabled_State to False  
105483>>>>>>>        End_Object  
105484>>>>>>>        
105484>>>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
105486>>>>>>>            Set Size to 13 216
105487>>>>>>>            Set Location to 49 63
105488>>>>>>>            Set Label to "Default Collation"
105489>>>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
105490>>>>>>>            Set Enabled_State to False  
105491>>>>>>>            
105491>>>>>>>            Procedure InitializeCollation 
105494>>>>>>>                String sCollation
105494>>>>>>>                
105494>>>>>>>                Move False to Err
105495>>>>>>>                Send Ignore_All of Error_Object_Id
105496>>>>>>>                // Fetch the SQL server's default collation:
105496>>>>>>>                // It will be used when creating a new database, if nothing else is specified.
105496>>>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
105497>>>>>>>                Send Trap_All of Error_Object_Id
105498>>>>>>>                If (Err = True) Begin
105500>>>>>>>                    Move "" to sCollation
105501>>>>>>>                End
105501>>>>>>>>
105501>>>>>>>                Set Value to sCollation
105502>>>>>>>            End_Procedure     
105503>>>>>>>    
105503>>>>>>>        End_Object  
105504>>>>>>>        
105504>>>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
105506>>>>>>>            Set Size to 13 216
105507>>>>>>>            Set Location to 65 63
105508>>>>>>>            Set Label to "Collation"
105509>>>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
105510>>>>>>>            Set pbAskToRemoveMissingFile to False
105511>>>>>>>            Set pbAutoCheckValueExistsAsFile to False
105512>>>>>>>            Set pbUseWorkspaceIniFile to True
105513>>>>>>>            Set piStartAtChar to 3
105514>>>>>>>            Set Prompt_Button_Mode to PB_PromptOn
105515>>>>>>>            
105515>>>>>>>            Function ReadWorkspaceIniFile Returns String[]
105518>>>>>>>                String[] asCollations   
105519>>>>>>>                Integer iCount iSize      
105519>>>>>>>                String sDriverID sCollation
105519>>>>>>>                
105519>>>>>>>                Get psDriverID to sDriverID      
105520>>>>>>>                // The SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
105520>>>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
105522>>>>>>>                    Function_Return asCollations
105523>>>>>>>                End                 
105523>>>>>>>>
105523>>>>>>>                
105523>>>>>>>                Send Cursor_Wait of Cursor_Control
105524>>>>>>>                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
105525>>>>>>>                Set psSavedFormValues to asCollations
105526>>>>>>>                    
105526>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
105528>>>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
105529>>>>>>>                    Set Value to sCollation
105530>>>>>>>                End
105530>>>>>>>>
105530>>>>>>>                Send Cursor_Ready of Cursor_Control
105531>>>>>>>                Function_Return asCollations
105532>>>>>>>            End_Function
105533>>>>>>>    
105533>>>>>>>            Procedure OnChange
105536>>>>>>>                String sValue
105536>>>>>>>                Get Value to sValue
105537>>>>>>>                Set psCollation to sValue
105538>>>>>>>            End_Procedure
105539>>>>>>>         
105539>>>>>>>            Procedure WriteWorkspaceIniFile
105542>>>>>>>            End_Procedure             
105543>>>>>>>            
105543>>>>>>>//            Procedure Prompt      
105543>>>>>>>//                If (ghoSuggestionTimer=0) Begin
105543>>>>>>>//                    Send CreateSuggestionTimer
105543>>>>>>>//                End
105543>>>>>>>//                Send ActivateSuggestionList
105543>>>>>>>//                Send FindSuggestions
105543>>>>>>>//                Set Visible_State of ghoSuggestionList to True
105543>>>>>>>//            End_Procedure 
105543>>>>>>>            
105543>>>>>>>            Procedure OnEnterObject
105546>>>>>>>                Set pbUseWorkspaceIniFile to True
105547>>>>>>>                Forward Send OnEnterObject
105549>>>>>>>            End_Procedure
105550>>>>>>>
105550>>>>>>>            Procedure OnExitObject
105553>>>>>>>                Set pbUseWorkspaceIniFile to False
105554>>>>>>>                Forward Send OnExitObject
105556>>>>>>>            End_Procedure
105557>>>>>>>        
105557>>>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
105558>>>>>>>//            On_Key kPrompt Send Prompt
105558>>>>>>>        End_Object   
105559>>>>>>>        
105559>>>>>>>        Object oDatabaseName_fm is a cRDCForm
105561>>>>>>>            Set Size to 13 216
105562>>>>>>>            Set Location to 81 63
105563>>>>>>>            Set Label_Col_Offset to 2
105564>>>>>>>            Set Label_Justification_Mode to JMode_Right
105565>>>>>>>            Set Label to "Database Name"
105566>>>>>>>            Set psToolTip to "Specify the name of the database to be created."
105567>>>>>>>        End_Object
105568>>>>>>>    
105568>>>>>>>    End_Object
105569>>>>>>>
105569>>>>>>>    Object oOK_Btn is a Button
105571>>>>>>>        Set Label    to "&OK"
105572>>>>>>>        Set Location to 130 198
105573>>>>>>>        Set peAnchors to anBottomRight   
105574>>>>>>>        
105574>>>>>>>        Property String psWorkingText "Working..."
105576>>>>>>>        Property String psIdleText    ""
105578>>>>>>>
105578>>>>>>>        Procedure OnClick
105581>>>>>>>            String sDatabase sDriverID sCollation
105581>>>>>>>            Boolean bOK bExists
105581>>>>>>>        
105581>>>>>>>            Get Value of oDatabaseName_fm to sDatabase    
105582>>>>>>>            Get psDriverID to sDriverID
105583>>>>>>>            Set psDatabaseName to ""
105584>>>>>>>
105584>>>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
105586>>>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
105587>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
105589>>>>>>>                    Get psCollation to sCollation
105590>>>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
105591>>>>>>>                End
105591>>>>>>>>
105591>>>>>>>
105591>>>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
105592>>>>>>>                If (bExists = True) Begin
105594>>>>>>>                    Set Value of oInfo_tb to ""
105595>>>>>>>                    Send Info_Box "The database already exists. No changes made."
105596>>>>>>>                    Procedure_Return
105597>>>>>>>                End
105597>>>>>>>>
105597>>>>>>>                Send Cursor_Wait of Cursor_Control     
105598>>>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
105599>>>>>>>                Send Cursor_Ready of Cursor_Control
105600>>>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
105601>>>>>>>                If (bOK = False) Begin
105603>>>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
105604>>>>>>>                    Procedure_Return
105605>>>>>>>                End 
105605>>>>>>>>
105605>>>>>>>                Set psDatabaseName to sDatabase
105606>>>>>>>                Send Close_Panel
105607>>>>>>>            End                                 
105607>>>>>>>>
105607>>>>>>>            Else If (sDatabase = "") Begin
105610>>>>>>>                Send Info_Box ("Please enter a database name and try again.")
105611>>>>>>>            End
105611>>>>>>>>
105611>>>>>>>        End_Procedure
105612>>>>>>>
105612>>>>>>>    End_Object
105613>>>>>>>
105613>>>>>>>    Object oCancel_Btn is a Button
105615>>>>>>>        Set Label    to "&Cancel"
105616>>>>>>>        Set Location to 130 253
105617>>>>>>>        Set peAnchors to anBottomRight
105618>>>>>>>
105618>>>>>>>        Procedure OnClick
105621>>>>>>>            Send Close_Panel
105622>>>>>>>        End_Procedure
105623>>>>>>>
105623>>>>>>>    End_Object
105624>>>>>>>
105624>>>>>>>    Object oHelp_btn is a Button
105626>>>>>>>        Set Location to 130 75
105627>>>>>>>        Set Label to "Help"
105628>>>>>>>        Set psImage to "ActionHelpInternet1.ico"
105629>>>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
105630>>>>>>>        Set peAnchors to anBottomLeft
105631>>>>>>>    
105631>>>>>>>        Procedure OnClick
105634>>>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
105635>>>>>>>        End_Procedure
105636>>>>>>>    
105636>>>>>>>    End_Object
105637>>>>>>>    
105637>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
105638>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
105639>>>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
105640>>>>>>>End_Object
105641>>>>>>>
105641>>>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
105644>>>>>>>    String sDatabaseName         
105644>>>>>>>    Handle ho
105644>>>>>>>    
105644>>>>>>>    Move (oCreateDatabase_dg(Self)) to ho
105645>>>>>>>    Set psDriverID of ho to sDriverID
105646>>>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
105647>>>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
105648>>>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
105649>>>>>>>    Send Popup of ho
105650>>>>>>>    
105650>>>>>>>    Get psDatabaseName of ho to sDatabaseName
105651>>>>>>>    Function_Return sDatabaseName
105652>>>>>>>End_Function                         
105653>>>>>
105653>>>>>Define CS_LoadingServers        for "Enumerating servers..."
105653>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
105653>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
105653>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
105653>>>>>Define CS_LoginAttempt          for "Connecting..."
105653>>>>>Define CS_LoginSuccessful       for "Login successful!"
105653>>>>>Define CS_LoginFailed           for "Login failed!"
105653>>>>>Define CS_DF_File_Schema        for "Schema"
105653>>>>>Define CS_DF_File_Owner         for "Owner"
105653>>>>>
105653>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
105655>>>>>    Set Label to "Edit SQL Connection"
105656>>>>>    Set Size to 315 324 //309 324
105657>>>>>    Set Location to 4 6
105658>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
105659>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
105660>>>>>    Set Locate_Mode to CENTER_ON_PARENT
105661>>>>>    Set Border_Style to Border_Thick
105662>>>>>    
105662>>>>>    Property Boolean pbReadOnly  False
105664>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
105666>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
105668>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
105670>>>>>    Property Handle phoDialogCommandbar
105672>>>>>    Property tSQLConnection pSQLConnectionData
105674>>>>>    Property tDataSourceRow[] pTheData
105676>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
105678>>>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
105680>>>>>
105680>>>>>    Object oSettings_grp is a cRDCHeaderGroup
105682>>>>>        Set Size to 202 303
105683>>>>>        Set Location to 77 11 //71 11
105684>>>>>        Set psImage to "Settings1.ico"
105685>>>>>        Set psLabel to "SQL Connection Settings"
105686>>>>>        Set peAnchors to anTopLeftRight
105687>>>>>        Set psToolTip to "Setup the SQL connection."
105688>>>>>
105688>>>>>        Object oConnectionID_fm is a cSQLForm
105690>>>>>            Set Size to 13 115
105691>>>>>            Set Location to 22 82
105692>>>>>            Set Label to "Connection ID"
105693>>>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
105694>>>>>            Set piItem to 2
105695>>>>>            Set peAnchors to anTopLeftRight
105696>>>>>        End_Object
105697>>>>>
105697>>>>>        Object oEnabled_cb is a cSQLCheckBox
105699>>>>>            Set Size to 10 36
105700>>>>>            Set Location to 25 210
105701>>>>>            Set Label to "Enabled"
105702>>>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
105703>>>>>            Set piItem to 1
105704>>>>>            Set peAnchors to anTopRight
105705>>>>>
105705>>>>>            Procedure OnChange
105708>>>>>                Boolean bChecked bNew
105708>>>>>                tSQLConnection SQLConnection
105708>>>>>                tSQLConnection SQLConnection
105708>>>>>
105708>>>>>                Get pbNew to bNew
105709>>>>>                Get Checked_State to bChecked
105710>>>>>                If (bNew = False and bChecked = True) Begin
105712>>>>>                    Get pSQLConnectionData to SQLConnection
105713>>>>>                    Move True to SQLConnection.bEnabled
105714>>>>>                End
105714>>>>>>
105714>>>>>
105714>>>>>            End_Procedure
105715>>>>>
105715>>>>>        End_Object
105716>>>>>
105716>>>>>        Object oODBC_rgp is a RadioGroup
105718>>>>>            Set Location to 38 24
105719>>>>>            Set Size to 32 173
105720>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
105720>>>>>            Set peAnchors to anTopLeftRight
105721>>>>>            Set Label to "ODBC Source Type"
105722>>>>>
105722>>>>>            Object oRadio0 is a Radio
105724>>>>>                Set Label to "User data"
105725>>>>>                Set Size to 10 44
105726>>>>>                Set Location to 12 5
105727>>>>>            End_Object
105728>>>>>
105728>>>>>            Object oRadio1 is a Radio
105730>>>>>                Set Label to "System data"
105731>>>>>                Set Size to 10 52
105732>>>>>                Set Location to 12 52
105733>>>>>            End_Object
105734>>>>>
105734>>>>>            Object oRadio2 is a Radio
105736>>>>>                Set Label to "Both"
105737>>>>>                Set Size to 10 26
105738>>>>>                Set Location to 13 109
105739>>>>>            End_Object
105740>>>>>
105740>>>>>            Object oRadio3 is a Radio
105742>>>>>                Set Label to "File"
105743>>>>>                Set Size to 10 25
105744>>>>>                Set Location to 13 141
105745>>>>>            End_Object
105746>>>>>
105746>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
105749>>>>>                Forward Send Notify_Select_State iToItem iFromItem 
105751>>>>>                If (oFileDSN_btn(Self) <> 0) Begin
105753>>>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
105754>>>>>                End
105754>>>>>>
105754>>>>>            End_Procedure
105755>>>>>
105755>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
105758>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
105759>>>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
105760>>>>>            End_Procedure
105761>>>>>
105761>>>>>            Set Current_Radio to 2
105762>>>>>        End_Object
105763>>>>>
105763>>>>>        Object oFileDSN_btn is a cRDCButton
105765>>>>>            Set Size to 13 78
105766>>>>>            Set Location to 42 210
105767>>>>>            Set Label to "Select File DSN..."
105768>>>>>            Set pbAutoEnable to True
105769>>>>>            Set peAnchors to anTopRight
105770>>>>>
105770>>>>>            Procedure OnClick
105773>>>>>                String sFileName
105773>>>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
105774>>>>>                If (sFileName <> "") Begin
105776>>>>>                    Set Value of oServer_fm to sFileName
105777>>>>>                End
105777>>>>>>
105777>>>>>            End_Procedure     
105778>>>>>            
105778>>>>>            Function IsEnabled Returns Boolean
105781>>>>>                String sDriverID
105781>>>>>                Integer iRadio
105781>>>>>                Get Value of oDriverID_cf to sDriverID
105782>>>>>                Get Current_Radio of oODBC_rgp to iRadio
105783>>>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
105784>>>>>            End_Function
105785>>>>>
105785>>>>>        End_Object
105786>>>>>
105786>>>>>        Object oODBCAdmin_btn is a cRDCButton
105788>>>>>            Set Size to 13 78
105789>>>>>            Set Location to 57 210
105790>>>>>            Set Label to "ODBC Admin" 
105791>>>>>            Set psImage to "ODBCAD32.ico"
105792>>>>>            Set pbAutoEnable to True
105793>>>>>            Set peAnchors to anTopRight
105794>>>>>            
105794>>>>>            Procedure OnClick
105797>>>>>                Handle hWnd
105797>>>>>                Get Window_Handle to hWnd
105798>>>>>                If (hWnd <> 0) Begin
105800>>>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
105805>>>>>                End
105805>>>>>>
105805>>>>>                Else Begin
105806>>>>>                    Send Stop_Box "Could not get a Windows handle.."
105807>>>>>                End
105807>>>>>>
105807>>>>>            End_Procedure
105808>>>>>
105808>>>>>            Function IsEnabled Returns Boolean
105811>>>>>                String sDriverID
105811>>>>>                Get Value of oDriverID_cf to sDriverID
105812>>>>>                Function_Return (sDriverID = ODBC_DRV_ID)
105813>>>>>            End_Function
105814>>>>>
105814>>>>>        End_Object
105815>>>>>
105815>>>>>        Object oServer_fm is a cSQLForm
105817>>>>>            Set Size to 13 114
105818>>>>>            Set Location to 74 82
105819>>>>>            Set Label to "Server"
105820>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
105821>>>>>            Set piItem to 5
105822>>>>>            Set peAnchors to anTopLeftRight
105823>>>>>
105823>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
105825>>>>>
105825>>>>>            Procedure Prompt
105828>>>>>                String sDriverID sValue
105828>>>>>                String[] sTheData
105829>>>>>                Integer iDbType iODBCType iRadio iPos
105829>>>>>                Handle ho
105829>>>>>
105829>>>>>                Get Prompt_Object to ho
105830>>>>>                If (ho = 0) Begin
105832>>>>>                    Procedure_Return
105833>>>>>                End
105833>>>>>>
105833>>>>>
105833>>>>>                Set Label of oShowInfo_tb to CS_LoadingServers
105834>>>>>                Send Cursor_Wait of Cursor_Control
105835>>>>>                Get SelectedDbType of oDbType_cf to iDbType
105836>>>>>                Get Value of oDriverID_cf to sDriverID
105837>>>>>                Move (Trim(sDriverID)) to sDriverID
105838>>>>>                Get Current_Radio of oODBC_rgp to iRadio
105839>>>>>                If (iRadio = 0) Begin
105841>>>>>                    Move SQL_FETCH_USER   to iODBCType
105842>>>>>                End
105842>>>>>>
105842>>>>>                If (iRadio = 1) Begin
105844>>>>>                    Move SQL_FETCH_SYSTEM to iODBCType
105845>>>>>                End
105845>>>>>>
105845>>>>>                If (iRadio = 2) Begin
105847>>>>>                    Move SQL_FETCH_ALL    to iODBCType
105848>>>>>                End
105848>>>>>>
105848>>>>>
105848>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105849>>>>>                Load_Driver sDriverID
105850>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
105851>>>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
105853>>>>>                    Send Cursor_Ready of Cursor_Control
105854>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
105855>>>>>                    Procedure_Return
105856>>>>>                End
105856>>>>>>
105856>>>>>
105856>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
105857>>>>>                Set psTheData  of ho to sTheData
105858>>>>>                Set Label of oShowInfo_tb to ""
105859>>>>>
105859>>>>>                Forward Send Prompt
105861>>>>>
105861>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
105861>>>>>                // We need to remove those parts from the comma and to the end of string.
105861>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
105863>>>>>                    Get Value to sValue
105864>>>>>                    Move (Pos(",", sValue)) to iPos
105865>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
105866>>>>>                    Set Value to sValue
105867>>>>>                End
105867>>>>>>
105867>>>>>            End_Procedure
105868>>>>>
105868>>>>>            Procedure OnChange
105871>>>>>                tSQLIntTableInfo[] sReturnStructArray
105871>>>>>                tSQLIntTableInfo[] sReturnStructArray
105872>>>>>                String sServer sDatabaseName sVal sDriverID
105872>>>>>                Integer iSize iCount iPos 
105872>>>>>                Boolean bFileDSN
105872>>>>>                
105872>>>>>                Move False to bFileDSN
105873>>>>>                Get Value of oDriverID_cf to sDriverID
105874>>>>>                If (sDriverID = "") Begin
105876>>>>>                    Procedure_Return
105877>>>>>                End
105877>>>>>>
105877>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
105879>>>>>                    Move "" to sDatabaseName
105880>>>>>                    Get Value to sServer 
105881>>>>>                    Move (Pos(",", sServer)) to iPos
105882>>>>>                    If (iPos <> 0) Begin
105884>>>>>                        Move (Left(sServer, (iPos -1))) to sServer
105885>>>>>                    End
105885>>>>>>
105885>>>>>                    If (sServer <> "") Begin
105887>>>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
105888>>>>>                    End
105888>>>>>>
105888>>>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
105889>>>>>                    If (SizeOfArray(sReturnStructArray)) Begin
105891>>>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
105893>>>>>                            // If a FILEDSN: (can only be one database name)
105893>>>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
105894>>>>>                            Move True to bFileDSN
105895>>>>>                        End
105895>>>>>>
105895>>>>>                        Else Begin
105896>>>>>                            // Else the DSN's were read from the registry.
105896>>>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
105897>>>>>                            Decrement iSize
105898>>>>>                            For iCount from 0 to iSize
105904>>>>>>
105904>>>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
105905>>>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
105907>>>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
105908>>>>>                                    Move iSize to iCount // We're done.
105909>>>>>                                End
105909>>>>>>
105909>>>>>                            Loop
105910>>>>>>
105910>>>>>                        End
105910>>>>>>
105910>>>>>                    End
105910>>>>>>
105910>>>>>                    Set Value of oDatabase_fm to sDatabaseName
105911>>>>>                    If (bFileDSN = True) Begin
105913>>>>>                        Set Current_Radio of oODBC_rgp to 3
105914>>>>>                    End    
105914>>>>>>
105914>>>>>                    Else Begin
105915>>>>>                        Set Current_Radio of oODBC_rgp to 2
105916>>>>>                    End
105916>>>>>>
105916>>>>>                End
105916>>>>>>
105916>>>>>
105916>>>>>            End_Procedure
105917>>>>>
105917>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
105920>>>>>                String sLabel
105920>>>>>                Handle ho
105920>>>>>
105920>>>>>                Get phoPromptObject to ho
105921>>>>>                Set Prompt_Button_Mode to PB_PromptOn
105922>>>>>                Case Begin
105922>>>>>                    Case (iDbType = EN_dbTypeDB2)
105924>>>>>                        Move "DSN" to sLabel
105925>>>>>                        Case Break
105926>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
105929>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
105931>>>>>                            Move "ODBC Data Source" to sLabel
105932>>>>>                        End
105932>>>>>>
105932>>>>>                        Else Begin
105933>>>>>                            Move "Server" to sLabel
105934>>>>>                        End
105934>>>>>>
105934>>>>>                        Case Break
105935>>>>>                    Case (iDbType = EN_dbTypeMySQL)
105938>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
105940>>>>>                            Move "ODBC Data Source" to sLabel
105941>>>>>                        End
105941>>>>>>
105941>>>>>                        Else Begin
105942>>>>>                            Move "DSN" to sLabel
105943>>>>>                        End
105943>>>>>>
105943>>>>>                        Case Break
105944>>>>>                    Case (iDbType = EN_dbTypeOracle)
105947>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
105949>>>>>                            Move "ODBC Data Source" to sLabel
105950>>>>>                        End
105950>>>>>>
105950>>>>>                        Else Begin
105951>>>>>                            Move "Server" to sLabel
105952>>>>>                        End
105952>>>>>>
105952>>>>>                        Case Break
105953>>>>>                    Case (iDbType = EN_dbTypePostgre)
105956>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
105958>>>>>                            Move "ODBC Data Source" to sLabel
105959>>>>>                        End
105959>>>>>>
105959>>>>>                        Else Begin
105960>>>>>                            Move "Server" to sLabel
105961>>>>>                        End
105961>>>>>>
105961>>>>>                        Case Break
105962>>>>>                    Case Else
105962>>>>>                Case End
105962>>>>>
105962>>>>>                Set Prompt_Object to ho
105963>>>>>                Set Label to sLabel
105964>>>>>            End_Procedure
105965>>>>>
105965>>>>>        End_Object
105966>>>>>
105966>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
105968>>>>>            Set Size to 10 48
105969>>>>>            Set Location to 76 210
105970>>>>>            Set Label to "Silent Login"
105971>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
105972>>>>>            Set peAnchors to anTopRight
105973>>>>>            Set piItem to 15
105974>>>>>        End_Object
105975>>>>>
105975>>>>>        Object oTrusted_cb is a cSQLCheckbox
105977>>>>>            Set Size to 12 85
105978>>>>>            Set Location to 91 82
105979>>>>>            Set Label to "Use Trusted Connection"
105980>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
105981>>>>>            Set piItem to 8
105982>>>>>
105982>>>>>            Procedure OnChange
105985>>>>>                Boolean bChecked
105985>>>>>                Get Checked_State to bChecked
105986>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
105987>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
105988>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
105989>>>>>            End_Procedure
105990>>>>>
105990>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
105993>>>>>                Boolean bChecked
105993>>>>>
105993>>>>>                Get Checked_State to bChecked
105994>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
105996>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
105997>>>>>                    If (bChecked = True) Begin
105999>>>>>                        Set Checked_State to False
106000>>>>>                    End
106000>>>>>>
106000>>>>>                End
106000>>>>>>
106000>>>>>                Else Begin
106001>>>>>                    Set Enabled_State to True
106002>>>>>                End
106002>>>>>>
106002>>>>>
106002>>>>>                Send OnChange
106003>>>>>            End_Procedure
106004>>>>>
106004>>>>>        End_Object
106005>>>>>
106005>>>>>        Object oUserID_fm is a cSQLForm
106007>>>>>            Set Size to 13 114
106008>>>>>            Set Location to 103 82
106009>>>>>            Set Label to "User ID"
106010>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
106011>>>>>            Set piItem to 9
106012>>>>>            Set peAnchors to anTopLeftRight
106013>>>>>        End_Object
106014>>>>>
106014>>>>>        Object oPassword_fm is a cSQLForm
106016>>>>>            Set Size to 13 61
106017>>>>>            Set Location to 103 210
106018>>>>>            Set Label to "Password"
106019>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
106020>>>>>            Set piItem to 10
106021>>>>>            Set Password_State to True
106022>>>>>            Set peAnchors to anTopRight
106023>>>>>            Set Label_Col_Offset to 0
106024>>>>>            Set Label_Justification_Mode to JMode_Top
106025>>>>>        End_Object
106026>>>>>
106026>>>>>        Object oShowInfo_tb is a TextBox
106028>>>>>            Set Auto_Size_State to False
106029>>>>>            Set Size to 10 114
106030>>>>>            Set Location to 119 82
106031>>>>>            Set TextColor to clGreen
106032>>>>>            Set Justification_Mode to JMode_Center
106033>>>>>            Set peAnchors to anTopRight
106034>>>>>        End_Object
106035>>>>>
106035>>>>>        Object oViewPassword_btn is a cRDCButton
106037>>>>>            Set Size to 13 15
106038>>>>>            Set Location to 103 273
106039>>>>>            Set psToolTip to "View/hide password"
106040>>>>>            Set psImage to "ViewPassword1.ico"
106041>>>>>            Set piImageMarginLeft to 2
106042>>>>>            Set peAnchors to anTopRight
106043>>>>>
106043>>>>>            Procedure OnClick
106046>>>>>                Handle ho
106046>>>>>                Boolean bState
106046>>>>>
106046>>>>>                Move (oPassword_fm(Self)) to ho
106047>>>>>                Get Password_State of ho 0 to bState
106048>>>>>                Send Deactivate of ho
106049>>>>>                Set Password_State of ho to (not(bState))
106050>>>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
106050>>>>>                Send Activate of ho (Parent(Self))
106051>>>>>            End_Procedure
106052>>>>>
106052>>>>>        End_Object
106053>>>>>
106053>>>>>        Object oCheckLogin_btn is a cRDCButton
106055>>>>>            Set Size to 13 78
106056>>>>>            Set Location to 119 210
106057>>>>>            Set Label to "Check &Login"
106058>>>>>            Set psImage to "ActionLogin1.ico"
106059>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
106060>>>>>            Set piImageMarginLeft to 3
106061>>>>>            Set peAnchors to anTopRight
106062>>>>>
106062>>>>>            Procedure OnClick
106065>>>>>                String sConnectionString sDriverID sError //sServer sDatabase sUserId sPassword 
106065>>>>>                Boolean bLoginSuccessful bMertechDriver // bTrusted 
106065>>>>>                Integer iDriverID
106065>>>>>                Handle hoErrorObj
106065>>>>>
106065>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
106066>>>>>                Move Error_Object_Id to hoErrorObj
106067>>>>>                Move Self to Error_Object_Id
106068>>>>>                Move False to Err
106069>>>>>
106069>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
106070>>>>>                Send PumpMsgQueue
106071>>>>>                
106071>>>>>                Get Value of oDriverID_cf to sDriverID
106072>>>>>                Move "" to sError
106073>>>>>                Get LoginString (&sError) to sConnectionString
106074>>>>>                If (sError <> "") Begin
106076>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
106077>>>>>                    Send Info_Box sError
106078>>>>>                    Procedure_Return
106079>>>>>                End
106079>>>>>>
106079>>>>>                
106079>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
106080>>>>>                If (iDriverID = 0) Begin
106082>>>>>                    Set TextColor of oLoginInfo_tb to clRed
106083>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
106084>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
106085>>>>>                    Procedure_Return
106086>>>>>                End
106086>>>>>>
106086>>>>>
106086>>>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
106087>>>>>                If (bMertechDriver = False) Begin
106089>>>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
106092>>>>>                End
106092>>>>>>
106092>>>>>
106092>>>>>                Move False to Err
106093>>>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
106094>>>>>
106094>>>>>                Move (Err = False) to bLoginSuccessful
106095>>>>>                If bLoginSuccessful Begin
106097>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
106098>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
106099>>>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
106100>>>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
106101>>>>>                End
106101>>>>>>
106101>>>>>                Else Begin
106102>>>>>                    Set TextColor of oLoginInfo_tb to clRed
106103>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
106104>>>>>                End
106104>>>>>>
106104>>>>>
106104>>>>>                Move hoErrorObj to Error_Object_Id
106105>>>>>                Send Cursor_Ready of Cursor_Control
106106>>>>>            End_Procedure
106107>>>>>
106107>>>>>            // This method is here simply to intercept any error that may occur while logging in
106107>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
106107>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
106110>>>>>                    If (LastErr = 25000) Begin
106112>>>>>                        If (Trim(sErrMsg) <> "") Begin
106114>>>>>                            Send Info_Box sErrMsg
106115>>>>>                        End
106115>>>>>>
106115>>>>>                    End  
106115>>>>>>
106115>>>>>            End_Procedure   
106116>>>>>            
106116>>>>>        End_Object
106117>>>>>
106117>>>>>        Object oIndexTableSpace_fm is a cSQLForm
106119>>>>>            Set Size to 13 114
106120>>>>>            Set Location to 133 82
106121>>>>>            Set Label to "Index Table Space"
106122>>>>>            Set piItem to 14
106123>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
106124>>>>>            Set Prompt_Button_Mode to PB_PromptOn
106125>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
106126>>>>>            Set peAnchors to anTopLeftRight
106127>>>>>
106127>>>>>            Procedure Prompt
106130>>>>>                String[] sTheData
106131>>>>>                Handle ho
106131>>>>>                tSQLConnection SQLConnection
106131>>>>>                tSQLConnection SQLConnection
106131>>>>>
106131>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
106132>>>>>                Get ReadCurrentSQLSettings to SQLConnection
106133>>>>>
106133>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
106134>>>>>
106134>>>>>                Get Prompt_Object to ho
106135>>>>>                Set psTheData     of ho to sTheData
106136>>>>>                Set Label of oShowInfo_tb to ""
106137>>>>>
106137>>>>>                Forward Send Prompt
106139>>>>>            End_Procedure
106140>>>>>
106140>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
106143>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
106144>>>>>            End_Procedure
106145>>>>>
106145>>>>>        End_Object
106146>>>>>
106146>>>>>        Object oLoginInfo_tb is a TextBox
106148>>>>>            Set Auto_Size_State to False
106149>>>>>            Set Size to 9 78
106150>>>>>            Set Location to 135 210
106151>>>>>            Set TextColor to clGreen
106152>>>>>            Set peAnchors to anTopRight
106153>>>>>            Set Justification_Mode to JMode_Left
106154>>>>>        End_Object
106155>>>>>
106155>>>>>        Object oBaseTableSpace_fm is a cSQLForm
106157>>>>>            Set Size to 13 114
106158>>>>>            Set Location to 148 82
106159>>>>>            Set Label to "Table Space"
106160>>>>>            Set piItem to 12
106161>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
106162>>>>>            Set Prompt_Button_Mode to PB_PromptOn
106163>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
106164>>>>>            Set peAnchors to anTopLeftRight
106165>>>>>
106165>>>>>            Procedure Prompt
106168>>>>>                String[] sTheData
106169>>>>>                Handle ho
106169>>>>>                tSQLConnection SQLConnection
106169>>>>>                tSQLConnection SQLConnection
106169>>>>>
106169>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
106170>>>>>                Get ReadCurrentSQLSettings to SQLConnection
106171>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
106172>>>>>
106172>>>>>                Get Prompt_Object to ho
106173>>>>>                Set psTheData  of ho to sTheData
106174>>>>>                Set Label of oShowInfo_tb to ""
106175>>>>>
106175>>>>>                Forward Send Prompt
106177>>>>>            End_Procedure
106178>>>>>
106178>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
106181>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
106182>>>>>            End_Procedure
106183>>>>>
106183>>>>>        End_Object
106184>>>>>
106184>>>>>        Object oLongTableSpace_fm is a cSQLForm
106186>>>>>            Set Size to 13 114
106187>>>>>            Set Location to 163 82
106188>>>>>            Set Label to "Long Table Space"
106189>>>>>            Set piItem to 13
106190>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
106191>>>>>            Set Prompt_Button_Mode to PB_PromptOn
106192>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
106193>>>>>            Set peAnchors to anTopLeftRight
106194>>>>>
106194>>>>>            Procedure Prompt
106197>>>>>                String[] sTheData
106198>>>>>                Handle ho
106198>>>>>                tSQLConnection SQLConnection
106198>>>>>                tSQLConnection SQLConnection
106198>>>>>
106198>>>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
106199>>>>>                Get ReadCurrentSQLSettings to SQLConnection
106200>>>>>
106200>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
106201>>>>>
106201>>>>>                Get Prompt_Object to ho
106202>>>>>                Set psTheData     of ho to sTheData
106203>>>>>                Set Label of oShowInfo_tb to ""
106204>>>>>
106204>>>>>                Forward Send Prompt
106206>>>>>            End_Procedure
106207>>>>>
106207>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
106210>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
106211>>>>>            End_Procedure
106212>>>>>
106212>>>>>        End_Object
106213>>>>>
106213>>>>>        Object oSchema_fm is a cSQLForm
106215>>>>>            Set Size to 13 78
106216>>>>>            Set Location to 163 210
106217>>>>>            Set Label to "Schema"
106218>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
106219>>>>>            Set piItem to 11
106220>>>>>            Set Enabled_State to False
106221>>>>>
106221>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
106223>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
106225>>>>>
106225>>>>>            Set peAnchors to anTopRight
106226>>>>>            Set Label_Justification_Mode to JMode_Top
106227>>>>>            Set Label_Col_Offset to 0
106228>>>>>
106228>>>>>            Procedure Prompt
106231>>>>>                String[] sTheData
106232>>>>>                Handle ho
106232>>>>>                tSQLConnection SQLConnection
106232>>>>>                tSQLConnection SQLConnection
106232>>>>>
106232>>>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
106233>>>>>                Get ReadCurrentSQLSettings to SQLConnection
106234>>>>>
106234>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
106235>>>>>
106235>>>>>                Get Prompt_Object to ho
106236>>>>>                Set psTheData     of ho to sTheData
106237>>>>>                Set Label of oShowInfo_tb to ""
106238>>>>>
106238>>>>>                Forward Send Prompt
106240>>>>>            End_Procedure
106241>>>>>
106241>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
106244>>>>>                String sValue
106244>>>>>
106244>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
106245>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
106247>>>>>                    Set Label to CS_DF_File_Owner
106248>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
106249>>>>>                    Set Prompt_Object to 0
106250>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
106251>>>>>                    Get Value to sValue
106252>>>>>                    If (Trim(sValue) = "") Begin
106254>>>>>                        Set Value to "dbo"
106255>>>>>                    End
106255>>>>>>
106255>>>>>                End
106255>>>>>>
106255>>>>>                Else Begin
106256>>>>>                    Set Label to CS_DF_File_Schema
106257>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
106258>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
106259>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
106260>>>>>                    If (Trim(sValue) = "dbo") Begin
106262>>>>>                        Set Value to ""
106263>>>>>                    End
106263>>>>>>
106263>>>>>                End
106263>>>>>>
106263>>>>>                If (Enabled_State(Self) = False) Begin
106265>>>>>                    Set Value to ""
106266>>>>>                End
106266>>>>>>
106266>>>>>            End_Procedure
106267>>>>>
106267>>>>>        End_Object
106268>>>>>
106268>>>>>        Object oDatabase_fm is a cSQLForm
106270>>>>>            Set Size to 13 114
106271>>>>>            Set Location to 178 82
106272>>>>>            Set Label to "Database"
106273>>>>>            Set peAnchors to anTopLeftRight
106274>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
106275>>>>>            Set piItem to 6
106276>>>>>            Set Prompt_Button_Mode to PB_PromptOn
106277>>>>>
106277>>>>>            Procedure Prompt
106280>>>>>                String[] sTheData
106281>>>>>                Handle ho
106281>>>>>                tSQLConnection SQLConnection
106281>>>>>                tSQLConnection SQLConnection
106281>>>>>
106281>>>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
106282>>>>>                Get ReadCurrentSQLSettings to SQLConnection
106283>>>>>
106283>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
106284>>>>>
106284>>>>>                Get Prompt_Object to ho
106285>>>>>                Set psTheData     of ho to sTheData
106286>>>>>                Set Label of oShowInfo_tb to ""
106287>>>>>
106287>>>>>                Forward Send Prompt
106289>>>>>            End_Procedure
106290>>>>>
106290>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
106293>>>>>                Boolean bAdd
106293>>>>>                String sValue
106293>>>>>
106293>>>>>                If (sDriverID <> "") Begin
106295>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
106296>>>>>                    If (Enabled_State(Self) = True) Begin
106298>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
106299>>>>>                        Get Value to sValue
106300>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
106302>>>>>                            Set Value to "master"
106303>>>>>                        End
106303>>>>>>
106303>>>>>                        Else Begin
106304>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
106305>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
106306>>>>>                            If (Value(Self) = "master") Begin
106308>>>>>                                Set Value to ""
106309>>>>>                            End
106309>>>>>>
106309>>>>>                        End
106309>>>>>>
106309>>>>>                    End
106309>>>>>>
106309>>>>>                    If (Enabled_State(Self) = False) Begin
106311>>>>>                        Set Value to ""
106312>>>>>                    End
106312>>>>>>
106312>>>>>                End
106312>>>>>>
106312>>>>>            End_Procedure
106313>>>>>
106313>>>>>        End_Object
106314>>>>>
106314>>>>>        Object oCreateDatabase_btn is a cRDCButton
106316>>>>>            Set Size to 13 78
106317>>>>>            Set Location to 178 210
106318>>>>>            Set Label to "Create Database..."
106319>>>>>            Set psImage to "ActionCreateDatabase1.ico"
106320>>>>>            Set pbAutoEnable to True
106321>>>>>            Set peAnchors to anTopRight
106322>>>>>        
106322>>>>>            Procedure OnClick                                                              
106325>>>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
106325>>>>>                
106325>>>>>                Get LoginString (&sError) to sConnectionString
106326>>>>>                If (sError <> "") Begin
106328>>>>>                    Send Info_Box sError
106329>>>>>                    Procedure_Return
106330>>>>>                End                         
106330>>>>>>
106330>>>>>                
106330>>>>>                Get Value of oDriverID_cf to sDriverID
106331>>>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
106332>>>>>                If (sDatabaseName <> "") Begin
106334>>>>>                    Set Value of oDatabase_fm to sDatabaseName
106335>>>>>                End
106335>>>>>>
106335>>>>>            End_Procedure                
106336>>>>>            
106336>>>>>            Function IsEnabled Returns Boolean
106339>>>>>                Integer iDbType    
106339>>>>>                Boolean bReadOnly
106339>>>>>                Get SelectedDbType of oDbType_cf to iDbType
106340>>>>>                Get pbReadOnly to bReadOnly
106341>>>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
106342>>>>>            End_Function
106343>>>>>        
106343>>>>>        End_Object
106344>>>>>
106344>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
106347>>>>>            String sDbType
106347>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
106348>>>>>            Set Label to (sDbType * "Connection Details")
106349>>>>>        End_Procedure
106350>>>>>
106350>>>>>    End_Object
106351>>>>>
106351>>>>>    Object oOK_Btn is a cRDCButton
106353>>>>>        Set Label    to C_$OK
106354>>>>>        Set Location to 287 208 //281 208
106355>>>>>        Set peAnchors to anBottomRight
106356>>>>>
106356>>>>>        Procedure OnClick
106359>>>>>            String sLoginText
106359>>>>>            String[] sConnectionData
106360>>>>>            tSQLConnection SQLIniFileConnection
106360>>>>>            tSQLConnection SQLIniFileConnection
106360>>>>>            Boolean bNew bOK bShouldSave
106360>>>>>            Integer iRetval
106360>>>>>
106360>>>>>            Delegate Get Should_Save to bShouldSave
106362>>>>>            If (bShouldSave = False) Begin
106364>>>>>                Set pbChanged to False
106365>>>>>                Send Close_Panel
106366>>>>>                Procedure_Return
106367>>>>>            End
106367>>>>>>
106367>>>>>
106367>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
106369>>>>>
106369>>>>>            Get pbNew to bNew
106370>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
106371>>>>>            Case Begin
106371>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
106373>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
106375>>>>>                        Move "" to SQLIniFileConnection.sDatabase
106376>>>>>                    End
106376>>>>>>
106376>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
106378>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
106380>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
106381>>>>>                        End
106381>>>>>>
106381>>>>>                        Else Begin
106382>>>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
106383>>>>>                        End
106383>>>>>>
106383>>>>>                    End
106383>>>>>>
106383>>>>>                    Else Begin
106384>>>>>                        // It should probably be allowed to use an UID but no password...
106384>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
106386>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106387>>>>>                        End
106387>>>>>>
106387>>>>>                        Else Begin
106388>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106389>>>>>                        End
106389>>>>>>
106389>>>>>                    End
106389>>>>>>
106389>>>>>                    Case Break
106390>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
106393>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
106395>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
106397>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
106398>>>>>                        End
106398>>>>>>
106398>>>>>                        Else Begin
106399>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
106400>>>>>                        End
106400>>>>>>
106400>>>>>                    End
106400>>>>>>
106400>>>>>                    Else Begin
106401>>>>>                        // It should probably be allowed to use an UID but no password...
106401>>>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
106403>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106404>>>>>                        End
106404>>>>>>
106404>>>>>                        Else Begin
106405>>>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106406>>>>>                        End
106406>>>>>>
106406>>>>>                    End
106406>>>>>>
106406>>>>>                    Case Break
106407>>>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
106410>>>>>                    // It should probably be allowed to use an UID but no password...
106410>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
106412>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106413>>>>>                    End
106413>>>>>>
106413>>>>>                    Else Begin
106414>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106415>>>>>                    End
106415>>>>>>
106415>>>>>                    Case Break
106416>>>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
106419>>>>>                    // It should probably be allowed to use an UID but no password...
106419>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
106421>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106422>>>>>                    End
106422>>>>>>
106422>>>>>                    Else Begin
106423>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106424>>>>>                    End
106424>>>>>>
106424>>>>>                    Case Break
106425>>>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
106428>>>>>                    // It should probably be allowed to use an UID but no password...
106428>>>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
106430>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106431>>>>>                    End
106431>>>>>>
106431>>>>>                    Else Begin
106432>>>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
106433>>>>>                    End
106433>>>>>>
106433>>>>>                    Case Break
106434>>>>>            Case End
106434>>>>>
106434>>>>>            If (bOK = False) Begin
106436>>>>>                Send Info_Box "Please fill in all connection data."
106437>>>>>                Procedure_Return
106438>>>>>            End
106438>>>>>>
106438>>>>>
106438>>>>>            Move MBR_Yes to iRetval
106439>>>>>            Get Label of oLoginInfo_tb to sLoginText
106440>>>>>            If (sLoginText = CS_LoginFailed) Begin
106442>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
106443>>>>>            End
106443>>>>>>
106443>>>>>            Else If (sLoginText = "") Begin
106446>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
106447>>>>>            End
106447>>>>>>
106447>>>>>            If (iRetval <> MBR_Yes) Begin
106449>>>>>                Procedure_Return
106450>>>>>            End
106450>>>>>>
106450>>>>>
106450>>>>>            Set pSQLConnectionData to SQLIniFileConnection
106451>>>>>            Set pbChanged to True
106452>>>>>            Send Close_Panel
106453>>>>>        End_Procedure
106454>>>>>
106454>>>>>    End_Object
106455>>>>>
106455>>>>>    Object oCancel_Btn is a cRDCButton
106457>>>>>        Set Label    to C_$Cancel
106458>>>>>        Set Location to 287 264 //281 264
106459>>>>>        Set peAnchors to anBottomRight
106460>>>>>
106460>>>>>        Procedure OnClick
106463>>>>>            Set pbChanged to False
106464>>>>>            Send Close_Panel
106465>>>>>        End_Procedure
106466>>>>>
106466>>>>>    End_Object
106467>>>>>
106467>>>>>    Object oHelp_Btn is a cRDCButton
106469>>>>>        Set Label to C_$Help
106470>>>>>        Set Location to 287 11 //281 11
106471>>>>>        Set peAnchors to anBottomLeft
106472>>>>>        Set psImage to "ActionHelp1.ico"
106473>>>>>
106473>>>>>        Procedure OnClick
106476>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
106477>>>>>        End_Procedure
106478>>>>>    End_Object
106479>>>>>
106479>>>>>    Object oConnectionType_grp is a cRDCHeaderGroup
106481>>>>>        Set Size to 60 303
106482>>>>>        Set Location to 8 11 //2 11
106483>>>>>        Set psImage to "SQLSettings1.ico"
106484>>>>>        Set psLabel to "Database Type Settings"
106485>>>>>
106485>>>>>        Object oDbType_cf is a cSQLComboForm
106487>>>>>            Set Size to 13 115
106488>>>>>            Set Location to 22 82
106489>>>>>            Set Label to "Database Type"
106490>>>>>            Set Entry_State to False
106491>>>>>            Set Combo_Sort_State to False
106492>>>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
106493>>>>>            Set piItem to 3
106494>>>>>            
106494>>>>>            Procedure Combo_Fill_List
106497>>>>>                Send Combo_Add_Item CS_dbTypeMSSQL
106498>>>>>                Send Combo_Add_Item CS_dbTypeMySQL
106499>>>>>                Send Combo_Add_Item CS_dbTypeOracle
106500>>>>>                Send Combo_Add_Item CS_dbTypeDB2
106501>>>>>                Send Combo_Add_Item CS_dbTypePostgre
106502>>>>>            End_Procedure
106503>>>>>
106503>>>>>            Procedure OnChange
106506>>>>>                Integer iDbType
106506>>>>>                String sDriverID
106506>>>>>    
106506>>>>>                Get SelectedDbType to iDbType
106507>>>>>                Send Refill_Comboform of oDriverID_cf iDbType
106508>>>>>                Get Value of oDriverID_cf to sDriverID
106509>>>>>                If (sDriverID = "") Begin
106511>>>>>                    Move MSSQLDRV_ID to sDriverID
106512>>>>>                End
106512>>>>>>
106512>>>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
106513>>>>>            End_Procedure
106514>>>>>    
106514>>>>>            Function SelectedDbType Returns Integer
106517>>>>>                Integer iRetval
106517>>>>>                String sDbType
106517>>>>>    
106517>>>>>                Get Value to sDbType
106518>>>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
106519>>>>>    
106519>>>>>                Function_Return iRetval
106520>>>>>            End_Function
106521>>>>>
106521>>>>>        End_Object
106522>>>>>
106522>>>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
106522>>>>>//        Object oStartSQLManager_btn is a cRDCButton
106522>>>>>//            Set Size to 13 78
106522>>>>>//            Set Location to 22 210
106522>>>>>//            Set Label to "SQL Manager"
106522>>>>>//            Set pbAutoEnable to True  
106522>>>>>//            Set psImage to "SSMS1.ico" 
106522>>>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
106522>>>>>//            Set peAnchors to anTopRight
106522>>>>>//        
106522>>>>>//            Procedure OnClick
106522>>>>>//                Runprogram Shell Background "Ssms.exe"    
106522>>>>>//            End_Procedure  
106522>>>>>//            
106522>>>>>//            Function IsEnabled Returns Boolean
106522>>>>>//                String sDbType
106522>>>>>//                Get Value of oDbType_cf to sDbType
106522>>>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
106522>>>>>//            End_Function
106522>>>>>//        
106522>>>>>//        End_Object
106522>>>>>
106522>>>>>        Object oDriverID_cf is a cSQLComboForm
106524>>>>>            Set Size to 13 115
106525>>>>>            Set Location to 37 82
106526>>>>>            Set Label to "Driver ID"
106527>>>>>            Set Entry_State to False
106528>>>>>            Set Combo_Sort_State to False
106529>>>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
106530>>>>>            Set piItem to 4
106531>>>>>
106531>>>>>            Procedure Refill_Comboform Integer iDbType
106534>>>>>                String sValue
106534>>>>>
106534>>>>>                Send Combo_Delete_Data
106535>>>>>                Send Combo_Add_Item MSSQLDRV_ID
106536>>>>>                Send Combo_Add_Item ODBC_DRV_ID
106537>>>>>                Send Combo_Add_Item SQLFLEX
106538>>>>>                Send Combo_Add_Item ODBC_DRV_ID
106539>>>>>                Send Combo_Add_Item MDSMySQL
106540>>>>>                Send Combo_Add_Item ODBC_DRV_ID
106541>>>>>                Send Combo_Add_Item ORAFLEX
106542>>>>>                Send Combo_Add_Item DB2_DRV_ID
106543>>>>>                Send Combo_Add_Item ODBC_DRV_ID
106544>>>>>                Send Combo_Add_Item MDSPgSQL
106545>>>>>                Send Combo_Add_Item DATAFLEX_ID
106546>>>>>
106546>>>>>                Case Begin
106546>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
106548>>>>>                        Move MSSQLDRV_ID to sValue
106549>>>>>                        Case Break
106550>>>>>                    Case (iDbType = EN_dbTypeMySQL)
106553>>>>>                        Move ODBC_DRV_ID to sValue
106554>>>>>                        Case Break
106555>>>>>                    Case (iDbType = EN_dbTypeOracle)
106558>>>>>                        Move ODBC_DRV_ID to sValue
106559>>>>>                        Case Break
106560>>>>>                    Case (iDbType = EN_dbTypeDB2)
106563>>>>>                        Move DB2_DRV_ID to sValue
106564>>>>>                        Case Break
106565>>>>>                    Case (iDbType = EN_dbTypePostgre)
106568>>>>>                        Move ODBC_DRV_ID to sValue
106569>>>>>                        Case Break
106570>>>>>                    Case Else
106570>>>>>                        Move DATAFLEX_ID to sValue
106571>>>>>                Case End
106571>>>>>                Set Value to sValue
106572>>>>>            End_Procedure
106573>>>>>
106573>>>>>            Procedure OnChange
106576>>>>>                String sDriverID
106576>>>>>                Integer iDbType
106576>>>>>
106576>>>>>                Get Value to sDriverID
106577>>>>>                If (sDriverID = "") Begin
106579>>>>>//                    Move MSSQLDRV_ID to sDriverID 
106579>>>>>                    Procedure_Return
106580>>>>>                End
106580>>>>>>
106580>>>>>                Get SelectedDbType of oDbType_cf to iDbType
106581>>>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
106583>>>>>            End_Procedure
106584>>>>>
106584>>>>>        End_Object
106585>>>>>
106585>>>>>        Object oShowDriverSettings_btn is a cRDCButton
106587>>>>>            Set Size to 13 78
106588>>>>>            Set Location to 37 210
106589>>>>>            Set Label to "Driver Settings"
106590>>>>>            Set Status_Help to "Shows settings for the selected driver."
106591>>>>>            Set psImage to "DriverSettings1.ico"
106592>>>>>            Set peAnchors to anTopRight
106593>>>>>
106593>>>>>            Procedure OnClick
106596>>>>>                String sDriver sPath 
106596>>>>>                
106596>>>>>                Get Value of oDriverID_cf to sDriver
106597>>>>>                Send PopupDriverSettings sDriver 
106598>>>>>            End_Procedure
106599>>>>>    
106599>>>>>        End_Object
106600>>>>>
106600>>>>>    End_Object
106601>>>>>
106601>>>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
106604>>>>>        tSQLConnection SQLConnection
106604>>>>>        tSQLConnection SQLConnection
106604>>>>>
106604>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
106605>>>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
106606>>>>>
106606>>>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
106607>>>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
106608>>>>>        Get Value of oServer_fm          to SQLConnection.sServer
106609>>>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
106610>>>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
106611>>>>>        Move False to Err
106612>>>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
106613>>>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
106614>>>>>        Move Err to SQLConnection.bError
106615>>>>>        
106615>>>>>        Function_Return SQLConnection
106616>>>>>    End_Function
106617>>>>>
106617>>>>>    Function LoginString String ByRef sError Returns String
106620>>>>>        String sDriverID sServer sDatabase
106620>>>>>        tSQLConnection SQLConnection
106620>>>>>        tSQLConnection SQLConnection
106620>>>>>        
106620>>>>>        Get Value of oDriverID_cf to sDriverID
106621>>>>>        If (sDriverID = "") Begin
106623>>>>>            Move "Please select a driver first, then try again." to sError
106624>>>>>            Function_Return ""
106625>>>>>        End
106625>>>>>>
106625>>>>>
106625>>>>>        Get Value of oServer_fm   to sServer
106626>>>>>        If (sServer = "") Begin
106628>>>>>            Move "Please select a server first, then try again." to sError
106629>>>>>            Function_Return ""
106630>>>>>        End
106630>>>>>>
106630>>>>>
106630>>>>>        Get Value of oDatabase_fm to sDatabase
106631>>>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
106633>>>>>            Move "master" to sDatabase
106634>>>>>        End
106634>>>>>>
106634>>>>>
106634>>>>>        Get ReadCurrentSQLSettings to SQLConnection
106635>>>>>        If (SQLConnection.bError = True) Begin
106637>>>>>            Move "Login Error" to sError
106638>>>>>        End
106638>>>>>>
106638>>>>>
106638>>>>>        Function_Return SQLConnection.sConnectionString
106639>>>>>    End_Function
106640>>>>>
106640>>>>>    // Returns True if anything has changed.
106640>>>>>    Function Should_Save Returns Boolean
106643>>>>>        String[] sConnectionData sConnectionData2
106645>>>>>        tSQLConnection SQLConnectionData
106645>>>>>        tSQLConnection SQLConnectionData
106645>>>>>        Boolean bState
106645>>>>>
106645>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
106647>>>>>        Get pSQLConnectionData to SQLConnectionData
106648>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
106649>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
106649>>>>>        // to be able to compare properly.
106649>>>>>        Move "" to sConnectionData2[7]
106650>>>>>
106650>>>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
106651>>>>>        Function_Return (bState = False)
106652>>>>>    End_Function
106653>>>>>
106653>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
106656>>>>>        Integer iCount iSize iItems iCurrentRow
106656>>>>>        String sValue sConnectionID
106656>>>>>        Boolean bExists
106656>>>>>        tDataSourceRow[] TheData
106656>>>>>        tDataSourceRow[] TheData
106657>>>>>        tDataSourceRow TheRow
106657>>>>>        tDataSourceRow TheRow
106657>>>>>
106657>>>>>        Move 0 to iItems
106658>>>>>        Get piCurrentRow to iCurrentRow
106659>>>>>        Move SQLConnection.sConnectionID to sConnectionID
106660>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
106661>>>>>        Get pTheData to TheData
106662>>>>>        Move (SizeOfArray(TheData)) to iSize
106663>>>>>        If (iCurrentRow <> -1) Begin
106665>>>>>            // This is the sConnectionID:
106665>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
106666>>>>>        End
106666>>>>>>
106666>>>>>        Else Begin
106667>>>>>            Move TheRow to TheData[iSize]
106668>>>>>        End
106668>>>>>>
106668>>>>>        Move (SizeOfArray(TheData)) to iSize
106669>>>>>        Decrement iSize
106670>>>>>        For iCount from 0 to iSize
106676>>>>>>
106676>>>>>            Move TheData[iCount].sValue[2] to sValue
106677>>>>>            Move (sValue = sConnectionID) to bExists
106678>>>>>            If (bExists) Begin
106680>>>>>                Increment iItems
106681>>>>>            End
106681>>>>>>
106681>>>>>        Loop
106682>>>>>>
106682>>>>>
106682>>>>>        Function_Return (iItems > 1)
106683>>>>>    End_Function
106684>>>>>
106684>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
106684>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
106687>>>>>        tDataSourceRow TheRow
106687>>>>>        tDataSourceRow TheRow
106687>>>>>        Integer iDbType
106687>>>>>        String sValue
106687>>>>>
106687>>>>>        Move 0                                  to TheRow.sValue[0]
106688>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
106689>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
106690>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
106691>>>>>
106691>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
106691>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
106692>>>>>        Move sValue                             to TheRow.sValue[4]
106693>>>>>
106693>>>>>        Move SQLConnection.iDbType to iDbType
106694>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
106695>>>>>        Move sValue                             to TheRow.sValue[5]
106696>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
106697>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
106698>>>>>
106698>>>>>        // Hidden columns (to make Should_Save function work)
106698>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
106699>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
106700>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
106701>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
106702>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
106703>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
106704>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
106705>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
106706>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
106707>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
106707>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
106707>>>>>
106707>>>>>        Function_Return TheRow
106708>>>>>    End_Function
106709>>>>>
106709>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
106712>>>>>        String[] sConnectionData
106713>>>>>        Integer iRetval
106713>>>>>
106713>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
106714>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
106715>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
106716>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
106717>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
106718>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
106719>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
106720>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
106721>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
106722>>>>>
106722>>>>>        If (SQLConnection.sPassword <> "") Begin
106724>>>>>            Move MBR_Yes to iRetval
106725>>>>>            If (pbDFConnId(Self) = True) Begin
106727>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
106728>>>>>                If (iRetval = MBR_Yes) Begin
106730>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
106731>>>>>                    Move "" to SQLConnection.sPassword 
106732>>>>>//                    Set Enabled_State of oCheckLogin_btn to False
106732>>>>>                End
106732>>>>>>
106732>>>>>                Else Begin
106733>>>>>                    Send Stop_UI
106734>>>>>                End
106734>>>>>>
106734>>>>>            End
106734>>>>>>
106734>>>>>            Else Begin
106735>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
106736>>>>>            End
106736>>>>>>
106736>>>>>        End
106736>>>>>>
106736>>>>>
106736>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
106737>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
106738>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
106739>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
106740>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
106741>>>>>
106741>>>>>        Function_Return sConnectionData
106742>>>>>    End_Function
106743>>>>>
106743>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
106746>>>>>        tSQLConnection SQLConnection
106746>>>>>        tSQLConnection SQLConnection
106746>>>>>
106746>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
106747>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
106748>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
106749>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
106750>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
106751>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
106752>>>>>
106752>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
106753>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
106754>>>>>
106754>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
106756>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
106757>>>>>        End
106757>>>>>>
106757>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
106757>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
106757>>>>>        If (pbDFConnId(Self) = True) Begin
106759>>>>>            Get psUncryptedPw to SQLConnection.sPassword
106760>>>>>        End
106760>>>>>>
106760>>>>>
106760>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
106761>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
106762>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
106763>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
106764>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
106765>>>>>
106765>>>>>        // Connection string:
106765>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
106766>>>>>
106766>>>>>        Function_Return SQLConnection
106767>>>>>    End_Function
106768>>>>>
106768>>>>>    Procedure Popup
106771>>>>>        tSQLConnection SQLIniFileConnection
106771>>>>>        tSQLConnection SQLIniFileConnection
106771>>>>>        String[] sConnectionData
106772>>>>>        String sDriverID
106772>>>>>        Integer iDbType
106772>>>>>        Boolean bAdd
106772>>>>>
106772>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
106773>>>>>        Get pSQLConnectionData to SQLIniFileConnection             
106774>>>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
106774>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
106775>>>>>        Set Value of oDriverID_cf to ""
106776>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
106778>>>>>            Move True to SQLIniFileConnection.bEnabled
106779>>>>>        End
106779>>>>>>
106779>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
106780>>>>>
106780>>>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
106781>>>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
106782>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
106784>>>>>
106784>>>>>        // We need this message to "auto-default" certain fields.
106784>>>>>        If (bAdd = True) Begin
106786>>>>>            Get SelectedDbType of oDbType_cf to iDbType
106787>>>>>            Get Value of oDriverID_cf to sDriverID
106788>>>>>            If (sDriverID = "") Begin
106790>>>>>                Move MSSQLDRV_ID to sDriverID
106791>>>>>            End
106791>>>>>>
106791>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
106793>>>>>        End
106793>>>>>>
106793>>>>>
106793>>>>>        Set Password_State of oPassword_fm to True
106794>>>>>        Set Value of oLoginInfo_tb to ""
106795>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
106796>>>>>
106796>>>>>        Forward Send Popup
106798>>>>>    End_Procedure
106799>>>>>
106799>>>>>    Procedure Page Integer iPageObject
106802>>>>>        Boolean bNew bReadOnly
106802>>>>>        String sText
106802>>>>>        Handle hWnd
106802>>>>>
106802>>>>>        Send Cursor_Ready of Cursor_Control
106803>>>>>        Forward Send Page iPageObject
106805>>>>>
106805>>>>>        Set Icon to "SQLConnections1.ico"
106806>>>>>
106806>>>>>        Get pbNew to bNew
106807>>>>>        If (bNew = True) Begin
106809>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
106810>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
106811>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
106812>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
106813>>>>>            Send Info_Box sText
106814>>>>>        End
106814>>>>>>
106814>>>>>
106814>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
106816>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
106817>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
106818>>>>>        End
106818>>>>>>
106818>>>>>
106818>>>>>        Get pbReadOnly to bReadOnly
106819>>>>>        If (bReadOnly = True) Begin
106821>>>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
106823>>>>>            Set Enabled_State of oConnectionType_grp to True
106824>>>>>            Set Enabled_State of oSettings_grp       to True
106825>>>>>            Set Enabled_State of oPassword_fm        to True
106826>>>>>            Set Enabled_State of oViewPassword_btn   to True
106827>>>>>            Set Enabled_State of oCheckLogin_btn     to True
106828>>>>>            Set Enabled_State of oCancel_Btn         to True
106829>>>>>            Set Enabled_State of oHelp_Btn           to True
106830>>>>>            Set Enabled_State of oShowDriverSettings_btn to True
106831>>>>>            Set Enabled_State of oCreateDatabase_btn to False
106832>>>>>            Send Activate of oCancel_Btn
106833>>>>>        End
106833>>>>>>
106833>>>>>    End_Procedure
106834>>>>>
106834>>>>>    Function IniFileName Returns String
106837>>>>>        String sRetval
106837>>>>>        Function_Return sRetval
106838>>>>>    End_Function
106839>>>>>
106839>>>>>    // Put a status bar at the bottom of the panel, which makes
106839>>>>>    // status_help work and puts a gripper in the lower right corner.
106839>>>>>    Procedure End_Construct_Object
106842>>>>>        Integer iStyle iSize iOffset
106842>>>>>
106842>>>>>        Forward Send End_Construct_Object
106844>>>>>
106844>>>>>        Get Border_Style to iStyle
106845>>>>>        Move 8 to iOffset
106846>>>>>        If (iStyle = Border_Thick) Begin
106848>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
106850>>>>>                Object oStatusBar is a cCJStatusBar
106852>>>>>                    Set phoDialogCommandbar to Self
106853>>>>>                    Object oStatusIdle is a cCJStatusBarPane
106855>>>>>                        Set piId to sbpIDIdlePane
106856>>>>>                        Set pbStyleStretch to True
106857>>>>>                    End_Object
106858>>>>>                End_Object
106859>>>>>            End_Object
106860>>>>>
106860>>>>>            Get Size to iSize
106861>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
106862>>>>>        End
106862>>>>>>
106862>>>>>    End_Procedure
106863>>>>>
106863>>>>>    Procedure ShowProgramHelp
106866>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
106867>>>>>    End_Procedure
106868>>>>>
106868>>>>>    On_Key Key_F1         Send ShowProgramHelp
106869>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
106870>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
106871>>>>>End_Object
106872>>>>>
106872>>>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
106872>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
106875>>>>>    Handle ho
106875>>>>>    String sPath sSQLConnectionsFileName
106875>>>>>    Boolean bExists
106875>>>>>    
106875>>>>>    Send Cursor_Wait of Cursor_Control
106876>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
106877>>>>>    Set pbReadOnly              of ho to False
106878>>>>>    Set pbNew                   of ho to bNew
106879>>>>>    Set piCurrentRow            of ho to iCurrentRow
106880>>>>>    Set pbDFConnId              of ho to bDFConnId
106881>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
106882>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
106883>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
106884>>>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
106885>>>>>    If (bExists = True) Begin
106887>>>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
106888>>>>>    End
106888>>>>>>
106888>>>>>    
106888>>>>>    Set pTheData                of ho to TheData
106889>>>>>
106889>>>>>    Send Popup                  of ho
106890>>>>>
106890>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
106891>>>>>    Get pbChanged               of ho to bChanged
106892>>>>>End_Procedure
106893>>>>>
106893>>>>>// Read-only access message
106893>>>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
106896>>>>>    Handle ho
106896>>>>>    String sPath sSQLConnectionsFileName
106896>>>>>
106896>>>>>    Send Cursor_Wait of Cursor_Control
106897>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
106898>>>>>    Set pbReadOnly              of ho to True
106899>>>>>
106899>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
106900>>>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
106901>>>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
106902>>>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
106903>>>>>
106903>>>>>    Send Popup of ho
106904>>>>>End_Procedure
106905>>>>>
106905>>>
106905>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
106915>>>>
106915>>>Object oSQLMaintainConnection is a dbView
106917>>>    Set Size to 135 538
106918>>>    Set Location to 2 2
106919>>>    Set Maximize_Icon to True
106920>>>    Set Minimize_Icon to False
106921>>>    Set Border_Style to Border_Thick
106922>>>    Set View_Mode to Viewmode_Zoom
106923>>>    Set pbAutoActivate to True
106924>>>    Set pbAcceptDropFiles to True
106925>>>
106925>>>    Set phoMainView of ghoApplication to Self
106926>>>    
106926>>>    Property Boolean pbEnabled False
106928>>>    Property Boolean pbNew False
106930>>>    Property tDataSourceRow[] pTheData
106932>>>
106932>>>    Function IniFileName Returns String
106935>>>        String sRetval
106935>>>        Get InfileName of oSQLConnections_grd to sRetval
106936>>>        Function_Return sRetval
106937>>>    End_Function
106938>>>
106938>>>    Object oGridInfo_tb is a TextBox
106940>>>        Set Auto_Size_State to False
106941>>>        Set Size to 9 368
106942>>>        Set Location to 10 34
106943>>>        Set Label to "Note: You can drag and drop a connection file on to the grid."
106944>>>        Set FontItalics to True
106945>>>        Set peAnchors to anTopLeftRight
106946>>>        Set Justification_Mode to JMode_Left
106947>>>    End_Object
106948>>>
106948>>>    Object oSQLConnections_grd is a cCJGrid
106950>>>        Set Size to 98 503
106951>>>        Set Location to 25 19
106952>>>        Set peAnchors to anAll
106953>>>        Set pbShowRowFocus to True
106954>>>        Set pbUseAlternateRowBackgroundColor to True
106955>>>        Set pbSelectionEnable to True
106956>>>        Set pbRestoreLayout to True
106957>>>        Set psLayoutSection to "oSQLConnections_grd"
106958>>>        Set piLayoutBuild to 13
106959>>>        Set pbShowFooter to True
106960>>>        Set pbAllowAppendRow to False
106961>>>        Set pbAllowEdit to False
106962>>>        Set pbAllowInsertRow to False
106963>>>        Set pbAutoAppend to False
106964>>>        Set pbAutoSave to False
106965>>>        Set pbEditOnTyping to False
106966>>>            Set peVisualTheme to xtpReportThemeOffice2003
106967>>>            Set peTooltipStyle to xtpToolTipOffice2013
106968>>>        
106968>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
106970>>>            Set piWidth to 18
106971>>>        End_Object
106972>>>
106972>>>        Object oActive_Col is a cCJGridColumn
106974>>>            Set piWidth to 81
106975>>>            Set psCaption to "Enabled"
106976>>>            Set pbCheckbox to True
106977>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
106978>>>        End_Object
106979>>>
106979>>>        Object oConnectionID_Col is a cCJGridColumn
106981>>>            Set piWidth to 90
106982>>>            Set psCaption to "ID"
106983>>>        End_Object
106984>>>
106984>>>        Object oDbType_Col is a cCJGridColumn
106986>>>            Set piWidth to 150
106987>>>            Set psCaption to "Database Type"
106988>>>        End_Object
106989>>>
106989>>>        Object oServer_Col is a cCJGridColumn
106991>>>            Set piWidth to 138
106992>>>            Set psCaption to "Server"
106993>>>        End_Object
106994>>>
106994>>>        Object oDatabase_Col is a cCJGridColumn
106996>>>            Set piWidth to 92
106997>>>            Set psCaption to "Database"
106998>>>        End_Object
106999>>>
106999>>>        Object oDriver_Col is a cCJGridColumn
107001>>>            Set piWidth to 101
107002>>>            Set psCaption to "Driver ID"
107003>>>        End_Object
107004>>>
107004>>>        Object oConnectionString_Col is a cCJGridColumn
107006>>>            Set piWidth to 372
107007>>>            Set psCaption to "Connection String"
107008>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
107009>>>        End_Object
107010>>>
107010>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
107010>>>        // as the tSQLConnection data.
107010>>>        // See the "Should_Save" function
107010>>>        //
107010>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
107010>>>        Object oConnectionStringFull_Col is a cCJGridColumn
107012>>>            Set piWidth to 50
107013>>>            Set psCaption to "Connection String (Untouched)"
107014>>>            Set pbVisible to False   
107015>>>            Set pbShowInFieldChooser to False
107016>>>        End_Object
107017>>>
107017>>>        Object oTrusted_Col is a cCJGridColumn
107019>>>            Set piWidth to 50
107020>>>            Set psCaption to "Trusted"
107021>>>            Set pbCheckbox to True
107022>>>            Set pbVisible to False
107023>>>        End_Object
107024>>>
107024>>>        Object oUserID_Col is a cCJGridColumn
107026>>>            Set piWidth to 50
107027>>>            Set psCaption to "UserID"
107028>>>            Set pbVisible to False
107029>>>        End_Object
107030>>>
107030>>>        Object oPassword_Col is a cCJGridColumn
107032>>>            Set piWidth to 50
107033>>>            Set psCaption to "Password"
107034>>>            Set pbVisible to False
107035>>>            Set pbShowInFieldChooser to False
107036>>>        End_Object
107037>>>
107037>>>        Object oSchema_Col is a cCJGridColumn
107039>>>            Set piWidth to 50
107040>>>            Set psCaption to "Schema"
107041>>>            Set pbVisible to False
107042>>>        End_Object
107043>>>
107043>>>        Object oBaseTableSpace_Col is a cCJGridColumn
107045>>>            Set piWidth to 50
107046>>>            Set psCaption to "Base Table Space"
107047>>>            Set pbVisible to False
107048>>>        End_Object
107049>>>
107049>>>        Object oLongTableSpace_Col is a cCJGridColumn
107051>>>            Set piWidth to 50
107052>>>            Set psCaption to "Long Table Space"
107053>>>            Set pbVisible to False
107054>>>        End_Object
107055>>>
107055>>>        Object oIndexTableSpace_Col is a cCJGridColumn
107057>>>            Set piWidth to 50
107058>>>            Set psCaption to "Index Table Space"
107059>>>            Set pbVisible to False
107060>>>        End_Object
107061>>>
107061>>>        Object oSilentLogin_Col is a cCJGridColumn
107063>>>            Set piWidth to 50
107064>>>            Set psCaption to "Silent Login"
107065>>>            Set pbCheckbox to True
107066>>>            Set pbVisible to False
107067>>>        End_Object
107068>>>
107068>>>//        Object oDisabled_Col is a cCJGridColumn
107068>>>//            Set piWidth to 50
107068>>>//            Set psCaption to "Disabled"
107068>>>//            Set pbVisible to False
107068>>>//        End_Object
107068>>>
107068>>>        Object oCJContextMenu is a cCJContextMenu
107070>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
107071>>>
107071>>>            Object oAddMenuItem is a cCJMenuItem
107073>>>                Set psCaption to "Add"
107074>>>                Set psTooltip to "Add new connection"
107075>>>                Set psImage to "ActionAdd1.ico"
107076>>>                Set psShortcut to "Ctrl+A"
107077>>>                Procedure OnExecute Variant vCommandBarControl
107080>>>                    Forward Send OnExecute vCommandBarControl
107082>>>                    Send AddItem
107083>>>                End_Procedure
107084>>>            End_Object
107085>>>
107085>>>            Object oEditMenuItem is a cCJMenuItem
107087>>>                Set psCaption to "Edit"
107088>>>                Set psTooltip to "Edit existing connection"
107089>>>                Set psImage to "ActionEdit1.ico"
107090>>>                Set psShortcut to "Ctrl+E"
107091>>>                Procedure OnExecute Variant vCommandBarControl
107094>>>                    Forward Send OnExecute vCommandBarControl
107096>>>                    Send EditItem
107097>>>                End_Procedure
107098>>>            End_Object
107099>>>
107099>>>            Object oDeleteMenuItem is a cCJMenuItem
107101>>>                Set psCaption to "Delete"
107102>>>                Set psTooltip to "Delete current connection"
107103>>>                Set psImage to "ActionDelete1.ico"
107104>>>                Set psShortcut to "Del"
107105>>>                Procedure OnExecute Variant vCommandBarControl
107108>>>                    Forward Send OnExecute vCommandBarControl
107110>>>                    Send DeleteItem 
107111>>>                End_Procedure
107112>>>            End_Object
107113>>>
107113>>>            Object oSaveMenuItem is a cCJMenuItem
107115>>>                Set pbControlBeginGroup to True
107116>>>                Set psCaption to "Save"
107117>>>                Set psTooltip to "Save changes"
107118>>>                Set psImage to "ActionSave1.ico" 
107119>>>                Set psShortcut to "Ctrl+S"
107120>>>                
107120>>>                Procedure OnExecute Variant vCommandBarControl
107123>>>                    Forward Send OnExecute vCommandBarControl
107125>>>                    Send SaveIniFile 
107126>>>                End_Procedure
107127>>>
107127>>>                Function IsEnabled Returns Boolean
107130>>>                    Boolean bState
107130>>>                    Get Should_Save to bState
107131>>>                    Function_Return (bState = True)
107132>>>                End_Function
107133>>>            End_Object
107134>>>
107134>>>            Object oSaveAsMenuItem is a cCJMenuItem
107136>>>                Set psCaption to "Save As"
107137>>>                Set psTooltip to "Save SQL Configuration File As"  
107138>>>                Set psImage to "ActionSaveAs1.ico"
107139>>>                
107139>>>                Procedure OnExecute Variant vCommandBarControl  
107142>>>                    String sPath sIniFileName sFileName
107142>>>
107142>>>                    Forward Send OnExecute vCommandBarControl
107144>>>                    
107144>>>                    Get psIniFilePath of ghoSQLConnectionHandler to sPath
107145>>>                    Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
107146>>>                    Get vSelectSaveFile ".int" "Please enter a file name to save to" sPath sIniFileName to sFileName
107147>>>                    If (sFileName <> "") Begin
107149>>>                        Get ParseFolderName sFileName to sPath
107150>>>                        Get ParseFileName   sFileName to sIniFileName
107151>>>                        Set psIniFilePath of ghoSQLConnectionHandler to sPath
107152>>>                        Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
107153>>>                        Send SaveIniFile  of (phoMainView(ghoApplication))
107154>>>                    End
107154>>>>
107154>>>                End_Procedure
107155>>>
107155>>>            End_Object   
107156>>>
107156>>>            Object oOpenMenuItem is a cCJMenuItem
107158>>>                Set pbControlBeginGroup to True
107159>>>                Set psCaption to "Open"
107160>>>                Set psTooltip to "Open SQL Connection ini-file"
107161>>>                Set psImage to "ActionOpen1.ico"
107162>>>                Set psShortcut to "Ctrl+O"
107163>>>                Procedure OnExecute Variant vCommandBarControl
107166>>>                    Forward Send OnExecute vCommandBarControl
107168>>>                    Send ActivateOpenDialog
107169>>>                End_Procedure
107170>>>            End_Object
107171>>>
107171>>>            Object oRefreshMenuItem is a cCJMenuItem
107173>>>                Set psCaption to "Refresh"
107174>>>                Set psTooltip to "Refresh grid (re-read values from ini-file)"
107175>>>                Set psImage to "ActionRefresh1.ico"
107176>>>                Set psShortcut to "Ctrl+R"
107177>>>
107177>>>                Procedure OnExecute Variant vCommandBarControl
107180>>>                    Forward Send OnExecute vCommandBarControl
107182>>>                    Send RefreshIniFile
107183>>>                End_Procedure
107184>>>
107184>>>                Function IsEnabled Returns Boolean
107187>>>                    Boolean bSave
107187>>>                    Get Should_Save to bSave
107188>>>                    Function_Return (bSave = True)
107189>>>                End_Function
107190>>>                
107190>>>            End_Object
107191>>>
107191>>>            Set phoContextMenu to Self
107192>>>        End_Object
107193>>>
107193>>>        Function Should_Save Returns Boolean
107196>>>            tDataSourceRow[] TheData1 TheData2
107196>>>            tDataSourceRow[] TheData1 TheData2
107198>>>            Handle hoDataSource
107198>>>            Boolean bShouldSave
107198>>>
107198>>>            Move True to bShouldSave
107199>>>            Get pTheData to TheData1
107200>>>            Get phoDataSource to hoDataSource
107201>>>            Get DataSource    of hoDataSource to TheData2
107202>>>                Move (not(IsSameArray(TheData1, TheData2))) to bShouldSave
107203>>>
107203>>>            Function_Return bShouldSave
107204>>>        End_Function
107205>>>
107205>>>        Function HasRecord Returns Boolean
107208>>>            tDataSourceRow[] TheData
107208>>>            tDataSourceRow[] TheData
107209>>>            Handle hoDataSource
107209>>>            Integer iSize
107209>>>
107209>>>            Get phoDataSource to hoDataSource
107210>>>            Get DataSource    of hoDataSource to TheData
107211>>>            Move (SizeOfArray(TheData)) to iSize
107212>>>
107212>>>            Function_Return (iSize > 0)
107213>>>        End_Function
107214>>>
107214>>>        Procedure ChangeHeaderText
107217>>>            Handle[] hoPanels
107218>>>            String sFileName
107218>>>
107218>>>            Send ChangeStatusRowText ""
107219>>>            Get IniFileName to sFileName
107220>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
107220>>>            // it wasn't always updated when this message was send. So instead change the
107220>>>            // text explicitly:
107220>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
107221>>>            Set psText of hoPanels[0] to sFileName
107222>>>        End_Procedure
107223>>>        
107223>>>        Function InFileName Returns String
107226>>>            String sFileName sPath
107226>>>            Handle ho
107226>>>            Boolean bChangesExist
107226>>>
107226>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107227>>>            Get psIniFilePath of ho to sPath
107228>>>            Get psIniFileName of ho to sFileName
107229>>>            If (sFileName = "") Begin
107231>>>                Move "" to sPath
107232>>>            End                 
107232>>>>
107232>>>            Else Begin
107233>>>                Get Should_Save to bChangesExist
107234>>>                If (bChangesExist = True) Begin
107236>>>                    Move (sFileName + "*") to sFileName
107237>>>                End
107237>>>>
107237>>>            End
107237>>>>
107237>>>            Function_Return (sPath + sFileName)
107238>>>        End_Function
107239>>>
107239>>>        Procedure LoadData
107242>>>            Handle hoDataSource ho
107242>>>            tDataSourceRow[] TheData
107242>>>            tDataSourceRow[] TheData
107243>>>            tDataSourceRow TheRow
107243>>>            tDataSourceRow TheRow
107243>>>            Integer iCount iSize
107243>>>            tSQLConnection[] SQLConnectionsArray
107243>>>            tSQLConnection[] SQLConnectionsArray
107244>>>
107244>>>            Send ChangeHeaderText
107245>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107246>>>
107246>>>            Get phoDataSource to hoDataSource
107247>>>            Send Reset of hoDataSource
107248>>>
107248>>>            Get ReadIniFile to SQLConnectionsArray
107249>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
107250>>>            Decrement iSize
107251>>>
107251>>>            // Load data to the grid datasource array
107251>>>            For iCount from 0 to iSize
107257>>>>
107257>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
107258>>>                Move TheRow to TheData[iCount]
107259>>>            Loop
107260>>>>
107260>>>
107260>>>            Set pTheData to TheData
107261>>>
107261>>>            // Initialize Grid with new data
107261>>>            Send InitializeData TheData
107262>>>
107262>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
107263>>>            Send MovetoFirstRow
107264>>>        End_Procedure    
107265>>>        
107265>>>        Procedure ClearData    
107268>>>            Handle hoDataSource
107268>>>            tDataSourceRow[] TheData
107268>>>            tDataSourceRow[] TheData
107269>>>
107269>>>            Send ChangeHeaderText
107270>>>            Set pTheData to TheData
107271>>>            Get phoDataSource to hoDataSource 
107272>>>            Send InitializeData TheData
107273>>>        End_Procedure
107274>>>
107274>>>        // Transfers data between a tSQLConnection struct and a grid data row.
107274>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
107277>>>            tDataSourceRow TheRow
107277>>>            tDataSourceRow TheRow
107277>>>            Integer iDbType
107277>>>            String sValue
107277>>>
107277>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
107278>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
107279>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
107280>>>
107280>>>            // We only show three asterisks ("***") instead of the password in the grid.
107280>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
107281>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
107282>>>
107282>>>            Move SQLConnection.iDbType to iDbType
107283>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
107284>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
107285>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
107286>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
107287>>>
107287>>>            // Hidden columns (to make Should_Save function work)
107287>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
107288>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
107289>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
107290>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
107291>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
107292>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
107293>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
107294>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
107295>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
107296>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
107296>>>
107296>>>            Function_Return TheRow
107297>>>        End_Function
107298>>>
107298>>>        // Transfers data between a grid data row and a tSQLConnection struct.
107298>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
107301>>>            tSQLConnection SQLConnection
107301>>>            tSQLConnection SQLConnection
107301>>>            String sValue
107301>>>
107301>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
107302>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
107303>>>
107303>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
107304>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
107305>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
107306>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
107307>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
107308>>>
107308>>>            // Hidden columns (to make Should_Save function work)
107308>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
107309>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
107310>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
107311>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
107312>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
107313>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
107314>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
107315>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
107316>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
107317>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
107317>>>
107317>>>            Function_Return SQLConnection
107318>>>        End_Function
107319>>>
107319>>>        // Called when the grid object is created:
107319>>>        Procedure Activating
107322>>>            Forward Send Activating
107324>>>            Send LoadData
107325>>>        End_Procedure
107326>>>
107326>>>        Function CurrentRow Returns Integer
107329>>>            Handle hoDataSource
107329>>>            Integer iRow
107329>>>
107329>>>            Get phoDataSource to hoDataSource
107330>>>            Get SelectedRow   of hoDataSource to iRow
107331>>>            Function_Return iRow
107332>>>        End_Function
107333>>>
107333>>>        Function CurrentRowData Returns tDataSourceRow
107336>>>            tDataSourceRow[] TheData
107336>>>            tDataSourceRow[] TheData
107337>>>            tDataSourceRow TheRow
107337>>>            tDataSourceRow TheRow
107337>>>            Handle ho hoDataSource
107337>>>            Integer iRow
107337>>>
107337>>>            Get phoDataSource  to hoDataSource
107338>>>            Get DataSource     of hoDataSource to TheData
107339>>>            Get SelectedRow    of hoDataSource to iRow
107340>>>            Move TheData[iRow] to TheRow
107341>>>
107341>>>            Function_Return TheRow
107342>>>        End_Function
107343>>>
107343>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
107346>>>            Integer iRow
107346>>>            Handle hoDataSource
107346>>>            tDataSourceRow[] RowData
107346>>>            tDataSourceRow[] RowData
107347>>>
107347>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
107349>>>            Send ChangeHeaderText
107350>>>
107350>>>            Get phoDataSource to hoDataSource
107351>>>
107351>>>            Get SelectedRow of hoDataSource to iRow
107352>>>            If (iRow <> -1) Begin
107354>>>                Get DataSource of hoDataSource to RowData
107355>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
107356>>>            End
107356>>>>
107356>>>        End_Procedure
107357>>>
107357>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
107360>>>            Forward Send OnComRowDblClick llRow llItem
107362>>>            Delegate Send EditItem 
107364>>>        End_Procedure
107365>>>
107365>>>        Procedure OnEnterKey
107368>>>            Forward Send OnEnterKey
107370>>>            Delegate Send EditItem 
107372>>>        End_Procedure
107373>>>
107373>>>        Procedure AddConnection tDataSourceRow TheRow
107376>>>            Integer iSize iCount
107376>>>            Handle hoDataSource
107376>>>            tDataSourceRow[] TheData
107376>>>            tDataSourceRow[] TheData
107377>>>            Boolean bEnabled
107377>>>
107377>>>            Get phoDataSource to hoDataSource
107378>>>            Get DataSource    of hoDataSource to TheData
107379>>>
107379>>>            Move (SizeOfArray(TheData)) to iSize
107380>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
107381>>>            If (bEnabled = True) Begin
107383>>>                // Then bEnabled state have changed; deactivate all current rows.
107383>>>                For iCount from 0 to (iSize -1)
107389>>>>
107389>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
107390>>>                Loop
107391>>>>
107391>>>            End
107391>>>>
107391>>>
107391>>>            Move TheRow to TheData[iSize]
107392>>>
107392>>>            // Initialize Grid with new data
107392>>>            Send InitializeData TheData True
107393>>>            Move (SizeOfArray(TheData)) to iSize
107394>>>            Send MoveToLastRow
107395>>>
107395>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
107396>>>        End_Procedure
107397>>>
107397>>>        Procedure UpdateConnection tDataSourceRow TheRow
107400>>>            Integer iRow iSize iCount
107400>>>            Handle hoDataSource
107400>>>            tDataSourceRow[] TheData
107400>>>            tDataSourceRow[] TheData
107401>>>            Boolean bEnabled
107401>>>
107401>>>            Get phoDataSource to hoDataSource
107402>>>            Get SelectedRow of hoDataSource to iRow
107403>>>            If (iRow <> -1) Begin
107405>>>                Get DataSource of hoDataSource to TheData
107406>>>
107406>>>                // If bEnabled state has changed; deactivate all rows.
107406>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
107407>>>                If (bEnabled = True) Begin
107409>>>                    Move (SizeOfArray(TheData)) to iSize
107410>>>                    Decrement iSize
107411>>>                    For iCount from 0 to iSize
107417>>>>
107417>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
107418>>>                    Loop
107419>>>>
107419>>>                End
107419>>>>
107419>>>
107419>>>                Move TheRow to TheData[iRow]
107420>>>            End
107420>>>>
107420>>>
107420>>>            // Initialize Grid with new data
107420>>>            Send ReInitializeData TheData True
107421>>>            Move (SizeOfArray(TheData)) to iSize
107422>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
107423>>>        End_Procedure
107424>>>
107424>>>        Procedure RemoveCurrentConnection
107427>>>            Integer iSize iRow iItem
107427>>>            Handle hoDataSource
107427>>>            tDataSourceRow[] TheData
107427>>>            tDataSourceRow[] TheData
107428>>>
107428>>>            Move 0 to iItem
107429>>>            Get phoDataSource to hoDataSource
107430>>>            Get DataSource of hoDataSource to TheData
107431>>>
107431>>>            Get SelectedRow of hoDataSource to iRow
107432>>>            If (iRow = -1) Begin
107434>>>                Procedure_Return
107435>>>            End
107435>>>>
107435>>>
107435>>>            Move False to Err
107436>>>            Send Request_Delete
107437>>>
107437>>>            Get DataSource of hoDataSource to TheData
107438>>>            Move (SizeOfArray(TheData)) to iSize
107439>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
107440>>>        End_Procedure
107441>>>
107441>>>        Function IsOneItemActive Returns Boolean
107444>>>            Handle hoDataSource ho
107444>>>            tDataSourceRow[] TheData
107444>>>            tDataSourceRow[] TheData
107445>>>            Integer iSize iCount
107445>>>            Boolean bRetval bExists
107445>>>            String sSection
107445>>>
107445>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107446>>>            Get psIniSectionName of ho to sSection
107447>>>            Get SectionExists    of ho sSection to bExists
107448>>>
107448>>>            Get phoDataSource to hoDataSource
107449>>>            Get DataSource of hoDataSource to TheData
107450>>>
107450>>>            Move (SizeOfArray(TheData)) to iSize
107451>>>            If (iSize = 0) Begin
107453>>>                Function_Return True
107454>>>            End
107454>>>>
107454>>>
107454>>>            Decrement iSize
107455>>>            For iCount from 0 to iSize
107461>>>>
107461>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
107463>>>                    Move True to bRetval
107464>>>                End
107464>>>>
107464>>>            Loop
107465>>>>
107465>>>
107465>>>            Function_Return bRetval
107466>>>        End_Function
107467>>>
107467>>>        Function ReadIniFile Returns tSQLConnection[]
107470>>>            tSQLConnection[] SQLConnectionsArray
107470>>>            tSQLConnection[] SQLConnectionsArray
107471>>>            Handle ho
107471>>>
107471>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107472>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
107473>>>
107473>>>            Function_Return SQLConnectionsArray
107474>>>        End_Function
107475>>>
107475>>>        Procedure WriteIniFile
107478>>>            Integer iCount iSize iRetval
107478>>>            Handle hoDataSource ho
107478>>>            tDataSourceRow[] TheData
107478>>>            tDataSourceRow[] TheData
107479>>>            tDataSourceRow TheRow
107479>>>            tDataSourceRow TheRow
107479>>>            tSQLConnection[] SQLConnectionArray
107479>>>            tSQLConnection[] SQLConnectionArray
107480>>>            tSQLConnection SQLConnection
107480>>>            tSQLConnection SQLConnection
107480>>>            Boolean bIsOneActive bOK
107480>>>            String sPath sIniFileName
107480>>>            
107480>>>            Get psIniFileName of ghoSQLConnectionHandler to sIniFileName
107481>>>            If (sIniFileName = "") Begin
107483>>>                Get vSelectSaveFile ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sIniFileName
107484>>>                If (sIniFileName <> "") Begin
107486>>>                    Get ParseFolderName sIniFileName to sPath
107487>>>                    Set psIniFilePath of ghoSQLConnectionHandler to sPath
107488>>>                    Get ParseFileName sIniFileName to sIniFileName
107489>>>                    Set psIniFileName of ghoSQLConnectionHandler to sIniFileName
107490>>>                End  
107490>>>>
107490>>>                Else Begin
107491>>>                    Procedure_Return
107492>>>                End
107492>>>>
107492>>>            End
107492>>>>
107492>>>            
107492>>>            // 2018-07-14 I don't think this is necessary. In fact it can be quite practical in
107492>>>            // testing to disable all connections, or if e.g. customer's connections has been tested,
107492>>>            // that no longer are available locally.
107492>>>            Get IsOneItemActive to bIsOneActive
107493>>>//            If (bIsOneActive = False) Begin
107493>>>//                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
107493>>>//                Procedure_Return
107493>>>//            End
107493>>>            If (bIsOneActive = False) Begin
107495>>>                Get YesNo_Box "Warning, no connection has been set to 'Enabled'. That means that the Database Framework will not read any information from here when initialized.\n\nAre you sure you want to continue to save without any connection Enabled?" to iRetval
107496>>>                If (iRetval = MBR_No) Begin
107498>>>                    Procedure_Return
107499>>>                End
107499>>>>
107499>>>            End
107499>>>>
107499>>>
107499>>>            Move 0 to iCount
107500>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107501>>>            Get phoDataSource to hoDataSource
107502>>>            Get DataSource of hoDataSource to TheData
107503>>>            Move (SizeOfArray(TheData)) to iSize
107504>>>            Decrement iSize
107505>>>
107505>>>            // Load data from the grid datasource array to SQLConnection array
107505>>>            For iCount from 0 to iSize
107511>>>>
107511>>>                Move TheData[iCount] to TheRow
107512>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
107513>>>                Move SQLConnection to SQLConnectionArray[iCount]
107514>>>            Loop
107515>>>>
107515>>>
107515>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
107516>>>            If (bOK = False) Begin
107518>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
107519>>>                Procedure_Return
107520>>>            End
107520>>>>
107520>>>
107520>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
107520>>>            Set pTheData to TheData
107521>>>            Send ChangeHeaderText
107522>>>            Send ChangeStatusRowText "Ready! File saved."
107523>>>        End_Procedure
107524>>>
107524>>>        Procedure OnHeaderClick Integer iCol
107527>>>            String sPath sFileName
107527>>>            Handle ho
107527>>>
107527>>>            Forward Send OnHeaderClick iCol
107529>>>
107529>>>            Get vSelect_File ("SQLConnections ini-files (*.ini)|" + CS_SQLIniFileName + "|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*") "Select a connection ini-file" "" to sFileName
107530>>>            If (sFileName <> "") Begin
107532>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107533>>>                Get ParseFolderName sFileName to sPath
107534>>>                Set psIniFilePath of ho to sPath
107535>>>                Get ParseFileName sFileName to sFileName
107536>>>                Set psIniFileName of ho to sFilename
107537>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
107538>>>                Send LoadData of oSQLConnections_grd
107539>>>            End
107539>>>>
107539>>>        End_Procedure
107540>>>
107540>>>        Procedure OnCreateGridControl 
107543>>>            Handle hoObject  
107543>>>            Integer iToolTipStyle      
107543>>>            Boolean bIsBalloonStyleSupported
107543>>>            
107543>>>            Forward Send OnCreateGridControl
107545>>>    
107545>>>            Get phoToolTipContext to hoObject
107546>>>            If (hoObject <> 0) Begin
107548>>>                Move xtpToolTipStandard to iToolTipStyle    
107549>>>                // Baloon tooltip style requires IE 5.0 or later, so check if installed.
107549>>>                // The ComShowTitleAndDescription also requires IE 5.0.
107549>>>                Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
107550>>>                If (bIsBalloonStyleSupported = True) Begin
107552>>>                    Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
107553>>>                End                                                   
107553>>>>
107553>>>                Set ComStyle             of hoObject to iToolTipStyle
107554>>>                Set ComShowOfficeBorder  of hoObject to True
107555>>>                Set ComShowShadow        of hoObject to True
107556>>>                // Set the max width for a tooltip. 250 just seems to be a good
107556>>>                // compromise. After 250 pixels the text will wrap to the next line automatically.
107556>>>                Set ComMaxTipWidth       of hoObject to 250 // In pixels
107557>>>            End 
107557>>>>
107557>>>        End_Procedure
107558>>>
107558>>>        // These overrides the grid standar behaviour
107558>>>        On_Key kSave_Record Send SaveIniFile
107559>>>        On_Key Key_F5       Send RefreshIniFile
107560>>>    End_Object
107561>>>
107561>>>    // Public access methods: (used by menu/toolbar system)
107561>>>    Procedure ActivateOpenDialog
107564>>>        Send OnHeaderClick of oSQLConnections_grd 1
107565>>>    End_Procedure
107566>>>
107566>>>    Procedure RefreshIniFile
107569>>>        Boolean bChanged
107569>>>        Handle ho
107569>>>        Integer iRetval
107569>>>
107569>>>        Move (oSQLConnections_grd(Self)) to ho
107570>>>        Get Should_Save of ho to bChanged
107571>>>        If (bChanged = True) Begin
107573>>>            Get YesNo_Box "Changes exists! Press 'Yes' to refresh (changes will be lost)." "Refresh Question" to iRetval
107574>>>            If (iRetval <> MBR_Yes) Begin
107576>>>                Procedure_Return
107577>>>            End
107577>>>>
107577>>>        End
107577>>>>
107577>>>        Send ChangeStatusRowText ""
107578>>>        Send LoadData of oSQLConnections_grd
107579>>>    End_Procedure
107580>>>
107580>>>    Procedure AddItem
107583>>>        Boolean bChanged bDFConnId
107583>>>        tSQLConnection SQLConnection
107583>>>        tSQLConnection SQLConnection
107583>>>        tDataSourceRow[] TheData
107583>>>        tDataSourceRow[] TheData
107584>>>        tDataSourceRow   TheRow
107584>>>        tDataSourceRow   TheRow
107584>>>        Handle hoDataSource
107584>>>
107584>>>        Send ChangeStatusRowText ""
107585>>>        Get IsDFConnId to bDFConnId
107586>>>        Move EN_DbTypeMSSQL to SQLConnection.iDbType
107587>>>        Move MSSQLDRV_ID    to SQLConnection.sDriverID
107588>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
107589>>>        Get DataSource of hoDataSource to TheData
107590>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
107591>>>        If (bChanged = True) Begin
107593>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
107594>>>            Send AddConnection of oSQLConnections_grd TheRow
107595>>>        End
107595>>>>
107595>>>    End_Procedure
107596>>>
107596>>>    Procedure EditItem
107599>>>        Boolean bEnabled bChanged bDFConnId
107599>>>        tSQLConnection SQLConnection
107599>>>        tSQLConnection SQLConnection
107599>>>        tDataSourceRow TheRow
107599>>>        tDataSourceRow TheRow
107599>>>        tDataSourceRow[] TheData
107599>>>        tDataSourceRow[] TheData
107600>>>        Handle hoDataSource
107600>>>        Integer iCurrentRow
107600>>>
107600>>>        Get CurrentRowData of oSQLConnections_grd to TheRow
107601>>>        Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
107602>>>        Send ChangeStatusRowText ""
107603>>>        Get pbEnabled to bEnabled
107604>>>        Get IsDFConnId to bDFConnId
107605>>>
107605>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
107606>>>        Get DataSource of hoDataSource to TheData
107607>>>        Get CurrentRow of oSQLConnections_grd to iCurrentRow
107608>>>
107608>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
107609>>>        If (bChanged = True) Begin
107611>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
107612>>>            Send UpdateConnection of oSQLConnections_grd TheRow
107613>>>        End
107613>>>>
107613>>>    End_Procedure
107614>>>
107614>>>    Procedure SaveIniFile
107617>>>        Send ChangeStatusRowText ""
107618>>>        Send WriteIniFile of oSQLConnections_grd
107619>>>    End_Procedure
107620>>>
107620>>>    Procedure ClearIniFile
107623>>>        Handle ho
107623>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107624>>>        Set psIniFilePath of ho to ""
107625>>>        Set psIniFileName of ho to ""
107626>>>        Set pbDFConnId of ho to False
107627>>>        Send ClearData of (oSQLConnections_grd(phoMainView(ghoApplication))) 
107628>>>    End_Procedure   
107629>>>                
107629>>>    Procedure DeleteItem
107632>>>        Send ChangeStatusRowText ""
107633>>>        Send RemoveCurrentConnection of oSQLConnections_grd
107634>>>    End_Procedure
107635>>>
107635>>>    Procedure ExitApplication
107638>>>        Send Exit_Application of ghoApplication
107639>>>    End_Procedure
107640>>>    
107640>>>    // Other messages used by the view:
107640>>>    Function IsDFConnId Returns Boolean
107643>>>        Boolean bDFConnId
107643>>>        Handle ho
107643>>>        String sFileName
107643>>>
107643>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107644>>>        Get psIniFileName of ho to sFileName
107645>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
107646>>>        Set pbDFConnId of ho to bDFConnId
107647>>>
107647>>>        Function_Return bDFConnId
107648>>>    End_Function
107649>>>
107649>>>    Procedure OnFileDropped String sFilename Boolean bLast
107652>>>        Boolean bHasChange
107652>>>        Handle ho hoGrid
107652>>>        Integer iRetval
107652>>>        String sPath
107652>>>
107652>>>        Forward Send OnFileDropped sFilename bLast
107654>>>
107654>>>        If (bLast = True) Begin
107656>>>            Move (oSQLConnections_grd(Self)) to hoGrid
107657>>>            Get ParseFolderName sFilename to sPath
107658>>>            Get ParseFileName   sFilename to sFilename
107659>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
107661>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
107662>>>                Procedure_Return
107663>>>            End
107663>>>>
107663>>>            Get Should_Save of hoGrid to bHasChange
107664>>>            If (bHasChange = True) Begin
107666>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
107667>>>                If (iRetval <> MBR_Yes) Begin
107669>>>                    Procedure_Return
107670>>>                End
107670>>>>
107670>>>            End
107670>>>>
107670>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
107671>>>            Set psIniFilePath of ho to sPath
107672>>>            Set psIniFileName of ho to sFilename
107673>>>            Send LoadData of oSQLConnections_grd
107674>>>        End
107674>>>>
107674>>>    End_Procedure
107675>>>
107675>>>    // This is only being called when there is no SQLConnections.ini file;
107675>>>    // thus a new active/enabled DFConnection ID needs to be established.
107675>>>    Procedure ConnectionDoesNotExist
107678>>>        tSQLConnection SQLConnection
107678>>>        tSQLConnection SQLConnection
107678>>>        Boolean bChanged bDFConnId bEnabled
107678>>>        Handle ho
107678>>>        tDataSourceRow TheRow
107678>>>        tDataSourceRow TheRow
107678>>>        Handle hoDataSource
107678>>>        tDataSourceRow[] TheData
107678>>>        tDataSourceRow[] TheData
107679>>>
107679>>>        Get IsDFConnId to bDFConnId
107680>>>
107680>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
107681>>>        Move True to bEnabled
107682>>>        Set pbNew to True
107683>>>        Set pbNew of ho to True
107684>>>
107684>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
107685>>>        Get DataSource of hoDataSource to TheData
107686>>>
107686>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
107687>>>        If (bChanged = True) Begin
107689>>>            // We also need to tell the main connection object that we now have
107689>>>            // created a connection.
107689>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
107690>>>            // And add the data to the grid.
107690>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
107691>>>            Send AddConnection of oSQLConnections_grd TheRow
107692>>>            // Not new anymore.
107692>>>            Set pbNew to False
107693>>>            Set pbNew of ho to False
107694>>>        End
107694>>>>
107694>>>    End_Procedure
107695>>>
107695>>>    Procedure ChangeStatusRowText String sText
107698>>>        Handle[] hoPanels
107699>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
107700>>>        Set psText of hoPanels[1] to sText
107701>>>    End_Procedure
107702>>>
107702>>>    // On idle handling:
107702>>>    Object oIdle is a cIdleHandler
107704>>>        Procedure OnIdle
107707>>>          Delegate Send OnIdle
107709>>>        End_Procedure
107710>>>    End_Object
107711>>>
107711>>>    Procedure OnIdle
107714>>>        Handle ho
107714>>>
107714>>>        Move (oSQLConnections_grd(Self)) to ho
107715>>>        Send ChangeHeaderText of ho
107716>>>    End_Procedure
107717>>>
107717>>>    Procedure Activating
107720>>>        Handle ho
107720>>>
107720>>>        Set Maximize_Icon to True
107721>>>        Set Minimize_Icon to False
107722>>>        Set Border_Style to Border_Thick
107723>>>        Set View_Mode to Viewmode_Zoom
107724>>>
107724>>>        // Note: The following line is essential for the resizing logic
107724>>>        // to work when starting the program.
107724>>>        Move (Client_Id(ghoCommandBars)) to ho
107725>>>        Set Border_Style of ho to Border_ClientEdge
107726>>>
107726>>>        Set pbEnabled of oIdle to True
107727>>>    End_Procedure
107728>>>
107728>>>    Procedure Deactivating
107731>>>        Set pbEnabled of oIdle to False
107732>>>        Forward Send Deactivating
107734>>>    End_Procedure
107735>>>
107735>>>    Function Verify_Exit_Application Returns Integer
107738>>>        Integer iRetval
107738>>>        Boolean bChanged
107738>>>
107738>>>        Get Should_Save of oSQLConnections_grd to bChanged
107739>>>        If (bChanged = False) Begin
107741>>>            Function_Return False
107742>>>        End
107742>>>>
107742>>>        Else Begin
107743>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
107744>>>            If (iRetval = MBR_Cancel) Begin
107746>>>                Function_Return True
107747>>>            End
107747>>>>
107747>>>            If (iRetval = MBR_Yes) Begin
107749>>>                Send SaveIniFile //KeyAction of oSave_btn
107750>>>                Send Exit_Application
107751>>>            End
107751>>>>
107751>>>            If (iRetval = MBR_No) Begin
107753>>>                Function_Return False
107754>>>            End
107754>>>>
107754>>>        End
107754>>>>
107754>>>        Function_Return True
107755>>>    End_Function
107756>>>
107756>>>    On_Key kDelete_Character Send DeleteItem 
107757>>>    On_Key Key_Ctrl+Key_D    Send DeleteItem 
107758>>>    On_Key Key_Alt+Key_D     Send DeleteItem 
107759>>>    On_Key Key_Ctrl+Key_E    Send EditItem   
107760>>>    On_Key Key_Alt+Key_E     Send EditItem   
107761>>>    On_Key Key_Ctrl+Key_A    Send AddItem    
107762>>>    On_Key Key_Alt+Key_A     Send AddItem    
107763>>>    On_Key Key_F5            Send RefreshIniFile 
107764>>>    On_Key Key_Ctrl+Key_R    Send RefreshIniFile 
107765>>>    On_Key Key_Alt+Key_R     Send RefreshIniFile 
107766>>>    On_Key Key_Ctrl+Key_F5   Send ClearIniFile
107767>>>    On_Key kSave_Record      Send SaveIniFile    
107768>>>    On_Key Key_Ctrl+Key_S    Send SaveIniFile    
107769>>>    On_Key Key_F2            Send SaveIniFile    
107770>>>    On_Key Key_Ctrl+Key_X    Send ExitApplication
107771>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
107772>>>    On_Key Key_Alt+Key_O     Send ActivateOpenDialog
107773>>>    On_Key kCancel           Send None
107774>>>    On_Key Key_Ctrl+Key_F4   Send None
107775>>>End_Object
107776>        Use ManageSQLConnections.dg
107776>        Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
107776>>>Use Windows.pkg
107776>>>Use Dfspnfrm.pkg
107776>>>Use cRegistry.pkg
107776>>>Use vWin32fh.pkg
107776>>>
107776>>>Enum_List
107776>>>    Define cx_RegKeyAlreadyExist
107776>>>    Define cx_RegKeyCreated
107776>>>    Define cx_RegkeyFailed
107776>>>    Define cx_RegKeyVDFKeyDoesNotExist
107776>>>    Define CX_InstalledOkVdfUnder16
107776>>>End_Enum_List
107776>>>
107776>>>// Note: The "Visual" part will automatically be removed if
107776>>>// the current DataFlex version is above 17.
107776>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
107776>>>Define CS_StudioTools       for "\Studio\Tools"
107776>>>Define CS_RegApplication    for "<application>"
107776>>>Define CS_RegWorkspace      for "<workspace>"
107776>>>Define CS_CommandLine       for "CommandLine"
107776>>>Define CS_Name              for "Name"
107776>>>Define CS_Separator         for "Separator"
107776>>>Define CS_Command           for "Command"
107776>>>
107776>>>Object oAddToStudio_dg is a ModalPanel
107778>>>    Set Size to 79 330
107779>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
107780>>>    Set piMinSize to 79 211
107781>>>    Set Location to 5 4
107782>>>    Set Locate_Mode to Center_On_Parent
107783>>>
107783>>>    Property String psTag CS_RegApplication
107785>>>
107785>>>    Object oStudioIntegration_grp is a Group
107787>>>        Set Size to 45 299
107788>>>        Set Location to 8 15
107789>>>        Set Label to "DataFlex Studio Integration"
107790>>>
107790>>>        Object oStudioMajorVersion_sf is a SpinForm
107792>>>            Set Size to 12 27
107793>>>            Set Location to 18 168
107794>>>            Set Maximum_Position to 30
107795>>>            Set Minimum_Position to 14
107796>>>            Set Label_Col_Offset to 2
107797>>>            Set Label_Justification_Mode to JMode_Right
107798>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
107799>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
107800>>>            Set Value to FMAC_VERSION
107801>>>            Set peAnchors to anNone
107802>>>        End_Object
107803>>>
107803>>>        Object oStudioMinorVersion_sf is a SpinForm
107805>>>            Set Size to 12 27
107806>>>            Set Location to 18 254
107807>>>            Set Label_Col_Offset to 2
107808>>>            Set Label to "Minor Version"
107809>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
107810>>>            Set Maximum_Position to 9
107811>>>            Set Minimum_Position to 0
107812>>>            Set Value to FMAC_REVISION
107813>>>            Set Label_Justification_Mode to JMode_Right
107814>>>            Set peAnchors to anNone
107815>>>        End_Object
107816>>>
107816>>>    End_Object
107817>>>
107817>>>    Object oOK_btn is a Button
107819>>>        Set Location to 59 207
107820>>>        Set Label to "Add Now"
107821>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
107822>>>        Set peAnchors to anTopRight
107823>>>
107823>>>        Procedure OnClick
107826>>>            Integer iRetval iMajorVersion iMinorVersion
107826>>>            String sText sStudioVersion
107826>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
107827>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
107828>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
107829>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
107830>>>            Case Begin
107830>>>                Case (iRetval = cx_RegKeyAlreadyExist)
107832>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
107833>>>                    Break
107834>>>                Case (iRetval = cx_RegKeyCreated)
107837>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
107838>>>                    Break
107839>>>                Case (iRetval = cx_RegkeyFailed)
107842>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
107843>>>                    Break
107844>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
107847>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
107848>>>                    Break
107849>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
107852>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
107853>>>                    Break
107854>>>            Case End
107854>>>
107854>>>            Send Info_Box sText
107855>>>        End_Procedure
107856>>>    End_Object
107857>>>
107857>>>    Object oCancel_Btn is a Button
107859>>>        Set Label to C_$Close
107860>>>        Set Location to 59 264
107861>>>        Set peAnchors to anBottomRight
107862>>>
107862>>>        Procedure OnClick
107865>>>            Send Close_Panel
107866>>>        End_Procedure
107867>>>
107867>>>    End_Object
107868>>>
107868>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
107871>>>        Boolean bOk bExists bOpen
107871>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
107871>>>        Handle hoReg hoArray
107871>>>        Integer i iItems iCreated iRetval
107871>>>
107871>>>        Move False to bOk
107872>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
107873>>>        If (sStudioVersion > "17.1") Begin
107875>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
107876>>>        End
107876>>>>
107876>>>
107876>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
107877>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
107878>>>        Get vFolderFormat sProgramPath to sProgramPath
107879>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
107880>>>        Get Module_Name to sProgram
107881>>>        Get Create (RefClass(cRegistry)) to hoReg
107882>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
107883>>>
107883>>>        // First check if the VDF version is installed
107883>>>        Get KeyExists of hoReg sStudioPath to bExists
107884>>>        If (bExists = False) Begin
107886>>>            Send Destroy of hoReg
107887>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
107888>>>        End
107888>>>>
107888>>>
107888>>>        // Then check if any tools have been installed in the Tools Menu.
107888>>>        // If no tools created yet, create the Tools registry key.
107888>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
107889>>>        Get KeyExists of hoReg sStudioPath to bExists
107890>>>        If (bExists = False) Begin
107892>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
107893>>>            Get CreateKey of hoReg sStudioPath to iCreated
107894>>>            If (iCreated <> 0) Begin
107896>>>                Move cx_RegkeyFailed to iRetval
107897>>>            End
107897>>>>
107897>>>            Else Begin
107898>>>                Move True to bExists
107899>>>            End
107899>>>>
107899>>>        End
107899>>>>
107899>>>
107899>>>        If (bExists = True) Begin
107901>>>            Get OpenKey of hoReg sStudioPath to bOk
107902>>>            If (bOk = True) Begin
107904>>>                Get Create (RefClass(Array)) to hoArray
107905>>>                Get GetSubkeys of hoReg hoArray to iItems
107906>>>                Decrement iItems
107907>>>                Move False to bExists
107908>>>                Set pfAccessRights of hoReg to KEY_READ
107909>>>                // Check if the key already exists:
107909>>>                For i from 0 to iItems
107915>>>>
107915>>>                    Get Value of hoArray i to sKey
107916>>>                    Move (sStudioPath + "\" + sKey) to sKey
107917>>>                    Get OpenKey of hoReg sKey to bOpen
107918>>>                    If (bOpen = True) Begin
107920>>>                        Get ReadString of hoReg CS_Name to sValue
107921>>>                        If (sValue = sProduct) Begin
107923>>>                            Move True to bExists
107924>>>                        End
107924>>>>
107924>>>                    End
107924>>>>
107924>>>                Loop
107925>>>>
107925>>>                Send Destroy of hoArray
107926>>>                If (bExists = False) Begin
107928>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
107929>>>                    // We need to create the next key number:
107929>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
107929>>>                    Increment iItems
107930>>>                    Increment iItems
107931>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
107932>>>                    If (iCreated = 0) Begin
107934>>>                        Send WriteString of hoReg CS_Name sProduct
107935>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
107935>>>                        If (sStudioVersion >= "16.0") Begin
107937>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
107938>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
107939>>>                        End
107939>>>>
107939>>>                        Else Begin
107940>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
107941>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
107942>>>                        End
107942>>>>
107942>>>                        Send WriteDword  of hoReg CS_Separator 1
107943>>>                        Move cx_RegKeyCreated to iRetval
107944>>>                    End
107944>>>>
107944>>>                    Else Begin
107945>>>                        Move cx_RegkeyFailed to iRetval
107946>>>                    End
107946>>>>
107946>>>                End
107946>>>>
107946>>>                Else Begin
107947>>>                    Move cx_RegKeyAlreadyExist to iRetval
107948>>>                End
107948>>>>
107948>>>                Send CloseKey of hoReg
107949>>>            End
107949>>>>
107949>>>        End
107949>>>>
107949>>>
107949>>>        Send Destroy of hoReg
107950>>>        Function_Return iRetval
107951>>>    End_Function
107952>>>
107952>>>    Procedure Page Integer iPageObject
107955>>>        Forward Send Page iPageObject
107957>>>        Set Icon to "ActionAddStudio1.ico"
107958>>>    End_Procedure
107959>>>
107959>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
107960>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
107961>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
107962>>>End_Object
107963>        Use CreateDatabase.dg
107963>
107963>        Procedure Activate_About
107966>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
107967>        End_Procedure
107968>
107968>    End_Object
107969>
107969>    Procedure ShowProgramHelp
107972>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
107973>    End_Procedure
107974>
107974>    On_Key Key_F1 Send ShowProgramHelp
107975>End_Object
107976>
107976>// Check if a SQLConnections.ini file exists;
107976>// else the user needs to setup a Connection ID and login info & save the new connection file.
107976>Procedure CheckIfConnectionExists
107978>    Boolean bIniFileExists
107978>    Get pbIniFileExists of ghoApplication to bIniFileExists
107979>    If (bIniFileExists = False) Begin
107981>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
107982>    End
107982>End_Procedure
107983>Send CheckIfConnectionExists
107984>
107984>Start_UI
107985>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 55483
Total Resources: 6
Total Commands : 107984
Total Windows  : 0
Total Pages    : 0
Static Data    : 882221
Message area   : 641262
Total Blocks   : 38176
